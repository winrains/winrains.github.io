<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java 8 习惯用语（10）：使用闭包捕获状态</title>
    <url>/2019/12/26/Java-8-%E4%B9%A0%E6%83%AF%E7%94%A8%E8%AF%AD%EF%BC%8810%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E6%8D%95%E8%8E%B7%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<p>在 Java™ 编程中，我们以不严格地使用术语 <em>lambda 表达式</em>来表示 lambda 表达式和闭包。但在某些情况下，理解它们的区别很重要。lambda 表达式是无状态的，而闭包是带有状态的。将 lambda 表达式替换为闭包，是一种管理函数式程序中的状态的好方法。</p>
<a id="more"></a>

<h2 id="无状态的生活"><a href="#无状态的生活" class="headerlink" title="无状态的生活"></a>无状态的生活</h2><p>我们在本系列中大量介绍了 lambda 表达式，您应该已经对它们有非常透彻的了解。它们是小巧的匿名函数，接受可选的参数，执行某种计算或操作，而且可能返回一个结果。lambda 表达式也是无状态的，这可能会在您的代码中产生重大影响。<br>我们首先看一个使用 lambda 表达式的简单示例。假设我们想将一个数字集合中的偶数乘以二。一种选择是使用 <code>Stream</code> 和 lambda 表达式创建一个函数管道，如下所示：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">numbers.stream<span class="params">()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">.filter</span><span class="params">(e -&gt; e % <span class="attr">2</span> == 0)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">.map</span><span class="params">(e -&gt; e * 2)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">.collect</span><span class="params">(toList()</span>);</span></pre></td></tr></table></figure>

<p>我们传入 <code>filter</code> 中的 lambda 表达式取代了 <code>Predicate</code> 函数接口。它接受一个数字，如果该数字是偶数，则返回 <code>true</code>，否则返回 <code>false</code>。另一方面，我们传递给 <code>map</code> 的 lambda 表达式取代了 <code>Function</code> 函数接口：它接受任何数字并返回该值的两倍。<br>这两个 lambda 表达式都依赖于传入的参数和字面常量。二者都是独立的，这意味着它们没有任何外部依赖项。因为它们依赖于传入的参数，而且可能还依赖于一些常量，所以 lambda 表达式是无状态的。它们很可爱，也很安静，就像熟睡的婴儿一样。</p>
<h2 id="我们为什么需要状态"><a href="#我们为什么需要状态" class="headerlink" title="我们为什么需要状态"></a>我们为什么需要状态</h2><p>现在让我们更仔细地看看传递给 <code>map</code> 方法的 lambda 表达式。如果我们希望计算给定值的三倍或四倍，该怎么办？我们可以将常量 <code>2</code> 转换为一个变量（比如 <code>factor</code>），但 lambda 表达式仍需要一种方式来获取该变量。<br>我们可以推断，lambda 表达式可以采用与接收参数 <code>e</code> 的相同方式来接收 <code>factor</code>，如下所示：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">.<span class="keyword">map</span><span class="function"><span class="params">((e, factor) -&gt; e * factor)</span></span></span></pre></td></tr></table></figure>

<p>还不错，但不幸的是它不起作用。方法 <code>map</code> 要求接受函数接口 <code>Function</code> 的一个实现作为参数。如果我们传入该接口外的任何内容（比如一个 <code>BiFunction</code>），<code>map</code> 不会接受。需要采用另一种方式将 <code>factor</code> 提供给我们的 lambda 表达式。</p>
<h2 id="词法范围"><a href="#词法范围" class="headerlink" title="词法范围"></a>词法范围</h2><p>函数要求变量在限定范围内。因为它们实际上是匿名函数，所以 lambda 表达式也要求引用的变量在限定范围内。一些变量以参数形式被函数或 lambda 表达式接收。一些变量是局部定义的。一些变量来自函数外部，位于所谓的<em>词法范围</em>中。<br>下面是一个词法范围示例。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">String</span> location = <span class="string">"World"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"Hello "</span> + location);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    runnable.<span class="built_in">run</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在 <code>print</code> 方法中，<code>location</code> 是一个局部变量。但是，<code>Runnable</code> 的 <code>run</code> 方法还引用了一个不是 <code>run</code> 方法的局部变量或参数的 <code>location</code>。对 <code>Hello</code> 旁边的 <code>location</code> 的引用被绑定到 <code>print</code> 方法的 <code>location</code> 变量。<br><em>词法范围</em>是函数的定义范围。反过来，它也可能是该定义范围的定义范围，等等。<br>在前面的代码中，方法 <code>run</code> 没有定义 <code>location</code> 或接收它作为参数。<code>run</code> 的定义范围是 <code>Runnable</code> 的匿名内部对象。因为没有将 <code>location</code> 定义为该实例中的字段，所以会继续搜索匿名内部对象的定义范围 — 在本例中为方法 <code>print</code> 的局部范围。<br>如果 <code>location</code> 不在该范围中，编译器会继续在 <code>print</code> 的定义范围内搜索，直到找到该变量或搜索失败。</p>
<h3 id="lambda-表达式中的词法范围"><a href="#lambda-表达式中的词法范围" class="headerlink" title="lambda 表达式中的词法范围"></a>lambda 表达式中的词法范围</h3><p>现在让我们看看，使用 lambda 表达式重写前面的代码后会发生什么：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">String</span> location = <span class="string">"World"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Runnable runnable = () -&gt; System.out.<span class="built_in">println</span>(<span class="string">"Hello "</span> + location);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    runnable.<span class="built_in">run</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>得益于 lambda 表达式，代码变得更简洁，但 <code>location</code> 的范围和绑定没有更改。lambda 表达式中的变量 <code>location</code> 被绑定到 lambda 表达式的词法范围中的变量 <code>location</code>。严格来讲，此代码中的 lambda 表达式是一个<em>闭包</em>。</p>
<h2 id="闭包如何携带状态"><a href="#闭包如何携带状态" class="headerlink" title="闭包如何携带状态"></a>闭包如何携带状态</h2><p>Lambda 表达式不依赖于任何外部实体；它们是依赖于自身参数和常量的内容。另一方面，闭包既依赖于参数和常量，也依赖于它们的词法范围中的变量。<br>从逻辑上讲，闭包被绑定到它们的词法范围中的变量。但是，尽管逻辑上讲是这样，但实际上并不总是这么做。有时甚至无法执行这样的绑定。<br>两个场景可以证明这一点。<br>首先，下面这段代码将一个 lambda 表达式或闭包传递给一个 <code>call</code> 方法：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Runnable runnable)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"calling runnable"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//level 2 of stack</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        runnable.<span class="built_in">run</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> value = <span class="number">4</span>;  <span class="comment">//level 1 of stack</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        call(</span></pre></td></tr><tr><td class="code"><pre><span class="line">           () -&gt; System.out.<span class="built_in">println</span>(value) <span class="comment">//level 3 of stack</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>此代码中的闭包使用了来自它的词法范围的变量 <code>value</code>。如果 <code>main</code> 是在堆栈级别 1 上执行的，那么 <code>call</code> 方法的主体会在堆栈级别 2 上执行。因为 <code>Runnable</code> 的 <code>run</code> 方法是从 <code>call</code> 内调用的，所以该闭包的主体会在级别 3 上运行。如果 <code>call</code> 方法要将该闭包传递给另一个方法（进而推迟调用的位置），则执行的堆栈级别可能高于 3。<br>您现在可能想知道在一个堆栈级别中的执行究竟如何能获取之前的另一个堆栈级别中的变量 — 尤其是未在调用中传递上下文时。简单来讲就是无法获取该变量。<br>现在考虑另一个示例：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runnable <span class="title">create</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> value = <span class="number">4</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Runnable runnable = () -&gt; System.out.<span class="built_in">println</span>(value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"exiting create"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> runnable;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Runnable runnable = create();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"In main"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        runnable.<span class="built_in">run</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在这个示例中，<code>create</code> 方法有一个局部变量 <code>value</code>，该变量的寿命很短：只要我们退出 <code>create</code>，它就会消失。<code>create</code> 内创建的闭包在其词法范围中引用了这个变量。在完成 <code>create</code> 方法后，该方法将闭包返回给 <code>main</code> 中的调用方。在此过程中，它从自己的堆栈中删除变量 <code>value</code>，而且 lambda 表达式将会执行。这是结果输出：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">exiting</span> <span class="string">create</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">In</span> <span class="string">main</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">4</span></span></pre></td></tr></table></figure>

<p>我们知道，在 <code>main</code> 中调用 <code>run</code> 时，<code>create</code> 中的 <code>value</code> 就会终止。尽管我们可以假设 lambda 表达式中的 <code>value</code> 直接被绑定到它的词法范围中的变量，但该假设并不成立。<br>可通过一个类比来揭示其中原委。</p>
<h3 id="闭包午休时间"><a href="#闭包午休时间" class="headerlink" title="闭包午休时间"></a>闭包午休时间</h3><p>假设我的办公室离家约 10 英里（使用改进的测量单位的话为 16 公里），而且我早上 8 点出门上班。中午，我有短暂的时间用午餐，但出于健康考虑，我喜欢吃家里烹饪的饭菜。由于休息时间很短，只有在离家时带上午餐，我才能吃上家里的饭菜。<br>这就是闭包要完成的任务：它们携带自己的午餐（或状态）。<br>为了讲得更清楚一些，让我们再看看 <code>create</code> 中的 lambda 表达式：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">Runnable runnable = <span class="function"><span class="params">()</span> -&gt;</span> System.out.println(value);</span></pre></td></tr></table></figure>

<p>我们编写的 lambda 表达式没有接受任何参数，但需要它的 <code>value</code>。编译类 <code>Sample</code> 并运行 <code>javap -c -p Sample.class</code> 来检查字节码。您会注意到，编译器为该闭包创建了一个方法，该方法接受一个 <code>int</code> 参数：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="built_in">void</span> lambda$create$<span class="number">0</span>(<span class="built_in">int</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Code:</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">3</span>  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">3</span>: iload_0</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">4</span>: invokevirtual #<span class="number">9</span> <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">7</span>: <span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>现在看看为 <code>create</code> 方法生成的字节码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: iconst_4</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span>: istore_0</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span>: iload_0</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3</span>: invokedynamic #<span class="number">2</span>,  <span class="number">0</span>  <span class="comment">// InvokeDynamic #0:run:(I)Ljava/lang/Runnable;</span></span></pre></td></tr></table></figure>

<p>值 <code>4</code> 存储在一个变量中，然后，该变量被加载并传递到为闭包创建的函数。在本例中，闭包保留着 <code>value</code> 的一个副本。<br>这就是闭包携带状态的方式。</p>
<h2 id="使用闭包"><a href="#使用闭包" class="headerlink" title="使用闭包"></a>使用闭包</h2><p>现在，我们回头看看本文开头的示例。除了计算集合中的偶数值的两倍，如果我们想要计算它们的三倍或四倍，该怎么办？为此，我们可以将原始 lambda 表达式转换为一个闭包。<br>这是我们之前看到的无状态代码：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">numbers.stream<span class="params">()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">.filter</span><span class="params">(e -&gt; e % <span class="attr">2</span> == 0)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">.map</span><span class="params">(e -&gt; e * 2)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">.collect</span><span class="params">(toList()</span>);</span></pre></td></tr></table></figure>

<p>使用闭包而不是 lambda 表达式，代码就会变成：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> factor = <span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">numbers.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(e -&gt; e % <span class="number">2</span> == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .map(e -&gt; e * factor)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .collect(toList());</span></pre></td></tr></table></figure>

<p><code>map</code> 方法现在接受一个闭包，而不是一个 lambda 表达式。我们知道，这个闭包接受一个参数 <code>e</code>，但它也捕获并携带 <code>factor</code> 变量的状态。<br>此变量位于该闭包的<em>词法范围</em>中。它可以是定义 lambda 表达式的函数中的局部变量；可以作为该外部函数的一个参数传入；可以位于闭包的定义范围（或该定义范围的定义范围等）中的任何地方。无论如何，该闭包将状态从定义该闭包的代码传递到了需要该变量的执行点。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>闭包不同于 lambda 表达式，因为它们依赖于自己的词法范围来获取一些变量。因此，闭包可以捕获并携带状态。lambda 表达式是无状态的，闭包是有状态的。可以在您的程序中使用闭包，将状态从定义上下文携带到执行点。</p>
<blockquote>
<p>作者：Venkat Subramaniam</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms10/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms10/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 习惯用语（9）：级联 lambda 表达式</title>
    <url>/2019/12/26/Java-8-%E4%B9%A0%E6%83%AF%E7%94%A8%E8%AF%AD%EF%BC%889%EF%BC%89%EF%BC%9A%E7%BA%A7%E8%81%94-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>在函数式编程中，函数既可以接收也可以返回其他函数。函数不再像传统的面向对象编程中一样，只是一个对象的<em>工厂</em>或<em>生成器</em>，它也能够创建和返回另一个函数。返回函数的函数可以变成<em>级联 lambda 表达式</em>，特别值得注意的是代码非常简短。尽管此语法初看起来可能非常陌生，但它有自己的用途。本文将帮助您认识级联 lambda 表达式，理解它们的性质和在代码中的用途。</p>
<a id="more"></a>

<h2 id="神秘的语法"><a href="#神秘的语法" class="headerlink" title="神秘的语法"></a>神秘的语法</h2><p>您是否看到过类似这样的代码段？</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="symbol">x</span> -&gt; <span class="symbol">y</span> -&gt; <span class="symbol">x</span> &gt; <span class="symbol">y</span></span></pre></td></tr></table></figure>

<p>如果您很好奇“这到底是什么意思？”，那么您并不孤单。对于不熟悉使用 lambda 表达式编程的开发人员，此语法可能看起来像货物正从快速行驶的卡车上一件件掉下来一样。<br>幸运的是，我们不会经常看到它们，但理解如何创建级联 lambda 表达式和如何在代码中理解它们会大大减少您的受挫感。</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>在谈论级联 lambda 表达式之前，有必要首先理解如何创建它们。对此，我们需要回顾一下高阶函数（已在<a href="https://www.ibm.com/developerworks/library/j-java8idioms1/index.html" target="_blank" rel="noopener">本系列第 1 篇文章</a>中介绍）和它们在<em>函数分解</em>中的作用，函数分解是一种将复杂流程分解为更小、更简单的部分的方式。<br>首先，考虑区分高阶函数与常规函数的规则：<br>常规函数</p>
<ul>
<li>可以接收对象</li>
<li>可以创建对象</li>
<li>可以返回对象</li>
</ul>
<p>高阶函数</p>
<ul>
<li>可以接收函数</li>
<li>可以创建函数</li>
<li>可以返回函数</li>
</ul>
<p>开发人员将匿名函数或 lambda 表达式传递给高阶函数，以让代码简短且富于表达。让我们看看这些高阶函数的两个示例。</p>
<h3 id="示例-1：一个接收函数的函数"><a href="#示例-1：一个接收函数的函数" class="headerlink" title="示例 1：一个接收函数的函数"></a>示例 1：一个接收函数的函数</h3><p>在 Java™ 中，我们使用函数接口来引用 lambda 表达式和方法引用。下面这个函数接收一个对象和一个函数：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> static <span class="type">int</span> totalSelectedValues(List&lt;<span class="type">Integer</span>&gt; <span class="keyword">values</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Predicate&lt;<span class="type">Integer</span>&gt; selector) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">values</span>.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .<span class="keyword">filter</span>(selector)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .reduce(<span class="number">0</span>, <span class="type">Integer</span>::sum);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>totalSelectedValues</code> 的第一个参数是集合对象，而第二个参数是 <code>Predicate</code> 函数接口。 因为参数类型是函数接口 (<code>Predicate</code>)，所以我们现在可以将一个 lambda 表达式作为第二个参数传递给 <code>totalSelectedValues</code>。例如，如果我们想仅对一个 <code>numbers</code> 列表中的<em>偶数值</em>求和，可以调用 <code>totalSelectedValues</code>，如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">total<span class="constructor">SelectedValues(<span class="params">numbers</span>, <span class="params">e</span> -&gt; <span class="params">e</span> % 2 <span class="operator">==</span> 0)</span>;</span></pre></td></tr></table></figure>

<p>假设我们现在在 <code>Util</code> 类中有一个名为 <code>isEven</code> 的 <code>static</code> 方法。在此情况下，我们可以使用 <code>isEven</code> 作为 <code>totalSelectedValues</code> 的参数，而不传递 lambda 表达式：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">totalSelectedValues(<span class="name">numbers</span>, Util:<span class="symbol">:isEven</span>)<span class="comment">;</span></span></pre></td></tr></table></figure>

<p>作为规则，只要一个函数接口显示为一个函数的参数的<em>类型</em>，您看到的就是一个高阶函数。</p>
<h3 id="示例-2：一个返回函数的函数"><a href="#示例-2：一个返回函数的函数" class="headerlink" title="示例 2：一个返回函数的函数"></a>示例 2：一个返回函数的函数</h3><p>函数可以接收函数、lambda 表达式或方法引用作为参数。同样地，函数也可以返回 lambda 表达式或方法引用。在此情况下，返回类型将是函数接口。<br>让我们首先看一个创建并返回 <code>Predicate</code> 来验证给定值是否为奇数的函数：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">public<span class="keyword"> static</span> Predicate&lt;Integer&gt; createIsOdd() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Predicate&lt;Integer&gt;<span class="built_in"> check </span>= (Integer number) -&gt; number % 2 != 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="built_in"> return </span>check;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>为了返回一个函数，我们必须提供一个函数接口作为返回类型。在本例中，我们的函数接口是 <code>Predicate</code>。尽管上述代码在语法上是正确的，但它可以更加简短。 我们使用类型引用并删除临时变量来改进该代码：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> static Predicate&lt;<span class="keyword">Integer</span>&gt; createIsOdd() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">number</span> -&gt; <span class="keyword">number</span> % <span class="number">2</span> <span class="comment">!= 0;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这是使用的 <code>createIsOdd</code> 方法的一个示例：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Predicate&lt;Integer&gt; isOdd = createIsOdd()<span class="comment">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">isOdd.test(<span class="number">4</span>)<span class="comment">;</span></span></pre></td></tr></table></figure>

<p>请注意，在 <code>isOdd</code> 上调用 <code>test</code> 会返回 <code>false</code>。我们也可以在 <code>isOdd</code> 上使用更多值来调用 <code>test</code>；它并不限于使用一次。</p>
<h2 id="创建可重用的函数"><a href="#创建可重用的函数" class="headerlink" title="创建可重用的函数"></a>创建可重用的函数</h2><p>现在您已大体了解高阶函数和如何在代码中找到它们，我们可以考虑使用它们来让代码更加简短。<br>设想我们有两个列表 <code>numbers1</code> 和 <code>numbers2</code>。假设我们想从第一个列表中仅提取大于 50 的数，然后从第二个列表中提取大于 50 的值并<em>乘以 2</em>。<br>可通过以下代码实现这些目的：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; result1 = numbers1.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="function"><span class="title">filter</span>(e -&gt;</span> e &gt; <span class="number">50</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .collect(toList());</span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; result2 = numbers2.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="function"><span class="title">filter</span>(e -&gt;</span> e &gt; <span class="number">50</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="function"><span class="title">map</span>(e -&gt;</span> e * <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .collect(toList());</span></pre></td></tr></table></figure>

<p>此代码很好，但您注意到它很冗长了吗？我们对检查数字是否大于 50 的 lambda 表达式使用了两次。 我们可以通过创建并重用一个 <code>Predicate</code>，从而删除重复代码，让代码更富于表达：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">Predicate&lt;<span class="built_in">Integer</span>&gt; isGreaterThan50 = number -&gt; number &gt; <span class="number">50</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; result1 = numbers1.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(isGreaterThan50)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .collect(toList());</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; result2 = numbers2.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(isGreaterThan50)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="built_in">map</span>(e -&gt; e * <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .collect(toList());</span></pre></td></tr></table></figure>

<p>通过将 lambda 表达式存储在一个引用中，我们可以重用它，这是我们避免重复 lambda 表达式的方式。如果我们想跨方法重用 lambda 表达式，也可以将该引用放入一个单独的方法中，而不是放在一个局部变量引用中。<br>现在假设我们想从列表 <code>numbers1</code> 中提取大于 25、50 和 75 的值。我们可以首先编写 3 个不同的 lambda 表达式：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; valuesOver25 = numbers1.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(e -&gt; e &gt; <span class="number">25</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="keyword">collect</span>(<span class="keyword">toList</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; valuesOver50 = numbers1.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(e -&gt; e &gt; <span class="number">50</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="keyword">collect</span>(<span class="keyword">toList</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; valuesOver75 = numbers1.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(e -&gt; e &gt; <span class="number">75</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="keyword">collect</span>(<span class="keyword">toList</span>());</span></pre></td></tr></table></figure>

<p>尽管上面每个 lambda 表达式将输入与一个不同的值比较，但它们做的事情完全相同。如何以较少的重复来重写此代码？</p>
<h2 id="创建和重用-lambda-表达式"><a href="#创建和重用-lambda-表达式" class="headerlink" title="创建和重用 lambda 表达式"></a>创建和重用 lambda 表达式</h2><p>尽管上一个示例中的两个 lambda 表达式相同，但上面 3 个表达式稍微不同。创建一个返回 <code>Predicate</code> 的 <code>Function</code> 可以解决此问题。<br>首先，函数接口 <code>Function</code> 将一个 <code>T</code> 类型的输入转换为 <code>U</code> 类型的输出。例如，下面的示例将一个给定值转换为它的平方根：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Function</span></span>&lt;<span class="keyword">Integer</span>, <span class="keyword">Double</span>&gt; <span class="built_in">sqrt</span> = <span class="keyword">value</span> -&gt; Math.<span class="built_in">sqrt</span>(<span class="keyword">value</span>);</span></pre></td></tr></table></figure>

<p>在这里，返回类型 <code>U</code> 可以很简单，比如 <code>Double</code>、<code>String</code> 或 <code>Person</code>。或者它也可以更复杂，比如 <code>Consumer</code> 或 <code>Predicate</code> 等另一个函数接口。<br>在本例中，我们希望一个 <code>Function</code> 创建一个 <code>Predicate</code>。所以代码如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Function</span></span>&lt;<span class="keyword">Integer</span>, Predicate&lt;<span class="keyword">Integer</span>&gt;&gt; isGreaterThan = (<span class="keyword">Integer</span> pivot) -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Predicate&lt;<span class="keyword">Integer</span>&gt; isGreaterThanPivot = (<span class="keyword">Integer</span> candidate) -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> candidate &gt; pivot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> isGreaterThanPivot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>引用 <code>isGreaterThan</code> 引用了一个表示 <code>Function</code>— 或更准确地讲表示 <code>Function&gt;</code> 的 lambda 表达式。输入是一个 <code>Integer</code>，输出是一个 <code>Predicate</code>。<br>在 lambda 表达式的主体中（外部 <code>{}</code> 内），我们创建了另一个引用 <code>isGreaterThanPivot</code>，它包含对另一个 lambda 表达式的引用。这一次，该引用是一个 <code>Predicate</code> 而不是 <code>Function</code>。最后，我们返回该引用。<br><code>isGreaterThan</code> 是一个 lambda 表达式的引用，该表达式在调用时返回<em>另一个</em> lambda 表达式 — 换言之，这里隐藏着一种 lambda 表达式级联关系。<br>现在，我们可以使用新创建的外部 lamba 表达式来解决代码中的重复问题：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; valuesOver25 = numbers1.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(isGreaterThan.apply(<span class="number">25</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="keyword">collect</span>(<span class="keyword">toList</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; valuesOver50 = numbers1.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(isGreaterThan.apply(<span class="number">50</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="keyword">collect</span>(<span class="keyword">toList</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; valuesOver75 = numbers1.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(isGreaterThan.apply(<span class="number">75</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="keyword">collect</span>(<span class="keyword">toList</span>());</span></pre></td></tr></table></figure>

<p>在 <code>isGreaterThan</code> 上调用 <code>apply</code> 会返回一个 <code>Predicate</code>，后者然后作为参数传递给 <code>filter</code> 方法。<br>尽管整个过程非常简单（作为示例），但是能够抽象为一个函数对于谓词更加复杂的场景来说尤其有用。</p>
<h2 id="保持简短的秘诀"><a href="#保持简短的秘诀" class="headerlink" title="保持简短的秘诀"></a>保持简短的秘诀</h2><p>我们已从代码中成功删除了重复的 lambda 表达式，但 <code>isGreaterThan</code> 的定义看起来仍然很杂乱。幸运的是，我们可以组合一些 Java 8 约定来减少杂乱，让代码更简短。<br>我们首先重构以下代码：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Function</span></span>&lt;<span class="keyword">Integer</span>, Predicate&lt;<span class="keyword">Integer</span>&gt;&gt; isGreaterThan = (<span class="keyword">Integer</span> pivot) -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Predicate&lt;<span class="keyword">Integer</span>&gt; isGreaterThanPivot = (<span class="keyword">Integer</span> candidate) -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> candidate &gt; pivot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> isGreaterThanPivot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>可以使用类型引用来从外部和内部 lambda 表达式的参数中删除类型细节：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer, Predicate&lt;Integer&gt;&gt; isGreaterThan = <span class="function"><span class="params">(pivot)</span> -&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Predicate&lt;Integer&gt; isGreaterThanPivot = <span class="function"><span class="params">(candidate)</span> -&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> candidate &gt; pivot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> isGreaterThanPivot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>目前，我们从代码中删除了两个单词，改进不大。<br>接下来，我们删除多余的 <code>()</code>，以及外部 lambda 表达式中不必要的临时引用：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Function</span></span>&lt;<span class="keyword">Integer</span>, Predicate&lt;<span class="keyword">Integer</span>&gt;&gt; isGreaterThan = pivot -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> candidate -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> candidate &gt; pivot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>代码更加简短了，但是仍然看起来有些杂乱。<br>可以看到内部 lambda 表达式的主体只有一行，显然 <code>{}</code> 和 <code>return</code> 是多余的。让我们删除它们：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Function</span></span>&lt;<span class="keyword">Integer</span>, Predicate&lt;<span class="keyword">Integer</span>&gt;&gt; isGreaterThan = pivot -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> candidate -&gt; candidate &gt; pivot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>现在可以看到，外部 lambda 表达式的主体<em>也</em>只有一行，所以 <code>{}</code> 和 <code>return</code> 在这里也是多余的。在这里，我们应用最后一次重构：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Function</span></span>&lt;<span class="keyword">Integer</span>, Predicate&lt;<span class="keyword">Integer</span>&gt;&gt; isGreaterThan =</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pivot -&gt; candidate -&gt; candidate &gt; pivot;</span></pre></td></tr></table></figure>

<p>现在可以看到 — 这是我们的级联 lambda 表达式。</p>
<h2 id="理解级联-lambda-表达式"><a href="#理解级联-lambda-表达式" class="headerlink" title="理解级联 lambda 表达式"></a>理解级联 lambda 表达式</h2><p>我们通过一个适合每个阶段的重构过程，得到了最终的代码 - 级联 lambda 表达式。在本例中，外部 lambda 表达式接收 <code>pivot</code> 作为参数，内部 lambda 表达式接收 <code>candidate</code> 作为参数。内部 lambda 表达式的主体同时使用它收到的参数 (<code>candidate</code>) 和来自外部范围的参数。也就是说，内部 lambda 表达式的主体同时依靠它的参数和它的<em>词法范围</em>或<em>定义范围</em>。<br>级联 lambda 表达式对于编写它的人非常有意义。但是对于读者呢？<br>看到一个只有一个向右箭头 (<code>-&gt;</code>) 的 lambda 表达式时，您应该知道您看到的是一个匿名函数，它接受参数（可能是空的）并执行一个操作或返回一个结果值。<br>看到一个包含两个向右箭头 (<code>-&gt;</code>) 的 lambda 表达式时，您看到的也是一个匿名函数，但它接受参数（可能是空的）并返回另一个 lambda 表达式。返回的 lambda 表达式可以接受它自己的参数或者可能是空的。它可以执行一个操作或返回一个值。它甚至可以返回另一个 lambda 表达式，但这通常有点大材小用，最好避免。<br>大体上讲，当您看到两个向右箭头时，可以将第一个箭头右侧的所有内容视为一个黑盒：一个由外部 lambda 表达式返回的 lambda 表达式。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>级联 lambda 表达式不是很常见，但您应该知道如何在代码中识别和理解它们。当一个 lambda 表达式返回另一个 lambda 表达式，而不是接受一个操作或返回一个值时，您将看到两个箭头。这种代码非常简短，但可能在最初遇到时非常难以理解。但是，一旦您学会识别这种函数式语法，理解和掌握它就会变得容易得多。</p>
<blockquote>
<p>作者：Venkat Subramaniam</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms9/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms9/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 习惯用语（8）：类型推断</title>
    <url>/2019/12/26/Java-8-%E4%B9%A0%E6%83%AF%E7%94%A8%E8%AF%AD%EF%BC%888%EF%BC%89%EF%BC%9A%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD/</url>
    <content><![CDATA[<p>Java™8 是第一个支持类型推断的 Java 版本，而且它仅对 lambda 表达式支持此功能。在 lambda 表达式中使用类型推断具有强大的作用，它将帮助您做好准备以应对未来的 Java 版本，在今后的版本中还会将类型推断用于变量等更多可能。这里的诀窍在于恰当地命名参数，相信 Java 编译器会推断出剩余的信息。<br>大多数时候，编译器完全能够推断类型。在它无法推断出来的时候，就会报错。<br>了解 lambda 表达式中的类型推断的工作原理，至少查看一个无法推断类型的示例。即使如此，也有解决办法。</p>
<a id="more"></a>

<h2 id="显式类型和冗余"><a href="#显式类型和冗余" class="headerlink" title="显式类型和冗余"></a>显式类型和冗余</h2><p>假设您询问某个人“您叫什么名字？”，他会回答“我名叫约翰”。这种情况经常发生，但简单地说“约翰”会更高效。您需要的只是一个名称，所以该句子的剩余部分都是多余的。<br>不幸的是，我们总是在代码中做这类多余的事情。Java 开发人员可以使用 <code>forEach</code> 迭代并输出某个范围内的每个值的双倍值，如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">IntStream</span>.</span></span>range<span class="constructor">Closed(1, 5)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  .for<span class="constructor">Each((<span class="params">int</span> <span class="params">number</span>)</span> -&gt; <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(number<span class="operator"> * </span><span class="number">2</span>));</span></pre></td></tr></table></figure>

<p><code>rangeClosed</code> 方法生成一个从 1 到 5 的 <code>int</code> 值流。lambda 表达式的唯一职责就是接收一个名为 <code>number</code> 的 <code>int</code> 参数，使用 <code>PrintStream</code> 的 <code>println</code> 方法输出该值的双倍值。从语法上讲，该 lambda 表达式没有错，但类型细节有些冗余。</p>
<h2 id="Java-8-中的类型推断"><a href="#Java-8-中的类型推断" class="headerlink" title="Java 8 中的类型推断"></a>Java 8 中的类型推断</h2><p>当您从某个数字范围中提取一个值时，编译器知道该值的类型为 <code>int</code>。不需要在代码中显式声明该值，尽管这是目前为止的约定。<br>在 Java 8 中，我们可以丢弃 lambda 表达式中的类型，如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">IntStream</span>.</span></span>range<span class="constructor">Closed(1, 5)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  .for<span class="constructor">Each((<span class="params">number</span>)</span> -&gt; <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(number<span class="operator"> * </span><span class="number">2</span>));</span></pre></td></tr></table></figure>

<p>由于 Java 是静态类型语言，它需要在编译时知道所有对象和变量的类型。在 lambda 表达式的参数列表中省略类型并不会让 Java 更接近动态类型语言。但是，添加适当的类型推断功能会让 Java 更接近其他静态类型语言，比如 Scala 或 Haskell。</p>
<h2 id="信任编译器"><a href="#信任编译器" class="headerlink" title="信任编译器"></a>信任编译器</h2><p>如果您在 lambda 表达式的一个参数中省略类型，Java 需要通过上下文细节来推断该类型。<br>返回到上一个示例，当我们在 <code>IntStream</code> 上调用 <code>forEach</code> 时，编译器会查找该方法来确定它采用的参数。<code>IntStream</code> 的 <code>forEach</code> 方法期望使用函数接口 <code>IntConsumer</code>，该接口的抽象方法 <code>accept</code> 采用了一个 <code>int</code> 类型的参数并返回 <code>void</code>。<br>如果在参数列表中指定了该类型，编译器将会确认该类型符合预期。<br>如果省略该类型，编译器会推断出预期的类型 —在本例中为 <code>int</code>。<br>无论是您提供类型还是编译器推断出该类型，Java 都会在编译时知道 lambda 表达式参数的类型。要测试这种情况，可以在 lambda 表达式中引入一个错误，同时省略参数的类型：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">IntStream</span>.</span></span>range<span class="constructor">Closed(1, 5)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  .for<span class="constructor">Each((<span class="params">number</span>)</span> -&gt; <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(number.length<span class="literal">()</span><span class="operator"> * </span><span class="number">2</span>));</span></pre></td></tr></table></figure>

<p>编译此代码时，Java 编译器会返回以下错误：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Sample</span>.</span></span>java:<span class="number">7</span>: error: <span class="built_in">int</span> cannot be dereferenced</span></pre></td></tr><tr><td class="code"><pre><span class="line">      .for<span class="constructor">Each((<span class="params">number</span>)</span> -&gt; <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(number.length<span class="literal">()</span><span class="operator"> * </span><span class="number">2</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                    ^</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span> error</span></pre></td></tr></table></figure>

<p>编译器知道名为 <code>number</code> 的参数的类型。它报错是因为它无法使用点运算符解除对某个 <code>int</code> 类型的变量的引用。可以对对象执行此操作，但不能对 <code>int</code> 变量这么做。</p>
<h2 id="类型推断的好处"><a href="#类型推断的好处" class="headerlink" title="类型推断的好处"></a>类型推断的好处</h2><p>在 lambda 表达式中省略类型有两个主要好处：</p>
<ul>
<li>键入的内容更少。无需输入类型信息，因为编译器自己能轻松确定该类型。</li>
<li>代码杂质更少 —<code>(number)</code> 比 <code>(int number)</code> 简单得多。</li>
</ul>
<p>此外，一般来讲，如果我们仅有一个参数，省略类型意味着也可以省略 <code>()</code>，如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">IntStream</span>.</span></span>range<span class="constructor">Closed(1, 5)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  .for<span class="constructor">Each(<span class="params">number</span> -&gt; System.<span class="params">out</span>.<span class="params">println</span>(<span class="params">number</span> <span class="operator">*</span> 2)</span>);</span></pre></td></tr></table></figure>

<p>请注意，您<em>将</em>需要为采用多个参数的 lambda 表达式添加括号。</p>
<h2 id="类型推断和可读性"><a href="#类型推断和可读性" class="headerlink" title="类型推断和可读性"></a>类型推断和可读性</h2><p>lambda 表达式中的类型推断违背了 Java 中的常规做法，在常规做法中，会指定每个变量和参数的类型。尽管一些开发人员辩称 Java 指定类型的约定让代码变得更可读、更容易理解，但我认为这种偏好反映出一种习惯而不是必要性。<br>以一个包含一系列转换的函数管道为例：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; result =</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cars.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="keyword">map</span><span class="function"><span class="params">((Car c) -&gt; c.getRegistration())</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    .<span class="title">map</span><span class="params">((String s) -&gt; DMVRecords.getOwner(s))</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    .<span class="title">map</span><span class="params">((Person o) -&gt; o.getName())</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    .<span class="title">map</span><span class="params">((String s) -&gt; s.toUpperCase())</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    .<span class="title">collect</span><span class="params">(toList())</span>;</span></span></pre></td></tr></table></figure>

<p>在这里，我们首先提供了一组 <code>Car</code> 实例和相关的注册信息。我们获取每辆车的车主和车主姓名，并将该姓名转换为大写。最后，将结果放入一个列表中。<br>这段代码中的每个 lambda 表达式都为其参数指定了一个类型，但我们为参数使用了单字母变量名。这在 Java 中很常见。但这种做法不合适，因为它丢弃了特定于域的上下文。<br>我们可以做得比这更好。让我们看看使用更强大的参数名重写代码后发生的情况：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; result =</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cars.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="keyword">map</span><span class="function"><span class="params">((Car car) -&gt; car.getRegistration())</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    .<span class="title">map</span><span class="params">((String registration) -&gt; DMVRecords.getOwner(registration))</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    .<span class="title">map</span><span class="params">((Person owner) -&gt; owner.getName())</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    .<span class="title">map</span><span class="params">((String name) -&gt; name.toUpperCase())</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    .<span class="title">collect</span><span class="params">(toList())</span>;</span></span></pre></td></tr></table></figure>

<p>这些参数名包含了特定于域的信息。我们没有使用 <code>s</code> 来表示 <code>String</code>，而是指定了特定于域的细节，比如 <code>registration</code> 和 <code>name</code>。类似地，我们没有使用 <code>p</code> 或 <code>o</code>，而是使用 <code>owner</code> 表明 <code>Person</code> 不只是一个人，还是这辆车的车主。<br>这个示例中的每个 lambda 表达式都比它所取代的表达式更好。在读取 lambda 表达式（例如 <code>(Person owner) -&gt; owner.getName()</code>）时，我们知道我们获得了车主的姓名，而不只是随便某个人的姓名。</p>
<h3 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h3><p>Scala 和 TypeScript 等一些语言更加重视参数名而不是类型。在 Scala 中，我们在定义类型之前定义参数，例如通过编写：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getOwner</span><span class="params">(<span class="symbol">registration:</span> String)</span></span></span></pre></td></tr></table></figure>

<p>而不是：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getOwner</span><span class="params">(String registration)</span></span></span></pre></td></tr></table></figure>

<p>类型和参数名都很有用，但在 Scala 中，参数名更重要一些。我们用 Java 编写 lambda 表达式时，也可以考虑这一想法。请注意我们在 Java 中的车辆注册示例中丢弃类型细节和括号时发生的情况：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; result =</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cars.stream<span class="literal">()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    .map(car -&gt; car.get<span class="constructor">Registration()</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .map(registration -&gt; <span class="module-access"><span class="module"><span class="identifier">DMVRecords</span>.</span></span>get<span class="constructor">Owner(<span class="params">registration</span>)</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .map(owner -&gt; owner.get<span class="constructor">Name()</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .map(name -&gt; name.<span class="keyword">to</span><span class="constructor">UpperCase()</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .collect(<span class="keyword">to</span><span class="constructor">List()</span>);</span></pre></td></tr></table></figure>

<p>因为我们添加了描述性的参数名，所以我们没有丢失太多上下文，而且显式类型（现在是冗余内容）已悄然消失。结果是我们获得了更干净、更朴实的代码。</p>
<h2 id="类型推断的局限性"><a href="#类型推断的局限性" class="headerlink" title="类型推断的局限性"></a>类型推断的局限性</h2><p>尽管使用类型推断可以提高效率和可读性，但这种技术并不适用于所有场合。在某些情况下，完全无法使用类型推断。幸运的是，您可以依靠 Java 编译器来获知何时出现这种情况。<br>我们首先看一个测试编译器并获得成功的示例，然后看一个测试失败的示例。最重要的是，在两种情况下，都能够相信编译器会按期望方式工作。</p>
<h3 id="扩展类型推断"><a href="#扩展类型推断" class="headerlink" title="扩展类型推断"></a>扩展类型推断</h3><p>在我们的第一个示例中，假设我们想创建一个 <code>Comparator</code> 来比较 <code>Car</code> 实例。我们首先需要一个 <code>Car</code> 类：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Car</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> String getRegistration() &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>接下来，我们将创建一个 <code>Comparator</code>，以便基于 <code>Car</code> 实例的注册信息对它们进行比较：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">public static Comparator&lt;Car&gt; createComparator() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> comparing<span class="function"><span class="params">((Car car) -&gt; car.getRegistration())</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">&#125;</span></span></pre></td></tr></table></figure>

<p>用作 <code>comparing</code> 方法的参数的 lambda 表达式在其参数列表中包含了类型信息。我们知道 Java 编译器非常擅长类型推断，那么让我们看看在省略参数类型的情况下会发生什么，如下所示：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Car&gt; <span class="title">createComparator</span>(<span class="params"></span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> comparing(car -&gt; car.getRegistration());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>comparing</code> 方法采用了 1 个参数。它期望使用 <code>Function</code> 并返回 <code>Comparator</code>。因为 <code>comparing</code> 是 <code>Comparator</code> 上的一个静态方法，所以编译器目前没有关于 <code>T</code> 或 <code>U</code> 可能是什么的线索。<br>为了解决此问题，编译器稍微扩展了推断范围，将范围扩大到传递给 <code>comparing</code> 方法的参数之外。它观察我们是如何处理调用 <code>comparing</code> 的结果的。根据此信息，编译器确定我们仅返回该结果。接下来，它看到由 <code>comparing</code> 返回的 <code>Comparator</code> 又作为 <code>Comparator</code> 由 <code>createComparator</code> 返回 。<br><em>注意了！</em>编译器现在已明白我们的意图：它推断应该将 <code>T</code> 绑定到 <code>Car</code>。根据此信息，它知道 lambda 表达式中的 <code>car</code> 参数的类型应该为 <code>Car</code>。<br>在这个例子中，编译器必须执行一些额外的工作来推断类型，但它成功了。接下来，让我们看看在提高挑战难度，让编译器达到其能力极限时，会发生什么。</p>
<h3 id="推断的局限性"><a href="#推断的局限性" class="headerlink" title="推断的局限性"></a>推断的局限性</h3><p>首先，我们在前一个 <code>comparing</code> 调用后面添加了一个新调用。在本例中，我们还为 lambda 表达式的参数重新引入显式类型：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">public static Comparator&lt;Car&gt; createComparator() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> comparing<span class="function"><span class="params">((Car car) -&gt; car.getRegistration())</span>.<span class="title">reversed</span><span class="params">()</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">&#125;</span></span></pre></td></tr></table></figure>

<p>借助显式类型，此代码没有编译问题，但现在让我们丢弃类型信息，看看会发生什么：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Car&gt; <span class="title">createComparator</span>(<span class="params"></span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> comparing(car -&gt; car.getRegistration()).reversed();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如您下面所见，进展并不顺利。Java 编译器抛出了错误：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Sample.java:21: error: cannot <span class="builtin-name">find</span> symbol</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return comparing(car -&gt; car.getRegistration()).reversed();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                               ^</span></pre></td></tr><tr><td class="code"><pre><span class="line">  symbol:   method getRegistration()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  location: variable car of<span class="built_in"> type </span>Object</span></pre></td></tr><tr><td class="code"><pre><span class="line">Sample.java:21: error: incompatible types: Comparator&lt;Object&gt; cannot be converted <span class="keyword">to</span> Comparator&lt;Car&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return comparing(car -&gt; car.getRegistration()).reversed();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                           ^</span></pre></td></tr><tr><td class="code"><pre><span class="line">2 errors</span></pre></td></tr></table></figure>

<p>像上一个场景一样，在包含 <code>.reversed()</code> 之前，编译器会询问我们将如何处理调用 <code>comparing(car -&gt; car.getRegistration())</code> 的结果。在上一个示例中，我们以 <code>Comparable</code> 形式返回结果，所以编译器能推断出 <code>T</code> 的类型为 <code>Car</code>。<br>但在修改过后的版本中，我们将传递 <code>comparable</code> 的结果作为调用 <code>reversed()</code> 的目标。<code>comparable</code> 返回 <code>Comparable</code>，<code>reversed()</code> 没有展示任何有关 <code>T</code> 的可能含义的额外信息。根据此信息，编译器推断 <code>T</code> 的类型肯定是 <code>Object</code>。遗憾的是，此信息对于该代码而言并不足够，因为 <code>Object</code> 缺少我们在 lambda 表达式中调用的 <code>getRegistration()</code> 方法。<br>类型推断在这一刻失败了。在这种情况下，编译器实际上需要一些信息。类型推断会分析参数、返回元素或赋值元素来确定类型，但在上下文提供的细节不足时，编译器就会达到其能力极限。</p>
<h3 id="能否采用方法引用作为补救措施？"><a href="#能否采用方法引用作为补救措施？" class="headerlink" title="能否采用方法引用作为补救措施？"></a>能否采用方法引用作为补救措施？</h3><p>在我们放弃这种特殊情况之前，让我们尝试另一种方法：不使用 lambda 表达式，而是尝试使用方法引用：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Car&gt; createComparator() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> comparing(<span class="string">Car:</span>:getRegistration).reversed();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>编译器对此解决方案非常满意。它在方法引用中使用 <code>Car::</code> 来推断类型。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>Java 8 为 lambda 表达式的参数引入了有限的类型推断能力，在未来的 Java 版本中，会将类型推断扩展到局部变量。现在应该学会省略类型细节并信任编译器，这有助于您轻松步入未来的 Java 环境。<br>依靠类型推断和适当命名的参数，编写简明、更富于表达且更少杂质的代码。只要您相信编译器能自行推断出类型，就可以使用类型推断。仅在您确定编译器确实需要您的帮助的情况下提供类型细节。</p>
<blockquote>
<p>作者：Venkat Subramaniam</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms8/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms8/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8 习惯用语（7）：函数接口</title>
    <url>/2019/12/26/Java-8-%E4%B9%A0%E6%83%AF%E7%94%A8%E8%AF%AD%EF%BC%887%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>lambda 表达式的<em>类型</em>是什么？一些语言使用<em>函数值</em>或<em>函数对象</em>来表示 lambda 表达式，但 Java™ 语言没有这么做。Java 使用函数接口来表示 lambda 表达式类型。乍一看似乎有点奇怪，但事实上这是一种确保对 Java 语言旧版本的向后兼容性的有效途径。</p>
<a id="more"></a>

<p>您应该非常熟悉下面这段代码：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="built_in">new</span> Thread(<span class="built_in">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">public</span> <span class="type">void</span> run() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("In another thread");</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">thread.<span class="keyword">start</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println("In main");</span></pre></td></tr></table></figure>

<p><code>Thread</code> 类和它的构造函数是在 Java 1.0 中引入的，距今已有超过 20 年的时间。从那时起，构造函数从未改变过。将 <code>Runnable</code> 的匿名实例传递给构造函数已成为一种传统。但是从 Java 8 开始，可以选择传递 lambda 表达式：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread<span class="function"><span class="params">(() -&gt; System.out.println(<span class="string">"In another thread"</span>))</span>;</span></span></pre></td></tr></table></figure>

<p><strong>关于本系列</strong><br>Java 8 是自 Java 语言诞生以来进行的一次最重大更新—包含了非常丰富的新功能，您可能想知道从何处开始着手了解它。在本系列中，作家兼教师 Venkat Subramaniam 提供了一种惯用的 Java 8 编程方法：这些简短的探索会激发您反思您认为理所当然的 Java 约定，同时逐步将新技术和语法集成到您的程序中。</p>
<p><code>Thread</code> 类的构造函数想要一个实现 <code>Runnable</code> 的实例。在本例中，我们传递了一个 lambda 表达式，而不是传递一个对象。我们可以选择向各种各样的方法和构造函数传递 lambda 表达式，包括在 Java 8 之前创建的一些方法和构造函数。这很有效，因为 lambda 表达式在 Java 中表示为函数接口。<br>函数接口有 3 条重要法则：</p>
<ol>
<li>一个函数接口只有一个抽象方法。</li>
<li>在 <code>Object</code> 类中属于公共方法的抽象方法不会被视为单一抽象方法。</li>
<li>函数接口可以有默认方法和静态方法。</li>
</ol>
<p>任何满足单一抽象方法法则的接口，都会被自动视为函数接口。这包括 <code>Runnable</code> 和 <code>Callable</code> 等传统接口，以及您自己构建的自定义接口。</p>
<h2 id="内置函数接口"><a href="#内置函数接口" class="headerlink" title="内置函数接口"></a>内置函数接口</h2><p>除了已经提到的单一抽象方法之外，JDK 8 还包含多个新函数接口。最常用的接口包括 <code>Function</code>、<code>Predicate</code> 和 <code>Consumer</code>，它们是在 <code>java.util.function</code> 包中定义的。<code>Stream</code> 的 <code>map</code> 方法接受 <code>Function</code> 作为参数。类似地，<code>filter</code> 使用 <code>Predicate</code>，<code>forEach</code> 使用 <code>Consumer</code>。该包还有其他函数接口，比如 <code>Supplier</code>、<code>BiConsumer</code> 和 <code>BiFunction</code>。<br>可以将内置函数接口用作我们自己的方法的参数。例如，假设我们有一个 <code>Device</code> 类，它包含方法 <code>checkout</code> 和 <code>checkin</code> 来指示是否正在使用某个设备。当用户请求一个新设备时，方法 <code>getFromAvailable</code> 从可用设备池中返回一个设备，或在必要时创建一个新设备。<br>我们可以实现一个函数来借用设备，就象这样：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> void borrowDevice(Consumer&lt;Device&gt; <span class="keyword">use</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="title">Device</span> <span class="title">device</span> = <span class="title">getFromAvailable</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    device.checkout();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">use</span>.<span class="title">accept</span>(<span class="title">device</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        device.checkin();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>borrowDevice</code> 方法：</p>
<ul>
<li>接受 <code>Consumer</code> 作为参数。</li>
<li>从池中获取一个设备（我们在这个示例中不关心线程安全问题）。</li>
<li>调用 <code>checkout</code> 方法将设备状态设置为 <em>checked out</em>。</li>
<li>将设备交付给用户。</li>
</ul>
<p>在完成设备调用后返回到 <code>Consumer</code> 的 <code>accept</code> 方法时，通过调用 <code>checkin</code> 方法将设备状态更改为 <em>checked in</em>。<br>下面给出了一种使用 <code>borrowDevice</code> 方法的方式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="constructor">Sample()</span>.borrow<span class="constructor">Device(<span class="params">device</span> -&gt; System.<span class="params">out</span>.<span class="params">println</span>(<span class="string">"using "</span> + <span class="params">device</span>)</span>);</span></pre></td></tr></table></figure>

<p>因为该方法接收一个函数接口作为参数，所以传入一个 lambda 表达式作为参数是可以接受的。</p>
<h2 id="自定义函数接口"><a href="#自定义函数接口" class="headerlink" title="自定义函数接口"></a>自定义函数接口</h2><p>尽管最好尽量使用内置函数接口，但有时需要自定义函数接口。<br>要创建自己的函数接口，需要做两件事：</p>
<ol>
<li>使用 <code>@FunctionalInterface</code> 注释该接口，这是 Java 8 对自定义函数接口的约定。</li>
<li>确保该接口只有一个抽象方法。</li>
</ol>
<p>该约定清楚地表明该接口应接收 lambda 表达式。当编译器看到该注释时，它会验证该接口是否只有一个抽象方法。<br>使用 <code>@FunctionalInterface</code> 注释可以确保，如果在未来更改该接口时意外违反抽象方法数量规则，您会获得错误消息。这很有用，因为您会立即发现问题，而不是留给另一位开发人员在以后处理它。没有人希望在将 lambda 表达式传递给其他人的自定义接口时获得错误消息。</p>
<h3 id="创建自定义函数接口"><a href="#创建自定义函数接口" class="headerlink" title="创建自定义函数接口"></a>创建自定义函数接口</h3><p>作为一个示例，我们将创建一个 <code>Order</code> 类，它有一系列 <code>OrderItem</code> 以及一个转换并输出它们的方法。我们首先创建一个接口。<br>下面的代码将创建一个 <code>Transformer</code> 函数接口。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">Transformer</span>&lt;<span class="symbol">T</span>&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    T transform(T input);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>该接口用 <code>@FunctionalInterface</code> 注释做了标记，表明它是一个函数接口。因为该注释包含在 <code>java.lang</code> 包中，所以没有必要导入。该接口有一个名为 <code>transform</code> 的方法，后者接受一个参数化为 <code>T</code> 类型的对象，并返回一个相同类型的转换后对象。转换的语义将由该接口的实现来决定。<br>这是 <code>OrderItem</code> 类：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderItem</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> final <span class="keyword">int</span> id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> final <span class="keyword">int</span> price;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderItem</span><span class="params">(<span class="keyword">int</span> theId, <span class="keyword">int</span> thePrice)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        id = theId;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        price = thePrice;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> price; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">String</span>.format(<span class="string">"id: %d price: %d"</span>, id, price); &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>OrderItem</code> 是一个简单的类，它有两个属性：<code>id</code> 和 <code>price</code>，以及一个 <code>toString</code> 方法。<br>现在来看看 <code>Order</code> 类。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.<span class="built_in">Stream</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;OrderItem&gt; items;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(List&lt;OrderItem&gt; orderItems)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        items = orderItems;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transformAndPrint</span><span class="params">(Transformer&lt;<span class="built_in">Stream</span>&lt;OrderItem&gt;&gt; transformOrderItems)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        transformOrderItems.transform(items.stream()).forEach(System.out::<span class="built_in">println</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>transformAndPrint</code> 方法接受 <code>Transform</code> 作为参数，调用 <code>transform</code> 方法来转换属于 <code>Order</code> 实例的订单项，然后按转换后的顺序输出这些订单项。<br>这是一个使用该方法的样本：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Comparator.comparing;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.<span class="built_in">Stream</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.*;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Order order = <span class="keyword">new</span> Order(Arrays.asList(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">new</span> OrderItem(<span class="number">1</span>, <span class="number">1225</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">new</span> OrderItem(<span class="number">2</span>, <span class="number">983</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">new</span> OrderItem(<span class="number">3</span>, <span class="number">1554</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        order.transformAndPrint(<span class="keyword">new</span> Transformer&lt;<span class="built_in">Stream</span>&lt;OrderItem&gt;&gt;() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">public</span> <span class="built_in">Stream</span>&lt;OrderItem&gt; transform(<span class="built_in">Stream</span>&lt;OrderItem&gt; orderItems) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> orderItems.sorted(comparing(OrderItem::getPrice));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们传递一个匿名内部类作为 <code>transformAndPrint</code> 方法的参数。在 <code>transform</code> 方法内，调用给定流的 <code>sorted</code> 方法，这会对订单项进行排序。这是我们的代码的输出，其中显示了按价格升序排列的订单项：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">id: <span class="number">2</span> price: <span class="number">983</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">id: <span class="number">1</span> price: <span class="number">1225</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">id: <span class="number">3</span> price: <span class="number">1554</span></span></pre></td></tr></table></figure>

<h3 id="lambda-表达式的强大功能"><a href="#lambda-表达式的强大功能" class="headerlink" title="lambda 表达式的强大功能"></a>lambda 表达式的强大功能</h3><p>在任何需要函数接口的地方，我们都有 3 种选择：</p>
<ol>
<li>传递一个匿名内部类。</li>
<li>传递一个 lambda 表达式。</li>
<li>在某些情况下传递一个方法引用而不是 lambda 表达式。</li>
</ol>
<p>传递匿名内部类的过程很复杂，我们只能传递方法引用来替代直通 lambda 表达式。考虑如果我们重写对 <code>transformAndPrint</code> 函数的调用，以使用 lambda 表达式来代替匿名内部类，将会发生什么：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">order.transform<span class="constructor">AndPrint(<span class="params">orderItems</span> -&gt; <span class="params">orderItems</span>.<span class="params">sorted</span>(<span class="params">comparing</span>(OrderItem::<span class="params">getPrice</span>)</span>));</span></pre></td></tr></table></figure>

<p>与我们最初提供的匿名内部类相比，这简洁得多且更容易阅读。</p>
<h2 id="自定义函数接口与内置函数接口"><a href="#自定义函数接口与内置函数接口" class="headerlink" title="自定义函数接口与内置函数接口"></a>自定义函数接口与内置函数接口</h2><p>我们的自定义函数接口演示了创建自定义接口的优势和不足。首先考虑优势：</p>
<ul>
<li>您可以为自定义接口提供一个描述性名称，帮助其他开发人员修改或重用它。像 <code>Transformer</code>、<code>Validator</code> 和 <code>ApplicationEvaluator</code> 这样的名称是特定于领域的，可以帮助读取接口方法的人推断对参数的预期是什么。</li>
<li>只要您高兴，可以为抽象方法提供任何具有有效语法的名称。只有接口的接收者会获得此优势，而且仅在传递抽象方法时才会体现出来。传递 lambda 表达式或方法引用的调用方不会获得此优势。</li>
<li>您可以在自己的接口中使用参数化的类型，或者让它保持简单并特定于某些类型。在本例中，可以编写 <code>Transformer</code> 接口来使用 <code>OrderItems</code> 而不是参数化类型 <code>T</code>。</li>
<li>您可以编写自定义的默认方法和静态方法，它们可供该接口的其他实现使用。</li>
</ul>
<p>当然，使用自定义函数接口也存在不足之处：</p>
<ul>
<li>想象创建多个接口，所有接口都有具有相同签名的抽象方法，比如接受 <code>String</code> 作为参数并返回 <code>Integer</code>。尽管方法的名称可能有所不同，但它们大部分都是多余的，可替换为一个具有通用名称的接口。</li>
<li>任何想要使用自定义接口的人，都必须投入额外的精力来学习、理解和记住它们。所有 Java 程序员都熟悉 <code>java.lang</code> 包中的 <code>Runnable</code>。我们一次又一次地看到它，所以可以轻松地记住它的用途。但是，如果我使用了一个自定义 <code>Executor</code>，您在使用该接口之前必须仔细了解它。在某些情况下，投入一些精力是值得的，但是如果 <code>Executor</code> 与 <code>Runnable</code> 非常相似，就会浪费精力。</li>
</ul>
<h2 id="哪种接口最好？"><a href="#哪种接口最好？" class="headerlink" title="哪种接口最好？"></a>哪种接口最好？</h2><p>了解自定义函数接口与内置函数接口的优缺点后，如何确定采用哪种接口？我们回顾一下 <code>Transformer</code> 接口来寻找答案。<br>回想一下，<code>Transformer</code> 的存在是为了传达将一个对象转换为另一个对象的语义。这里，我们按名称来引用它：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transformAndPrint</span><span class="params">(Transformer&lt;<span class="built_in">Stream</span>&lt;OrderItem&gt;&gt; transformOrderItems)</span> </span>&#123;</span></pre></td></tr></table></figure>

<p>方法 <code>transformAndPrint</code> 接收一个负责执行转换的参数。该转换可能对 <code>OrderItems</code> 集合中的元素进行重新排序。或者，它可能屏蔽每个订单项的部分细节。或者该转换可以决定什么都不做，仅返回原始集合。将实现工作留给调用方。<br>重要的是，调用方知道它们可以将转换实现作为参数提供给 <code>transformAndPrint</code> 方法。函数接口的名称和它的文档应该提供这些细节。在本例中，从参数名称 (<code>transformOrderItems</code>) 也可以清楚了解这些细节，而且它们应包含在 <code>transformAndPrint</code> 函数的文档中。尽管函数接口的名称很有用，但它不是了解函数接口用途和用法的唯一途径。<br>仔细查看 <code>Transformer</code> 接口，并将它的用途与 JDK 的内置函数接口进行比较，我们看到 <code>Function</code> 可以取代 <code>Transformer</code>。要测试 <code>Transformer</code> 函数接口，可以从代码中删除它并更改 <code>transformAndPrint</code> 函数，就像这样：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transformAndPrint</span><span class="params">(Function&lt;<span class="built_in">Stream</span>&lt;OrderItem&gt;, <span class="built_in">Stream</span>&lt;OrderItem&gt;&gt; transformOrderItems)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    transformOrderItems.apply(items.stream())</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .forEach(System.out::<span class="built_in">println</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>改动很小 —除了将 <code>Transformer&gt;</code> 更改为 <code>Function&gt;</code>、<code>Stream&gt;</code>，我们还将方法调用从 <code>transform()</code> 更改为 <code>apply()</code>。<br>对 <code>transformAndPrint</code> 的调用使用了一个匿名内部类，我们还需要更改这一点。但是，我们已更改该调用来使用 lambda 表达式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">order.transform<span class="constructor">AndPrint(<span class="params">orderItems</span> -&gt; <span class="params">orderItems</span>.<span class="params">sorted</span>(<span class="params">comparing</span>(OrderItem::<span class="params">getPrice</span>)</span>));</span></pre></td></tr></table></figure>

<p>函数接口的名称与 lambda 表达式无关—它仅与编译器相关，编译器将 lambda 表达式参数与方法参数联系起来。方法的名称是 <code>transform</code> 还是 <code>apply</code>，同样与调用方无关。<br>使用内置的函数接口让我们的接口减少了一个，调用该方法也具有同样功效。我们也没有损害代码的可读性。这个练习告诉我们，我们可以轻松地将自定义函数接口替换为内置接口。我们只需提供 <code>transformAndPrint</code> 的文档（未显示）并采用含义更明确的方式命名该参数。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>将 lambda 表达式设置为函数接口类型的设计决策，有助于在 Java 8 与早期 Java 版本之间实现向后兼容性。可以将 lambda 表达式传递给任何通常接收单一抽象方法接口的旧函数。要接收 lambda 表达式，方法的参数类型应为函数接口。<br>在某些情况下，创建自己的函数接口是合情合理的，但在这么做时应该小心谨慎。仅在应用程序需要高度专业化的方法时，或者现有接口无法满足您的需求时，才考虑自定义函数接口。请始终检查一个 JDK 的内置函数接口中是否存在该功能。尽量使用内置函数接口。</p>
<blockquote>
<p>作者：Venkat Subramaniam</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms7/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms7/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8 习惯用语（6）：完美的 lambda 表达式</title>
    <url>/2019/12/26/Java-8-%E4%B9%A0%E6%83%AF%E7%94%A8%E8%AF%AD%EF%BC%886%EF%BC%89%EF%BC%9A%E5%AE%8C%E7%BE%8E%E7%9A%84-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>目前您已在本系列中了解到，函数组合的一个主要好处是它会获得富于表达的代码。编写简短的 lambda 表达式是实现这一表达能力的关键，但通常说起来容易做起来难。本文会加深您目前对创建单行 lambda 表达式的各个方面的了解。通过学习函数组合的结构和好处，您很快就会掌握完美的 lambda 表达式，—一个仅短短一行的表达式。</p>
<a id="more"></a>

<h2 id="编写-lambda-表达式的两种方法"><a href="#编写-lambda-表达式的两种方法" class="headerlink" title="编写 lambda 表达式的两种方法"></a>编写 lambda 表达式的两种方法</h2><p>众所周知，lambda 表达式是匿名函数，它们天生就很简洁。普通的函数或方法通常有 4 个元素：</p>
<ul>
<li>一个名称</li>
<li>返回类型</li>
<li>参数列表</li>
<li>主体</li>
</ul>
<p>在这里可以看到，lambda 表达式只有这 4 元素中的最后两个：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">(parameter <span class="keyword">list</span>)</span> -&gt;</span> body</span></pre></td></tr></table></figure>

<p><code>“-&gt;”</code> 将参数列表与函数主体分离，旨在对给定参数进行处理。函数的主体可能是一个表达式或一条语句。下面给出了一个示例：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">(Integer e)</span> -&gt;</span> e * <span class="number">2</span></span></pre></td></tr></table></figure>

<p>在此代码中，主体只有一行：一个返回给定参数两次的表达式。信噪比很高，没有分号，也不需要 <code>return</code> 关键字。这就是一个理想的 lambda 表达式。</p>
<h3 id="多行-lambda-表达式"><a href="#多行-lambda-表达式" class="headerlink" title="多行 lambda 表达式"></a>多行 lambda 表达式</h3><p>在 Java ™中，lambda 表达式的主体也可能是一个复杂的表达式或声明语句；也就是说，一个 lambda 表达式包含多行。在这种情况下，分号必不可少。如果 lambda 表达式返回一个结果，也会需要 <code>return</code> 关键字。下面给出了一个示例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">Integer</span> e) -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> <span class="built_in">sqrt</span> = Math.<span class="built_in">sqrt</span>(e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> <span class="built_in">log</span> = Math.<span class="built_in">log</span>(e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span> + <span class="built_in">log</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>本示例中的 lambda 表达式返回了 <code>sqrt</code> 和给定参数的 <code>log</code> 的和。因为主体包含多行，所以括号 (<code>{}</code>)、分号 (<code>;</code>) 和 <code>return</code> 关键字都是必需的。<br>如果感觉好像 Java 因为我们编写多行 lambda 表达式而惩罚我们，—或许我们应该接受这样的暗示。</p>
<h2 id="函数组合的强大功能"><a href="#函数组合的强大功能" class="headerlink" title="函数组合的强大功能"></a>函数组合的强大功能</h2><p>函数式编码风格利用了函数组合的表达能力。比较两段代码时，很容易看出富于表达的好处。第一段代码是用命令式风格编写的：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> result = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> e : values) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(e &gt; <span class="number">3</span> &amp;&amp; e % <span class="number">2</span> == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      result = e * <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>现在考虑用函数式风格编写的相同代码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> result = values.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .filter(e -&gt; e &gt; <span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .filter(e -&gt; e % <span class="number">2</span> == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .map(e -&gt; e * <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .findFirst()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .orElse(<span class="number">0</span>);</span></pre></td></tr></table></figure>

<p>两段代码获得了相同的结果。在命令式代码中，我们需要读入 <code>for</code> 循环，按照分支和中断来跟随流程。第二段代码使用了函数组合，更容易阅读一些。因为它是从上往下执行的，所以我们只需要传递该代码一次。<br>本质上，第二段代码读起来像是一个问题陈述：<em>给定一些值，仅选择大于 3 的值。从这些值中，仅选择偶数值，并将它们乘以 2。最后，挑选第一个结果。如果没有任何值存在，则返回 0。</em><br>此代码不仅优雅，而且它的<em>工作量并不比</em>命令式代码多。得益于 <code>Stream</code>的惰性计算能力，这里没有浪费计算资源。<br>函数组合的表达能力很大程度上依赖于每个 lambda 表达式的简洁性。如果您的 lambda 表达式包含多行（甚至<a href="https://twitter.com/venkat_s/status/611119147586600960" target="_blank" rel="noopener">两行可能都太多</a>），您可能没有理解函数式编程的关键点。</p>
<h2 id="充满危险的长-lambda-表达式"><a href="#充满危险的长-lambda-表达式" class="headerlink" title="充满危险的长 lambda 表达式"></a>充满危险的长 lambda 表达式</h2><p>要更好地理解编写简短的 lambda 表达式的好处，可考虑反面情况：一个包含多行代码的杂乱 lambda 表达式：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">System.<span class="keyword">out</span>.println(</span></pre></td></tr><tr><td class="code"><pre><span class="line">values.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .mapToInt(e -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= e; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span>(e % i == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">sum</span> += i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .<span class="built_in">sum</span>());</span></pre></td></tr></table></figure>

<p>尽管此代码是用函数式风格编写的，但它丢失了函数式编程的优点。让我们考虑一下原因何在。</p>
<p>1.难以读懂</p>
<p>好代码应该易于读懂。此代码需要绞尽脑汁才能读懂：很难找到不同部分的开头和结尾。</p>
<p>2.用途不明</p>
<p>好代码读起来应该像一个故事，而不是像一个字谜。像这样冗长的、无特色的代码隐藏了它的具体用途，会耗费读者的时间和精力。将这段代码包装在一个命名函数中可以使其模块化，同时也可以通过相关的名称揭示它的用途。</p>
<p>3.代码质量差</p>
<p>无论您的代码有何用途，您可能都希望在某个时候重用它。这段代码的逻辑已嵌入在 lambda 表达式中，后者又以参数形式传递给另一个函数 <code>mapToInt</code>。如果我们在程序的其他某个地方需要该代码，我们可能忍不住重写它，这会引起代码库中的不一致性。或者，我们也可以复制并粘贴该代码。两种选项都会得到好代码或高品质的软件。</p>
<p>4.难以测试</p>
<p>代码始终依靠键入的内容进行操作，而且不一定是我们打算执行的操作，所以这代表着必须测试任何非平凡代码。如果 lambda 表达式中的代码无法用作一个单元，则无法对它执行单元测试。您可以运行集成测试，但这无法取代单元测试，尤其是在代码执行重要工作时。</p>
<p>5.代码覆盖范围小</p>
<p>一位学习 Java 8 课程的学员最近表示他们讨厌 lambda 表达式。在我问为什么时，他们向我展示了一位同事的作品，其中包含的 lambda 表达式运行了数百行代码。嵌入在参数中的 Lambda 表达式无法轻松地作为单元提取出来，而且许多表达式在覆盖范围报告中显示为红色。由于一无所知，该团队很难假设这些代码在工作正常。</p>
<h2 id="使用-Lambda-作为粘合代码"><a href="#使用-Lambda-作为粘合代码" class="headerlink" title="使用 Lambda 作为粘合代码"></a>使用 Lambda 作为粘合代码</h2><p>解决所有这些问题的方法是让您的 lambda 表达式高度简洁。作为第一个且非常有用的步骤，避免在 lambda 表达式中使用括号。考虑如何使用此技术轻松地重写前面杂乱的 lambda 表达式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(</span></pre></td></tr><tr><td class="code"><pre><span class="line">values.stream<span class="literal">()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  .map<span class="constructor">ToInt(<span class="params">e</span> -&gt; <span class="params">sumOfFactors</span>(<span class="params">e</span>)</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .sum<span class="literal">()</span>);</span></pre></td></tr></table></figure>

<p>此代码很简洁，尽管它不完整。该代码也具有很高的可读性。它的用途是： <em>给定一组值，将该列表转换为每个数的因数之和，然后计算所获得的集合的和。</em> 显式命名以前包含在括号中的代码主体，这会让此代码变得更容易阅读和理解。函数管道现在既整洁又容易理解。<br>不需要解字谜，因为此代码直接表明了它的用途。计算因数之和的代码已模块化为一个名为 <code>sumOfFactors</code>的单独方法，该方法可以重用。因为它是一个单独方法，所以对它的逻辑执行单元测试也很容易。因为此代码如此容易测试，所以您可以确保良好的代码覆盖范围。<br>简言之，曾经杂乱的 lambda 表达式现在成为了 <em>粘合代码</em>— 它没有承担大量责任，只是将命名函数粘合到 <code>mapToInt</code> 函数。</p>
<h3 id="使用方法引用进行调优"><a href="#使用方法引用进行调优" class="headerlink" title="使用方法引用进行调优"></a>使用方法引用进行调优</h3><p>就像在<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms5/index.html" target="_blank" rel="noopener">本系列的其他地方</a>看到的一样，可以通过将 lambda 表达式替换为方法引用，让上述代码更富于表达（其中 <code>sumOfFactors</code> 是一个名为 <code>Sample</code>的类的方法）：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="selector-tag">values</span><span class="selector-class">.stream</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="selector-class">.mapToInt</span>(<span class="selector-tag">Sample</span><span class="selector-pseudo">::sumOfFactors)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="selector-class">.sum</span>());</span></pre></td></tr></table></figure>

<p>这是重写后的 <code>sumOfFactors</code> 方法：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> static <span class="built_in">int</span> sumOfFactors(<span class="built_in">int</span> <span class="keyword">number</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> IntStream.rangeClosed(<span class="number">1</span>, <span class="keyword">number</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(i -&gt; <span class="keyword">number</span> % i == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="built_in">sum</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>现在它是一个简短的方法。该方法中的 lambda 表达式也很简洁：只有一行，没有过多的繁杂过程或噪音。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>简短的 lambda 表达式能提高代码可读性，这是函数式编程的重要好处之一。包含多行的 lambda 表达式具有相反的效果，会让代码变得杂乱且难以阅读。多行 lambda 表达式还难以测试和重用，这可能导致重复工作和代码质量差。幸运的是，通过将多行 lambda 表达式的主体转移到一个命名函数中，然后从 lambda 表达式内调用该函数，这样很容易避免这些问题。我也推荐尽可能将 lambda 表达式替换为方法引用。<br>简言之，我推荐避免多行 lambda 表达式，除非是为了演示它们为什么不好。</p>
<blockquote>
<p>作者：Venkat Subramaniam</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms6/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms6/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 习惯用语（5）：传递表达式的替代方案</title>
    <url>/2019/12/26/Java-8-%E4%B9%A0%E6%83%AF%E7%94%A8%E8%AF%AD%EF%BC%885%EF%BC%89%EF%BC%9A%E4%BC%A0%E9%80%92%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>Lambda 表达式被广泛用在函数式编程中，但它们很难阅读和理解。在许多情况下，lambda 表达式的存在<em>只是</em>为了传递一个或多个形参，最好将它替换为方法引用。在本文中，您将学习如何识别代码中的传递 lambda 表达式，以及如何将它们替换为相应的方法引用。尽管方法引用的使用需要学习，但长期收益很快会超过您最初的付出。</p>
<a id="more"></a>

<h2 id="传递-lambda-表达式是什么？"><a href="#传递-lambda-表达式是什么？" class="headerlink" title="传递 lambda 表达式是什么？"></a>传递 lambda 表达式是什么？</h2><p>在函数式编程中，常常传递 lambda 表达式作为匿名函数，使用 lambda 作为更高阶函数的实参。例如，在清单 1 中，我们将一个 lambda 表达式传递给 <code>filter</code> 方法：</p>
<p>清单 1. 一个传递 lambda 表达式</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">numbers.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .filter(e -&gt; e % <span class="number">2</span> == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .forEach(e -&gt; System.<span class="keyword">out</span>.println(e));</span></pre></td></tr></table></figure>

<p>请注意，在此代码中，我们还将一个 lambda 表达式传递给了 <code>forEach</code> 方法。尽管这两个 lambda 表达式明显具有不同作用，但它们之间还有另一个重要的细微区别：第一个 lambda 表达式实际执行一些工作，而第二个没有。<br>传递给 <code>forEach</code> 方法的 lambda 表达式就是我们所称的<em>传递 lambda 表达式</em>。表达式 <code>e -&gt; System.out.println(e)</code><em>将它的形参</em>作为实参传递给 <code>PrintStream</code> 类的 <code>println</code> 方法，该方法是 <code>System.out</code> 实例。<br>尽管清单 1 中的第二个 lambda 表达式没有任何错误，但它的语法对于当前这个任务而言过于复杂。为了理解 <code>(parameters) -&gt; body</code> 的用途，我们需要进入 <em>body</em>（在 <code>-&gt;</code> 的右侧）来查看该形参发生了什么。如果该 lambda 表达式没有对该形参执行任何实际操作，则付出的努力就白费了。<br>在此情况下，将传递 lambda 表达式替换为方法引用会比较有益。不同于方法调用，方法引用指的是我们传递形参的方法。使用方法引用也会带来各种各样的形参传递方式。<br>尝试像这样重写前面的代码：</p>
<p>清单 2. 通过方法引用传递形参</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">numbers</span><span class="selector-class">.stream</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="selector-class">.filter</span>(e -&gt; e % <span class="number">2</span> == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="selector-class">.forEach</span>(System.<span class="attribute">out</span>::println);</span></pre></td></tr></table></figure>

<p>使用方法引用会减少理解代码的工作。尽管最初的好处可能看起来较小，但随着我们编写和阅读更多代码，好处会倍增。</p>
<h2 id="传递形参作为实参"><a href="#传递形参作为实参" class="headerlink" title="传递形参作为实参"></a>传递形参作为实参</h2><p>在接下来的几节中，我们将探讨传递 lambda 表达式的变形。我将介绍如何将每种表达式替换为方法引用。</p>
<h3 id="实例方法的实参"><a href="#实例方法的实参" class="headerlink" title="实例方法的实参"></a>实例方法的实参</h3><p>lambda 表达式将其形参作为实参传递给实例方法，这非常常见。您在清单 1 中已看到，形参 <code>e</code> 作为实参传递给 <code>println</code> 方法，该方法本身是 <code>System.out</code> 的一个实例方法。<br>在清单 2 中，我们使用以下格式将此 lambda 表达式替换为方法引用 <code>System.out::println</code>：<em>referenceToInstance::methodName</em>。<br>在图 1 中可以看到这种替换，图中展示了一个 lambda 表达式的结构，形参作为实参传递给一个实例方法：</p>
<p>图 1. 从形参到实例方法的实参</p>
<p><img src="http://image.winrains.cn/2019/08/c02a9-figure1.jpg" alt="一个传递 lambda 表达式的结构图。"><br>如果不熟悉方法引用，查看这样的 lambda 表达式能帮助您理解它的结构和形参传递到何处。要将 lambda 表达式更改为方法引用，只需删除通用的部分（形参和实参），并在方法调用上将点替换为冒号。</p>
<h4 id="this-上的一个方法的实参"><a href="#this-上的一个方法的实参" class="headerlink" title="this 上的一个方法的实参"></a><code>this</code> 上的一个方法的实参</h4><p>前面的传递表达式的一种特殊情况是，在当前方法的 <em>context</em> 实例上调用实例方法。<br>假设我们有一个名为 <code>Example</code> 的类，其中包含一个实例方法 <code>increment</code>：</p>
<p>清单 3. 一个包含实例方法的类</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Example</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> increment(<span class="built_in">int</span> number) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> number + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>现在假设我们有另一个实例方法，我们在其中创建了一个 lambda 表达式并将它传递给 <code>Stream</code> 的 <code>map</code> 方法，如下所示：</p>
<p>清单 4. 一个将形参传递给实例方法的 lambda 表达式</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line">.map(<span class="variable">e</span> -&gt; <span class="function"><span class="title">increment</span>(<span class="variable">e</span>))</span></span></pre></td></tr></table></figure>

<p>可能不那么显而易见，但此代码在结构上非常类似于上一个示例 — 在两种情况下，我们都将形参作为实参传递给实例方法。稍微重写此代码，以让此相似性更加明显：</p>
<p>清单 5. 传递表达式揭秘</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">.<span class="keyword">map</span>(e<span class="function"> -&gt;</span> <span class="keyword">this</span>.increment(e))</span></pre></td></tr></table></figure>

<p>引入冗余的 <code>this</code> 作为对 <code>increment</code> 的调用的目标，以让传递表达式的结构变得清晰。现在我们可以通过方法引用轻松地解决冗余问题：</p>
<p>清单 6. 方法引用解决冗余问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.<span class="built_in">map</span>(<span class="keyword">this</span>::increment)</span></pre></td></tr></table></figure>

<p>与将 <code>e -&gt; System.out.println(e)</code> 替换为 <code>System.out::println</code> 非常相似的是，可以将 lambda 表达式 <code>e -&gt; increment(e)</code>（或更准确地讲 <code>e -&gt; this.increment(e)</code>）替换为 <code>this::increment</code>。在两种情况下，代码都更加清晰。</p>
<h3 id="静态方法的实参"><a href="#静态方法的实参" class="headerlink" title="静态方法的实参"></a>静态方法的实参</h3><p>在前面两个示例中，我们替换的 lambda 表达式将一个形参作为实参传递给实例方法。也可以替换将形参传递给静态方法的 lambda 表达式。</p>
<p>清单 7. 将形参传递给静态方法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">.map(e -&gt; <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>value<span class="constructor">Of(<span class="params">e</span>)</span>)</span></pre></td></tr></table></figure>

<p>这里，lambda 表达式将形参作为实参传递给 <code>Integer</code> 类的 <code>valueOf</code> 方法。该代码的结构与图 1 中所示的结构相同。唯一的区别在于，在这个例子中，被调用的方法是<em>静态方法</em>而不是实例方法。就像前两个示例一样，我们将此 lambda 表达式替换为方法引用。我们未将方法引用放在实例上，而将它放在一个类上，如清单 8 所示。</p>
<p>清单 8. 对静态方法的方法引用</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">.<span class="built_in">map</span>(<span class="built_in">Integer</span><span class="type">::valueOf</span>)</span></pre></td></tr></table></figure>

<p>总结一下：如果 lambda 表达式的目的仅是将一个形参传递给实例方法，那么可以将它替换为实例上的方法引用。如果传递表达式要传递给静态方法，可以将它替换为类上的方法引用。</p>
<h2 id="将形参传递给目标"><a href="#将形参传递给目标" class="headerlink" title="将形参传递给目标"></a>将形参传递给目标</h2><p>您可能在两种不同的场景中使用 <em>ClassName::methodName</em> 格式。您刚才已看到第一种场景，其中的形参作为实参传递给静态方法。现在让我们考虑一种变形：形参是方法调用的目标。</p>
<p>清单 9. 使用形参作为目标</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.map</span>(<span class="selector-tag">e</span> <span class="selector-tag">-</span>&gt; <span class="selector-tag">e</span><span class="selector-class">.doubleValue</span>())</span></pre></td></tr></table></figure>

<p>在这个示例中，形参 <code>e</code>（我们假设其推断类型为 <code>Integer</code>）是对 <code>doubleValue</code> 方法的调用的目标。图 2 中给出了这种传递 lambda 表达式的结构。</p>
<p>图 2. 从形参到目标</p>
<p><img src="http://image.winrains.cn/2019/08/5d54c-figure2.jpg" alt="一个将形参传递给目标的 lambda 表达式的结构图。"><br>尽管前两个 lambda 表达式中的形参以不同方式传递 — 一个作为实参传递给静态方法，另一个作为实例方法调用的目标 — 但方法引用的格式完全相同：<em>ClassName::methodName</em>。</p>
<h4 id="模糊性与方法引用"><a href="#模糊性与方法引用" class="headerlink" title="模糊性与方法引用"></a>模糊性与方法引用</h4><p>查看方法引用，不容易确定形参传递给了静态方法还是用作了目标。要了解区别，我们需要知道方法是静态方法还是实例方法。从代码可读性角度讲，这不那么重要，但知道该区别对成功编译至关重要。<br>如果一个类的一个静态方法和一个兼容的实例方法同名，而且我们使用了方法引用，则编译器将认为该调用模糊不清。所以，举例而言，我们不能将 lambda 表达式 <code>(Integer e) -&gt; e.toString()</code> 替换为方法引用 <code>Integer::toString</code>，因为 <code>Integer</code> 类同时包含静态方法 <code>public static String toString(int i)</code> 和实例方法 <code>public String toString()</code>。<br>您或您的 IDE 可能建议使用 <code>Object::toString</code> 解决这个特定的问题，因为 <code>Object</code> 中没有 <code>static``toString</code> 方法。尽管该解决方案可以编译，但这种小聪明通常没什么帮助。您必须能够确认方法引用正在调用想要的方法。在存在疑问时，最好使用 lambda 表达式，以避免任何混淆或可能的错误。</p>
<h2 id="传递构造函数调用"><a href="#传递构造函数调用" class="headerlink" title="传递构造函数调用"></a>传递构造函数调用</h2><p>除了静态和实例方法，也可以使用方法引用来表示对构造函数的调用。考虑一个从 <code>Supplier</code> 中发出的构造函数调用，Supplier 作为实参提供给 <code>toCollection</code> 方法，如下所示。</p>
<p>清单 10. 一个构造函数调用</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">.collect<span class="function"><span class="params">(toCollection(() -&gt; <span class="keyword">new</span> LinkedList&lt;Double&gt;()))</span>;</span></span></pre></td></tr></table></figure>

<p>清单 10 中代码的目的是获取一个数据 <code>Stream</code> ，将它精减或收集到一个 <code>LinkedList</code> 中。<code>toCollection</code> 方法接受一个 <code>Supplier</code> 作为其实参。Supplier 不接受任何形参，因此 <code>()</code> 为空。它返回一个 <code>Collection</code> 实例，该实例在本例中是 <code>LinkedList</code>。<br>尽管参数列表是空的，但代码的一般结构如下：</p>
<p>图 3. 从形参到构造函数实参</p>
<p><img src="http://image.winrains.cn/2019/08/92ca7-figure3.jpg" alt="一个用于将形参传递给构造函数的 lambda 表达式的结构图。"><br>收到的形参（可能是空的）被作为实参传递给构造函数。在此示例中，我们可以将 lambda 表达式替换为对 <code>new</code> 的方法引用。做法如下：</p>
<p>清单 11. 将构造函数调用替换为方法引用</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">.collect(<span class="keyword">to</span><span class="constructor">Collection(LinkedList::<span class="params">new</span>)</span>);</span></pre></td></tr></table></figure>

<p>包含方法引用的代码比包含 lambda 表达式的原始代码简洁得多，因此更容易阅读和理解。</p>
<h2 id="传递多个实参"><a href="#传递多个实参" class="headerlink" title="传递多个实参"></a>传递多个实参</h2><p>目前您已看到了单一形参和传递空形参的例子。但方法引用不仅限于 0 或 1 个形参，它们也适用于多个实参。考虑下面这个 <code>reduce</code> 运算：</p>
<p>清单 12. 对 lambda 表达式执行 reduce()</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">.reduce<span class="function"><span class="params">(<span class="number">0</span>, (total, e) -&gt; Integer.sum(total, e))</span>);</span></span></pre></td></tr></table></figure>

<p>在 <code>Stream</code> 上调用 <code>reduce</code> 方法，并使用 <code>Integer</code> 的 <code>sum</code> 方法对流中的值求和。这个例子中的 lambda 表达式接受两个形参，它们作为实参（按完全相同的顺序）传递给 <code>sum</code> 方法。图 4 显示了这个 lambda 表达式的结构。</p>
<p>图 4. 传递两个形参作为实参</p>
<p><img src="http://image.winrains.cn/2019/08/7bd79-figure4.jpg" alt="一个用于将两个形参作为实参传递的 lambda 表达式的结构图。"><br>我们可以将这个 lambda 表达式替换为方法引用，如下所示：</p>
<p>清单 13. 替换一个接受两个形参的 lambda 表达式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.reduce</span>(0, <span class="selector-tag">Integer</span><span class="selector-pseudo">::sum))</span>;</span></pre></td></tr></table></figure>

<p>如果 <code>static</code> 方法调用接受提供给 lambda 表达式的形参作为实参（与它们在形参列表中出现的顺序完全相同），则可以将 lambda 表达式替换为指向 <code>static</code> 方法的方法引用。</p>
<h4 id="作为目标和实参传递"><a href="#作为目标和实参传递" class="headerlink" title="作为目标和实参传递"></a>作为目标和实参传递</h4><p>无需将所有形参作为实参传递给 <code>static</code> 方法，lambda 表达式可以使用一个形参作为实例方法调用的目标。如果第一个形参用作目标，则可以将 lambda 表达式替换为方法引用。考虑清单 14。</p>
<p>清单 14. 对使用形参作为目标的 lambda 表达式执行 reduce()</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">.reduce<span class="function"><span class="params">(<span class="string">""</span>, (result, letter) -&gt; result.concat(letter))</span>);</span></span></pre></td></tr></table></figure>

<p>在这个例子中，在 <code>Stream</code> 上调用 <code>reduce</code> 方法。该 lambda 表达式使用 <code>String</code> 的 <code>concat</code> 实例方法串联字符串。这个 lambda 表达式中的传递结构不同于您在上一个 <code>reduce</code> 示例中看到的结构：</p>
<p>图 5. 第一个形参作为调用的目标而传递</p>
<p><img src="http://image.winrains.cn/2019/08/35ea6-figure5.jpg" alt="一个用于传递两个形参中第一个形参的 lambda 表达式的结构图。"><br>lambda 表达式的第一个形参用作实例方法调用的目标。第二个形参用作该方法的实参。根据此顺序，可以将该 lambda 表达式替换为方法引用，如清单 15 所示：</p>
<p>清单 15. 使用第一个形参作为目标的方法引用</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">.reduce(<span class="string">""</span>, <span class="built_in">String</span><span class="type">::concat</span>));</span></pre></td></tr></table></figure>

<p>请注意，尽管该 lambda 表达式调用了一个实例方法，但您再次使用了类名称。换句话说，无论您调用静态方法还是将第一个形参作为目标来调用实例方法，方法引用看起来都是一样的。只要不存在模糊性，就没有问题。</p>
<h2 id="最好使用方法引用"><a href="#最好使用方法引用" class="headerlink" title="最好使用方法引用"></a>最好使用方法引用</h2><p>要掌握传递 lambda 表达式的变形和结构，以及取代它们的方法引用，需要花一定的时间和精力。我花了两周时间才完全理解这些概念和语法。在这之后，就开始感觉使用方法引用取代传递表达式变得更加自然。<br>比 lambda 表达式更好的是，方法引用还使您的代码变得非常简洁和富于表达，这可以大大减少阅读代码的工作。要进一步理解这一点，可以考虑最后一个示例。</p>
<p>清单 16. 使用 lambda 表达式的示例</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; nonNullNamesInUpperCase =</span></pre></td></tr><tr><td class="code"><pre><span class="line">    names.stream<span class="literal">()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      .filter(name -&gt; <span class="module-access"><span class="module"><span class="identifier">Objects</span>.</span></span>non<span class="constructor">Null(<span class="params">name</span>)</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">      .map(name -&gt; name.<span class="keyword">to</span><span class="constructor">UpperCase()</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">      .collect(collecting<span class="constructor">AndThen(<span class="params">toList</span>()</span>, <span class="built_in">list</span> -&gt; <span class="module-access"><span class="module"><span class="identifier">Collections</span>.</span></span>unmodifiable<span class="constructor">List(<span class="params">list</span>)</span>));</span></pre></td></tr></table></figure>

<p>给定一个 <code>List names</code>，上面的代码删除列表中的所有 <code>null</code> 值，将每个名称转换为大写，并将结果收集到一个无法修改的列表中。<br>现在让我们使用方法引用重写上述代码。在本例中，每个 lambda 表达式都是一个传递表达式，无论是传递给静态方法还是实例方法。因此，我们将每个 lambda 表达式替换为一个方法引用：</p>
<p>清单 17. 使用方法引用</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; nonNullNamesInUpperCase =</span></pre></td></tr><tr><td class="code"><pre><span class="line">    names.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">      .filter(Objects<span class="type">::nonNull</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">      .<span class="built_in">map</span>(<span class="built_in">String</span><span class="type">::toUpperCase</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">      .collect(collectingAndThen(toList(), Collections<span class="type">::unmodifiableList</span>));</span></pre></td></tr></table></figure>

<p>比较这两个清单，很容易看到使用方法引用的代码更加流畅且更容易阅读。它的意思很简单：<em>给定名称，过滤非 null 值，映射到大写形式，然后收集到一个不可修改的列表中</em>。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>只要看到一个 lambda 表达式的唯一目的是将形参传递给一个或多个其他函数，就需要考虑将该 lambda 表达式替换为方法引用是否更好。决定因素在于，lambda 表达式内没有完成任何实际工作。在这种情况下，lambda 表达式就是一个<em>传递</em>表达式，而且它的语法对于当前这个任务而言可能过于复杂了。<br>对于大部分开发人员，需要花一些精力才能了解如何使用方法引用。但是，一旦熟悉了，您就会发现与使用 lambda 表达式的代码相比，使用方法引用会让同样的代码更流畅且富于表达。</p>
<blockquote>
<p>作者：Venkat Subramaniam</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms5/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms5/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 习惯用语（4）：提倡使用有帮助的编码</title>
    <url>/2019/12/26/Java-8-%E4%B9%A0%E6%83%AF%E7%94%A8%E8%AF%AD%EF%BC%884%EF%BC%89%EF%BC%9A%E6%8F%90%E5%80%A1%E4%BD%BF%E7%94%A8%E6%9C%89%E5%B8%AE%E5%8A%A9%E7%9A%84%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>表达能力是函数式编程的优势之一，但这对您的代码意味着什么？在本文中，我们将比较命令式和函数式代码的示例，判断这两者的表达能力和简洁性的品质。您将了解这些品质如何帮助确保可读性，还会考虑一个反面示例：对简洁性的过度追求导致代码无用。最后，我将介绍 Java 8 对于函数组合中的垂直对齐点的约定。尽管一些 Java 开发人员可能不熟悉此约定，但可以用一个简单示例来证明其价值。</p>
<p><strong>关于本系列</strong><br>Java 8 是自 Java 语言诞生以来进行的一次最重大更新 — 包含了非常丰富的新功能，您可能想知道从何处开始着手了解它。在本系列中，作家兼教师 Venkat Subramaniam 提供了一种惯用的 Java 8 编程方法：在逐步将新技术和语法集成到您的程序中时，这些简短的探索会激发您对理所当然的 Java 约定的反思。</p>
<a id="more"></a>

<h2 id="令人惊讶的结果"><a href="#令人惊讶的结果" class="headerlink" title="令人惊讶的结果"></a>令人惊讶的结果</h2><p>在 Java 8 发布一年左右，我在自己的网站上宣布进行一次简短且不受约束的调查，并邀请开发人员参与该调查。每个参与者都会看到一段命令式或函数式代码，然后需要确定代码的行为。我计算了每位访问者提供回复所花的时间，并比较来自两个不同代码示例的结果。该调查开放了 48 小时，在此期间有 1,100 多人参与调查。调查结果令人感到有些惊讶。<br>大部分开发人员，包括作者本人，都有丰富的命令式编程经验。尽管函数式编程已存在很长时间，但大部分 Java 程序员都对它并不熟悉。了解到这一点后，82% 的收到命令式代码的调查回复者能确定其正确行为并不令人感到惊讶。与此同时，收到函数式代码的回复者中只有 75% 回答正确。<br>但是，令我惊讶的是回复者理解两个代码示例所用的时间。理解命令式代码所用的平均时间比理解函数式代码所用的平均时间长 30 秒。</p>
<h2 id="在家里尝试这个实验"><a href="#在家里尝试这个实验" class="headerlink" title="在家里尝试这个实验"></a>在家里尝试这个实验</h2><p>函数式代码比命令式代码更富于表达且更简洁 —<em>前提是需要精心编写</em>。一个简单示例可以证明这一点。在查看下面的代码示例之前，请准备一个计时器。像我的调查回复者一样，您的任务是理解代码的细节。您要计算每个示例所需的时间。<br>准备好了吗？启动计时器并阅读下面的代码，然后写下您预计它会产生的行为。</p>
<p>清单 1. 命令式代码示例</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="keyword">String</span>&gt; names = Arrays.asList(<span class="string">"Jack"</span>, <span class="string">"Jill"</span>, <span class="string">"Nate"</span>, <span class="string">"Kara"</span>, <span class="string">"Kim"</span>, <span class="string">"Jullie"</span>, <span class="string">"Paul"</span>, <span class="string">"Peter"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;<span class="keyword">String</span>&gt; subList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">String</span> name : names) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(name.length() == <span class="number">4</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        subList.<span class="built_in">add</span>(name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">StringBuilder namesOfLength4 = <span class="keyword">new</span> StringBuilder();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; subList.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    namesOfLength4.<span class="built_in">append</span>(subList.<span class="built_in">get</span>(i));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    namesOfLength4.<span class="built_in">append</span>(<span class="string">", "</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(subList.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    namesOfLength4.<span class="built_in">append</span>(subList.<span class="built_in">get</span>(subList.<span class="built_in">size</span>() - <span class="number">1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.<span class="built_in">println</span>(namesOfLength4);</span></pre></td></tr></table></figure>

<p>您理解此代码需要多少时间？如果时间比您预计的要长，不要惊讶。与其说这个时间反映了您的能力，不如说它反映了该代码的糟糕品质。<br>现在考虑一个使用 Java 8 支持的函数样式编写的等效示例：</p>
<p>清单 2. 函数式代码示例</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">as</span><span class="constructor">List(<span class="string">"Jack"</span>, <span class="string">"Jill"</span>, <span class="string">"Nate"</span>, <span class="string">"Kara"</span>, <span class="string">"Kim"</span>, <span class="string">"Jullie"</span>, <span class="string">"Paul"</span>, <span class="string">"Peter"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  names.stream<span class="literal">()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(name -&gt; name.length<span class="literal">()</span><span class="operator"> == </span><span class="number">4</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .collect(<span class="module-access"><span class="module"><span class="identifier">Collectors</span>.</span></span>joining(<span class="string">", "</span>)));</span></pre></td></tr></table></figure>

<p>您理解此代码会花用多少时间？显然，您已经确定了清单 1 的用途，所以这不是一次真正的实验。如果想真正比较这些示例，可以要求一些同事来理解一个或另一个代码示例，然后比较他们的回复时间。</p>
<h3 id="函数式编码为什么至关重要"><a href="#函数式编码为什么至关重要" class="headerlink" title="函数式编码为什么至关重要"></a>函数式编码为什么至关重要</h3><p>如果您熟悉 Java 8，可能会顺利理解清单 2 中的代码。即使不熟悉 Java 8，得益于描述性的方法名称，您可能也能理解它。您还能快速理解此代码，因为它比清单 1 简洁得多。<br>基本上讲，该代码的含义是：<em>给定一个名称集合，仅选择长度为 4 的名称，然后通过逗号将它们连接起来。</em><br>这个示例是人为的，但它确实证明了简洁性和表达能力在编码中的价值。我们在函数式代码中看到的这些品质比命令式代码中要多得多。</p>
<h2 id="编写可读的代码"><a href="#编写可读的代码" class="headerlink" title="编写可读的代码"></a>编写可读的代码</h2><p>函数式代码富于表达且简洁，这使程序不但更短，而且更容易阅读。考虑另一个示例：</p>
<p>清单 3. 命令式代码示例</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> result = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> e : numbers) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(e &gt; <span class="number">3</span> &amp;&amp; e % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; e &lt; <span class="number">8</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        result += e * <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.<span class="keyword">out</span>.println(result);</span></pre></td></tr></table></figure>

<p>给定名为 <code>numbers</code> 的列表，此代码将计算大于 3 且小于 8 的偶数并将该数字乘以 2，然后输出结果。该代码包含 7 行，我们可能可以减少一两行。<br>现在考虑 Java 8 中使用函数样式编写的相同代码：</p>
<p>清单 4. 一段替代性的函数式代码</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">System.out.println(</span></pre></td></tr><tr><td class="code"><pre><span class="line">   numbers.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">       .<span class="function"><span class="title">filter</span>(e -&gt;</span> e  &gt; <span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       .<span class="function"><span class="title">filter</span>(e -&gt;</span> e % <span class="number">2</span> == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       .<span class="function"><span class="title">filter</span>(e -&gt;</span> e &lt; <span class="number">8</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       .<span class="function"><span class="title">mapToInt</span>(e -&gt;</span> e * <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       .sum());</span></pre></td></tr></table></figure>

<p>清单 4 也为 7 行，但在这种情况下，进一步减少代码没有帮助。<br>函数式代码并不总是比命令式代码短。更重要的是它富于表达。简洁但难读的代码毫无帮助。</p>
<h2 id="不要犯这个错误"><a href="#不要犯这个错误" class="headerlink" title="不要犯这个错误"></a>不要犯这个错误</h2><p>函数式代码的设计目标是比命令式代码更简洁，但这不能保证它更可读。考虑下面这个示例：</p>
<p>清单 5. 联接选定名称的函数式代码</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(names.stream().<span class="keyword">filter</span>(<span class="type">name</span> -&gt; <span class="type">name</span>.startsWith("J")).<span class="keyword">filter</span>(<span class="type">name</span> -&gt; <span class="type">name</span>.length() &gt; <span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .map(<span class="type">name</span> -&gt; <span class="type">name</span>.toUpperCase()).collect(Collectors.joining(", ")));</span></pre></td></tr></table></figure>

<p>在清单 5 中，<code>filter</code>、<code>map</code> 和其他函数式元素增加了代码的表达能力。但您可能注意到，此代码让人感觉更加生硬，而不是更简洁。<br>尽管它只有两行，但此代码仍需要花大量精力来阅读和理解。您的眼睛需要努力寻找函数调用在何处结束，下一个调用从何处开始。该代码非常简短，但它编写得非常生硬。编写这种毫无帮助的代码只有一个理由：开发人员肯定憎恨与他共事的每个人。</p>
<h3 id="让您的代码简洁而不是生硬"><a href="#让您的代码简洁而不是生硬" class="headerlink" title="让您的代码简洁而不是生硬"></a>让您的代码简洁而不是生硬</h3><p>生硬的代码可能非常简短，但仍然很难读懂。简洁的代码也简短，但读起来让人感觉愉悦且容易理解。<br>在编程过程中，我们很容易忽略表达能力和可读性的价值。Java 8 通过约定来鼓励这些品质，建议我们对齐函数组合的垂直方向上的各点。<br>不幸的是，我观察到不熟悉 Java 8 的程序员常常忽略此约定，甚至在多次提醒后才想起它。经验更丰富的程序员应在代码评审期间执行此约定。优秀的 Java 8 IDE 也可以提供帮助，提供使用这类约定的快捷方式。<br>清单 6 展示了我们使用对齐约定重写清单 5 的代码的结果：</p>
<p>清单 6. Java 8 中的函数组合</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">System.out.println(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    names.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .<span class="function"><span class="title">filter</span>(<span class="keyword">name</span> -&gt;</span> <span class="keyword">name</span>.startsWith(<span class="string">"J"</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .<span class="function"><span class="title">filter</span>(<span class="keyword">name</span> -&gt;</span> <span class="keyword">name</span>.length() &gt; <span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .<span class="function"><span class="title">map</span>(<span class="keyword">name</span> -&gt;</span> <span class="keyword">name</span>.toUpperCase())</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .collect(Collectors.joining(<span class="string">", "</span>)));</span></pre></td></tr></table></figure>

<p>在这里，我们看到了来自清单 5 的同一段生硬的代码，但各个点已在垂直方向上对齐，而且我们抵抗住了将多个条件组合到一个参数中的诱惑。结果，每行都具有凝聚力：范围狭小而专注，仅含一个明确的任务。</p>
<h2 id="一种有帮助的约定"><a href="#一种有帮助的约定" class="headerlink" title="一种有帮助的约定"></a>一种有帮助的约定</h2><p>尽管可能看似可有可无，但遵循 Java 8 的对齐约定肯定非常有益。</p>
<ul>
<li>遵循此约定的代码更容易阅读、理解和解释。我们可以在详细检查每部分之前，快速掌握整个目标。</li>
<li>元素非常明确且容易找到，有助于更快地修改。如果我们想包含另一个条件，或者删除或修改一个现有条件，那么可以相对容易找到该行并执行更改。</li>
<li>该代码更容易维护，这表明我们关心团队的其他开发人员。除了让代码更容易维护之外，编写有帮助的代码还能显著提高团队士气。</li>
</ul>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>保持每行代码都简短紧凑是一种不错的做法，但是走极端可能导致代码变得生硬难读。要提高表达能力，可以问自己代码是否容易理解。要提高可读性，可采用 Java 8 垂直对齐各点的约定。使用这些简单技巧，就能创建出简洁、富于表达且可读的函数式代码。</p>
<blockquote>
<p>作者：Venkat Subramaniam</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms4/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms4/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8 习惯用语（3）：传统 for 循环的函数式替代方案</title>
    <url>/2019/12/26/Java-8-%E4%B9%A0%E6%83%AF%E7%94%A8%E8%AF%AD%EF%BC%883%EF%BC%89%EF%BC%9A%E4%BC%A0%E7%BB%9F-for-%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>尽管 <code>for</code> 循环包含许多可变部分，但许多开发人员仍非常熟悉它，并会不假思索地使用它。从 Java™ 8 开始，我们有多个强大的新方法可帮助简化复杂迭代。在本文中，您将了解如何使用 <code>IntStream</code> 方法 <code>range</code>、<code>iterate</code> 和 <code>limit</code> 来迭代范围和跳过范围中的值。您还将了解新的 <code>takeWhile</code> 和 <code>dropWhile</code> 方法（即将在 Java 9 中引入）。</p>
<p><strong>关于本系列</strong><br>Java 8 是自 Java 语言诞生以来进行的一次最重大更新 — 包含了非常丰富的新功能，您可能想知道从何处开始着手了解它。在本系列中，作家兼教师 Venkat Subramaniam 提供了一种惯用的 Java 8 编程方法：这些简短的探索会激发您反思您认为理所当然的 Java 约定，同时逐步将新技术和语法集成到您的程序中。</p>
<a id="more"></a>

<h2 id="for-循环的麻烦"><a href="#for-循环的麻烦" class="headerlink" title="for 循环的麻烦"></a>for 循环的麻烦</h2><p>在 Java 语言的第 1 个版本中就开始引入了传统的 <code>for</code> 循环，它的更简单的变体 <code>for-each</code> 是在 Java 5 中引入的。大部分开发人员更喜欢使用 <code>for-each</code> 执行日常迭代，但对于迭代一个范围或跳过范围中的值等操作，他们仍会使用 <code>for</code>。<br><code>for</code> 循环非常强大，但它包含太多可变部分。甚至在打印 <code>get set</code> 提示的最简单任务中，也可以看出这一点：</p>
<p>清单 1. 完成一个简单任务的复杂代码</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.print("Get set...");</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.print(i + "...");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在清单 1 中，我们从 1 开始循环处理索引变量 <code>i</code>，将它限制到小于 4 的值。请注意，<code>for</code> 循环需要我们告诉循环是递增的。在本例中，我们还选择了前递增而不是后递增。<br>清单 1 中没有太多代码，但比较繁琐。Java 8 提供了一种更简单、更优雅的替代方法：<code>IntStream</code> 的 <code>range</code> 方法。以下是打印清单 1 中的相同 <code>get set</code> 提示的 <code>range</code>方法：</p>
<p>清单 2. 完成一个简单任务的简单代码</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(<span class="string">"Get set..."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">IntStream</span>.</span></span>range(<span class="number">1</span>, <span class="number">4</span>).for<span class="constructor">Each(<span class="params">i</span> -&gt; System.<span class="params">out</span>.<span class="params">print</span>(<span class="params">i</span> + <span class="string">"..."</span>)</span>);</span></pre></td></tr></table></figure>

<p>在清单 2 中，我们看到并没有显著减少代码量，但降低了它的复杂性。这样做有两个重要原因：</p>
<ol>
<li>不同于 <code>for</code>，<code>range</code> 不会强迫我们初始化某个可变变量。</li>
<li>迭代会自动执行，所以我们不需要像循环索引一样定义增量。</li>
</ol>
<p>在语义上，最初的 <code>for</code> 循环中的变量 <code>i</code> 是一个<em>可变变量</em>。理解 <code>range</code> 和类似方法的价值对理解该设计的结果很有帮助。</p>
<h2 id="可变变量与参数"><a href="#可变变量与参数" class="headerlink" title="可变变量与参数"></a>可变变量与参数</h2><p><code>for</code> 循环中定义的变量 <code>i</code> 是单个变量，它会在每次对循环执行迭代时发生改变。<code>range</code> 示例中的变量 <code>i</code> 是拉姆达表达式的参数，所以它在每次迭代中都是一个全新的变量。这是一个细微区别，但决定了两种方法的不同。以下示例有助于阐明这一点。<br>清单 3 中的 <code>for</code> 循环想在一个内部类中使用索引变量：</p>
<p>清单 3. 在内部类中使用索引变量</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="type">int</span> <span class="keyword">temp</span> = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    executorService.submit(<span class="built_in">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">public</span> <span class="type">void</span> run() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            //<span class="keyword">If</span> uncommented the next <span class="type">line</span> will result <span class="keyword">in</span> an error</span></pre></td></tr><tr><td class="code"><pre><span class="line">            //<span class="keyword">System</span>.<span class="keyword">out</span>.println("Running task " + i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            //<span class="keyword">local</span> variables referenced <span class="keyword">from</span> an <span class="keyword">inner</span> <span class="keyword">class</span> must be final <span class="keyword">or</span> effectively final</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.println("Running task " + <span class="keyword">temp</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">executorService.shutdown();</span></pre></td></tr></table></figure>

<p>我们有一个匿名的内部类实现了 <code>Runnable</code> 接口。我们想在 <code>run</code> 方法中访问索引变量 <code>i</code>，但编译器不允许这么做。<br>作为此限制的解决办法，我们可以创建一个局部临时变量，比如 <code>temp</code>，它是索引变量的一个副本。每次新的迭代都会创建变量 <code>temp</code>。在 Java 8 以前，我们需要将该变量标记为 <code>final</code>。从 Java 8 开始，可以将它视为实际的最终结果，因为我们不会再更改它。无论如何，由于事实上索引变量是一个在迭代中改变的变量，<code>for</code> 循环中就会出现这个额外变量。<br>现在尝试使用 <code>range</code> 函数解决同一个问题。</p>
<p>清单 4. 在内部类中使用拉姆达参数</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">5</span>).<span class="keyword">forEach</span>(i -&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    executorService.submit(<span class="built_in">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">public</span> <span class="type">void</span> run() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.println("Running task " + i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;));</span></pre></td></tr><tr><td class="code"><pre><span class="line">executorService.shutdown();</span></pre></td></tr></table></figure>

<p>在作为一个参数被拉姆达表达式接受后，索引变量 <code>i</code> 的语义与循环索引变量有所不同。与清单 3 中手动创建的 <code>temp</code> 非常相似，这个 <code>i</code> 参数在每次迭代中都表现为一个全新的变量。它是<em>实际最终变量</em>，因为我们不会在任何地方更改它的值。因此，我们可以直接在内部类的上下文中使用它 — 且不会有任何麻烦。<br>因为 <code>Runnable</code> 是一个函数接口，所以我们可以轻松地将匿名的内部类替换为拉姆达表达式，比如：</p>
<p>清单 5. 将内部类替换为拉姆达表达式</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">5</span>).forEach(i<span class="function"> -&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    executorService.submit<span class="function"><span class="params">(() -&gt; System.out.println(<span class="string">"Running task "</span> + i))</span>);</span></span></pre></td></tr></table></figure>

<p>显然，对于相对简单的迭代，使用 <code>range</code> 代替 <code>for</code> 具有一定优势，但 <code>for</code> 的特殊价值体现在于它能处理更复杂的迭代场景。让我们看看 <code>range</code> 和其他 Java 8 方法孰优孰劣。</p>
<h2 id="封闭范围"><a href="#封闭范围" class="headerlink" title="封闭范围"></a>封闭范围</h2><p>创建 <code>for</code> 循环时，可以将索引变量封闭在一个范围内，比如：</p>
<p>清单 6. 一个具有封闭范围的 for 循环</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span></pre></td></tr></table></figure>

<p>索引变量 <code>i</code> 接受值 <code>0</code>、<code>1</code>、……<code>5</code>。无需使用 <code>for</code>，我们可以使用 <code>rangeClosed</code> 方法。在本例中，我们告诉 <code>IntStream</code> 将最后一个值限制在该范围内：</p>
<p>清单 7. rangeClosed 方法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">IntStream</span>.</span></span>range<span class="constructor">Closed(0, 5)</span></span></pre></td></tr></table></figure>

<p>迭代此范围时，我们会获得包含边界值 5 在内的值。</p>
<h2 id="跳过值"><a href="#跳过值" class="headerlink" title="跳过值"></a>跳过值</h2><p>对于基本循环，<code>range</code> 和 <code>rangeClosed</code> 方法是 <code>for</code> 的更简单、更优雅的替代方法，但是如果想跳过一些值该怎么办？在这种情况下，<code>for</code> 对前期工作的需求使该运算变得非常容易。在清单 8 中，<code>for</code> 循环在迭代期间快速跳过两个值：</p>
<p>清单 8. 使用 for 跳过值</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> total = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i = i + <span class="number">3</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    total += i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>清单 8 中的循环在 1 到 100 内对每次读到的第三个值作求和计算 — 这种复杂运算可使用 <code>for</code> 轻松完成。能否也使用 <code>range</code> 解决此问题？<br>首先，可以考虑使用 <code>IntStream</code> 的 <code>range</code> 方法，再结合使用 <code>filter</code> 或 <code>map</code>。但是，所涉及的工作比使用 <code>for</code> 循环要多。一种更可行的解决方案是结合使用 <code>iterate</code> 和 <code>limit</code>：</p>
<p>清单 9. 使用 limit 的迭代</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">IntStream.iterate(<span class="number">1</span>, e -&gt; e + <span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .limit(<span class="number">34</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .sum()</span></pre></td></tr></table></figure>

<p><code>iterate</code> 方法很容易使用；它只需获取一个初始值即可开始迭代。作为第二参数传入的拉姆达表达式决定了迭代中的下一个值。这类似于清单 8，我们将一个表达式传递给 <code>for</code> 循环来递增索引变量的值。但是，在本例中有一个<em>陷阱</em>。不同于 <code>range</code> 和 <code>rangeClosed</code>，没有参数来告诉 <code>iterate</code> 方法何时停止迭代。如果我们没有限制该值，迭代会一直进行下去。<br>如何解决这个问题？<br>我们对 1 到 100 之间的值感兴趣，而且想从 1 开始跳过两个值。稍加运算，即可确定给定范围中有 34 个符合要求的值。所以我们将该数字传递给 <code>limit</code> 方法。<br>此代码很有效，但过程太复杂：提前执行数学运算不那么有趣，而且它限制了我们的代码。如果我们决定跳过 3 个值而不是 2 个值，该怎么办？我们不仅需要更改代码，结果也很容易出错。我们需要有一个更好的方法。</p>
<h2 id="takeWhile-方法"><a href="#takeWhile-方法" class="headerlink" title="takeWhile 方法"></a>takeWhile 方法</h2><p>Java 9 中即将引入的 <code>takeWhile</code> 是一个新方法，它使得执行有限制的迭代变得更容易。使用 <code>takeWhile</code>，可以直接表明<em>只要满足想要的条件</em>，迭代就应该继续执行。以下是使用 <code>takeWhile</code> 实现清单 9 中的迭代的代码。</p>
<p>清单 10. 有条件的迭代</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">IntStream</span>.</span></span>iterate(<span class="number">1</span>, e -&gt; e + <span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">     .take<span class="constructor">While(<span class="params">i</span> -&gt; <span class="params">i</span> &lt;= 100)</span> <span class="comment">//available in Java 9</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     .sum<span class="literal">()</span></span></pre></td></tr></table></figure>

<p>无需将迭代限制到预先计算的次数，我们使用提供给 <code>takeWhile</code> 的条件，动态确定何时终止迭代。与尝试预先计算迭代次数相比，这种方法简单得多，而且更不容易出错。<br>与 <code>takeWhile</code> 方法相反的是 <code>dropWhile</code>，它跳过满足给定条件前的值，这两个方法都是 JDK 中非常需要的补充方法。<code>takeWhile</code> 方法类似于 break，而 <code>dropWhile</code> 则类似于 continue。从 Java 9 开始，它们将可用于任何类型的 <code>Stream</code>。</p>
<h2 id="逆向迭代"><a href="#逆向迭代" class="headerlink" title="逆向迭代"></a>逆向迭代</h2><p>与正向迭代相比，逆向迭代同样非常简单，无论使用传统的 <code>for</code> 循环还是 <code>IntStream</code>。<br>以下是一个逆向的 <code>for</code> 循环迭代：</p>
<p>清单 11. 使用 for 的逆向迭代</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">7</span>; i &gt; <span class="number">0</span>; i--) &#123;</span></pre></td></tr></table></figure>

<p><code>range</code> 或 <code>rangeClosed</code> 中的第一个参数不能大于第二个参数，所以我们无法使用这两种方法来执行逆向迭代。但可以使用 <code>iterate</code> 方法：</p>
<p>清单 12. 使用 iterate 的逆向迭代</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">IntStream.iterate(<span class="number">7</span>, e -&gt; e - <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">     .limit(<span class="number">7</span>)</span></pre></td></tr></table></figure>

<p>将一个拉姆达表达式作为参数传递给 <code>iterate</code> 方法，该方法对给定值进行递减，以便沿相反方向执行迭代。我们使用 <code>limit</code> 函数指定我们希望在逆向迭代期间看到总共多少个值。如有必要，还可以使用 <code>takeWhile</code> 和 <code>dropWhile</code> 方法来动态调整迭代流。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>尽管传统 <code>for</code> 循环非常强大，但它有些过于复杂。Java 8 和 Java 9 中的新方法可帮助简化迭代，甚至是简化复杂的迭代。方法 <code>range</code>、<code>iterate</code> 和 <code>limit</code> 的可变部分较少，这有助于提高代码效率。这些方法还满足了 Java 的一个长期以来的要求，那就是局部变量必须声明为 final，然后才能从内部类访问它。将一个可变索引变量更换为实际的 final 参数只有很小的语义差别，但它减少了大量垃圾变量。最终您会得到更简单、更优雅的代码。</p>
<blockquote>
<p>作者：Venkat Subramaniam</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms3/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms3/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8 习惯用语（2）：函数组合与集合管道模式</title>
    <url>/2019/12/26/Java-8-%E4%B9%A0%E6%83%AF%E7%94%A8%E8%AF%AD%EF%BC%882%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88%E4%B8%8E%E9%9B%86%E5%90%88%E7%AE%A1%E9%81%93%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在开始采用函数式编程风格时，您的程序中会自然而然地出现一些函数设计模式，但您仍需要努力掌握它们。本文将介绍函数组合和集合管道，您可以结合使用这两种函数式模式来迭代代码中的集合。了解这些模式的结构有助于您搭建自己的 Java™ 程序，从而充分利用高阶函数和拉姆达表达式。</p>
<p><strong>关于本系列</strong>Java 8 是自 Java 语言诞生以来进行的一次最重大更新 — 包含了非常丰富的新功能，您可能想知道从何处开始着手了解它。在本系列中，作家兼教师 Venkat Subramaniam 提供了一种惯用的 Java 8 编程方法：这些简短的探索会激发您反思您认为理所当然的 Java 约定，同时逐步将新技术和语法集成到您的程序中。</p>
<a id="more"></a>

<h2 id="语句与表达式"><a href="#语句与表达式" class="headerlink" title="语句与表达式"></a>语句与表达式</h2><p>如果在代码库中快速查找 <code>for</code>，您可能会惊奇地发现，您的代码中对 <code>for</code> 循环的使用非常频繁。我将这种情形称为 <em><code>for</code>重复(hammer)</em>：只要我们需要循环，似乎就会用到 <code>for</code>。<br>在 Java 中，<code>for</code> 和 <code>while</code> 都是语句。<em>语句</em>执行一个操作，但不会生成任何结果。就本质而言，任何执行有用的操作的语句都会导致数据变化。这是语句表达其效果的唯一方式。而<em>表达式</em>则相反：它们可以得出结果而不会导致变化。<br>在代码中使用语句就像是合作处理一部分工作，但无法在团队成员之间直接转交工作结果。分享结果的唯一方法是将它放在桌面上或架子上，让另一位团队成员可以获得它。表达式的工作更像一条链：当某个人完成一项任务时，他将结果转交给链中的下一个人。<br>表达式帮助实现了集合管道模式，Martin Fowler 将该模式描述为<a href="https://martinfowler.com/articles/collection-pipeline" target="_blank" rel="noopener">运算序列</a>，会将从一次运算收集的输出提供给下一次运算。尽管面向对象的编程中使用了集合管道模式（您可能在使用对象构建器的代码中看到过它），但它在函数编程中更常见。<br>函数组合和集合管道模式是两种可协同工作的模式。下一节将使用熟悉的 <code>for</code> 语句解决一个问题。然后将介绍如何使用这两种模式更高效地解决同一个问题。</p>
<h2 id="使用语句进行迭代和排序"><a href="#使用语句进行迭代和排序" class="headerlink" title="使用语句进行迭代和排序"></a>使用语句进行迭代和排序</h2><p>首先创建一个 <code>Car</code> 类，它包含属性 make、model 和 year：</p>
<p>清单 1. 一个 Car 类</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package agiledeveloper;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> make;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> model;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> year;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="keyword">String</span> theMake, <span class="keyword">String</span> theModel, <span class="keyword">int</span> yearOfMake)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        make = theMake;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        model = theModel;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        year = yearOfMake;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getMake</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> make;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> model;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getYear</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> year;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们可以添加一个 <code>Car</code> 实例集合，比如：</p>
<p>清单 2. 一个 Car 实例集合</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> agiledeveloper;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Comparator.comparing;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.toList;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iterating</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Car&gt; createCars() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Arrays.asList(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">new</span> <span class="type">Car</span>(<span class="string">"Jeep"</span>, <span class="string">"Wrangler"</span>, <span class="number">2011</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">new</span> <span class="type">Car</span>(<span class="string">"Jeep"</span>, <span class="string">"Comanche"</span>, <span class="number">1990</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">new</span> <span class="type">Car</span>(<span class="string">"Dodge"</span>, <span class="string">"Avenger"</span>, <span class="number">2010</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">new</span> <span class="type">Car</span>(<span class="string">"Buick"</span>, <span class="string">"Cascada"</span>, <span class="number">2016</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">new</span> <span class="type">Car</span>(<span class="string">"Ford"</span>, <span class="string">"Focus"</span>, <span class="number">2012</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">new</span> <span class="type">Car</span>(<span class="string">"Chevrolet"</span>, <span class="string">"Geo Metro"</span>, <span class="number">1992</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在清单 3 中，我们使用命令式编程来迭代该列表，并获取 2000 年后制造的汽车的名称。然后按年份对这些型号进行升序排序。</p>
<p>清单 3. 使用 ‘for’ 按年份对各种型号进行排序</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static List&lt;String&gt; get<span class="constructor">ModelsAfter2000UsingFor(List&lt;Car&gt; <span class="params">cars</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;Car&gt; carsSortedByYear = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for(Car car : cars) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(car.get<span class="constructor">Year()</span> &gt; <span class="number">2000</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            carsSortedByYear.add(car);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Collections</span>.</span></span>sort(carsSortedByYear, <span class="keyword">new</span> Comparator&lt;Car&gt;<span class="literal">()</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        public <span class="built_in">int</span> compare(Car car1, Car car2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return <span class="keyword">new</span> <span class="constructor">Integer(<span class="params">car1</span>.<span class="params">getYear</span>()</span>).compare<span class="constructor">To(<span class="params">car2</span>.<span class="params">getYear</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;String&gt; models = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for(Car car : carsSortedByYear) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        models.add(car.get<span class="constructor">Model()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return models;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr></table></figure>

<p>如您所见，此代码中有许多循环。首先，<code>getModelsAfter2000UsingFor</code> 方法接受一个汽车列表作为参数。它提取或过滤出 2000 年后制造的汽车，将它们放在一个名为 <code>carsSortedByYear</code> 的新列表中。接下来，按照制造年份对该列表进行升序排序。最后，循环处理列表 <code>carsSortedByYear</code>，以获取型号名称，并在一个列表中返回它们。<br>能否提高这段代码的效率？我们可以通过一次性对所有汽车排序来消除一个 <code>for</code> 循环，但随后需要对一个更大的对象列表进行排序。<br>这是汽车列表示例的输出：</p>
<p>清单 4. getModelsAfter2000UsingFor 的输出</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Avenger,</span> Wrangler, Focus, Cascada</span></pre></td></tr></table></figure>

<p>这个排序示例演示了我所称的<em>语句的效果</em>。尽管函数和方法通常可用作表达式，但 <code>Collections``sort</code> 方法没有返回结果。因为它被用作语句，所以它改变了作为参数提供的列表。两个 <code>for</code> 循环在迭代时都改变了相应的列表。作为语句，这是这些元素的工作方式。因此，该代码包含不必要的垃圾变量，如图 1 所示。</p>
<p>图 1. 语句的效果</p>
<p><img src="http://image.winrains.cn/2019/08/a255b-fig1.png" alt="img"></p>
<h2 id="使用集合管道进行迭代和排序"><a href="#使用集合管道进行迭代和排序" class="headerlink" title="使用集合管道进行迭代和排序"></a>使用集合管道进行迭代和排序</h2><p>在函数编程中，通常会通过一系列更小的模块化函数或运算来对复杂运算进行排序。该系列被称为<em>函数组合</em>（composition of functions, or a function composition）。当一个数据集合流经一个函数组合时，它就变成一个集合管道。函数组合和集合管道是函数式编程中常用的两种设计模式。<br>无需使用一个很大的 <code>for</code> 重复（ hammer ），依据手头的问题，我们能使用多种专业工具。无需像命令式编程中常见的那样对所有运算都使用语句，函数式编程鼓励使用表达式。表达式没有语句所拥有的改变对象的副作用。像 <code>filter</code> 或 <code>map</code> 这样的表达式也返回一个结果，我们可以将它传递给另一个函数，我们就是通过这种方式创建集合管道的。考虑清单 5 中的代码。</p>
<p>清单 5. 集合管道模式中的函数组合</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> static <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; getModelsAfter2000UsingPipeline(</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="built_in">List</span>&lt;Car&gt; cars) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     cars.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">         .filter(car -&gt; car.getYear() &gt; <span class="number">2000</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">         .sorted(Comparator.comparing(Car<span class="type">::getYear</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">         .<span class="built_in">map</span>(Car<span class="type">::getModel</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">         .collect(toList());</span></pre></td></tr><tr><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr></table></figure>

<p>方法 <code>getModelsAfter2000UsingPipeline</code> 生成的结果与 清单 3 中的方法 <code>getModelsAfter2000UsingFor</code> 相同，但要注意代码中的不同之处：</p>
<ul>
<li>函数式代码比命令式代码更简洁。</li>
<li>函数式代码不会表现出明显的易变性，而且使用了更少的垃圾变量。</li>
<li>第二个方法中使用的函数/方法都是有返回值的表达式。将此方法与 清单 3 中的 <code>Collections.sort</code> 方法进行对比。</li>
<li><code>getModelsAfter2000UsingPipeline</code> 使用了集合管道模式，而且非常富于表达。</li>
</ul>
<p>只用了短短几行代码，代码的意图就很明显 — 给定一个汽车集合，过滤或提取仅在 2000 年或以后制造的汽车；然后按年份进行排序，将这些对象映射或转换为它们的型号，最后将结果收集到一个列表中。<br>清单 5 中的代码如此简洁且富于表达，部分原因是使用了方法引用。将一个拉姆达表达式传递给 <code>filter</code> 很有用，因为它可以获取给定对象的 year 属性并将其与 year 2000 进行比较。但是，将拉姆达表达式传递给 <code>map</code> 就没有这么有效。传递给 <code>map</code> 方法的表达式为 <code>car -&gt; car.getModel()</code>，该表达式非常繁琐。该拉姆达表达式仅返回给定对象的某个属性，不执行任何实际计算或运算。我们最好将它替换为一个方法引用。<br>我们将方法引用 <code>Car::getModel</code> 传递给 <code>map</code> 方法，而不传递拉姆达表达式。类似地，我们将方法引用 <code>Car::getYear</code> 传递给 comparing 方法，而不传递拉姆达表达式 <code>car -&gt; car.getYear()</code>。方法引用简短、简洁且富于表达。最好尽可能地使用它们。<br>图 2 给出了清单 5 中的集合管道。</p>
<p>图 2. 集合管道的魅力</p>
<p><img src="http://image.winrains.cn/2019/08/55ced-fig2.png" alt="img"><br>查看图 2，可以看到 <code>getModelsAfter2000UsingPipeline</code> 函数如何执行集合管道，通过一系列函数转换给定输入。随着数据流经各个函数，Java 8 的惰性计算和函数融合功能（参阅 2014 年的 <a href="https://pragprog.com/book/vsjava8/functional-programming-in-java" target="_blank" rel="noopener"><em>Java 中的函数编程</em></a>）可帮助避免在某些情况下创建中间对象。数据在管道中传输时，函数不会使中间对象变得可见或可用。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>在命令式编程中，对于大部分数据处理，通常都会使用 <code>for</code> 和 <code>while</code> 循环。在本文中，您了解了一种在函数式编程中非常流行的替代方法。函数组合是一项简单技术，有助于对模块化函数进行排序，从而创建更复杂的运算。按该序列处理数据时，您就有了一个集合管道。结合使用函数组合和集合管道模式，可以创建复杂的程序，让数据从上游流到下游，并经历一系列转换。</p>
<blockquote>
<p>作者：Venkat Subramaniam</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms2/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms2/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8 习惯用语（1）：函数式编程</title>
    <url>/2019/12/26/Java-8-%E4%B9%A0%E6%83%AF%E7%94%A8%E8%AF%AD%EF%BC%881%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>Java 开发人员早已习惯了命令式编程和面向对象的编程，因为 Java 语言从第一个版本开始就支持这些格式。在 Java 8 中，我们获得了一组强大的新的函数特性和语法。函数式编程已有数十年的历史，而且与面向对象的编程相比，函数式编程通常更简洁、更具表达力、更不容易出错，而且更容易并行化。所以在 Java 程序中引入函数特性是有充分理由的。尽管如此，函数式的编程需要对代码的设计方式进行一些改变。</p>
<p><strong>关于本系列</strong>Java 8 是自 Java 语言诞生以来进行的一次最重大更新 — 包含了非常丰富的新功能，您可能想知道从何处开始着手了解它。在本系列中，作者兼教师 Venkat Subramaniam 提供了一种惯用的 Java 8 编程方法：这些简短的探索会激发您反思您认为理所当然的 Java 约定，同时逐步将新方法和语法集成到您的程序中。</p>
<a id="more"></a>

<p>我发现声明式思考（而不是命令式思考）可以简化向更加函数化编程的过渡。在新的 <a href="https://www.ibm.com/developerworks/cn/views/global/libraryview.jsp?sort_by=&show_abstract=true&show_all=&search_flag=&contentarea_by=Jamp;ava+technology&search_by=Java+8++习惯用语&topic_by=-1&type_by=所有类别&ibm-search=搜索" target="_blank" rel="noopener"><em>Java 8 习惯用语</em> 系列</a> 的第一篇文章中，我将解释命令式、声明式和函数式编程之间的区别和共性。然后，将展示如何使用声明式思考方式逐步将函数方法集成到 Java 程序中。</p>
<h2 id="命令式格式"><a href="#命令式格式" class="headerlink" title="命令式格式"></a>命令式格式</h2><p>经过针对命令式编程培训的开发人员已经习惯了告诉程序做什么和该如何做。这是一个简单示例：</p>
<p>清单 1. findNemo in the imperative style</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindNemo</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;<span class="keyword">String</span>&gt; names = Arrays.asList(<span class="string">"Dory"</span>, <span class="string">"Gill"</span>, <span class="string">"Bruce"</span>, <span class="string">"Nemo"</span>, <span class="string">"Darla"</span>, <span class="string">"Marlin"</span>, <span class="string">"Jacques"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        findNemo(names);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findNemo</span><span class="params">(List&lt;<span class="keyword">String</span>&gt; names)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">boolean</span> found = <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">String</span> name : names) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (name.equals(<span class="string">"Nemo"</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                found = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (found)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"Found Nemo"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"Sorry, Nemo not found"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>findNemo()</code> 方法首先初始化一个可变的<em>flag</em> 变量，也称为<em>垃圾（garbage）变量</em>。开发人员通常会随便给这些变量命名，比如 <code>f</code>、<code>t</code> 或 <code>temp</code>，这些名称表明了我们对这些变量不应存在的一般态度。在本例中，该变量名为 <code>found</code>。<br>接下来，该程序会在给定的 <code>names</code> 列表中循环，一次处理一个元素。它检查获得的名称是否与它寻找的值（在本例中为 <code>Nemo</code>）相等。如果值匹配，那么它会将 flag 变量设置为 <code>true</code>，并通知控制流“跳出”循环。<br>因为这是一个命令式编程的程序 — 许多 Java 开发人员最熟悉的格式 — 所以您需要定义程序的每一步：告诉它迭代每个元素，比较值，设置 flag 变量，然后跳出循环。命令式格式为您提供了完全的控制权，这有时是件好事。而另一方面，您需要执行所有工作。在许多情况下，可以减少工作量来提高效率。</p>
<h2 id="声明式格式"><a href="#声明式格式" class="headerlink" title="声明式格式"></a>声明式格式</h2><p>声明式编程意味着，您仍会告诉程序要做什么，但将实现细节留给底层的函数库。让我们看看用声明式格式重新编写来自 [清单 1](<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单</a> 1) 的 <code>findNemo</code> 方法时，会发生什么：</p>
<p>清单 2. findNemo in the declarative style</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findNemo</span><span class="params">(List&lt;<span class="keyword">String</span>&gt; names)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(names.contains(<span class="string">"Nemo"</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Found Nemo"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Sorry, Nemo not found"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>首先请注意，这个版本中没有任何垃圾变量。您也没有将精力浪费在对集合的循环处理上，而是使用内置的 <code>contains()</code> 方法来完成工作。您仍然需要告诉程序要做什么 — 检查集合是否包含我们寻找的值 — 但将细节留给底层的方法。<br>在命令式示例中，您控制着迭代，而且程序完全按照要求来操作。在声明式版本中，您无需关心工作如何完成，只要它完成即可。<code>contains()</code> 的实现可能不同，但只要结果符合预期，您可能就会很开心。花更少的精力获得同样的结果。<br>训练自己以声明式编程思考，这将大大简化向 Java 中的函数式编程的过渡。为什么呢？因为函数式编程是以声明式为基础而建立的。声明式思考试图逐步从命令式编程过渡到函数式编程。</p>
<h2 id="函数式格式"><a href="#函数式格式" class="headerlink" title="函数式格式"></a>函数式格式</h2><p>尽管函数式格式的编程始终是声明式的，但简单地使用声明式编程并不等于函数式编程。这是因为函数式编程合并了声明式方法与高阶函数。图 1 直观地展示了命令式、声明式和函数式编程之间的关系。</p>
<p>图 1. 命令式、声明式和函数式编程的联系</p>
<p><img src="http://image.winrains.cn/2019/08/78336-fig1.jpg" alt="命令式、声明式和函数式编程风格之间的区别和重叠的逻辑图。"></p>
<h3 id="Java-中的高阶函数"><a href="#Java-中的高阶函数" class="headerlink" title="Java 中的高阶函数"></a>Java 中的高阶函数</h3><p>在 Java 中，要将对象传递给方法，在方法内创建对象，并从方法中返回对象。可以对函数执行同样的操作。也就是说，可以将函数传递给方法，在方法内创建函数，并从方法返回函数。<br>在此上下文中，<em>方法</em> 是类的一部分 — 静态或实例 — 但函数对于方法而言是本地函数，不能特意与类或实例关联。可以接收、创建或返回函数的函数或方法被视为<em>高阶函数</em>。</p>
<h2 id="函数式编程示例"><a href="#函数式编程示例" class="headerlink" title="函数式编程示例"></a>函数式编程示例</h2><p>采用新编程的格式需要改变您思考程序的方式。可以通过简单的示例来实践这一过程，并逐步建立更复杂的程序。</p>
<p>清单 3. A Map in the imperative style</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseMap</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Map&lt;<span class="keyword">String</span>, Integer&gt; pageVisits = <span class="keyword">new</span> HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">String</span> page = <span class="string">"https://agiledeveloper.com"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        incrementPageVisit(pageVisits, page);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        incrementPageVisit(pageVisits, page);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(pageVisits.<span class="built_in">get</span>(page));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">incrementPageVisit</span><span class="params">(Map&lt;<span class="keyword">String</span>, Integer&gt; pageVisits, <span class="keyword">String</span> page)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!pageVisits.containsKey(page)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pageVisits.<span class="built_in">put</span>(page, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pageVisits.<span class="built_in">put</span>(page, pageVisits.<span class="built_in">get</span>(page) + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在 [清单 3](<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单</a> 3) 中，<code>main()</code> 函数创建了一个 <code>HashMap</code>，其中包含一个网站的页面访问次数。同时，每次访问给定页面，<code>incrementPageVisit()</code> 方法都会增加计数。我们将重点查看此方法。<br><code>incrementPageVisit()</code> 方法是使用命令式格式编写的：它的职责是递增给定页面的计数，将该计数存储在 <code>Map</code> 中。该方法不知道给定页面是否有计数，所以它首先会检查是否存在计数。如果不存在，那么它会插入一个 “0” 作为该页面的计数。然后获得该计数，递增它，并将新值存储在 <code>Map</code> 中。<br>声明式思考要求您将此方法的设计思路从 “如何做” 转变为 “做什么”。当调用方法 <code>incrementPageVisit()</code> 时，您希望将给定页面的计数初始化为 1 或将运行值递增 1。这就是<em>做什么<em>。<br>因为您在执行声明式编程，所以下一步是扫描 JDK 库，查找 <code>Map</code> 接口中可以完成您的目标的方法 — 也就是说，寻找一个知道</em>如何</em> 完成给定任务的内置方法。<br>事实证明，<code>merge()</code> 方法能完美实现您的目标。清单 4 使用新的声明式方法修改来自 [清单 3](<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单</a> 3) 的 <code>incrementPageVisit()</code> 方法。但是，在本例中，并不仅仅通过选择更智能的方法采用更加声明式的格式编程；因为 <code>merge()</code> 是一个高阶函数，所以新代码实际上是一个不错的函数式编程示例：</p>
<p>清单 4. A Map in the functional style</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">incrementPageVisit</span><span class="params">(Map&lt;<span class="keyword">String</span>, Integer&gt; pageVisits, <span class="keyword">String</span> page)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pageVisits.merge(page, <span class="number">1</span>, (oldValue, value) -&gt; oldValue + value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在清单 4 中，<code>page</code> 作为第一个参数传递给 <code>merge()</code>：该键的值应该更新。第二个参数是给该键分配的初始值，<em>如果</em><code>Map</code> 中不存在该键（在本例中，该值为 “1”）。第三个参数（一个拉姆达表达式）接收 map 中该键对应的值作为其参数，并且将该值作为变量传递给 merge 方法中的第二个参数。 这个拉姆达表达式返回的是它的参数的和，实际上就是递增计数。<br>比较[清单 4](<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单</a> 4) 中的 <code>incrementPageVisit()</code> 方法中的一行代码与 [清单 3](<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单</a> 3) 中的多行代码。[清单 4](<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单</a> 4) 中的程序是一个函数式编程示例，由此可见声明式考虑问题有助于我们的跳跃性思维。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>在 Java 程序中采用函数式方法和语法有许多好处：代码简洁，更富于表达，不易出错，更容易并行化，而且通常比面向对象的代码更容易理解。我们面临的挑战在于将思维方式从命令式编程 — 绝大多数开发人员都熟悉它 — 转变为声明式思考。<br>尽管函数式编程不那么容易或直观，但您可以通过学习关注您想要程序实现的<em>目的</em> 而不是关注您希望它执行的<em>方式</em>，从而实现思维上的巨大飞跃。通过允许底层函数库管理执行代码，您将逐步直观地了解高阶函数，它们是函数式编程的构建基块。</p>
<blockquote>
<p>作者：Venkat Subramaniam</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8 习惯用语（0）：函数纯度</title>
    <url>/2019/12/26/Java-8-%E4%B9%A0%E6%83%AF%E7%94%A8%E8%AF%AD%EF%BC%880%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0%E7%BA%AF%E5%BA%A6/</url>
    <content><![CDATA[<p>在本系列前面的部分中，我介绍了<a href="https://www.ibm.com/developerworks/library/j-java8idioms2/index.html" target="_blank" rel="noopener">函数组合和集合管道模式</a>。在本文中，我们将再次介绍函数管道的好处和构建块。您将进一步了解如何使用 <code>java.util.stream</code> 构建函数管道，以及为什么在管道中保持函数纯度是有益的。</p>
<a id="more"></a>

<h2 id="函数管道和-Stream-API"><a href="#函数管道和-Stream-API" class="headerlink" title="函数管道和 Stream API"></a>函数管道和 Stream API</h2><p>我们使用 <code>Stream</code> 在 Java™ 中构建函数管道。在函数式代码中使用 <code>Stream</code> 有 3 个好处：</p>
<ul>
<li><code>Stream</code> 简洁、富于表达、非常优雅，而且代码读起来就像是问题陈述。</li>
<li>Stream 采用了惰性计算，这使得它在您的程序中非常高效。</li>
<li>它可以并行使用。</li>
</ul>
<p>在本系列中，您已详细了解了优雅和简洁的代码的好处。在本文中，我们将重点介绍其他两个好处。效率是您在使用函数管道时寻求的主要好处之一，所以我们首先从这里开始介绍。</p>
<h2 id="惰性计算"><a href="#惰性计算" class="headerlink" title="惰性计算"></a>惰性计算</h2><p>下面的命令式代码非常高效：它仅执行绝对必要的工作。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">23</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">Integer result = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> e : numbers) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(e &gt; <span class="number">10</span> &amp;&amp; e % <span class="number">2</span> == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        result = e * <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(result != <span class="literal">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"The value is "</span> + result);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"No value found"</span>);</span></pre></td></tr></table></figure>

<p>该代码迭代 <code>numbers</code> 集合中的元素，但仅迭代至找到满足它的两个要求（大于 10 且是偶数）的元素。找到第一个数字后，就不会再处理其他值。<br>现在让我们使用函数管道重写上述代码：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">23</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.println(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  numbers.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(e -&gt; e &gt; <span class="number">10</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(e -&gt; e % <span class="number">2</span> == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .map(e -&gt; e * <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .findFirst()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .map(e -&gt; <span class="string">"The value is "</span> + e)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .orElse(<span class="string">"No value found"</span>));</span></pre></td></tr></table></figure>

<p>这个函数式版本生成的结果与命令式版本相同。在给出的示例中，命令式版本不会处理任何超过 12 的值，函数版本也是如此。不同之处在于代码处理给定变量的方式。</p>
<h3 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h3><p>Java <code>Stream</code> 基本上是惰性的，就像我十几岁的孩子一样。下面是我家里的一个场景，可能有助于您理解流的行为。<br>我的妻子对儿子说：“关掉电视”。<br>跟没说一样。<br>妻子说：“把垃圾倒掉”。<br>没有任何动作。<br>她再说：“做你的家庭作业”。<br>铅笔没被拿起过。<br>妻子说：“我要叫你爸爸了。”<br>孩子马上行动起来，按下电视遥控器上的关闭按钮……<br>像十几岁的孩子一样，<code>Stream</code> 只有两种方法：中间和最终。根据家中每位家长扮演的角色，后一个方法等效于 <code>callDaddy()</code> 或 <code>callMommy()</code> 方法。<br><code>Stream</code> 累积并<em>组合</em>或<em>融合</em>中间操作，然后执行它们。但是像十几岁的孩子一样，它仅执行满足最终操作所必需的工作。因为中间操作被融合，所以流对管道中数据的处理方式存在一个重要区别：<code>Stream</code> 不会像命令式代码一样执行数据集合上的每个函数，而是执行每个元素上的函数的融合集合，但仅在需要时执行。<br>为了验证此行为，我们可以稍微更改一下最初的函数式代码：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">23</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.println(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  numbers.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .peek(e -&gt; System.out.println(<span class="string">"processing "</span> + e))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(e -&gt; e &gt; <span class="number">10</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(e -&gt; e % <span class="number">2</span> == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .map(e -&gt; e * <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .findFirst()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .map(e -&gt; <span class="string">"The value is "</span> + e)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .orElse(<span class="string">"No value found"</span>));</span></pre></td></tr></table></figure>

<p>在这里，我们在函数管道中的第一个 <code>filter</code> 的前面添加了对 <code>peek</code> 的调用。<code>peek</code> 方法对调试很有用，使我们能在执行期间<em>留意到</em><code>Stream</code>。这是新代码的输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">processing <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">processing <span class="number">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">processing <span class="number">8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">processing <span class="number">15</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">processing <span class="number">12</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">The value <span class="keyword">is</span> <span class="number">24</span></span></pre></td></tr></table></figure>

<p>该代码处理了直到 12（包含 12）的所有值，但它没有触及超过目标值的任何值。这是因为最终操作 <code>findFirst</code> 会触发流处理的终止。此外，两个 <code>filter</code> 和 <code>map</code> 调用中的操作融合在一起，然后在序列中的每个元素上执行计算。超过 <code>findFirst</code> 中的内部终止信号后，就不会再计算元素。<br>在本例中，惰性显然提高了效率，因为函数管道只执行必要的工作。它是效率与优雅结合的典范。</p>
<h2 id="并行化"><a href="#并行化" class="headerlink" title="并行化"></a>并行化</h2><p>在您有一个大型集合或者需要执行消耗大量时间的任务的情况下，并行化可能非常有用。下面的代码将模拟一个耗时的操作。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Sample</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> static <span class="built_in">int</span> simulateTimeConsumingComputation(<span class="built_in">int</span> number) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Thread.sleep(<span class="number">1000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> number * <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        numbers.stream().map(Sample::simulateTimeConsumingComputation).forEachOrdered(System.<span class="keyword">out</span>::println);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如果正常运行此代码，您会发现所用时间约为 10 秒。这太长了。 我们可以使用一个并行流来提高速度，如下所示：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">numbers</span><span class="selector-class">.stream</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="selector-class">.parallel</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="selector-class">.map</span>(<span class="selector-tag">Sample</span><span class="selector-pseudo">::simulateTimeConsumingComputation)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr></table></figure>

<p>并行流使执行速度变得快得多。新代码在 16 核处理器上运行所用的时间约为 1 秒，在 8 核处理器上所用时间约为 2 秒。这是因为在默认情况下，并行流使用了与系统上的核心数一样多的线程。<br>您还会注意到，并行化此代码只需相对较少的工作。按顺序执行的函数管道的结构与并行运行的函数管道没什么不同，这使得函数管道非常容易并行化。</p>
<h2 id="函数纯度的规则"><a href="#函数纯度的规则" class="headerlink" title="函数纯度的规则"></a>函数纯度的规则</h2><p>目前您可能很喜欢这些技术给您的印象：惰性能提高效率，并行化的编写与顺序处理一样容易 — 使用它们吧！但是有一个陷阱：这些技术的成功取决于代码的<em>纯度</em>。您的函数管道中的所有 lambda 表达式和闭包都必须是纯的。<br>在继续后面的学习之前，您应该了解纯函数的一些知识。首先，纯函数是<em>幂等的</em>— 这意味着对纯函数的调用次数没有限制。其次，无论调用纯函数多少次，只要给定相同的输入，它都会产生相同的结果。第三，纯函数没有副作用：无论您使用它做什么，纯函数都不会更改您的程序中的其他任何元素。<br>如果您想编写纯函数，请记住，最后这个特征最为重要。实质上，函数纯度有两个规则：</p>
<ul>
<li>函数不会更改任何元素。</li>
<li>函数不依赖于任何可能更改的元素。</li>
</ul>
<p>纯函数绝不会在执行期间引起更改或发生更改。</p>
<h2 id="为什么函数纯度至关重要"><a href="#为什么函数纯度至关重要" class="headerlink" title="为什么函数纯度至关重要"></a>为什么函数纯度至关重要</h2><p><em>惰性计算</em>意味着一个函数可以在现在或以后计算，或者可以完全跳过计算。无论采用何种方式，只要得到想要的结果就行。但是，如果函数有副作用，惰性计算就不会生效。下一个示例将展示在函数管道包含不纯函数时会发生什么。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] factor = new <span class="built_in">int</span>[] &#123; <span class="number">2</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = numbers.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .map(e -&gt; e * factor[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">factor[<span class="number">0</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">stream.forEach(System.<span class="keyword">out</span>::println);</span></pre></td></tr></table></figure>

<p>Java 假设提供给操作的 lambda 表达式和闭包是纯的。如果您的代码不满足这一要求，您将承担相应的后果。<br>为了增添乐趣，可以询问一些同事他们预计此代码的输出是什么。您不可能获得一致的回答。更可能的情况是，您会看到许多人感到困惑和不确定。<br>在这个示例中，传递给 <code>map</code> 的闭包是不纯的。它违背了纯度的第二个规则，因为该闭包依赖的变量可能发生改变（而且事实上它确实发生了改变）。由于惰性计算，作为参数传递给 <code>map</code> 的闭包只在调用 <code>forEach</code> 后才会计算。<br>因为 <code>factor[0]</code> 是可变的，从创建闭包到最终计算它的过程中，该值可以是任何值。这个可变变量让代码变得很难理解。很难理解的代码也就很难维护，而且这通常是出现错误的一个原因。<br>并行流也是如此：如果传递给操作的状态不纯，结果将是不可预测的。</p>
<h2 id="避免共享可变性"><a href="#避免共享可变性" class="headerlink" title="避免共享可变性"></a>避免共享可变性</h2><p>传递给操作的 lambda 表达式和闭包应该是纯的。它们不应修改任何外部状态，也不应依赖于任何可变的外部状态。<br>开发人员常常询问他们是否应完全避免可变性。答案很简单：不要使用可变性。相反，应<strong>避免共享可变性</strong>。在中间和最终操作中，如果修改了一个共享可变变量，代码会变得难以推断。共享可变性还使得通过并行和/或惰性计算无法获得正确的结果。您可以选择不使用并行化，但您无法控制惰性计算，因为它是流的一种隐式行为。<br>尽管共享可变性会花费一些成本，但您可以通过小心地改变隔离变量来获得不错的结果，隔离变量是严格禁止被多个线程共享的变量。在处理的数据量非常大时，改变隔离变量可以提高性能。在一个处理包含数百万个对象的集合的最新项目中，我的团队使用了隔离可变性将性能提高到对数据负载合理的水平。这样做能够奏效是因为我们仔细验证了该项目中不存在共享可变性。我们还验证了我们的结果不仅快，而且正确。<br>对于小型或中等规模的集合，或者您无需可变性就能实现合理性能的情况，最明智的做法是避免 lambda 表达式和闭包中的可变性。如果您在其中一个元素中采用了可变性，请确保您正在改变一个隔离变量，而且永远不要改变共享变量。从函数管道的开始到结束，闭包所依赖的状态绝不应被多个线程修改。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>惰性计算和轻松的并行执行是使用函数管道的两个重要好处。两个特性都取决于<em>函数纯度</em>，这意味着 lambda 表达式和闭包不得在您的程序中产生任何副作用。在本文中，您了解了这个规则和它存在的原因，还探索了可以安全改变隔离变量的一个例外情况。<br>理解函数纯度很重要，因为如果您违背了 lambda 表达式和闭包中的纯度要求，Java 不会产生错误，甚至不会生成警告。所以您需要验证您的 lambda 表达式不依赖于共享可变状态，而且执行的结果既高效又正确。</p>
<blockquote>
<p>作者：Venkat Subramaniam</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms11/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms11/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>Lambda表达式介绍</title>
    <url>/2019/12/26/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1、什么是Lambda表达式"><a href="#1、什么是Lambda表达式" class="headerlink" title="1、什么是Lambda表达式"></a>1、什么是Lambda表达式</h3><p>Lambda 表达式是一种匿名函数，简单地说，它是没有声明的方法，也即没有访问修饰符、返回值声明和名字。<br>它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使 Java 语言的表达能力得到了提升。</p>
<a id="more"></a>

<h3 id="2、Lambda表达式的语法"><a href="#2、Lambda表达式的语法" class="headerlink" title="2、Lambda表达式的语法"></a>2、<strong>Lambda表达式的语法</strong></h3><p>基本语法: (parameters) -&gt; expression<br>或者：(parameters) -&gt;{ statements;<br>举例说明：</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 不需要参数,返回值为 5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">() -&gt; <span class="number">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">x</span> -&gt; <span class="number">2</span> * <span class="symbol">x</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 3. 接受2个参数(数字),并返回他们的差值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">(<span class="symbol">x</span>, <span class="symbol">y</span>) -&gt; <span class="symbol">x</span> – <span class="symbol">y</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 4. 接收2个int型整数,返回他们的和</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">(int <span class="symbol">x</span>, int <span class="symbol">y</span>) -&gt; <span class="symbol">x</span> + <span class="symbol">y</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">(String s) -&gt; System.out.print(s)</span></pre></td></tr></table></figure>

<h3 id="3、什么是函数式接口"><a href="#3、什么是函数式接口" class="headerlink" title="3、什么是函数式接口"></a>3、什么是函数式接口</h3><p>再对上面进行举例说明之前，必须先来理解下函数式接口，因为Lambda是建立在函数式接口的基础上的。<br> <strong>记住！</strong><br>（1）只包含一个抽象方法的接口，称为函数式接口。<br>（2）你可以通过 Lambda 表达式来创建该接口的对象。<br>（3）我们可以在任意函数式接口上使用 <code>@FunctionalInterface</code> 注解，这样做可以检测它是否是一个函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。<br>在实际开发者🈶️两个比较常见的函数式接口：<strong>Runnable接口，Comparator接口</strong><br>先举例<strong>Runnable接口相关</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 1.1使用匿名内部类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">"Hello world !"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 1.2使用 lambda 获得Runnable接口对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">new</span> Thread(() -&gt; System.out.<span class="built_in">println</span>(<span class="string">"Hello world !"</span>)).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//=============================================================================</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 2.1使用匿名内部类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Runnable race1 = <span class="keyword">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">"Hello world !"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 2.2使用 lambda直接获得接口对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Runnable race2 = () -&gt; System.out.<span class="built_in">println</span>(<span class="string">"Hello world !"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 直接调用 run 方法(没开新线程哦!)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        race1.<span class="built_in">run</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        race2.<span class="built_in">run</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/*输出结果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Hello world !</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Hello world !</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Hello world !</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Hello world !</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *／</span></span></pre></td></tr></table></figure>

<p>通过上面案例可以看出：通过Lambda表达式看去舒服清爽多了，2而通过匿名内部类代码总是不够整洁。<br>再举一个例子：<strong>使用Lambda对数组排序</strong></p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class TestArray &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">String</span>[] players = &#123;<span class="string">"zhansgan"</span>, <span class="string">"lisi"</span>, <span class="string">"wangwu"</span>, <span class="string">"zhaoliu"</span>,  <span class="string">"wangmazi"</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 1.1 使用匿名内部类根据 surname 排序 players</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Arrays.<span class="built_in">sort</span>(players, <span class="keyword">new</span> Comparator&lt;<span class="keyword">String</span>&gt;() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">public</span> <span class="built_in">int</span> compare(<span class="keyword">String</span> s1, <span class="keyword">String</span> s2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> (s1.compareTo(s2));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 1.2 使用 lambda 排序,根据 surname</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Arrays.<span class="built_in">sort</span>(players, (<span class="keyword">String</span> s1, <span class="keyword">String</span> s2) -&gt;  s1.compareTo(s2));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//================================================================================================</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 2.1 使用匿名内部类根据 name lenght 排序 players</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Arrays.<span class="built_in">sort</span>(players, <span class="keyword">new</span> Comparator&lt;<span class="keyword">String</span>&gt;() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">public</span> <span class="built_in">int</span> compare(<span class="keyword">String</span> s1, <span class="keyword">String</span> s2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> (s1.length() - s2.length());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 2.2使用Lambda,根据name length</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Arrays.<span class="built_in">sort</span>(players, (<span class="keyword">String</span> s1, <span class="keyword">String</span> s2) -&gt; (s1.length() - s2.length()));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//==================================================================================================</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 3.1 使用匿名内部类排序 players, 根据最后一个字母</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Arrays.<span class="built_in">sort</span>(players, <span class="keyword">new</span> Comparator&lt;<span class="keyword">String</span>&gt;() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">public</span> <span class="built_in">int</span> compare(<span class="keyword">String</span> s1, <span class="keyword">String</span> s2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> (s1.charAt(s1.length() - <span class="number">1</span>) - s2.charAt(s2.length() - <span class="number">1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 3.2 使用Lambda,根据最后一个字母</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Arrays.<span class="built_in">sort</span>(players, (<span class="keyword">String</span> s1, <span class="keyword">String</span> s2) -&gt; (s1.charAt(s1.length() - <span class="number">1</span>) - s2.charAt(s2.length() - <span class="number">1</span>)));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过上面例子我们再来思考为什么Lambda表达式需要函数式接口？其实很简单目的就是为来保证唯一。<br><strong>你的</strong>Runnable接口只要一个抽象方法，那么我用<code>() -&gt; System.out.println(&quot;Hello world !&quot;)</code>，就只能代表run方法，如果你下面还有一个抽象方法，那我使用Lambda表达式，那鬼才知道要调用哪个抽象方法呢。</p>
<h2 id="二、方法引用"><a href="#二、方法引用" class="headerlink" title="二、方法引用"></a><strong>二、方法引用</strong></h2><h3 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a><strong>1、基本介绍</strong></h3><p><strong>首先注意：</strong>方法引用，不是方法调用！方法引用，不是方法调用！方法引用，不是方法调用！<br>函数式接口的实例可以通过 lambda 表达式、 方法引用、构造方法引用来创建。方法引用是 lambda 表达式的语法糖，任何用方法引用的地方都可由lambda表达式替换，但是并不是所有的lambda表达式都可以用方法引用来替换。<br>举例<br>这就是一个打印集合所有元素的例子，<code>value -&gt; System.out.println(value)</code> 是一个Consumer函数式接口， 这个函数式接口可以通过方法引用来替换。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArray</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         List&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span> = Arrays.asList(<span class="string">"xuxiaoxiao"</span>, <span class="string">"xudada"</span>, <span class="string">"xuzhongzhong"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="built_in">list</span>.forEach(value -&gt; System.out.<span class="built_in">println</span>(value));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/* 输出：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * xuxiaoxiao</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * xudada</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * xuzhongzhong</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用方法引用的方式，和上面的输出是一样的，方法引用使用的是双冒号（::）</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>.for<span class="constructor">Each(System.<span class="params">out</span>::<span class="params">println</span>)</span>;</span></pre></td></tr></table></figure>

<h3 id="2、分类"><a href="#2、分类" class="headerlink" title="2、分类"></a>2、分类</h3><table>
<thead>
<tr>
<th>类别</th>
<th>使用形式</th>
</tr>
</thead>
<tbody><tr>
<td>静态方法引用</td>
<td>类名 :: 静态方法名</td>
</tr>
<tr>
<td>实例方法引用</td>
<td>对象名(引用名) :: 实例方法名</td>
</tr>
<tr>
<td>类方法引用</td>
<td>类名 :: 实例方法名</td>
</tr>
<tr>
<td>构造方法引用</td>
<td>类名 :: new</td>
</tr>
</tbody></table>
<p><strong>（1）静态方法引用</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(<span class="keyword">String</span> name, <span class="keyword">String</span> color, <span class="keyword">double</span> weight)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.color = color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.weight = weight;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareByWeight</span><span class="params">(Apple a1, Apple a2)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">double</span> diff = a1.getWeight() - a2.getWeight();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Double(diff).intValue();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//还有getter setter toString</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>有一个苹果的List，现在需要根据苹果的重量进行排序。List 的 sort 函数接收一个 Comparator 类型的参数，Comparator 是一个函数式接口，接收两个参数，返回一个int值。<br>Apple的静态方法compareByWeight正好符合Comparator函数式接口，所以可以使用：<br><code>Apple::compareByWeight</code> 静态方法引用来替代lambda表达式</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> LambdaTest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple1 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"红富士"</span>, <span class="string">"Red"</span>, 280)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple2 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"冯心"</span>, <span class="string">"Yello"</span>, 470)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple3 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"大牛"</span>, <span class="string">"Red"</span>, 320)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple4 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"小小"</span>, <span class="string">"Green"</span>, 300)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;Apple&gt; appleList = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">as</span><span class="constructor">List(<span class="params">apple1</span>, <span class="params">apple2</span>, <span class="params">apple3</span>, <span class="params">apple4</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//lambda 表达式形式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//appleList.sort((Apple a1, Apple a2) -&gt; &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//    return new Double(a1.getWeight() - a2.getWeight()).intValue();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//&#125;);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//静态方法引用形式（可以看出引用方法比上面的更加简单</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        appleList.sort(Apple::compareByWeight);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appleList.for<span class="constructor">Each(<span class="params">apple</span> -&gt; System.<span class="params">out</span>.<span class="params">println</span>(<span class="params">apple</span>)</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'红富士'</span>, <span class="attribute">color</span>=<span class="string">'Red'</span>, <span class="attribute">weight</span>=280.0&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'小小'</span>, <span class="attribute">color</span>=<span class="string">'Green'</span>, <span class="attribute">weight</span>=300.0&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'大牛'</span>, <span class="attribute">color</span>=<span class="string">'Red'</span>, <span class="attribute">weight</span>=320.0&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'冯心'</span>, <span class="attribute">color</span>=<span class="string">'Yello'</span>, <span class="attribute">weight</span>=470.0&#125;</span></pre></td></tr></table></figure>

<p><strong>注意：</strong><code>Apple.compareByWeight</code>是方法的调用，而<code>Apple::compareByWeight</code>方法引用，这两者完全不是一回事。<br><strong>（2）实例方法引用</strong><br>这个compareByWeight是一个实例方法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> AppleComparator &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public <span class="built_in">int</span> compare<span class="constructor">ByWeight(Apple <span class="params">a1</span>, Apple <span class="params">a2</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        double diff = a1.get<span class="constructor">Weight()</span> - a2.get<span class="constructor">Weight()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return <span class="keyword">new</span> <span class="constructor">Double(<span class="params">diff</span>)</span>.<span class="built_in">int</span><span class="constructor">Value()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>下面的例子通过实例对象的方法引用 <code>comparator::compareByWeight</code> 来代替lambda表达式</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> LambdaTest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple1 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"红富士"</span>, <span class="string">"Red"</span>, 280)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple2 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"冯心"</span>, <span class="string">"Yello"</span>, 470)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple3 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"哈哈"</span>, <span class="string">"Red"</span>, 320)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple4 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"小小"</span>, <span class="string">"Green"</span>, 300)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;Apple&gt; appleList = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">as</span><span class="constructor">List(<span class="params">apple1</span>, <span class="params">apple2</span>, <span class="params">apple3</span>, <span class="params">apple4</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//lambda 表达式形式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//appleList.sort((Apple a1, Apple a2) -&gt; &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//    return new Double(a1.getWeight() - a2.getWeight()).intValue();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//&#125;);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//实例方法引用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        AppleComparator comparator = <span class="keyword">new</span> <span class="constructor">AppleComparator()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appleList.sort(comparator::compareByWeight);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appleList.for<span class="constructor">Each(<span class="params">apple</span> -&gt; System.<span class="params">out</span>.<span class="params">println</span>(<span class="params">apple</span>)</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'红富士'</span>, <span class="attribute">color</span>=<span class="string">'Red'</span>, <span class="attribute">weight</span>=280.0&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'小小'</span>, <span class="attribute">color</span>=<span class="string">'Green'</span>, <span class="attribute">weight</span>=300.0&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'哈哈'</span>, <span class="attribute">color</span>=<span class="string">'Red'</span>, <span class="attribute">weight</span>=320.0&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'冯心'</span>, <span class="attribute">color</span>=<span class="string">'Yello'</span>, <span class="attribute">weight</span>=470.0&#125;</span></pre></td></tr></table></figure>

<p>通过上面两个例子可以看到，静态方法引用和实例方法引用都是比较好理解的。<br>（3）类方法引用<br>一般来说，同类型对象的比较，应该当前调用方法的对象与另外一个对象进行比较，好的设计应该像下面：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> category;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(<span class="keyword">String</span> category, <span class="keyword">String</span> color, <span class="keyword">double</span> weight)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.category = category;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.color = color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.weight = weight;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//这里和上面静态方式唯一区别就是这个参数就一个，需要实例对象调这个方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareByWeight</span><span class="params">(Apple other)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">double</span> diff = <span class="keyword">this</span>.getWeight() - other.getWeight();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Double(diff).intValue();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//getter setter toString</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>还是之前List排序的例子，看看使用类方法引用如何写：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> LambdaTest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple1 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"红富士"</span>, <span class="string">"Red"</span>, 280)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple2 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"黄元帅"</span>, <span class="string">"Yello"</span>, 470)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple3 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"红将军"</span>, <span class="string">"Red"</span>, 320)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple4 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"国光"</span>, <span class="string">"Green"</span>, 300)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;Apple&gt; appleList = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">as</span><span class="constructor">List(<span class="params">apple1</span>, <span class="params">apple2</span>, <span class="params">apple3</span>, <span class="params">apple4</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//lambda 表达式形式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//appleList.sort((Apple a1, Apple a2) -&gt; &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//    return new Double(a1.getWeight() - a2.getWeight()).intValue();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//&#125;);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//这里是类方法引用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        appleList.sort(Apple::compareByWeight);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appleList.for<span class="constructor">Each(<span class="params">apple</span> -&gt; System.<span class="params">out</span>.<span class="params">println</span>(<span class="params">apple</span>)</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'红富士'</span>, <span class="attribute">color</span>=<span class="string">'Red'</span>, <span class="attribute">weight</span>=280.0&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'国光'</span>, <span class="attribute">color</span>=<span class="string">'Green'</span>, <span class="attribute">weight</span>=300.0&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'红将军'</span>, <span class="attribute">color</span>=<span class="string">'Red'</span>, <span class="attribute">weight</span>=320.0&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'黄元帅'</span>, <span class="attribute">color</span>=<span class="string">'Yello'</span>, <span class="attribute">weight</span>=470.0&#125;</span></pre></td></tr></table></figure>

<p>这里使用的是：类名::实例方法名。首先要说明的是，方法引用不是方法调用。compareByWeight一定是某个实例调用的，就是lambda表达式的第一个参数，然后lambda表达式剩下的参数作为<br>compareByWeight的参数，这样compareByWeight正好符合lambda表达式的定义。<br>或者也可以这样理解：<br><code>(Apple a1, Apple a2) -&gt; { return new Double(a1.getWeight() - a2.getWeight()).intValue(); }</code><br><code>int compareByWeight(Apple other)</code> 需要当前对象调用，然后与另外一个对象比较，并且返回一个int值。可以理解为lambda表达式的第一个参数 a1 赋值给当前对象， 然后 a2 赋值给 other对象，然后返回int值。<br><strong>（4）构造方法引用</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructionMethodTest</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getString</span><span class="params">(Supplier&lt;<span class="keyword">String</span>&gt; supplier)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> supplier.<span class="built_in">get</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ConstructionMethodTest test = <span class="keyword">new</span> ConstructionMethodTest();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//lambda表达式形式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(test.getString(() -&gt; &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">String</span>();&#125;));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//构造方法引用形式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(test.getString(<span class="keyword">String</span>::<span class="keyword">new</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>getString 方法接收一个Supplier类型的参数，Supplier 不接收参数，返回一个String。lambda表达式应该这样写：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">()</span> -&gt;</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> String();&#125;</span></pre></td></tr></table></figure>

<p>替换成方法引用的形式如下： 实际上调用的是String 无参构造方法。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span>::<span class="keyword">new</span></span></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1、<a href="https://www.cnblogs.com/franson-2016/p/5593080.html" target="_blank" rel="noopener">Java中Lambda表达式的使用</a><br>2、<a href="https://blog.csdn.net/yitian_66/article/details/80652656" target="_blank" rel="noopener">java8特性概要以及demo分析</a><br>3<a href="https://blog.csdn.net/yitian_66/article/details/80652656" target="_blank" rel="noopener">、</a><a href="https://blog.csdn.net/yitian_66/article/details/80652656" target="_blank" rel="noopener">java8 笔记 - 方法引用（四）</a></p>
<blockquote>
<p>作者：雨点的名字</p>
<p>来源：<a href="https://www.cnblogs.com/qdhxhz/p/9393724.html" target="_blank" rel="noopener">https://www.cnblogs.com/qdhxhz/p/9393724.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>Java深浅拷贝</title>
    <url>/2019/12/26/Java%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>我觉得主要跟JVM内存分配有关,对于基本数据类型,只存在栈内存,所以它的拷贝不存在深浅拷贝这个概念。而对于对象而言,一个对象的创建会在内存中分配两块空间,一个在栈内存存对象的引用指针,一个在堆内存存放对象。这个时候会有一个问题，你拷贝的只是这个引用指针还是拷贝两块内存一起拷贝,这个时候就会有深浅拷贝一说。<br>还有之前我认为Arrays.copyOf()是深度拷贝,亲测后发现原来它也是浅拷贝。下面进行具体说明。</p>
<a id="more"></a>

<h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><p>数据分为<code>基本数据</code>类型(int, boolean, double, byte, char等)和<code>对象数据</code>类型。<br>基本数据类型的特点：<code>直接存储在栈(stack)中的数据</code>.<br>引用数据类型的特点：<code>在栈内存存储对象引用，真实的数据存放在堆内存里</code><br>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。<br><img src="http://image.winrains.cn/2019/08/b47af-1090617-20190313235427505-245278508.jpg" alt="img"></p>
<h2 id="三、什么是浅拷贝和深拷贝"><a href="#三、什么是浅拷贝和深拷贝" class="headerlink" title="三、什么是浅拷贝和深拷贝"></a>三、什么是浅拷贝和深拷贝</h2><p>首先需要明白，<code>深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的</code>。那先来看看浅拷贝和深拷贝的概念。<br>在 Java 中，除了基本数据类型（元类型）之外，还存在 类的实例对象 这个引用数据类型。而一般使用 <code>=</code>号做赋值操作的时候。对于基本数据类型，实际上是拷贝的它的值，但是对于对象而言，其实赋值的只是这个对象的引用，将原对象的引用传递过去，他们实际上还是指向的同一个对象。<br><code>浅拷贝</code>：如果在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行了引用的传递，而没有真实的创建一个新的对象。<br><code>深拷贝</code>：在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量。<br>深拷贝和浅拷贝的示意图大致如下：<br><img src="http://image.winrains.cn/2019/08/8e501-1090617-20190313235500918-1556393479.jpg" alt="img"><br><img src="http://image.winrains.cn/2019/08/8dcb2-1090617-20190313235507983-512560464.jpg" alt="img"><br>具体接下来代码演示。</p>
<h2 id="四、代码演示"><a href="#四、代码演示" class="headerlink" title="四、代码演示"></a>四、代码演示</h2><h3 id="1、浅拷贝"><a href="#1、浅拷贝" class="headerlink" title="1、浅拷贝"></a>1、浅拷贝</h3><p><strong>Person</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> Integer age;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> sex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 提供get和set方法和全参构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>Test</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static void main(String<span class="literal">[]</span> args) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person person = <span class="keyword">new</span> <span class="constructor">Person(<span class="string">"小小"</span>, 3, <span class="string">"女"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 将person值赋值给person1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person person1 = person;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(person);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(person1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    person1.set<span class="constructor">Name(<span class="string">"小小她爸"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"person 中 name为："</span> + person.get<span class="constructor">Name()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"person1 中 name为："</span> + person.get<span class="constructor">Name()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>查看运行结果<br><img src="http://image.winrains.cn/2019/08/4cbf5-1090617-20190313235604444-1064708140.jpg" alt="img"><br>从图片中我们可以很明显看出,它们指向的内存地址是一致的,同样我改变person1的属性值时发现person的属性值也改变了。<br><code>说明</code>：对于对象用<code>&quot;=&quot;</code> 赋值 其实只是引用指针的复制,这两个引用还是指向同一个对象。</p>
<h3 id="2、深拷贝"><a href="#2、深拷贝" class="headerlink" title="2、深拷贝"></a>2、深拷贝</h3><p>如果要实现深拷贝就会比较复杂点<br><strong>Student</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 如果对象要实现深拷贝 那么实体需要做两步</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 1、实体实现Cloneable接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 2、重写 clone()方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Student <span class="keyword">implements</span> Cloneable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> Integer age;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> sex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//这也是个实体</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> Address address;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 提供get和set方法和全参构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> <span class="built_in">Object</span> clone() throws CloneNotSupportedException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>Test</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static void main(String<span class="literal">[]</span> args) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Student student = <span class="keyword">new</span> <span class="constructor">Student(<span class="string">"小小"</span>, 3, <span class="string">"女"</span>, <span class="params">null</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 将person值赋值给person1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Student student1 = (Student) student.clone<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(student);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(student1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    student1.set<span class="constructor">Name(<span class="string">"小小她爸"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"person 中 name为："</span> + student.get<span class="constructor">Name()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"person1 中 name为："</span> + student1.get<span class="constructor">Name()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><img src="http://image.winrains.cn/2019/08/60ea8-1090617-20190313235621488-1930654079.jpg" alt="img"><br>这里可以已经是两个不同的对象了。但是这里需要注意的是,如果对象中含有对象,这个对象还是浅拷贝。<br><strong>Address</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Address</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> String city;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> phone;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 提供get和set方法和全参构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>Test</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static void main(String<span class="literal">[]</span> args) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Address address = <span class="keyword">new</span> <span class="constructor">Address(<span class="string">"杭州"</span>, 1888888888)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Student student2 = <span class="keyword">new</span> <span class="constructor">Student(<span class="string">"小小"</span>, 3, <span class="string">"女"</span>, <span class="params">address</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 将person值赋值给person1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Student student3 = (Student) student2.clone<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    address.set<span class="constructor">City(<span class="string">"北京天安门"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"person2 中 city为："</span> + student2.get<span class="constructor">Address()</span>.get<span class="constructor">City()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"person3 中 city为："</span> + student3.get<span class="constructor">Address()</span>.get<span class="constructor">City()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><img src="http://image.winrains.cn/2019/08/b6122-1090617-20190313235642049-1971336257.jpg" alt="img"><br>我们发现虽然Student是实现了深拷贝，但Address却还是浅拷贝,那如何让Adress也实现深拷贝呢。<br><strong>Address修改</strong></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> String  city;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> phone;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 提供get和set方法和全参构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> <span class="function">Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">clone</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>Student修改</strong></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改clone方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function">Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Student s = (Student) <span class="keyword">super</span>.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    s.address = (Address) address.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><img src="http://image.winrains.cn/2019/08/65f79-1090617-20190313235631951-1609979398.jpg" alt="img"><br><code>弊端</code>: 这里我们Person 类只有一个 Address 引用类型，而 Address 类没有，所以我们只用重写 Address 类的clone 方法，但是如果 Address 类也存在一个引用类型，<br>那么我们也要重写其clone 方法，这样下去，有多少个引用类型，我们就要重写多少次，如果存在很多引用类型，那么代码量显然会很大，所以这种方法不太合适。<br>所以还有另一种实现深拷贝方法。<br><strong>序列化实现深拷贝</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序列化实现深拷贝</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public Object deep<span class="constructor">Clone()</span> throws Exception&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 序列化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ByteArrayOutputStream bos = <span class="keyword">new</span> <span class="constructor">ByteArrayOutputStream()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ObjectOutputStream oos = <span class="keyword">new</span> <span class="constructor">ObjectOutputStream(<span class="params">bos</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    oos.write<span class="constructor">Object(<span class="params">this</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 反序列化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ByteArrayInputStream bis = <span class="keyword">new</span> <span class="constructor">ByteArrayInputStream(<span class="params">bos</span>.<span class="params">toByteArray</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> <span class="constructor">ObjectInputStream(<span class="params">bis</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return ois.read<span class="constructor">Object()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">　<span class="comment">//因为序列化产生的是两个完全独立的对象，所有无论嵌套多少个引用类型，序列化都是能实现深拷贝的。</span></span></pre></td></tr></table></figure>

<h2 id="五、Arrays-copyOf"><a href="#五、Arrays-copyOf" class="headerlink" title="五、Arrays.copyOf()"></a>五、Arrays.copyOf()</h2><p>之前我误以为Arrays.copyOf()为深拷贝,那只是因为我用的是基本数据类型作为数组,而基本数据类型上面已经说过它没有深浅拷贝这个概念，可以把他理解成只有深拷贝。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static void main(String<span class="literal">[]</span> args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 1、基本数据类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">int</span><span class="literal">[]</span> a = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Arrays.copyOf拷贝</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">int</span><span class="literal">[]</span> copy = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>copy<span class="constructor">Of(<span class="params">a</span>, <span class="params">a</span>.<span class="params">length</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    a<span class="literal">[<span class="number">0</span>]</span> = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">copy</span>)</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">a</span>)</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 2、对象数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Student<span class="literal">[]</span> stuArr = &#123; <span class="keyword">new</span> <span class="constructor">Student(<span class="string">"小小"</span>, 3, <span class="string">"女"</span>)</span>, <span class="keyword">new</span> <span class="constructor">Student(<span class="string">"小小爸"</span>, 29, <span class="string">"男"</span>)</span>, <span class="keyword">new</span> <span class="constructor">Student(<span class="string">"小小妈"</span>, 27, <span class="string">"女"</span>)</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Arrays.copyOf拷贝</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Student<span class="literal">[]</span> copyStuArr = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>copy<span class="constructor">Of(<span class="params">stuArr</span>, <span class="params">stuArr</span>.<span class="params">length</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    copyStuArr<span class="literal">[<span class="number">0</span>]</span>.set<span class="constructor">Name(<span class="string">"小小爷爷"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">stuArr</span>)</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">copyStuArr</span>)</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>运行结果：<br><img src="http://image.winrains.cn/2019/08/72add-1090617-20190313235732499-1673590724.jpg" alt="img"><br>可以明显看出,对于基本数据类型只有深拷贝,而对于数组对象而言,明显存在深浅拷贝,而且可以看出<code>Arrays.copyOf()为浅拷贝</code>。</p>
<blockquote>
<p>作者：雨点的名字</p>
<p>来源：<a href="https://www.cnblogs.com/qdhxhz/p/10527245.html" target="_blank" rel="noopener">https://www.cnblogs.com/qdhxhz/p/10527245.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 泛型全解</title>
    <url>/2019/12/26/Java-%E6%B3%9B%E5%9E%8B%E5%85%A8%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>对于java的泛型我一直属于一知半解的，平常真心用的不多。直到阅读《Effect Java》,看到很多平常不了解的用法，才下定决心，需要系统的学习，并且记录下来。</p>
<a id="more"></a>

<hr>
<h2 id="1、泛型的概述："><a href="#1、泛型的概述：" class="headerlink" title="1、泛型的概述："></a>1、泛型的概述：</h2><h3 id="1-1-泛型的由来"><a href="#1-1-泛型的由来" class="headerlink" title="1.1 泛型的由来"></a>1.1 泛型的由来</h3><p>根据《Java编程思想》中的描述，泛型出现的动机：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有很多原因促成了泛型的出现，而最引人注意的一个原因，就是为了创建容器类。</span></pre></td></tr></table></figure>

<p>泛型的思想很早就存在，如C++中的模板（Templates）。模板的精神：<strong>参数化类型</strong></p>
<h3 id="1-2-基本概述"><a href="#1-2-基本概述" class="headerlink" title="1.2 基本概述"></a>1.2 基本概述</h3><ul>
<li>泛型的本质就是”参数化类型”。一提到参数，最熟悉的就是定义方法的时候需要形参，调用方法的时候，需要传递实参。那”参数化类型”就是将原来具体的类型参数化</li>
<li>泛型的出现避免了强转的操作，在编译器完成类型转化，也就避免了运行的错误。</li>
</ul>
<h3 id="1-3-泛型的目的"><a href="#1-3-泛型的目的" class="headerlink" title="1.3 泛型的目的"></a>1.3 泛型的目的</h3><ul>
<li>Java泛型也是一种语法糖，在编译阶段完成类型的转换的工作，避免在运行时强制类型转换而出现ClassCastException,类型转化异常。</li>
</ul>
<h3 id="1-4-实例"><a href="#1-4-实例" class="headerlink" title="1.4 实例"></a>1.4 实例</h3><p>JDK 1.5时增加了泛型，在很大的程度上方便在集合上的使用。</p>
<ul>
<li>不使用泛型：</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">list</span>.add(<span class="number">11</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">list</span>.add(<span class="string">"ssss"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.<span class="built_in">size</span>(); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>((<span class="keyword">String</span>) <span class="built_in">list</span>.<span class="built_in">get</span>(i));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>因为list类型是Object。所以int,String类型的数据都是可以放入的，也是都可以取出的。但是上述的代码，运行的时候就会抛出类型转化异常，这个相信大家都能明白。</p>
<ul>
<li>使用泛型：</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">list</span>.add(<span class="string">"hahah"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">list</span>.add(<span class="string">"ssss"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.<span class="built_in">size</span>(); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>((<span class="keyword">String</span>)<span class="built_in">list</span>.<span class="built_in">get</span>(i));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在上述的实例中，我们只能添加String类型的数据，否则编译器会报错。</p>
<hr>
<h2 id="2、泛型的使用"><a href="#2、泛型的使用" class="headerlink" title="2、泛型的使用"></a>2、泛型的使用</h2><p>泛型的三种使用方式：<strong>泛型类</strong>，<strong>泛型方法</strong>，<strong>泛型接口</strong></p>
<h3 id="2-1-泛型类"><a href="#2-1-泛型类" class="headerlink" title="2.1 泛型类"></a>2.1 泛型类</h3><ul>
<li>泛型类概述：把泛型定义在类上</li>
<li>定义格式：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名 &lt;泛型类型1,...&gt; &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li>注意事项：泛型类型必须是引用类型（非基本数据类型）</li>
</ul>
<h3 id="2-2-泛型方法"><a href="#2-2-泛型方法" class="headerlink" title="2.2 泛型方法"></a>2.2 泛型方法</h3><ul>
<li>泛型方法概述：把泛型定义在方法上</li>
<li>定义格式：</li>
</ul>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml">public <span class="tag">&lt;<span class="name">泛型类型</span>&gt;</span> 返回类型 方法名（泛型类型 变量名） </span><span class="template-variable">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="template-variable">&#125;</span></span></pre></td></tr></table></figure>

<ul>
<li>注意要点：<ul>
<li>方法声明中定义的形参只能在该方法里使用，而接口、类声明中定义的类型形参则可以在整个接口、类中使用。当调用fun()方法时，根据传入的实际对象，编译器就会判断出类型形参T所代表的实际类型。</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="function"><span class="title">fun</span><span class="params">(T t)</span></span> &#123;   <span class="comment">// 可以接收任意类型的数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> t ;     <span class="comment">// 直接把参数返回</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo26</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> static void main(String args[])&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Demo d = new Demo() ; <span class="comment">// 实例化Demo对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        String str = d<span class="function">.<span class="title">fun</span><span class="params">(<span class="string">"汤姆"</span>)</span></span> ; <span class="comment">// 传递字符串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        int i = d<span class="function">.<span class="title">fun</span><span class="params">(<span class="number">30</span>)</span></span> ;  <span class="comment">// 传递数字，自动装箱</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(str) ; <span class="comment">// 输出内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(i) ;  <span class="comment">// 输出内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="2-3-泛型接口"><a href="#2-3-泛型接口" class="headerlink" title="2.3 泛型接口"></a>2.3 泛型接口</h3><ul>
<li>泛型接口概述：把泛型定义在接口</li>
<li>定义格式：</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>接口名&lt;泛型类型&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li>实例：</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 泛型接口的定义格式:        修饰符  interface 接口名&lt;数据类型&gt; &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">Inter</span>&lt;<span class="symbol">T</span>&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">void</span> show(T t) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 子类是泛型类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">InterImpl</span>&lt;<span class="symbol">E</span>&gt; <span class="symbol">implements</span> <span class="symbol">Inter</span>&lt;<span class="symbol">E</span>&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> show(E t) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Inter&lt;String&gt; <span class="built_in">int</span>er = new InterImpl&lt;String&gt;() ;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>er.show(<span class="string">"hello"</span>) ;</span></pre></td></tr></table></figure>

<h3 id="2-4-源码中泛型的使用，下面是List接口和ArrayList类的代码片段。"><a href="#2-4-源码中泛型的使用，下面是List接口和ArrayList类的代码片段。" class="headerlink" title="2.4 源码中泛型的使用，下面是List接口和ArrayList类的代码片段。"></a>2.4 源码中泛型的使用，下面是List接口和ArrayList类的代码片段。</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义接口时指定了一个类型形参，该形参名为E</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">List</span>&lt;<span class="symbol">E</span>&gt; <span class="symbol">extends</span> <span class="symbol">Collection</span>&lt;<span class="symbol">E</span>&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">//在该接口里，E可以作为类型使用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> E <span class="keyword">get</span>(<span class="built_in">int</span> index) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="built_in">void</span> add(E e) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//定义类时指定了一个类型形参，该形参名为E</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ArrayList</span>&lt;<span class="symbol">E</span>&gt; <span class="symbol">extends</span> <span class="symbol">AbstractList</span>&lt;<span class="symbol">E</span>&gt; <span class="symbol">implements</span> <span class="symbol">List</span>&lt;<span class="symbol">E</span>&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">//在该类里，E可以作为类型使用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="built_in">void</span> <span class="keyword">set</span>(E e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   .......................</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="2-5-泛型类派生子类"><a href="#2-5-泛型类派生子类" class="headerlink" title="2.5 泛型类派生子类"></a>2.5 泛型类派生子类</h3><p><strong>父类派生子类的时候不能在包含类型形参，需要传入具体的类型</strong></p>
<ul>
<li>错误的方式：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Container&lt;K</span>, <span class="title">V&gt;</span> </span>&#123;&#125;</span></pre></td></tr></table></figure>

<ul>
<li>正确的方式：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Container&lt;Integer</span>, <span class="title">String&gt;</span> </span>&#123;&#125;</span></pre></td></tr></table></figure>

<ul>
<li>也可以不指定具体的类型，系统就会把K,V形参当成Object类型处理</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Container</span> </span>&#123;&#125;</span></pre></td></tr></table></figure>

<h3 id="2-6-泛型构造器"><a href="#2-6-泛型构造器" class="headerlink" title="2.6 泛型构造器"></a>2.6 泛型构造器</h3><ul>
<li>构造器也是一种方法，所以也就产生了所谓的泛型构造器。</li>
<li>和使用普通方法一样没有区别，一种是显示指定泛型参数，另一种是隐式推断</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Person</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> &lt;T&gt; Person(T t) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">new</span> Person(<span class="number">22</span>);<span class="comment">// 隐式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">new</span> &lt;<span class="keyword">String</span>&gt; Person(<span class="string">"hello"</span>);<span class="comment">//显示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li><p>特殊说明：</p>
<ul>
<li>如果构造器是泛型构造器，同时该类也是一个泛型类的情况下应该如何使用泛型构造器：因为泛型构造器可以显式指定自己的类型参数（需要用到菱形，放在构造器之前），而泛型类自己的类型实参也需要指定（菱形放在构造器之后），这就同时出现了两个菱形了，这就会有一些小问题，具体用法再这里总结一下。 以下面这个例子为代表</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Person</span>&lt;<span class="symbol">E</span>&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> &lt;T&gt; Person(T t) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>正确用法：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person&lt;<span class="keyword">String</span>&gt; person = <span class="keyword">new</span> Person(<span class="string">"sss"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>PS：编译器会提醒你怎么做的</p>
</li>
</ul>
<h3 id="2-7-高级通配符"><a href="#2-7-高级通配符" class="headerlink" title="2.7 高级通配符"></a>2.7 高级通配符</h3><h4 id="2-7-1背景："><a href="#2-7-1背景：" class="headerlink" title="2.7.1背景："></a>2.7.1背景：</h4><h4 id="2-7-2-lt-extends-T-gt-上界通配符"><a href="#2-7-2-lt-extends-T-gt-上界通配符" class="headerlink" title="2.7.2 &lt;? extends T&gt; 上界通配符"></a>2.7.2 &lt;? extends T&gt; 上界通配符</h4><ul>
<li><ul>
<li>正因为无法确定具体的类型是什么，add方法受限（可以添加null，因为null表示任何类型），但可以从列表中获取元素后赋值给父类型。如上图中的第一个例子，第三个add()操作会受限，原因在于List和List是List&lt;? extends Animal&gt;的子类型。上界通配符顾名思义，&lt;? extends T&gt;表示的是类型的上界【包含自身】，因此通配的参数化类型可能是T或T的子类。</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//它表示集合中的所有元素都是Animal类型或者其子类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;? <span class="keyword">extends</span> Animal&gt;</span></pre></td></tr></table></figure>

<ul>
<li>例如：</li>
<li>这样就确定集合中元素的类型，虽然不确定具体的类型，但最起码知道其父类。然后进行其他操作。这就是所谓的上限通配符，使用关键字extends来实现，实例化时，指定类型实参只能是extends后类型的子类或其本身。</li>
</ul>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Cat是其子类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">List</span><span class="meta">&lt;?</span> extends Animal&gt; <span class="keyword">list</span> = <span class="keyword">new</span> ArrayList&lt;Cat&gt;();</span></pre></td></tr></table></figure>

<h4 id="2-7-3-lt-super-T-gt-下界通配符"><a href="#2-7-3-lt-super-T-gt-下界通配符" class="headerlink" title="2.7.3 &lt;? super T&gt; 下界通配符"></a>2.7.3 &lt;? super T&gt; 下界通配符</h4><ul>
<li><p>下界通配符&lt;? super T&gt;表示的是参数化类型是T的超类型（包含自身），层层至上，直至Object</p>
<ul>
<li>编译器无从判断get()返回的对象的类型是什么，因此get()方法受限。但是可以进行add()方法，add()方法可以添加T类型和T类型的子类型，如第二个例子中首先添加了一个Cat类型对象，然后添加了两个Cat子类类型的对象，这种方法是可行的，但是如果添加一个Animal类型的对象，显然将继承的关系弄反了，是不可行的。</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//它表示集合中的所有元素都是Cat类型或者其父类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">List</span> &lt;? <span class="keyword">super</span> Cat&gt;</span></pre></td></tr></table></figure>

<ul>
<li>例如这就是所谓的下限通配符，使用关键字super来实现，实例化时，指定类型实参只能是extends后类型的子类或其本身</li>
</ul>
</li>
<li><pre><code>//Animal是其父类
List&lt;? super Cat&gt; list = new ArrayList&lt;Animal&gt;();
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">#### <span class="number">2.7</span><span class="number">.4</span> &lt;?&gt; 无界通配符</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- 任意类型，如果没有明确，那么就是Object以及任意的Java类了</span></pre></td></tr><tr><td class="code"><pre><span class="line">- 无界通配符用&lt;?&gt;表示，?代表了任何的一种类型，能代表任何一种类型的只有null（Object本身也算是一种类型，但却不能代表任何一种类型，所以List和List的含义是不同的，前者类型是Object，也就是继承树的最上层，而后者的类型完全是未知的）</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">------</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">## <span class="number">3</span>、泛型擦除</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">### <span class="number">3.1</span> 概念</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">编译器编译带类型说明的集合时会去掉类型信息</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">### <span class="number">3.2</span> 验证实例：</span></pre></td></tr></table></figure>
public class GenericTest {
  public static void main(String[] args) {
      new GenericTest().testType();
  }
  public void testType(){
      ArrayList&lt;Integer&gt; collection1 = new ArrayList&lt;Integer&gt;();
      ArrayList&lt;String&gt; collection2= new ArrayList&lt;String&gt;();
      System.out.println(collection1.getClass()==collection2.getClass());
      //两者class类型一样,即字节码一致
      System.out.println(collection2.getClass().getName());
      //class均为java.util.ArrayList,并无实际类型参数信息
  }
}
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>输出结果：</span></pre></td></tr></table></figure>
true
java.util.ArrayList
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- 分析：</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - 这是因为不管为泛型的类型形参传入哪一种类型实参，对于Java来说，它们依然被当成同一类处理，在内存中也只占用一块内存空间。从Java泛型这一概念提出的目的来看，其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的<span class="keyword">class</span>文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - **在静态方法、静态初始化块或者静态变量的声明和初始化中不允许使用类型形参。由于系统中并不会真正生成泛型类，所以instanceof运算符后不能使用泛型类**</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">------</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">## <span class="number">4</span>、泛型与反射</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- 把泛型变量当成方法的参数，利用<span class="function"><span class="keyword">Method</span>类的<span class="title">getGenericParameterTypes</span>方法来获取泛型的实际类型参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">- 例子：</span></span></pre></td></tr></table></figure>
public class GenericTest {
  public static void main(String[] args) throws Exception {
      getParamType();
  }
   /*利用反射获取方法参数的实际参数类型*/
  public static void getParamType() throws NoSuchMethodException{
      Method method = GenericTest.class.getMethod(&quot;applyMap&quot;,Map.class);
      //获取方法的泛型参数的类型
      Type[] types = method.getGenericParameterTypes();
      System.out.println(types[0]);
      //参数化的类型
      ParameterizedType pType  = (ParameterizedType)types[0];
      //原始类型
      System.out.println(pType.getRawType());
      //实际类型参数
      System.out.println(pType.getActualTypeArguments()[0]);
      System.out.println(pType.getActualTypeArguments()[1]);
  }
  /*供测试参数类型的方法*/
  public static void applyMap(Map&lt;Integer,String&gt; map){
  }
}
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>输出结果：</span></pre></td></tr></table></figure>
java.util.Map&lt;java.lang.Integer, java.lang.String&gt;
interface java.util.Map
class java.lang.Integer
class java.lang.String
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>通过反射绕开编译器对泛型的类型限制</span></pre></td></tr></table></figure>
public static void main(String[] args) throws Exception {
  //定义一个包含int的链表
  ArrayList&lt;Integer&gt; al = new ArrayList&lt;Integer&gt;();
  al.add(1);
  al.add(2);
  //获取链表的add方法，注意这里是Object.class，如果写int.class会抛出NoSuchMethodException异常
  Method m = al.getClass().getMethod(&quot;add&quot;, Object.class);
  //调用反射中的add方法加入一个string类型的元素，因为add方法的实际参数是Object
  m.invoke(al, &quot;hello&quot;);
  System.out.println(al.get(2));
}
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">------</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">## <span class="number">5</span> 泛型的限制</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">### <span class="number">5.1</span> 模糊性错误</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- 对于泛型类User&lt;K,V&gt;而言，声明了两个泛型类参数。在类中根据不同的类型参数重载show方法。</span></pre></td></tr></table></figure>
public class User&lt;K, V&gt; {
  public void show(K k) { // 报错信息：&apos;show(K)&apos; clashes with &apos;show(V)&apos;; both methods have same erasure
  }
  public void show(V t) {
  }
}
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">由于泛型擦除，二者本质上都是Obejct类型。方法是一样的，所以编译器会报错。</span></pre></td></tr><tr><td class="code"><pre><span class="line">换一个方式：</span></pre></td></tr></table></figure>
public class User&lt;K, V&gt; {
  public void show(String k) {
  }
  public void show(V t) {
  }
}
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">使用结果：</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">![<span class="string">img</span>](<span class="link">http://image.winrains.cn/2019/08/20190828170342-95a82.png</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">可以正常的使用</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="section">### 5.2 不能实例化类型参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">编译器也不知道该创建那种类型的对象</span></pre></td></tr></table></figure>
public class User&lt;K, V&gt; {
  private K key = new K(); // 报错：Type parameter &apos;K&apos; cannot be instantiated directly
}
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">### <span class="number">5.3</span> 对静态成员的限制</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">静态方法无法访问类上定义的泛型；如果静态方法操作的类型不确定，必须要将泛型定义在方法上。</span></pre></td></tr><tr><td class="code"><pre><span class="line">**如果静态方法要使用泛型的话，必须将静态方法定义成泛型方法**。</span></pre></td></tr></table></figure>
public class User&lt;T&gt; {
  //错误
  private static T t;
  //错误
  public static T getT() {
      return t;
  }
  //正确
  public static &lt;K&gt; void test(K k) {
  }
}
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">### <span class="number">5.4</span> 对泛型数组的限制</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- 不能实例化元素类型为类型参数的数组，但是可以将数组指向类型兼容的数组的引用</span></pre></td></tr></table></figure>
public class User&lt;T&gt; {
  private T[] values;
  public User(T[] values) {
      //错误，不能实例化元素类型为类型参数的数组
      this.values = new T[5];
      //正确，可以将values 指向类型兼容的数组的引用
      this.values = values;
  }
}</code></pre></li>
</ul>
<h3 id="5-5-对泛型异常的限制"><a href="#5-5-对泛型异常的限制" class="headerlink" title="5.5 对泛型异常的限制"></a>5.5 对泛型异常的限制</h3><p>泛型类不能扩展 Throwable，意味着不能创建泛型异常类 <a href="https://link.juejin.im?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F501277%2Fwhy-doesnt-java-allow-generic-subclasses-of-throwable">答案链接</a></p>
<blockquote>
<p>作者：风吹过wu</p>
<p>来源：<a href="https://juejin.im/post/5d64d0f8f265da03a653264e" target="_blank" rel="noopener">https://juejin.im/post/5d64d0f8f265da03a653264e</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring data jpa 的使用与详解（二）：复杂动态查询及分页，排序</title>
    <url>/2019/12/26/Spring-data-jpa-%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%A4%8D%E6%9D%82%E5%8A%A8%E6%80%81%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%88%86%E9%A1%B5%EF%BC%8C%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>上一篇介绍了spring data jpa在spring boot中的基本搭建和整合，以及较为简单的查询，这一篇来说spring data jpa中如何实现较为复杂的查询及分页，排序。</p>
<a id="more"></a>

<h3 id="1-使用Specification实现复杂查询"><a href="#1-使用Specification实现复杂查询" class="headerlink" title="1 使用Specification实现复杂查询"></a>1 使用Specification实现复杂查询</h3><h4 id="1-1-什么是Specification"><a href="#1-1-什么是Specification" class="headerlink" title="1.1 什么是Specification"></a>1.1 什么是Specification</h4><p>Specification是springDateJpa中的一个接口，他是用于当jpa的一些基本CRUD操作的扩展，可以把他理解成一个spring jpa的复杂查询接口。其次我们需要了解Criteria 查询，这是是一种类型安全和更面向对象的查询。而Spring Data JPA支持JPA2.0的Criteria查询，相应的接口是JpaSpecificationExecutor。<br>而JpaSpecificationExecutor这个接口基本是围绕着Specification接口来定义的， Specification接口中只定义了如下一个方法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Predicate <span class="keyword">to</span><span class="constructor">Predicate(Root&lt;T&gt; <span class="params">root</span>, CriteriaQuery&lt;?&gt; <span class="params">query</span>, CriteriaBuilder <span class="params">cb</span>)</span>;</span></pre></td></tr></table></figure>

<p><strong>Criteria查询基本概念</strong><br>Criteria 查询是以元模型的概念为基础的，元模型是为具体持久化单元的受管实体定义的，这些实体可以是实体类，嵌入类或者映射的父类。<br><strong>CriteriaQuery接口</strong><br>代表一个specific的顶层查询对象，它包含着查询的各个部分，比如：select 、from、where、group by、order by等注意：CriteriaQuery对象只对实体类型或嵌入式类型的Criteria查询起作用。<br><strong>Root:</strong><br>代表Criteria查询的根对象，Criteria查询的查询根定义了实体类型，能为将来导航获得想要的结果，它与SQL查询中的FROM子句类似。 Root实例是类型化的，且定义了查询的FROM子句中能够出现的类型。root代表查询的实体类,query可以从中得到root对象,告诉jpa查询哪一个实体类,还可以添加查询条件,还可以结合EntityManager对象 得到最终查询的 TypedQuery对象。 <strong>CriteriaBuilder接口</strong><br>用来构建CritiaQuery的构建器对象Predicate：一个简单或复杂的谓词类型，其实就相当于条件或者是条件组合。 可通过 EntityManager.getCriteriaBuilder 而得。</p>
<h3 id="2-使用Specification进行复杂的动态查询"><a href="#2-使用Specification进行复杂的动态查询" class="headerlink" title="2 使用Specification进行复杂的动态查询"></a>2 使用Specification进行复杂的动态查询</h3><p>maven的依赖继续使用上一章的就可以，这里修改一下实体类和controller层。<br>请求实体类:</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">Data</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class AccountRequest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//从第几页开始</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="built_in">Integer</span> page;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//每一页查询多少</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="built_in">Integer</span> limit;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> pwd;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> email;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="built_in">Integer</span><span class="meta">[</span><span class="meta">]</span> types;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>实体类：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Table</span>(name = <span class="string">"account"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@ToString</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@EntityListeners</span>(AuditingEntityListener.class)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class Account &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Id</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@GenericGenerator</span>(name = <span class="string">"idGenerator"</span>, strategy = <span class="string">"uuid"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@GeneratedValue</span>(generator = <span class="string">"idGenerator"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(name = <span class="string">"username"</span>, unique = true, nullable = false, length = <span class="number">64</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String username;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(name = <span class="string">"password"</span>, nullable = false, length = <span class="number">64</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String password;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(name = <span class="string">"email"</span>, length = <span class="number">64</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String email;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(name = <span class="string">"type"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Short type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@CreatedDate</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(name = <span class="string">"create_time"</span>, nullable = false)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private LocalDateTime createTime;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Repository层：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">AccountRepository</span> <span class="symbol">extends</span> <span class="symbol">JpaRepository</span>&lt;<span class="symbol">Account</span>,<span class="symbol">String</span>&gt;, <span class="symbol">JpaSpecificationExecutor</span>&lt;<span class="symbol">Account</span>&gt; &#123;&#125;</span></pre></td></tr></table></figure>

<p>controller层（还是直接略过service层）</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">private AccountRepository repository;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@PostMapping("/get")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> List&lt;Account&gt; <span class="keyword">get</span>(@RequestBody AccountRequest request) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Specification&lt;Account&gt; specification = <span class="built_in">new</span> Specification&lt;Account&gt;() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">public</span> Predicate toPredicate(Root&lt;Account&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder builder) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            // 所有的断言 及条件</span></pre></td></tr><tr><td class="code"><pre><span class="line">            List&lt;Predicate&gt; predicates = <span class="built_in">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            // 精确匹配id pwd</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (request.getId() != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                predicates.<span class="keyword">add</span>(builder.equal(root.<span class="keyword">get</span>("id"), request.getId()));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (request.getPwd() != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                predicates.<span class="keyword">add</span>(builder.equal(root.<span class="keyword">get</span>("password"), request.getPwd()));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            // 模糊搜索 <span class="type">name</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (request.getName() != <span class="keyword">null</span> &amp;&amp; !request.getName().equals("")) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                predicates.<span class="keyword">add</span>(builder.<span class="keyword">like</span>(root.<span class="keyword">get</span>("username"), "%" + request.getName() + "%"));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (request.getEmail() != <span class="keyword">null</span> &amp;&amp; !request.getEmail().equals("")) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                predicates.<span class="keyword">add</span>(builder.<span class="keyword">like</span>(root.<span class="keyword">get</span>("email"), "%" + request.getEmail() + "%"));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            // <span class="keyword">in</span>范围查询</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (request.getTypes() != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                CriteriaBuilder.<span class="keyword">In</span>&lt;<span class="keyword">Object</span>&gt; <span class="keyword">types</span> = builder.<span class="keyword">in</span>(root.<span class="keyword">get</span>("type"));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> (<span class="type">Integer</span> <span class="keyword">type</span> : request.getTypes()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">types</span> = <span class="keyword">types</span>.<span class="keyword">value</span>(<span class="keyword">type</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                predicates.<span class="keyword">add</span>(<span class="keyword">types</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> builder.<span class="keyword">and</span>(predicates.toArray(<span class="built_in">new</span> Predicate[predicates.size()]));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;Account&gt; accounts = repository.findAll(specification);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> accounts;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过重写Specification的toPredicate的方法，这样一个复杂的动态sql查询就完成了，通过post请求直接就可以调用了。</p>
<h3 id="3-分页及排序"><a href="#3-分页及排序" class="headerlink" title="3 分页及排序"></a>3 分页及排序</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/page"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Account&gt; getPage(<span class="meta">@RequestBody</span> AccountRequest request) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Specification&lt;Account&gt; specification = <span class="keyword">new</span> Specification&lt;Account&gt;() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">public</span> Predicate toPredicate(Root&lt;Account&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                CriteriaBuilder criteriaBuilder) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            List&lt;Predicate&gt; predicates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// do anything</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> criteriaBuilder.and(predicates.toArray(<span class="keyword">new</span> Predicate[predicates.size()]));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 表示通过createTime进行 ASC排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    PageRequest page = <span class="keyword">new</span> PageRequest(request.getPage() - <span class="number">1</span>, request.getLimit(), Sort.Direction.ASC, <span class="string">"createTime"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Page&lt;Account&gt; pageInfo = repository.findAll(specification, page);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">return</span> pageInfo.<span class="title">getContent</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面的代码是在经过复杂查询并进行分页与排序，通过<code>PageRequest</code>来构建分页排序的规则。传入起始页及每页的数量，还有排序的规则及以哪个属性排序。<strong>jpa中是以第0页开始的，所以传参的时候需要注意！</strong><br>当然，如果你不需要进行复杂的查询也可以对数据进行分页及排序查询。<br>修改repository，使其继承<code>PagingAndSortingRepository</code>。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">@Repository</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">AccountRepository</span> <span class="symbol">extends</span> <span class="symbol">JpaRepository</span>&lt;<span class="symbol">Account</span>,<span class="symbol">String</span>&gt;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="symbol">JpaSpecificationExecutor</span>&lt;<span class="symbol">Account</span>&gt; , <span class="symbol">PagingAndSortingRepository</span>&lt;<span class="symbol">Account</span>,<span class="symbol">String</span>&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Page&lt;Account&gt; findByAge(<span class="built_in">int</span> age, Pageable pageable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用时先创建<code>pageable</code>参数，然后传进去就可以了。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示第1页每页显示3条</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">PageRequest pr = <span class="keyword">new</span> <span class="constructor">PageRequest(1,3)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//根据年龄进行查询</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Page&lt;Account&gt; stus = accountPageRepository.find<span class="constructor">ByAge(22,<span class="params">pr</span>)</span>;</span></pre></td></tr></table></figure>

<p>排序也是一样的，在repository中创建方法</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">List</span>&lt;Account&gt; findByPwd(String <span class="keyword">pwd</span>, <span class="keyword">Sort</span> <span class="keyword">sort</span>);</span></pre></td></tr></table></figure>

<p>调用的时候传入sort对象</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置排序方式为username降序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;Account&gt; accs = accountPageRepository.findByAge(<span class="string">"123456"</span>,<span class="keyword">new</span> <span class="keyword">Sort</span>(<span class="keyword">Sort</span>.Direction.DESC,<span class="string">"username"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//设置排序以username和type进行升序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">acc = accountPageRepository.findByAge(<span class="string">"123456"</span>,<span class="keyword">new</span> <span class="keyword">Sort</span>(<span class="keyword">Sort</span>.Direction.ASC,<span class="string">"username"</span>,<span class="string">"type"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//设置排序方式以name升序，以address降序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Sort</span> <span class="keyword">sort</span> = <span class="keyword">new</span> <span class="keyword">Sort</span>(<span class="keyword">new</span> <span class="keyword">Sort</span>.Order(<span class="keyword">Sort</span>.Direction.ASC,<span class="string">"name"</span>),<span class="keyword">new</span> <span class="keyword">Sort</span>.Order(<span class="keyword">Sort</span>.Direction.DESC,<span class="string">"type"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">accs = accountPageRepository.findByAge(<span class="string">"123456"</span>,<span class="keyword">sort</span>);</span></pre></td></tr></table></figure>

<blockquote>
<p>作者：爱西考的王同学</p>
<p>来源：<a href="https://juejin.im/post/5d64f70fe51d4561fa2ec09c" target="_blank" rel="noopener">https://juejin.im/post/5d64f70fe51d4561fa2ec09c</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
      </categories>
      <tags>
        <tag>Spring Data JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring data jpa 的使用与详解（一）：框架整合及基本使用</title>
    <url>/2019/12/26/Spring-data-jpa-%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%8F%8A%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1-什么是JPA"><a href="#1-什么是JPA" class="headerlink" title="1 什么是JPA"></a>1 什么是JPA</h3><p>JPA全称Java Persistence API，可以通过注解或者XML描述【对象-关系表】之间的映射关系，并将实体对象持久化到数据库中。JPA的出现主要是为了简化持久层开发以及整合ORM技术，结束Hibernate、TopLink、JDO等ORM框架各自为营的局面。<br>JAP为我们提供了<strong>ORM映射元数据</strong>,<strong>JPA的API</strong>,<strong>JPQL查询语言</strong>等,但JPA仅仅是一种规范，<strong>也就是说JPA仅仅定义了一些接口</strong>，而接口是需要实现才能工作的。所以底层需要某种实现，而Hibernate就是实现了JPA接口的ORM框架。</p>
<a id="more"></a>

<h3 id="2-什么是Hibernate框架"><a href="#2-什么是Hibernate框架" class="headerlink" title="2 什么是Hibernate框架"></a>2 <strong>什么是Hibernate框架</strong></h3><p>Hibernate是Java中的对象关系映射解决方案。对象关系映射或ORM是将应用程序域模型对象映射到关系数据库表的编程技术。Hibernate是一个基于Java的ORM工具，它提供了一个框架，用于将应用程序域对象映射到关系数据库表。<br>Hibernate提供了Java Persistence API的参考实现，使其成为具有松散耦合优势的ORM工具的绝佳选择。</p>
<h3 id="3-什么是Spring-Data-JPA"><a href="#3-什么是Spring-Data-JPA" class="headerlink" title="3 什么是Spring Data JPA"></a>3 什么是Spring Data JPA</h3><p>Spring Data是Spring Framework的一部分。Spring Data存储库抽象的目标是显著减少为各种持久性存储实现数据访问层所需的代码量。<br>Spring Data JPA不是JPA提供者。它是一个库/框架，它在我们的JPA提供程序（如Hibernate）的顶部添加了一个额外的抽象层。</p>
<h3 id="4-Hibernate和Spring-Data-JPA的关系"><a href="#4-Hibernate和Spring-Data-JPA的关系" class="headerlink" title="4 Hibernate和Spring Data JPA的关系"></a>4 Hibernate和Spring Data JPA的关系</h3><p>Hibernate是一个JPA实现，而Spring Data JPA是一个JPA数据访问抽象。Spring Data提供了GenericDao自定义实现的解决方案，它还可以通过方法名称约定代表您生成JPA查询。<br>Spring Data JPA不是一个实现或JPA提供者，它只是一个抽象，用于显著减少为各种持久性存储实现数据访问层所需的代码量。Spring Data JPA始终需要JPA提供程序，如Hibernate。</p>
<p><img src="http://image.winrains.cn/2019/08/20190828172848-a1ae9.png" alt="img"></p>
<h3 id="5-Spring-data-jpa概述"><a href="#5-Spring-data-jpa概述" class="headerlink" title="5 Spring data jpa概述"></a>5 Spring data jpa概述</h3><p>JPA Spring Data：致力于减少数据访问层（DAO）的开发量，开发者唯一要做的，就只是声明持久层的接口，其他都交给Spring Data JPA来完成。<br>框架怎么可能代替开发者实现业务逻辑呢？比如：当有一个 UserDao.findUserById() 这样一个方法声明，大致应该能判断出这是根据给定条件的 ID 查询出满足条件的 User 对象。Spring Data JPA 做的便是规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</p>
<h3 id="5-Spring-data-JPA使用"><a href="#5-Spring-data-JPA使用" class="headerlink" title="5 Spring data JPA使用"></a>5 Spring data JPA使用</h3><h4 id="5-1-jar包引入"><a href="#5-1-jar包引入" class="headerlink" title="5.1 jar包引入"></a>5.1 jar包引入</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure>

<h4 id="5-2-Spring-data-jpa配置"><a href="#5-2-Spring-data-jpa配置" class="headerlink" title="5.2 Spring data jpa配置"></a>5.2 Spring data jpa配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 借助spring data实现自动化的jpa repository，只需编写接口无需编写实现类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于xml配置的&lt;jpa:repositories base-package="com.example.repository" /&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// repositoryImplementationPostfix默认就是Impl</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// entityManagerFactoryRef默认就是entityManagerFactory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// transactionManagerRef默认就是transactionManager</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@EnableJpaRepositories</span>(basePackages = &#123;<span class="string">"com.wtj.repository"</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        repositoryImplementationPostfix = <span class="string">"Impl"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        entityManagerFactoryRef = <span class="string">"entityManagerFactory"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        transactionManagerRef = <span class="string">"transactionManager"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 启用事务管理器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//审计功能 用来自动填充@CreateDate等</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@EnableJpaAuditing</span>(dateTimeProviderRef = <span class="string">"dateTimeProvider"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDataJpaConfig</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> DateTimeProvider <span class="title">dateTimeProvider</span><span class="params">(DateTimeService dateTimeService)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> dateTimeService::getNow;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> JpaVendorAdapter <span class="title">jpaVendorAdapter</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        HibernateJpaVendorAdapter jpaVendorAdapter = <span class="keyword">new</span> HibernateJpaVendorAdapter();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 设置数据库类型（可使用org.springframework.orm.jpa.vendor包下的Database枚举类）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        jpaVendorAdapter.setDatabase(Database.MYSQL);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 设置打印sql语句</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        jpaVendorAdapter.setShowSql(<span class="keyword">true</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 设置不生成ddl语句</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        jpaVendorAdapter.setGenerateDdl(<span class="keyword">false</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 设置hibernate方言</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        jpaVendorAdapter.setDatabasePlatform(<span class="string">"org.hibernate.dialect.MySQL5Dialect"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> jpaVendorAdapter;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 配置实体管理器工厂</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactory</span><span class="params">(</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">            DataSource dataSource, JpaVendorAdapter jpaVendorAdapter)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        LocalContainerEntityManagerFactoryBean emfb = <span class="keyword">new</span> LocalContainerEntityManagerFactoryBean();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 注入数据源</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        emfb.setDataSource(dataSource);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 注入jpa厂商适配器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        emfb.setJpaVendorAdapter(jpaVendorAdapter);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 设置扫描基本包</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        emfb.setPackagesToScan(<span class="string">"com.wtj.entity"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> emfb;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 配置jpa事务管理器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">(EntityManagerFactory emf)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        JpaTransactionManager transactionManager = <span class="keyword">new</span> JpaTransactionManager();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 配置实体管理器工厂</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        transactionManager.setEntityManagerFactory(emf);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> transactionManager;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>启用web支持还需要在Spring MVC配置类上添加<code>@EnableSpringDataWebSupport</code>注解</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@ComponentScan</span>(basePackages = &#123;<span class="string">"com.wtj.controller"</span>&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@EnableWebMvc</span>   <span class="comment">// 启用spring mvc</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@EnableSpringDataWebSupport</span>     <span class="comment">// 启用springmvc对spring data的支持</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class WebMvcConfig extends WebMvcConfigurerAdapter &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">server</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">port</span>: <span class="number">20000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">servlet</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">context-path</span>: /</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attribute">spring</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">datasource</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">url</span>: <span class="attribute">jdbc</span>:<span class="attribute">mysql</span>:<span class="comment">//localhost:3306/mytest1?useUnicode=true&amp;serverTimezone=UTC&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;allowMultiQueries=true&amp;useSSL=false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">username</span>: root</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">password</span>: root</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">jpa</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">database</span>: MySQL</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">database-platform</span>: org.hibernate.dialect.MySQL5InnoDBDialect</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">show-sql</span>: true</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">hibernate</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attribute">ddl-auto</span>: update</span></pre></td></tr></table></figure>

<blockquote>
<p>ddl-auto 解释：</p>
</blockquote>
<ul>
<li>create : 每次运行程序时，都会重新创建表，故而数据会丢失。</li>
<li>create-drop：每次运行程序时会先创建表结构，然后待程序结束时清空表。</li>
<li>upadte：每次运行程序，没有表时会创建表，如果对象发生改变会更新表结构，原有数据不会清空，只会更新（推荐使用）。</li>
<li>validate：运行程序会校验数据与数据库的字段类型是否相同，字段不同会报错。</li>
<li>none: 禁用DDL处理。</li>
</ul>
<h4 id="5-3-简单的Spring-dat-jpa例子"><a href="#5-3-简单的Spring-dat-jpa例子" class="headerlink" title="5.3 简单的Spring dat jpa例子"></a>5.3 简单的Spring dat jpa例子</h4><p>例子简单就不写service层了，直接在controller中调用。<br><strong>创建实体类</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Table</span>(name = <span class="string">"account"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@ToString</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class Account &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Id</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@GenericGenerator</span>(name = <span class="string">"idGenerator"</span>, strategy = <span class="string">"uuid"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@GeneratedValue</span>(generator = <span class="string">"idGenerator"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(name = <span class="string">"username"</span>, unique = true, nullable = false, length = <span class="number">64</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String username;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(name = <span class="string">"password"</span>, nullable = false, length = <span class="number">64</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String password;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(name = <span class="string">"email"</span>, length = <span class="number">64</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String email;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>主键采用UUID策略 <code>@GenericGenerator</code>是Hibernate提供的主键生成策略注解，注意下面的<code>@GeneratedValue</code>（JPA注解）使用generator = “idGenerator”引用了上面的name = “idGenerator”主键生成策略。</p>
</blockquote>
<blockquote>
<p><strong>JPA自带的几种主键生成策略</strong><br>TABLE： 使用一个特定的数据库表格来保存主键。<br>SEQUENCE： 根据底层数据库的序列来生成主键，条件是数据库支持序列。这个值要与generator一起使用，generator 指定生成主键使用的生成器（可能是orcale中自己编写的序列）。<br>IDENTITY： 主键由数据库自动生成（主要是支持自动增长的数据库，如mysql）。<br>AUTO： 主键由程序控制，也是GenerationType的默认值。</p>
</blockquote>
<p><strong>dao层</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">@Repository</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">AccountRepository</span> <span class="symbol">extends</span> <span class="symbol">JpaRepository</span>&lt;<span class="symbol">Account</span>,<span class="symbol">String</span>&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>controller层</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = <span class="meta-string">"/role"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> AccountRepository repository;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@PostMapping()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> Account save(<span class="meta">@RequestBody</span> Account account) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> repository.save(account);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@DeleteMapping(<span class="meta-string">"/&#123;id&#125;"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> void delete(<span class="meta">@PathVariable(<span class="meta-string">"id"</span>)</span> String accountId) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        repository.deleteById(accountId);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@PutMapping(<span class="meta-string">"/&#123;id&#125;"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> Account update(<span class="meta">@PathVariable(<span class="meta-string">"id"</span>)</span> String accountId, <span class="meta">@RequestBody</span> Account account) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        account.setId(accountId);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> repository.saveAndFlush(account);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@GetMapping(<span class="meta-string">"/&#123;id&#125;"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> Account getAccountInfo(<span class="meta">@PathVariable(<span class="meta-string">"id"</span>)</span> String accountId) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Optional&lt;Account&gt; optional = repository.findById(accountId);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> optional.orElseGet(Account::new);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>最后在数据库中造几条假数据进行crud就可以了。</p>
<h4 id="5-4-Repository接口"><a href="#5-4-Repository接口" class="headerlink" title="5.4 Repository接口"></a>5.4 Repository接口</h4><p><strong>Repository 接口概述:</strong></p>
<ol>
<li>Repository 接口是 Spring Data 的一个核心接口，它不提供任何方法，是一个空接口，即是一个标记接口。开发者需要在自己定义的接口中声明需要的方法 。</li>
</ol>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Repository&lt;T, ID extends Serializable&gt; &#123; &#125;</span></pre></td></tr></table></figure>

<ol>
<li>Spring Data可以让我们只定义接口，只要遵循Spring Data的规范，就无需写实现类。</li>
<li>若我们定义的接口继承了Repository，则该接口会被IOC容器识别为一个Repository Bean，纳入到IOC容器中，进而可以在该接口中定义满足一定规范的方法。实际上在IOC容器中放的是该接口的实现类，只不过spring帮我们实现了，实际上它是一个代理。</li>
<li>与继承 Repository 等价的一种方式，就是在持久层接口上使用 @RepositoryDefinition 注解，并为其指定 domainClass 和 idClass 属性，指定对象和主键类型。</li>
</ol>
<p><strong>Repository 的子接口:</strong><br>基础的 Repository提供了最基本的数据访问功能，其几个子接口则扩展了一些功能。它们的继承关系如下：</p>
<ul>
<li>Repository：仅仅是一个标识，表明任何继承它的均为仓库接口类.</li>
<li>CrudRepository：继承Repository，实现了一组CRUD相关的方法.</li>
<li>PagingAndSortingRepository： 继承 CrudRepository，实现了一组分页排序相关的方法.</li>
<li>JpaRepository：继承PagingAndSortingRepository，实现一组JPA规范相关的方法.</li>
<li>自定义的 XxxxRepository 需要继承 JpaRepository，这样的XxxxRepository接口就具备了通用的数据访问控制层的能力.</li>
<li>JpaSpecificationExecutor：不属于Repository体系，实现一组JPACriteria 查询相关的方法.</li>
</ul>
<h4 id="5-5-自定义条件查询语句"><a href="#5-5-自定义条件查询语句" class="headerlink" title="5.5 自定义条件查询语句"></a>5.5 自定义条件查询语句</h4><p>按照 Spring Data的规范，查询方法以<code>find | read | get</code> 开头，涉及条件查询时，条件的属性用条件关键字连接，要注意的是：条件属性以首字母大写。 比如说现在要按照account的名称进行查询：<br>在AccountRepository接口中新增方法</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">@Repository</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">AccountRepository</span> <span class="symbol">extends</span> <span class="symbol">JpaRepository</span>&lt;<span class="symbol">Account</span>,<span class="symbol">String</span>&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Account findAccountByUsername(String username);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>controller中新增方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(<span class="meta-string">"/name/&#123;username&#125;"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Account getAccountByName(<span class="meta">@PathVariable(<span class="meta-string">"username"</span>)</span> String userName) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Account account = repository.findAccountByUsername(userName);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> account;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这样就可以根据名称进行查询了，当然你也可以使用这种方法进行复杂查询，spring data jpa中支持的关键字如下：</p>
<p><img src="http://image.winrains.cn/2019/08/20190828172850-cb242.png" alt="img"></p>
<p><img src="http://image.winrains.cn/2019/08/20190828172850-a36d8.png" alt="img"></p>
<h4 id="5-6-自定义sql语句"><a href="#5-6-自定义sql语句" class="headerlink" title="5.6 自定义sql语句"></a>5.6 自定义sql语句</h4><p>有些时候spring data jpa提供的查询条件满足不了业务需求的时候，可以使用自定义的sql来进行查询。<br>想要使用自定义sql需要使用<code>@Query</code>注解，@Query注解使用起来很简单，默认的属性是value，就是当前写的SQL语句，有时会用到nativeQuery属性，这个属性是用来标记当前的SQL是本地SQL，还是符合JPA语法规范的SQL。这里需要解释一下本地SQL和JPA语法规范的SQL区别。</p>
<ul>
<li>本地SQL，是根据实际使用的数据库类型写的SQL，这种SQL中使用到的一些语法格式不能被JPA解析以及可能不兼容其他数据库，这种SQL称为本地SQL，此时需要将nativeQuery属性设置为true，否则会报错。</li>
<li>JPA语法规范的SQL，往往这种SQL本身是不适用于任何数据库的，需要JPA将这种SQL转换成真正当前数据库所需要的SQL语法格式。</li>
</ul>
<blockquote>
<p>JPA很好的一个特性就是用JPA语法规范写的SQL，会根据当前系统使用的数据库类型改变生成的SQL语法，兼容数据库类型的切换，如之前使用的是MySQL，现在换成Oracle，由于不同类型的数据库，SQL语法会有区别，如果使用的是mybatis，就需要手动去改SQL兼容Oracle，而JPA就不用啦，无缝对接。<br>很大的时候使用JPA感觉都是为了兼容后期可能会有数据库切换的问题，所以在使用JPA的时候，不要去使用本地SQL，这就违背了使用JPA的初衷，让nativeQuery属性保持默认值就可以啦！</p>
</blockquote>
<p>AccountRepository中新增方法</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Query</span>(<span class="string">"select a from Account a where a.username = :username"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Account findAccountByName(<span class="variable">@Param</span>(<span class="string">"username"</span>)String name);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Query</span>(<span class="string">"select a from Account a where a.email = ?1"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Account findAccountByEmail(String email);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Query</span>(value = <span class="string">"select * from account where username = ?1"</span>,nativeQuery = true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Account getAccount(String username);</span></pre></td></tr></table></figure>

<ul>
<li>在SQL上使用占位符的两种方式，第一种是使用”:”后加变量的名称，第二种是使用”?”后加方法参数的位置。如果使用”:”的话，需要使用@Param注解来指定变量名；如果使用”?”就需要注意参数的位置。</li>
<li>使用JPA语句中SQL语句中直接用实体类代表表名，因为在实体类中使用了@Table注解，将该实体类和表进行了关联。 controller中新增方法（方法名还有url起的都比较随意。。。。。）</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(<span class="meta-string">"/sql/&#123;username&#125;"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Account findAccountByName(<span class="meta">@PathVariable(<span class="meta-string">"username"</span>)</span> String userName)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Account account = repository.findAccountByName(userName);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> account;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(<span class="meta-string">"/email/&#123;email&#125;"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Account findAccountByEmail(<span class="meta">@PathVariable(<span class="meta-string">"email"</span>)</span> String email)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Account account = repository.findAccountByEmail(email);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> account;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(<span class="meta-string">"/username/&#123;username&#125;"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Account getAccount(<span class="meta">@PathVariable(<span class="meta-string">"username"</span>)</span> String username)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Account account = repository.getAccount(username);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> account;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>最后通过请求就可以获得数据并且在控制台可以看到打印出的响应的sql。<br>当自定义sql涉及到删除，修改，插入的操作的时候需要加上<code>@Modifying</code>注解。注明当前方法是修改操作。</p>
<blockquote>
<p>作者：爱西考的王同学</p>
<p>来源：<a href="https://juejin.im/post/5d5ba7bae51d453b1e478ac5" target="_blank" rel="noopener">https://juejin.im/post/5d5ba7bae51d453b1e478ac5</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring Data JPA</category>
      </categories>
  </entry>
  <entry>
    <title>业务架构、应用架构与云基础架构</title>
    <url>/2019/12/26/%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84%E3%80%81%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E4%B8%8E%E4%BA%91%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<blockquote>
<p>本部分节选自《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-se.gitbook.io%2Fi%2F%3Fq%3D%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84">软件架构设计</a>》</p>
</blockquote>
<p>软件开发就是把一个复杂的问题分解为一系列简单的问题，再把一系列简单的解决方案组合成一个复杂的解决方案。而软件开发中最大的挑战，就是即能够快速高效地针对需求、环境的变化做出改变，也能够持续提供稳定、高可用的服务。而软件架构，就是软件系统的骨骼与框架。<br>所谓架构，见仁见智，很难有一个明确或标准的定义；但架构并非镜花水月或阳春白雪，有系统的地方就需要架构，大到航空飞机，小到一个电商系统里面的一个功能组件，都需要设计和架构。抽象而言，架构就是对系统中的实体以及实体之间的关系所进行的抽象描述，是对物/信息的功能与形式元素之间的对应情况所做的分配，是对元素之间的关系以及元素同周边环境之间的关系所做的定义。架构能将目标系统按某个原则进行切分，切分的原则，是要便于不同的角色进行并行工作，结构良好的创造活动要优于毫无结构的创造活动。</p>
<a id="more"></a>

<p><strong>软件架构的核心价值，即是控制系统的复杂性，将核心业务逻辑和技术细节的分离与解耦</strong>。软件架构是系统的草图，它描述的对象是直接构成系统的抽象组件；各个组件之间的连接则明确和相对细致地描述组件之间的通信。在实现阶段，这些抽象组件被细化为实际的组件，比如具体某个类或者对象。在面向对象领域中，组件之间的连接通常用接口来实现。架构师的职责是努力训练自己的思维，用它去理解复杂的系统，通过合理的分解和抽象，理解并解析需求，创建有用的模型，确认、细化并扩展模型，管理架构；能够进行系统分解形成整体架构，能够正确的技术选型，能够制定技术规格说明并有效推动实施落地。</p>
<h1 id="软件架构分类"><a href="#软件架构分类" class="headerlink" title="软件架构分类"></a>软件架构分类</h1><p>在笔者的知识体系中，实际上将架构分为业务架构、应用架构、云基础架构这几大类，业务架构主要着眼于控制业务的复杂性，基础架构着眼于解决分布式系统中存在的一系列问题。无论何种架构，都希望能实现系统的可变的同时保障业务的高可用。另一个层面，根据企业中职责的划分，我们往往可以将软件架构，及关联的架构师划分为以下几类：</p>
<ul>
<li>业务架构/解决方案架构：核心是解决业务带来的系统复杂性，了解客户/业务方的痛点，项目定义，现有环境；梳理高阶需求和非功能性需求，进行问题域划分与领域建模等工作；沟通，方案建议，多次迭代，交付总体架构。</li>
<li>应用架构：根据业务场景的需要，设计应用的层次结构，制定应用规范、定义接口和数据交互协议等。并尽量将应用的复杂度控制在一个可以接受的水平，从而在快速的支撑业务发展的同时，在保证系统的可用性和可维护性的同时，确保应用满足非功能属性要求（性能、安全、稳定性等）。</li>
<li>数据架构：专注于构建数据中台，统一数据定义规范，标准化数据表达，形成有效易维护的数据资产。打造统一的大数据处理平台，包括数据可视化运营平台、数据共享平台、数据权限管理平台等。</li>
<li>中间件架构：专注于中间件系统的构建，需要解决服务器负载，分布式服务的注册和发现，消息系统，缓存系统，分布式数据库等问题，同时架构师要在 CAP 之间进行权衡。</li>
<li>运维架构：负责运维系统的规划、选型、部署上线，建立规范化的运维体系。</li>
<li>物理架构：物理架构关注软件元件是如何放到硬件上的，专注于基础设施，某种软硬件体系，甚至云平台，包括机房搭建、网络拓扑结构，网络分流器、代理服务器、Web 服务器、应用服务器、报表服务器、整合服务器、存储服务器和主机等。</li>
</ul>
<h2 id="架构模式与架构风格"><a href="#架构模式与架构风格" class="headerlink" title="架构模式与架构风格"></a>架构模式与架构风格</h2><p>软件架构设计的一个核心问题是能否使用重复的架构模式，即能否达到架构级的软件重用。也就是说，能否在不同的软件系统中，使用同一架构。当我们讨论软件架构时，常常会提及软件架构模式（Architectural Pattern）与软件架构风格（Architectural Style）。<br>软件架构模式往往会用于具体地解决某个具体的重复的架构问题，而架构风格则是对于某个具体的架构设计方案的命名。软件架构风格是描述某一特定应用领域中系统组织方式的惯用模式；架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效组织成一个完整的系统。<br>在笔者的系列文章中，CRUD、分层架构、六边形架构、洋葱架构、REST 以及 DDD，都算是架构风格；而 CQRS、EDA、UDLA、微服务等则被划分到架构模式中。</p>
<h2 id="系统复杂性的来源与应对"><a href="#系统复杂性的来源与应对" class="headerlink" title="系统复杂性的来源与应对"></a>系统复杂性的来源与应对</h2><p>在软件开发中，程序员往往能够脱离现实规律的束缚，创造出天马行空的世界，其也是最具有创造力的活动之一。编程唯一需要的是创造力思维和思维组织能力，这意味着在软件开发过程中最大限制是理解我们正在创建的对象。随着软件的演进，加入更多的功能点，系统变得越来越复杂：各个模块（Module）间存在着各种微妙的依赖关系。系统的复杂性随着时间积累，对于程序员来说，修改系统时考虑周全所有的的相关因素变得越来越困难。这就会使软件开放进度变缓慢，并且引入 Bug，而导致会进一步延缓开发进度，增加开发成本。在任何一个系统的生命周期中，复杂性不可避免会增加；系统越大，需要更多的人开发，管理系统复杂性的工作就越困难。<br>Eric Evans 在 Domain‐Driven Design 一书中吐槽了所谓的意大利面式架构，即代码确实做了有用的事，但很难解释它是如何去执行的；他认为造成这种窘境的主要原因是，将领域问题的复杂度与技术细节的复杂度混合在了一起，最终导致整体复杂度的指数级增长。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084125-e6d37.png" alt="img"></p>
<p>复杂性不是凭空而来，很多时候也不是刻意为之，这也就意味着复杂性的增加往往不会以我们的主观意志为转移。就像房间里的大象，我们无法逃避，也不能视而不见。复杂性的来源可能是：</p>
<ul>
<li>吸积与持续迭代：增量式设计意味着软件设计永不结束，设计在系统的生命周期中持续发生，程序员要时刻考虑设计问题。增量开发也意味着持续重构。一个系统的初始设计几乎从来都不是最好的方案。随着经验的增加，必然会发现更好的设计方案。</li>
<li>交互且无扩展性设计：当吸积效应导致的大规模系统，结合了交互这个特性，会使技术系统更加复杂。一个技术系统除了作用于自身，还会与其它大量系统产生交互。比如下单购买一件商品，那么订单系统，商品系统，支付系统，物流系统，卡券系统就会交互协作。这样吸积的复杂性，由于交互特性的出现，会呈现几何级数上升。</li>
<li>不合理的业务封装：不合理的业务封装是一个相对宽泛的概念，其具体的表现譬如面向过程而不是对象、分层不合理等。</li>
<li>缺乏统一语言：典型的敏捷开发的结构，流水线上的各个角色往往会专注于自己负责的环节，精细化的分工也限制了每个角色的全局视角；虽然我们经常提倡所谓的主人翁意识，但是在落地时又很难去推进。</li>
<li>缺乏约束与规范：在团队协作开发的背景下，缺少规范和约束会严重损害架构的一致性（Consistency），代码的可维护性将急剧下降。可能规范在实现层面就是命名、分包等不影响代码运行的小问题，但是千里之堤，溃于蚁穴，正是这些微末的不注意导致了整体复杂性的雪崩。</li>
</ul>
<p>复杂性的应对永远不会是一劳永逸，我们需要不断地推陈出新，是动态、渐进的重塑自己对软件系统的认识，不断认识问题和寻找更优解的持续迭代。第一个控制复杂性的途径是代码简单，意图清晰（Obvious）。例如: 减少特殊场景的处理，或变量命名一致性都能降低系统复杂性。另一种方式就是对复杂问题的抽象然后分而治之。</p>
<h2 id="领域驱动设计"><a href="#领域驱动设计" class="headerlink" title="领域驱动设计"></a>领域驱动设计</h2><p><img src="http://image.winrains.cn/2019/08/20190829084126-4077f.png" alt="领域驱动设计"></p>
<blockquote>
<p>本部分节选自《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-se.gitbook.io%2Fi%2F%3Fq%3D%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1">领域驱动设计</a>》</p>
</blockquote>
<p>DDD 领域驱动设计，起源于 2004 年著名建模专家 Eric Evans 发表的他最具影响力的著名书籍：《Domain-Driven Design – Tackling Complexity in the Heart of Software》，Eric Evans 在该书中只是提供了一套原始理论，并没有提供一套方法论，因此多年来对于 DDD 也是见仁见智。更早些时候 MartinFowler 曾经提出贫血模型与充血模型的概念，他认为我们大多数系统以 POJO 作为模型，只有普通的 getter、setter 方法，没有真正的行为，好像缺少血液的人，在 Evans 看来，DDD 中模型都是以充血形式存在，也就是说在 DDD 中，我们设计的模型不仅包含描述业务属性，还要包含能够描述动作的方法，不同的是，领域中一些概念不能用在模型对象，如仓储、工厂、服务等，如强加于模型中，将破坏模型的定义。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084126-3a049.png" alt="领域驱动设计架构"></p>
<p>领域驱动设计的战略核心即是将问题域与应用架构相剥离，将业务语义显现化，把原先晦涩难懂的业务算法逻辑，通过领域对象（Domain Object），统一语言（Ubiquitous Language）转化为领域概念清晰的显性化表达出来。</p>
<ul>
<li>统一语言，软件的开发人员/使用人员都使用同一套语言，即对某个概念，名词的认知是统一的，建立清晰的业务模型，形成统一的业务语义。将模型作为语言的支柱。确保团队在内部的所有交流中，代码中，画图，写东西，特别是讲话的时候都要使用这种语言。例如账号，转账，透支策略，这些都是非常重要的领域概念，如果这些命名都和我们日常讨论以及 PRD 中的描述保持一致，将会极大提升代码的可读性，减少认知成本。。比如不再会有人在会议中对“工单”、“审核单”、“表单”而反复确认含义了，DDD 的模型建立不会被 DB 所绑架。</li>
<li>面向领域，业务语义显性化，以领域去思考问题，而不是模块。将隐式的业务逻辑从一推 if-else 里面抽取出来，用通用语言去命名、去写代码、去扩展，让其变成显示概念；很多重要的业务概念，按照事务脚本的写法，其含义完全淹没在代码逻辑中没有突显出来。</li>
<li>职责划分，根据实际业务合理划分模型，模型之间依赖结构和边界更加清晰，避免了混乱的依赖关系，进而增加可读性、可维护性；单一职责，模型只关注自身的本职工作，避免“越权”而导致混乱的调用关系。通过建模，更好的表达现实世界中的复杂业务，随着时间的发展，不断增加系统对实际业务的沉淀，也将更好的通过清晰的代码描述业务逻辑，模型的内聚增加了系统的高度模块化，提升代码的可重用性，对比传统三层模式中，很有可能大量重复的功能散落在各个 Service 内部。</li>
</ul>
<h1 id="微服务与云原生架构"><a href="#微服务与云原生架构" class="headerlink" title="微服务与云原生架构"></a>微服务与云原生架构</h1><blockquote>
<p>本部分节选自《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-be.gitbook.io%2Fi%2F%3Fq%3D%E5%BE%AE%E6%9C%8D%E5%8A%A1">微服务与云原生</a>》</p>
</blockquote>
<p><img src="http://image.winrains.cn/2019/08/20190829084127-4ff85.png" alt="服务衍化"></p>
<h2 id="单体分层架构"><a href="#单体分层架构" class="headerlink" title="单体分层架构"></a>单体分层架构</h2><p>在 Web 应用程序发展的早期，大部分工程是将所有的服务端功能模块打包到单个巨石型（Monolith）应用中，譬如很多企业的 Java 应用程序打包为 war 包，最终会形成如下的架构：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084128-a1f71.png" alt="img"></p>
<p>巨石型应用易于搭建开发环境、易于测试、易于部署；其缺陷也非常明显，无法进行局部改动与部署，编译时间过长，回归测试周期过长，开发效率降低等。集中式架构分为标准的三层：数据访问层、服务层和 Web 层。<br>在 Web2.0 时代刚刚流行的时候，互联网应用与企业级应用并没有本质的区别，集中式架构分为标准的三层：数据访问层、服务层和 Web 层。</p>
<ul>
<li>数据访问层用于定义数据访问接口，实现对真实数据库的访问；</li>
<li>服务层用于对应用业务逻辑进行处理；</li>
<li>Web 层用于处理异常、逻辑跳转控制、页面渲染模板等。</li>
</ul>
<h2 id="SOA-面向服务架构"><a href="#SOA-面向服务架构" class="headerlink" title="SOA 面向服务架构"></a>SOA 面向服务架构</h2><p>SOA（Service-Oriented Architecture） 面向服务架构，是在互联网应用规模迅速增长，集中式架构已无法做到无限制地提升系统的吞吐量的背景下，产生的涉及模块化开发、分布式扩展部署等相对宽泛的概念。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084128-ec735.png" alt="img"></p>
<p>SOA 是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。SOA 中的接口独立于实现服务的硬件平台、操作系统和编程语言，采用中立的方式进行定义。这使得构建在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。面向服务架构，它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用。服务层是 SOA 的基础，可以直接被应用调用，从而有效控制系统中与软件代理交互的人为依赖性。<br>实施 SOA 的关键目标是实现企业 IT 资产的最大化作用。要实现这一目标，就要在实施 SOA 的过程中牢记以下特征：可从企业外部访问、随时可用、粗粒度的服务接口分级、松散耦合、可重用的服务、服务接口设计管理、标准化的服务接口、支持各种消息模式、精确定义的服务契约。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084129-6d44b.png" alt="img"></p>
<p>服务消费者（Service Consumer）可以通过发送消息来调用服务，这些消息由一个服务总线（Service Bus）转换后发送给适当的服务实现。这种服务架构可以提供一个业务规则引（Business Rules Engine），该引擎容许业务规则被合并在一个服务里或多个服务里。这种架构也提供了一个服务管理基础（Service Management Infrastructure），用来管理服务，类似审核，列表（billing），日志等功能。此外，该架构给企业提供了灵活的业务流程，更好地处理控制请求（Regulatory Requirement），例如 Sarbanes Oxley（SOX），并且可以在不影响其他服务的情况下更改某项服务。<br>由于分布式系统十分复杂，因此产生了大量的用于简化分布式系统开发的分布式中间件和分布式数据库，服务化的架构设计理念也被越来越多的公司所认同。如下是 Dubbo 官方文档公布了一张有关 SOA 系统演化过程的图片：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084130-c028a.jpeg" alt="img"></p>
<h2 id="MSA-微服务架构"><a href="#MSA-微服务架构" class="headerlink" title="MSA 微服务架构"></a>MSA 微服务架构</h2><p>微服务（Microservices Architecture Pattern）由 Martin Fowler 在 2014 年提出的，是希望将某个单一的单体应用，转化为多个可以独立运行、独立开发、独立部署、独立维护的服务或者应用的聚合，从而满足业务快速变化及分布式多团队并行开发的需求。如康威定律（Conway’s Law）所言，任何组织在设计一套系统（广义概念）时，所交付的设计方案在结构上都与该组织的通信结构保持一致，微服务与微前端不仅仅是技术架构的变化，还包含了组织方式、沟通方式的变化。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084131-24bd9.png" alt="img"></p>
<p>对于微服务，不同背景的人也有不同的见解，对于熟悉 SOA 的开发者，微服务也可以认为是去除了 ESB 的 SOA 的一种实现方案；ESB 是 SOA 架构中的中心总线，设计图形应该是星形的，而微服务是去中心化的分布式软件架构。SOA 更多强调重用，而微服务偏向于重写。SOA 偏向水平服务，微服务偏向垂直服务；SOA 偏向自上而下的设计，微服务偏向自下而上的设计。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084132-c149e.png" alt="img"></p>
<p>微服务与微前端原理和软件工程，面向对象设计中的原理同样相通，都是遵循单一职责(Single Responsibility)、关注分离(Separation of Concerns)、模块化(Modularity)与分而治之(Divide &amp; Conquer)等基本的原则。从巨石型应用到微服务的衍化也并非一蹴而就，如下图也演示了简单的渐进式替代过程：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084133-bd151.png" alt="img"></p>
<p><img src="http://image.winrains.cn/2019/08/20190829084134-1dc20.png" alt="img"></p>
<h2 id="Cloud-Native-云原生架构"><a href="#Cloud-Native-云原生架构" class="headerlink" title="Cloud Native 云原生架构"></a>Cloud Native 云原生架构</h2><blockquote>
<p>云原生是通过构建团队、文化和技术，利用自动化和架构来管理系统的复杂性和解放生产力。 — Joe Beda，Heotio CTO，联合创始人</p>
</blockquote>
<p><img src="http://image.winrains.cn/2019/08/20190829084136-e1caf.png" alt="img"></p>
<p>Pivotal 是云原生应用的提出者，并推出了 Pivotal Cloud Foundry 云原生应用平台和 Spring 开源 Java 开发框架，成为云原生应用架构中先驱者和探路者。早在 2015 年 Pivotal 公司的 Matt Stine 写了一本叫做迁移到云原生应用架构的小册子，其中探讨了云原生应用架构的几个主要特征：符合 12 Factors 应用、面向微服务架构、自服务敏捷架构、基于 API 的协作以及抗脆弱性。2015 年 Google 主导成立了云原生计算基金会（CNCF），起初 CNCF 对云原生（Cloud Native）的定义包含以下三个方面：应用容器化、面向微服务架构、应用支持容器的编排调度。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084137-d09a8.png" alt="img"></p>
<p>云原生应用程序简单地定义为从头开始为云计算架构而构建应用程序；这意味着，如果我们将应用程序设计为预期将部署在分布式、可扩展的基础架构上，我们的应用程序就是云原生的。随着公共云将承载越来越多的算力，未来云计算将是主流的 IT 能力交付方式，CNCF 也对云原生进行了重新定义：云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用；云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API。</p>
<ul>
<li>Codeless 对应的是服务开发，实现了源代码托管，你只需要关注你的代码实现，而不需要关心你的代码在哪，因为在整个开发过程中你都不会感受到代码库和代码分支的存在。</li>
<li>Applicationless 对应的是服务发布，在服务化框架下，你的服务发布不再需要申请应用，也不需要关注你的应用在哪。</li>
<li>Serverless 对应的则是服务运维，有了 Serverless 化能力，你不再需要关注你的机器资源，Servlerless 会帮你搞定机器资源的弹性扩缩容</li>
</ul>
<p>这些技术组合搭配，能够构建容错性好、易于管理和便于观察的松耦合系统；再结合可靠的自动化手段，云原生技术能够使工程师轻松地对系统作出频繁和可预测的重大变更。由此可见，云原生是保障系统能力灵动性地有效抓手；云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。微服务架构非常适合云原生应用程序；但是，云原生同样存在着一定的限制，如果你的云原生应用程序部署在 AWS 等公有云上，则云原生 API 不是跨云平台的。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084138-a47dc.png" alt="img"></p>
<p>云原生应用的关键属性包括了：使用轻量级的容器打包、使用最合适的语言和框架开发、以松耦合的微服务方式设计、以 API 为中心的交互和协作、无状态和有状态服务在架构上界限清晰、不依赖于底层操作系统和服务器、部署在自服务、弹性的云基础设施上、通过敏捷的 DevOps 流程管理、自动化能力、通过定义和策略驱动的资源分配。云原生是分布式应用当下重要的发展路径，其终态应当是 Distributionless，所有与分布式相关的问题由云平台解，分布式应用的开发会跟传统应用的开发一样方便，甚至更加便捷。</p>
<h1 id="云基础架构"><a href="#云基础架构" class="headerlink" title="云基础架构"></a>云基础架构</h1><blockquote>
<p>本部分节选自《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-infras.gitbook.io%2Fi%2F">分布式基础架构之虚拟化与编排</a>》</p>
</blockquote>
<p><img src="http://image.winrains.cn/2019/08/20190829084140-51d5f.png" alt="应用基础架构变迁"></p>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>虚拟机由某些特定的硬件和内核虚拟化组成，运行客户操作系统。称为管理程序的软件创建虚拟化硬件，其可以包括虚拟磁盘，虚拟网络接口，虚拟 CPU 等。虚拟机还包括可以与此虚拟硬件通信的宾客内核。管理程序可以托管，这意味着它是一些在主机操作系统（MacOS）上运行的软件，如示例中所示。它也可以是裸机，直接在机器硬件上运行（替换你的操作系统）。无论哪种方式，管理程序方法都被认为是重量级的，因为它需要虚拟化多个部分（如果不是全部硬件和内核）。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084141-249d1.png" alt="img"></p>
<p>VM 需要硬件虚拟化才能实现机器级隔离，而容器则只需要在同一操作系统内进行隔离操作。 随着隔离空间数量的增加，开销差异变得非常明显。</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>在过去几年里，云平台发展迅速，但其中困扰运维工程师最多的，是需要为各种迥异的开发语言安装相应的运行时环境。虽然自动化运维工具可以降低环境搭建的复杂度，但仍然不能从根本上解决环境的问题。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084142-766b5.png" alt="img"></p>
<p>Docker 的出现成为了软件开发行业新的分水岭，容器技术的成熟也标志着技术新纪元的开启。Docker 提供了让开发工程师可以将应用和依赖封装到一个可移植的容器中的能力，这项举措使得 Docker 大有席卷整个软件行业并且进而改变行业游戏规则的趋势，这像极了当年智能手机刚出现时的场景——改变了整个手机行业的游戏规则。Docker 通过集装箱式的封装方式，让开发工程师和运维工程师都能够以 Docker 所提供的镜像分发的标准化方式发布应用，使得异构语言不再是捆绑团队的枷锁。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084143-4d164.png" alt="img"></p>
<p>容器是包含应用程序代码，配置和依赖关系的软件包，可提供运营效率和生产力。容器为我们提供了可预测的，可重复的和不可变的运行预期，容器的兴起是 DevOps 即服务的一个巨大推动因素，可以克服当今面临的最大安全障碍。容器化通过在操作系统级别进行虚拟化来使应用程序可移植，从而创建基于内核的隔离的封装系统。容器化的应用程序可以放在任何地方，无需依赖项运行或需要整个 VM，从而消除了依赖关系。<br>作为独立的单元，容器能够在任何主机操作系统，CentOS，Ubuntu，MacOS，甚至是像 Windows 这样的非 UNIX 系统中运行。容器还充当标准化的工作或计算单元。一个常见的范例是每个容器运行单个 Web 服务器，数据库的单个分片或单个 Spark 工作程序等，只需要扩展容器的数量就能够便捷地扩展应用。每个容器都有一个固定的资源配置（CPU，RAM，线程数等），并且扩展应用程序需要只扩展容器的数量而不是单个资源原语。当应用程序需要按比例放大或缩小时，这为工程师提供了更容易的抽象。容器也是实现微服务架构的一个很好的工具，每个微服务只是一组协作容器。例如，可以使用单个主容器和多个从容器来实现 Redis 微服务。</p>
<h2 id="Kubernetes-与编排"><a href="#Kubernetes-与编排" class="headerlink" title="Kubernetes 与编排"></a>Kubernetes 与编排</h2><p>随着虚拟化技术的成熟和分布式架构的普及，用来部署、管理和运行应用的云平台被越来越多地提及。IaaS、PaaS 和 SaaS 是云计算的三种基本服务类型，分别表示关注硬件基础设施的基础设施即服务、关注软件和中间件平台的平台即服务，以及关注业务应用的软件即服务。容器的出现，使原有的基于虚拟机的云主机应用，彻底转变为更加灵活和轻量的容器与编排调度的云平台应用。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084144-5aac4.png" alt="img"></p>
<p>然而容器单元越来越散落使得管理成本逐渐上升，大家对容器编排工具的需求前所未有的强烈，Kubernetes、Mesos、Swarm 等为云原生应用提供了强有力的编排和调度能力，它们是云平台上的分布式操作系统。容器编排是通常可以部署多个容器以通过自动化实现应用程序的过程。像 Kubernetes 和 Docker Swarm 这样的容器管理和容器编排引擎，使用户能够指导容器部署并自动执行更新，运行状况监视和故障转移过程。<br>Kubernetes 是目前世界范围内关注度最高的开源项目，它是一个出色的容器编排系统，用于提供一站式服务。Kubernetes 出身于互联网行业巨头 Google，它借鉴了由上百位工程师花费十多年时间打造的 Borg 系统的理念，安装极其简易，网络层对接方式十分灵活。Kubernetes 和 Mesos 的出色表现给行业中各类工程师的工作模式带来了颠覆性的改变。他们再也不用关注每一台服务器，当服务器出现问题时，只要将其换掉即可。业务开发工程师不必再过分关注非功能需求，只需专注自己的业务领域即可。而中间件开发工程师则需要开发出健壮的云原生中间件，用来连接业务应用与云平台。<br>Kubernetes、Service Mesh 和 Serverless 三者共同演绎不同层次的封装和向上屏蔽下面的细节。Kubernetes 引入了不同的设计模式，实现对各种云资源全新、有效和优雅的抽象和管理模式，让集群的管理和应用发布变成了件相当轻松且不易出错的事。被广泛采用的微服务软件架构将分布式应用的各种复杂度迁移到了服务之间，如何通过全局一致、体系化、规范化和无侵入的手段进行治理就变成了微服务软件架构下至关重要的内容。Kubernetes 细化的应用程序的分解粒度，同时将服务发现、配置管理、负载均衡和健康检查等作为基础设施的功能，简化了应用程序的开发。而 Kubernetes 这种声明式配置尤其适合 CI/CD 流程，况且现在还有如 Helm、Draft、Spinnaker、Skaffold 等开源工具可以帮助我们发布 Kuberentes 应用。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084145-f0e6e.png" alt="img"></p>
<p>Service Mesh 通过将各服务所共用和与环境相关的内容剥离到部署于每个服务边上的 Sidecar 进程而轻松地做到了。这一剥离动作使得服务与平台能充分解耦而方便各自演进与发展，也使得服务变轻而有助于改善服务启停的及时性。Service Mesh 因为将那些服务治理相关的逻辑剥离到了 Sidecar 中且作为独立进程，所以 Sidecar 所实现的功能天然地支持多语言，为上面的服务采用多语言开发创造了更为有利的条件。通过 Service Mesh 对整个网络的服务流量进行技术收口，让异地多活这样涉及流量调度的系统工程实现起来更加优雅、简洁与有效，也能更加方便地实现服务版本升级时的灰度、回滚而改善安全生产质量。由于技术收口，给服务流量的治理和演进、排错、日志采集的经济性等疑难问题创造了新的发展空间。</p>
<h1 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h1><p><img src="http://image.winrains.cn/2019/08/20190829084146-b3ca1.png" alt="img"></p>
<p>您可以通过以下导航来在 Gitbook 中阅读笔者的系列文章，涵盖了技术资料归纳、编程语言与理论、Web 与大前端、服务端开发与基础架构、云计算与大数据、数据科学与人工智能、产品设计等多个领域：</p>
<ul>
<li><p>知识体系：《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-al.gitbook.io%2Fi%2F">Awesome Lists | CS 资料集锦</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-ac.gitbook.io%2Fi%2F">Awesome CheatSheets | 速学速查手册</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwx-chevalier%2FAwesome-Interviews">Awesome Interviews | 求职面试必备</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwx-chevalier%2FAwesome-RoadMaps">Awesome RoadMaps | 程序员进阶指南</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwx-chevalier%2FAwesome-MindMaps">Awesome MindMaps | 知识脉络思维脑图</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwx-chevalier%2FAwesome-CS-Books">Awesome-CS-Books | 开源书籍（.pdf）汇总</a>》</p>
</li>
<li><p>编程语言：《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-pl.gitbook.io%2Fi%2F">编程语言理论</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-pl.gitbook.io%2Fi%2Fjava%2Fjava">Java 实战</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-pl.gitbook.io%2Fi%2Fjavascript%2Fjavascript">JavaScript 实战</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-pl.gitbook.io%2Fi%2Fgo%2Fgo">Go 实战</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-pl.gitbook.io%2Fi%2Fpython%2Fpython">Python 实战</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-pl.gitbook.io%2Fi%2Frust%2Frust">Rust 实战</a>》</p>
</li>
<li><p>软件工程、模式与架构：《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-se.gitbook.io%2Fi%2F">编程范式与设计模式</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-se.gitbook.io%2Fi%2F">数据结构与算法</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-se.gitbook.io%2Fi%2F">软件架构设计</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-se.gitbook.io%2Fi%2F">整洁与重构</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-se.gitbook.io%2Fi%2F">研发方式与工具</a>》</p>
</li>
<li><p>Web 与大前端：《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-web.gitbook.io%2Fi%2F">现代 Web 开发基础与工程实践</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-fe.gitbook.io%2Fi%2F">数据可视化</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-fe.gitbook.io%2Fi%2F">iOS</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-fe.gitbook.io%2Fi%2F">Android</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-fe.gitbook.io%2Fi%2F">混合开发与跨端应用</a>》</p>
</li>
<li><p>服务端开发实践与工程架构：《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-be.gitbook.io%2Fi%2F">服务端基础</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-be.gitbook.io%2Fi%2F">微服务与云原生</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-be.gitbook.io%2Fi%2F">测试与高可用保障</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-be.gitbook.io%2Fi%2F">DevOps</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-be.gitbook.io%2Fi%2F">Node</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-be.gitbook.io%2Fi%2F">Spring</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-be.gitbook.io%2Fi%2F">信息安全与渗透测试</a>》</p>
</li>
<li><p>分布式基础架构：《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-infras.gitbook.io%2Fi%2F">分布式系统</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-infras.gitbook.io%2Fi%2F">分布式计算</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-infras.gitbook.io%2Fi%2F">数据库</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-infras.gitbook.io%2Fi%2F">网络</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-infras.gitbook.io%2Fi%2F">虚拟化与编排</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-infras.gitbook.io%2Fi%2F">云计算与大数据</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-infras.gitbook.io%2Fi%2F">Linux 与操作系统</a>》</p>
</li>
<li><p>数据科学，人工智能与深度学习：《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-aidl.gitbook.io%2Fi%2F">数理统计</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-aidl.gitbook.io%2Fi%2F">数据分析</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-aidl.gitbook.io%2Fi%2F">机器学习</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-aidl.gitbook.io%2Fi%2F">深度学习</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-aidl.gitbook.io%2Fi%2F">自然语言处理</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-aidl.gitbook.io%2Fi%2F">工具与工程化</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-aidl.gitbook.io%2Fi%2F">行业应用</a>》</p>
</li>
<li><p>产品设计与用户体验：《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-pd.gitbook.io%2Fi%2F">产品设计</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-pd.gitbook.io%2Fi%2F">交互体验</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-pd.gitbook.io%2Fi%2F">项目管理</a>》</p>
</li>
<li><p>行业应用：《<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwx-chevalier%2FBusiness-Series">行业迷思</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwx-chevalier%2FBusiness-Series">功能域</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwx-chevalier%2FBusiness-Series">电子商务</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwx-chevalier%2FBusiness-Series">智能制造</a>》</p>
</li>
</ul>
<p>此外，你还可前往 <a href="https://link.juejin.im?target=https%3A%2F%2Fwx-chevalier.github.io%2Fhome%2F%23%2Fsearch">xCompass</a> 交互式地检索、查找需要的文章/链接/书籍/课程；或者在 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwx-chevalier%2FDeveloper-Zero-To-Mastery">MATRIX 文章与代码索引矩阵</a>中查看文章与项目源代码等更详细的目录导航信息。最后，你也可以关注微信公众号：『<strong>某熊的技术之路</strong>』以获取最新资讯。</p>
<blockquote>
<p>作者：王下邀月熊</p>
<p>来源：<a href="https://juejin.im/post/5d66a4875188250d9432a973" target="_blank" rel="noopener">https://juejin.im/post/5d66a4875188250d9432a973</a></p>
</blockquote>
]]></content>
      <categories>
        <category>系统架构</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL规范</title>
    <url>/2019/12/26/MySQL%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="一、数据库命令规范"><a href="#一、数据库命令规范" class="headerlink" title="一、数据库命令规范"></a>一、数据库命令规范</h2><p>· 所有数据库对象名称必须使用小写字母并用下划线分割<br>· 所有数据库对象名称禁止使用mysql保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）<br>· 数据库对象的命名要能做到见名识意，并且最后不要超过32个字符<br>· 临时库表必须以tmp_为前缀并以日期为后缀，备份表必须以bak_为前缀并以日期(时间戳)为后缀<br>· 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索 引失效，导致查询效率降低）</p>
<a id="more"></a>

<h2 id="二、数据库基本设计规范"><a href="#二、数据库基本设计规范" class="headerlink" title="二、数据库基本设计规范"></a>二、数据库基本设计规范</h2><h3 id="1、所有表必须使用Innodb存储引擎"><a href="#1、所有表必须使用Innodb存储引擎" class="headerlink" title="1、所有表必须使用Innodb存储引擎"></a>1、所有表必须使用Innodb存储引擎</h3><p>没有特殊要求（即Innodb无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用Innodb存储引擎（mysql5.5之前默认使用Myisam，5.6以后默认的为Innodb）Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好</p>
<h3 id="2、数据库和表的字符集统一使用UTF8"><a href="#2、数据库和表的字符集统一使用UTF8" class="headerlink" title="2、数据库和表的字符集统一使用UTF8"></a>2、数据库和表的字符集统一使用UTF8</h3><p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效</p>
<h3 id="3、所有表和字段都需要添加注释"><a href="#3、所有表和字段都需要添加注释" class="headerlink" title="3、所有表和字段都需要添加注释"></a>3、所有表和字段都需要添加注释</h3><p>使用comment从句添加表和列的备注 从一开始就进行数据字典的维护</p>
<h3 id="4、尽量控制单表数据量的大小，建议控制在500万以内"><a href="#4、尽量控制单表数据量的大小，建议控制在500万以内" class="headerlink" title="4、尽量控制单表数据量的大小，建议控制在500万以内"></a>4、尽量控制单表数据量的大小，建议控制在500万以内</h3><p>500万并不是MySQL数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题<br>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p>
<h3 id="5、谨慎使用MySQL分区表"><a href="#5、谨慎使用MySQL分区表" class="headerlink" title="5、谨慎使用MySQL分区表"></a><strong>5、谨慎使用MySQL分区表</strong></h3><p>分区表在物理上表现为多个文件，在逻辑上表现为一个表 谨慎选择分区键，跨分区查询效率可能更低 建议采用物理分表的方式管理大数据</p>
<h3 id="6、尽量做到冷热数据分离，减小表的宽度"><a href="#6、尽量做到冷热数据分离，减小表的宽度" class="headerlink" title="6、尽量做到冷热数据分离，减小表的宽度"></a>6、尽量做到冷热数据分离，减小表的宽度</h3><p>MySQL限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节 减少磁盘IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的IO） 更有效的利用缓存，避免读入无用的冷数据 经常一起使用的列放到一个表中（避免更多的关联操作）</p>
<h3 id="7、禁止在表中建立预留字段"><a href="#7、禁止在表中建立预留字段" class="headerlink" title="7、禁止在表中建立预留字段"></a>7、禁止在表中建立预留字段</h3><p>预留字段的命名很难做到见名识义 预留字段无法确认存储的数据类型，所以无法选择合适的类型 对预留字段类型的修改，会对表进行锁定</p>
<h3 id="8、禁止在数据库中存储图片，文件等大的二进制数据"><a href="#8、禁止在数据库中存储图片，文件等大的二进制数据" class="headerlink" title="8、禁止在数据库中存储图片，文件等大的二进制数据"></a>8、禁止在数据库中存储图片，文件等大的二进制数据</h3><p>通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时 通常存储于文件服务器，数据库只存储文件地址信息</p>
<h3 id="9、禁止在线上做数据库压力测试"><a href="#9、禁止在线上做数据库压力测试" class="headerlink" title="9、禁止在线上做数据库压力测试"></a>9、禁止在线上做数据库压力测试</h3><h3 id="10、禁止从开发环境，测试环境直接连接生成环境数据库"><a href="#10、禁止从开发环境，测试环境直接连接生成环境数据库" class="headerlink" title="10、禁止从开发环境，测试环境直接连接生成环境数据库"></a>10、禁止从开发环境，测试环境直接连接生成环境数据库</h3><h2 id="三、数据库字段设计规范"><a href="#三、数据库字段设计规范" class="headerlink" title="三、数据库字段设计规范"></a>三、数据库字段设计规范</h2><h3 id="1、优先选择符合存储需要的最小的数据类型"><a href="#1、优先选择符合存储需要的最小的数据类型" class="headerlink" title="1、优先选择符合存储需要的最小的数据类型"></a>1、优先选择符合存储需要的最小的数据类型</h3><p>· 原因<br>列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的IO次数也就越多， 索引的性能也就越差<br>· 方法<br>1）将字符串转换成数字类型存储，如：将IP地址转换成整形数据。<br>mysql提供了两个方法来处理ip地址：<br><img src="http://image.winrains.cn/2019/08/20190829084907-d831b.jpeg" alt="img"><br>插入数据前，先用inet_aton把ip地址转为整型，可以节省空间。显示数据时，使用inet_ntoa把整型的ip地址转为地址显示即可。<br>2）对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符号整型来存储<br>因为：无符号相对于有符号可以多出一倍的存储空间<br><img src="http://image.winrains.cn/2019/08/20190829084907-68f48.jpeg" alt="img"><br>VARCHAR(N)中的N代表的是字符数，而不是字节数<br>使用UTF8存储255个汉字 Varchar(255)=765个字节。过大的长度会消耗更多的内存</p>
<h3 id="2、避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据"><a href="#2、避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据" class="headerlink" title="2、避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据"></a>2、避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据</h3><p>· 建议把BLOB或是TEXT列分离到单独的扩展表中<br>Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。<br>而且对于这种数据，Mysql还是要进行二次查询，会使sql性能变得很差，但是不是说一定不能使用这样的数据类型。<br>如果一定要使用，建议把BLOB或是TEXT列分离到单独的扩展表中，查询时一定不要使用select * 而只需要取出必要的列，不需要TEXT列的数据时不要对该列进行查询。<br>· TEXT或BLOB类型只能使用前缀索引<br>因为MySQL对索引字段长度是有限制的，所以TEXT类型只能使用前缀索引，并且TEXT列上是不能有默认值的。</p>
<h3 id="3、避免使用ENUM类型"><a href="#3、避免使用ENUM类型" class="headerlink" title="3、避免使用ENUM类型"></a>3、避免使用ENUM类型</h3><p>· 修改ENUM值需要使用ALTER语句<br>· ENUM类型的ORDER BY操作效率低，需要额外操作<br>· 禁止使用数值作为ENUM的枚举值</p>
<h3 id="4、尽可能把所有列定义为NOT-NULL"><a href="#4、尽可能把所有列定义为NOT-NULL" class="headerlink" title="4、尽可能把所有列定义为NOT NULL"></a>4、尽可能把所有列定义为NOT NULL</h3><p>原因：<br>· 索引NULL列需要额外的空间来保存，所以要占用更多的空间；<br>· 进行比较和计算时要对NULL值做特别的处理</p>
<h3 id="5、使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间"><a href="#5、使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间" class="headerlink" title="5、使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间"></a>5、使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间</h3><p>TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07。<br>TIMESTAMP 占用4字节和INT相同，但比INT可读性高<br>超出TIMESTAMP取值范围的使用DATETIME类型存储。<br>经常会有人用字符串存储日期型的数据（不正确的做法）：<br>· 缺点1：无法用日期函数进行计算和比较<br>· 缺点2：用字符串存储日期要占用更多的空间</p>
<h3 id="6、同财务相关的金额类数据必须使用decimal类型"><a href="#6、同财务相关的金额类数据必须使用decimal类型" class="headerlink" title="6、同财务相关的金额类数据必须使用decimal类型"></a>6、同财务相关的金额类数据必须使用decimal类型</h3><p>· 非精准浮点：float,double<br>· 精准浮点：decimal<br>Decimal类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节。可用于存储比bigint更大的整型数据。</p>
<h2 id="四、索引设计规范"><a href="#四、索引设计规范" class="headerlink" title="四、索引设计规范"></a>四、索引设计规范</h2><h3 id="1、限制每张表上的索引数量，建议单张表索引不超过5个"><a href="#1、限制每张表上的索引数量，建议单张表索引不超过5个" class="headerlink" title="1、限制每张表上的索引数量，建议单张表索引不超过5个"></a>1、限制每张表上的索引数量，建议单张表索引不超过5个</h3><p>索引并不是越多越好！索引可以提高效率同样可以降低效率。<br>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。<br>因为mysql优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加mysql优化器生成执行计划的时间，同样会降低查询性能。</p>
<h3 id="2、禁止给表中的每一列都建立单独的索引"><a href="#2、禁止给表中的每一列都建立单独的索引" class="headerlink" title="2、禁止给表中的每一列都建立单独的索引"></a>2、禁止给表中的每一列都建立单独的索引</h3><p>5.6版本之前，一个sql只能使用到一个表中的一个索引，5.6以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好</p>
<h3 id="3、每个Innodb表必须有个主键"><a href="#3、每个Innodb表必须有个主键" class="headerlink" title="3、每个Innodb表必须有个主键"></a>3、每个Innodb表必须有个主键</h3><p>Innodb是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。<br>每个表都可以有多个索引，但是表的存储顺序只能有一种 Innodb是按照主键索引的顺序来组织表的。<br>不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引） 不要使用UUID、MD5、HASH、字符串列作为主键（无法保证数据的顺序增长）。<br>主键建议使用自增ID值。</p>
<h2 id="五、常见索引列建议"><a href="#五、常见索引列建议" class="headerlink" title="五、常见索引列建议"></a>五、常见索引列建议</h2><p>· 出现在SELECT、UPDATE、DELETE语句的WHERE从句中的列<br>· 包含在ORDER BY、GROUP BY、DISTINCT中的字段<br>并不要将符合1和2中的字段的列都建立一个索引，通常将1、2中的字段建立联合索引效果更好<br>· 多表join的关联列</p>
<h2 id="六、如何选择索引列的顺序"><a href="#六、如何选择索引列的顺序" class="headerlink" title="六、如何选择索引列的顺序"></a>六、如何选择索引列的顺序</h2><p>建立索引的目的是：希望通过索引进行数据查找，减少随机IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。<br>· 区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）；<br>· 尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好）；<br>· 使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）。</p>
<h2 id="七、避免建立冗余索引和重复索引"><a href="#七、避免建立冗余索引和重复索引" class="headerlink" title="七、避免建立冗余索引和重复索引"></a>七、避免建立冗余索引和重复索引</h2><p>因为这样会增加查询优化器生成执行计划的时间。<br>· 重复索引示例：primary key(id)、index(id)、unique index(id)<br>· 冗余索引示例：index(a,b,c)、index(a,b)、index(a)</p>
<h2 id="八、优先考虑覆盖索引"><a href="#八、优先考虑覆盖索引" class="headerlink" title="八、优先考虑覆盖索引"></a>八、优先考虑覆盖索引</h2><p>对于频繁的查询优先考虑使用覆盖索引。<br>覆盖索引：就是包含了所有查询字段(where,select,ordery by,group by包含的字段)的索引<br>覆盖索引的好处：<br>· 避免Innodb表进行索引的二次查询<br>Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息，<br>如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了IO操作，提升了查询效率。<br>· 可以把随机IO变成顺序IO加快查询效率<br>由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO。</p>
<h2 id="九、索引SET规范"><a href="#九、索引SET规范" class="headerlink" title="九、索引SET规范"></a>九、索引SET规范</h2><p>尽量避免使用外键约束<br>· 不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引；<br>· 外键可用于保证数据的参照完整性，但建议在业务端实现；<br>· 外键会影响父表和子表的写操作从而降低性能。</p>
<h2 id="十、数据库SQL开发规范"><a href="#十、数据库SQL开发规范" class="headerlink" title="十、数据库SQL开发规范"></a>十、数据库SQL开发规范</h2><h3 id="1、建议使用预编译语句进行数据库操作"><a href="#1、建议使用预编译语句进行数据库操作" class="headerlink" title="1、建议使用预编译语句进行数据库操作"></a>1、建议使用预编译语句进行数据库操作</h3><p>预编译语句可以重复使用这些计划，减少SQL编译所需要的时间，还可以解决动态SQL所带来的SQL注入的问题 只传参数，比传递SQL语句更高效 相同语句可以一次解析，多次使用，提高处理效率。</p>
<h3 id="2、避免数据类型的隐式转换"><a href="#2、避免数据类型的隐式转换" class="headerlink" title="2、避免数据类型的隐式转换"></a>2、避免数据类型的隐式转换</h3><p>隐式转换会导致索引失效。如：select name,phone from customer where id = ‘111’;</p>
<h3 id="3、充分利用表上已经存在的索引"><a href="#3、充分利用表上已经存在的索引" class="headerlink" title="3、充分利用表上已经存在的索引"></a>3、充分利用表上已经存在的索引</h3><p>· 避免使用双%号的查询条件。<br>如a like ‘%123%’，（如果无前置%,只有后置%，是可以用到列上的索引的）<br>· 一个SQL只能利用到复合索引中的一列进行范围查询<br>如：有 a,b,c列的联合索引，在查询条件中有a列的范围查询，则在b,c列上的索引将不会被用到，在定义联合索引时，如果a列要用到范围查找的话，就要把a列放到联合索引的右侧。<br>使用left join或 not exists来优化not in操作<br>因为not in 也通常会使用索引失效。</p>
<h3 id="4、数据库设计时，应该要对以后扩展进行考虑"><a href="#4、数据库设计时，应该要对以后扩展进行考虑" class="headerlink" title="4、数据库设计时，应该要对以后扩展进行考虑"></a>4、数据库设计时，应该要对以后扩展进行考虑</h3><h3 id="5、程序连接不同的数据库使用不同的账号，进制跨库查询"><a href="#5、程序连接不同的数据库使用不同的账号，进制跨库查询" class="headerlink" title="5、程序连接不同的数据库使用不同的账号，进制跨库查询"></a>5、程序连接不同的数据库使用不同的账号，进制跨库查询</h3><p>· 为数据库迁移和分库分表留出余地<br>· 降低业务耦合度<br>· 避免权限过大而产生的安全风险</p>
<h3 id="6、禁止使用SELECT-必须使用SELECT-lt-字段列表-gt-查询"><a href="#6、禁止使用SELECT-必须使用SELECT-lt-字段列表-gt-查询" class="headerlink" title="6、禁止使用SELECT * 必须使用SELECT &lt;字段列表&gt; 查询"></a>6、禁止使用SELECT * 必须使用SELECT &lt;字段列表&gt; 查询</h3><p>原因：<br>· 消耗更多的CPU和IO以网络带宽资源<br>· 无法使用覆盖索引<br>· 可减少表结构变更带来的影响</p>
<h3 id="7、禁止使用不含字段列表的INSERT语句"><a href="#7、禁止使用不含字段列表的INSERT语句" class="headerlink" title="7、禁止使用不含字段列表的INSERT语句"></a>7、禁止使用不含字段列表的INSERT语句</h3><p>如：insert into values (‘a’,’b’,’c’);<br>应使用insert into t(c1,c2,c3) values (‘a’,’b’,’c’);</p>
<h3 id="8、避免使用子查询，可以把子查询优化为join操作"><a href="#8、避免使用子查询，可以把子查询优化为join操作" class="headerlink" title="8、避免使用子查询，可以把子查询优化为join操作"></a>8、避免使用子查询，可以把子查询优化为join操作</h3><p>通常子查询在in子句中，且子查询中为简单SQL(不包含union、group by、order by、limit从句)时，才可以把子查询转化为关联查询进行优化。<br>子查询性能差的原因：<br>· 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能 会受到一定的影响；<br>· 特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大；<br>· 由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询。</p>
<h3 id="9、避免使用JOIN关联太多的表"><a href="#9、避免使用JOIN关联太多的表" class="headerlink" title="9、避免使用JOIN关联太多的表"></a>9、避免使用JOIN关联太多的表</h3><p>对于Mysql来说，是存在关联缓存的，缓存的大小可以由join_buffer_size参数进行设置。<br>在Mysql中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，所占用的内存也就越大。<br>如果程序中大量的使用了多表关联的操作，同时join_buffer_size设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。<br>同时对于关联操作来说，会产生临时表操作，影响查询效率Mysql最多允许关联61个表，建议不超过5个。</p>
<h3 id="10、减少同数据库的交互次数"><a href="#10、减少同数据库的交互次数" class="headerlink" title="10、减少同数据库的交互次数"></a>10、减少同数据库的交互次数</h3><p>数据库更适合处理批量操作 合并多个相同的操作到一起，可以提高处理效率</p>
<h3 id="11、对应同一列进行or判断时，使用in代替or"><a href="#11、对应同一列进行or判断时，使用in代替or" class="headerlink" title="11、对应同一列进行or判断时，使用in代替or"></a>11、对应同一列进行or判断时，使用in代替or</h3><p>in的值不要超过500个in操作可以更有效的利用索引，or大多数情况下很少能利用到索引。</p>
<h3 id="12、禁止使用order-by-rand-进行随机排序"><a href="#12、禁止使用order-by-rand-进行随机排序" class="headerlink" title="12、禁止使用order by rand() 进行随机排序"></a>12、禁止使用order by rand() 进行随机排序</h3><p>会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的CPU和IO及内存资源。<br>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式</p>
<h3 id="13、WHERE从句中禁止对列进行函数转换和计算"><a href="#13、WHERE从句中禁止对列进行函数转换和计算" class="headerlink" title="13、WHERE从句中禁止对列进行函数转换和计算"></a>13、WHERE从句中禁止对列进行函数转换和计算</h3><p>对列进行函数转换或计算时会导致无法使用索引。<br>· 不推荐：<br><img src="http://image.winrains.cn/2019/08/20190829084907-5b451.jpeg" alt="img"><br>· 推荐：<br><img src="http://image.winrains.cn/2019/08/20190829084907-218f3.jpeg" alt="img"></p>
<h3 id="14、在明显不会有重复值时使用UNION-ALL而不是UNION"><a href="#14、在明显不会有重复值时使用UNION-ALL而不是UNION" class="headerlink" title="14、在明显不会有重复值时使用UNION ALL而不是UNION"></a>14、在明显不会有重复值时使用UNION ALL而不是UNION</h3><p>· UNION会把两个结果集的所有数据放到临时表中后再进行去重操作<br>· UNION ALL不会再对结果集进行去重操作</p>
<h3 id="15、拆分复杂的大SQL为多个小SQL"><a href="#15、拆分复杂的大SQL为多个小SQL" class="headerlink" title="15、拆分复杂的大SQL为多个小SQL"></a>15、拆分复杂的大SQL为多个小SQL</h3><p>· 大SQL：逻辑上比较复杂，需要占用大量CPU进行计算的SQL<br>· MySQL：一个SQL只能使用一个CPU进行计算<br>· SQL拆分后可以通过并行执行来提高处理效率</p>
<h2 id="十一、数据库操作行为规范"><a href="#十一、数据库操作行为规范" class="headerlink" title="十一、数据库操作行为规范"></a>十一、数据库操作行为规范</h2><h3 id="1、超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作"><a href="#1、超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作" class="headerlink" title="1、超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作"></a>1、超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作</h3><p>· 大批量操作可能会造成严重的主从延迟<br>主从环境中，大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况<br>· binlog日志为row格式时会产生大量的日志<br>大批量写操作会产生大量日志，特别是对于row格式二进制数据而言，由于在row格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因。<br>· 避免产生大事务操作<br>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对MySQL的性能产生非常大的影响。<br>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批。</p>
<h3 id="2、对于大表使用pt-online-schema-change修改表结构"><a href="#2、对于大表使用pt-online-schema-change修改表结构" class="headerlink" title="2、对于大表使用pt-online-schema-change修改表结构"></a>2、对于大表使用pt-online-schema-change修改表结构</h3><p>· 避免大表修改产生的主从延迟<br>· 避免在对表字段进行修改时进行锁表<br>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。<br>pt-online-schema-change它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。<br>把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。<br>把原来一个DDL操作，分解成多个小的批次进行。</p>
<h3 id="3、禁止为程序使用的账号赋予super权限"><a href="#3、禁止为程序使用的账号赋予super权限" class="headerlink" title="3、禁止为程序使用的账号赋予super权限"></a>3、禁止为程序使用的账号赋予super权限</h3><p>当达到最大连接数限制时，还运行1个有super权限的用户连接super权限只能留给DBA处理问题的账号使用。</p>
<h3 id="4、对于程序连接数据库账号，遵循权限最小原则"><a href="#4、对于程序连接数据库账号，遵循权限最小原则" class="headerlink" title="4、对于程序连接数据库账号，遵循权限最小原则"></a>4、对于程序连接数据库账号，遵循权限最小原则</h3><p>程序使用数据库账号只能在一个DB下使用，不准跨库 程序使用的账号原则上不准有drop权限。</p>
<blockquote>
<p>作者：程序员追风</p>
<p>来源：<a href="https://juejin.im/post/5d663c6de51d453b8b5fa605" target="_blank" rel="noopener">https://juejin.im/post/5d663c6de51d453b8b5fa605</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Maven介绍</title>
    <url>/2019/12/26/Maven%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="什么是Maven"><a href="#什么是Maven" class="headerlink" title="什么是Maven"></a>什么是Maven</h1><p>乍一看，Maven似乎包含很多内容，但简而言之，Maven试图将模式应用于项目的构建基础设施，以便通过提供使用最佳实践的清晰路径来促进理解和生产力。Maven本质上是一个项目管理和理解工具，因此提供了一种帮助管理的方法:</p>
<ul>
<li>Builds</li>
<li>Documentation</li>
<li>Reporting</li>
<li>Dependencies</li>
<li>SCMs</li>
<li>Releases</li>
<li>Distribution</li>
</ul>
<a id="more"></a>

<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>Maven最初设计，是以简化Jakarta Turbine项目的建设。在几个项目，每个项目包含了不同的Ant构建文件。 JAR检查到CVS。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>1）为了使项目管理更加简单。<br>2）提供统一的构建系统。<br>3）提供优质项目的资讯。<br>4）为最佳实践开发提供指导。<br>5）允许透明地迁移到新特性。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate <span class="attribute">-DgroupId</span>=com.mycompany.app <span class="attribute">-DartifactId</span>=my-app <span class="attribute">-DarchetypeArtifactId</span>=maven-archetype-quickstart <span class="attribute">-DarchetypeVersion</span>=1.4 <span class="attribute">-DinteractiveMode</span>=<span class="literal">false</span></span></pre></td></tr></table></figure>

<p>生成的文件目录：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">my</span>-app</span></pre></td></tr><tr><td class="code"><pre><span class="line">|<span class="comment">-- pom.xml</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">`<span class="comment">-- src</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |<span class="comment">-- main</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |   `<span class="comment">-- java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |       `<span class="comment">-- com</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |           `<span class="comment">-- mycompany</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |               `<span class="comment">-- app</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |                   `<span class="comment">-- App.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    `<span class="comment">-- test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        `<span class="comment">-- java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            `<span class="comment">-- com</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                `<span class="comment">-- mycompany</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    `<span class="comment">-- app</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                        `<span class="comment">-- AppTest.java</span></span></pre></td></tr></table></figure>

<h3 id="创建一个工程"><a href="#创建一个工程" class="headerlink" title="创建一个工程"></a>创建一个工程</h3><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">mvn <span class="class"><span class="keyword">package</span></span></span></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">..</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] BUILD SUCCESSFUL</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Total time: 2 seconds</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Finished at: Thu Jul 07 21:34:52 CEST 2011</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Final Memory: 3M/6M</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ------------------------------------------------------------------------</span></pre></td></tr></table></figure>

<p>与执行的第一个命令（architetype:generate）不同，您可能会注意到第二个命令只是一个单词package。这不是一个目标，而是一个阶段。阶段是构建生命周期中的一个步骤，它是一个有序的阶段序列。当一个阶段被给定时，Maven将执行序列中的每个阶段，直到并包括定义的阶段。例如，如果我们执行编译阶段，实际执行的阶段是：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">validate</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">generate</span>-sources</span></pre></td></tr><tr><td class="code"><pre><span class="line">process-sources</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">generate</span>-resources</span></pre></td></tr><tr><td class="code"><pre><span class="line">process-resources</span></pre></td></tr><tr><td class="code"><pre><span class="line">compile</span></pre></td></tr></table></figure>

<h3 id="编译jar包"><a href="#编译jar包" class="headerlink" title="编译jar包"></a>编译jar包</h3><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">java -cp target/my-<span class="keyword">app</span>-1.0-SNAPSHOT.jar com.mycompany.<span class="keyword">app</span>.<span class="keyword">App</span></span></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line">Hello World!</span></pre></td></tr></table></figure>

<h3 id="Java9或者之后的版本"><a href="#Java9或者之后的版本" class="headerlink" title="Java9或者之后的版本"></a>Java9或者之后的版本</h3><p>默认情况下，Maven版本可能使用Maven -compiler-plugin的旧版本，与Java 9或更高版本不兼容。要针对Java 9或更高版本，您至少应该使用maven-compiler-plugin的3.6.0版本，并将maven.compiler.release属性设置为您要针对的Java版本(例如9、10、11、12等)。 在下面的例子中，我们将Maven项目配置为使用Maven -compiler-plugin的3.8.1版本和目标Java 11:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.release</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.release</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></pre></td></tr></table></figure>

<h2 id="Maven阶段"><a href="#Maven阶段" class="headerlink" title="Maven阶段"></a>Maven阶段</h2><ul>
<li><strong>validate</strong>: 验证项目是正确的，并且所有必要的信息都是可用的。</li>
<li><strong>compile</strong>: 编译项目的源代码。</li>
<li><strong>test</strong>:使用合适的单元测试框架测试编译后的源代码。这些测试不应该要求打包或部署代码。</li>
<li><strong>package</strong>:将编译后的代码打包成可分发的格式，比如JAR。</li>
<li><strong>integration-test</strong>: 如果需要，将包处理并部署到可以运行集成测试的环境中。</li>
<li><strong>verify</strong>: 运行任何检查来验证包是否有效并满足质量标准。</li>
<li><strong>install</strong>: 将包安装到本地存储库中，以便在本地的其他项目中作为依赖项使用。</li>
<li><strong>deploy</strong>: 在集成或发布环境中完成，将最终的包复制到远程存储库，以便与其他开发人员和项目共享。</li>
</ul>
<p>在上面的缺省列表之外，还有两个Maven生命周期值得注意。他们是：</p>
<ul>
<li><strong>clean</strong>: 清理先前构建创建的工件。</li>
<li><strong>site</strong>: 为这个项目生成站点文档。</li>
</ul>
<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>使用命令：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mvn -B archetype:generate \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">-DarchetypeGroupId</span>=org.apache.maven.archetypes \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">-DgroupId</span>=com.mycompany.app \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">-DartifactId</span>=my-app</span></pre></td></tr></table></figure>

<p>执行此命令后，您将注意到发生了一些事情。首先，您将注意到为新项目创建了一个名为my-app的目录，该目录包含一个名为pom.xml的文件，如下所示:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Quick Start Archetype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p><strong>pom.xml</strong>包含该项目的项目对象模型(POM)。POM是Maven中的基本工作单元。记住这一点很重要，因为Maven本质上是以项目为中心的，因为一切都围绕着项目的概念。简而言之，POM包含关于项目的所有重要信息，本质上是一站式搜索，查找与项目相关的任何内容。理解POM非常重要，我们鼓励新用户参考对POM的介绍。 这是一个非常简单的POM，但仍然显示每个POM包含的关键元素 ,所以让我们逐一介绍一下，让您熟悉POM的要点:</p>
<ul>
<li><strong>project</strong> 这是所有Maven pom.xml文件中的顶级元素。</li>
<li><strong>modelVersion</strong> 此元素指示此POM使用的对象模型的版本。模型本身的版本更改非常不频繁，但如果Maven开发人员认为有必要更改模型，则必须更改模型，以确保使用的稳定性。</li>
<li><strong>groupId</strong> 此元素指示创建项目的组织或组的唯一标识符。groupId是项目的关键标识符之一，通常基于组织的完全限定域名。例如org.apache.maven。插件是所有Maven插件的指定groupId。</li>
<li><strong>artifactId</strong> 此元素指示此项目生成的主要构件的唯一基名称。项目的主要构件通常是一个JAR文件。像源包这样的次要构件也使用artifactId作为它们最终名称的一部分。Maven生成的典型工件的形式是-.&lt;扩展名&gt;(例如，myapp-1.0.jar)。</li>
<li><strong>packaging</strong> 此元素指示此构件(例如JAR、WAR、EAR等)要使用的包类型。这不仅意味着如果生成的工件是JAR、WAR或EAR，还可以指示作为构建过程一部分使用的特定生命周期。(生命周期是我们将在指南中进一步讨论的主题。现在，请记住，项目的指定打包可以在定制构建生命周期中发挥一定的作用。打包元素的默认值是JAR，因此您不必为大多数项目指定此值。</li>
<li><strong>version</strong> 此元素指示由项目生成的工件的版本。Maven在帮助您进行版本管理方面走了很长的路，您经常会在版本中看到快照设计器，这表明项目处于开发状态。我们将在本指南中进一步讨论快照的使用及其工作原理。</li>
<li><strong>name</strong> 此元素指示用于项目的显示名称。这通常在Maven生成的文档中使用。</li>
<li><strong>url</strong> 此元素指示可以在何处找到项目的站点。这通常在Maven生成的文档中使用。</li>
<li><strong>description</strong> 此元素提供项目的基本描述。这通常在Maven生成的文档中使用。</li>
</ul>
<h2 id="编译Maven"><a href="#编译Maven" class="headerlink" title="编译Maven"></a>编译Maven</h2><p>切换到原型创建pom.xml的目录:生成并执行以下命令编译应用程序源代码:</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mvn </span>compile</span></pre></td></tr></table></figure>

<p>执行此命令后，您将看到如下输出:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Building Maven Quick Start Archetype</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>]    task-segment: [compile]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] artifact org.apache.maven.plugins:maven-resources-plugin: \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  checking <span class="keyword">for</span> updates <span class="keyword">from</span> central</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">..</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] artifact org.apache.maven.plugins:maven-compiler-plugin: \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  checking <span class="keyword">for</span> updates <span class="keyword">from</span> central</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">..</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [resources:resources]</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">..</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [compiler:compile]</span></pre></td></tr><tr><td class="code"><pre><span class="line">Compiling 1 source file <span class="keyword">to</span> &lt;dir&gt;/my-app/target/classes</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] BUILD SUCCESSFUL</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Total time: 3 minutes 54 seconds</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Finished at: Fri Sep 23 15:48:34 GMT-05:00 2005</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Final Memory: 2M/6M</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr></table></figure>

<p>第一次执行这个(或任何其他)命令时，Maven将需要下载完成该命令所需的所有插件和相关依赖项。从Maven的干净安装来看，这可能需要相当长的时间(在上面的输出中，它花费了近4分钟)。如果您再次执行该命令，Maven现在将拥有它所需要的东西，因此它不需要下载任何新内容，并且能够更快地执行该命令。<br>从输出中可以看到，编译后的类放在${basedir}/target/classes中，这是Maven使用的另一种标准约定。因此，如果您是一个敏锐的观察者，您会注意到，通过使用标准约定，上面的POM非常小，您不必显式地告诉Maven您的任何源文件在哪里，或者输出应该放在哪里。通过遵循标准Maven约定，您可以用很少的努力完成很多工作!作为一个随意的比较，让我们来看看您在Ant中为了完成同样的事情可能必须做些什么。<br>现在，只需编译一个应用程序源代码树，所示Ant脚本的大小与上面所示POM的大小基本相同。但是，我们将看到我们可以用这个简单的POM做更多的事情!</p>
<h2 id="我如何编译我的测试源并运行我的单元测试"><a href="#我如何编译我的测试源并运行我的单元测试" class="headerlink" title="我如何编译我的测试源并运行我的单元测试?"></a>我如何编译我的测试源并运行我的单元测试?</h2><p>现在，您已经成功地编译了应用程序的源代码，并且已经有了一些需要编译和执行的单元测试(因为每个程序员总是编写和执行他们的单元测试<em>nudge nudge wink</em>)。<br>执行以下命令:</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mvn </span>test</span></pre></td></tr></table></figure>

<p>执行此命令后，您将看到如下输出:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Building Maven Quick Start Archetype</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>]    task-segment: [test]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] artifact org.apache.maven.plugins:maven-surefire-plugin: \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  checking <span class="keyword">for</span> updates <span class="keyword">from</span> central</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">..</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [resources:resources]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [compiler:compile]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] <span class="literal">Nothing</span> <span class="keyword">to</span> compile - all classes are up <span class="keyword">to</span> date</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [resources:testResources]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [compiler:testCompile]</span></pre></td></tr><tr><td class="code"><pre><span class="line">Compiling 1 source file <span class="keyword">to</span> C:\Test\Maven2\test\my-app\target\test-classes</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">..</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [surefire:test]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Setting reports dir: C:\Test\Maven2\test\my-app\target/surefire-reports</span></pre></td></tr><tr><td class="code"><pre><span class="line">-------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line"> T E S T S</span></pre></td></tr><tr><td class="code"><pre><span class="line">-------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[surefire] Running com.mycompany.app.AppTest</span></pre></td></tr><tr><td class="code"><pre><span class="line">[surefire] Tests run: 1, Failures: 0, Errors: 0, Time elapsed: 0 sec</span></pre></td></tr><tr><td class="code"><pre><span class="line">Results :</span></pre></td></tr><tr><td class="code"><pre><span class="line">[surefire] Tests run: 1, Failures: 0, Errors: 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] BUILD SUCCESSFUL</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Total time: 15 seconds</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Finished at: Thu Oct 06 08:12:17 MDT 2005</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Final Memory: 2M/8M</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr></table></figure>

<p>关于输出需要注意的一些事情:<br>Maven这次下载了更多的依赖项。这些是执行测试所需的依赖项和插件(它已经拥有编译所需的依赖项，不会再下载它们)。<br>在编译和执行测试之前，Maven编译主代码(所有这些类都是最新的，因为自上次编译以来，我们没有更改任何东西)。<br>如果你只是想编译你的测试源(而不是执行测试)，你可以执行以下步骤:</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mvn </span>test-compile</span></pre></td></tr></table></figure>

<h2 id="如何创建一个JAR并将其安装到本地存储库中"><a href="#如何创建一个JAR并将其安装到本地存储库中" class="headerlink" title="如何创建一个JAR并将其安装到本地存储库中?"></a>如何创建一个JAR并将其安装到本地存储库中?</h2><p>制作JAR文件非常简单，可以通过执行以下命令来完成:</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">mvn <span class="class"><span class="keyword">package</span></span></span></pre></td></tr></table></figure>

<p>如果您查看项目的POM，您会注意到打包元素被设置为jar。Maven就是这样知道如何从上面的命令生成JAR文件的(稍后我们将对此进行更多讨论)。现在可以查看{basedir}/target目录，您将看到生成的JAR文件。 现在，您将希望将生成的工件(JAR文件)安装到本地存储库{user.home}中。m2/repository是默认位置)。有关存储库的更多信息，您可以参考我们对存储库的介绍，但是让我们继续安装我们的工件!执行以下命令:</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mvn </span>install</span></pre></td></tr></table></figure>

<p>执行此命令后，应该会看到以下输出:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Building Maven Quick Start Archetype</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>]    task-segment: [install]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [resources:resources]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [compiler:compile]</span></pre></td></tr><tr><td class="code"><pre><span class="line">Compiling 1 source file <span class="keyword">to</span> &lt;dir&gt;/my-app/target/classes</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [resources:testResources]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [compiler:testCompile]</span></pre></td></tr><tr><td class="code"><pre><span class="line">Compiling 1 source file <span class="keyword">to</span> &lt;dir&gt;/my-app/target/test-classes</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [surefire:test]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Setting reports dir: &lt;dir&gt;/my-app/target/surefire-reports</span></pre></td></tr><tr><td class="code"><pre><span class="line">-------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line"> T E S T S</span></pre></td></tr><tr><td class="code"><pre><span class="line">-------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[surefire] Running com.mycompany.app.AppTest</span></pre></td></tr><tr><td class="code"><pre><span class="line">[surefire] Tests run: 1, Failures: 0, Errors: 0, Time elapsed: 0.001 sec</span></pre></td></tr><tr><td class="code"><pre><span class="line">Results :</span></pre></td></tr><tr><td class="code"><pre><span class="line">[surefire] Tests run: 1, Failures: 0, Errors: 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [jar:jar]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Building jar: &lt;dir&gt;/my-app/target/my-app-1.0-SNAPSHOT.jar</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [install:install]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Installing &lt;dir&gt;/my-app/target/my-app-1.0-SNAPSHOT.jar <span class="keyword">to</span> \</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &lt;local-repository&gt;/com/mycompany/app/my-app/1.0-SNAPSHOT/my-app-1.0-SNAPSHOT.jar</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] BUILD SUCCESSFUL</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Total time: 5 seconds</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Finished at: Tue Oct 04 13:20:32 GMT-05:00 2005</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Final Memory: 3M/8M</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr></table></figure>

<p>请注意surefire插件(执行测试)寻找包含在具有特定命名约定的文件中的测试。默认情况下，测试包括:</p>
<ul>
<li><code>**/*Test.java</code></li>
<li><code>**/Test*.java</code></li>
<li><code>**/*TestCase.java</code></li>
</ul>
<p>默认不包括:</p>
<ul>
<li><code>**/Abstract*Test.java</code></li>
<li><code>**/Abstract*TestCase.java</code></li>
</ul>
<p>您已经完成了设置、构建、测试、打包和安装典型Maven项目的过程。这可能是绝大多数项目将使用Maven做的事情，如果您已经注意到，到目前为止您所能做的一切都是由一个18行文件驱动的，即项目的模型或POM。如果您查看一个典型的Ant构建文件，该文件提供了与我们到目前为止已经实现的功能相同的功能，您将注意到它已经是POM的两倍大，而我们才刚刚开始!Maven提供了更多的功能，而不需要像现在这样对POM进行任何添加。要从示例Ant构建文件中获得更多功能，必须不断添加容易出错的内容。<br>那么你还能免费得到什么呢?有很多Maven插件可以用上面所述的简单POM开箱即用。我们将在这里特别提到一个，因为它是Maven非常宝贵的特性之一:不需要您做任何工作，这个POM就有足够的信息为您的项目生成一个web站点!您很可能想自定义Maven站点，但如果时间紧迫，您只需执行以下命令即可提供关于项目的基本信息:</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mvn </span>site</span></pre></td></tr></table></figure>

<p>还有很多其他独立的目标也可以执行，例如:</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mvn </span>clean</span></pre></td></tr></table></figure>

<h2 id="什么是快照版本"><a href="#什么是快照版本" class="headerlink" title="什么是快照版本?"></a>什么是快照版本?</h2><p>注意，下面显示的pom.xml文件中的version标记的值有后缀:<code>-SNAPSHOT</code>。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;groupId&gt;<span class="string">...</span>&lt;<span class="string">/groupId</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;artifactId&gt;my-app&lt;<span class="string">/artifactId</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;<span class="keyword">version</span>&gt;1.0-SNAPSHOT&lt;<span class="string">/version</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;name&gt;Maven Quick Start Archetype&lt;<span class="string">/name</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">...</span></span></pre></td></tr></table></figure>

<p>快照值指的是沿着开发分支的“最新”代码，不能保证代码是稳定的或不变的。相反，“release”版本(任何没有后缀SNAPSHOT的版本值)中的代码是不变的。<br>换句话说，快照版本是最终“发布”版本之前的“开发”版本。快照比它的发布“更老”。<br>在发布过程中，x的一个版本。y-SNAPSHOT更改为x.y.发布过程也将开发版本增加到x.(y+1)-SNAPSHOT。例如，版本1.0- snapshot作为版本1.0发布，而新的开发版本是版本1.1-SNAPSHOT。</p>
<h2 id="我如何使用插件"><a href="#我如何使用插件" class="headerlink" title="我如何使用插件?"></a>我如何使用插件?</h2><p>无论何时您想为Maven项目定制构建，都可以通过添加或重新配置插件来完成。<br>Maven 1.0用户注意:在Maven 1.0中，您将向Maven .xml添加一些preGoal，并向project.properties添加一些条目。在这里，情况有点不同。<br>对于本例，我们将配置Java编译器以允许JDK 5.0源代码。这是简单的添加到您的POM:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr></table></figure>

<p>您将注意到Maven中的所有插件看起来都很像依赖项——在某些方面确实如此。这个插件将自动下载和使用-包括一个特定的版本，如果你要求它(默认是使用最新可用的)。<br>configuration元素将给定的参数应用于编译器插件中的每个目标。在上面的例子中，编译器插件已经被用作构建过程的一部分，这只是改变了配置。还可以向流程添加新目标，并配置特定的目标。有关这方面的信息，请参阅构建生命周期的介绍。<br>要了解插件的可用配置，可以查看插件列表，并导航到正在使用的插件和目标。有关如何配置插件的可用参数的一般信息，请参阅配置插件的指南。</p>
<h2 id="如何向JAR添加资源"><a href="#如何向JAR添加资源" class="headerlink" title="如何向JAR添加资源?"></a>如何向JAR添加资源?</h2><p>另一个可以满足的常见用例是将资源打包到JAR文件中，它不需要修改上面的POM。对于这个常见的任务，Maven再次依赖于标准目录布局，这意味着通过使用标准Maven约定，您只需将这些资源放在标准目录结构中，就可以将资源打包到jar中。<br>您可以在下面的示例中看到，我们添加了<code>{basedir}/src/main/resources</code>目录中放置的任何目录或文件都打包在JAR中，从JAR的底部开始使用完全相同的结构。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">my</span>-app</span></pre></td></tr><tr><td class="code"><pre><span class="line">|<span class="comment">-- pom.xml</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">`<span class="comment">-- src</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |<span class="comment">-- main</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |   |<span class="comment">-- java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |   |   `<span class="comment">-- com</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |   |       `<span class="comment">-- mycompany</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |   |           `<span class="comment">-- app</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |   |               `<span class="comment">-- App.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |   `<span class="comment">-- resources</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |       `<span class="comment">-- META-INF</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |           `<span class="comment">-- application.properties</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    `<span class="comment">-- test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        `<span class="comment">-- java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            `<span class="comment">-- com</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                `<span class="comment">-- mycompany</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    `<span class="comment">-- app</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                        `<span class="comment">-- AppTest.java</span></span></pre></td></tr></table></figure>

<p>在我们的例子中，我们有一个META-INF目录和一个应用程序。该目录中的属性文件。如果您打开Maven为您创建的JAR并查看它，您将看到以下内容:</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">|<span class="comment">-- META-INF</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|   |<span class="comment">-- MANIFEST.MF</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|   |<span class="comment">-- application.properties</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|   `<span class="comment">-- maven</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|       `<span class="comment">-- com.mycompany.app</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|           `<span class="comment">-- my-app</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|               |<span class="comment">-- pom.properties</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|               `<span class="comment">-- pom.xml</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">`<span class="comment">-- com</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    `<span class="comment">-- mycompany</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        `<span class="comment">-- app</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            `<span class="comment">-- App.class</span></span></pre></td></tr></table></figure>

<p>可以看到，<code>${basedir}/src/main/resources</code>的内容可以从JAR和我们的应用程序的底部开始找到。<code>application.properties</code>文件在<code>META-INF</code>目录中。您还会注意到其他一些文件，比如<code>META-INF/MANIFEST.MF</code>,以及<code>pom.xml</code> 和 <code>pom.properties</code>文件。这些都是Maven中生成JAR的标准配置。如果您选择，您可以创建自己的清单，但是Maven将在缺省情况下生成清单。(您还可以修改默认清单中的条目。这个我们以后再谈。)<code>pom.xml</code> 和<code>pom.properties</code>。属性文件打包在JAR中，因此Maven生成的每个构件都是自描述的，并且如果需要，还允许您在自己的应用程序中使用元数据。一个简单的用途可能是检索应用程序的版本。在POM文件上操作需要使用一些Maven实用程序，但是可以使用标准Java API使用这些属性，如下所示:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#Generated by Maven</span></pre></td></tr><tr><td class="code"><pre><span class="line">#Tue Oct <span class="number">04</span> <span class="number">15</span>:<span class="number">43</span>:<span class="number">21</span> GMT<span class="number">-05</span>:<span class="number">00</span> <span class="number">2005</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">version=<span class="number">1.0</span>-SNAPSHOT</span></pre></td></tr><tr><td class="code"><pre><span class="line">groupId=com.mycompany.app</span></pre></td></tr><tr><td class="code"><pre><span class="line">artifactId=my-app</span></pre></td></tr></table></figure>

<p>要将资源添加到单元测试的类路径中，除了将资源放入的目录为<code>${basedir}/src/test/resources</code>之外，遵循与向JAR添加资源相同的模式。此时，您将拥有一个项目目录结构，如下所示:</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">my-app</span></pre></td></tr><tr><td class="code"><pre><span class="line">|<span class="string">-- pom.xml</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">`-- src</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    </span>|<span class="string">-- main</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">   `-- com</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">       `-- mycompany</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">           `-- app</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">               `-- App.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    </span>|<span class="string">   `-- resources</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    </span>|<span class="string">       `-- META-INF</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    </span>|<span class="string">           </span>|<span class="string">-- application.properties</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    `-- test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">        </span>|<span class="string">-- java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">        </span>|<span class="string">   `-- com</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">        </span>|<span class="string">       `-- mycompany</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">        </span>|<span class="string">           `-- app</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">        </span>|<span class="string">               `-- AppTest.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">        `-- resources</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">            `-- test.properties</span></span></pre></td></tr></table></figure>

<p>在单元测试中，您可以使用如下简单的代码片段来访问测试所需的资源:</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="params">...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Retrieve resource</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">InputStream is = getClass().getResourceAsStream( <span class="string">"/test.properties"</span> );</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Do something with the resource</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="params">...</span></span></pre></td></tr></table></figure>

<h2 id="如何过滤资源文件"><a href="#如何过滤资源文件" class="headerlink" title="如何过滤资源文件?"></a>如何过滤资源文件?</h2><p>有时，资源文件需要包含一个只能在构建时提供的值。要在Maven中实现这一点，可以使用${}语法将包含值的属性引用放到资源文件中。属性可以是pom中定义的值之一。xml，用户设置中定义的值。xml，在外部属性文件或系统属性中定义的属性。<br>要让Maven在复制时过滤资源，只需将pom.xml中的资源目录的<code>filtering</code>设置为true:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Quick Start Archetype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>您将注意到，我们必须添加以前没有的 <code>build</code>, <code>resources</code> 和 <code>resource</code>元素。此外，我们必须显式地声明资源位于src/main/resources目录中。所有这些信息都是以前作为默认值提供的，但是因为用于<code>filtering</code>的默认值是false，所以我们必须将其添加到pom.xml中，以便覆盖该默认值并将<code>filtering</code>设置为true。<br>引用pom中定义的属性。属性名使用定义值的xml元素的名称，允许“pom”作为项目(根)元素的别名。因此<code>${project.name}</code>引用项目的名称，<code>${project.version}</code>引用项目的版本，<code>${project.build.finalName}</code>是指在打包构建的项目时创建的文件的最终名称，等等。请注意，POM的一些元素有默认值，因此不需要在<code>pom.xml</code>中显式地定义这些值。类似地，可以使用以“settings”开头的属性名引用用户<code>settings.xml</code>中的值(例如<code>${settings.localRepository}</code>引用用户的本地存储库的路径)。<br>为了继续我们的示例，让我们向<code>application.properties</code>添加几个属性(我们把它放在src/main/resources目录中)，当资源被过滤时，它的值将被提供:</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">application</span>.<span class="built_in">name</span>=$&#123;project.<span class="built_in">name</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">application</span>.<span class="built_in">version</span>=$&#123;project.<span class="built_in">version</span>&#125;</span></pre></td></tr></table></figure>

<p>有了它，您可以执行以下命令(process-resources是复制和过滤资源的构建生命周期阶段):</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">mvn <span class="built_in">process</span>-resources</span></pre></td></tr></table></figure>

<p>和<code>target/classes</code>下的<code>application.properties</code>(最终会进入jar)看起来是这样的:</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">application</span>.<span class="built_in">name</span>=Maven Quick Start Archetype</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">application</span>.<span class="built_in">version</span>=<span class="number">1.0</span>-SNAPSHOT</span></pre></td></tr></table></figure>

<p>要引用外部文件中定义的属性，只需在pom.xml中添加对该外部文件的引用。首先，让我们创建外部属性文件并调用它:</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">src/main/filters/<span class="built_in">filter</span>.properties:<span class="comment"># filter.properties</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">my.<span class="built_in">filter</span>.<span class="built_in">value</span>=hello!</span></pre></td></tr></table></figure>

<p>接下来，我们将在pom.xml中添加对这个新文件的引用:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Quick Start Archetype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">filter</span>&gt;</span>src/main/filters/filter.properties<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>然后，如果我们在应用程序中添加对该属性的引用。属性文件:</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">application.name</span>=<span class="variable">$&#123;project.name&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">application.version</span>=<span class="variable">$&#123;project.version&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">message</span>=<span class="variable">$&#123;my.filter.value&#125;</span></span></pre></td></tr></table></figure>

<p><code>mvn process-resources</code>命令的下一个执行将把我们的新属性值放入<code>application.properties</code>。作为定义my.filter.value 的替代方法。在外部文件中，您也可以在pom.xml的properties部分中定义value属性，您将得到相同的效果(注意，我不需要对<code>src/main/filters/filter.properties</code>的引用):</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Quick Start Archetype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">my.filter.value</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">my.filter.value</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>过滤资源还可以从系统属性中获取值;要么是内置到Java中的系统属性(比如<code>java.version</code> 或者<code>user.home</code>)。或在命令行上使用标准Java -D参数定义的属性。为了继续这个示例，让我们更改我们的应用程序。属性文件看起来像这样:</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"># application.properties</span></pre></td></tr><tr><td class="code"><pre><span class="line">java.<span class="keyword">version</span>=<span class="variable">$&#123;java</span>.<span class="keyword">version</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">command.<span class="keyword">line</span>.<span class="keyword">prop</span>=<span class="variable">$&#123;command</span>.<span class="keyword">line</span>.<span class="keyword">prop</span>&#125;</span></pre></td></tr></table></figure>

<p>现在，当您执行以下命令时(注意command.line.prop的定义)，<code>application.properties</code>将包含来自系统属性的值。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">mvn <span class="built_in">process</span>-resources <span class="string">"-Dcommand.line.prop=hello again"</span></span></pre></td></tr></table></figure>

<h2 id="我如何使用外部依赖"><a href="#我如何使用外部依赖" class="headerlink" title="我如何使用外部依赖?"></a>我如何使用外部依赖?</h2><p>您可能已经注意到我们作为示例使用的POM中有一个<code>dependencies</code>元素。实际上，您一直在使用外部依赖项，但在这里我们将更详细地讨论它是如何工作的。有关更详细的介绍，请参阅我们对依赖机制的介绍。<br>pom.xml的<code>dependencies</code>部分列出了我们的项目为了构建而需要的所有外部依赖项(无论是在编译时、测试时、运行时还是其他时候)。现在，我们的项目只依赖于JUnit(为了清晰起见，我去掉了所有的资源过滤):</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Quick Start Archetype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>对于每个外部依赖项，至少需要定义4个东西:groupId、artifactId、version和scope。groupId、artifactId和版本与构建该依赖项的项目的<code>pom.xml</code>中给出的版本相同。scope元素指示项目如何使用该依赖项，可以是<code>compile</code>、<code>test</code>和<code>runtime</code>等值。有关可以为依赖项指定的所有内容的更多信息，请参见项目描述符引用(<a href="https://link.juejin.im?target=https%3A%2F%2Fmaven.apache.org%2Fref%2F3.6.1%2Fmaven-model%2Fmaven.html">maven.apache.org/ref/3.6.1/m…</a>)。<br>有了这些关于依赖项的信息，Maven将能够在构建项目时引用依赖项。Maven从哪里引用依赖项?Maven查看本地存储库(<code>${user.home}/.m2/repository</code>是默认位置)来查找所有依赖项。在前一节中，我们将项目中的构件(my-app-1.0- snap .jar)安装到本地存储库中。一旦它安装在那里，另一个项目就可以将该jar引用为依赖项，只需将依赖项信息添加到它的pom.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-other-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>那么在其他地方构建的依赖关系呢?它们如何进入我的本地存储库?当项目引用本地存储库中不可用的依赖项时，Maven将从远程存储库下载该依赖项到本地存储库。您可能注意到Maven在构建第一个项目时下载了很多东西(这些下载是用于构建项目的各种插件的依赖项)。默认情况下，可以通过<a href="http://repo.maven.apache.org/maven2/找到(并浏览)Maven使用的远程存储库。您还可以设置自己的远程存储库(可能是您公司的一个中央存储库)来代替或附加使用默认的远程存储库。有关存储库的更多信息，请参阅存储库介绍。" target="_blank" rel="noopener">http://repo.maven.apache.org/maven2/找到(并浏览)Maven使用的远程存储库。您还可以设置自己的远程存储库(可能是您公司的一个中央存储库)来代替或附加使用默认的远程存储库。有关存储库的更多信息，请参阅存储库介绍。</a><br>让我们为项目添加另一个依赖项。假设我们在代码中添加了一些日志记录，并且需要添加log4j作为依赖项。首先，我们需要知道log4j的groupId、artifactId和版本。Maven中心上的适当目录称为/maven2/log4j/log4j。在该目录中有一个名为maven-metada .xml的文件。log4j的maven-metada .xml是这样的:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">metadata</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">versioning</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">versions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">versions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">versioning</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">metadata</span>&gt;</span></span></pre></td></tr></table></figure>

<p>从这个文件中，我们可以看到我们想要的groupId是“log4j”，而artifactId是“log4j”。我们看到有很多不同的版本值可供选择;现在，我们只使用最新版本1.2.12(一些maven-metada .xml文件也可能指定哪个版本是当前版本)。在maven-metada .xml文件旁边，我们可以看到与log4j库的每个版本对应的目录。在这些文件中，我们将找到实际的<strong>jar文件</strong>(例如log4j-1.2.12.jar)、<strong>pom文件</strong>(这是依赖项的pom.xml，表示它可能具有的任何进一步依赖项和其他信息)和另一个<strong>maven-metada .xml文件</strong>。还有一个<strong>md5文件</strong>对应于每个文件，其中包含这些文件的md5散列。您可以使用它对库进行身份验证，或者确定您可能已经在使用某个特定库的哪个版本。<br>现在我们知道了需要的信息，可以将依赖项添加到pom.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Quick Start Archetype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><p>Maven通过自动包含传递依赖项，避免了发现和指定您自己的依赖项所需的库。<br>通过从指定的远程存储库中读取依赖项的项目文件，可以简化此功能。通常，这些项目的所有依赖项都将在您的项目中使用，就像项目从父项目继承的依赖项或从依赖项继承的依赖项一样。<br>可以收集依赖项的级别数量没有限制。只有在发现循环依赖项时才会出现问题。<br>使用传递依赖关系，所包含的库的图可以快速增长得相当大。由于这个原因，有一些额外的功能限制哪些依赖关系包括在内:<br><strong>依赖项中介</strong>——当遇到多个版本作为依赖项时，它决定将选择工件的哪个版本。Maven选择“<strong>最近的定义</strong>”。也就是说，它使用依赖树中与项目最接近的依赖项的版本。您总是可以通过在项目的POM中显式声明一个版本来保证该版本。请注意，如果依赖项树中的两个依赖项版本具有相同的深度，则第一个声明将获胜。</p>
<blockquote>
<p>“最接近的定义”意味着所使用的版本将是依赖关系树中最接近您的项目的版本。例如，如果A、B和C的依赖关系定义为A -&gt; B -&gt; C -&gt; D 2.0和A -&gt; E -&gt; D 1.0，那么在构建A时将使用D 1.0，因为从A到D到E的路径更短。您可以在a中显式地向d2.0添加依赖项，以强制使用d2.0。</p>
</blockquote>
<p><strong>依赖关系管理</strong>——这允许项目作者直接指定工件的版本，当它们遇到传递依赖项或没有指定版本的依赖项时使用。在前面的示例中部分依赖直接添加到即使它是不能直接使用的a .相反,可以包括D作为依赖dependencyManagement部分和直接控制哪个版本的D时使用,或者是引用。<br><strong>依赖关系范围</strong>——这允许您只包含适合当前构建阶段的依赖关系。下面将对此进行更详细的描述。<br><strong>排除依赖关系</strong>——如果项目X依赖于项目Y，而项目Y依赖于项目Z，那么项目X的所有者可以使用“”exclusion”元素显式地排除项目Z作为依赖关系。<br><strong>可选依赖项</strong>——如果项目Y依赖于项目Z，项目Y的所有者可以使用“optional”元素将项目Z标记为可选依赖项。当项目X依赖于项目Y时，X将只依赖于Y，而不依赖于Y的可选依赖项Z。(将可选依赖项视为“默认排除”可能会有所帮助。)<br>虽然传递依赖项可以隐式地包含所需的依赖项，但显式地指定直接在源代码中使用的依赖项是一个很好的实践。这一最佳实践证明了它的价值，特别是当项目的依赖项更改其依赖项时。<br>例如,假设您的项目指定一个依赖另一个项目B, B和项目指定依赖项目C .如果你直接使用组件项目C,和你不指定项目C在您的项目中,它可能会导致构建失败当项目B突然更新/删除项目C的依赖。<br>直接指定依赖关系的另一个原因是，它为您的项目提供了更好的文档:只需阅读项目中的POM文件就可以了解更多信息。<br>Maven还提供了依赖关系:分析插件目标来分析依赖关系:它有助于使这一最佳实践更容易实现。</p>
<h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>依赖项的范围——<code>compile</code>, <code>runtime</code>, <code>test</code>, <code>system</code>和 <code>provided</code>。用于计算用于编译、测试等的各种类路径。它还帮助确定在这个项目的发行版中包含哪些工件。有关更多信息，请参见依赖机制。默认范围是compile。<br>依赖关系管理是Maven的一个核心特性。管理单个项目的依赖关系很容易。管理由数百个模块组成的多模块项目和应用程序的依赖关系是可能的。Maven在使用定义良好的类路径和库版本定义、创建和维护可重复构建方面帮助很大。<br>依赖范围用于限制依赖项的传递性，还用于影响用于各种构建任务的类路径。<br>有6种适用范围:<br><strong>compile</strong><br>这是默认范围，如果没有指定则使用。编译依赖项在项目的所有类路径中都可用。此外，这些依赖项将传播到依赖的项目。<br><strong>provided</strong><br>这很像<code>compile</code>，但表明您希望JDK或容器在运行时提供依赖项。例如，当为Java Enterprise Edition构建web应用程序时，您将对Servlet API和相关Java EE API的依赖scope设置为<code>provided</code>，因为web容器提供了这些类。此范围仅在编译和测试类路径上可用，且不可传递。<br><strong>runtime</strong><br>此范围指示此依赖项不是编译所需的，而是执行所需的。它位于运行时和测试类路径中，但不在编译类路径中。<br><strong>test</strong><br>此范围表明，应用程序的正常使用不需要依赖项，仅在测试编译和执行阶段可用。这个范围不是可传递的。<br><strong>system</strong><br>除了必须显式地提供包含它的JAR之外，此范围与<code>provided</code>的类似。工件总是可用的，并且不会在存储库中查找。<br><strong>import</strong><br>此范围仅在<code>部分的`pom`类型依赖项上受支持。它指示要用指定POM的</code>节中的有效依赖项列表替换依赖项。由于替换了依赖项，具有导入范围的依赖项实际上并不参与限制依赖项的传递性。<br>每个范围(import除外)都以不同的方式影响传递依赖关系，如下表所示。如果将依赖项设置为左列中的作用域，则该依赖项与第一行中的作用域的传递依赖项将导致主项目中的依赖项，其作用域列在交集处。如果没有列出范围，则意味着将省略依赖项。</p>
<table>
<thead>
<tr>
<th></th>
<th>compile</th>
<th>provided</th>
<th>runtime</th>
<th>test</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>compile(*)</td>
<td>-</td>
<td>runtime</td>
<td>-</td>
</tr>
<tr>
<td>provided</td>
<td>provided</td>
<td>-</td>
<td>provided</td>
<td>-</td>
</tr>
<tr>
<td>runtime</td>
<td>runtime</td>
<td>-</td>
<td>runtime</td>
<td>-</td>
</tr>
<tr>
<td>test</td>
<td>test</td>
<td>-</td>
<td>test</td>
<td>-</td>
</tr>
</tbody></table>
<p>(*)注意:这应该是运行时范围，以便所有编译依赖项必须显式列出。但是，如果您所依赖的库从另一个库扩展了一个类，那么这两个库必须在编译时可用。因此，即使编译时依赖项是传递的，它们仍然作为编译范围。</p>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>依赖项管理部分是集中化依赖项信息的机制。当您有一组继承公共父类的项目时，可以将所有关于依赖关系的信息放在公共POM中，并对子POMs中的构件有更简单的引用。通过一些例子可以很好地说明这种机制。给定这两个延伸相同父节点的POMs:<br>Project A::</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-a<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-c<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>excluded-artifact<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-a<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>Project B:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-c<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>war<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-a<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>这两个示例POMs共享一个公共依赖项，并且每个POMs都有一个重要的依赖项。这些信息可以像这样放在父POM中:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-a<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-c<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>excluded-artifact<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-c<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>war<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-a<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>然后两个孩子的poms变得简单多了:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-a<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-a<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">&lt;!-- This is not a jar dependency, so we must specify type. --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-c<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">&lt;!-- This is not a jar dependency, so we must specify type. --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>war<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-a<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">&lt;!-- This is not a jar dependency, so we must specify type. --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>注意:在这两个依赖项引用中，我们必须指定``元素。这是因为，针对dependencyManagement部分匹配依赖项引用的最小信息集实际上是{groupId、artifactId、type、classifier}。在许多情况下，这些依赖关系将引用没有分类器的jar构件。这允许我们将标识简写为{groupId, artifactId}，因为类型字段的缺省值是jar，缺省分类器是null。<br>依赖项管理部分的第二个非常重要的用途是控制传递依赖项中使用的工件的版本。例如，考虑以下项目:<br>Project A:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>A<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>A<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>d<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>Project B:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>A<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>B<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>d<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>当maven在项目B上运行时，工件a、b、c和d的1.0版本将被使用，而不考虑它们的pom中指定的版本。<br>a和c都声明为项目的依赖项，因此由于依赖项中介使用1.0版本。两者都有运行时范围，因为它是直接指定的。<br>b在b的父依赖项管理部分中定义，由于依赖项管理对于传递依赖项优先于依赖项中介，所以如果在a或c的pom中引用1.0版本，则选择1.0版本。b也有编译范围。<br>最后，由于d是在B的依赖项管理部分中指定的，如果d是a或c的依赖项(或传递依赖项)，那么将选择1.0版本——同样，因为依赖项管理优先于依赖项中介，而且当前pom的声明优先于其父声明。<br>有关依赖项管理标记的引用信息可从项目描述符引用获得。</p>
<h3 id="引入依赖项"><a href="#引入依赖项" class="headerlink" title="引入依赖项"></a>引入依赖项</h3><p>上一节中的示例描述了如何通过继承指定托管依赖项。然而，在较大的项目中，这可能是不可能完成的，因为项目只能从单个父级继承。为了适应这一点，项目可以从其他项目导入托管依赖项。这是通过将pom工件声明为具有“import”范围的依赖项来实现的。<br>Project B:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>B<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>A<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>d<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>假设A是前面示例中定义的pom，那么最终结果将是相同的。除了d之外，A的所有托管依赖项都将被合并到B中，因为d是在这个pom中定义的。<br>Project X:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>X<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>X<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>Project Y:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Y<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>Y<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>Project Z:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Z<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Z<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>X<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Y<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>在上面的例子中，Z从X和Y中导入托管依赖项。然而，X和Y都包含依赖项a。<br>这个过程是递归的。例如，如果X导入另一个pom Q，当Z被处理时，它将简单地显示Q的所有托管依赖项都在X中定义。<br>当用于定义相关工件的“库”时，导入是最有效的，这些工件通常是多项目构建的一部分。一个项目使用这些库中的一个或多个构件是相当常见的。然而，有时很难使用构件将项目中的版本与库中分发的版本保持同步。下面的模式说明了如何创建“物料清单”(BOM)供其他项目使用。<br>项目的根是BOM pom。它定义了将在库中创建的所有构件的版本。希望使用该库的其他项目应该将此pom导入其pom的dependencyManagement部分。</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">project1Version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">project1Version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">project2Version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">project2Version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;project1Version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;project2Version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></span></pre></td></tr></table></figure>

<p>父子项目以BOM pom作为父项目。这是一个普通的多项目pom。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>project1<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>project2<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>接下来是实际的项目poms:</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;project1Version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;project2Version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></span></pre></td></tr></table></figure>

<p>下面的项目展示了如何在另一个项目中使用库，而不必指定依赖项目的版本。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>use<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<h3 id="系统依赖"><a href="#系统依赖" class="headerlink" title="系统依赖"></a>系统依赖</h3><p><code>重要提示:这是不推荐的。</code><br>与范围系统的依赖关系总是可用的，并且不会在存储库中查找。它们通常用于告诉Maven JDK或VM提供的依赖关系。因此，系统依赖关系对于解决对工件的依赖关系特别有用，这些工件现在由JDK提供，但是在以前可以单独下载。典型的例子是JDBC标准扩展或Java身份验证和授权服务(JAAS)。<br>一个简单的例子是:</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="params">&lt;project&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="params">&lt;dependencies&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="params">&lt;dependency&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="params">&lt;groupId&gt;</span>javax.sql<span class="params">&lt;/groupId&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="params">&lt;artifactId&gt;</span>jdbc-stdext<span class="params">&lt;/artifactId&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="params">&lt;version&gt;</span><span class="number">2.0</span><span class="params">&lt;/version&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="params">&lt;scope&gt;</span>system<span class="params">&lt;/scope&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="params">&lt;systemPath&gt;</span>$&#123;java.home&#125;<span class="meta-keyword">/lib/</span>rt.jar<span class="params">&lt;/systemPath&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="params">&lt;/dependency&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="params">&lt;/dependencies&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="params">&lt;/project&gt;</span></span></pre></td></tr></table></figure>

<p>如果您的工件是由JDK的<code>tools.jar</code>提供的，系统路径定义如下:</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="params">&lt;project&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="params">&lt;dependencies&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="params">&lt;dependency&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="params">&lt;groupId&gt;</span>sun.jdk<span class="params">&lt;/groupId&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="params">&lt;artifactId&gt;</span>tools<span class="params">&lt;/artifactId&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="params">&lt;version&gt;</span><span class="number">1.5</span><span class="number">.0</span><span class="params">&lt;/version&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="params">&lt;scope&gt;</span>system<span class="params">&lt;/scope&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="params">&lt;systemPath&gt;</span>$&#123;java.home&#125;/..<span class="meta-keyword">/lib/</span>tools.jar<span class="params">&lt;/systemPath&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="params">&lt;/dependency&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="params">&lt;/dependencies&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="params">&lt;/project&gt;</span></span></pre></td></tr></table></figure>

<h2 id="Optional-amp-Exclusion"><a href="#Optional-amp-Exclusion" class="headerlink" title="Optional &amp; Exclusion"></a>Optional &amp; Exclusion</h2><p>本节讨论可选的依赖项和依赖项排除。这将帮助用户了解它们是什么、何时以及如何使用它们。它还解释了为什么排除是在每个依赖项的基础上而不是在POM级别进行的。</p>
<h3 id="可选依赖关系"><a href="#可选依赖关系" class="headerlink" title="可选依赖关系"></a>可选依赖关系</h3><p>当不可能(无论出于什么原因)将项目分割为子模块时，将使用可选依赖项。其思想是，一些依赖关系仅用于项目中的某些特性，如果不使用该特性，就不需要这些依赖关系。理想情况下，这样的特性将被划分为依赖于核心功能项目的子模块。这个新的子项目将只有非可选的依赖项，因为如果您决定使用子项目的功能，就需要所有这些依赖项。<br>然而，由于项目不能被分割(无论出于什么原因)，这些依赖项声明为可选的。如果用户希望使用与可选依赖项相关的功能，则必须在自己的项目中重新声明该可选依赖项。这不是处理这种情况的最清楚的方法，但是可选依赖项和依赖项排除都是权宜之计。</p>
<h4 id="为什么使用可选依赖项"><a href="#为什么使用可选依赖项" class="headerlink" title="为什么使用可选依赖项?"></a>为什么使用可选依赖项?</h4><p>可选依赖项节省空间和内存。它们防止有问题的jar(违反许可协议或导致类路径问题)被绑定到WAR、EAR、fat jar或类似的jar中。</p>
<h4 id="如何使用optional标签"><a href="#如何使用optional标签" class="headerlink" title="如何使用optional标签"></a>如何使用optional标签</h4><p>通过在依赖项声明中将``元素设置为true，可以将依赖项声明为可选:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- declare the dependency to be set as optional --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectA<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Project-A<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span> <span class="comment">&lt;!-- value will be true or false only --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<h4 id="可选依赖项如何工作"><a href="#可选依赖项如何工作" class="headerlink" title="可选依赖项如何工作?"></a>可选依赖项如何工作?</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Project</span>-A -&gt; <span class="keyword">Project</span>-B</span></pre></td></tr></table></figure>

<p>上面的图表说明项目a依赖于项目b。当A在其POM中将B声明为可选依赖项时，此关系保持不变。它就像一个普通的构建，其中Project-B将被添加到Project-A的类路径中。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Project</span>-X -&gt; <span class="keyword">Project</span>-A</span></pre></td></tr></table></figure>

<p>当另一个项目(project - x)在其POM中将project - a声明为依赖项时，依赖项的可选属性将生效。Project-B不包含在Project-X的类路径中。您需要在项目X的POM中直接声明它，以便将B包含在X的类路径中。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>假设有一个名为X2的项目，它具有与Hibernate类似的功能。它支持许多数据库，如MySQL、PostgreSQL和Oracle的几个版本。每个受支持的数据库都需要额外依赖于驱动程序jar。所有这些依赖项都需要在编译时构建X2。但是，您的项目只使用一个特定的数据库，其他数据库不需要驱动程序。X2可以将这些依赖项声明为可选的，这样当您的项目在其POM中将X2声明为直接依赖项时，X2支持的所有驱动程序不会自动包含在项目的类路径中。您的项目必须包含对它所使用的数据库的特定驱动程序的显式依赖。</p>
<h3 id="Dependency-Exclusions"><a href="#Dependency-Exclusions" class="headerlink" title="Dependency Exclusions"></a>Dependency Exclusions</h3><p>由于Maven临时解析依赖项，所以项目的类路径中可能包含不需要的依赖项。例如，某个较老的jar可能存在安全问题，或者与您正在使用的Java版本不兼容。为了解决这个问题，Maven允许您排除特定的依赖项。排除是针对POM中的特定依赖项设置的，并且针对特定的groupId和artifactId。当您构建项目时，该构件将不会通过声明排除的依赖项添加到项目的类路径中。</p>
<h4 id="如何使用dependency-exclusions"><a href="#如何使用dependency-exclusions" class="headerlink" title="如何使用dependency exclusions"></a>如何使用dependency exclusions</h4><p>在包含有问题jar的<code>元素中添加一个</code>元素。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectA<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Project-A<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span>  <span class="comment">&lt;!-- declare the exclusion here --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectB<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Project-B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<h4 id="依赖性排除是如何工作的，以及什么时候使用它-作为最后的手段"><a href="#依赖性排除是如何工作的，以及什么时候使用它-作为最后的手段" class="headerlink" title="依赖性排除是如何工作的，以及什么时候使用它(作为最后的手段!)"></a>依赖性排除是如何工作的，以及什么时候使用它(作为最后的手段!)</h4><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="type">Project</span>-<span class="type">A</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   -&gt; <span class="type">Project</span>-<span class="type">B</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        -&gt; <span class="type">Project</span>-<span class="type">D</span> &lt;! <span class="comment">-- This dependency should be excluded --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">              -&gt; <span class="type">Project</span>-<span class="type">E</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">              -&gt; <span class="type">Project</span>-<span class="type">F</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   -&gt; <span class="type">Project</span> <span class="type">C</span></span></pre></td></tr></table></figure>

<p>从图中可以看出，Project-A依赖于Project-B, Project-B依赖于Project-D。Project- D依赖于Project- E和F.默认情况下，Project A的类路径包括:</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">B, </span>C, D, E, F</span></pre></td></tr></table></figure>

<p>假设您不希望将项目D及其依赖项添加到项目A的类路径中，因为存储库中缺少了项目D的一些依赖项，而且您不需要项目b中依赖于项目D的功能。项目b的开发人员可以将依赖关系标记为项目d <code>true</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectD<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ProjectD<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure>

<p>不幸的是,他们没有。最后，您可以将其排除在您自己的POM中，用于项目a，如下所示:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectA<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Project-A<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectB<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Project-B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectD<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> <span class="comment">&lt;!-- Exclude Project-D from Project-B --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Project-D<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>如果您将Project-A部署到存储库中，并且Project-X声明了对Project-A的正常依赖关系，Project-D还会被排除在类路径之外吗?</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Project</span>-X -&gt; <span class="keyword">Project</span>-A</span></pre></td></tr></table></figure>

<p>答案是肯定的。Project-A已经声明它不需要Project-D来运行，所以它不会作为Project-A的传递依赖项引入。 现在，考虑项目x依赖于项目y，如下图所示:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Project</span>-X -&gt; <span class="keyword">Project</span>-Y</span></pre></td></tr><tr><td class="code"><pre><span class="line">               -&gt; <span class="keyword">Project</span>-B</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    -&gt; <span class="keyword">Project</span>-D</span></pre></td></tr><tr><td class="code"><pre><span class="line">                       ...</span></pre></td></tr></table></figure>

<p>Project-Y也依赖于Project-B，它确实需要Project-D所支持的特性。因此，它不会在依赖项列表中的Project-D上放置排斥。它还可能提供一个额外的存储库，从这个存储库可以解析Project-E。在这种情况下，重要的是不要在全局中排除Project-D，因为它是Project-Y的合法依赖项。<br>作为另一个场景，假设您不想要的依赖项是Project-E而不是Project-D。你如何排除它?见下图:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Project-A</span></pre></td></tr><tr><td class="code"><pre><span class="line">   -&gt; Project-B</span></pre></td></tr><tr><td class="code"><pre><span class="line">        -&gt; Project-D</span></pre></td></tr><tr><td class="code"><pre><span class="line">              -&gt; Project-E <span class="comment">&lt;!-- Exclude this dependency --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">              -&gt; Project-F</span></pre></td></tr><tr><td class="code"><pre><span class="line">   -&gt; Project C</span></pre></td></tr></table></figure>

<p>排除作用作用于声明它们的点以下的整个依赖关系图。如果您想排除Project-E而不是Project-D，只需将排除更改为指向Project-E，但不将排除移动到Project-D。您不能更改Project-D的POM。如果可以，您可以使用可选的依赖项而不是排除项，或者将Project-D分割为多个子项目，每个子项目只有正常的依赖项。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectA<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Project-A<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectB<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Project-B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectE<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> <span class="comment">&lt;!-- Exclude Project-E from Project-B --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Project-E<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<h4 id="为什么要在每个依赖项的基础上而不是在POM级别上进行排除"><a href="#为什么要在每个依赖项的基础上而不是在POM级别上进行排除" class="headerlink" title="为什么要在每个依赖项的基础上而不是在POM级别上进行排除"></a>为什么要在每个依赖项的基础上而不是在POM级别上进行排除</h4><p>这主要是为了确保依赖关系图是可预测的，并防止继承影响排除不应该排除的依赖关系。如果您使用了最后一种方法，并且不得不进行排除，那么您应该绝对确定哪些依赖项引入了不需要的传递依赖项。<br>如果您确实希望确保某个特定依赖项不会出现在类路径中，无论路径是什么，都可以将<a href="https://link.juejin.im?target=https%3A%2F%2Fmaven.apache.org%2Fenforcer%2Fenforcer-rules%2FbannedDependencies.html">禁止依赖项规则</a>配置为在发现有问题的依赖项时构建失败。当构建失败时，您需要在强制程序找到的每个路径上添加特定的排除。</p>
<h2 id="如何在远程存储库中部署jar"><a href="#如何在远程存储库中部署jar" class="headerlink" title="如何在远程存储库中部署jar ?"></a>如何在远程存储库中部署jar ?</h2><p>要将jar部署到外部存储库，您必须在pom.xml中配置存储库url，并在settings.xml中配置连接到存储库的身份验证信息。<br>下面是一个使用scp和用户名/密码身份验证的例子:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Quick Start Archetype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.codehaus.plexus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>plexus-utils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">filter</span>&gt;</span>src/main/filters/filters.properties<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">&lt;!--</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">   |</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">   |</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">   |</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">   --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>mycompany-repository<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>MyCompany Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>scp://repository.mycompany.com/repository/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>mycompany-repository<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">username</span>&gt;</span>jvanzyl<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">&lt;!-- Default value is ~/.ssh/id_dsa --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">privateKey</span>&gt;</span>/path/to/identity<span class="tag">&lt;/<span class="name">privateKey</span>&gt;</span> (default is ~/.ssh/id_dsa)</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">passphrase</span>&gt;</span>my_key_passphrase<span class="tag">&lt;/<span class="name">passphrase</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span></pre></td></tr></table></figure>

<p>注意,如果您正在连接到一个openssh ssh服务器的参数“PasswordAuthentication”设置sshd_confing为”no”,你必须输入你的密码每次用户名/密码身份验证(尽管您可以使用另一个ssh客户机登录输入用户名和密码)。在本例中，您可能希望切换到公钥身份验证。 如果在settings.xml中使用密码，应该小心。有关更多信息，请参见密码加密。（<a href="https://link.juejin.im?target=https%3A%2F%2Fmaven.apache.org%2Fguides%2Fmini%2Fguide-encryption.html%EF%BC%89">maven.apache.org/guides/mini…</a></p>
<h2 id="如何创建文档"><a href="#如何创建文档" class="headerlink" title="如何创建文档?"></a>如何创建文档?</h2><p>要开始使用Maven的文档系统，可以使用原型机制使用以下命令为现有项目生成站点:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">-DarchetypeGroupId</span>=org.apache.maven.archetypes \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">-DarchetypeArtifactId</span>=maven-archetype-site \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">-DgroupId</span>=com.mycompany.app \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">-DartifactId</span>=my-app-site</span></pre></td></tr></table></figure>

<h2 id="我如何构建其他类型的项目"><a href="#我如何构建其他类型的项目" class="headerlink" title="我如何构建其他类型的项目?"></a>我如何构建其他类型的项目?</h2><p>注意，生命周期适用于任何项目类型。例如，回到基本目录，我们可以创建一个简单的web应用程序:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">-DarchetypeGroupId</span>=org.apache.maven.archetypes \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">-DarchetypeArtifactId</span>=maven-archetype-webapp \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">-DgroupId</span>=com.mycompany.app \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">-DartifactId</span>=my-webapp</span></pre></td></tr></table></figure>

<p>注意，这些必须都在一行上。这将创建一个名为my-webapp的目录，其中包含以下项目描述符:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-webapp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>my-webapp<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>注意``元素——这告诉Maven将构建为一个WAR。切换到webapp项目的目录，并尝试:</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">mvn <span class="class"><span class="keyword">package</span></span></span></pre></td></tr></table></figure>

<p>你会看到<code>target/my-webapp.war</code>被构建了，所有正常的步骤都被执行了。</p>
<h2 id="如何同时构建多个项目"><a href="#如何同时构建多个项目" class="headerlink" title="如何同时构建多个项目?"></a>如何同时构建多个项目?</h2><p>Maven内置了处理多个模块的概念。在本节中，我们将展示如何构建上面的WAR，并在一个步骤中包含前面的JAR。 首先，我们需要在前面两个目录中添加一个父pom.xml文件，所以它应该是这样的:</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">+- pom.xml</span></pre></td></tr><tr><td class="code"><pre><span class="line">+- my-app</span></pre></td></tr><tr><td class="code"><pre><span class="line">| +- pom.xml</span></pre></td></tr><tr><td class="code"><pre><span class="line">| +- src</span></pre></td></tr><tr><td class="code"><pre><span class="line">|   +- main</span></pre></td></tr><tr><td class="code"><pre><span class="line">|     +- java</span></pre></td></tr><tr><td class="code"><pre><span class="line">+- my-webapp</span></pre></td></tr><tr><td class="code"><pre><span class="line">| +- pom.xml</span></pre></td></tr><tr><td class="code"><pre><span class="line">| +- src</span></pre></td></tr><tr><td class="code"><pre><span class="line">|   +- main</span></pre></td></tr><tr><td class="code"><pre><span class="line">|     +- webapp</span></pre></td></tr></table></figure>

<p>您将创建的POM文件应该包含以下内容:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-webapp<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>我们需要一个从webapp依赖于JAR，所以添加到<code>my-webapp/pom.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr></table></figure>

<p>最后，将以下``元素添加到子目录中的其他pom.xml文件中:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr></table></figure>

<p>现在,试试…从顶层目录运行:</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mvn </span>verify</span></pre></td></tr></table></figure>

<p>WAR现在已经在<code>my-webapp/target/my-webapp.war</code>中创建。JAR包括:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ jar tvf my-webapp/target/my-webapp<span class="number">-1.0</span>-SNAPSHOT.war</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">0</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">56</span> EST <span class="number">2005</span> META-INF/</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">222</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">54</span> EST <span class="number">2005</span> META-INF/MANIFEST.MF</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">0</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">56</span> EST <span class="number">2005</span> META-INF/maven/</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">0</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">56</span> EST <span class="number">2005</span> META-INF/maven/com.mycompany.app/</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">0</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">56</span> EST <span class="number">2005</span> META-INF/maven/com.mycompany.app/my-webapp/</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3239</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">56</span> EST <span class="number">2005</span> META-INF/maven/com.mycompany.app/my-webapp/pom.xml</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">0</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">56</span> EST <span class="number">2005</span> WEB-INF/</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">215</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">56</span> EST <span class="number">2005</span> WEB-INF/web.xml</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">123</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">56</span> EST <span class="number">2005</span> META-INF/maven/com.mycompany.app/my-webapp/pom.properties</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">52</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">56</span> EST <span class="number">2005</span> index.jsp</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">0</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">56</span> EST <span class="number">2005</span> WEB-INF/lib/</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2713</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">56</span> EST <span class="number">2005</span> WEB-INF/lib/my-app<span class="number">-1.0</span>-SNAPSHOT.jar</span></pre></td></tr></table></figure>

<p>这是怎么回事?首先，创建的父POM(称为<code>app</code>)有一个<code>pom</code>打包和定义的模块列表。这告诉Maven在一组项目上运行所有操作，而不是只运行当前的一个(要覆盖此行为，可以使用<code>--non-recursive</code>命令行选项)。<br>接下来，我们告诉WAR它需要<code>my-app</code> JAR。这做了一些事情:它使WAR中的任何代码在类路径上都可用(在本例中没有)，它确保JAR总是在WAR之前构建的，并指示WAR插件将JAR包含在其库目录中。<br>您可能已经注意到<code>junit-4.11.jar</code>是一个依赖项，但最终没有进入WAR。原因是<code>test</code>元素-它只用于测试，因此不像编译时依赖my-app那样包含在web应用程序中。<br>最后一步是包含父定义。这与Maven 1.0中您可能熟悉的扩展元素不同:这确保了即使项目是通过在存储库中查找而与父项目单独分布的，也始终能够找到POM。</p>
<h1 id="构建生命周期介绍"><a href="#构建生命周期介绍" class="headerlink" title="构建生命周期介绍"></a>构建生命周期介绍</h1><h2 id="构建生命周期基础知识"><a href="#构建生命周期基础知识" class="headerlink" title="构建生命周期基础知识"></a>构建生命周期基础知识</h2><p>Maven基于构建生命周期的核心概念。这意味着构建和分发特定工件(项目)的过程被清晰地定义了。<br>对于构建项目的人员来说，这意味着只需要学习一小组命令就可以构建任何Maven项目，POM将确保他们得到他们想要的结果。<br>有三个内置的构建生命周期:default、clean和site。<code>default</code>生命周期处理项目部署，<code>clean</code>生命周期处理项目清理，而<code>site</code>生命周期处理项目站点文档的创建。</p>
<h2 id="构建生命周期阶段组成"><a href="#构建生命周期阶段组成" class="headerlink" title="构建生命周期阶段组成"></a>构建生命周期阶段组成</h2><p>每个构建生命周期都由不同的构建阶段列表定义，其中一个构建阶段表示生命周期中的一个阶段。 例如，默认的生命周期包括以下几个阶段(完整的生命周期阶段列表，请参考生命周期参考):</p>
<ul>
<li><code>validate</code> -验证项目是正确的，并且所有必要的信息都是可用的</li>
<li><code>compile</code> - 编译项目的源代码</li>
<li><code>test</code> - 使用合适的单元测试框架测试编译后的源代码。这些测试不应该要求打包或部署代码</li>
<li><code>package</code> - 将编译后的代码以其可分发格式打包，例如JAR。</li>
<li><code>verify</code> - 对集成测试的结果进行任何检查，以确保满足质量标准</li>
<li><code>install</code> - 将包安装到本地存储库中，以便在本地的其他项目中作为依赖项使用</li>
<li><code>deploy</code> - 在构建环境中完成后，将最终的包复制到远程存储库，以便与其他开发人员和项目共享。</li>
</ul>
<p>这些生命周期阶段(加上这里没有显示的其他生命周期阶段)按顺序执行，以完成默认的生命周期。鉴于上面的生命周期阶段,这意味着当默认使用生命周期,Maven将首先验证项目,然后将试图编译源代码,运行这些测试,包二进制文件(如jar),运行集成测试方案,验证了集成测试,验证包安装到本地存储库,然后将安装包部署到远程存储库。</p>
<h3 id="常用命令行调用"><a href="#常用命令行调用" class="headerlink" title="常用命令行调用"></a>常用命令行调用</h3><p>在开发环境中，使用以下调用将构件构建并安装到本地存储库中。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mvn </span>install</span></pre></td></tr></table></figure>

<p>在执行安装之前，此命令按顺序执行每个默认的生命周期阶段(<code>validate</code>, <code>compile</code>, <code>package</code>等)。您只需要调用要执行的最后一个构建阶段，在这种情况下，<code>instal</code>l: 在构建环境中，使用以下调用干净地构建并将构件部署到共享存储库中。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mvn </span>clean deploy</span></pre></td></tr></table></figure>

<p>同一个命令可以在多模块场景中使用(例如，具有一个或多个子项目的项目)。Maven遍历每个子项目并执行clean，然后执行deploy(包括所有先前的构建阶段步骤)。</p>
<h3 id="构建阶段由插件目标组成"><a href="#构建阶段由插件目标组成" class="headerlink" title="构建阶段由插件目标组成"></a>构建阶段由插件目标组成</h3><p>然而，即使构建阶段负责构建生命周期中的特定步骤，它执行这些职责的方式也可能不同。这是通过声明绑定到那些构建阶段的插件目标来实现的。<br>插件目标表示一个特定的任务(比构建阶段更精细)，它有助于构建和管理项目。它可能被绑定到零个或多个构建阶段。不绑定到任何构建阶段的目标可以通过直接调用在构建生命周期之外执行。执行的顺序取决于调用目标和构建阶段的顺序。例如，考虑下面的命令。clean和package参数是构建阶段，而<code>dependency:copy-dependencies</code>是(插件的)目标。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">mvn clean dependency:<span class="keyword">copy</span>-<span class="keyword">dependencies</span> <span class="keyword">package</span></span></pre></td></tr></table></figure>

<p>如果这是执行,<code>clean</code> 阶段将首先执行(这意味着它将运行所有干净的前阶段生命周期,加上<code>clean</code>阶段本身),然后以<code>dependency:copy-dependencies</code>为目标,最后执行方案阶段(及其构建阶段之前的缺省生命周期)。<br>此外，如果一个目标被绑定到一个或多个构建阶段，那么该目标将在所有这些阶段中被调用。 此外，构建阶段还可以有零个或多个目标。如果构建阶段没有绑定目标，那么该构建阶段将不会执行。但如果它有一个或多个目标，它将执行所有这些目标。</p>
<h2 id="设置您的项目以使用构建生命周期"><a href="#设置您的项目以使用构建生命周期" class="headerlink" title="设置您的项目以使用构建生命周期"></a>设置您的项目以使用构建生命周期</h2><p>构建生命周期非常简单，可以使用，但是当您为项目构建Maven构建时，如何为每个构建阶段分配任务呢?</p>
<h3 id="Packaging"><a href="#Packaging" class="headerlink" title="Packaging"></a>Packaging</h3><p>第一种也是最常见的方法是通过同样命名的POM元素``设置项目的打包。一些有效的打包值是jar、war、ear和pom。如果没有指定打包值，则默认为jar。<br>每个包都包含一个要绑定到特定阶段的目标列表。例如，jar打包将绑定以下目标来构建默认生命周期的各个阶段。</p>
<table>
<thead>
<tr>
<th>Phase</th>
<th>plugin:goal</th>
</tr>
</thead>
<tbody><tr>
<td><code>process-resources</code></td>
<td><code>resources:resources</code></td>
</tr>
<tr>
<td><code>compile</code></td>
<td><code>compiler:compile</code></td>
</tr>
<tr>
<td><code>process-test-resources</code></td>
<td><code>resources:testResources</code></td>
</tr>
<tr>
<td><code>test-compile</code></td>
<td><code>compiler:testCompile</code></td>
</tr>
<tr>
<td><code>test</code></td>
<td><code>surefire:test</code></td>
</tr>
<tr>
<td><code>package</code></td>
<td><code>jar:jar</code></td>
</tr>
<tr>
<td><code>install</code></td>
<td><code>install:install</code></td>
</tr>
<tr>
<td><code>deploy</code></td>
<td><code>deploy:deploy</code></td>
</tr>
</tbody></table>
<p>这几乎是一组标准的绑定;然而，有些包装对它们的处理不同。例如，一个纯元数据的项目(打包值是pom)只将目标绑定到安装和部署阶段(对于一些打包类型的目标到构建阶段的完整列表，请参考生命周期引用)。<br>注意，对于某些可用的打包类型，您可能还需要在POM的``部分中包含一个特定的插件，并为该插件指定<code>true</code>。丛应用程序和丛服务打包提供了丛应用程序和丛服务打包。</p>
<h1 id="POM文件介绍"><a href="#POM文件介绍" class="headerlink" title="POM文件介绍"></a>POM文件介绍</h1><h2 id="什么是POM"><a href="#什么是POM" class="headerlink" title="什么是POM"></a>什么是POM</h2><p>项目对象模型或POM是Maven中的基本工作单元。它是一个XML文件，包含Maven用于构建项目的有关项目和配置细节的信息。它包含大多数项目的默认值。例如build目录，它是目标;源目录，即src/main/java;测试源目录，即src/test/java;等等。在执行任务或目标时，Maven在当前目录中查找POM。它读取POM，获取所需的配置信息，然后执行目标。<br>POM中可以指定的一些配置包括项目依赖项、可以执行的插件或目标、构建概要文件等等。还可以指定项目版本、描述、开发人员、邮件列表等其他信息。</p>
<h2 id="Super-POM"><a href="#Super-POM" class="headerlink" title="Super POM"></a>Super POM</h2><p>Super POM是Maven的默认POM。除非显式设置，否则所有POMs都会继承Super POM，这意味着在Super POM中指定的配置将由为项目创建的POMs继承。下面的代码片段是Maven 3.5.4的Super POM。</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Central Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Central Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>never<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$</span><span class="template-variable">&#123;project.basedir&#125;</span><span class="xml">/target<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$</span><span class="template-variable">&#123;project.build.directory&#125;</span><span class="xml">/classes<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$</span><span class="template-variable">&#123;project.artifactId&#125;</span><span class="xml">-$</span><span class="template-variable">&#123;project.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">testOutputDirectory</span>&gt;</span>$</span><span class="template-variable">&#123;project.build.directory&#125;</span><span class="xml">/test-classes<span class="tag">&lt;/<span class="name">testOutputDirectory</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>$</span><span class="template-variable">&#123;project.basedir&#125;</span><span class="xml">/src/main/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">scriptSourceDirectory</span>&gt;</span>$</span><span class="template-variable">&#123;project.basedir&#125;</span><span class="xml">/src/main/scripts<span class="tag">&lt;/<span class="name">scriptSourceDirectory</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>$</span><span class="template-variable">&#123;project.basedir&#125;</span><span class="xml">/src/test/java<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$</span><span class="template-variable">&#123;project.basedir&#125;</span><span class="xml">/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$</span><span class="template-variable">&#123;project.basedir&#125;</span><span class="xml">/src/test/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="comment">&lt;!-- <span class="doctag">NOTE:</span> These plugins will be removed from future versions of the super POM --&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="comment">&lt;!-- They are kept for the moment as they are very unlikely to conflict with lifecycle mappings (MNG-4453) --&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-antrun-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2-beta-5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-release-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$</span><span class="template-variable">&#123;project.build.directory&#125;</span><span class="xml">/site<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="comment">&lt;!-- <span class="doctag">NOTE:</span> The release profile will be removed from future versions of the super POM --&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>release-profile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>performRelease<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">build</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-sources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">                  <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar-no-fork<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">              <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-javadocs<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">                  <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">              <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">updateReleaseInfo</span>&gt;</span>true<span class="tag">&lt;/<span class="name">updateReleaseInfo</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></span></pre></td></tr></table></figure>

<blockquote>
<p>作者：lamar酱</p>
<p>来源：<a href="https://juejin.im/post/5d66477ae51d4561af16dd46" target="_blank" rel="noopener">https://juejin.im/post/5d66477ae51d4561af16dd46</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title>Java后端目前最常用的工具和框架</title>
    <url>/2019/12/26/Java%E5%90%8E%E7%AB%AF%E7%9B%AE%E5%89%8D%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E5%92%8C%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>本篇内容涵盖14个方面，涉及上百个框架和工具。会有你喜欢的，大概也会有你所讨厌的家伙。这是我平常工作中打交道最多的工具，大小公司都适用。如果你有更好的，欢迎留言补充。</p>
<a id="more"></a>

<h2 id="一、消息队列"><a href="#一、消息队列" class="headerlink" title="一、消息队列"></a>一、消息队列</h2><p><img src="http://image.winrains.cn/2019/08/20190829093426-ca111.png" alt="img"></p>
<p><strong>一个大型的分布式系统，通常都会异步化，走消息总线。</strong> 消息队列作为最主要的基础组件，在整个体系架构中，有着及其重要的作用。kafka是目前最常用的消息队列，尤其是在大数据方面，有着极高的吞吐量。而rocketmq和rabbitmq，都是电信级别的消息队列，在业务上用的比较多。2019年了，不要再盯着JMS不放了（说的就是臃肿的ActiveMQ）。<br>pulsar是为了解决一些kafka上的问题而诞生的消息系统，比较年轻，工具链有限。有些激进的团队经过试用，反响不错。<br>mqtt具体来说是一种协议，主要用在物联网方面，能够双向通信，属于消息队列范畴。</p>
<h2 id="二、缓存"><a href="#二、缓存" class="headerlink" title="二、缓存"></a>二、缓存</h2><p><img src="http://image.winrains.cn/2019/08/20190829093427-21d77.png" alt="img"></p>
<p>数据缓存是减少数据库压力的有效途径，有单机java内缓存，和分布式缓存之分。<br>对于单机来说，guava的cache和ehcache都是些熟面孔。<br>对于分布式缓存来说，优先选择的就是<code>redis</code>，别犹豫。由于redis是单线程的，并不适合高耗时操作。所以对于一些数据量比较大的缓存，比如图片、视频等，使用老牌的memcached效果会好的多。<br>JetCache是一个基于Java的缓存系统封装，提供统一的api和注解来简化缓存的使用。类似SpringCache，支持本地缓存和分布式缓存，是简化开发的利器。</p>
<h2 id="三、分库分表"><a href="#三、分库分表" class="headerlink" title="三、分库分表"></a>三、分库分表</h2><p><img src="http://image.winrains.cn/2019/08/20190829093428-37063.png" alt="img"></p>
<p>分库分表，几乎每一个上点规模的公司，都会有自己的方案。目前，推荐使用驱动层的<code>sharding-jdbc</code>，或者代理层的<code>mycat</code>。如果你没有额外的运维团队，又不想花钱买其他机器，那么就选前者。<br>如果分库分表涉及的项目不多，spring的动态数据源是一个非常好的选择。它直接编码在代码里，直观但不易扩展。<br>如果只需要<strong>读写分离</strong> ，那么mysql官方驱动里的replication协议，是更加轻量级的选择。<br><strong>上面的分库分表组件，都是大浪淘沙，最终的优胜品。这些组件不同于其他组件选型，方案一旦确定，几乎无法回退，所以要慎之又慎。</strong><br>分库分表是小case，准备分库分表的阶段，才是重点：也就是数据同步。</p>
<h2 id="四、数据同步"><a href="#四、数据同步" class="headerlink" title="四、数据同步"></a>四、数据同步</h2><p><img src="http://image.winrains.cn/2019/08/20190829093428-33f78.png" alt="img"></p>
<p>国内使用mysql的公司居多，但postgresql凭借其优异的性能，使用率逐渐攀升。<br><strong>不管什么数据库，实时数据同步工具，都是把自己模拟成一个从库，进行数据拉取和解析。</strong> 具体来说，mysql是通过binlog进行同步；postgresql使用wal日志进行同步。<br>对mysql来说，canal是国内用的最多的方案；类似的databus也是比较好用的工具。<br>现在，canal、maxwell等工具，都支持将要同步的数据写入到mq中，进行后续处理，方便了很多。<br>对于ETL（抽取、清洗、转换）来说，基本上都是source、task、sink路线，与前面的功能对应。gobblin、datax、logstash、sqoop等，都是这样的工具。<br>它们的主要工作，就是怎么方便的定义配置文件，编写各种各样的数据源适配接口等。这些ETL工具，也可以作为数据同步（尤其是全量同步）的工具，通常是根据<code>ID</code>，或者<strong>最后更新时间</strong> 等，进行处理。<br>binlog是实时增量工具，ETL工具做辅助。通常一个数据同步功能，需要多个组件的参与，他们共同组成一个整体。</p>
<h2 id="五、通讯"><a href="#五、通讯" class="headerlink" title="五、通讯"></a>五、通讯</h2><p><img src="http://image.winrains.cn/2019/08/20190829093430-2a85d.png" alt="img"></p>
<p>Java 中，netty已经成为当之无愧的网络开发框架，包括其上的socketio（不要再和我提mina了）。对于http协议，有common-httpclient，以及更加轻量级的工具okhttp来支持。<br>对于一个rpc来说，要约定一个通讯方式和序列化方式。json是最常用的序列化方式，但是传输和解析成本大，xml等文本协议与其类似，都有很多冗余的信息；avro和kryo是二进制的序列化工具，没有这些缺点，但调试不便。<br><strong>rpc是远程过程调用的意思</strong> ，其中，thrift、dubbo、gRPC默认都是二进制序列化方式的socket通讯框架；feign、hessian都是onhttp的远程调用框架。<br>对了，gRPC的序列化工具是protobuf，一个压缩比很高的二进制序列化工具。<br><strong>通常，服务的响应时间主要耗费在业务逻辑以及数据库上，通讯层耗时在其中的占比很小。可以根据自己公司的研发水平和业务规模来选择。</strong></p>
<h2 id="六、微服务"><a href="#六、微服务" class="headerlink" title="六、微服务"></a>六、微服务</h2><p><img src="http://image.winrains.cn/2019/08/20190829093431-82a4c.png" alt="img"></p>
<p>我们不止一次说到微服务，这一次我们从围绕它的一堆支持框架，来窥探一下这个体系。是的，这里依然是在说spring cloud。<br>默认的注册中心eureka不再维护，consul已经成为首选。nacos、zookeeper等，都可以作为备选方案。其中nacos带有后台，比较适合国人使用习惯。<br>熔断组件，官方的hystrix也已经不维护了。推荐使用resilience4j，最近阿里的sentinel也表现强劲。<br>对于调用链来说，由于OpenTracing的兴起，有了很多新的面孔。推荐使用jaeger或者skywalking。spring cloud集成的sleuth+zipkin功能稍弱，甚至不如传统侵入式的cat。<br>配置中心是管理多环境配置文件的利器，尤其在你不想重启服务器的情况下进行配置更新。目前，开源中做的最好的要数apollo，并提供了对spring boot的支持。disconf使用也较为广泛。相对来说，spring cloud config功能就局限了些，用的很少。</p>
<hr>
<p>网关方面，使用最多的就是nginx，在nginx之上，有基于lua脚本的openrestry。由于openresty的使用非常繁杂，所以有了kong这种封装级别更高的网关。<br>对于spring cloud来说，zuul系列推荐使用zuul2，zuul1是多线程阻塞的，有硬伤。spring-cloud-gateway是spring cloud亲生的，但目前用的不是很广泛。</p>
<h2 id="七、分布式工具"><a href="#七、分布式工具" class="headerlink" title="七、分布式工具"></a>七、分布式工具</h2><p><img src="http://image.winrains.cn/2019/08/20190829093432-cb97f.png" alt="img"></p>
<p>大家都知道分布式系统zookeeper能用在很多场景，与其类似的还有基于raft协议的etcd和consul。<br>由于它们能够保证极高的一致性，所以用作协调工具是再好不过了。<strong>用途集中在：配置中心、分布式锁、命名服务、分布式协调、master选举等场所。</strong><br>对于分布式事务方面，则有阿里的fescar工具进行支持。但如非特别的必要，还是使用<code>柔性事务</code>，追寻<code>最终一致性</code>，比较好。</p>
<h2 id="八、监控系统"><a href="#八、监控系统" class="headerlink" title="八、监控系统"></a>八、监控系统</h2><p><img src="http://image.winrains.cn/2019/08/20190829093433-c7b1d.png" alt="img"></p>
<p>监控系统组件种类繁多，目前，最流行的大概就是上面四类。<br>zabbix在主机数量不多的情况下，是非常好的选择。<br>prometheus来势凶猛，大有一统天下的架势。它也可以使用更加漂亮的grafana进行前端展示。<br>influxdata的influxdb和telegraf组件，都比较好用，主要是功能很全。<br>使用es存储的elkb工具链，也是一个较好的选择。我所知道的很多公司，都在用。</p>
<h2 id="九、调度"><a href="#九、调度" class="headerlink" title="九、调度"></a>九、调度</h2><p><img src="http://image.winrains.cn/2019/08/20190829093433-4bf36.png" alt="img"></p>
<p>大家可能都用过cron表达式。这个表达式，最初就是来自linux的crontab工具。<br>quartz是java中比较古老的调度方案，分布式调度采用数据库锁的方式，管理界面需要自行开发。<br>elastic-job-cloud应用比较广泛，但系统运维复杂，学习成本较高。相对来说，xxl-job就更加轻量级一些。中国人开发的系统，后台都比较漂亮。</p>
<h2 id="十、入口工具"><a href="#十、入口工具" class="headerlink" title="十、入口工具"></a>十、入口工具</h2><p><img src="http://image.winrains.cn/2019/08/20190829093434-2acc5.png" alt="img"></p>
<p>为了统一用户的访问路口，一般会使用一些入口工具进行支持。<br>其中，haproxy、lvs、keepalived等，使用非常广泛。<br>服务器一般采用稳定性较好的centos，并配备ansible工具进行支持，那叫一个爽。</p>
<h2 id="十一、OLT（A）P"><a href="#十一、OLT（A）P" class="headerlink" title="十一、OLT（A）P"></a>十一、OLT（A）P</h2><p><img src="http://image.winrains.cn/2019/08/20190829093435-9d501.png" alt="img"></p>
<p><strong>现在的企业，数据量都非常大，数据仓库是必须的。</strong><br>搜索方面，solr和elasticsearch比较流行，它们都是基于lucene的。solr比较成熟，稳定性更好一些，但实时搜索方面不如es。<br>列式存储方面，基于Hadoop 的hbase，使用最是广泛；基于LSM的leveldb写入性能优越，但目前主要是作为嵌入式引擎使用多一些。<br>tidb是国产新贵，兼容mysql协议，公司通过培训向外输出dba，未来可期。<br>时序数据库方面，opentsdb用在超大型监控系统多一些。druid和kudu，在处理多维度数据实时聚合方面，更胜一筹。<br>cassandra在刚出现时火了一段时间，虽然有facebook弃用的新闻，但生态已经形成，常年霸占数据库引擎前15名。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829093436-96406.png" alt="img"></p>
<h2 id="十二、CI-CD"><a href="#十二、CI-CD" class="headerlink" title="十二、CI/CD"></a>十二、CI/CD</h2><p><img src="http://image.winrains.cn/2019/08/20190829093436-f0047.png" alt="img"></p>
<p>为了支持持续集成和虚拟化，除了耳熟能详的docker，我们还有其他工具。<br>jenkins是打包发布的首选，毕竟这么多年了，一直是老大哥。当然，写Idea的那家公司，还出了一个叫TeamCity的工具，操作界面非常流畅。<br>sonar（注意图上的错误）不得不说是一个神器，用了它之后，小伙伴们的代码一片飘红，我都快被吐沫星子给淹没了。<br>对于公司内部来说，一般使用gitlab搭建git服务器。其实，它里面的gitlab CI，也是非常好用的。</p>
<h2 id="十三、问题排查"><a href="#十三、问题排查" class="headerlink" title="十三、问题排查"></a>十三、问题排查</h2><p><img src="http://image.winrains.cn/2019/08/20190829093437-f4198.png" alt="img"></p>
<p>java经常发生内存溢出问题。使用jmap导出堆栈后，我一般使用mat进行深入分析。<br>如果在线上实时分析，有arthas和perf两款工具。<br>当然，有大批量的linux工具进行支持。比如下面这些：<br><a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F9RbTGQ4k4s92mrSf2xJ5TQ">《Linux上，最常用的一批命令解析（10年精选）》</a></p>
<h2 id="十四、本地工具"><a href="#十四、本地工具" class="headerlink" title="十四、本地工具"></a>十四、本地工具</h2><p><img src="http://image.winrains.cn/2019/08/20190829093437-e085f.png" alt="img"></p>
<p>本地使用的jar包和工具，那就多了去了。下面仅仅提一下最最常用的几个。<br>数据库连接池方面，国内使用druid最多。目前，有号称速度最快的hikari数据库连接池，以及老掉牙的dbcp和c3p0。<br>json方面，国内使用fastjson最多，三天两头冒出个漏洞；国外则使用jackson多一些。它们的api都类似，jackson特性多一些，但fastjson更加容易使用。<br>工具包方面，虽然有各种commons包，guava首选。</p>
<blockquote>
<p>作者：小姐姐味道</p>
<p>来源：<a href="https://juejin.im/post/5d5375baf265da03b2152f3d" target="_blank" rel="noopener">https://juejin.im/post/5d5375baf265da03b2152f3d</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>Linux常用命令：vim技巧</title>
    <url>/2019/12/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%9Avim%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>研发线上使用最多的编辑器，就是<code>vi</code>。无论是最快查看某个文件内容，还是快速编辑某个文件，<code>vi</code>都能帮上忙。<br>软件世界貌似有一些非常长寿的东西，<code>vi</code>算是一个。本篇文章聚焦的是研发线上最常用的一些功能。至于安装插件，写一些脚本，那一般是在开发机上玩的，生产环境没有条件、也没有时间忍受你做这些增强。希望看完本文，能够对这款神器有一个大体印象。当然，熟练的使用还需要日常有意识的培养。</p>
<blockquote>
<p><code>vim</code>是<code>vi</code>的增强版，一般现代<code>linux</code>都不缺那几兆空间，所以预装的都是增强版，本文默认使用<code>vim</code>。</p>
</blockquote>
<a id="more"></a>

<h1 id="养成习惯"><a href="#养成习惯" class="headerlink" title="养成习惯"></a>养成习惯</h1><p><code>vim</code>最大的贡献就是它的<strong>按键系统</strong>。这也是为什么<strong>chrome</strong>、<strong>idea</strong>、<strong>atom</strong>等编辑器都会提供一个<code>vim mode</code>。<strong>笔者见过很多资深的程序员，包括架构师，习惯使用方向键去控制光标的移动**</strong>。<strong>这不能说不对，但这也抛弃了<code>vim</code>最大的精华所在，效率上低了一大截。坚持使用<code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>，你会感谢你今天的纠正。大脑和手指真的是有记忆，当你用的足够多，这也就成了你约定俗成的设定。<br><code>vim</code>另外一个特点就是</strong>带模式的**。一共四种模式，我们不需要记忆，只需要使用例子去理解即可。</p>
<h1 id="不要添乱"><a href="#不要添乱" class="headerlink" title="不要添乱"></a>不要添乱</h1><p>不要使用<code>vim</code>打开大文件，<code>vim</code>会一次性读取所有内容到内存，容易造成宿主机内存溢出。<br>打开文件前，可以使用<code>du -h</code>命令查看文件大小。一般，<code>100MB</code>以下为宜。</p>
<h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><p>以下操作在普通模式下执行，连续按键</p>
<h2 id="漫游"><a href="#漫游" class="headerlink" title="漫游"></a>漫游</h2><blockquote>
<p><strong>j</strong> 向下<br><strong>30j</strong> 向下移动30行<br><strong>k</strong> 向上<br><strong>h</strong> 向左<br><strong>l</strong> 向右<br><strong>0</strong> 到行首<br><strong>^</strong> 到行首第一个字符，如果前面有空格的话<br><strong>$</strong> 到行尾<br><strong>gg</strong> 快速到文件头<br><strong>G</strong> 快速到文件尾<br><strong>100G</strong> 跳转到第100行</p>
</blockquote>
<p><em>不建议在插入模式下进行光标移动，这很低效</em></p>
<h2 id="复制：y"><a href="#复制：y" class="headerlink" title="复制：y"></a>复制：y</h2><blockquote>
<p><strong>yy</strong> 复制一行<br><strong>10yy</strong> 向下复制10行<br><strong>yw</strong> 复制光标开始的一个单词<br><strong>y$</strong> 复制光标到行尾<br><strong>yfB</strong> 复制光标到第一个大写B中间的内容<br><strong>y2fB</strong> 复制光标到第二个大写B中间的内容</p>
</blockquote>
<h2 id="剪切-x"><a href="#剪切-x" class="headerlink" title="剪切: x"></a>剪切: x</h2><blockquote>
<p><strong>x</strong> 向剪切一个一个字符，如果是在行尾，则为向前剪切<br><strong>3x</strong> 剪切三个<br><strong>xp</strong> 非行尾交换两个字符，如从<code>bs</code>变成<code>sb</code></p>
</blockquote>
<h2 id="删除：d"><a href="#删除：d" class="headerlink" title="删除：d"></a>删除：d</h2><p><em>删除的内容会放到剪贴板，按<code>p</code>即可粘贴到其他地方</em></p>
<blockquote>
<p><strong>dd</strong> 删除一行<br><strong>200dd</strong> 删除200行<br><strong>dw</strong> 删除一个单词 （最喜欢啦）<br><strong>df”</strong> 删除到出现的第一个双引号</p>
</blockquote>
<h2 id="粘贴-p"><a href="#粘贴-p" class="headerlink" title="粘贴: p"></a>粘贴: p</h2><blockquote>
<p><strong>p</strong> 粘贴复制或剪切的内容<br><strong>3p</strong> 将复制或剪切的内容粘贴三次</p>
</blockquote>
<h1 id="可视化模式"><a href="#可视化模式" class="headerlink" title="可视化模式"></a>可视化模式</h1><h3 id="v-行模式，选择一些内容"><a href="#v-行模式，选择一些内容" class="headerlink" title="v 行模式，选择一些内容"></a><code>v</code> 行模式，选择一些内容</h3><p>可视化模式是非常有用的一种模式，在普通模式下按<strong>v</strong>即可进入。<br>使用<code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>进行漫游，选中相应的内容。<br>例子，选中一部分想要的内容，并删除。<br><img src="http://image.winrains.cn/2019/08/20190829093954-8c6f5.gif" alt="img"></p>
<h3 id="ctrl-v-块模式"><a href="#ctrl-v-块模式" class="headerlink" title="ctrl+v 块模式"></a><code>ctrl+v</code> 块模式</h3><blockquote>
<p>演示：将文件中的每一行添加到<code>ArrayList</code>中：</p>
</blockquote>
<p><img src="http://image.winrains.cn/2019/08/20190829093955-c3509.gif" alt="img"><br><strong>1)</strong> 在命令模式下，执行<code>%s/$/&quot;);/g</code>，在行尾追加数据<br><strong>2)</strong> 按<code>ESC</code>进入普通模式，并使用<code>gg</code>回到行首<br><strong>3)</strong> 按<code>ctrl+v</code>进入可视化模式，然后按<code>G</code>到文件尾<br><strong>4)</strong> 不要理会编辑器反应，按<code>I</code>进入插入模式，输入<code>list.add(&quot;</code><br><strong>5)</strong> 按<code>ESC</code>回到普通模式，可以发现以上输入已经在每一行生效了<br>块模式还可以完成列互换，貌似在<code>UE</code>里见过此神技。<br><img src="http://image.winrains.cn/2019/08/20190829093955-cd913.gif" alt="img"></p>
<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>上面的例子里已经展示了命令模式的进入模式。<strong>在普通模式下，输入<code>:</code>即可进入</strong>。</p>
<blockquote>
<p><strong>%s/$/sth/</strong> 在行尾追加sth<br><strong>%s/^M//g</strong> 替换掉dos换行符，<code>\^M</code>使用<code>ctrl+v  + Enter</code>即可输入<br><strong>:g/^\s*$/d</strong> 删除空行以及只有空格的行<br><strong>%s/#.*//g</strong> 删除<code>#</code>之后的字符</p>
</blockquote>
<p><em>没错，命令模式用的是正则，这些经验是通用的</em><br>你已经发现了，这大概就是针对编辑器窗口的<code>sed</code>命令。</p>
<h1 id="查找字符串"><a href="#查找字符串" class="headerlink" title="查找字符串"></a>查找字符串</h1><p><em>同样的，正则的知识也可以应用*</em><br>在普通模式下，按下<code>/</code>直接进入查找，输入相应的字符串按确定即可。</p>
<blockquote>
<p><strong>n</strong> 查找下一个匹配<br><strong>N</strong> 查找上一个匹配<br><strong>2n</strong> 查找下面第二个匹配</p>
</blockquote>
<p>如果觉得跳来跳去晕头转向，可以在命令模式下输入<code>set nu</code>开启行号。</p>
<h1 id="宏录制"><a href="#宏录制" class="headerlink" title="宏录制"></a>宏录制</h1><p>这可以说是<code>vim</code>的一个杀手锏了。拿上面的例子来说。<br>将文件中的每一行添加到<code>ArrayList</code>中。<br><img src="http://image.winrains.cn/2019/08/20190829093955-45b8b.gif" alt="img"><br><strong>1)</strong> 按下<code>gg</code>到行首<br><strong>2)</strong> 按下<code>qa</code>进行宏录制，<code>a</code>是我们起的一个标记名称<br><strong>3)</strong> 按<code>I</code>进入插入模式，输入<code>list.add(&quot;</code><br><strong>4)</strong> 按<code>ESC</code>进入普通模式，然后按<code>$</code>跳到行尾<br><strong>5)</strong> 按<code>j</code>进入下一行，然后按<code>^</code>回到行首<br><strong>6)</strong> 再次按下<code>q</code>结束宏录制<br><strong>7)</strong> 输入<code>@a</code>触发宏测试一下录制效果<br><strong>8)</strong> 输入<code>100@a</code>重复宏100次，也就是影响下面的100行<br><em>可以录制不同的多个宏，方便的进行批量操作</em></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>另外用的一些比较少的主要功能有</p>
<blockquote>
<p><strong>r</strong> 替换字符<br><strong>ggVG</strong> 全选<br><strong>u</strong> 恢复更改<br><strong>J</strong> 合并下一行<br><strong>gU</strong> 光标处转大写<br><strong>ggguG</strong> 整篇文章大写转化为小写<br><strong>%</strong> 跳转到下一个匹配,如在<code>上按`%`，则跳转到相应的</code><br><strong>:e /tmp/a</strong> 在同一个编辑器内打开<code>/tmp/a</code>文件。同一个编辑器的缓冲区是剪贴板是共享的，可以方便在多个文件中复制<br><strong>bp</strong> 跳转到上一个缓冲区<br><strong>bn</strong> 跳转到下一个缓冲区</p>
</blockquote>
<h1 id="退出编辑器"><a href="#退出编辑器" class="headerlink" title="退出编辑器"></a>退出编辑器</h1><blockquote>
<p><strong>wq</strong> 保存当前文件并退出<br><strong>wqa</strong> 保存所有文件并退出<br><strong>q!</strong> 不保存，直接退出<br><strong>qa!</strong> 有多个文件被打开，同时退出</p>
</blockquote>
<p>本篇文章只聚焦常用功能，帮助读者快速处理线上文本。至于更多的，也装不下，只有你自己去探索喽。<br><code>vim</code>的入门门槛比较高，幸运的是，用多了，你就无法释手了。</p>
<blockquote>
<p>作者：小姐姐养的狗</p>
<p>来源：<a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650518612&amp;idx=1&amp;sn=125c2cb9ee6d76a6817fb0ebc5a3c5e4&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650518612&amp;idx=1&amp;sn=125c2cb9ee6d76a6817fb0ebc5a3c5e4&amp;scene=21#wechat_redirect</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux技术</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令：sed技巧</title>
    <url>/2019/12/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%9Ased%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p><code>sed</code>命令应用广泛，使用简单，是快速文本处理的利器。它其实没多少技巧，背诵、使用是最合适的学习渠道，属于硬技能。但它又很复杂，因为高级功能太多。本篇不去关注sed的高级功能，仅对常用的一些操作，进行说明。<br>随着使用，你会发现它和<code>vim</code>的一些理念是想通的，正则表达式的语法也基本上一样，并没有多少学习成本。从个人视野和工作效率上来看，sed命令都是程序员必须掌握的一个重要工具。</p>
<blockquote>
<p>那些说可以现场google用法的，大多习惯将文本拷贝到excel里，慢慢磨洋工，遇到大批量文件更是手忙脚乱。不是一家人不进一家门，本文不是为你写的。</p>
</blockquote>
<a id="more"></a>

<h1 id="一个简单的入门"><a href="#一个简单的入门" class="headerlink" title="一个简单的入门"></a>一个简单的入门</h1><p><img src="http://image.winrains.cn/2019/08/20190829094951-ce583.jpeg" alt="http://image.winrains.cn/2019/08/20190829094951-ce583.jpeg"><br>如图，一个简单的sed命令包含三个主要部分：<code>参数</code>、<code>范围</code>、<code>操作</code>。要操作的文件，可以直接挂在命令行的最后。除了命令行，sed也可以通过-f参数指定一个sed脚本，这个属于高级用法，不做过多描述。<br>有些示例命令我会重复多次，聪明如你一定能发现其中规律，有时连解释都用不着。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p><strong>-n</strong> 这个参数是<code>--quiet</code>或者<code>--silent</code>的意思。表明忽略执行过程的输出，只输出我们的结果即可。<br>我们常用的还有另外一个参数 ：<code>-i</code>。</p>
<blockquote>
<p>使用此参数后，所有改动将在原文件上执行。你的输出将覆盖原文件。<strong>非常危险</strong>，一定要注意。</p>
</blockquote>
<h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p><strong>1,4</strong> 表示找到文件中1,2,3,4行的内容。<br>这个范围的指定很有灵性，请看以下示例（请自行替换图中的范围部分）。</p>
<blockquote>
<p><strong>5</strong> 选择第5行。<br><strong>2,5</strong> 选择2到5行，共4行。<br><strong>1~2</strong> 选择奇数行。<br><strong>2~2</strong> 选择偶数行。<br><strong>2,+3</strong> 和<code>2,5</code>的效果是一样的，共4行。<br><strong>2,$</strong> 从第二行到文件结尾。</p>
</blockquote>
<p>范围的选择还可以使用正则匹配。请看下面示例。</p>
<blockquote>
<p><strong>/sys/,+3</strong> 选择出现sys字样的行，以及后面的三行。<br><strong>/^sys/,/mem/</strong> 选择以sys开头的行，和出现mem字样行之间的数据。</p>
</blockquote>
<p>为了直观，下面的命令一一对应上面的介绍，范围和操作之间是可以有空格的。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">'5p'</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed -n <span class="string">'2,5 p'</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed -n <span class="string">'1~2 p'</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed -n <span class="string">'2~2 p'</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed -n <span class="string">'2,+3p'</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed -n <span class="string">'2,$ p'</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed -n <span class="string">'/sys/,+3 p'</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed -n <span class="string">'/^sys/,/mem/p'</span> <span class="keyword">file</span></span></pre></td></tr></table></figure>

<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>最常用的操作就是<code>p</code>，意思就是打印。比如，以下两个命令就是等同的：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cat</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed -n <span class="string">'p'</span> <span class="keyword">file</span></span></pre></td></tr></table></figure>

<p>除了打印，还有以下操作，我们来说常用的。</p>
<blockquote>
<p><strong>p</strong> 对匹配内容进行打印。<br><strong>d</strong> 对匹配内容进行删除。这个时候就要去掉<code>-n</code>参数了，想想为什么。<br><strong>w</strong> 将匹配内容写入到其他地方。</p>
</blockquote>
<p><code>a</code>,<code>i</code>,<code>c</code>等操作虽基本但使用少，不做介绍。我们依然拿一些命令来说明。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">'2,5 p'</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed    <span class="string">'2,5 d'</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed -n <span class="string">'2,5 w output.txt'</span> <span class="keyword">file</span></span></pre></td></tr></table></figure>

<p>我们来看一下sed命令都能干些啥，上点命令体验一下。<br>删除所有#开头的行和空行。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">sed -e <span class="string">'s/#.*//'</span> -e <span class="string">'/^$/ d'</span> <span class="keyword">file</span></span></pre></td></tr></table></figure>

<p>最常用的，比如下面这个。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">'2p'</span> <span class="regexp">/etc/g</span>roup</span></pre></td></tr></table></figure>

<p>表示打印group文件中的第二行。</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、参数部分 比如 -n</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span>、模式部分 比如'<span class="number">2</span>p'</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3</span>、文件，比如/etc/group</span></pre></td></tr></table></figure>

<p>那么我想一次执行多个命令，还不想写sed脚本文件怎么办？那就需要加-e参数。<br>sed的操作单元是<code>行</code>。</p>
<h1 id="替换模式"><a href="#替换模式" class="headerlink" title="替换模式"></a>替换模式</h1><p>以上是<code>sed</code>命令的常用匹配模式，但它还有一个强大的替换模式，意思就是查找替换其中的某些值，并输出结果。使用替换模式很少使用<code>-n</code>参数。<br><img src="http://image.winrains.cn/2019/08/20190829094952-73bc4.jpeg" alt="http://image.winrains.cn/2019/08/20190829094952-73bc4.jpeg"><br>替换模式的参数有点多，但第一部分和第五部分都是可以省略的。替换后会将<strong>整个文本</strong>输出出来。<br>前半部分用来匹配一些范围，而后半部分执行替换的动作。</p>
<h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>这个范围和上面的范围语法类似。看下面的例子。</p>
<blockquote>
<p><strong>/sys/,+3</strong> 选择出现sys字样的行，以及后面的三行。<br><strong>/^sys/,/mem/</strong> 选择以sys开头的行，和出现mem字样行之间的数据。</p>
</blockquote>
<p>具体命令为：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'/sys/,+3 s/a/b/g'</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed <span class="string">'/^sys/,/mem/s/a/b/g'</span> <span class="keyword">file</span></span></pre></td></tr></table></figure>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>这里的命令是指s。也就是substitute的意思。</p>
<h2 id="查找匹配"><a href="#查找匹配" class="headerlink" title="查找匹配"></a>查找匹配</h2><p>查找部分会找到要被替换的字符串。这部分可以接受纯粹的字符串，也可以接受正则表达式。看下面的例子。</p>
<blockquote>
<p><strong>a</strong> 查找范围行中的字符串<code>a</code>。<br><strong>[a,b,c]</strong> 从范围行里查找字符串a或者b或者c。</p>
</blockquote>
<p>命令类似：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'s/a/b/g'</span> <span class="built_in">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed <span class="string">'s/[a,b,c]/&lt;&amp;&gt;/g'</span> <span class="built_in">file</span><span class="comment">#这个命令我们下面解释</span></span></pre></td></tr></table></figure>

<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>是时候把找出的字符串给替换掉了。本部分的内容将替换查找匹配部分找到的内容。<br>可惜的是，这部分不能使用正则。常用的就是精确替换。比如把a替换成b。<br>但也有高级功能。和java或者python的正则api类似，sed的替换同样有<code>Matched Pattern</code>的含义，同样可以得到Group，不深究。常用的替位符，就是<code>&amp;</code>。<br><strong><code>&amp;</code></strong>号，再重复一遍。当它用在替换字符串中的时候，代表的是原始的查找匹配数据。</p>
<blockquote>
<p><strong>[&amp;]</strong> 表明将查找到的数据使用[]包围起来。<br><strong>“&amp;”</strong> 表明将查找的数据使用””包围起来。</p>
</blockquote>
<p>下面这条命令，将会把文件中的每一行，使用引号包围起来。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">sed <span class="symbol">'s</span>/.*/<span class="string">"&amp;"</span>/' <span class="keyword">file</span></span></pre></td></tr></table></figure>

<h2 id="flag-参数"><a href="#flag-参数" class="headerlink" title="flag 参数"></a>flag 参数</h2><p>这些参数可以单个使用，也可以使用多个，仅介绍最常用的。</p>
<blockquote>
<p><strong>g</strong> 默认只匹配行中第一次出现的内容，加上g，就可以全文替换了。常用。<br><strong>p</strong> 当使用了<code>-n</code>参数，<code>p</code>将仅输出匹配行内容。<br><strong>w</strong> 和上面的w模式类似，但是它仅仅输出有变换的行。<br><strong>i</strong> 这个参数比较重要，表示忽略大小写。<br><strong>e</strong> 表示将输出的每一行，执行一个命令。不建议使用，可以使用xargs配合完成这种功能。</p>
</blockquote>
<p>看两个命令的语法：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">'s/a/b/gipw output.txt'</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed <span class="string">'s/^/ls -la/e'</span> <span class="keyword">file</span></span></pre></td></tr></table></figure>

<h2 id="好玩"><a href="#好玩" class="headerlink" title="好玩"></a>好玩</h2><p>由于正则的关系，很多字符需要转义。你会在脚本里做些很多<code>\\</code>，<code>\*</code>之类的处理。你可以使用<code>|^@!</code>四个字符来替换<code>\</code>。<br>比如，下面五个命令是一样的。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">sed '<span class="string">/aaa/s/</span>\<span class="string">/etc/</span>\<span class="string">/usr/g</span>' file</span></pre></td></tr><tr><td class="code"><pre><span class="line">sed '<span class="string">/aaa/s</span>@<span class="string">/etc</span>@<span class="string">/usr</span>@g' file</span></pre></td></tr><tr><td class="code"><pre><span class="line">sed '<span class="string">/aaa/s</span>^<span class="string">/etc</span>^<span class="string">/usr</span>^g' file</span></pre></td></tr><tr><td class="code"><pre><span class="line">sed '<span class="string">/aaa/s</span>|<span class="string">/etc</span>|<span class="string">/usr</span>|g' file</span></pre></td></tr><tr><td class="code"><pre><span class="line">sed '<span class="string">/aaa/s</span>!<span class="string">/etc</span>!<span class="string">/usr</span>!g' file</span></pre></td></tr></table></figure>

<p>注意：前半部分的范围是不能使用这种方式的。我习惯使用符号<code>@</code>。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>可以看到，正则表达式在命令行中无处不在。以下，紧做简要说明。</p>
<blockquote>
<p><strong>^</strong> 行首<br><strong>$</strong> 行尾<br><strong>.</strong> 单个字符<br><strong>*** 0个或者多个匹配<br>**+</strong> 1个或者多个匹配<br><strong>?</strong> 0个或者1个匹配<br><strong>{m}</strong> 前面的匹配重复m次<br><strong>{m,n}</strong> 前面的匹配重复m到n次<br><strong>\</strong> 转义字符<br><strong>[0-9]</strong> 匹配括号中的任何一个字符,or的作用<br>| or，或者<br><strong>\b</strong> 匹配一个单词。比如<code>\blucky\b</code> 只匹配单词lucky</p>
</blockquote>
<h2 id="参数i"><a href="#参数i" class="headerlink" title="参数i"></a>参数i</h2><p>上面已经简单介绍了参数i，它的作用是让操作在原文件执行。无论你执行了啥，原始文件都将会被覆盖。这是非常危险的。<br>通过加入一个参数，可以将原文件做个备份。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">sed -<span class="selector-tag">i</span><span class="selector-class">.bak</span> <span class="string">'s/a/b/'</span> file</span></pre></td></tr></table></figure>

<p>以上命令会对原file文件生效，并生成一个file.bak文件。强烈建议使用i参数同时指定bak文件。</p>
<h2 id="表演一下"><a href="#表演一下" class="headerlink" title="表演一下"></a>表演一下</h2><p>我们通过两个命令，来稍微看下sed和其他命令组合起来的威力。<br><strong>输出长度不小于50个字符的行</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sed</span> -n <span class="string">'/^.&#123;50&#125;/p'</span></span></pre></td></tr></table></figure>

<p><strong>统计文件中有每个单词出现了多少次</strong></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'s/ /\n/g'</span> <span class="keyword">file</span> | <span class="keyword">sort</span> | uniq -c</span></pre></td></tr></table></figure>

<p><strong>查找目录中的py文件，删掉所有行级注释</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span> ./ -name <span class="string">"*.py"</span> | xargs sed  -<span class="built_in">i</span>.bak <span class="string">'/^[ ]*#/d'</span></span></pre></td></tr></table></figure>

<p><strong>查看第5-7行和10-13行</strong></p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">sed -n -e '<span class="number">5</span>,<span class="number">7</span>p' -e '<span class="number">10</span>,<span class="number">13</span>p' file</span></pre></td></tr></table></figure>

<p><strong>仅输出ip地址</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">ip<span class="built_in"> route </span>show | sed -n <span class="string">'/src/p'</span> | sed -e <span class="string">'s/  */ /g'</span> | cut -d<span class="string">' '</span> -f9</span></pre></td></tr></table></figure>

<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>本文配合<a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&mid=2650518612&idx=1&sn=125c2cb9ee6d76a6817fb0ebc5a3c5e4&scene=21#wechat_redirect" target="_blank" rel="noopener">《Linux生产环境上，最常用的一套“vim“技巧》</a><br>一文，查看更佳，你会发现很多相似的东西，这和<code>KISS</code>原则是密不可分的。<br>sed还有一个精华就是<code>x</code>(Exchange)命令，但也属于高级功能。有些你可能在很多Makefile里见过了。sed甚至还可以写推箱子游戏，虽然代码很酷，但，脑回路完全不够用啊。</p>
<blockquote>
<p>作者：小姐姐养的狗</p>
<p>来源：<a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650519751&amp;idx=1&amp;sn=adef39cb108277731608069960692c77&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650519751&amp;idx=1&amp;sn=adef39cb108277731608069960692c77&amp;scene=21#wechat_redirect</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux技术</category>
      </categories>
      <tags>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令：awk技巧</title>
    <url>/2019/12/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%9Aawk%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>敢用自己的名字做软件名字的，都有非常强大的自信。比如，垠语言什么的。<br><code>awk</code>的命名得自于它的三个创始人姓别的首字母，都是<code>80来岁</code>的老爷爷了。当然也有四个人的组合：流行的GoF设计模式。但对于我这游戏爱好者来说，想到的竟然是三位一体，果然是不争气啊。<br>它长的很像C，为什么这么有名，除了它强大的功能，我们姑且认为<code>a</code>这个字母比较靠前吧。<code>awk</code>比<code>sed</code>简单，它更像一门编程语言。</p>
<a id="more"></a>

<h1 id="打印某一列"><a href="#打印某一列" class="headerlink" title="打印某一列"></a>打印某一列</h1><p>下面，这几行代码的效果基本是相同的：打印文件中的第一列。</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta">#Java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.println(aStr.split(<span class="string">" "</span>)[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#Python</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(aString.split(<span class="string">" "</span>)[<span class="number">0</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#cut 命令</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cut -d <span class="string">" "</span> -f1   file</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#awk命令</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">awk <span class="string">'&#123;print $1&#125;'</span> file</span></pre></td></tr></table></figure>

<p>这可能是awk最常用的功能了：<strong>打印文件中的某一列</strong>。它智能的去切分你的数据，不管是<code>空格</code>，还是<code>TAB</code>，大概率是你想要的。<br>对于csv这种文件来说，分隔的字符是<code>,</code>。AWK使用<code>-F</code>参数去指定。以下代码打印csv文件中的第1和第2列。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">awk</span> -F <span class="string">","</span>  <span class="string">'&#123;print <span class="variable">$1</span>,<span class="variable">$2</span>&#125;'</span> file</span></pre></td></tr></table></figure>

<p>由此，我们可以看出一个基本的awk命令的组成部分。<br><img src="http://image.winrains.cn/2019/08/20190829100428-4bf32.jpeg" alt="http://image.winrains.cn/2019/08/20190829100428-4bf32.jpeg"></p>
<blockquote>
<p><strong>一般的开发语言，数组下标是以0开始的，但awk的列<code>$</code>是以<code>1</code>开始的，而<code>0</code>指的是原始字符串。</strong></p>
</blockquote>
<h1 id="网络状态统计"><a href="#网络状态统计" class="headerlink" title="网络状态统计"></a>网络状态统计</h1><p>本小节，采用awk统计netstat命令的一些网络状态，来看一下awk语言的基本要素。netstat的输出类似于：<br><img src="http://image.winrains.cn/2019/08/20190829100429-f24aa.jpeg" alt="http://image.winrains.cn/2019/08/20190829100429-f24aa.jpeg"><br>其中，第6列，标明了网络连接所处于的网络状态。我们先给出awk命令，看一下统计结果。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">netstat</span>  <span class="string">-ant |</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">awk</span> <span class="string">' \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">BEGIN&#123;print</span>  <span class="string">"State","Count" &#125;  \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">/^tcp/</span> <span class="string">\</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">&#123;</span> <span class="string">rt[$6]++ &#125; \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">END&#123;</span>  <span class="string">for(i in rt)&#123;print i,rt[i]&#125;  &#125;'</span></span></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">State</span> <span class="string">Count</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">LAST_ACK</span> <span class="string">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">LISTEN</span> <span class="string">64</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">CLOSE_WAIT</span> <span class="string">43</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">ESTABLISHED</span> <span class="string">719</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">SYN_SENT</span> <span class="string">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">TIME_WAIT</span> <span class="string">146</span></span></pre></td></tr></table></figure>

<p>下面这张图会配合以上命令详细说明，希望你能了解awk的精髓。<br><img src="http://image.winrains.cn/2019/08/20190829100430-463b7.jpeg" alt="http://image.winrains.cn/2019/08/20190829100430-463b7.jpeg"><br>乍一看，好吓人的命令，但是很简单。awk和我们通常的程序不太一样，它分为四个部分。<br>1、<strong>BEGIN 开头部分</strong>，可选的。用来设置一些参数，输出一些表头，定义一些变量等。上面的命令仅打印了一行信息而已。<br>2、<strong>END 结尾部分</strong>，可选的。用来计算一些汇总逻辑，或者输出这些内容。上面的命令，使用简单的for循环，输出了数组rt中的内容。<br>3、<strong>Pattern 匹配部分</strong>，依然可选。用来匹配一些需要处理的行。上面的命令，只匹配tcp开头的行，其他的不进入处理。<br>4、<strong>Action 模块</strong>。主要逻辑体，按行处理，统计打印，都可以。</p>
<blockquote>
<p><strong>注意点</strong><br>1、awk的主程序部分使用单引号‘包围，而不能是双引号<br>2、awk的列开始的index是0，而不是1</p>
</blockquote>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>我们从几个简单的例子，来看下awk的作用。<br>1、输出Recv-Q不为0的记录</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">netstat</span> -ant | awk <span class="string">'<span class="variable">$2</span> &gt; 0 &#123;print&#125;'</span></span></pre></td></tr></table></figure>

<p>2、外网连接数，根据ip分组</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">netstat</span> -ant | awk <span class="string">'/^tcp/&#123;print <span class="variable">$4</span>&#125;'</span> | awk -F: <span class="string">'!/^:/&#123;print <span class="variable">$1</span>&#125;'</span> | sort | uniq -c</span></pre></td></tr></table></figure>

<p>3、打印RSS物理内存占用</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">top -b -n <span class="number">1</span> | awk 'NR&gt;<span class="number">7</span>&#123;rss+=$<span class="number">6</span>&#125;END&#123;print rss&#125;</span></pre></td></tr></table></figure>

<p>4、过滤（去掉）空白行</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">awk <span class="string">'NF'</span> <span class="keyword">file</span></span></pre></td></tr></table></figure>

<p>5、打印奇数行</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">awk <span class="comment">'a=!a' file</span></span></pre></td></tr></table></figure>

<p>6、输出行数</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">awk <span class="string">'END&#123;print NR&#125;'</span> <span class="keyword">file</span></span></pre></td></tr></table></figure>

<p>这些命令，是需要了解awk的一些内部变量的，接下来我们来介绍。</p>
<h1 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h1><h2 id="FS"><a href="#FS" class="headerlink" title="FS"></a>FS</h2><p>下面的两个命令是等价的 。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">awk -F ':'  '&#123;<span class="keyword">print</span> <span class="variable">$3&#125;</span>' <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">awk 'BEGIN&#123;FS=<span class="string">":"</span>&#125;&#123;<span class="keyword">print</span> <span class="variable">$3&#125;</span>' <span class="keyword">file</span></span></pre></td></tr></table></figure>

<p><strong>BEGIN块中的<code>FS</code>，就是内部变量，可以直接指定或者输出。</strong>如果你的文件既有用<code>,</code>分隔的，也有用<code>:</code>分割的，FS甚至可以指定多个分隔符同时起作用。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">FS</span>=<span class="string">"[,:|]"</span></span></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>OFS</strong> 指定输出内容的分割符，列数非常多的时候，简化操作。相似命令：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">awk -F ':' '&#123;<span class="keyword">print</span> <span class="variable">$1</span>,<span class="string">"-"</span>,<span class="variable">$2</span>,<span class="string">"-"</span>,<span class="variable">$4&#125;</span>' <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">awk 'BEGIN&#123;FS=<span class="string">":"</span>;OFS=<span class="string">"-"</span>&#125;&#123;<span class="keyword">print</span> <span class="variable">$1</span>,<span class="variable">$2</span>,<span class="variable">$4&#125;</span>' <span class="keyword">file</span></span></pre></td></tr></table></figure>

<p><strong>NF</strong> 列数。非常有用，比如，过滤一些列数不满足条件的内容。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">awk -F, <span class="string">'&#123;if(NF==3)&#123;print&#125;&#125;'</span> <span class="keyword">file</span></span></pre></td></tr></table></figure>

<p><strong>NR</strong> 行号，例如，下面两个命令是等价的。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cat</span> -<span class="keyword">n</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">awk '&#123;<span class="keyword">print</span> NR,<span class="variable">$0&#125;</span>' <span class="keyword">file</span></span></pre></td></tr></table></figure>

<p><strong>RS</strong> 记录分隔标志<br><strong>ORS</strong> 指定记录输出的分隔标志<br><strong>FILENAME</strong> 当前处理的文件名称，在一次性处理多个文件时非常有用</p>
<h2 id="编程语言特性"><a href="#编程语言特性" class="headerlink" title="编程语言特性"></a>编程语言特性</h2><h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><p>从上面的代码可以看出，awk可以做一些简单的运算。它的语言简洁，不需要显示的定义变量的类型。<br>比如上面的<code>rt[$6]++</code>，就已经默认定义了一个叫做rt的hash(array?)，里面的key是网络状态，而value是可以进行运算的(+-*/%)。<br>包含一些内置的数学运算（有限)</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">log</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">sqrt</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">exp</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">sin</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">cos</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">atan2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">rand</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">srand</span></span></pre></td></tr></table></figure>

<h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><p>类似其他语言，awk也内置了很多字符串操作函数。它本来就是处理字符串的，所以必须强大。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">length</span><span class="params">(str)</span></span> #获取字符串长度</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">split</span><span class="params">(input-string,output-array,separator)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">substr</span><span class="params">(input-string, location, length)</span></span></span></pre></td></tr></table></figure>

<h3 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h3><p>awk是个小型的编程语言，看它的基本语法，如果你需要复杂一点的逻辑，请自行深入了解，包括一些时间处理函数：</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line"># logic</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">if</span>(<span class="meta">x</span>=a)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">if</span>(<span class="meta">x</span>=a)&#123;&#125;<span class="meta">else</span>&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">while</span>(<span class="meta">x</span>=a)&#123;break;<span class="meta">continue</span>;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">do</span>&#123;&#125;<span class="meta">while</span>(<span class="meta">x</span>=a)</span></pre></td></tr><tr><td class="code"><pre><span class="line">for(;;)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"># <span class="meta">array</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">arr[<span class="meta">key</span>] = value</span></pre></td></tr><tr><td class="code"><pre><span class="line">for(<span class="meta">key</span> <span class="meta">in</span> arr)&#123;arr[<span class="meta">key</span>]&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">delete</span> arr[<span class="meta">key</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">asort(arr) #简单排序</span></pre></td></tr></table></figure>

<p>据说，awk可以胜任所有的文本操作。因为它本身就是一门语言啊。</p>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>曾经使用awk编写过复杂的日志处理和统计程序。虽然比写<code>sed</code>舒畅了很多，但还是备受煎熬。更加上现在有各种nawk,gawk版本之间的区别，所以业务复杂度一增长，就习惯性的转向更加简洁、工具更全的python。<br>awk处理一些简单的文本还是极其方便的，最常用的还是打印某一列之类的，包括一些格式化输出。对于awk，要简单的滚瓜烂熟，复杂的耳熟能详，毕竟有些<code>大牛</code>，就喜欢写这种脚本呢。</p>
<blockquote>
<p>作者：小姐姐养的狗</p>
<p>来源：<a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650519843&amp;idx=1&amp;sn=fe4a5c405a35b42a850054eb4283ff40&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650519843&amp;idx=1&amp;sn=fe4a5c405a35b42a850054eb4283ff40&amp;scene=21#wechat_redirect</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux技术</category>
      </categories>
      <tags>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud核心组件</title>
    <url>/2019/12/26/Spring-Cloud%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>邻国相望，鸡犬之声相闻，民至老死不相往来。这个世界被小诸侯给切的七零八落，一锅乱麻。<br>而现实是，我的国家因为常年打仗，剩下的女人很多，需要打通远嫁他方的通道；而A国盛产长得和猪一样大的耗子，卖的很好。它们可以做成皮大氅，用来取暖。所以交流是在所难免的。<br>现实是这样的：<br>一、A国不知道B国身处何方，经常有牧民捧着藏宝图一样的破布，葬身在崎岖的山路上。<br>二、B国听不懂C国含糊不清的吐词，感觉他们在求救，等跑近一看，却发现其实是在骂娘。<br>三、C国生产的南瓜就知道卖给D国，剩下的都烂在了地里，E国都开始吃树皮了。<br>四、F国倒是远近闻名，但四面八方蜂拥而至的难民，让他们非常苦恼。其中，G国的难民，最是恶劣。<br>五、曾有其他大陆板块的使者，5年不得要领。见神粥大地现状，作诗一首：《真TM乱》。<br>作为一个穿越者，一个怜悯众生的剩人。我要留给这个世界一张蓝图，好让后人记住我的名字：xjjdog。同时，我也想起了，我为什么有这种这种强大的自信。<br>”回忆“的片段将我带回到21世纪。</p>
<a id="more"></a>

<h1 id="一、我要聊点技术了：单体应用"><a href="#一、我要聊点技术了：单体应用" class="headerlink" title="一、我要聊点技术了：单体应用"></a>一、我要聊点技术了：单体应用</h1><p>我们刚开始的服务，其实并没有那么复杂。我只有一台配置非常低的机器，我的应用，我的代码，我的聪明才智，全部在这一个小小的工程里面。由于我是搞it的，所以我的项目名字就叫<code>jisuanji</code>。有人说我用中文拼音做项目名，太那个。我不听，我就是这么命名。我还把公共模块叫<code>gg</code>，密码字段叫<code>mm</code>，谁管得着呢。<br>对，看下面的图，就是这么简单。项目能活到用nginx来做负载均衡这一步，就算是小成功了。<br><img src="http://image.winrains.cn/2019/08/20190829101552-5f8aa.png" alt="http://image.winrains.cn/2019/08/20190829101552-5f8aa.png"><br>这个时候，所有的代码就是一个整体，用户访问什么，我直接给就是。</p>
<h1 id="二、我拆成了两个服务"><a href="#二、我拆成了两个服务" class="headerlink" title="二、我拆成了两个服务"></a>二、我拆成了两个服务</h1><p>可能是我和我一样二的人有点多，我的项目访问量越来越大，这也许就叫臭味相投吧。我自己的开发速度，已经追不上头脑里的idea，是时候招个人对服务进行拆分了。<br>不能拆的太过火，所以刚开始，我把<code>jisuanji</code>拆成了两个服务。其中的服务B，仅仅部署了一个节点，因为它的压力还不是太大。即使这样，我不得不买上3台服务器来部署服务节点，真是肉痛。我这么抠门的人，数据库当然也是共用的。虽然有时候机器压力有点大，但暂时还死不了人。<br><img src="http://image.winrains.cn/2019/08/20190829101553-259b6.png" alt="http://image.winrains.cn/2019/08/20190829101553-259b6.png"><br>这个时候我就面临了一个选择问题：服务A要怎么访问服务B呢？<br>由于我搞过一段时间的webservice，首先就想到了它。但这玩意太重了，我还不如通过Http访问来的舒爽。通过HttpClient，或者OkHttp，我的服务A，现在可以直接模拟Http请求访问服务B了。<br>当团队里有第二个人，就开始吐槽我的项目了。以下是他罗列的，我的项目的罪状：1、复杂度太高，代码严重耦合；2、技术债务多，拍脑袋需求一箩筐；3、代码不规范，一坨屎；4、技术创新难，一个类几千行…<br>至于么？从一个服务拆成两个，就这么吐槽我。不过为了以后能拆出成百上千个服务，这口气我暂时忍了，毕竟我这人还是比较虚心的。</p>
<h1 id="三、乱成一锅粥了"><a href="#三、乱成一锅粥了" class="headerlink" title="三、乱成一锅粥了"></a>三、乱成一锅粥了</h1><p>等过去半年一看，好家伙，服务给我拆了了几十个。当我的同伴把系统结构图拿给我看，我直接懵逼了。我挑了9个能看的服务，画了张图。<br><img src="http://image.winrains.cn/2019/08/20190829101553-e20ea.jpeg" alt="http://image.winrains.cn/2019/08/20190829101553-e20ea.jpeg"><br>首先进行了业务拆分。比如支付业务，订单业务，用户中心，商品中心等，都组建了独立的团队。每个业务又进行了细分，拆分成不同的服务。<br>在这之间，进行了下面的改动：<br>一、有小伙伴写了个通用的HttpClient调用组件，自己的负载均衡策略。<br>二、有另外一个小伙伴，习惯protobuf，所以选了gRPC。<br>三、事实证明SOA还是有市场的，这不，就有几个服务的交互引入了webservice。<br>四、有人想要用RMI，被我及时发现、否决，腹死胎中了。<br>五、每次建个新服务，都需要更新一下excel，然后将这个excel周知出去。<br>现在的整个系统，简直是个四不像。什么通信方式都有，什么交互格式都不缺。拿最要命的D服务来说，光通讯模块，就引入了20几个jar包。如果应用扩展到上千个…My god…<br>更要命的是，这么多服务，每次上线一个模块都胆战心惊，因为它不知道到底会有什么连锁反应。<br>是时候叫出超级飞侠了。哦不，叫出微服务了。</p>
<h1 id="四、微服务来袭"><a href="#四、微服务来袭" class="headerlink" title="四、微服务来袭"></a>四、微服务来袭</h1><p>目前，最火的微服务框架，就是SpringCloud了。虽然netflix公司对某些组件的维护经常爽约，但有些核心组件还是非常经典的。</p>
<h2 id="1、注册中心：Eureka"><a href="#1、注册中心：Eureka" class="headerlink" title="1、注册中心：Eureka"></a>1、注册中心：Eureka</h2><p>服务A，怎么找到服务B，有很多种方式。比如你生活在一个小镇上，你问xjjdog是谁，老王可能认识他，但小李可能并不知晓；但小李认识老王，所以通过他最终也能找到xjjdog，只不过麻烦一些。<br>你可以随便拉小镇上的一个人，来问xjjdog是谁。你还会变戏法一样拿出一个小本本，把你认识的人，都告诉他们。当你脑残式的问了一个遍，到最后所有人都知道xjjdog了。<br>上面说的就是gossip协议。最终，你们都能够知道彼此，因为都是大嘴巴。比如小郑生了个孩子，过不了多少时间，全镇子的人都把这个孩子记录在本子上了。<br>用这种方式，服务都能够知道彼此，完成通信。</p>
<hr>
<p>可惜这并不美好，从小镇的东头跑到西头，需要很长时间。在这个时间里，小郑刚生的孩子可能因为先天疾病夭折了。我们需要一种信息集中度和实效性更高的方式。<br><strong>这就需要一个中心，那里的信息就是权威。</strong> 在SpringCloud体系中，最常用的注册中心就是Eureka。任何服务启动以后，都会把自己注册到Eureka的注册表中；当服务死亡的时候，也会通知Eureka。<br><img src="http://image.winrains.cn/2019/08/20190829101553-38112.jpeg" alt="http://image.winrains.cn/2019/08/20190829101553-38112.jpeg"><br>这样，当服务A想要找服务B的时候，只需要问一下Eureka Server就可以了，它什么都知道。<br>为了达到这个目的，还是要有一部分工作量的。且看下图。这个注册动作，是由一个叫做Eureka Client的组件来完成的。服务启动和关闭的时候，会通过这个组件推销自己；而当服务A想要调用服务B的时候，直接问Eureka Server就可以了。服务A拿到结果后，会把结果缓存在本地的注册表里。<br>你可以认为是一个拷贝。所以Eureka Server死掉后，并不影响服务A找到服务B。<br><img src="http://image.winrains.cn/2019/08/20190829101553-1da0e.jpeg" alt="http://image.winrains.cn/2019/08/20190829101553-1da0e.jpeg"></p>
<h2 id="2、负载均衡组件：Ribbon"><a href="#2、负载均衡组件：Ribbon" class="headerlink" title="2、负载均衡组件：Ribbon"></a>2、负载均衡组件：Ribbon</h2><p>现在问题来了。服务A拿到服务B的实例列表以后，发现有两台。</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">10.0.0.12</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">10.0.0.16</span></span></pre></td></tr></table></figure>

<p>接下来麻烦了，该调哪台机器呢？这就是SpringCloud中组件Ribbon的作用。其实<code>Round Robin</code>是一个通用的计算机术语。它是最常用的负载均衡策略，请求会均匀的分配给后面的每台服务器。<br>Ribbon工作时，会做下面四件事：<br>1、优先选择在一个Zone且负载较少的Eureka Server，进行连接。<br>2、定期从Eureka更新、过滤服务和实例列表。<br>3、根据负载均衡策略，从注册表中选择一个真正的实例地址。<br>4、通过RestClient对服务发起调用。<br><img src="http://image.winrains.cn/2019/08/20190829101553-68ea9.jpeg" alt="http://image.winrains.cn/2019/08/20190829101553-68ea9.jpeg"><br>可以看到，Ribbon背后，还是采用的Http协议进行交互。看以下代码，就可以直接实现对远端服务的调用。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@LoadBalanced</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">RestTemplate restTemplate()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">RestTemplate</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="code"><pre><span class="line"> @<span class="selector-tag">Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="selector-tag">RestTemplate</span> <span class="selector-tag">restTemplate</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">String</span> <span class="selector-tag">test</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">restTemplate</span><span class="selector-class">.getForObject</span>(<span class="string">"http://test-service/test"</span>, String.class);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Ribbon的Filter会查找<code>test-service</code>，并替换成相应的实例地址。<br><img src="http://image.winrains.cn/2019/08/20190829101554-51598.jpeg" alt="http://image.winrains.cn/2019/08/20190829101554-51598.jpeg"><br><strong>策略</strong><br>Ribbon不仅仅提供了轮询的策略，还有其他的，比如：<br>1、随机Random<br>2、根据响应时间加权<br>3、自定义<br>拿轮询来说，最终的选择逻辑就在RoundRobinRule类中。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> increment<span class="constructor">AndGetModulo(<span class="params">int</span> <span class="params">modulo</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (;;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">int</span> current = nextServerCyclicCounter.get<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">int</span> next = (current + <span class="number">1</span>) % modulo;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (nextServerCyclicCounter.compare<span class="constructor">AndSet(<span class="params">current</span>, <span class="params">next</span>)</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="3、为简化代码而生：Feign"><a href="#3、为简化代码而生：Feign" class="headerlink" title="3、为简化代码而生：Feign"></a>3、为简化代码而生：Feign</h2><p>可以看到，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。而且返回类型不安全，也表达不出什么语义。<br>其实，通过Ribbon方式，已经能够完成微服务之间的调用了。但SpringCloud的开发语言是Java，肯定要进行更加高级的封装，才能体现它的逼格。<br>Feign得益于Java的动态代理机制，最终封装出一套简洁的接口调用方式，将需要调用的其他服务的方法定义成抽象方法即可，不需要自己构建http请求。<br><img src="http://image.winrains.cn/2019/08/20190829101554-1cf4b.jpeg" alt="http://image.winrains.cn/2019/08/20190829101554-1cf4b.jpeg"><br>首先，Feign会根据@FerignClient注解，通过动态代理，创建一个动态代理类。接下来，你只要通过调用接口的方式，就可以构造上面提到的Ribbon调用参数，这个过程会自动填充。最后，通过构造的Ribbon请求，发起真正的调用，并通过反射组装返回值。<br>所以，Feign只是一层皮，最终还是要通过Ribbon进行调用。在我看来，把Ribbon和Feign合成一个组件，也是合理的。<br>它们有一个比较通用的名词，就叫做RPC（远程调用）。</p>
<h2 id="4、异常的保护伞：断路器"><a href="#4、异常的保护伞：断路器" class="headerlink" title="4、异常的保护伞：断路器"></a>4、异常的保护伞：断路器</h2><p>下面以一个支付请求为例，说一下不是风平浪静的情况下，服务会有什么反应。<br>每一个真正的支付请求，都会调用其他四个服务。首先，使用鉴权服务，获取用户的支付权限；然后，风控服务会做一些规则验证；为了更好的推销产品，会调用营销业务，获取一些推荐信息；最后，调用聚合支付服务，进行真正的支付。<br>其中，营销业务其实是可有可无的。让用户首先把钱花出去，是我们的首要任务。<br>考虑下面一种场景，营销业务由于系统故障或者负载问题，发生了大面积的不可用或者超时。然后，所有的请求都卡在了获取营销信息的代码上。<br>如图所示，鉴权和风控都已经通过了。因为一个旁路功能：营销业务，导致真正的支付无法进行。这个时候，如果有人调用支付请求，会发现支付请求也完蛋了。<br>因为它们最终都卡在了营销这一段小代码上。<br><img src="http://image.winrains.cn/2019/08/20190829101554-1f5f1.jpeg" alt="http://image.winrains.cn/2019/08/20190829101554-1f5f1.jpeg"><br>所以，对于营销业务这种不是链路上必备的服务提供者，要有一个手段，让它在发生问题的时候，隔离它一段时间。<br>负责这个功能的组件，就叫做Hystrix。<br>以我们编程的思维来说，这就是个if条件。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(服务发生问题) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="string">"暂时不要处理"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>但我们不能这么编码在业务代码里。所以Hystrix对每个服务开了一个线程池，并有比较复杂的规则，来控制这些出问题的服务的行为。比如，在2分钟内，直接返回营销业务的默认结果，而不是一直卡在那里。<br>这个过程，就叫熔断。就像电源一样，出了问题，先切断保险丝，别把电器给烧了。</p>
<h2 id="5、此网关非彼网关：zuul"><a href="#5、此网关非彼网关：zuul" class="headerlink" title="5、此网关非彼网关：zuul"></a>5、此网关非彼网关：zuul</h2><p>API网关是一个反向的<code>路由</code>，它屏蔽了内部的细节，为调用者提供了统一的入口。网关，其实是一堆<code>过滤器</code>的几何，可以实现一系列和业务无关的横切面功能。<br>熟悉Spring的都知道AOP，路由的一个功能，就是针对于分布式服务的一个AOP。<br>还是先说下网关的职责吧。简单罗列几个：<br>1、安全认证。提供统一的认证方式和鉴权功能，避免重复开发。<br>2、熔断，限流。针对问题服务，进行熔断操作；对流量进行预估，限制访问。<br>3、日志监控。统一流量入口，进行流量分析和监控。<br>4、屏蔽内部细节，对外提供一致的接口。<br>5、实现灰度。使用自定义策略实现分流，达到测试的目的。<br>网关的位置，大体就如下图。<br><img src="http://image.winrains.cn/2019/08/20190829101554-b8b41.jpeg" alt="http://image.winrains.cn/2019/08/20190829101554-b8b41.jpeg"><br>可以看到，我们平常用的nginx，就可以当作网关。但对于微服务来说，nginx的配置实在是太麻烦了。不是说nginx功能不够强大，而是因为它们不是一个体系的，就存在整合成本（比如kong）。<br>zuul就不一样了，它和SpringCloud的其他组件，是一家子的。一家子的，当然会特殊照顾。Zuul本身就是一个Servlet，外部请求经过一系列Filter后，会达到真正的服务。上面说的熔断器，就是高度集成的。</p>
<h2 id="6、一张聚合图"><a href="#6、一张聚合图" class="headerlink" title="6、一张聚合图"></a>6、一张聚合图</h2><p>有了上面关键组件，事情就明了的多了。我们把它放在一张图中，就是下面的样子。<br><img src="http://image.winrains.cn/2019/08/20190829101554-64356.png" alt="http://image.winrains.cn/2019/08/20190829101554-64356.png"><br>我们将其简化一下，就可以得到一张更简洁的图。可以看到，只需要3个关键点：<br>1、服务注册中心，统一管理所有服务的信息，默认组件是Eureka。<br>2、RPC，网络通信组件，服务A怎么调用服务B。在SpringCloud中，就是Ribbon+Feign。<br>3、网关，拆分的服务怎么暴露接口，最终见人的样子。默认组件是Zuul。<br><img src="http://image.winrains.cn/2019/08/20190829101554-df043.png" alt="http://image.winrains.cn/2019/08/20190829101554-df043.png"></p>
<h1 id="征途"><a href="#征途" class="headerlink" title="征途"></a>征途</h1><h2 id="一点道理"><a href="#一点道理" class="headerlink" title="一点道理"></a>一点道理</h2><p>处理杂乱无章的事情，最有效的途径，就是集权和中心化。集权和中心化的核心就是授权或者认同，否则注定失败。授权是对上，各位当权者应该同意我的做法，所以我需要用及其易懂的语言，去说服他们接受这个体系；认同，是对下，最好是从人民的抱怨声中，出具的改善措施，所以要权威专业。<br>和微服务一样，需要给一些陈旧的概念，强行赋予看起来比较自然的新意义。比如我把统一语言，叫做文化融合，就显得高大上一些。<br>第二个，就是把职责拆的足够细。够细才能够精，每个位置上的人才能各司其职。<br>还有一点，整个过程，要能够系统化，能够进行推演。如果一件事有着不可预料的后果，那是冒险家干的事情。</p>
<h2 id="一些途径"><a href="#一些途径" class="headerlink" title="一些途径"></a>一些途径</h2><p>为了对世界进行初步的了解，我成立了资源统计部，对山川河流进行了初步的勘查，绘制出有章可循的地图。对社会的现状和错综复杂的关系进行了摸底。我把这些信息出版成图书，遭到藏宝图收藏者们的嫉妒和憎恶。他们躲藏在不为人知的角落，龌龊行事。<br>我还选了一个自己觉得好听的方言，统一了每个诸侯国的语言。在推行的过程中，多次受到土著们强烈的反对，拒不改正。被我强行斩首了几个之后，以后的推行，就快的多了。<br>对于所有的重要商品，进行了集中管控。这个世界贵重的不是黄金，而是食物，所以我还修建了四通八达的道路和无孔不入的交易中心。从此之后，很少饿死过人。由于这部分是在我的控制范围内，所以进行的很顺畅。<br>G国的民风比较彪悍，经常发生暴力事件。这也难免，从刚开始，这个国家就难以驯化。好在缺了他们，这个系统也能循环的下去。前不久G国又发生了重大的事件，所有其他国家联合抵制，禁止G国国民入境。但时间是化解伤痛的良药，我估计这样的限制不会持续很久。<br>但糟粕还是有的。有人的地方，就有江湖，就有压迫。但这样的糟粕我是不想让其他人看到的。来访的使者，应该只能够看到歌舞升平、安居乐业，这注定了不能让他们和底层接触，否则就发现金玉其外败絮其中的现状了。<br>他们和外交官打的不亦乐乎，我很欣慰。</p>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>我清楚的知道，为了建立一个和谐自然的系统，曾经花费了多大的代价。这其中的组成部分，并不能总是完美无缺的运行。而且，在这个看似平和的整体上，就滋生了其他无数令人头痛的问题 ，不过这是另外一个话题了。<br>就是这样。我所做的一切，我所有的期望，只不过是为了：当新的机会在我身后，我能够从容的、华丽的转身。<br>这就是我为了有一天能够穿越，所做的准备。</p>
<blockquote>
<p>作者：小姐姐养的狗</p>
<p>来源：<a href="https://mp.weixin.qq.com/s/hjYAddJEqgg3ZWTJnPTD9g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/hjYAddJEqgg3ZWTJnPTD9g</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring Cloud</category>
      </categories>
  </entry>
  <entry>
    <title>微服务只是特定领域的子集</title>
    <url>/2019/12/26/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8F%AA%E6%98%AF%E7%89%B9%E5%AE%9A%E9%A2%86%E5%9F%9F%E7%9A%84%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<p>大家都在学SpringCloud，貌似学会了SC就牛逼哄哄，感觉不得了的样子。但微服务，在整个企业级应用中，只占了一小部分。微服务引入的问题比解决的问题还要多，你会遇到各种各样的bottleneck。<br>微服务解决的是计算节点的问题，然而根源却在存储节点。当业务规模变得越来越庞大，存储、编码、管理都会成为问题。<br>接下来我们谈一些放之四海而皆准的道理，不需要贴上”XX公司最佳实践”之类的标签。</p>
<a id="more"></a>

<p>下面是一张因数据扩张引出的微服务相关的图，简约但不简单。中小型公司只要有这些元素，就能玩的很好；大点的公司，因为规模太大，每个组件都会遇到瓶颈，所谓的专项的优化并不能脱离它的本质。<br>那我们开始。</p>
<blockquote>
<p>注意，这张图仅是主要数据路径，一个子集，其他的包括CDN、通讯层等，不在此列。</p>
</blockquote>
<p><img src="http://image.winrains.cn/2019/08/20190829102103-1918a.jpeg" alt="http://image.winrains.cn/2019/08/20190829102103-1918a.jpeg"><br>这张图并不包含某个特定领域的具体架构，属于一个整体性的概括。我们从数据库容量的瓶颈说起，看一下微服务在其中的比重。</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>用户数据要存储，就存在数据库。过去这么多年，NoSQL并不能消除开发人员的恐惧，所以，MySQL之类还是大多数公司的首选存储。<br>假设你的业务增长的很好，这个就有意思多了。项目开始，你的sql玩的越6，那么给后人埋的坑，越多。因为sql的功能太丰富了，一不小心，就炫技了。你会发现，林子越大，对sql的规范要求越高。一些官宣的特性，在公司内是严格禁止的。<br>市场发展很好，终于来报应了。以前的技巧变成了现在的累赘。慢查询、全文扫描，招招毙命。想要加缓存，结果发现无从下手；想要分库分表，结果发现表关系错综复杂。</p>
<h2 id="小表和宽表"><a href="#小表和宽表" class="headerlink" title="小表和宽表"></a>小表和宽表</h2><p>所以第一步，还是得去填坑。一个超过3个表的联合查询业务，大概率是不合理的。在加缓存和分库分表之前，还是得重新设计一下数据表。<br>忘掉什么数据库范式，我们将存在两类表：小表和宽表。<br>小表提供了最基本的数据，可能一个简单的KV就完成了。一些联合查询，是直接可以在程序里进行循环拼接的。程序里循环1000次10毫秒的查询，比单次查询耗费6秒要强的多。这就是分布式系统的特点，小耗时的批量查询，比hang在那里更加有生命力。<br>宽表通过冗余的方式，提供了某个重要功能常用的分析数据。这种表的字段一般都特别多，在写入时通过拼接获取冗余数据，一般用在读多写少的场景。<br>完成了这一步，接下来的工作才能进行。<br><img src="http://image.winrains.cn/2019/08/20190829102103-da4b8.jpeg" alt="http://image.winrains.cn/2019/08/20190829102103-da4b8.jpeg"></p>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>在<a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&mid=2650519118&idx=1&sn=fc4b92154cb9ab6dcec5b5544c6274aa&scene=21#wechat_redirect" target="_blank" rel="noopener">《“分库分表” ？选型和流程要慎重，否则会失控》</a>中，详细的说明了分库分表的选型，这里浅谈一下过程。<br>分库分表很可能会引入某一种中间件，因为仅仅将数据库分开还不行。HA，FailOver等特性，是同时需要的。<br>分库分为垂直分和水平分。垂直面向的是业务拆分，即将一部分表按照业务逻辑独立到其他库中；水平面向的是容量，即通过分库分表的模式使数据有一个扩张的途径。<br>数据一定要有一个可以度量的切分维度，否则就过于分散，或者过于倾斜，影响后续的处理。</p>
<h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><p>有分就有合，比如某些报表业务需要全量的数据。<br>不同业务通过共享数据库来共享数据不得不说是个非常蠢的主意。这个时候就需要一些数据同步工具。<br>数据同步组件可以说是一个公司的必备组件。有基于最后更新时间的高延迟同步工具，也有基于binlog的低延迟同步工具。有的公司为了稳定，还会有所谓的多机房同步。<br>数据同步最怕异常，因为大多数同步都有顺序性要求。一切运行良好的时候，大家皆大欢喜；一旦出现异常，就需要其他手段来保证异常期间的数据同步和延迟。<br>这都是些脏活，自动化有时候会适得其反，监控是第一位的。</p>
<h1 id="分层的数据存储"><a href="#分层的数据存储" class="headerlink" title="分层的数据存储"></a>分层的数据存储</h1><p>可以预见的是，即使你分库分表了，还是能很快达到瓶颈。分库分表后，你的一些统计功能可能还用不了了，在一些传统的管理系统上，这是硬伤。<br>一个分层的数据存储层是必要的。你的一些业务，可能一个分支走的是MySQL，换了另外一个条件就成了ES。<br>不同的DB做不同的事情。RDBMS只做原始数据的存储和查询，是扁平快的数据通道；特定的单机高性能DB，做一些汇聚和科学计算；分布式的类RT的存储，用来存储一些中等规模的数据，并提供一些中延迟的搜索功能；海量的存储系统，存储系统所有的历史记录，并提供离线分析功能。<br><img src="http://image.winrains.cn/2019/08/20190829102104-47af3.jpeg" alt="http://image.winrains.cn/2019/08/20190829102104-47af3.jpeg"><br>不要想着某一类存储解决所有的问题，那是骗人的。存储部分的复杂性不是普通的微服务能够相比的。<br>是谁保证了分层的数据存储设计呢？除了一部分通过MQ分发数据的业务，还是得靠我们的数据同步组件。</p>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>但DB的压力实在是太大了，我们不得不考虑缓存。缓存不能乱用，有两个原则：一个是缓存不能侵入业务，也就是不能带有业务逻辑；一个是缓存的命中率要高，否则适得其反。缓存是对高并发、高速接口的补充，是系统稳定性的必要不充分条件。<br>除了Redis等外置的缓存集群，jvm内缓存也是一个比较重要的场所。缓存的存在是因为I/O设备的缓慢，通常放在内存中，断电后即消失。<br>缓存涉及到源数据库和缓存数据库之间的数据同步。通常，更新源库时，会同时删掉缓存中相关的就数据，这样在下次读取的时候，能够读取到最新的数据。<br><img src="http://image.winrains.cn/2019/08/20190829102105-751f9.jpeg" alt="http://image.winrains.cn/2019/08/20190829102105-751f9.jpeg"><br>缓存限制最大的就是其容量问题，而且都贵的很。假如业务模式固定，一些kv存储使用LevelDB或者HBase等方案，会显著节约成本。</p>
<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>是时候将工程模块化了，毕竟上百个程序员共享一个代码库，风险已经很大了。<br>模块化通常会按照业务线进行拆分。比如，支付模块和报表模块的拆分。<br>模块拆分后，相似的模块会共享数据库。但更多的是通过冗余数据来解决，这样能将业务解耦，一部分出现问题，另一部分能够运行良好。好比你隔壁出了杀人案你第二天还能正常去上班。<br>模块之间要找到一种交互方式，比如使用HttpClient、OkHttp等。重要的是统一，统一了以后就有一个高大上的名字了：RPC。<br>一个小模块很有可能会发展为一个大的业务线，也有可能无人问津。<br><img src="http://image.winrains.cn/2019/08/20190829102106-adb82.jpeg" alt="http://image.winrains.cn/2019/08/20190829102106-adb82.jpeg"></p>
<h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><p>模块化之间另一种共享数据或者数据交互的方式就是MQ。除了有削峰等功效，MQ更多改变的是一种交互模式，一种对业务的解耦。<br>Kafka几乎每个公司都在用，最高能有几十万的吞吐量。RabbitMQ、RocketMQ等，更多用在可靠性要求非常高的场景，但比较耗机器。<br>MQ资源一般都要求绝对的高可靠，作为基础设施，一旦出问题，将带来非常大的事故。设计的时候要考虑异常情况下的数据处理流向，以及MQ恢复后的补偿策略。<br>MQ集群设计的比较小一些才合理，避免不同业务，不同可靠性级别的消息互相影响。MQ在业务上和功能上要相互隔离，做到最小服务集合。<br>为了避免MQ当机对正常业务产生影响，非重要链路上的MQ不能阻塞业务的正常进行，这种消息通常通过异步线程发送。</p>
<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><p>我们已经使用消息和模块化，将系统拆分成了多个工程。将这些工程使用统一的方式管理起来，统一其交互模式和在上面的治理，就是微服务的范畴。<br>微服务就是一个多模块项目规范化的过程。非规范的服务与微服务体系，是要共存一段时间的，如何保证新旧服务的替换，是一个管理上的问题。<br><img src="http://image.winrains.cn/2019/08/20190829102106-7252d.jpeg" alt="http://image.winrains.cn/2019/08/20190829102106-7252d.jpeg"></p>
<h2 id="功能组件"><a href="#功能组件" class="headerlink" title="功能组件"></a>功能组件</h2><p>根据SpringCloud的描述，一个服务想要被发现，需要将自己注册到通用的注册中心，其他服务可以从同一个地方，获取它的实例，进而调用。<br>而真正产生调用的功能，就是RPC的功能。RPC要考虑一系列比如超时、重拾、熔断等功能。在某些访问量非常大的节点，可能还要考虑预热。<br>RPC要能产生一些统计性数据，比如TPS、QPS、TP值等，很显然SpringCloud是缺乏的，我们要借助外部系统进行分析。<br>在外部请求流转到内部之前，需要经过一层网关的处理。像一些通用的操作，比如权限、限流、灰度等，就可以在网关层处理。<br><img src="http://image.winrains.cn/2019/08/20190829102106-c69d8.jpeg" alt="http://image.winrains.cn/2019/08/20190829102106-c69d8.jpeg"></p>
<h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h2><p>微服务最重要的特色就是其治理功能。服务治理的依据就是监控信息。通过统计每次调用的大小、耗时、分布，能够得出服务的大体拓扑。<br>通常以下信息最有用：<br>1、QPS，时间序列的qps分布，最高区间qps<br>2、平均响应时间，接口的平均响应时间，最大耗时和最小耗时<br>3、TP值分布，90%，99%等请求是在x耗时内完成<br>通过以上信息能够对服务进行画像。是扩容、缩容、专项治理的数据依据。<br>微服务引出的另外一个问题就是调用链，即某个请求的真实路径。分布式环境下的问题排查，会非常的困难，调用链能够帮助研发快速定位问题，并帮助理解业务的数据流向。<br>服务治理的目的就是找到不合理的请求和分布，比如某个接口耗时太长；某个接口请求量大，需要加缓存；某个功能依赖链条过长，需要业务优化等。<br>服务治理要借助大量的外部分析工具，更多通用的业务模型，需要大数据平台的支持。<br>我们把监控/报警也放在服务治理的部分，在<a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&mid=2650518678&idx=1&sn=8c8c9c40620b649cfb673ecef70a23f4&scene=21#wechat_redirect" target="_blank" rel="noopener">《这么多监控组件，总有一款适合你》</a>中，我们详细的讨论了监控部分的技术选择方案。</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p><img src="http://image.winrains.cn/2019/08/20190829102107-4e49e.jpeg" alt="http://image.winrains.cn/2019/08/20190829102107-4e49e.jpeg"><br>微服务产生的另外一个问题就是日志太过分散。一个核心的业务可能有上百个实例，你不可能打开100个终端去看日志。这就涉及到日志的收集。<br>日志归集功能就是把分散的日志集合到一个地方，它的主要挑战就是数据量。<br>通常日志分为两部分，一部分是全量的，可以通过定时同步等方式，备份到日志堡垒机或者hdfs中；一部分是过滤后的日志，比如一些异常信息，集中在某一个处理平台中进行报警。<br>很多研发喜欢将用户行为数据输出到日志文件中，这部分日志被收集后，会通过流计算或者离线计算，得到一些推荐和模型。日志信息进入了大数据处理的范畴，我们不过多描述。</p>
<h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><p>如果一个上点规模的公司，技术团队有什么值得一做的系统，那么发布系统算一个。<a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&mid=2650518647&idx=1&sn=8e616b6ff14d69d31db768a131b572c4&scene=21#wechat_redirect" target="_blank" rel="noopener">《发布系统有那么难么?》</a>中，谈了一种可能的模式。<br>发布系统就是给一堆脚本包了一张方便的皮。一些流程性工具、发布验证、CI/CD功能，很容易能够添加到自己的发布系统中。<br>很多微服务推广的文章中，谈到虚拟化（Docker）等，其实不是必须的。虚拟化减少了服务编排的时间，能够方便的进行扩容和缩容，但对监控、日志收集、网络拓扑等，要求比较高。建议是整个体系中的最后一步而不是第一步。<br>你的系统是否灵活，还与公司的文化环境相关。如果上个线走审批流程就需要一两周，那么做一个敏捷的持续集成系统就不是那么必要了。</p>
<h1 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h1><p>基础设施更多指的是运维体系，这是支撑整个系统健康发展的基石。我倾向于基础运维和基础架构不分家，因为它们的模式和文化，是一个公司研发环境的基石。<br><img src="http://image.winrains.cn/2019/08/20190829102107-6990d.jpeg" alt="http://image.winrains.cn/2019/08/20190829102107-6990d.jpeg"><br>另外一些基础组件，比如配置中心、调度中心、分布式锁管理等，都对可靠性有较高的要求。</p>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>这套体系看着简单，也有固定的解决方案。但问题就在于，许多公司从成立玩到倒闭，玩了那么多年，还是没玩明白。<br>真是可怜。</p>
<blockquote>
<p>作者：小姐姐养的狗</p>
<p>来源：<a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650519373&amp;idx=1&amp;sn=e3aeeb36137a8a20765ee6bfa902071c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650519373&amp;idx=1&amp;sn=e3aeeb36137a8a20765ee6bfa902071c&amp;scene=21#wechat_redirect</a></p>
</blockquote>
]]></content>
      <categories>
        <category>系统架构</category>
        <category>微服务</category>
      </categories>
  </entry>
  <entry>
    <title>WebSocket协议八问</title>
    <url>/2019/12/26/WebSocket%E5%8D%8F%E8%AE%AE%E5%85%AB%E9%97%AE/</url>
    <content><![CDATA[<p>WebSocket是一种比较新的协议，它是伴随着<code>html5</code>规范而生的，虽然还比较年轻，但大多主流浏览器都已经支持。它使用方便、应用广泛，已经渗透到前后端开发的各种场景中。<br>对http<code>一问一答</code>中二式流程的不满，催生了支持双向通信的<code>WebSocket</code>诞生。WebSocket是个<code>不太干净</code>协议。</p>
<hr>
<p><strong>本文包括以下内容：</strong><br>一、WebSocket协议只能浏览器发起么？<br>二、WebSocket和HTTP什么关系？<br>三、WebSocket和长轮询有什么区别？<br>四、如何创建一个连接？<br>五、如何处理数据？<br>六、如何使用Nginx做负载均衡？<br>七、java服务端怎么实现？<br>八、WebSocket能干些啥？</p>
<a id="more"></a>

<hr>
<h1 id="一、WebSocket协议只能浏览器发起么？"><a href="#一、WebSocket协议只能浏览器发起么？" class="headerlink" title="一、WebSocket协议只能浏览器发起么？"></a>一、WebSocket协议只能浏览器发起么？</h1><p>不是。目前此协议的受众的也不仅仅是web开发者。<br>WebSocket只是一种协议，它和http协议一样，使用<code>类似okhttp</code>的组件，可以在任何地方进行调用，甚至可以借助WebSocket实现<code>RPC</code>框架。<br><img src="http://image.winrains.cn/2019/08/32d70-20190829103016-beab0.jpeg" alt="http://image.winrains.cn/2019/08/32d70-20190829103016-beab0.jpeg"></p>
<h1 id="二、WebSocket和HTTP什么关系？"><a href="#二、WebSocket和HTTP什么关系？" class="headerlink" title="二、WebSocket和HTTP什么关系？"></a>二、WebSocket和HTTP什么关系？</h1><p>WebSocket和http一样，都是处于<code>OSI</code>模型中的最高层：<code>应用层</code>。<br><img src="http://image.winrains.cn/2019/08/1b408-20190829103017-8d087.jpeg" alt="http://image.winrains.cn/2019/08/1b408-20190829103017-8d087.jpeg"><br>WebSocket借助<code>http</code>协议进行握手，握手成功后，就会变身为<code>TCP通道</code>，从此与http不再相见。<br>使用netstat或者ss，能够看到对应的连接，它与处于抽象层的socket，在外观上没有区别。</p>
<h1 id="三、WebSocket和长轮询有什么区别？"><a href="#三、WebSocket和长轮询有什么区别？" class="headerlink" title="三、WebSocket和长轮询有什么区别？"></a>三、WebSocket和长轮询有什么区别？</h1><p>长轮询，就是客户端发送一个请求，服务端将一直在这个连接上等待（当然有一个超长的超时时间），直到有数据才返回，它依然是一个一问一答的模式。比如著名的comted。<br>WebSocket在握手成功后，就是<code>全双工</code>的TCP通道，数据可以主动从服务端发送到客户端，处于链接两端的应用没有任何区别。<br>WebSocket创建的连接和Http的长连接是不一样的。由于Http长连接底层依然是Http协议，所以它还是一问一答，只是Hold住了一条命长点的连接而已。<br>长轮询和Http长连接是阻塞的I/O，但WebSocket可以是非阻塞的（具体是多路复用）。<br><img src="http://image.winrains.cn/2019/08/d701e-20190829103017-1ff82.jpeg" alt="http://image.winrains.cn/2019/08/d701e-20190829103017-1ff82.jpeg"></p>
<h1 id="四、如何创建一个连接？"><a href="#四、如何创建一个连接？" class="headerlink" title="四、如何创建一个连接？"></a>四、如何创建一个连接？</h1><p>WebSocket的连接创建是借助Http协议进行的。这样设计主要是考虑兼容性，在浏览器中就可以很方便的发起请求，看起来比较具有迷惑性。<br>下图是一个典型的由浏览器发起的ws请求，可以看到和http请求长的是非常相似的。但是，它只是请求阶段长得像而已：<br><img src="http://image.winrains.cn/2019/08/6dda7-20190829103017-cf6d8.jpeg" alt="http://image.winrains.cn/2019/08/6dda7-20190829103017-cf6d8.jpeg"><br>请求的地址，一般是：<code>ws://\*\*\*</code>，或者是使用了SSL/TLS加密的安全协议<code>wss:</code>，用来标识是WebSocket请求。<br>1、 首先，通过Http头里面的<code>Upgrade</code>域，请求进行协议转换。如果服务端支持的话，就可以切换到WebSocket协议。简单点讲：连接已经在那了，通过握手切换成ws协议，就是切换了连接的一个状态而已。<br>1、<code>Connection</code>域可以认为是与<code>Upgrade</code>域配对的头信息。像nginx等代理服务器，是要先处理Connection，然后再发起协议转换的。<br>Sec-WebSocket-Key 是随机的字符串，服务器端会用这些数据来构造出一个 SHA-1 的信息摘要。如此操作，可以尽量避免普通 HTTP 请求被误认为 WebSocket 协议。<br>其他的，像Sec-WebSocket*字样的头信息，表明了客户端支持的子协议以及其他信息。像loT中很流行的mqtt，就可以作为WebSocket的子协议。<br><img src="http://image.winrains.cn/2019/08/77963-20190829103017-eb89d.jpeg" alt="http://image.winrains.cn/2019/08/77963-20190829103017-eb89d.jpeg"><br>使用javascript，可以很容易连接一个WebSocket服务端。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="actionscript">  <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:80'</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="actionscript">  ws.onopen = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'ws onopen'</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="actionscript">    ws.send(<span class="string">'from client: hello'</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="actionscript">  ws.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'ws onmessage'</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'from server: '</span> + e.data);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr></table></figure>

<h1 id="五、如何处理数据？"><a href="#五、如何处理数据？" class="headerlink" title="五、如何处理数据？"></a>五、如何处理数据？</h1><p>WebSocket是通过事件通知的方式运行的。它包含四个事件和两个动作（发送和关闭）。<br><strong>WebSocket的事件</strong></p>
<table>
<thead>
<tr>
<th>事件</th>
<th>钩子</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>open</td>
<td>onopen</td>
<td>连接建立时触发</td>
</tr>
<tr>
<td>message</td>
<td>onmessage</td>
<td>客户端接收服务端数据时触发</td>
</tr>
<tr>
<td>error</td>
<td>onerror</td>
<td>通信发生错误时触发</td>
</tr>
<tr>
<td>close</td>
<td>onclose</td>
<td>连接关闭时触发</td>
</tr>
</tbody></table>
<p>数据可直接通过<code>Socket.send()</code>方法进行传输。<br>通过chrome的Inspect-&gt;Network-&gt;WS，可以看到页面上的WebSocket连接。如图Opcode为2，表明它是一个二进制帧。<br><img src="http://image.winrains.cn/2019/08/eb9c2-20190829103018-9f834.jpeg" alt="http://image.winrains.cn/2019/08/eb9c2-20190829103018-9f834.jpeg"><br>WebSocket有类似tcp协议的帧格式，在此不做过多解释。<br>参考：(<a href="https://tools.ietf.org/html/rfc6455#section-5.1" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6455#section-5.1</a>)</p>
<h2 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h2><p>心跳对应的ping、pong操作，opcode分别是0x9、0xA。收到心跳的一方需要自行更新心跳的更新时间。同《<a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&mid=2650519418&idx=1&sn=b465291cbc396a0b665ed120d1176f68&scene=21#wechat_redirect" target="_blank" rel="noopener">使用Netty，我们到底在开发些什么？</a>》介绍的类似，在一些移动环境中，需要更加智能的控制心跳。</p>
<h1 id="六、如何使用Nginx做负载均衡？"><a href="#六、如何使用Nginx做负载均衡？" class="headerlink" title="六、如何使用Nginx做负载均衡？"></a>六、如何使用Nginx做负载均衡？</h1><p>nginx官网已经给出了例子。主要是Upgrade和Connection头的设置。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">map <span class="variable">$http_upgrade</span> <span class="variable">$connection_upgrade</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    default upgrade;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">''</span> close;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">location <span class="regexp">/chat/</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    proxy_pass http:<span class="regexp">//</span>backend;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    proxy_http_version <span class="number">1.1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    proxy_set_header Upgrade <span class="variable">$http_upgrade</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    proxy_set_header Connection <span class="variable">$connection_upgrade</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>需要注意的是，nginx做负载均衡，不需要配置<code>ip_hash</code>等参数，nginx天然支持。由于ip_hash仅使用ip地址的前三个数字做hash，还有可能造成服务端的不均衡。</p>
<h1 id="七、java服务端怎么实现？"><a href="#七、java服务端怎么实现？" class="headerlink" title="七、java服务端怎么实现？"></a>七、java服务端怎么实现？</h1><p>可以实现javax.WebSocket下的包，简单的实现ws服务端。目前基本可以通过注解的方式去编写代码，比如<code>ServerEndpoint</code>。<br>推荐使用基于netty的netty-socketio进行服务端的编写。由于使用的是netty，所以能够在多个层面进行切入，获取一些统计数据，执行一些控制指令。socketio是一套解决方案，它有多个语言的客户端，并处理了市面上大多数的兼容问题。</p>
<h1 id="八、WebSocket能干些啥？"><a href="#八、WebSocket能干些啥？" class="headerlink" title="八、WebSocket能干些啥？"></a>八、WebSocket能干些啥？</h1><h2 id="通知功能"><a href="#通知功能" class="headerlink" title="通知功能"></a>通知功能</h2><p>保持一个长连接，当服务端游新的消息，能够实时的推送到使用方。像知乎的点赞通知、评论等，都可以使用WebSocket通信。<br>某些使用<code>H5</code>的客户端，为了简化开发，也会使用WebSocket进行消息的通知，由于它是实时推送的，会有更好的用户体验。</p>
<h2 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h2><p>一些次优级别的数据，比如行为日志、trace、异常执栈收集等，都可以开辟专门的WebSocket通道进行传输。这能够增加信息的集中度，并能及时的针对用户的行为进行合适的配置推送。由于大多数浏览器内核都支持，它将使客户端<code>APM</code>编程模型变得简单。</p>
<h2 id="加密-amp-amp-认证"><a href="#加密-amp-amp-认证" class="headerlink" title="加密 &amp;&amp; 认证"></a>加密 &amp;&amp; 认证</h2><p>虽然使用Fiddler、Charles等能够抓到很多WebSocket包。但如果同时开启SSL，传输加密后的二进制数据，会大幅增加破解的成本，会安全的多。</p>
<h2 id="反向控制钩子"><a href="#反向控制钩子" class="headerlink" title="反向控制钩子"></a>反向控制钩子</h2><p>这个…由于是双工长连接，服务端完全可以推送一些钩子命令，甚至直接是代码，在客户端进行执行。比如截个屏，录个音，种个小马。用户只要通过了授权申请，剩下的就随你发挥了。<br>支付宝偷偷调用你的相机给你拍照的梗，我是相信的。</p>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>想当年，cometd的出现，惊为天人，振奋了很久。但技术日新月异，cometd已经衰老，而Socket.io得到了快速发展。WebSocket经过一段时间的混沌期，规范已经越来越完善，使用也越来越方便，不需要再处理那么多的兼容。<br>但它的本质，还是新瓶装旧酒，换汤不换药。WebSocket的发展得益于HTML5规范的制定。规范的意义，就是约束厂商们天马行空的实现，以及指明发展的方向。<br>这当然有典型的反例，那就是<code>ie</code>。现在，只有一群公认的**，还坚持在用。</p>
<blockquote>
<p>作者：小姐姐养的狗</p>
<p>来源：<a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650519450&amp;idx=1&amp;sn=a8ba905f2410671cb8e2f8ec6b33a7a9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650519450&amp;idx=1&amp;sn=a8ba905f2410671cb8e2f8ec6b33a7a9&amp;scene=21#wechat_redirect</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>StringBuilder为什么线程不安全</title>
    <url>/2019/12/26/StringBuilder%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>周五去面试又被面试的一个问题问哑巴了</p>
<blockquote>
<p>面试官：StringBuilder和StringBuffer的区别在哪？<br>我：StringBuilder不是线程安全的，StringBuffer是线程安全的<br>面试官：那StringBuilder不安全的点在哪儿？<br>我：。。。（哑巴了）</p>
</blockquote>
<p>在这之前我只记住了StringBuilder不是线程安全的，StringBuffer是线程安全的这个结论，至于StringBuilder为什么不安全从来没有去想过。</p>
<a id="more"></a>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote>
<p>在分析设个问题之前我们要知道StringBuilder和StringBuffer的内部实现跟String类一样，都是通过一个char数组存储字符串的，不同的是String类里面的char数组是final修饰的，是不可变的，而StringBuilder和StringBuffer的char数组是可变的。</p>
</blockquote>
<p>首先通过一段代码去看一下多线程操作StringBuilder对象会出现什么问题</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">StringBuilderDemo</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) throws InterruptedException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        StringBuilder <span class="built_in">string</span>Builder = new StringBuilder();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            new Thread(new Runnable() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">public</span> <span class="built_in">void</span> run() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="built_in">string</span>Builder.append(<span class="string">"a"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Thread.sleep(<span class="number">100</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(<span class="built_in">string</span>Builder.length());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们能看到这段代码创建了10个线程，每个线程循环1000次往StringBuilder对象里面append字符。正常情况下代码应该输出10000，但是实际运行会输出什么呢？</p>
<p><img src="http://image.winrains.cn/2019/08/20190829104615-6ff18.png" alt="img"></p>
<p>我们看到输出了“9326”，小于预期的10000，并且还抛出了一个ArrayIndexOutOfBoundsException异常（异常不是必现）。</p>
<h4 id="1、为什么输出值跟预期值不一样"><a href="#1、为什么输出值跟预期值不一样" class="headerlink" title="1、为什么输出值跟预期值不一样"></a>1、为什么输出值跟预期值不一样</h4><p>我们先看一下StringBuilder的两个成员变量（这两个成员变量实际上是定义在AbstractStringBuilder里面的，StringBuilder和StringBuffer都继承了AbstractStringBuilder）</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储字符串的具体内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//已经使用的字符数组的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">count</span>;</span></pre></td></tr></table></figure>

<p>再看StringBuilder的append()方法：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">@Override</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> StringBuilder <span class="built_in">append</span>(<span class="keyword">String</span> <span class="built_in">str</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">super</span>.<span class="built_in">append</span>(<span class="built_in">str</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>StringBuilder的append()方法调用的父类AbstractStringBuilder的append()方法</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder append(String <span class="keyword">str</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">str</span> == <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> appendNull();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> len = <span class="keyword">str</span>.length();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ensureCapacityInternal(<span class="keyword">count</span> + len);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">str</span>.getChars(<span class="number">0</span>, len, value, <span class="keyword">count</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">count</span> += len;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们先不管代码的第五行和第六行干了什么，直接看第七行，count += len不是一个原子操作。假设这个时候count值为10，len值为1，两个线程同时执行到了第七行，拿到的count值都是10，执行完加法运算后将结果赋值给count，所以两个线程执行完后count值为11，而不是12。这就是为什么测试代码输出的值要比10000小的原因。</p>
<h4 id="2、为什么会抛出ArrayIndexOutOfBoundsException异常"><a href="#2、为什么会抛出ArrayIndexOutOfBoundsException异常" class="headerlink" title="2、为什么会抛出ArrayIndexOutOfBoundsException异常"></a>2、为什么会抛出ArrayIndexOutOfBoundsException异常</h4><p>我们看回AbstractStringBuilder的append()方法源码的第五行，ensureCapacityInternal()方法是检查StringBuilder对象的原char数组的容量能不能盛下新的字符串，如果盛不下就调用expandCapacity()方法对char数组进行扩容。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void ensure<span class="constructor">CapacityInternal(<span class="params">int</span> <span class="params">minimumCapacity</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// overflow-conscious code</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        expand<span class="constructor">Capacity(<span class="params">minimumCapacity</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>扩容的逻辑就是new一个新的char数组，新的char数组的容量是原来char数组的两倍再加2，再通过System.arryCopy()函数将原数组的内容复制到新数组，最后将指针指向新的char数组。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void expand<span class="constructor">Capacity(<span class="params">int</span> <span class="params">minimumCapacity</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//计算新的容量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">int</span> newCapacity = value.length<span class="operator"> * </span><span class="number">2</span> + <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//中间省略了一些检查逻辑</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    value = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>copy<span class="constructor">Of(<span class="params">value</span>, <span class="params">newCapacity</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Arrys.copyOf()方法</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">char</span>[] copyOf(<span class="built_in">char</span>[] original, <span class="built_in">int</span> newLength) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">char</span>[] <span class="built_in">copy</span> = <span class="keyword">new</span> <span class="built_in">char</span>[newLength];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//拷贝数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.arraycopy(original, <span class="number">0</span>, <span class="built_in">copy</span>, <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                         Math.<span class="built_in">min</span>(original.length, newLength));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">copy</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>AbstractStringBuilder的append()方法源码的第六行，是将String对象里面char数组里面的内容拷贝到StringBuilder对象的char数组里面，代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">str.get<span class="constructor">Chars(0, <span class="params">len</span>, <span class="params">value</span>, <span class="params">count</span>)</span>;</span></pre></td></tr></table></figure>

<p>getChars()方法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void get<span class="constructor">Chars(<span class="params">int</span> <span class="params">srcBegin</span>, <span class="params">int</span> <span class="params">srcEnd</span>, <span class="params">char</span> <span class="params">dst</span>[], <span class="params">int</span> <span class="params">dstBegin</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//中间省略了一些检查</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>拷贝流程见下图</p>
<p><img src="http://image.winrains.cn/2019/08/20190829104616-1d8a7.png" alt="img"></p>
<p>假设现在有两个线程同时执行了StringBuilder的append()方法，两个线程都执行完了第五行的ensureCapacityInternal()方法，此刻count=5。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829104616-ea5e7.png" alt="img"></p>
<p>这个时候线程1的cpu时间片用完了，线程2继续执行。线程2执行完整个append()方法后count变成6了</p>
<p><img src="http://image.winrains.cn/2019/08/20190829104617-849b5.png" alt="img"></p>
<p>线程1继续执行第六行的str.getChars()方法的时候拿到的count值就是6了，执行char数组拷贝的时候就会抛出ArrayIndexOutOfBoundsException异常。<br>至此，StringBuilder为什么不安全已经分析完了。如果我们将测试代码的StringBuilder对象换成StringBuffer对象会输出什么呢？</p>
<p><img src="http://image.winrains.cn/2019/08/20190829104618-6d57d.png" alt="img"></p>
<p>当然是输出10000啦！那么StringBuffer用什么手段保证线程安全的？这个问题你点进StringBuffer的append()方法里面就知道了。</p>
<blockquote>
<p>作者：千山qianshan</p>
<p>来源：<a href="https://juejin.im/post/5d6228046fb9a06add4e37fe" target="_blank" rel="noopener">https://juejin.im/post/5d6228046fb9a06add4e37fe</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解多线程（五）：Java虚拟机的锁优化技术</title>
    <url>/2019/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E9%94%81%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>本文是《<a href="http://www.hollischuang.com/archives/tag/深入理解多线程" target="_blank" rel="noopener">深入理解多线程</a>》的第五篇文章，前面几篇文章中我们从synchronized的实现原理开始，一直介绍到了Monitor的实现原理。</p>
<a id="more"></a>

<h3 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h3><p>通过前面几篇文章，我们已经知道：<br>1、同步方法通过<code>ACC_SYNCHRONIZED</code>关键字隐式的对方法进行加锁。当线程要执行的方法被标注上<code>ACC_SYNCHRONIZED</code>时，需要先获得锁才能执行该方法。《<a href="http://www.hollischuang.com/archives/1883" target="_blank" rel="noopener">深入理解多线程（一）——Synchronized的实现原理</a>》<br>2、同步代码块通过<code>monitorenter</code>和<code>monitorexit</code>执行来进行加锁。当线程执行到<code>monitorenter</code>的时候要先获得所锁，才能执行后面的方法。当线程执行到<code>monitorexit</code>的时候则要释放锁。《<a href="http://www.hollischuang.com/archives/2030" target="_blank" rel="noopener">深入理解多线程（四）—— Moniter的实现原理</a>》<br>3、在HotSpot虚拟机中，使用<strong>oop-klass模型</strong>来表示对象。每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个<code>instanceKlass</code>，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个<code>instanceOopDesc</code>对象，这个对象中包含了对象头以及实例数据。《<a href="http://www.hollischuang.com/archives/1910" target="_blank" rel="noopener">深入理解多线程（二）—— Java的对象模型</a>》<br>4、对象头中主要包含了GC分代年龄、锁状态标记、哈希码、epoch等信息。对象的状态一共有五种，分别是无锁态、轻量级锁、重量级锁、GC标记和偏向锁。《<a href="http://www.hollischuang.com/archives/1953" target="_blank" rel="noopener">深入理解多线程（三）—— Java的对象头</a>》<br><strong>在上一篇文章的最后，我们说过，事实上，只有在JDK1.6之前，<code>synchronized</code>的实现才会直接调用<code>ObjectMonitor</code>的<code>enter</code>和<code>exit</code>，这种锁被称之为重量级锁。</strong><br><strong>高效并发是从JDK 1.5 到 JDK 1.6的一个重要改进，HotSpot虚拟机开发团队在这个版本中花费了很大的精力去对Java中的锁进行优化，如适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等。这些技术都是为了在线程之间更高效的共享数据，以及解决竞争问题。</strong><br>本文，主要先来介绍一下自旋、锁消除以及锁粗化等技术。<br>这里简单说明一下，本文要介绍的这几个概念，以及后面要介绍的轻量级锁和偏向锁，其实对于使用他的开发者来说是屏蔽掉了的，也就是说，<strong>作为一个Java开发，你只需要知道你想在加锁的时候使用synchronized就可以了，具体的锁的优化是虚拟机根据竞争情况自行决定的。</strong><br>也就是说，在JDK 1.5 以后，我们即将介绍的这些概念，都被封装在synchronized中了。</p>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>要想把锁说清楚，一个重要的概念不得不提，那就是线程和线程的状态。锁和线程的关系是怎样的呢，举个简单的例子你就明白了。<br>比如，你今天要去银行办业务，你到了银行之后，要先取一个号，然后你坐在休息区等待叫号，过段时间，广播叫到你的号码之后，会告诉你去哪个柜台办理业务，这时，你拿着你手里的号码，去到对应的柜台，找相应的柜员开始办理业务。当你办理业务的时候，这个柜台和柜台后面的柜员只能为你自己服务。当你办完业务离开之后，广播再喊其他的顾客前来办理业务。<br><a href="http://image.winrains.cn/2019/08/f092d-Pic1.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/f092d-Pic1.png" alt="Pic1"></a></p>
<blockquote>
<p>这个例子中，每个顾客是一个<strong>线程</strong>。 柜台前面的那把椅子，就是<strong>锁</strong>。 柜台后面的柜员，就是<strong>共享资源</strong>。 你发现无法直接办理业务，要取号等待的过程叫做<strong>阻塞</strong>。 当你听到叫你的号码的时候，你起身去办业务，这就是<strong>唤醒</strong>。 当你坐在椅子上开始办理业务的时候，你就<strong>获得锁</strong>。 当你办完业务离开的时候，你就<strong>释放锁</strong>。</p>
</blockquote>
<p>对于线程来说，一共有五种状态，分别为：初始状态(New) 、就绪状态(Runnable) 、运行状态(Running) 、阻塞状态(Blocked) 和死亡状态(Dead) 。<br><a href="http://image.winrains.cn/2019/08/6d157-thread.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/6d157-thread.png" alt="thread"></a></p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>在<a href="http://www.hollischuang.com/archives/2030" target="_blank" rel="noopener">前一篇</a>文章中，我们介绍的<code>synchronized</code>的实现方式中使用<code>Monitor</code>进行加锁，这是一种互斥锁，为了表示他对性能的影响我们称之为重量级锁。<br>这种互斥锁在互斥同步上对性能的影响很大，Java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统的帮忙，这就要从用户态转换到内核态，因此状态转换需要花费很多的处理器时间。<br>就像去银行办业务的例子，当你来到银行，发现柜台前面都有人的时候，你需要取一个号，然后再去等待区等待，一直等待被叫号。这个过程是比较浪费时间的，那么有没有什么办法改进呢？<br>有一种比较好的设计，那就是银行提供自动取款机，当你去银行取款的时候，你不需要取号，不需要去休息区等待叫号，你只需要找到一台取款机，排在其他人后面等待取款就行了。<br><a href="http://image.winrains.cn/2019/08/1e69c-Pic2.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/1e69c-Pic2.png" alt="Pic2"></a><br>之所以能这样做，是因为取款的这个过程相比较之下是比较节省时间的。如果所有人去银行都只取款，或者办理业务的时间都很短的话，那也就可以不需要取号，不需要去单独的休息区，不需要听叫号，也不需要再跑到对应的柜台了。<br>而，在程序中，Java虚拟机的开发工程师们在分析过大量数据后发现：共享数据的锁定状态一般只会持续很短的一段时间，为了这段时间去挂起和恢复线程其实并不值得。<br>如果物理机上有多个处理器，可以让多个线程同时执行的话。我们就可以让后面来的线程“稍微等一下”，但是并不放弃处理器的执行时间，看看持有锁的线程会不会很快释放锁。这个“稍微等一下”的过程就是自旋。<br>自旋锁在JDK 1.4中已经引入，在JDK 1.6中默认开启。<br>很多人在对于自旋锁的概念不清楚的时候可能会有以下疑问：这么听上去，自旋锁好像和阻塞锁没啥区别，反正都是等着嘛。</p>
<ul>
<li>对于去银行取钱的你来说，站在取款机面前等待和去休息区等待叫号有一个很大的区别：<ul>
<li>那就是如果你在休息区等待，这段时间你什么都不需要管，随意做自己的事情，等着被唤醒就行了。</li>
<li>如果你在取款机面前等待，那么你需要时刻关注自己前面还有没有人，因为没人会唤醒你。</li>
<li>很明显，这种直接去取款机前面排队取款的效率是比较高。</li>
</ul>
</li>
</ul>
<p><strong>所以呢，自旋锁和阻塞锁最大的区别就是，到底要不要放弃处理器的执行时间。对于阻塞锁和自旋锁来说，都是要等待获得共享资源。但是阻塞锁是放弃了CPU时间，进入了等待区，等待被唤醒。而自旋锁是一直“自旋”在那里，时刻的检查共享资源是否可以被访问。</strong><br>由于自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。如果线程竞争不激烈，并且保持锁的时间段。适合使用自旋锁。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>除了自旋锁之后，JDK中还有一种锁的优化被称之为锁消除。还拿去银行取钱的例子说。<br>你去银行取钱，所有情况下都需要取号，并且等待吗？其实是不用的，当银行办理业务的人不多的时候，可能根本不需要取号，直接走到柜台前面办理业务就好了。<br><a href="http://image.winrains.cn/2019/08/21271-Pic3.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/21271-Pic3.png" alt="Pic3"></a><br>能这么做的前提是，没有人和你抢着办业务。<br>上面的这种例子，在锁优化中被称作“锁消除”，是JIT编译器对内部锁的具体实现所做的一种优化。<br>在动态编译同步块的时候，JIT编译器可以借助一种被称为逃逸分析（Escape Analysis）的技术来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。<br>如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。<br>如以下代码：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> f() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">Object</span> hollis = <span class="built_in">new</span> <span class="keyword">Object</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    synchronized(hollis) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(hollis);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>代码中对<code>hollis</code>这个对象进行加锁，但是<code>hollis</code>对象的生命周期只在<code>f()</code>方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。优化成：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> f() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">Object</span> hollis = <span class="built_in">new</span> <span class="keyword">Object</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(hollis);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>这里，可能有读者会质疑了，代码是程序员自己写的，程序员难道没有能力判断要不要加锁吗？就像以上代码，完全没必要加锁，有经验的开发者一眼就能看的出来的。其实道理是这样，但是还是有可能有疏忽，比如我们经常在代码中使用<code>StringBuffer</code>作为局部变量，而<code>StringBuffer</code>中的<code>append</code>是线程安全的，有<code>synchronized</code>修饰的，这种情况开发者可能会忽略。这时候，JIT就可以帮忙优化，进行锁消除。</p>
</blockquote>
<p>了解我的朋友都知道，一般到这个时候，我就会开始反编译，然后拿出反编译之后的代码来证明锁优化确实存在。<br>但是，之前很多例子之所以可以用反编译工具，是因为那些“优化”，如语法糖等，是在<code>javac编译</code>阶段发生的，并不是在<code>JIT编译</code>阶段发生的。而锁优化，是JIT编译器的功能，所以，无法使用现有的反编译工具查看具体的优化结果。（关于javac编译和JIT编译的关系和区别，我在我的知识星球中单独发了一篇文章介绍。）</p>
<blockquote>
<p>但是，如果读者感兴趣，还是可以看的，只是会复杂一点，首先你要自己build一个fasttest版本的jdk，然后在使用java命令对<code>.class</code>文件进行执行的时候加上<code>-XX:+PrintEliminateLocks</code>参数。而且jdk的模式还必须是server模式。</p>
</blockquote>
<p>总之，读者只需要知道，在使用<code>synchronized</code>的时候，如果JIT经过逃逸分析之后发现并无线程安全问题的话，就会做锁消除。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>很多人都知道，在代码中，需要加锁的时候，我们提倡尽量减小锁的粒度，这样可以避免不必要的阻塞。<br>这也是很多人原因是用同步代码块来代替同步方法的原因，因为往往他的粒度会更小一些，这其实是很有道理的。<br>还是我们去银行柜台办业务，最高效的方式是你坐在柜台前面的时候，只办和银行相关的事情。如果这个时候，你拿出手机，接打几个电话，问朋友要往哪个账户里面打钱，这就很浪费时间了。最好的做法肯定是提前准备好相关资料，在办理业务时直接办理就好了。<br><a href="http://image.winrains.cn/2019/08/de86f-Pic4.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/de86f-Pic4.png" alt="Pic4"></a><br>加锁也一样，把无关的准备工作放到锁外面，锁内部只处理和并发相关的内容。这样有助于提高效率。<br>那么，这和锁粗化有什么关系呢？可以说，大部分情况下，减小锁的粒度是很正确的做法，只有一种特殊的情况下，会发生一种叫做锁粗化的优化。<br>就像你去银行办业务，你为了减少每次办理业务的时间，你把要办的五个业务分成五次去办理，这反而适得其反了。因为这平白的增加了很多你重新取号、排队、被唤醒的时间。<br>如果在一段代码中连续的对同一个对象反复加锁解锁，其实是相对耗费资源的，这种情况可以适当放宽加锁的范围，减少性能消耗。<br>当JIT发现一系列连续的操作都对同一个对象反复加锁和解锁，甚至加锁操作出现在循环体中的时候，会将加锁同步的范围扩散（粗化）到整个操作序列的外部。<br>如以下代码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    synchronized(<span class="keyword">this</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">do</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>会被粗化成：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">synchronized(<span class="keyword">this</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">do</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>这其实和我们要求的减小锁粒度并不冲突。减小锁粒度强调的是不要在银行柜台前做准备工作以及和办理业务无关的事情。而锁粗化建议的是，同一个人，要办理多个业务的时候，可以在同一个窗口一次性办完，而不是多次取号多次办理。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>自Java 6/Java 7开始，Java虚拟机对内部锁的实现进行了一些优化。这些优化主要包括锁消除（Lock Elision）、锁粗化（Lock Coarsening）、偏向锁（Biased Locking）以及适应性自旋锁（Adaptive Locking）。这些优化仅在Java虚拟机server模式下起作用（即运行Java程序时我们可能需要在命令行中指定Java虚拟机参数“-server”以开启这些优化）。<br>本文主要介绍了自旋锁、锁粗化和锁消除的概念。在JIT编译过程中，虚拟机会根据情况使用这三种技术对锁进行优化，目的是减少锁的竞争，提升性能。</p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/2344" target="_blank" rel="noopener">https://www.hollischuang.com/archives/2344</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解多线程（四）：Monitor的实现原理</title>
    <url>/2019/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AMonitor%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>在<a href="http://www.hollischuang.com/archives/1883" target="_blank" rel="noopener">深入理解多线程（一）——Synchronized的实现原理</a>中介绍过关于<code>Synchronize</code>的实现原理，无论是同步方法还是同步代码块，无论是<code>ACC_SYNCHRONIZED</code>还是<code>monitorenter</code>、<code>monitorexit</code>都是基于<code>Monitor</code>实现的，那么这篇来介绍下什么是<strong>Monitor</strong>。</p>
<a id="more"></a>

<h3 id="操作系统中的管程"><a href="#操作系统中的管程" class="headerlink" title="操作系统中的管程"></a>操作系统中的管程</h3><p>如果你在大学学习过操作系统，你可能还记得管程（monitors）在操作系统中是很重要的概念。同样Monitor在java同步机制中也有使用。</p>
<blockquote>
<p>管程 (英语：Monitors，也称为监视器) 是一种程序结构，结构内的多个子程序（对象或模块）形成的多个工作线程互斥访问共享资源。这些共享资源一般是硬件设备或一群变量。管程实现了在一个时间点，最多只有一个线程在执行管程的某个子程序。与那些通过修改数据结构实现互斥访问的并发程序设计相比，管程实现很大程度上简化了程序设计。 管程提供了一种机制，线程可以临时放弃互斥访问，等待某些条件得到满足后，重新获得执行权恢复它的互斥访问。</p>
</blockquote>
<h3 id="Java线程同步相关的Monitor"><a href="#Java线程同步相关的Monitor" class="headerlink" title="Java线程同步相关的Monitor"></a>Java线程同步相关的Monitor</h3><p>在多线程访问共享资源的时候，经常会带来可见性和原子性的安全问题。为了解决这类线程安全的问题，Java提供了同步机制、互斥锁机制，这个机制保证了在同一时刻只有一个线程能访问共享资源。这个机制的保障来源于监视锁Monitor，每个对象都拥有自己的监视锁Monitor。<br>先来举个例子，然后我们在上源码。我们可以把监视器理解为包含一个特殊的房间的建筑物，这个特殊房间同一时刻只能有一个客人（线程）。这个房间中包含了一些数据和代码。<br><a href="http://image.winrains.cn/2019/08/df48a-Java-Monitor.jpg" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/df48a-Java-Monitor.jpg" alt="Java-Monitor"></a><br>如果一个顾客想要进入这个特殊的房间，他首先需要在走廊（Entry Set）排队等待。调度器将基于某个标准（比如 FIFO）来选择排队的客户进入房间。如果，因为某些原因，该客户客户暂时因为其他事情无法脱身（线程被挂起），那么他将被送到另外一间专门用来等待的房间（Wait Set），这个房间的可以可以在稍后再次进入那件特殊的房间。如上面所说，这个建筑屋中一共有三个场所。<br><a href="http://image.winrains.cn/2019/08/64de8-java-monitor-associate-with-object.jpg" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/64de8-java-monitor-associate-with-object.jpg" alt="java-monitor-associate-with-object"></a><br>总之，监视器是一个用来监视这些线程进入特殊的房间的。他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。<br>Monitor其实是一种同步工具，也可以说是一种同步机制，它通常被描述为一个对象，主要特点是：</p>
<blockquote>
<p>对象的所有方法都被“互斥”的执行。好比一个Monitor只有一个运行“许可”，任一个线程进入任何一个方法都需要获得这个“许可”，离开时把许可归还。<br>通常提供singal机制：允许正持有“许可”的线程暂时放弃“许可”，等待某个谓词成真（条件变量），而条件成立后，当前进程可以“通知”正在等待这个条件变量的线程，让他可以重新去获得运行许可。</p>
</blockquote>
<h3 id="监视器的实现"><a href="#监视器的实现" class="headerlink" title="监视器的实现"></a>监视器的实现</h3><p>在Java虚拟机(HotSpot)中，Monitor是基于C++实现的，由<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp" target="_blank" rel="noopener">ObjectMonitor</a>实现的，其主要数据结构如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">ObjectMonitor()</span> <span class="string">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_header</span>       <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_count</span>        <span class="string">=</span> <span class="number">0</span><span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_waiters</span>      <span class="string">=</span> <span class="number">0</span><span class="string">,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_recursions</span>   <span class="string">=</span> <span class="number">0</span><span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_object</span>       <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_owner</span>        <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_WaitSet</span>      <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_WaitSetLock</span>  <span class="string">=</span> <span class="number">0</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_Responsible</span>  <span class="string">=</span> <span class="literal">NULL</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_succ</span>         <span class="string">=</span> <span class="literal">NULL</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_cxq</span>          <span class="string">=</span> <span class="literal">NULL</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">FreeNext</span>      <span class="string">=</span> <span class="literal">NULL</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_EntryList</span>    <span class="string">=</span> <span class="literal">NULL</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_SpinFreq</span>     <span class="string">=</span> <span class="number">0</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_SpinClock</span>    <span class="string">=</span> <span class="number">0</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">OwnerIsThread</span> <span class="string">=</span> <span class="number">0</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">&#125;</span></span></pre></td></tr></table></figure>

<p>源码地址：<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.hpp#L193" target="_blank" rel="noopener">objectMonitor.hpp</a><br>ObjectMonitor中有几个关键属性：</p>
<blockquote>
<p>_owner：指向持有ObjectMonitor对象的线程<br>_WaitSet：存放处于wait状态的线程队列<br>_EntryList：存放处于等待锁block状态的线程队列<br>_recursions：锁的重入次数<br>_count：用来记录该线程获取锁的次数</p>
</blockquote>
<p>当多个线程同时访问一段同步代码时，首先会进入<code>_EntryList</code>队列中，当某个线程获取到对象的monitor后进入<code>_Owner</code>区域并把monitor中的<code>_owner</code>变量设置为当前线程，同时monitor中的计数器<code>_count</code>加1。即获得对象锁。<br>若持有monitor的线程调用<code>wait()</code>方法，将释放当前持有的monitor，<code>_owner</code>变量恢复为<code>null</code>，<code>_count</code>自减1，同时该线程进入<code>_WaitSet</code>集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示<br><a href="http://image.winrains.cn/2019/08/bd30d-monitor.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/bd30d-monitor.png" alt="monitor"></a><br>ObjectMonitor类中提供了几个方法：<br><strong>获得锁</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">void ATTR ObjectMonitor::enter(TRAPS) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Thread * <span class="keyword">const</span> <span class="keyword">Self</span> = THREAD ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void * cur ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//通过CAS尝试把monitor的`_owner`字段设置为当前线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cur = Atomic::cmpxchg_ptr (<span class="keyword">Self</span>, &amp;_owner, <span class="keyword">NULL</span>) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//获取锁失败</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (cur == <span class="keyword">NULL</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        assert (_recursions == <span class="number">0</span>   , <span class="string">"invariant"</span>) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        assert (_owner      == <span class="keyword">Self</span>, <span class="string">"invariant"</span>) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// CONSIDER: set or assert OwnerIsThread == 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果旧值和当前线程一样，说明当前线程已经持有锁，此次为重入，_recursions自增，并获得锁。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (cur == <span class="keyword">Self</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// TODO-<span class="doctag">FIXME:</span> check for integer overflow!  BUGID 6557169.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        _recursions ++ ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果当前线程是第一次进入该monitor，设置_recursions为1，_owner为当前线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">Self</span>-&gt;is_lock_owned ((address)cur)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        assert (_recursions == <span class="number">0</span>, <span class="string">"internal state error"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _recursions = <span class="number">1</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Commute owner from a thread-specific on-stack BasicLockObject address to</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// a full-fledged "Thread *".</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        _owner = <span class="keyword">Self</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        OwnerIsThread = <span class="number">1</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 省略部分代码。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 通过自旋执行ObjectMonitor::EnterI方法等待锁的释放</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (;;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        jt-&gt;set_suspend_equivalent();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// cleared by handle_special_suspend_equivalent_condition()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// or java_suspend_self()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        EnterI (THREAD) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!ExitSuspendEquivalent(jt)) <span class="keyword">break</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// We have acquired the contended monitor, but while we were</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// waiting another thread suspended us. We don't want to enter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// the monitor while suspended because that would surprise the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// thread that suspended us.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        _recursions = <span class="number">0</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _succ = <span class="keyword">NULL</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">exit</span> (<span class="keyword">Self</span>) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        jt-&gt;java_suspend_self();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><a href="http://image.winrains.cn/2019/08/b370f-lockenter.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/b370f-lockenter.png" alt="lockenter"></a><br>释放锁</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">void ATTR ObjectMonitor::<span class="keyword">exit</span>(TRAPS) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   Thread * Self = THREAD ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">//如果当前线程不是Monitor的所有者</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (THREAD != <span class="variable">_owner</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">if</span> (THREAD-&gt;is_lock_owned((address) <span class="variable">_owner</span>)) &#123; <span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// Transmute _owner from a BasicLock pointer to a Thread address.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// We don't need to hold _mutex for this transition.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// Non-null to Non-null is safe as long as all readers can</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// tolerate either flavor.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="built_in">assert</span> (<span class="variable">_recursions</span> == <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="variable">_owner</span> = THREAD ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="variable">_recursions</span> = <span class="number">0</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       OwnerIsThread = <span class="number">1</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// <span class="doctag">NOTE:</span> we need to handle unbalanced monitor enter/exit</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// in native code by throwing an exception.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// <span class="doctag">TODO:</span> Throw an IllegalMonitorStateException ?</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       TEVENT (<span class="keyword">Exit</span> - <span class="keyword">Throw</span> IMSX) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="built_in">assert</span>(<span class="literal">false</span>, <span class="string">"Non-balanced monitor enter/exit!"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">THROW</span>(vmSymbols::java_lang_IllegalMonitorStateException());</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       return;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果_recursions次数不为0.自减</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (<span class="variable">_recursions</span> != <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="variable">_recursions</span>--;        <span class="comment">// this is simple recursive enter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     TEVENT (Inflated <span class="keyword">exit</span> - recursive) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     return ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">//省略部分代码，根据不同的策略（由QMode指定），从cxq或EntryList中获取头节点，通过ObjectMonitor::ExitEpilog方法唤醒该节点封装的线程，唤醒操作最终由unpark完成。</span></span></pre></td></tr></table></figure>

<p><a href="http://image.winrains.cn/2019/08/ce586-lockexit.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/ce586-lockexit.png" alt="lockexit"></a><br>除了enter和exit方法以外，<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp" target="_blank" rel="noopener">objectMonitor.cpp</a>中还有</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>      <span class="title">wait</span><span class="params">(jlong <span class="built_in">millis</span>, <span class="keyword">bool</span> interruptable, TRAPS)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>      <span class="title">notify</span><span class="params">(TRAPS)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>      <span class="title">notifyAll</span><span class="params">(TRAPS)</span></span>;</span></pre></td></tr></table></figure>

<p>等方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面介绍的就是HotSpot虚拟机中Monitor的的加锁以及解锁的原理。<br>通过这篇文章我们知道了<code>sychronized</code>加锁的时候，会调用objectMonitor的<code>enter</code>方法，解锁的时候会调用<code>exit</code>方法。事实上，只有在JDK1.6之前，<code>synchronized</code>的实现才会直接调用ObjectMonitor的<code>enter</code>和<code>exit</code>，这种锁被称之为重量级锁。为什么说这种方式操作锁很重呢？</p>
<ul>
<li>Java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统的帮忙，这就要从用户态转换到核心态，因此状态转换需要花费很多的处理器时间，对于代码简单的同步块（如被<code>synchronized</code>修饰的<code>get</code> 或<code>set</code>方法）状态转换消耗的时间有可能比用户代码执行的时间还要长，所以说<code>synchronized</code>是java语言中一个重量级的操纵。</li>
</ul>
<p>所以，在JDK1.6中出现对锁进行了很多的优化，进而出现轻量级锁，偏向锁，锁消除，适应性自旋锁，锁粗化(自旋锁在1.4就有 只不过默认的是关闭的，jdk1.6是默认开启的)，这些操作都是为了在线程之间更高效的共享数据 ，解决竞争问题。后面的文章会继续介绍这几种锁以及他们之间的关系。<br><a href="http://bigdatadecode.club/JavaSynchronizedTheory.html" target="_blank" rel="noopener">Java Synchronized实现原理</a><br><a href="http://www.jianshu.com/p/f4454164c017" target="_blank" rel="noopener">JVM源码分析之Object.wait/notify实现</a><br><a href="http://blog.csdn.net/penngrove/article/details/44175387" target="_blank" rel="noopener">Linux Kernel CMPXCHG函数分析</a><br><a href="https://www.cnblogs.com/kundeg/p/8422557.html" target="_blank" rel="noopener">从jvm源码看synchronized</a></p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/2030" target="_blank" rel="noopener">https://www.hollischuang.com/archives/2030</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解多线程（三）：Java的对象头</title>
    <url>/2019/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AJava%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%A4%B4/</url>
    <content><![CDATA[<p><a href="http://www.hollischuang.com/archives/1910" target="_blank" rel="noopener">上一篇</a>文章中我们从HotSpot的源码入手，介绍了Java的对象模型。这一篇文章在上一篇文章的基础上再来介绍一下Java的对象头。主要介绍一下对象头的作用，结构以及他和锁的关系。</p>
<a id="more"></a>

<h3 id="Java对象模型回顾与勘误"><a href="#Java对象模型回顾与勘误" class="headerlink" title="Java对象模型回顾与勘误"></a>Java对象模型回顾与勘误</h3><p>在上一篇文章中，关于对象头的部分描述有误，我已经在我博客的文章中就行修正 。这里再重新表述一下。<br>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个<code>instanceKlass</code>，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个<code>instanceOopDesc</code>对象，这个对象中包含了对象头以及实例数据。<br>这里提到的对象头到底是什么呢？</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">oopDesc</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  friend <span class="class"><span class="keyword">class</span> <span class="title">VMStructs</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="symbol">private:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  volatile markOop  _mark;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">_metadata</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    wideKlassOop    _klass;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    narrowOop       _compressed_klass;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125; _metadata;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面代码中的<code>_mark</code>和<code>_metadata</code>其实就是对象头的定义。关于<code>_metadata</code>之前就介绍过，这里不再赘述。由于这个专题主要想介绍和JAVA并发相关的知识，所以本文展开介绍一下<code>_mark</code> ，即mark word。<br>对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。<br>对markword的设计方式上，非常像网络协议报文头：将mark word划分为多个比特位区间，并在不同的对象状态下赋予比特位不同的含义。下图描述了在32位虚拟机上，在对象不同状态时 mark word各个比特位区间的含义。<br><img src="http://image.winrains.cn/2019/08/acec7-ObjectHead-1024x329.png" alt="ObjectHead"><br>同样，在HotSpot的源码中我们可以找到关于对象头对象的定义，会一一印证上图的描述。对应与<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/markOop.hpp" target="_blank" rel="noopener">markOop.hpp</a>类。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; age_bits                 = <span class="number">4</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      lock_bits                = <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      biased_lock_bits         = <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      max_hash_bits            = BitsPerWord - age_bits - lock_bits - biased_lock_bits,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      hash_bits                = max_hash_bits &gt; <span class="number">31</span> ? <span class="number">31</span> : max_hash_bits,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      cms_bits                 = LP64_ONLY(<span class="number">1</span>) NOT_LP64(<span class="number">0</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      epoch_bits               = <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>从上面的枚举定义中可以看出，对象头中主要包含了GC分代年龄、锁状态标记、哈希码、epoch等信息。<br>从上图中可以看出，对象的状态一共有五种，分别是无锁态、轻量级锁、重量级锁、GC标记和偏向锁。在32位的虚拟机中有两个Bits是用来存储锁的标记为的，但是我们都知道，两个bits最多只能表示四种状态：00、01、10、11，那么第五种状态如何表示呢 ，就要额外依赖1Bit的空间，使用0和1来区分。</p>
<blockquote>
<p>在32位的HotSpot虚拟机 中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码(HashCode)，4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，表示非偏向锁。</p>
</blockquote>
<p><a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/markOop.hpp" target="_blank" rel="noopener">markOop.hpp</a>类中有关于对象状态的定义：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; locked_value             = <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       unlocked_value           = <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       monitor_value            = <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       marked_value             = <span class="number">3</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       biased_lock_pattern      = <span class="number">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>简单翻译一下：</p>
<blockquote>
<p>locked_value(00) = 0<br>unlocked_value(01) = 1<br>monitor_value(10) = 2<br>marked_value(11) = 3<br>biased_lock_pattern(101) = 5</p>
</blockquote>
<p>关于为什么要定义这么多状态，上面提到的轻量级锁、重量级锁、偏向锁以及他们之前的关系，会在下一篇文章中重点阐述，敬请期待。</p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/1953" target="_blank" rel="noopener">https://www.hollischuang.com/archives/1953</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解多线程（二）：Java的对象模型</title>
    <url>/2019/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AJava%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p><a href="http://www.hollischuang.com/archives/1883" target="_blank" rel="noopener">上一篇</a>文章中简单介绍过<code>synchronized</code>关键字的方式，其中，同步代码块使用<code>monitorenter</code>和<code>monitorexit</code>两个指令实现，同步方法使用<code>ACC_SYNCHRONIZED</code>标记符实现。后面几篇文章会从JVM源码的角度更加深入，层层剥开<code>synchronized</code>的面纱。在进入正题之前，肯定有些基础知识需要铺垫，那么先来看一下一个容易被忽略的但是又很重要的知识点 —— Java对象模型 。<br>大家都知道的是，Java对象保存在堆内存中。在内存中，一个Java对象包含三部分：对象头、实例数据和对齐填充。其中对象头是一个很关键的部分，因为<strong>对象头中包含锁状态标志、线程持有的锁等标志</strong>。这篇文章就主要从Java对象模型入手，找一找我们关系的对象头以及对象头中和锁相关的运行时数据在JVM中是如何表示的。</p>
<a id="more"></a>

<h3 id="Java的对象模型"><a href="#Java的对象模型" class="headerlink" title="Java的对象模型"></a>Java的对象模型</h3><p>任何一个接触过Java的人都知道，Java是一种面向对象语言。在学习Java的过程中你一定对下面两句话不陌生：</p>
<ul>
<li>1、在面向对象的软件中，对象（Object）是某一个类（Class）的实例。 <a href="https://zh.wikipedia.org/wiki/对象_(计算机科学)" target="_blank" rel="noopener">维基百科</a></li>
<li>2、一切皆对象 <a href="https://book.douban.com/subject/1474824/" target="_blank" rel="noopener">Thinking In Java</a></li>
</ul>
<p>我们还知道，在JVM的内存结构中，对象保存在堆内存中，而我们在对对象进行操作时，其实操作的是对象的引用。那么对象本身在JVM中的结构是什么样的呢？本文的所有分析均基于<a href="https://github.com/openjdk-mirror/jdk7u-hotspot" target="_blank" rel="noopener">HotSpot</a>虚拟机。</p>
<h3 id="oop-klass-model"><a href="#oop-klass-model" class="headerlink" title="oop-klass model"></a>oop-klass model</h3><p>HotSpot是基于c++实现，而c++是一门面向对象的语言，本身是具备面向对象基本特征的，所以Java中的对象表示，最简单的做法是为每个Java类生成一个c++类与之对应。但HotSpot JVM并没有这么做，而是设计了一个<code>OOP-Klass Model</code>。OOP（<code>Ordinary Object Pointer</code>）指的是普通对象指针，而<code>Klass</code>用来描述对象实例的具体类型。<br>为什么HotSpot要设计一套<code>oop-klass model</code>呢？答案是：HotSopt JVM的设计者不想让每个对象中都含有一个<code>vtable</code>（虚函数表）<br>这个解释似乎可以说得通。众所周知，C++和Java都是面向对象的语言，面向对象语言有一个很重要的特性就是多态。关于多态的实现，C++和Java有着本质的区别。</p>
<blockquote>
<p>多态是面向对象的最主要的特性之一，是一种方法的动态绑定，实现运行时的类型决定对象的行为。多态的表现形式是父类指针或引用指向子类对象，在这个指针上调用的方法使用子类的实现版本。多态是IOC、模板模式实现的关键。</p>
<blockquote>
<p>在C++中通过虚函数表的方式实现多态，每个包含虚函数的类都具有一个虚函数表（virtual table），在这个类对象的地址空间的最靠前的位置存有指向虚函数表的指针。在虚函数表中，按照声明顺序依次排列所有的虚函数。由于C++在运行时并不维护类型信息，所以在编译时直接在子类的虚函数表中将被子类重写的方法替换掉。<br>在Java中，在运行时会维持类型信息以及类的继承体系。每一个类会在方法区中对应一个数据结构用于存放类的信息，可以通过Class对象访问这个数据结构。其中，类型信息具有superclass属性指示了其超类，以及这个类对应的方法表（其中只包含这个类定义的方法，不包括从超类继承来的）。而每一个在堆上创建的对象，都具有一个指向方法区类型信息数据结构的指针，通过这个指针可以确定对象的类型。</p>
</blockquote>
</blockquote>
<p>上面这段是我从网上摘取过来的，说的有一定道理，但是也不全对。至于为啥，我会在后文介绍到Klass的时候细说。<br>关于opp-klass模型的整体定义，在HotSpot的<a href="https://github.com/openjdk-mirror/jdk7u-hotspot" target="_blank" rel="noopener">源码</a>中可以找到。<br>oops模块可以分成两个相对独立的部分：OOP框架和Klass框架。<br>在<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/oopsHierarchy.hpp" target="_blank" rel="noopener">oopsHierarchy.hpp</a>里定义了oop和klass各自的体系。</p>
<h3 id="oop-klass结构"><a href="#oop-klass结构" class="headerlink" title="oop-klass结构"></a>oop-klass结构</h3><p><a href="http://image.winrains.cn/2019/08/d99a2-oops.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/d99a2-oops.png" alt="oops"></a><br>oop体系：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义了oops共同基类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">oopDesc</span>*                            <span class="title">oop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示一个Java类型实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">instanceOopDesc</span>*            <span class="title">instanceOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示一个Java方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">methodOopDesc</span>*                    <span class="title">methodOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示一个Java方法中的不变信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">constMethodOopDesc</span>*            <span class="title">constMethodOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//记录性能信息的数据结构</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">methodDataOopDesc</span>*            <span class="title">methodDataOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//定义了数组OOPS的抽象基类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">arrayOopDesc</span>*                    <span class="title">arrayOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示持有一个OOPS数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">objArrayOopDesc</span>*            <span class="title">objArrayOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示容纳基本类型的数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">typeArrayOopDesc</span>*            <span class="title">typeArrayOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示在Class文件中描述的常量池</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">constantPoolOopDesc</span>*            <span class="title">constantPoolOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//常量池告诉缓存</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">constantPoolCacheOopDesc</span>*   <span class="title">constantPoolCacheOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//描述一个与Java类对等的C++类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">klassOopDesc</span>*                    <span class="title">klassOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示对象头</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">markOopDesc</span>*                    <span class="title">markOop</span>;</span></span></pre></td></tr></table></figure>

<p><strong>上面列出的是整个Oops模块的组成结构，其中包含多个子模块。每一个子模块对应一个类型，每一个类型的OOP都代表一个在JVM内部使用的特定对象的类型。</strong><br>从上面的代码中可以看到，有一个变量opp的类型是<code>oppDesc</code> ，OOPS类的共同基类型为<code>oopDesc</code>。<br><strong>在Java程序运行过程中，每创建一个新的对象，在JVM内部就会相应地创建一个对应类型的OOP对象。</strong>在HotSpot中，根据JVM内部使用的对象业务类型，具有多种<code>oopDesc</code>的子类。除了<code>oppDesc</code>类型外，opp体系中还有很多<code>instanceOopDesc</code>、<code>arrayOopDesc</code> 等类型的实例，他们都是<code>oopDesc</code>的子类。<br><a href="http://image.winrains.cn/2019/08/c4110-OOP结构.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/c4110-OOP%E7%BB%93%E6%9E%84.png" alt="OOP结构"></a><br>这些OOPS在JVM内部有着不同的用途，例如<strong>，<code>instanceOopDesc</code>表示类实例，<code>arrayOopDesc</code>表示数组。</strong>也就是说，<strong>当我们使用<code>new</code>创建一个Java对象实例的时候，JVM会创建一个<code>instanceOopDesc</code>对象来表示这个Java对象。同理，当我们使用<code>new</code>创建一个Java数组实例的时候，JVM会创建一个<code>arrayOopDesc</code>对象来表示这个数组对象。</strong><br>在HotSpot中，oopDesc类定义在<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/oop.hpp" target="_blank" rel="noopener">oop.hpp</a>中，instanceOopDesc定义在<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/instanceOop.hpp" target="_blank" rel="noopener">instanceOop.hpp</a>中，arrayOopDesc定义在<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/arrayOop.hpp" target="_blank" rel="noopener">arrayOop.hpp</a>中。<br>简单看一下相关定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">oopDesc</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VMStructs</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">volatile</span> markOop  _mark;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">union</span> _metadata &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wideKlassOop    _klass;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        narrowOop       _compressed_klass;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; _metadata;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// field addresses in oop</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">void</span>*     <span class="title">field_base</span><span class="params">(<span class="keyword">int</span> offset)</span>        <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jbyte*    <span class="title">byte_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span>   <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jchar*    <span class="title">char_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span>   <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jboolean* <span class="title">bool_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span>   <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jint*     <span class="title">int_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span>    <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jshort*   <span class="title">short_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span>  <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jlong*    <span class="title">long_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span>   <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jfloat*   <span class="title">float_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span>  <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jdouble*  <span class="title">double_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">address*  <span class="title">address_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">instanceOopDesc</span> :</span> <span class="keyword">public</span> oopDesc &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arrayOopDesc</span> :</span> <span class="keyword">public</span> oopDesc &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过上面的源码可以看到，<code>instanceOopDesc</code>实际上就是继承了<code>oopDesc</code>，并没有增加其他的数据结构，也就是说<code>instanceOopDesc</code>中主要包含以下几部分数据：<code>markOop  _mark</code>和<code>union _metadata</code> 以及一些不同类型的 <code>field</code>。<br>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头、实例数据和对齐填充。在虚拟机内部，一个Java对象对应一个<code>instanceOopDesc</code>的对象。其中对象头包含了两部分内容：<code>_mark</code>和<code>_metadata</code>，而实例数据则保存在oopDesc中定义的各种field中。</p>
<h4 id="mark"><a href="#mark" class="headerlink" title="_mark"></a>_mark</h4><p>文章开头我们就说过，之所以我们要写这篇文章，是因为对象头中有和锁相关的运行时数据，这些运行时数据是<code>synchronized</code>以及其他类型的锁实现的重要基础，而关于锁标记、GC分代等信息均保存在<code>_mark</code>中。因为本文主要介绍的<code>oop-klass</code>模型，在这里暂时不对对象头做展开，下一篇文章介绍。</p>
<h4 id="metadata"><a href="#metadata" class="headerlink" title="_metadata"></a>_metadata</h4><p>前面介绍到的<code>_metadata</code>是一个共用体，其中<code>_klass</code>是普通指针，<code>_compressed_klass</code>是压缩类指针。在深入介绍之前，就要来到<code>oop-Klass</code>中的另外一个主角<code>klass</code>了。</p>
<h3 id="klass"><a href="#klass" class="headerlink" title="klass"></a>klass</h3><p>klass体系</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//klassOop的一部分，用来描述语言层的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Klass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//在虚拟机层面描述一个Java类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">instanceKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//专有instantKlass，表示java.lang.Class的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>     <span class="title">instanceMirrorKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//专有instantKlass，表示java.lang.ref.Reference的子类的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>     <span class="title">instanceRefKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示methodOop的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">methodKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示constMethodOop的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">constMethodKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示methodDataOop的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">methodDataKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//最为klass链的端点，klassKlass的Klass就是它自身</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">klassKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示instanceKlass的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>     <span class="title">instanceKlassKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示arrayKlass的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>     <span class="title">arrayKlassKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示objArrayKlass的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>       <span class="title">objArrayKlassKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示typeArrayKlass的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>       <span class="title">typeArrayKlassKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示array类型的抽象基类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">arrayKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示objArrayOop的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>     <span class="title">objArrayKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示typeArrayOop的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>     <span class="title">typeArrayKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示constantPoolOop的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">constantPoolKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示constantPoolCacheOop的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">constantPoolCacheKlass</span>;</span></span></pre></td></tr></table></figure>

<p>和<code>oopDesc</code>是其他oop类型的父类一样，Klass类是其他klass类型的父类。<br><a href="http://image.winrains.cn/2019/08/527b3-klass.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/527b3-klass.png" alt="klass"></a><br>Klass向JVM提供两个功能：</p>
<ul>
<li>实现语言层面的Java类（在Klass基类中已经实现）</li>
<li>实现Java对象的分发功能（由Klass的子类提供虚函数实现）</li>
</ul>
<p>文章开头的时候说过：之所以设计<code>oop-klass</code>模型，是因为HotSopt JVM的设计者不想让每个对象中都含有一个虚函数表。<br>HotSopt JVM的设计者把对象一拆为二，分为<code>klass</code>和<code>oop</code>，其中<code>oop</code>的职能主要在于表示对象的实例数据，所以其中不含有任何虚函数。而klass为了实现虚函数多态，所以提供了虚函数表。所以，关于Java的多态，其实也有虚函数的影子在。<br><code>_metadata</code>是一个共用体，其中<code>_klass</code>是普通指针，<code>_compressed_klass</code>是压缩类指针。这两个指针都指向<code>instanceKlass</code>对象，它用来描述对象的具体类型。</p>
<h3 id="instanceKlass"><a href="#instanceKlass" class="headerlink" title="instanceKlass"></a>instanceKlass</h3><p>JVM在运行时，需要一种用来标识Java内部类型的机制。在HotSpot中的解决方案是：为每一个已加载的Java类创建一个<code>instanceKlass</code>对象，用来在JVM层表示Java类。<br>来看下<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/instanceKlass.hpp" target="_blank" rel="noopener">instanceKlass</a>的内部结构：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类拥有的方法列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">objArrayOop     <span class="variable">_methods</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//描述方法顺序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">typeArrayOop    <span class="variable">_method_ordering</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//实现的接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">objArrayOop     <span class="variable">_local_interfaces</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//继承的接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">objArrayOop     <span class="variable">_transitive_interfaces</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//域</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">typeArrayOop    <span class="variable">_fields</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//常量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">constantPoolOop <span class="variable">_constants</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//类加载器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">oop             <span class="variable">_class_loader</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//protected域</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">oop             <span class="variable">_protection_domain</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ....</span></pre></td></tr></table></figure>

<p>可以看到，一个类该具有的东西，这里面基本都包含了。<br>这里还有个点需要简单介绍一下。<br>在JVM中，对象在内存中的基本存在形式就是oop。那么，对象所属的类，在JVM中也是一种对象，因此它们实际上也会被组织成一种oop，即klassOop。同样的，对于klassOop，也有对应的一个klass来描述，它就是klassKlass，也是klass的一个子类。klassKlass作为oop的klass链的端点。关于对象和数组的klass链大致如下图：<br><a href="http://image.winrains.cn/2019/08/e6430-400_ac3_932.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/e6430-400_ac3_932.png" alt="400_ac3_932"></a><br>在这种设计下，JVM对内存的分配和回收，都可以采用统一的方式来管理。oop-klass-klassKlass关系如图：<br><a href="http://image.winrains.cn/2019/08/ce592-2579123-5b117a7c06e83d84.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/ce592-2579123-5b117a7c06e83d84.png" alt="2579123-5b117a7c06e83d84"></a></p>
<h3 id="内存存储"><a href="#内存存储" class="headerlink" title="内存存储"></a>内存存储</h3><p>关于一个Java对象，他的存储是怎样的，一般很多人会回答：对象存储在堆上。稍微好一点的人会回答：对象存储在堆上，对象的引用存储在栈上。今天，再给你一个更加显得牛逼的回答：</p>
<blockquote>
<p>对象的实例（instantOopDesc)保存在堆上，对象的元数据（instantKlass）保存在方法区，对象的引用保存在栈上。</p>
</blockquote>
<p>其实如果细追究的话，上面这句话有点故意卖弄的意思。因为我们都知道。<strong>方法区用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong> 所谓加载的类信息，其实不就是给每一个被加载的类都创建了一个 instantKlass对象么。<br>talk is cheap ,show me the code ：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Model</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.b = b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> c = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Model modelA = <span class="keyword">new</span> Model(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Model modelB = <span class="keyword">new</span> Model(<span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>存储结构如下：<br><a href="http://image.winrains.cn/2019/08/e3b37-20170615230126453.jpeg" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/e3b37-20170615230126453.jpeg" alt="20170615230126453"></a><br>从上图中可以看到，在方法区的instantKlass中有一个<code>int a=1</code>的数据存储。在堆内存中的两个对象的oop中，分别维护着<code>int b=3</code>,<code>int b=2</code>的实例数据。和oopDesc一样，instantKlass也维护着一些<code>fields</code>，用来保存类中定义的类数据，比如<code>int a=1</code>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个<code>instanceKlass</code>，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个<code>instanceOopDesc</code>对象，这个对象中包含了两部分信息，对象头以及元数据。对象头中有一些运行时数据，其中就包括和多线程相关的锁的信息。元数据其实维护的是指针，指向的是对象所属的类的<code>instanceKlass</code>。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://blog.csdn.net/linxdcn/article/details/73287490" target="_blank" rel="noopener">【理解HotSpot虚拟机】对象在jvm中的表示：OOP-Klass模型</a><br><a href="http://www.jianshu.com/p/b6cb4c694951" target="_blank" rel="noopener">Java反射: 从JDK到JVM全链路详解</a><br><a href="http://www.voidcn.com/article/p-pzznrtkc-ez.html" target="_blank" rel="noopener">HotSpotVM 对象机制实现浅析#1</a><br><a href="https://book.douban.com/subject/25847620/" target="_blank" rel="noopener">HotSpot实战</a></p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/1910" target="_blank" rel="noopener">https://www.hollischuang.com/archives/1910</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解多线程（一）：Synchronized的实现原理</title>
    <url>/2019/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ASynchronized%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><code>synchronized</code>，是Java中用于解决并发情况下数据同步访问的一个很重要的关键字。当我们想要保证一个共享资源在同一时间只会被一个线程访问到时，我们可以在代码中使用<code>synchronized</code>关键字对类或者对象加锁。那么，本文来介绍一下<code>synchronized</code>关键字的实现原理是什么。在阅读本文之间，建议先看下<a href="http://www.hollischuang.com/archives/1876" target="_blank" rel="noopener">Java虚拟机是如何执行线程同步的</a> 。</p>
<a id="more"></a>

<h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><p>众所周知，在Java中，<code>synchronized</code>有两种使用形式，同步方法和同步代码块。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hollis 17/11/9.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth1</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">synchronized</span> (SynchronizedTest<span class="class">.<span class="keyword">class</span>)</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.println(<span class="string">"Hello World"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们先来使用<a href="http://www.hollischuang.com/archives/1107" target="_blank" rel="noopener">Javap</a>来反编译以上代码，结果如下（部分无用信息过滤掉了）：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> synchronized <span class="built_in">void</span> doSth();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  descriptor: ()V</span></pre></td></tr><tr><td class="code"><pre><span class="line">  flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Code:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String Hello World</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> doSth1();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  descriptor: ()V</span></pre></td></tr><tr><td class="code"><pre><span class="line">  flags: ACC_PUBLIC</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Code:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">0</span>: ldc           #<span class="number">5</span>                  <span class="comment">// class com/hollis/SynchronizedTest</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">2</span>: dup</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">3</span>: astore_1</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">4</span>: monitorenter</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">5</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">8</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String Hello World</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">10</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">13</span>: aload_1</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">14</span>: monitorexit</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">15</span>: goto          <span class="number">23</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">18</span>: astore_2</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">19</span>: aload_1</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">20</span>: monitorexit</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">21</span>: aload_2</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">22</span>: athrow</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">23</span>: <span class="keyword">return</span></span></pre></td></tr></table></figure>

<p><a href="http://www.hollischuang.com/archives/58" target="_blank" rel="noopener">反编译</a>后，我们可以看到Java编译器为我们生成的字节码。在对于<code>doSth</code>和<code>doSth1</code>的处理上稍有不同。也就是说。JVM对于同步方法和同步代码块的处理方式不同。<br>对于同步方法，JVM采用<code>ACC_SYNCHRONIZED</code>标记符来实现同步。 对于同步代码块。JVM采用<code>monitorenter</code>、<code>monitorexit</code>两个指令来实现同步。<br>关于这部分内容，在<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.14" target="_blank" rel="noopener">JVM规范</a>中也可以找到相关的描述。</p>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10" target="_blank" rel="noopener">The Java® Virtual Machine Specification</a>中有关于方法级同步的介绍：</p>
<blockquote>
<p>Method-level synchronization is performed implicitly, as part of method invocation and return. A synchronized method is distinguished in the run-time constant pool’s method_info structure by the ACC_SYNCHRONIZED flag, which is checked by the method invocation instructions. When invoking a method for which ACC_SYNCHRONIZED is set, the executing thread enters a monitor, invokes the method itself, and exits the monitor whether the method invocation completes normally or abruptly. During the time the executing thread owns the monitor, no other thread may enter it. If an exception is thrown during invocation of the synchronized method and the synchronized method does not handle the exception, the monitor for the method is automatically exited before the exception is rethrown out of the synchronized method.</p>
</blockquote>
<p>主要说的是： 方法级的同步是隐式的。同步方法的常量池中会有一个<code>ACC_SYNCHRONIZED</code>标志。当某个线程要访问某个方法的时候，会检查是否有<code>ACC_SYNCHRONIZED</code>，如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁。这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。</p>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>同步代码块使用<code>monitorenter</code>和<code>monitorexit</code>两个指令实现。 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html" target="_blank" rel="noopener">The Java® Virtual Machine Specification</a> 中有关于这两个指令的介绍：</p>
<h4 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h4><blockquote>
<p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:</p>
<blockquote>
<p>If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.<br>If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.<br>If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.</p>
</blockquote>
</blockquote>
<h4 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h4><blockquote>
<p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.<br>The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p>
</blockquote>
<p>大致内容如下： 可以把执行<code>monitorenter</code>指令理解为加锁，执行<code>monitorexit</code>理解为释放锁。 每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁（执行<code>monitorenter</code>）后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁（执行<code>monitorexit</code>指令）的时候，计数器再自减。当计数器为0的时候。锁将被释放，其他线程便可以获得锁。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>同步方法通过<code>ACC_SYNCHRONIZED</code>关键字隐式的对方法进行加锁。当线程要执行的方法被标注上<code>ACC_SYNCHRONIZED</code>时，需要先获得锁才能执行该方法。<br>同步代码块通过<code>monitorenter</code>和<code>monitorexit</code>执行来进行加锁。当线程执行到<code>monitorenter</code>的时候要先获得所锁，才能执行后面的方法。当线程执行到<code>monitorexit</code>的时候则要释放锁。<br>每个对象自身维护这一个被加锁次数的计数器，当计数器数字为0时表示可以被任意线程获得锁。当计数器不为0时，只有获得锁的线程才能再次获得锁。即可重入锁。</p>
</blockquote>
<p>至此，我们大致了解了Synchronized的原理。但是还有几个问题并没有介绍清楚，比如，Monitor到底是什么？对象的锁的状态保存在哪里？ 别急，后面会再介绍。</p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/1883" target="_blank" rel="noopener">https://www.hollischuang.com/archives/1883</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>Synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>同步容器Vector并不是所有操作都线程安全</title>
    <url>/2019/12/26/%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8Vector%E5%B9%B6%E4%B8%8D%E6%98%AF%E6%89%80%E6%9C%89%E6%93%8D%E4%BD%9C%E9%83%BD%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h3 id="问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？"><a href="#问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？" class="headerlink" title="问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？"></a><strong>问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？</strong></h3><p><strong>答：同步容器中的所有自带方法都是线程安全的，因为方法都使用<code>synchronized</code>关键字标注。但是，对这些集合类的复合操作无法保证其线程安全性。需要客户端通过主动加锁来保证</strong><br>如果你看过JDK的源码，那么你会发现，像Vector这样的同步容器的所有共有方法全都是<code>synchronized</code>的。也就是说，我们可以在多线程场景中放心的使用<strong>单独</strong>这些方法，因为这些方法本身的确是线程安全的。那么为什么又说复合操作无法保证线程安全呢？这里举个栗子，我们定义如下删除Vector中最后一个元素方法：</p>
<a id="more"></a>

<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">deleteLast</span><span class="params">(Vector v)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> lastIndex  = v.<span class="built_in">size</span>()<span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    v.<span class="built_in">remove</span>(lastIndex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面这个方法是一个复合方法，包括<code>size(）</code>和<code>remove()</code>，乍一看上去好像并没有什么问题，无论是<code>size()</code>方法还是<code>remove()</code>方法都是线程安全的，那么整个<code>deleteLast</code>方法应该也是线程安全的。但是时，如果多线程调用该方法的过程中有，<code>remove</code>方法有可能抛出<code>ArrayIndexOutOfBoundsException</code>。我们看一下<code>remove</code>方法具体实现，什么情况下会抛出这个异常呢。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> synchronized E remove(<span class="keyword">int</span> <span class="keyword">index</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    modCount++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">index</span> &gt;= elementCount)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="keyword">index</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    E oldValue = elementData(<span class="keyword">index</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> numMoved = elementCount - <span class="keyword">index</span> - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.arraycopy(elementData, <span class="keyword">index</span>+<span class="number">1</span>, elementData, <span class="keyword">index</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                         numMoved);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> oldValue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>从上面代码中可以看出，当<code>index &gt;= elementCount</code>时，会抛出<code>ArrayIndexOutOfBoundsException</code>，也就是说，当当前索引值不再有效的时候，将会抛出这个异常。因为<code>removeLast</code>方法，有可能被多个线程同时执行，当线程一通过<code>index()</code>获得索引值为10，在尝试通过<code>remove()</code>删除该索引位置的元素之前，线程2把该索引位置的值删除掉了，这时线程一在执行时便会抛出异常。<br>为了避免出现类似问题，可以尝试加锁：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    synchronized (v) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> index = v.<span class="built_in">size</span>() - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        v.<span class="built_in">remove</span>(index);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如上，我们在<code>deleteLast</code>中，对v进行加锁，即可保证同一时刻，不会有其他线程删除掉v中的元素。<br>至此，我们已经解释清楚了我们的问题。</p>
<h3 id="问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？-1"><a href="#问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？-1" class="headerlink" title="问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？"></a><strong>问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？</strong></h3><p><strong>答：同步容器中的所有自带方法都是线程安全的，因为方法都使用<code>synchronized</code>关键字标注。但是，对这些集合类的复合操作无法保证其线程安全性。需要客户端通过主动加锁来保证。</strong><br>由于我们自己已知<code>Vector</code>等同步容器是线程安全的，所以我们通常在多线程场景中会直接拿来使用，并不会考虑太多，从而可能导致问题。<br>所以，我们在使用同步容器的时候，如果只使用其中的自带方法，那么可以放心使用，因为他们是线程安全的，但是如果我们想做复合操作，尤其是涉及到删除容器中的元素时，一定要注意是否需要客户端主动加锁。<br>下面，我们考虑以下代码，如果在多线程场景中使用会不会出现线程安全问题：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &lt; v.size(); i++) &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="name">v</span>.get(<span class="name">i</span>))<span class="comment">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>显然，以上代码在迭代的过程中，并不会出现线程安全问题。但是，如果在程序中还有以下代码有可能被同时调用呢？</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; v.<span class="built_in">size</span>(); <span class="built_in">i</span>++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    v.remove(<span class="built_in">i</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>由于，不同线程在同一时间操作同一个Vector，其中包括删除操作，那么就同样有可能发生线程安全问题。所以，在使用同步容器的时候，如果涉及到多个线程同时执行删除操作，就要考虑下是否需要加锁。</p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/1786" target="_blank" rel="noopener">https://www.hollischuang.com/archives/1786</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>线程安全</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中String类型是否有长度限制</title>
    <url>/2019/12/26/Java%E4%B8%ADString%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E6%9C%89%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/</url>
    <content><![CDATA[<p>String是Java中很重要的一个数据类型，除了基本数据类型以外，String是被使用的最广泛的了，但是，关于String，其实还是有很多东西容易被忽略的。就如本文我们要讨论的问题：Java中的String有没有长度限制？这个问题要分两个阶段看，分别是编译期和运行期。不同的时期限制不一样。</p>
<a id="more"></a>

<h3 id="编译期"><a href="#编译期" class="headerlink" title="编译期"></a>编译期</h3><p>首先，我们先来合理的推断一下，当我们在代码中使用String s = “”;的形式来定义String对象的时候，””中字符的个数有没有限制呢？<br>既然是合理的推断，那就要要足够的依据，所以我们可以从String的源码入手，根据public String(char value[], int offset, int count)的定义，count是int类型的，所以，char value[]中最多可以保存Integer.MAX_VALUE个,即2147483647字符。(jdk1.8.0_73)<br>但是，实验证明，String s = “”;中，最多可以有65534个字符。如果超过这个个数。就会在编译期报错。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">String</span> s = <span class="string">"a...a"</span>;<span class="comment">// 共65534个a</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.<span class="built_in">println</span>(s.length());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">String</span> s1 = <span class="string">"a...a"</span>;<span class="comment">// 共65535个a</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.<span class="built_in">println</span>(s1.length());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>以上代码，会在String s1 = “a…a”;// 共65535个a处编译失败：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">✗ javac <span class="module-access"><span class="module"><span class="identifier">StringLenghDemo</span>.</span></span>java</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">StringLenghDemo</span>.</span></span>java:<span class="number">11</span>: 错误: 常量字符串过长</span></pre></td></tr></table></figure>

<p><strong>明明说好的长度限制是2147483647，为什么65535个字符就无法编译了呢？</strong><br>当我们使用字符串字面量直接定义String的时候，是会把字符串在常量池中存储一份的。那么上面提到的65534其实是常量池的限制。<br>常量池中的每一种数据项也有自己的类型。Java中的UTF-8编码的Unicode字符串在常量池中以CONSTANT_Utf8类型表示。<br>CONSTANTUtf8info是一个CONSTANTUtf8类型的常量池数据项，它存储的是一个常量字符串。常量池中的所有字面量几乎都是通过CONSTANTUtf8info描述的。CONSTANTUtf8_info的定义如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">CONSTANT_Utf8_info</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">u1</span> tag;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">u2</span> length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">u1</span> bytes[length];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>由于本文的重点并不是CONSTANTUtf8info的介绍，这里就不详细展开了，我们只需要我们使用字面量定义的字符串在class文件中，是使用CONSTANTUtf8info存储的，而CONSTANTUtf8info中有u2 length;表明了该类型存储数据的长度。<br>u2是无符号的16位整数，因此理论上允许的的最大长度是2^16=65536。而 java class 文件是使用一种变体UTF-8格式来存放字符的，null 值使用两个 字节来表示，因此只剩下 65536－ 2 ＝ 65534个字节。<br>关于这一点，在the class file format spec中也有明确说明：</p>
<blockquote>
<p>The length of field and method names, field and method descriptors, and other constant string values is limited to 65535 characters by the 16-bit unsigned length item of the CONSTANTUtf8info structure (§4.4.7). Note that the limit is on the number of bytes in the encoding and not on the number of encoded characters. UTF-8 encodes some characters using two or three bytes. Thus, strings incorporating multibyte characters are further constrained.</p>
</blockquote>
<p><strong>也就是说，在Java中，所有需要保存在常量池中的数据，长度最大不能超过65535，这当然也包括字符串的定义咯。</strong></p>
<h3 id="运行期"><a href="#运行期" class="headerlink" title="运行期"></a>运行期</h3><p>上面提到的这种String长度的限制是编译期的限制，也就是使用String s= “”;这种字面值方式定义的时候才会有的限制。<br>那么。String在运行期有没有限制呢，答案是有的，就是我们前文提到的那个Integer.MAX_VALUE ，这个值约等于4G，在运行期，如果String的长度超过这个范围，就可能会抛出异常。(在jdk 1.9之前）<br>int 是一个 32 位变量类型，取正数部分来算的话，他们最长可以有</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>^<span class="number">31</span>-<span class="number">1</span> =<span class="number">2147483647</span> 个 <span class="number">16</span>-bit Unicodecharacter</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">2147483647 </span>* <span class="number">16</span> = <span class="number">34359738352</span> 位</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">34359738352 </span>/ <span class="number">8</span> = <span class="number">4294967294</span> (Byte)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">4294967294 </span>/ <span class="number">1024</span> = <span class="number">4194303.998046875</span> (KB)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4194303.998046875</span> / <span class="number">1024</span> = <span class="number">4095.9999980926513671875</span> (MB)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4095.9999980926513671875</span> / <span class="number">1024</span> = <span class="number">3.99999999813735485076904296875</span> (GB)</span></pre></td></tr></table></figure>

<p>有近 4G 的容量。</p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/3916" target="_blank" rel="noopener">https://www.hollischuang.com/archives/3916</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>工厂模式介绍</title>
    <url>/2019/12/26/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>很多人认为工厂模式很简单，只是有一个建造工厂，帮我们进行对象构造而已。那么请尝试回答下以下问题：</p>
<blockquote>
<p>1、工厂模式分为几类？<br>2、GOF 23种设计模式中，工厂方法模式和抽象工厂模式有什么区别？<br>3、不在GOF 23种设计模式中的简单工厂模式是什么？<br>4、简单工厂模式、工厂方法模式和抽象工厂模式各自解决什么问题？有什么不同？</p>
</blockquote>
<p>如果以上四个问题，你都可以很好的回答的话，那么这篇文章就没有继续读下去的必要了，否则，建议你好好学习下本文。</p>
<a id="more"></a>

<h3 id="三种工厂模式"><a href="#三种工厂模式" class="headerlink" title="三种工厂模式"></a>三种工厂模式</h3><p>工厂模式可以分为三类：</p>
<ul>
<li>1）简单工厂模式（Simple Factory）</li>
<li>2）工厂方法模式（Factory Method）</li>
<li>3）抽象工厂模式（Abstract Factory）</li>
</ul>
<p>这三种模式从上到下逐步抽象，并且更具一般性。<br>GOF在《设计模式》一书中将工厂模式分为两类：工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）。<br>将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。<br>这三种工厂模式在设计模式的分类中都属于<strong>创建型模式</strong>。<br>创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。<br>创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。<br>创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。<br>工厂模式是创建型模式中比较重要的。工厂模式的主要功能就是帮助我们实例化对象的。<strong>之所以名字中包含工厂模式四个字，是因为对象的实例化过程是通过工厂实现的，是用工厂代替new操作的。</strong><br>这样做的好处是封装了对象的实例化细节，尤其是对于实例化较复杂或者对象的生命周期应该集中管理的情况。会给你系统带来更大的可扩展性和尽量少的修改量。<br>接下来我们分别介绍下这三种工厂模式。</p>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。<br>在介绍简单工厂模式之前，我们尝试解决以下问题：<br>现在我们要使用面向对象的形式定义计算器，为了实现各算法之间的解耦。主要的用到的类如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算类的基类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> double value1 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> double value2 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public double getValue1() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> value1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void setValue1(double value1) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.value1 = value1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public double getValue2() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> value2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void setValue2(double value2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.value2 = value2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> double getResule();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//加法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> double getResule() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> getValue1() + getValue2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//减法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OperationSub</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> double getResule() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> getValue1() - getValue2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//乘法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OperationMul</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> double getResule() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> getValue1() * getValue2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//除法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OperationDiv</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> double getResule() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (getValue2() != <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> getValue1() / getValue2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"除数不能为零"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>当我想要执行加法运算时，可以使用如下代码：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        OperationAdd operationAdd = <span class="keyword">new</span> OperationAdd();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        operationAdd.setValue1(<span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        operationAdd.setValue2(<span class="number">5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(operationAdd.getResule());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>当我需要执行减法运算时，我就要创建一个OperationSub类。也就是说，我想要使用不同的运算的时候就要创建不同的类，并且要明确知道该类的名字。<br>那么这种重复的创建类的工作其实可以放到一个统一的工厂类中。简单工厂模式有以下优点：</p>
<blockquote>
<p>1、一个调用者想创建一个对象，只要知道其名称就可以了。<br>2、屏蔽产品的具体实现，调用者只关心产品的接口。</p>
</blockquote>
<h4 id="简单工厂模式实现方式"><a href="#简单工厂模式实现方式" class="headerlink" title="简单工厂模式实现方式"></a><strong>简单工厂模式实现方式</strong></h4><p>简单工厂模式其实和他的名字一样，很简单。先来看看它的组成:</p>
<blockquote>
<p>Factory:这是本模式的核心,含有一定的商业逻辑和判断逻辑。在java中它往往由 一个具体类实现。（OperationFactory）<br>Product:它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。（Operation）<br>ConcreteProduct:工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。 来用类图来清晰的表示下的它们之间的关系（OperationAdd\OperationSub等）</p>
</blockquote>
<p><img src="http://image.winrains.cn/2019/08/c5e3c-15588649289622.jpg" alt="img"><br>在原有类的基础上，定义工厂类：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工厂类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Operation createOperation(<span class="keyword">String</span> operation) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Operation oper = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">"+"</span>:<span class="type"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="type">                oper </span>= <span class="keyword">new</span> <span class="type">OperationAdd</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">"-"</span>:<span class="type"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="type">                oper </span>= <span class="keyword">new</span> <span class="type">OperationSub</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">"*"</span>:<span class="type"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="type">                oper </span>= <span class="keyword">new</span> <span class="type">OperationMul</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">"/"</span>:<span class="type"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="type">                oper </span>= <span class="keyword">new</span> <span class="type">OperationDiv</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">default</span>:<span class="type"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="type">                throw new UnsupportedOperationException</span>(<span class="string">"不支持该操作"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> oper;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>有了工厂类之后，可以使用工厂创建对象：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Operation operationAdd = <span class="module-access"><span class="module"><span class="identifier">OperationFactory</span>.</span></span>create<span class="constructor">Operation(<span class="string">"+"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">operationAdd.set<span class="constructor">Value1(10)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">operationAdd.set<span class="constructor">Value2(5)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(operationAdd.get<span class="constructor">Resule()</span>);</span></pre></td></tr></table></figure>

<p>通过简单工厂模式，该计算器的使用者不需要关系实现加法逻辑的那个类的具体名字，他只要知道该类对应的参数”+”就可以了。</p>
<h4 id="简单工厂模式存在的问题"><a href="#简单工厂模式存在的问题" class="headerlink" title="简单工厂模式存在的问题"></a><strong>简单工厂模式存在的问题</strong></h4><p>当我们需要增加一种计算时，例如开平方。这个时候我们需要先定义一个类继承<code>Operation</code>类，其中实现平方的代码。除此之外我们还要修改<code>OperationFactory</code>类的代码，增加一个case。这显然是违背开闭原则的。可想而知对于新产品的加入，工厂类是很被动的。<br>我们举的例子是最简单的情况。而在实际应用中，很可能产品是一个多层次的树状结构。 简单工厂可能就不太适用了。</p>
<h4 id="简单工厂模式总结"><a href="#简单工厂模式总结" class="headerlink" title="简单工厂模式总结"></a><strong>简单工厂模式总结</strong></h4><p>工厂类是整个简单工厂模式的关键。包含了必要的逻辑判断，根据外界给定的信息，决定究竟应该创建哪个具体类的对象。通过使用工厂类，外界可以从直接创建具体产品对象的尴尬局面摆脱出来，仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的。明确了各自的职责和权利，有利于整个软件体系结构的优化。<br>但是由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。<br>当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；<br>这些缺点在工厂方法模式中得到了一定的解决。</p>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。<br>工厂方法模式是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。</p>
<blockquote>
<p>工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。”</p>
</blockquote>
<h4 id="工厂方法模式用途"><a href="#工厂方法模式用途" class="headerlink" title="工厂方法模式用途"></a><strong>工厂方法模式用途</strong></h4><p>工厂方法模式和简单工厂模式虽然都是通过工厂来创建对象，他们之间最大的不同是——<strong>工厂方法模式在设计上完全完全符合“开闭原则”。</strong><br>在以下情况下可以使用工厂方法模式：</p>
<blockquote>
<p>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。<br>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。<br>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</p>
</blockquote>
<h4 id="工厂方法模式实现方式"><a href="#工厂方法模式实现方式" class="headerlink" title="工厂方法模式实现方式"></a><strong>工厂方法模式实现方式</strong></h4><p>工厂方法模式包含如下角色：</p>
<blockquote>
<p>Product：抽象产品（<code>Operation</code>）<br>ConcreteProduct：具体产品(<code>OperationAdd</code>)<br>Factory：抽象工厂(<code>IFactory</code>)<br>ConcreteFactory：具体工厂(<code>AddFactory</code>)</p>
</blockquote>
<p><img src="http://image.winrains.cn/2019/08/7fbba-15588647240804.jpg" alt="img"><br>这里还用计算器的例子。在保持<code>Operation</code>，<code>OperationAdd</code>，<code>OperationDiv</code>，<code>OperationSub</code>，<code>OperationMul</code>等几个方法不变的情况下，修改简单工厂模式中的工厂类（<code>OperationFactory</code>）。替代原有的那个”万能”的大工厂类，这里使用工厂方法来代替：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工厂接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">Operation <span class="title">CreateOption</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//加法类工厂</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOption</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationAdd();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//除法类工厂</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOption</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationDiv();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//除法类工厂</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOption</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationMul();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//减法类工厂</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOption</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationSub();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这样，在客户端中想要执行加法运算时，需要以下方式：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        IFactory factory = <span class="keyword">new</span> AddFactory();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Operation operationAdd =  factory.CreateOption();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        operationAdd.setValue1(<span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        operationAdd.setValue2(<span class="number">5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(operationAdd.<span class="built_in">getResult</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>到这里，一个工厂方法模式就已经写好了。<br>从代码量上看，这种工厂方法模式比简单工厂方法模式更加复杂。针对不同的操作（Operation）类都有对应的工厂。很多人会有以下疑问：</p>
<blockquote>
<p>貌似工厂方法模式比简单工厂模式要复杂的多？<br>工厂方法模式和我自己创建对象没什么区别？为什么要多搞出一些工厂来？</p>
</blockquote>
<p>下面就针对以上两个问题来深入理解一下工厂方法模式。</p>
<h4 id="为什么要使用工厂来创建对象？"><a href="#为什么要使用工厂来创建对象？" class="headerlink" title="为什么要使用工厂来创建对象？"></a><strong>为什么要使用工厂来创建对象？</strong></h4><blockquote>
<p>封装对象的创建过程</p>
</blockquote>
<p>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户<strong>隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</strong><br>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。<strong>它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。</strong>工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</p>
<h4 id="为什么每种对象要单独有一个工厂？"><a href="#为什么每种对象要单独有一个工厂？" class="headerlink" title="为什么每种对象要单独有一个工厂？"></a><strong>为什么每种对象要单独有一个工厂？</strong></h4><blockquote>
<p>符合『开放-封闭原则』</p>
</blockquote>
<p>主要目的是为了解耦。在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则。<br>以上就是工厂方法模式的优点。但是，工厂模式也有一些不尽如人意的地方：</p>
<blockquote>
<p>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。<br>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</p>
</blockquote>
<h4 id="工厂方法模式总结"><a href="#工厂方法模式总结" class="headerlink" title="工厂方法模式总结"></a><strong>工厂方法模式总结</strong></h4><p>工厂方法模式是简单工厂模式的进一步抽象和推广。<br>由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。<br>在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。<br>工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。<br>抽象工厂模式提供了一种方式，可以将同一产品族的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。</p>
<h4 id="产品族"><a href="#产品族" class="headerlink" title="产品族"></a><strong>产品族</strong></h4><p>来认识下什么是产品族: 位于不同产品等级结构中,功能相关的产品组成的家族。如下面的例子，就有两个产品族：跑车族和商务车族。<br><img src="http://image.winrains.cn/2019/08/5a461-15588644956826.jpg" alt="img"></p>
<h4 id="抽象工厂模式用途"><a href="#抽象工厂模式用途" class="headerlink" title="抽象工厂模式用途"></a><strong>抽象工厂模式用途</strong></h4><p>抽象工厂模式和工厂方法模式一样，都符合开放-封闭原则。但是不同的是，工厂方法模式在增加一个具体产品的时候，都要增加对应的工厂。但是抽象工厂模式只有在新增一个类型的具体产品时才需要新增工厂。也就是说，工厂方法模式的一个工厂只能创建一个具体产品。而抽象工厂模式的一个工厂可以创建属于一类类型的多种具体产品。工厂创建产品的个数介于简单工厂模式和工厂方法模式之间。<br>在以下情况下可以使用抽象工厂模式：</p>
<blockquote>
<p>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。<br>系统中有多于一个的产品族，而每次只使用其中某一产品族。<br>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。<br>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</p>
</blockquote>
<h4 id="抽象工厂模式实现方式"><a href="#抽象工厂模式实现方式" class="headerlink" title="抽象工厂模式实现方式"></a><strong>抽象工厂模式实现方式</strong></h4><p>抽象工厂模式包含如下角色：</p>
<blockquote>
<p>AbstractFactory(抽象工厂)：用于声明生成抽象产品的方法<br>ConcreteFactory(具体工厂)：实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中；<br>AbstractProduct(抽象产品)：为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法；<br>Product(具体产品)：定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。</p>
</blockquote>
<p>本文的例子采用一个汽车代工厂造汽车的例子。假设我们是一家汽车代工厂商，我们负责给奔驰和特斯拉两家公司制造车子。我们简单的把奔驰车理解为需要加油的车，特斯拉为需要充电的车。其中奔驰车中包含跑车和商务车两种，特斯拉同样也包含奔驰车和商务车。<br><img src="http://image.winrains.cn/2019/08/c1a96-15588645213493.jpg" alt="img"><br>以上场景，我们就可以把跑车和商务车分别对待，对于跑车有单独的工厂创建，商务车也有单独的工厂。这样，以后无论是再帮任何其他厂商造车，只要是跑车或者商务车我们都不需要再引入工厂。同样，如果我们要增加一种其他类型的车，比如越野车，我们也不需要对跑车或者商务车的任何东西做修改。<br>下面是抽象产品，奔驰车和特斯拉车：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">BenzCar</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//加汽油</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> gasUp();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">TeslaCar</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//充电</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> charge();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>下面是具体产品，奔驰跑车、奔驰商务车、特斯拉跑车、特斯拉商务车：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">BenzSportCar</span> <span class="symbol">implements</span> <span class="symbol">BenzCar</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> gasUp() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"给我的奔驰跑车加最好的汽油"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">BenzBusinessCar</span> <span class="symbol">implements</span> <span class="symbol">BenzCar</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> gasUp() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"给我的奔驰商务车加一般的汽油"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">TeslaSportCar</span> <span class="symbol">implements</span> <span class="symbol">TeslaCar</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> charge() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"给我特斯拉跑车冲满电"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">TeslaBusinessCar</span> <span class="symbol">implements</span> <span class="symbol">TeslaCar</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> charge() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"不用给我特斯拉商务车冲满电"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>下面是抽象工厂：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>CarFactory &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public BenzCar getBenzCar();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public TeslaCar getTeslaCar();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>下面是具体工厂：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SportCarFactory</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">CarFactory</span></span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> BenzCar getBenzCar() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">BenzSportCar</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> TeslaCar getTeslaCar() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">TeslaSportCar</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessCarFactory</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">CarFactory</span></span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> BenzCar getBenzCar() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">BenzBusinessCar</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> TeslaCar getTeslaCar() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">TeslaBusinessCar</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="“开闭原则”的倾斜性"><a href="#“开闭原则”的倾斜性" class="headerlink" title="“开闭原则”的倾斜性"></a><strong>“开闭原则”的倾斜性</strong></h4><p>“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的。对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：</p>
<blockquote>
<p>增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。<br>增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持“开闭原则”。</p>
</blockquote>
<p>抽象工厂模式的这种性质称为“开闭原则”的倾斜性，抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，但不能为新的产品等级结构的增加提供这样的方便。</p>
<h4 id="抽象工厂模式总结"><a href="#抽象工厂模式总结" class="headerlink" title="抽象工厂模式总结"></a><strong>抽象工厂模式总结</strong></h4><p>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。<br>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。<br>抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。</p>
<h3 id="三种工厂模式对比"><a href="#三种工厂模式对比" class="headerlink" title="三种工厂模式对比"></a>三种工厂模式对比</h3><h4 id="简单工厂模式的优缺点"><a href="#简单工厂模式的优缺点" class="headerlink" title="简单工厂模式的优缺点"></a><strong>简单工厂模式的优缺点</strong></h4><ul>
<li>优点：<ul>
<li>1、屏蔽产品的具体实现，调用者只关心产品的接口。</li>
<li>2、实现简单</li>
</ul>
</li>
<li>缺点：<ul>
<li>1、增加产品，需要修改工厂类，不符合开放-封闭原则</li>
<li>2、工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则</li>
</ul>
</li>
</ul>
<h4 id="工厂方法模式的优缺点"><a href="#工厂方法模式的优缺点" class="headerlink" title="工厂方法模式的优缺点"></a><strong>工厂方法模式的优缺点</strong></h4><ul>
<li>优点：<ul>
<li>1、继承了简单工厂模式的优点</li>
<li>2、符合开放-封闭原则</li>
</ul>
</li>
<li>缺点：<ul>
<li>1、增加产品，需要增加新的工厂类，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</li>
</ul>
</li>
</ul>
<h4 id="抽象工厂模式的优缺点"><a href="#抽象工厂模式的优缺点" class="headerlink" title="抽象工厂模式的优缺点"></a><strong>抽象工厂模式的优缺点</strong></h4><ul>
<li>优点：<ul>
<li>1、隔离了具体类的生成，使得客户并不需要知道什么被创建</li>
<li>2、每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；</li>
</ul>
</li>
<li>缺点<ul>
<li>增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。</li>
</ul>
</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/eb056-15588638543500.jpg" alt="img"><br>简单工厂 ： 用来生产同一等级结构中的任意产品。（对于增加新的产品，主要是新增产品，就要修改工厂类。符合单一职责原则。不符合开放-封闭原则）<br>工厂方法 ：用来生产同一等级结构中的固定产品。（支持增加任意产品，新增产品时不需要更改已有的工厂，需要增加该产品对应的工厂。符合单一职责原则、符合开放-封闭原则。但是引入了复杂性）<br>抽象工厂 ：用来生产不同产品族的全部产品。（增加新产品时，需要修改工厂，增加产品族时，需要增加工厂。符合单一职责原则，部分符合开放-封闭原则，降低了复杂性）<br>最后，三种工厂模式各有优缺点，没有最好的，只有最合适的！</p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/3709" target="_blank" rel="noopener">https://www.hollischuang.com/archives/3709</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>工厂模式</category>
      </categories>
  </entry>
  <entry>
    <title>IntelliJ IDEA必装插件</title>
    <url>/2019/12/26/IntelliJ-IDEA%E5%BF%85%E8%A3%85%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>本文，给大家推荐几款我私藏已久的，自己经常使用的，可以提升代码效率的插件。</p>
<a id="more"></a>

<h2 id="IDEA插件简介"><a href="#IDEA插件简介" class="headerlink" title="IDEA插件简介"></a>IDEA插件简介</h2><p>常见的IDEA插件主要有如下几类：</p>
<h3 id="常用工具支持"><a href="#常用工具支持" class="headerlink" title="常用工具支持"></a>常用工具支持</h3><p>Java日常开发需要接触到很多常用的工具，为了便于使用，很多工具也有IDEA插件供开发使用，其中大部分已经在IDEA中默认集成了。例如maven、git、svn、tomcat、jetty、jrebel、Gradle等。</p>
<h3 id="功能增强"><a href="#功能增强" class="headerlink" title="功能增强"></a>功能增强</h3><p>还有些插件提供了一些IDE中不具有的功能，比如静态代码扫描、代码自动生成等。</p>
<h3 id="框架集成"><a href="#框架集成" class="headerlink" title="框架集成"></a>框架集成</h3><p>集成框架主要是为了提供框架定制的代码和配置的生成，以及快速的访问框架提供的功能。例如集成Spring框架，Mybatis框架等。</p>
<h3 id="UI定制化及优化"><a href="#UI定制化及优化" class="headerlink" title="UI定制化及优化"></a>UI定制化及优化</h3><p>UI定制化相关的插件主要提供一下个性化需求定制，例如修改编辑区的背景图片插件、修改代码颜色等。</p>
<h3 id="其他编程语言支持"><a href="#其他编程语言支持" class="headerlink" title="其他编程语言支持"></a>其他编程语言支持</h3><p>IDEA主要支持Java，为了使用其他语言，可以使用一些支持其他语言的插件，通过这些插件可以实现语法分析，配色主题，代码格式化和提示等功能。例如Go语言的支持的插件。</p>
<h3 id="个人或者公司特殊需求"><a href="#个人或者公司特殊需求" class="headerlink" title="个人或者公司特殊需求"></a>个人或者公司特殊需求</h3><p>公司内部插件</p>
<h2 id="我的插件一览"><a href="#我的插件一览" class="headerlink" title="我的插件一览"></a>我的插件一览</h2><p>这里简单介绍一些笔者日常开发中使用到的插件。 以下是我的IDEA中自己安装的插件列表。这些插件都是我经过很长时间的使用之后最终保留下来的，都是值得安装的一些插件。其中被我打码的就是公司内部插件。<br><img src="http://image.winrains.cn/2019/08/40c4f-15479665089765.jpg" alt="img"></p>
<h2 id="IDEA插件安装"><a href="#IDEA插件安装" class="headerlink" title="IDEA插件安装"></a>IDEA插件安装</h2><p>IDEA的插件安装非常简单，对于很多插件来说，只要你知道插件的名字就可以在IDEA里面直接安装。<br>Preferences—&gt;Plugins—&gt;查找所需插件—&gt;Install<br>或者<br>Preferences—&gt;Plugins—&gt;Install plug from disk —&gt;选择下载好的插件安装<br>安装之后重启IDEA即可生效</p>
<h3 id="IDEA插件仓库"><a href="#IDEA插件仓库" class="headerlink" title="IDEA插件仓库"></a>IDEA插件仓库</h3><p>IntelliJ IDEA激发了许多Java开发人员编写插件， IntelliJ IDEA Plugins（<a href="https://plugins.jetbrains.com/?idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/?idea</a> ）中目前包含3000+个插件并且还在不断增长。<br><img src="http://image.winrains.cn/2019/08/58b19-15479620248612.jpg" alt="img"></p>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><p>作者目前使用的IntelliJ IDEA版本是专业版2018.2.4（Ultimate Edition）<br><img src="http://image.winrains.cn/2019/08/4483c-15479603329394.jpg" alt="img"><br>很多插件中提供的功能在这个版本中都已经集成进来了，这里简单说几个可能比较常用的，这几种功能就无需加装插件了。</p>
<h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><p>目前，IDEA支持设置背景图片。这对于广大程序员来说无疑是个好功能。整日对着枯燥的代码实在是会让人疲乏。要是可以设置一张美女图片的话。。。<br><strong>设置方法</strong><br>Ctrl+Shift+A(或者help -&gt; find action)调用弹窗后输入Set Background Image<br><img src="http://image.winrains.cn/2019/08/28b10-15479606563989.jpg" alt="img"><br>在里面设定要设置为Image的图片,透明度调到15左右，保存即可。<br><img src="http://image.winrains.cn/2019/08/1ac63-15479609892646.jpg" alt="img"><br><strong>效果如下</strong><br><img src="http://image.winrains.cn/2019/08/a4dfc-15479609485695.jpg" alt="img"></p>
<h3 id="内置terminal"><a href="#内置terminal" class="headerlink" title="内置terminal"></a>内置terminal</h3><p>目前IntelliJ IDEA已经有一个内置的terminal工具，可以方便的使用shell命令。<br><img src="http://image.winrains.cn/2019/08/75127-15479610703144.jpg" alt="img"></p>
<h3 id="内置support"><a href="#内置support" class="headerlink" title="内置support"></a>内置support</h3><p>目前很多新版本的IntelliJ IDEA中，已经内置了很多support插件，比如我们常用的markdown support 、UML support 以及 android support等。<br><img src="http://image.winrains.cn/2019/08/f2924-15479615077554.jpg" alt="img"><br>PS：由于作者使用的是专业版，不知道社区版是否也会内置这些插件，如果没有内置的话，读者可以根据需要自行下载相关插件并安装。<br>有了markdowm support插件以后，就可以直接预览md语法的内容了。<br><img src="http://image.winrains.cn/2019/08/761da-15479618675094.jpg" alt="img"></p>
<h2 id="必备插件"><a href="#必备插件" class="headerlink" title="必备插件"></a>必备插件</h2><h3 id="Maven-Helper"><a href="#Maven-Helper" class="headerlink" title="Maven Helper"></a>Maven Helper</h3><p>目前，Java开发很多都在使用maven进行项目管理和自动构建。<br>日常开发中，可能经常会遇到jar包冲突等问题，就需要通过查看maven依赖树来查查看依赖情况。这种方式不是很高效，这里推荐一个插件，安装之后，直接打开pom文件，即可查看依赖数，还能自动分析是否存在jar包冲突。<br>一旦安装了Maven Helper插件，只要打开pom文件，就可以打开该pom文件的Dependency Analyzer视图（在文件打开之后，文件下面会多出这样一个tab）。<br><img src="http://image.winrains.cn/2019/08/3d81a-15479624935730.jpg" alt="img"><br>进入Dependency Analyzer视图之后有三个查看选项，分别是Conflicts(冲突)、All Dependencies as List(列表形式查看所有依赖)、All Dependencies as Tree(树结构查看所有依赖)。并且这个页面还支持搜索。</p>
<h3 id="FindBugs-IDEA"><a href="#FindBugs-IDEA" class="headerlink" title="FindBugs-IDEA"></a>FindBugs-IDEA</h3><p>FindBugs很多人都并不陌生，Eclipse中有插件可以帮助查找代码中隐藏的bug，IDEA中也有这款插件。<br>使用方法很简单，就是可以对多种级别的内容进行finbugs<br><img src="http://image.winrains.cn/2019/08/a365c-15479625706835.png" alt="img"><br>分析完之后会有一个视图进行提示，详细的说明是哪种问题。<br><img src="http://image.winrains.cn/2019/08/c79aa-15479625758685.png" alt="img"><br>按照提示解决完问题之后再执行findbug查看情况即可。</p>
<h3 id="阿里巴巴代码规约检测"><a href="#阿里巴巴代码规约检测" class="headerlink" title="阿里巴巴代码规约检测"></a>阿里巴巴代码规约检测</h3><p>2017年10月14日杭州云栖大会，Java代码规约扫描插件全球首发仪式正式启动，规范正式以插件形式公开走向业界，引领Java语言的规范之路。<br>Java代码规约扫描插件以今年年初发布的《阿里巴巴Java开发规约》为标准，作为Eclipse、IDEA的插件形式存在，检测JAVA代码中存在不规范得位置然后给予提示。规约插件是采用kotlin语言开发的，感兴趣的同学可以去开看插件源码。<br>阿里巴巴规约插件包含三个子菜单：编码规约扫描、关闭试试检测功能。<br><img src="http://image.winrains.cn/2019/08/63d65-15479626591284.jpg" alt="img"><br>并且，该插件支持在编写代码的同时进行提示，<br><img src="http://image.winrains.cn/2019/08/74649-15479627335217.jpg" alt="img"><br>这款插件，真的可以很大程度上提升代码质量，一定要安装。</p>
<h3 id="GsonFormat"><a href="#GsonFormat" class="headerlink" title="GsonFormat"></a>GsonFormat</h3><p>Java开发中，经常有把json格式的内容转成Object的需求，比如项目开始时，合作方给你提供了一个json格式request/response，这时候你就需要将其定义成一个Java类，GsonFormat这款插件可以实现该功能。<br><img src="http://image.winrains.cn/2019/08/abd2e-15479627865604.gif" alt="img"></p>
<h3 id="Lombok-plugin"><a href="#Lombok-plugin" class="headerlink" title="Lombok plugin"></a>Lombok plugin</h3><p>在Java中，我们经常会定义很多JavaBean，这些Bean需要有getter、setter、toString、equals和hashCode等方法。<br>通常情况下，我们可以使用IDEA的快捷键生成这些代码，但是自动生成的代码后，如果bean中的属性一旦有修改，需要重新生成，给代码维护增加了一定的负担。<br>有一款很好的插件，可以帮助开发者节省这部分工作。那就是Lombok。<br>只要在IDEA中安装了该插件，只需要在JavaBean中添加一行注解代码，插件就会自动帮我们生成getter、setter、toString、equals和hashCode等方法。<br>当然，这些方法不止在IDE中的代码调用中需要用到，在真正线上部署的时候也需要有，所以，还需要使用maven引入一个lombok的包。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;groupId&gt;org.projectlombok&lt;<span class="regexp">/groupId&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">      &lt;artifactId&gt;lombok&lt;/</span>artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;version&gt;<span class="number">1.16</span><span class="number">.10</span>&lt;<span class="regexp">/version&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">&lt;/</span>dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * @author Hollis</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HollisLab</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Wechat wechat = <span class="keyword">new</span> Wechat();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wechat.setId(<span class="string">"Hollis"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wechat.setDesc(<span class="string">"每日更新Java技术文章"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(wechat);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Data</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wechat</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private <span class="built_in">String</span> id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private <span class="built_in">String</span> desc;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Wechat(<span class="attribute">id</span>=Hollis, <span class="attribute">desc</span>=每日更新Java技术文章)</span></pre></td></tr></table></figure>

<p>我们在Wechat类上面添加了@Data注解，插件就自动帮我们添加了getter/setter和toString方法。</p>
<h3 id="String-Manipulation"><a href="#String-Manipulation" class="headerlink" title="String Manipulation"></a>String Manipulation</h3><p>字符串日常开发中经常用到的，但是不同的字符串类型在不同的地方可能有一些不同的规则，比如类名要用驼峰形式、常量需要全部大写等，有时候还需要进行编码解码等。这里推荐一款强大的字符串转换工具——String Manipulation。<br>它强大到什么程度，看下他的功能列表你就知道了：<br><img src="http://image.winrains.cn/2019/08/59068-15479639987089.jpg" alt="img"></p>
<ul>
<li>文本转换操作<ul>
<li>切换样式（camelCase, hyphen-lowercase, HYPHEN-UPPERCASE, snake_case, SCREAMING_SNAKE_CASE, dot.case, words lowercase, Words Capitalized, PascalCase）</li>
<li>转换为SCREAMING_SNAKE_CASE (或转换为camelCase)</li>
<li>转换为 snake_case (或转换为camelCase)</li>
<li>转换为dot.case (或转换为camelCase)</li>
<li>转换为hyphen-case (或转换为camelCase)</li>
<li>转换为hyphen-case (或转换为snake_case)</li>
<li>转换为camelCase (或转换为Words)</li>
<li>转换为camelCase (或转换为lowercase words)</li>
<li>转换为PascalCase (或转换为camelCase)</li>
<li>选定文本大写</li>
<li>样式反转</li>
</ul>
</li>
<li>Un/Escape<ul>
<li>Un/Escape 选中的 java 文本</li>
<li>Un/Escape 选中的 javascript 文本</li>
<li>Un/Escape 选中的 HTML 文本</li>
<li>Un/Escape 选中的 XML 文本</li>
<li>Un/Escape 选中的 SQL 文本</li>
<li>Un/Escape 选中的 PHP 文本</li>
<li>将 diacritics(accents) 转换为 ASCII</li>
<li>将非ASCII 转换为转义的Unicode</li>
<li>将转义的Unicode转换为字符串</li>
</ul>
</li>
<li>Encode/Decode<ul>
<li>Encode 选中的文本为 MD5 Hex16</li>
<li>De/Encode 选中的文本为 URL</li>
<li>De/Encode 选中的文本为 Base64</li>
</ul>
</li>
<li>递增/递减<ul>
<li>递增/递减所有找到的数字</li>
<li>复制行并且递增/递减所有找到的数字</li>
<li>创建序列：保持第一个数字，递增替换所有其他数字</li>
<li>递增重复的数字</li>
</ul>
</li>
<li>按自然顺序排序<ul>
<li>按行倒序</li>
<li>按行随机排序</li>
<li>区分大小写A-z排序</li>
<li>区分大小写z-A排序</li>
<li>不区分大小写A-Z排序</li>
<li>不区分大小写Z-A排序</li>
<li>按行长度排序</li>
<li>通过子选择行排序：每行仅处理一个选择/插入符号</li>
</ul>
</li>
<li>对齐<ul>
<li>通过选定的分隔将选定的文本格式化为列/表格</li>
<li>将文本对齐为左/中/右</li>
</ul>
</li>
<li>过滤/删除/移除<ul>
<li>grep选定的文本，所有行不匹配输入文字将被删除。 （不能在列模式下工作）</li>
<li>移除选定的文本</li>
<li>移除选定文本中的所有空格</li>
<li>删除选定文本中的所有空格</li>
<li>删除重复的行</li>
<li>只保留重复的行</li>
<li>删除空行</li>
<li>删除所有换行符</li>
</ul>
</li>
<li>其他<ul>
<li>交换字符/选择/线/标记</li>
<li>切换文件路径分隔符：Windows &lt; – &gt; UNIX</li>
</ul>
</li>
</ul>
<p>安装好插件后，选中需要处理的内容后，按快捷键Alt+m，即可弹出工具功能列表。<br>很好很强大的一款字符串处理工具。</p>
<h3 id="ignore"><a href="#ignore" class="headerlink" title=".ignore"></a>.ignore</h3><p>目前很多开发都在使用git做版本控制工具，但是有些时候有些代码我们是不想提到到我们的代码仓库中的，比如ide自动生成的一些配置文件，或者是我们打包生成的一些jar文件等，这时候就需要编写一个.ignore文件，来排除那些不想被版本管理的文件。<br>这里推荐一个好用的插件.ignore，他可以帮我们方便的生成各种ignore文件。<br>安装插件后，选中项目，右键新建的时候，会多出一个.ignore文件的选项，可以通过这个选项创建ignore文件。<br><img src="http://image.winrains.cn/2019/08/9ab64-15479645941037.jpg" alt="img"><br>在弹出的对话框中，可以自动帮我们生成一份.ignore文件，这里我们让其帮忙自动排除所有和idea有关的文件。 <img src="http://image.winrains.cn/2019/08/68614-15479646877699.jpg" alt="img"></p>
<h3 id="Mybatis-plugin"><a href="#Mybatis-plugin" class="headerlink" title="Mybatis plugin"></a>Mybatis plugin</h3><p>目前ORM框架中，Mybatis非常受欢迎。但是，同时给很多开发带来困扰的就是Mybatis需要很多xml的配置文件，有的时候很难去进行修改。<br>这里推荐一款神器，可以让你像编辑java代码一样编辑mybatis的文件。<br>Intellij Idea Mybatis插件主要功能：</p>
<ul>
<li>提供Mapper接口与配置文件中对应SQL的导航</li>
<li>编辑XML文件时自动补全</li>
<li>根据Mapper接口, 使用快捷键生成xml文件及SQL标签</li>
<li>ResultMap中的property支持自动补全，支持级联(属性A.属性B.属性C)</li>
<li>快捷键生成@Param注解</li>
<li>XML中编辑SQL时, 括号自动补全</li>
<li>XML中编辑SQL时, 支持参数自动补全(基于@Param注解识别参数)</li>
<li>自动检查Mapper XML文件中ID冲突</li>
<li>自动检查Mapper XML文件中错误的属性值</li>
<li>支持Find Usage</li>
<li>支持重构从命名</li>
<li>支持别名</li>
<li>自动生成ResultMap属性</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/c18c4-15479651996039.jpg" alt="img"><br><img src="http://image.winrains.cn/2019/08/dd63b-15479652100916.jpg" alt="img"><br>（图源：<a href="https://www.oschina.net/p/intellij-mybatis-plugin）" target="_blank" rel="noopener">https://www.oschina.net/p/intellij-mybatis-plugin）</a><br>但是这款插件是收费的，但是不影响他确实是一个很实用，可以很大程度上提升开发效率的插件。读者可以考虑使用Free Mybatis plugin（这款插件我没用过，具体是否好用有待考证）。</p>
<h3 id="Key-promoter-X"><a href="#Key-promoter-X" class="headerlink" title="Key promoter X"></a>Key promoter X</h3><p>对于很多刚刚开始使用IDEA的开发者来说，最苦恼的就是不知道快捷键操作是什么。<br>使用IDEA，如果所有操作都使用鼠标，那么说明你还不是一个合格的程序员。<br>这里推荐一款可以进行快捷键提示的插件Key promoter X。<br>Key Promoter X 是一个提示插件，当你在IDEA里面使用鼠标的时候，如果这个鼠标操作是能够用快捷键替代的，那么Key Promoter X会弹出一个提示框，告知你这个鼠标操作可以用什么快捷键替代。<br>当我使用鼠标查看一个方法都被哪些类使用的时候，就会提示：<br><img src="http://image.winrains.cn/2019/08/78545-15479654859661.jpg" alt="img"><br>记住这个快捷键以后，就可以使用快捷键代替鼠标啦。</p>
<h3 id="AceJump"><a href="#AceJump" class="headerlink" title="AceJump"></a>AceJump</h3><p>前面介绍了一款可以通过使用快捷键来代替鼠标操作的插件，这里再介绍一款可以彻底摆脱鼠标的插件，即AceJump<br>AceJump允许您快速将光标导航到编辑器中可见的任何位置，只需点击“ctrl +;”，然后输入一个你想要跳转到的字符，之后键入匹配的字符就跳转到你想要挑战的地方了。<br><img src="http://image.winrains.cn/2019/08/2fc37-15479658623827.jpg" alt="img"><br>如以上代码，我想在这个类中，跳转到println那个位置，只需要按下快捷键：“ctrl +;”，然后输入println，即可定位到目标位置。<br>上图中，我输入了pri三个字母后，页面提示三个可选项，分别用字母G、H、D标注，这时候只需要按下对应字母，即可快速定位到指定位置，是不是很方便。</p>
<h3 id="activate-power-mode"><a href="#activate-power-mode" class="headerlink" title="activate-power-mode"></a>activate-power-mode</h3><p>最后，介绍一款程序员很好的在妹子面前装X的插件——activate-power-mode 。<br>安装了这款插件之后，你写代码的时候，就会附加一些狂拽炫酷屌炸天的效果：<br><img src="http://image.winrains.cn/2019/08/a45d6-15479661234183.gif" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文一共介绍了11款可以提升程序员开发效率、提升代码质量、提升编码心情的软件。欢迎大家安装尝试一下。</p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/3220" target="_blank" rel="noopener">https://www.hollischuang.com/archives/3220</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>IntelliJ IDEA</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构</title>
    <url>/2019/12/26/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>redis 是 key-value 类型的数据库，key 一般是一个字符串，但他的value可以储存5种数据类型</p>
<h2 id="key-的定义注意事项"><a href="#key-的定义注意事项" class="headerlink" title="key 的定义注意事项"></a>key 的定义注意事项</h2><p>它的 key 在定义时，需要注意以下事项</p>
<ul>
<li>不要超过 1024 个字节，过长除了会消耗内存，还会降低查找效率</li>
<li>有统一的命名规范</li>
</ul>
<a id="more"></a>

<h3 id="key-常用的命令"><a href="#key-常用的命令" class="headerlink" title="key 常用的命令"></a>key 常用的命令</h3><ul>
<li><strong>查询所有的键</strong>：<code>keys *</code></li>
<li><strong>查询所有以某个字符串开头的的键</strong>：<code>keys 字符串?</code></li>
<li><strong>删除键</strong>：<code>del 键1 键2</code></li>
<li><strong>查看键是否存在</strong>：<code>exists 键</code> 存在返回1 不存在返回0</li>
<li><strong>对键重命名</strong>： <code>rename 键 新键名</code></li>
<li><strong>设置过期时间</strong>：<code>expire 键 秒</code></li>
<li><strong>查看键的剩余过期时间</strong>：<code>ttl 键</code> 返回剩余的秒 如果键没有设置超时时间返回-1</li>
<li><strong>查看键对应的值的类型</strong>：<code>type 键</code> <strong>sorted-set</strong> 类型的值会返回 zset</li>
</ul>
<h2 id="五种数据类型"><a href="#五种数据类型" class="headerlink" title="五种数据类型"></a>五种数据类型</h2><p>redis 的值有五种数据类型</p>
<ul>
<li><strong>String</strong>：存储字符串、整数、浮点数</li>
<li><strong>list</strong>: 存储字符串、整数、浮点数列表</li>
<li><strong>set</strong>：存储字符串、整数、浮点数集合</li>
<li><strong>sort set</strong>：存储有序字符串、整数、浮点数集合</li>
<li><strong>hash</strong>：存储键值对</li>
</ul>
<p>比较常用的是 <strong>String</strong>、<strong>hash</strong></p>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>string 类型的数据在redis中是以二进制的方式存储的，这就避免了编码格式的问题，存入的是什么编码格式的字符串，读取的就是什么编码格式的字符串</p>
<ul>
<li>以二进制形式存储，存入和获取的数据一致</li>
<li>value 最多可以容纳的数据长度是 512M</li>
</ul>
<h3 id="string-常用命令"><a href="#string-常用命令" class="headerlink" title="string 常用命令"></a>string 常用命令</h3><ul>
<li><strong>赋值</strong>：<code>set 键 值</code></li>
<li><strong>不存在才赋值</strong>:<code>setnx 键 值</code> 存在不赋值，返回0， 不存在才赋值，返回1</li>
<li><strong>取值</strong>：<code>get 键</code> 获取键的值</li>
<li><strong>修改</strong>：<code>getset 键 新值</code> 将键的值改为新值</li>
<li><strong>删除</strong>：<code>del 键</code> 删除键的值</li>
<li><strong>数值加1</strong>：<code>inc 键</code> 如果 键 不存在，则创建 键 并设置值为0再加1，如果存在就直接加1，如果存在但值不能转成整型，就会报错</li>
<li><strong>数值减1</strong>：<code>decr 键</code>，decr 正好 与 inc 命令相反，它是减1</li>
<li><strong>数值加</strong>：：<code>incby 键 数值</code>，与 <code>inc 键</code> 相同，不同的地方在于他指定了要加的数值</li>
<li><strong>数值减</strong>：<code>decrby 键 数值</code>，与 <code>inc 键</code> 相同，不同的地方在于他指定了要减的数值</li>
<li><strong>拼接</strong>：<code>append 键 值</code> 在指定键后面拼接值，如果键不存在，创建 键 并初始化化为 值</li>
<li><strong>判断键是否存在</strong>：<code>exists 键</code>， 存在返回1，不存在返回0</li>
</ul>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>hash 类型可以看做是 string key 和 string value 的 map 容器<br>一个hesh可以存储 4294967295 个键值对</p>
<h3 id="hash-常用命令"><a href="#hash-常用命令" class="headerlink" title="hash 常用命令"></a>hash 常用命令</h3><ul>
<li><strong>赋值</strong>：<code>hset 键 hash的键 hash的值</code> 存入一对 hash ，同一个 键 可以存入多对hash</li>
<li><strong>批量赋值</strong>：<code>hmset 键 hash的键1 hash的值1 hash的键2 hash的值2</code> 在一个键中同时存入多对hash</li>
<li><strong>取值</strong>：<code>hget 键 hash的键</code> 取出 hash键对应的值</li>
<li><strong>批量取值</strong>：<code>hmget 键 hash的键1 hash的键2</code> 取出 hash键1、hash键2对应的值</li>
<li><strong>获取全部的值</strong>：<code>hgetall 键</code> 获取 键 中所有 hash键对应的值</li>
<li><strong>删除</strong>：<code>hdel 键 hash的键1 hash的键2</code> 删除hash的键1、hash的键2对应的键值对</li>
<li><strong>数值加</strong>：：<code>hincby 键 hash的键 数值</code>，给 hash的键对应的值 加上指定的数值</li>
<li><strong>判断某个 hash键 是否存在</strong>：<code>hexists 键 hash的键</code>， 存在返回1，不存在返回0</li>
<li><strong>获取 hash对 的数量</strong>：<code>hlen 键</code> 获取该键中 hash 对的数量</li>
<li><strong>获取所有的 hash键</strong>： <code>hkeys</code> 获取该键中 hash键的列表</li>
<li><strong>获取所有的 hash值</strong>： <code>hvals</code> 获取该键中 hash值的列表</li>
</ul>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）<br>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。<br>如果列表中的所以元素被删除，那么列表本身也会被删除</p>
<h3 id="list-常用命令"><a href="#list-常用命令" class="headerlink" title="list 常用命令"></a>list 常用命令</h3><ul>
<li><strong>左端添加</strong>：<code>lpush 键 值1 值2 值3</code> 在list左边添加值 如果键不存在则创建 插入后的顺序为值3 值2 值1</li>
<li><strong>右端添加</strong>：<code>rpush 键 值1 值2 值3</code> 在list右边添加值 如果键不存在则创建 插入后的顺序为值1 值2 值3</li>
<li><strong>查看</strong>：<code>lrange 键 开始下标 结束下标</code> 包括开始不包括结束 下标可以从0开始 也可以从-1开始，-1就表示倒数第一个</li>
<li><strong>左端弹出</strong>：<code>lpop 键</code> 删除掉list左边第一个元素</li>
<li><strong>右端弹出</strong>：<code>rpop 键</code> 删除掉list右边第一个元素</li>
<li><strong>获取列表中元素的个数</strong>： <code>llen 键</code> 如果键不存在，返回0</li>
<li><strong>list存在时，左端添加</strong>：<code>lpushx 键 值</code> 键存在则添加，键不存在不添加</li>
<li><strong>list存在时，右端添加</strong>：<code>rpushx 键 值</code> 键存在则添加，键不存在不添加</li>
<li><strong>批量删除某个元素</strong>：<code>lrem 键 个数 元素</code> 个数为正数则从左往右删除 个数为负数则从右往左删除 个数为0则删除所有 举例 lrem nameList 2 tom 表示从左往右删除 nameList 中2个 tom 元素。lrem nameList -3 joy 表示从右往左删除 nameList 中3个 joy 元素。lrem nameList 0 ros 删除nameList中所以的 ros</li>
<li><strong>修改某一下标的值</strong>：<code>lset 键 下标的值</code> 下标可以从0开始 也可以从-1开始，-1就表示倒数第一个 如果下标存在则覆盖原有值 如果下标不存在则报错</li>
<li><strong>在某个元素之前插入元素</strong> ：<code>linsert 键 before 元素 要插入的元素</code> 从左往右匹配第一个找到的元素 插入之后，插入点后面的元素下标+1</li>
<li><strong>在某个元素之后插入元素</strong> ：<code>linsert 键 after 元素 要插入的元素</code> 从左往右匹配第一个找到的元素 插入之后，插入点后面的元素下标+1</li>
<li><strong>将链表a的尾部元素弹出插入到链表b的头部</strong>：<code>rpoplpush 键a 键b</code> 完成之后 链表a会少一个元素 链表b会多一个元素</li>
</ul>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set 可以看成是没有排序的字符集合，和list不同的是 set 中不允许出现重复元素<br>一个set 最多可以包含 232 - 1 个元素</p>
<h3 id="set-常用命令"><a href="#set-常用命令" class="headerlink" title="set 常用命令"></a>set 常用命令</h3><ul>
<li><strong>添加元素</strong>：<code>sadd 键 元素1 元素2 元素3</code> 重复的元素只会保留一份</li>
<li><strong>删除元素</strong>：<code>srem 键 元素1 元素2</code></li>
<li><strong>查看元素</strong>：<code>smembers 键</code> 它会列出所有的元素</li>
<li><strong>查看set中是否包含某元素</strong>：<code>sismember 键 元素</code> 返回1表示存在 0表示不存在</li>
<li><strong>获取set中元素的数量</strong>： <code>scard 键</code></li>
<li><strong>随机获取一个元素</strong>： <code>srandmember 键</code></li>
</ul>
<h4 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h4><p>假设 set1 中有 a、b、c， set2 中有 1、2、c</p>
<ul>
<li><strong>差集(补集)运算</strong>： <code>sdiff 键a 键b</code> 谁在前面，求谁的差集(补集)</li>
</ul>
<p>set1的差集(补集)为红色部分中的 1、2，命令写作 <code>sdiff set1 set2</code></p>
<p><img src="http://image.winrains.cn/2019/08/20190829134305-4eff6.png" alt="img"></p>
<p>set2的差集(补集)为红色部分中的 a、b，命令写作 <code>sdiff set2 set1</code></p>
<p><img src="http://image.winrains.cn/2019/08/20190829134305-cd37f.png" alt="img"></p>
<ul>
<li><p><strong>存储差集(补集)到新set</strong>：<code>sdiffstore 新集合 集合1 集合2</code> 将集合1的差集(补集) 存入新集合</p>
</li>
<li><p>交集运算</p>
<p>：</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">sinter</span> <span class="comment">键a</span> <span class="comment">键b</span></span></pre></td></tr></table></figure>

<p> 结果是两个set 中都有的元素</p>
<p><img src="http://image.winrains.cn/2019/08/20190829134306-4b266.png" alt="img"></p>
</li>
<li><p><strong>存储交集到新set</strong>：<code>sinterstore 新集合 集合1 集合2</code> 将集合1 和集合2的交集存入新集合</p>
</li>
<li><p>并集运算</p>
<p>：</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">sunion</span> <span class="comment">键a</span> <span class="comment">键b</span></span></pre></td></tr></table></figure>

<p> 会将两个 set 中的元素合并在一起，重复的元素只会保留一份</p>
<p><img src="http://image.winrains.cn/2019/08/20190829134306-3b37d.png" alt="img"></p>
</li>
<li><p><strong>存储并集到新set</strong>：<code>sunionstore 新集合 集合1 集合2</code> 将集合1 和集合2的并集存入新集合</p>
</li>
</ul>
<h2 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted-set"></a>sorted-set</h2><p>有序的set集合，除了顺序其他都和set一致，比如不允许出现重复元素<br>sorted-set 中的每一个成员都有一个对应的分数，sorted-set 通过分数确定成员的顺序<br>如果两个元素的分数一样，那么按照元素的字典顺序排序</p>
<h3 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h3><ul>
<li><strong>添加元素</strong>：<code>zadd 键 分数1 值1 分数2 值2</code> 例如 zadd sortName 90 张三 93 王五</li>
<li><strong>更新分数</strong>：<code>zadd 键 新分数 值1</code> 例如 zadd sortName 100 张三</li>
<li><strong>获取元素的分数</strong>：<code>zscore 键 值</code></li>
<li><strong>获取元素数量</strong>：<code>zcard 键</code></li>
<li><strong>删除某个元素</strong>：<code>zrem 键 值1 值2</code></li>
<li><strong>查看元素</strong>：<code>zrange 键 序号1 序号2</code> 序号可以从0开始 也可以从-1开始，-1就表示倒数第一个 比如 zrange sortName 0 -1 表示查看 sortName 的第一个元素到最后一个元素</li>
<li><strong>查看元素和对应的分数</strong>：<code>zrange 键 序号1 序号2 withscorse</code> 按分数从小到大排序</li>
<li><strong>查看元素和对应的分数</strong>：<code>zrevrange 键 序号1 序号2 withscorse</code> 按分数从大到小排序</li>
<li><strong>按照排名的范围删除元素</strong>：<code>zremrangebyrank 键 序号1 序号2</code> 包含开始不包含结束</li>
<li><strong>按照分数的范围删除元素</strong>：<code>zremrangebyscore 键 分数1 分数2</code> 包含开始分数不包含结束分数</li>
<li><strong>获取某段分数内的元素</strong>：<code>zrangebyscore 键 分数1 分数2 withscorse limit 数字1 数字2</code> 包含开始分数不包含结束分数， 结果按分数从小到大排序， withscorse是可选参数，加上之后会显示分数 limit也是可选参数，例如 limit 0 2 表示只取结果集的前两位</li>
<li><strong>给元素加分数</strong>：<code>zincrby 键 要加的分数 值</code></li>
<li><strong>获取某段分数中元素的个数</strong>：<code>zcount 键 分数1 分数2</code></li>
</ul>
<blockquote>
<p>作者：我妻礼弥</p>
<p>来源：<a href="https://juejin.im/post/5d64806151882528307e7e79" target="_blank" rel="noopener">https://juejin.im/post/5d64806151882528307e7e79</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>最全的select加锁分析</title>
    <url>/2019/12/26/%E6%9C%80%E5%85%A8%E7%9A%84select%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>大家在面试中有没遇到面试官问你下面六句Sql的区别呢</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ?</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> &lt; ?</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> &lt; ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ? <span class="keyword">for</span> <span class="keyword">update</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> &lt; ? <span class="keyword">for</span> <span class="keyword">update</span></span></pre></td></tr></table></figure>

<a id="more"></a>

<p>如果你能清楚的说出，这六句sql在不同的事务隔离级别下，是否加锁，加的是共享锁还是排他锁，是否存在间隙锁，那这篇文章就没有看的意义了。 之所以写这篇文章是因为目前为止网上这方面的文章太片面，都只说了一半，且大多没指明隔离级别，以及<code>where</code>后跟的是否为索引条件列。在此，我就不一一列举那些有误的文章了，大家可以自行百度一下，大多都是讲不清楚。 OK，要回答这个问题，先问自己三个问题</p>
<ul>
<li>当前事务隔离级别是什么</li>
<li>id列是否存在索引</li>
<li>如果存在索引是聚簇索引还是非聚簇索引呢？</li>
</ul>
<p>OK，开始回答</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ul>
<li>innodb一定存在聚簇索引，默认以主键作为聚簇索引</li>
<li>有几个索引，就有几棵B+树(不考虑hash索引的情形)</li>
<li>聚簇索引的叶子节点为磁盘上的真实数据。非聚簇索引的叶子节点还是索引，指向聚簇索引B+树。</li>
</ul>
<p>下面啰嗦点基础知识</p>
<h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><p><strong>共享锁</strong>(S锁):假设事务T1对数据A加上共享锁，那么事务T2<strong>可以</strong>读数据A，<strong>不能</strong>修改数据A。<br><strong>排他锁</strong>(X锁):假设事务T1对数据A加上共享锁，那么事务T2<strong>不能</strong>读数据A，<strong>不能</strong>修改数据A。 我们通过<code>update</code>、<code>delete</code>等语句加上的锁都是行级别的锁。只有<code>LOCK TABLE … READ</code>和<code>LOCK TABLE … WRITE</code>才能申请表级别的锁。<br><strong>意向共享锁</strong>(IS锁):一个事务在获取（任何一行/或者全表）S锁之前，一定会先在所在的表上加IS锁。<br><strong>意向排他锁</strong>(IX锁):一个事务在获取（任何一行/或者全表）X锁之前，一定会先在所在的表上加IX锁。</p>
<blockquote>
<p><strong>意向锁存在的目的?</strong></p>
</blockquote>
<p>OK，这里说一下意向锁存在的目的。假设事务T1，用X锁来锁住了表上的几条记录，那么此时表上存在IX锁，即意向排他锁。那么此时事务T2要进行<code>LOCK TABLE … WRITE</code>的表级别锁的请求，可以直接根据意向锁是否存在而判断是否有锁冲突。</p>
<h3 id="加锁算法"><a href="#加锁算法" class="headerlink" title="加锁算法"></a>加锁算法</h3><p>我的说法是来自官方文档: <code>https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html</code> 加上自己矫揉造作的见解得出。<br>ok，记得如下三种，本文就够用了<br><code>Record Locks</code>：简单翻译为行锁吧。注意了，该锁是对索引记录进行加锁！锁是在加索引上而不是行上的。注意了，innodb一定存在聚簇索引，因此行锁最终都会落到聚簇索引上！<br><code>Gap Locks</code>：简单翻译为间隙锁，是对索引的间隙加锁，其目的只有一个，防止其他事物插入数据。在<code>Read Committed</code>隔离级别下，不会使用间隙锁。这里我对官网补充一下，隔离级别比<code>Read Committed</code>低的情况下，也不会使用间隙锁，如隔离级别为<code>Read Uncommited</code>时，也不存在间隙锁。当隔离级别为<code>Repeatable Read</code>和<code>Serializable</code>时，就会存在间隙锁。<br><code>Next-Key Locks</code>：这个理解为<code>Record Lock</code>+索引前面的<code>Gap Lock</code>。记住了，锁住的是索引前面的间隙！比如一个索引包含值，10，11，13和20。那么，间隙锁的范围如下</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(negative infinity, <span class="number">10</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">(<span class="number">10</span>, <span class="number">11</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">(<span class="number">11</span>, <span class="number">13</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">(<span class="number">13</span>, <span class="number">20</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">(<span class="number">20</span>, positive infinity)</span></pre></td></tr></table></figure>

<h3 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h3><p>最后一点基础知识了，大家坚持看完，这些是后面分析的基础！ 在mysql中select分为快照读和当前读，执行下面的语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ?;</span></pre></td></tr></table></figure>

<p>执行的是快照读，读的是数据库记录的快照版本，是不加锁的。（这种说法在隔离级别为<code>Serializable</code>中不成立，后面我会补充。） 那么，执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span></pre></td></tr></table></figure>

<p>会对读取记录加S锁 (共享锁)，执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ? <span class="keyword">for</span> <span class="keyword">update</span></span></pre></td></tr></table></figure>

<p>会对读取记录加X锁 (排他锁)，那么</p>
<blockquote>
<p><strong>加的是表锁还是行锁呢？</strong></p>
</blockquote>
<p>针对这点，我们先回忆一下事务的四个隔离级别，他们由弱到强如下所示:</p>
<ul>
<li><code>Read Uncommited(RU)</code>：读未提交，一个事务可以读到另一个事务未提交的数据！</li>
<li><code>Read Committed (RC)</code>：读已提交，一个事务可以读到另一个事务已提交的数据!</li>
<li><code>Repeatable Read (RR)</code>:可重复读，加入间隙锁，一定程度上避免了幻读的产生！注意了，只是一定程度上，并没有完全避免!我会在下一篇文章说明!另外就是记住从该级别才开始加入间隙锁(这句话记下来，后面有用到)!</li>
<li><code>Serializable</code>：串行化，该级别下读写串行化，且所有的<code>select</code>语句后都自动加上<code>lock in share mode</code>，即使用了共享锁。因此在该隔离级别下，使用的是当前读，而不是快照读。</li>
</ul>
<p>那么关于是表锁还是行锁，大家可以看到网上最流传的一个说法是这样的，</p>
<blockquote>
<p><strong>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。 InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong></p>
</blockquote>
<p>这句话大家可以搜一下，都是你抄我的，我抄你的。那么，这句话本身有两处错误！ <strong>错误一</strong>:并不是用表锁来实现锁表的操作，而是利用了<code>Next-Key Locks</code>，也可以理解为是用了行锁+间隙锁来实现锁表的操作! 为了便于说明，我来个例子，假设有表数据如下，pId为主键索引</p>
<table>
<thead>
<tr>
<th>pId(int)</th>
<th>name(varchar)</th>
<th>num(int)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>aaa</td>
<td>100</td>
</tr>
<tr>
<td>2</td>
<td>bbb</td>
<td>200</td>
</tr>
<tr>
<td>7</td>
<td>ccc</td>
<td>200</td>
</tr>
</tbody></table>
<p>执行语句(name列无索引)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">`aaa`</span> <span class="keyword">for</span> <span class="keyword">update</span></span></pre></td></tr></table></figure>

<p>那么此时在pId=1,2,7这三条记录上存在行锁(把行锁住了)。另外，在(-∞,1)(1,2)(2,7)(7,+∞)上存在间隙锁(把间隙锁住了)。因此，给人一种整个表锁住的错觉！<br><code>ps:</code>对该结论有疑问的，可自行执行<code>show engine innodb status;</code>语句进行分析。<br><strong>错误二</strong>:所有文章都不提隔离级别！<br>注意我上面说的，之所以能够锁表，是通过行锁+间隙锁来实现的。那么，<code>RU</code>和<code>RC</code>都不存在间隙锁，这种说法在<code>RU</code>和<code>RC</code>中还能成立么？ 因此，该说法只在<code>RR</code>和<code>Serializable</code>中是成立的。如果隔离级别为<code>RU</code>和<code>RC</code>，无论条件列上是否有索引，都不会锁表，只锁行！</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>下面来对开始的问题作出解答，假设有表如下，pId为主键索引</p>
<table>
<thead>
<tr>
<th>pId(int)</th>
<th>name(varchar)</th>
<th>num(int)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>aaa</td>
<td>100</td>
</tr>
<tr>
<td>2</td>
<td>bbb</td>
<td>200</td>
</tr>
<tr>
<td>3</td>
<td>bbb</td>
<td>300</td>
</tr>
<tr>
<td>7</td>
<td>ccc</td>
<td>200</td>
</tr>
</tbody></table>
<h4 id="RC-RU-条件列非索引"><a href="#RC-RU-条件列非索引" class="headerlink" title="RC/RU+条件列非索引"></a>RC/RU+条件列非索引</h4><p>(1)<code>select * from table where num = 200</code><br>不加任何锁，是快照读。<br>(2)<code>select * from table where num &gt; 200</code><br>不加任何锁，是快照读。<br>(3)<code>select * from table where num = 200 lock in share mode</code><br>当num = 200，有两条记录。这两条记录对应的pId=2，7，因此在pId=2，7的聚簇索引上加行级S锁，采用当前读。<br>(4)<code>select * from table where num &gt; 200 lock in share mode</code><br>当num &gt; 200，有一条记录。这条记录对应的pId=3，因此在pId=3的聚簇索引上加上行级S锁，采用当前读。<br>(5)<code>select * from table where num = 200 for update</code><br>当num = 200，有两条记录。这两条记录对应的pId=2，7，因此在pId=2，7的聚簇索引上加行级X锁，采用当前读。<br>(6)<code>select * from table where num &gt; 200 for update</code><br>当num &gt; 200，有一条记录。这条记录对应的pId=3，因此在pId=3的聚簇索引上加上行级X锁，采用当前读。</p>
<h4 id="RC-RU-条件列是聚簇索引"><a href="#RC-RU-条件列是聚簇索引" class="headerlink" title="RC/RU+条件列是聚簇索引"></a>RC/RU+条件列是聚簇索引</h4><p>恩，大家应该知道pId是主键列，因此pId用的就是聚簇索引。此情况其实和<strong>RC/RU+条件列非索引</strong>情况是类似的。<br>(1)<code>select * from table where pId = 2</code><br>不加任何锁，是快照读。<br>(2)<code>select * from table where pId &gt; 2</code><br>不加任何锁，是快照读。<br>(3)<code>select * from table where pId = 2 lock in share mode</code><br>在pId=2的聚簇索引上，加S锁，为当前读。<br>(4)<code>select * from table where pId &gt; 2 lock in share mode</code><br>在pId=3，7的聚簇索引上，加S锁，为当前读。<br>(5)<code>select * from table where pId = 2 for update</code><br>在pId=2的聚簇索引上，加X锁，为当前读。<br>(6)<code>select * from table where pId &gt; 2 for update</code><br>在pId=3，7的聚簇索引上，加X锁，为当前读。<br>这里，大家可能有疑问</p>
<blockquote>
<p><strong>为什么条件列加不加索引，加锁情况是一样的？</strong></p>
</blockquote>
<p>ok,其实是不一样的。在RC/RU隔离级别中，MySQL Server做了优化。在条件列没有索引的情况下，尽管通过聚簇索引来扫描全表，进行全表加锁。但是，MySQL Server层会进行过滤并把不符合条件的锁当即释放掉，因此你看起来最终结果是一样的。但是<strong>RC/RU+条件列非索引</strong>比本例多了一个释放不符合条件的锁的过程！</p>
<h4 id="RC-RU-条件列是非聚簇索引"><a href="#RC-RU-条件列是非聚簇索引" class="headerlink" title="RC/RU+条件列是非聚簇索引"></a>RC/RU+条件列是非聚簇索引</h4><p>我们在num列上建上非唯一索引。此时有一棵聚簇索引(主键索引，pId)形成的B+索引树，其叶子节点为硬盘上的真实数据。以及另一棵非聚簇索引(非唯一索引，num)形成的B+索引树，其叶子节点依然为索引节点，保存了num列的字段值，和对应的聚簇索引。<br>接下来分析开始<br>(1)<code>select * from table where num = 200</code><br>不加任何锁，是快照读。<br>(2)<code>select * from table where num &gt; 200</code><br>不加任何锁，是快照读。<br>(3)<code>select * from table where num = 200 lock in share mode</code><br>当num = 200，由于num列上有索引，因此先在 num = 200的两条索引记录上加行级S锁。接着，去聚簇索引树上查询，这两条记录对应的pId=2，7，因此在pId=2，7的聚簇索引上加行级S锁，采用当前读。<br>(4)<code>select * from table where num &gt; 200 lock in share mode</code><br>当num &gt; 200，由于num列上有索引，因此先在符合条件的 num = 300的一条索引记录上加行级S锁。接着，去聚簇索引树上查询，这条记录对应的pId=3，因此在pId=3的聚簇索引上加行级S锁，采用当前读。<br>(5)<code>select * from table where num = 200 for update</code><br>当num = 200，由于num列上有索引，因此先在 num = 200的两条索引记录上加行级X锁。接着，去聚簇索引树上查询，这两条记录对应的pId=2，7，因此在pId=2，7的聚簇索引上加行级X锁，采用当前读。<br>(6)<code>select * from table where num &gt; 200 for update</code><br>当num &gt; 200，由于num列上有索引，因此先在符合条件的 num = 300的一条索引记录上加行级X锁。接着，去聚簇索引树上查询，这条记录对应的pId=3，因此在pId=3的聚簇索引上加行级X锁，采用当前读。</p>
<h4 id="RR-Serializable-条件列非索引"><a href="#RR-Serializable-条件列非索引" class="headerlink" title="RR/Serializable+条件列非索引"></a>RR/Serializable+条件列非索引</h4><p>RR级别需要多考虑的就是gap lock，他的加锁特征在于，无论你怎么查都是锁全表。如下所示 接下来分析开始<br>(1)<code>select * from table where num = 200</code><br>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，在pId = 1,2,3,7（全表所有记录）的聚簇索引上加S锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock<br>(2)<code>select * from table where num &gt; 200</code><br>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，在pId = 1,2,3,7（全表所有记录）的聚簇索引上加S锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock<br>(3)<code>select * from table where num = 200 lock in share mode</code><br>在pId = 1,2,3,7（全表所有记录）的聚簇索引上加S锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock<br>(4)<code>select * from table where num &gt; 200 lock in share mode</code><br>在pId = 1,2,3,7（全表所有记录）的聚簇索引上加S锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock<br>(5)<code>select * from table where num = 200 for update</code><br>在pId = 1,2,3,7（全表所有记录）的聚簇索引上加X锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock<br>(6)<code>select * from table where num &gt; 200 for update</code><br>在pId = 1,2,3,7（全表所有记录）的聚簇索引上加X锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock</p>
<h4 id="RR-Serializable-条件列是聚簇索引"><a href="#RR-Serializable-条件列是聚簇索引" class="headerlink" title="RR/Serializable+条件列是聚簇索引"></a>RR/Serializable+条件列是聚簇索引</h4><p>恩，大家应该知道pId是主键列，因此pId用的就是聚簇索引。该情况的加锁特征在于，如果<code>where</code>后的条件为精确查询(<code>=</code>的情况)，那么只存在record lock。如果<code>where</code>后的条件为范围查询(<code>&gt;</code>或<code>&lt;</code>的情况)，那么存在的是record lock+gap lock。<br>(1)<code>select * from table where pId = 2</code><br>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，是当前读，在pId=2的聚簇索引上加S锁，不存在gap lock。<br>(2)<code>select * from table where pId &gt; 2</code><br>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，是当前读，在pId=3,7的聚簇索引上加S锁。在(2,3)(3,7)(7,+∞)加上gap lock<br>(3)<code>select * from table where pId = 2 lock in share mode</code><br>是当前读，在pId=2的聚簇索引上加S锁，不存在gap lock。<br>(4)<code>select * from table where pId &gt; 2 lock in share mode</code><br>是当前读，在pId=3,7的聚簇索引上加S锁。在(2,3)(3,7)(7,+∞)加上gap lock<br>(5)<code>select * from table where pId = 2 for update</code><br>是当前读，在pId=2的聚簇索引上加X锁。<br>(6)<code>select * from table where pId &gt; 2 for update</code><br>在pId=3,7的聚簇索引上加X锁。在(2,3)(3,7)(7,+∞)加上gap lock<br>(7)<code>select * from table where pId = 6 [lock in share mode|for update]</code><br>注意了，pId=6是不存在的列，这种情况会在(3,7)上加gap lock。<br>(8)<code>select * from table where pId &gt; 18 [lock in share mode|for update]</code><br>注意了，pId&gt;18，查询结果是空的。在这种情况下，是在(7,+∞)上加gap lock。</p>
<h4 id="RR-Serializable-条件列是非聚簇索引"><a href="#RR-Serializable-条件列是非聚簇索引" class="headerlink" title="RR/Serializable+条件列是非聚簇索引"></a>RR/Serializable+条件列是非聚簇索引</h4><p>这里非聚簇索引，需要区分是否为唯一索引。因为如果是非唯一索引，间隙锁的加锁方式是有区别的。<br>先说一下，唯一索引的情况。如果是唯一索引，情况和<strong>RR/Serializable+条件列是聚簇索引</strong>类似，唯一有区别的是:这个时候有两棵索引树，加锁是加在对应的非聚簇索引树和聚簇索引树上！大家可以自行推敲!<br>下面说一下，非聚簇索引是非唯一索引的情况，他和唯一索引的区别就是通过索引进行精确查询以后，不仅存在record lock，还存在gap lock。而通过唯一索引进行精确查询后，只存在record lock，不存在gap lock。老规矩在num列建立非唯一索引<br>(1)<code>select * from table where num = 200</code><br>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，是当前读，在pId=2，7的聚簇索引上加S锁，在num=200的非聚集索引上加S锁，在(100,200)(200,300)加上gap lock。<br>(2)<code>select * from table where num &gt; 200</code><br>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，是当前读，在pId=3的聚簇索引上加S锁，在num=300的非聚集索引上加S锁。在(200,300)(300,+∞)加上gap lock<br>(3)<code>select * from table where num = 200 lock in share mode</code><br>是当前读，在pId=2，7的聚簇索引上加S锁，在num=200的非聚集索引上加S锁，在(100,200)(200,300)加上gap lock。<br>(4)<code>select * from table where num &gt; 200 lock in share mode</code><br>是当前读，在pId=3的聚簇索引上加S锁，在num=300的非聚集索引上加S锁。在(200,300)(300,+∞)加上gap lock。<br>(5)<code>select * from table where num = 200 for update</code><br>是当前读，在pId=2，7的聚簇索引上加S锁，在num=200的非聚集索引上加X锁，在(100,200)(200,300)加上gap lock。<br>(6)<code>select * from table where num &gt; 200 for update</code><br>是当前读，在pId=3的聚簇索引上加S锁，在num=300的非聚集索引上加X锁。在(200,300)(300,+∞)加上gap lock<br>(7)<code>select * from table where num = 250 [lock in share mode|for update]</code><br>注意了，num=250是不存在的列，这种情况会在(200,300)上加gap lock。<br>(8)<code>select * from table where num &gt; 400 [lock in share mode|for update]</code><br>注意了，pId&gt;400，查询结果是空的。在这种情况下，是在(400,+∞)上加gap lock。</p>
<blockquote>
<p>作者：RDJ</p>
<p>来源：<a href="https://juejin.im/post/5d5671a2e51d45620821cea7" target="_blank" rel="noopener">https://juejin.im/post/5d5671a2e51d45620821cea7</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型中的通配符</title>
    <url>/2019/12/26/Java%E6%B3%9B%E5%9E%8B%E4%B8%AD%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许开发者在编译时检测到非法的类型。<br>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<a id="more"></a>

<h2 id="泛型带来的好处"><a href="#泛型带来的好处" class="headerlink" title="泛型带来的好处"></a>泛型带来的好处</h2><p>在没有泛型的情况的下，通过对类型 Object 的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是本身就是一个安全隐患。<br>那么泛型的好处就是在编译的时候能够检查类型安全，并且所有的强制转换都是自动和隐式的。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperGeneric</span>&lt;T&gt; &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> T t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">this</span>.t = t; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// do nothing</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    * 不指定类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noSpecifyType</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        GlmapperGeneric glmapperGeneric = <span class="keyword">new</span> GlmapperGeneric();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        glmapperGeneric.<span class="built_in">set</span>(<span class="string">"test"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 需要强制类型转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">String</span> test = (<span class="keyword">String</span>) glmapperGeneric.<span class="built_in">get</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(test);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 指定类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specifyType</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        GlmapperGeneric&lt;<span class="keyword">String</span>&gt; glmapperGeneric = <span class="keyword">new</span> GlmapperGeneric();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        glmapperGeneric.<span class="built_in">set</span>(<span class="string">"test"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 不需要强制类型转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">String</span> test = glmapperGeneric.<span class="built_in">get</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(test);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面这段代码中的 specifyType 方法中 省去了强制转换，可以在编译时候检查类型安全，可以用在类，方法，接口上。</p>
<h2 id="泛型中通配符"><a href="#泛型中通配符" class="headerlink" title="泛型中通配符"></a>泛型中通配符</h2><p>我们在定义泛型类，泛型方法，泛型接口的时候经常会碰见很多不同的通配符，比如 T，E，K，V 等等，这些通配符又都是什么意思呢？</p>
<h3 id="常用的-T，E，K，V，？"><a href="#常用的-T，E，K，V，？" class="headerlink" title="常用的 T，E，K，V，？"></a>常用的 T，E，K，V，？</h3><p>本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。<strong>通常情况下，T，E，K，V，？ 是这样约定的：</strong></p>
<ul>
<li>？ 表示不确定的 java 类型</li>
<li>T (type) 表示具体的一个java类型</li>
<li>K V (key value) 分别代表java键值中的Key Value</li>
<li>E (element) 代表Element</li>
</ul>
<h3 id="？-无界通配符"><a href="#？-无界通配符" class="headerlink" title="？ 无界通配符"></a>？ <strong>无界通配符</strong></h3><p>先从一个小例子看起，原文在 <a href="https://link.juejin.im?target=https%3A%2F%2Fcodeday.me%2Fbug%2F20180113%2F116421.html">这里</a> 。<br>我有一个父类 Animal 和几个子类，如狗、猫等，现在我需要一个动物的列表，我的第一个想法是像这样的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">List<span class="tag">&lt;<span class="name">Animal</span>&gt;</span> listAnimals</span></pre></td></tr></table></figure>

<p>但是老板的想法确实这样的：</p>
<figure class="highlight capnproto"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;? <span class="keyword">extends</span> Animal&gt; listAnimals</span></pre></td></tr></table></figure>

<p>为什么要使用通配符而不是简单的泛型呢？通配符其实在声明局部变量时是没有什么意义的，但是当你为一个方法声明一个参数时，它是非常重要的。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countLegs</span> <span class="params">(List&lt;? extends Animal &gt; animals )</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> ( Animal animal : animals )</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        retVal += animal.countLegs();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> retVal;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countLegs1</span> <span class="params">(List&lt; Animal &gt; animals )</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> ( Animal animal : animals )</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        retVal += animal.countLegs();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> retVal;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;Dog&gt; dogs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 不会报错</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    countLegs( dogs );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 报错</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    countLegs1(dogs);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>当调用 countLegs1 时，就会飘红，提示的错误信息如下：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829135619-25fc4.png" alt="img"></p>
<p>所以，对于不确定或者不关心实际要操作的类型，可以使用无限制通配符（尖括号里一个问号，即 &lt;?&gt; ），表示可以持有任何类型。像 countLegs 方法中，限定了上届，但是不关心具体类型是什么，所以对于传入的 Animal 的所有子类都可以支持，并且不会报错。而 countLegs1 就不行。</p>
<h3 id="上界通配符-lt-extends-E-gt"><a href="#上界通配符-lt-extends-E-gt" class="headerlink" title="上界通配符 &lt; ? extends E&gt;"></a>上界通配符 &lt; ? extends E&gt;</h3><blockquote>
<p>上届：用 extends 关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。</p>
</blockquote>
<p>在类型参数中使用 extends 表示这个泛型中的参数必须是 E 或者 E 的子类，这样有两个好处：</p>
<ul>
<li>如果传入的类型不是 E 或者 E 的子类，编译不成功</li>
<li>泛型中可以使用 E 的方法，要不然还得强转成 E 才能使用</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;K <span class="keyword">extends</span> A, E <span class="keyword">extends</span> B&gt; <span class="function">E <span class="title">test</span><span class="params">(K arg1, E arg2)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    E result = arg2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    arg2.compareTo(arg1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//.....</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> result;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>类型参数列表中如果有多个类型参数上限，用逗号分开</p>
</blockquote>
<h3 id="下界通配符-lt-super-E-gt"><a href="#下界通配符-lt-super-E-gt" class="headerlink" title="下界通配符 &lt; ? super E&gt;"></a>下界通配符 &lt; ? super E&gt;</h3><blockquote>
<p>下界: 用 super 进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object</p>
</blockquote>
<p>在类型参数中使用 super 表示这个泛型中的参数必须是 E 或者 E 的父类。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;<span class="type">T</span>&gt; void test(<span class="type">List</span>&lt;? <span class="keyword">super</span> <span class="type">T</span>&gt; dst, <span class="type">List</span>&lt;<span class="type">T</span>&gt; src)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="type">T</span> t : src) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dst.add(t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public static void main(<span class="type">String</span>[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="type">List</span>&lt;<span class="type">Dog</span>&gt; dogs = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="type">List</span>&lt;<span class="type">Animal</span>&gt; animals = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">new</span> <span class="type">Test3</span>().test(animals,dogs);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Dog 是 Animal 的子类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>dst 类型 “大于等于” src 的类型，这里的“大于等于”是指 dst 表示的范围比 src 要大，因此装得下 dst 的容器也就能装 src 。</p>
<h3 id="？-和-T-的区别"><a href="#？-和-T-的区别" class="headerlink" title="？ 和 T 的区别"></a>？ 和 T 的区别</h3><p><img src="http://image.winrains.cn/2019/08/20190829135619-75ae8.png" alt="img"></p>
<p>？和 T 都表示不确定的类型，区别在于我们可以对 T 进行操作，但是对 ？ 不行，比如如下这种 ：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">T t = operate<span class="comment">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 不可以</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">？ car = operate<span class="comment">()</span>;</span></pre></td></tr></table></figure>

<p>简单总结下：<br>T 是一个 确定的 类型，通常用于泛型类和泛型方法的定义，？是一个 不确定 的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。</p>
<h4 id="区别1：通过-T-来-确保-泛型参数的一致性"><a href="#区别1：通过-T-来-确保-泛型参数的一致性" class="headerlink" title="区别1：通过 T 来 确保 泛型参数的一致性"></a>区别1：通过 T 来 确保 泛型参数的一致性</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 T 来 确保 泛型参数的一致性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="built_in">Number</span>&gt; <span class="built_in">void</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">test(List&lt;T&gt; dest, List&lt;T&gt; src)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">test(List&lt;? <span class="keyword">extends</span> <span class="built_in">Number</span>&gt; dest, List&lt;? <span class="keyword">extends</span> <span class="built_in">Number</span>&gt; src)</span></pre></td></tr></table></figure>

<p>像下面的代码中，约定的 T 是 Number 的子类才可以，但是申明时是用的 String ，所以就会飘红报错。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829135620-2b52e.png" alt="img"></p>
<p>不能保证两个 List 具有相同的元素类型的情况</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">GlmapperGeneric&lt;<span class="keyword">String</span>&gt; glmapperGeneric = <span class="keyword">new</span> <span class="type">GlmapperGeneric</span>&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;<span class="keyword">String</span>&gt; dest = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;Number&gt; src = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">glmapperGeneric.testNon(dest,src);</span></pre></td></tr></table></figure>

<p>上面的代码在编译器并不会报错，但是当进入到 testNon 方法内部操作时（比如赋值），对于 dest 和 src 而言，就还是需要进行类型转换。</p>
<h4 id="区别2：类型参数可以多重限定而通配符不行"><a href="#区别2：类型参数可以多重限定而通配符不行" class="headerlink" title="区别2：类型参数可以多重限定而通配符不行"></a>区别2：类型参数可以多重限定而通配符不行</h4><p><img src="http://image.winrains.cn/2019/08/20190829135620-be4a2.png" alt="img"></p>
<p>使用 &amp; 符号设定多重边界（Multi Bounds)，指定泛型类型 T 必须是 MultiLimitInterfaceA 和 MultiLimitInterfaceB 的共有子类型，此时变量 t 就具有了所有限定的方法和属性。对于通配符来说，因为它不是一个确定的类型，所以不能进行多重限定。</p>
<h4 id="区别3：通配符可以使用超类限定而类型参数不行"><a href="#区别3：通配符可以使用超类限定而类型参数不行" class="headerlink" title="区别3：通配符可以使用超类限定而类型参数不行"></a>区别3：通配符可以使用超类限定而类型参数不行</h4><p>类型参数 T 只具有 一种 类型限定方式：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">T <span class="keyword">extends</span> A</span></pre></td></tr></table></figure>

<p>但是通配符 ? 可以进行 两种限定：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">? <span class="keyword">extends</span> A</span></pre></td></tr><tr><td class="code"><pre><span class="line">? <span class="keyword">super</span> A</span></pre></td></tr></table></figure>

<h2 id="Class-和-Class-区别"><a href="#Class-和-Class-区别" class="headerlink" title="Class 和 Class 区别"></a><code>Class</code> 和 <code>Class</code> 区别</h2><p>前面介绍了 ？ 和 T 的区别，那么对于，<code>Class</code> 和 `` 又有什么区别呢？<br><code>Class</code> 和 <code>Class</code><br>最常见的是在反射场景下的使用，这里以用一段发射的代码来说明下。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过反射的方式生成  multiLimit</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 对象，这里比较明显的是，我们需要使用强制类型转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">MultiLimit multiLimit = (MultiLimit)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name(<span class="string">"com.glmapper.bridge.boot.generic.MultiLimit"</span>)</span>.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span></pre></td></tr></table></figure>

<p>对于上述代码，在运行期，如果反射的类型不是 MultiLimit 类，那么一定会报 java.lang.ClassCastException 错误。<br>对于这种情况，则可以使用下面的代码来代替，使得在在编译期就能直接 检查到类型的问题：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829135621-e19b0.png" alt="img"></p>
<p><code>Class</code> 在实例化的时候，T 要替换成具体类。<code>Class</code> 它是个通配泛型，? 可以代表任何类型，所以主要用于声明时的限制情况。比如，我们可以这样做申明：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Class</span>&lt;?&gt; clazz;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 不可以，因为 T 需要指定类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Class</span>&lt;T&gt; clazzT;</span></pre></td></tr></table></figure>

<p>所以当不知道定声明什么类型的 Class 的时候可以定义一 个Class&lt;?&gt;。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829135622-b7ad1.png" alt="img"></p>
<p>那如果也想 <code>public Class clazzT;</code> 这样的话，就必须让当前的类也指定 T ，</p>
<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span>&lt;<span class="title">T</span>&gt; &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">Class</span>&lt;?&gt; <span class="title">clazz</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    // 不会报错</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">Class</span>&lt;<span class="title">T</span>&gt; <span class="title">clazzT</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文零碎整理了下 JAVA 泛型中的一些点，不是很全，仅供参考。如果文中有不当的地方，欢迎指正。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.toutiao.com%2Fa6694132392728199683">JAVA泛型通配符T，E，K，V区别，网友回复：一文秒懂</a></li>
</ul>
<blockquote>
<p>作者：glmapper</p>
<p>来源：<a href="https://juejin.im/post/5d5789d26fb9a06ad0056bd9" target="_blank" rel="noopener">https://juejin.im/post/5d5789d26fb9a06ad0056bd9</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring AOP介绍</title>
    <url>/2019/12/26/Spring-AOP%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="为什么要有aop"><a href="#为什么要有aop" class="headerlink" title="为什么要有aop"></a>为什么要有aop</h3><p>我们都知道Java是一种面向对象编程【也就是OOP】的语言，不得不说面向对象编程是一种及其优秀的设计，但是任何语言都无法十全十美，对于OOP语言来说，当需要为部分对象引入公共部分的时候，OOP就会引入大量的重复代码【这些代码我们可以称之为横切代码】。而这也是Aop出现的原因，没错，<strong>Aop就是被设计出来弥补OOP短板的</strong>。Aop便是将这些横切代码封装到一个可重用模块中，继而降低模块间的耦合度，这样也有利于后面维护。</p>
<a id="more"></a>

<h3 id="Aop是什么东西"><a href="#Aop是什么东西" class="headerlink" title="Aop是什么东西"></a>Aop是什么东西</h3><p>学过Spring的都知道，Spring内比较核心的功能便是Ioc和Aop，Ioc的主要作用是应用对象之间的解耦，而Aop则可以实现横切代码【如权限、日志等】与他们绑定的对象之间的解耦，举个浅显易懂的小栗子，在用户调用很多接口的地方，我们都需要做权限认证，判断用户是否有调用该接口的权限，如果每个接口都要自己去做类似的处理，未免有点sb了，也不够装x，因此Aop就可以派上用场了，将这些处理的代码放到切片中，定义一下切片、连接点和通知，刷刷刷跑起来就ojbk了。<br>想要了解Aop，就要先理解以下几个术语，如PointCut、Advice、JoinPoint。接下来尽量用白话文描述下。<br><strong>PointCut【切点】</strong> 其实切点的概念很好理解，你想要去切某个东西之前总得先知道要在哪里切入是吧，切点格式如下：execution(* com.nuofankj.springdemo.aop.<em>Service.</em>(..)) 可以看出来，格式使用了正常表达式来定义那个范围内的类、那些接口会被当成切点，简单明了。<br><strong>Advice</strong> Advice行内很多人都定义成了通知，但是我总觉得有点勉强。所谓的Advice其实就是定义了Aop何时被调用，确实有种通知的感觉，何时调用其实也不过以下几种：</p>
<ul>
<li>Before 在方法被调用之前调用</li>
<li>After 在方法完成之后调用</li>
<li>After-returning 在方法成功执行之后调用</li>
<li>After-throwing 在方法抛出异常之后调用</li>
<li>Around 在被通知的方法调用之前和调用之后调用</li>
</ul>
<p><strong>JoinPoint【连接点】</strong> JoinPoint连接点，其实很好理解，上面又有通知、又有切点，那和具体业务的连接点又是什么呢？没错，其实就是对应业务的方法对象，因为我们在横切代码中是有可能需要用到具体方法中的具体数据的，而连接点便可以做到这一点。</p>
<h3 id="给出一个Aop在实际中的应用场景"><a href="#给出一个Aop在实际中的应用场景" class="headerlink" title="给出一个Aop在实际中的应用场景"></a>给出一个Aop在实际中的应用场景</h3><p>先给出两个业务内的接口，一个是聊天，一个是购买东西</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140729-c2c96.png" alt="图片描述"></p>
<p><img src="http://image.winrains.cn/2019/08/20190829140730-705db.png" alt="图片描述"></p>
<p>接下来该给出说了那么久的切片了</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140730-b536d.png" alt="图片描述"></p>
<p>可以从中看到PointCut【切点】是</p>
<blockquote>
<p>execution(* com.nuofankj.springdemo.aop.<em>Service.</em>(..))</p>
</blockquote>
<p>Advice是</p>
<blockquote>
<p>Before</p>
</blockquote>
<p>JoinPoint【连接点】是</p>
<blockquote>
<p>MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod();</p>
</blockquote>
<p>代码浅显易懂，其实就是将ChatService和BuyService里边给userId做权限校验的逻辑抽出来做成切片。<br>那么如何拿到具体业务方法内的具体参数呢？ 这里是定义了一个新的注解</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140731-c3324.png" alt="图片描述"></p>
<p>作用可以直接看注释，使用地方如下</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140732-e1517.png" alt="图片描述"></p>
<p>可以看到对应接口使用了AuthPermission的注解，而取出的地方在于</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140732-ad2a0.png" alt="图片描述"></p>
<p>是的，这样便可以取出来对应的接口传递的userId具体是什么了，而校验逻辑可以自己处理。送佛送到西，不对，撸码撸整套，接下来给出运行的主类</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140733-a9a1f.png" alt="图片描述"></p>
<p>可以看到，上面有一个接口传递的userId是1，另一个是123，而上面权限认证只有1才说通过，否则会抛出异常。运行结果如下</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140734-55ef4.png" alt="图片描述"></p>
<p>运行结果可想而知，1的通过验证，123的失败。</p>
<h3 id="Spring-Aop做了什么【开始源码跟踪阅读】"><a href="#Spring-Aop做了什么【开始源码跟踪阅读】" class="headerlink" title="Spring Aop做了什么【开始源码跟踪阅读】"></a>Spring Aop做了什么【开始源码跟踪阅读】</h3><p>首先给出Main类</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140734-e3249.png" alt="2"></p>
<p>可以看到我这里用的是AnnotationConfigApplicationContext，解释下</p>
<blockquote>
<p>AnnotationConfigApplicationContext是一个用来管理注解bean的容器，所以我可以用该容器取得我定义了@Service注解的类的实例。</p>
</blockquote>
<p>打断点后，启动程序，我们可以看到TestDemo的实例在idea的表现是这样的</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140735-31fda.png" alt="3"></p>
<p>而BuyService的实例却不同</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140736-d6fe1.png" alt="4"></p>
<p>我们可以从看到BuyService是SpringCGLIB强化过的一个实例，那么问题来了</p>
<ul>
<li>为什么BuyService被强化过而TestDemo没有？</li>
<li>SpringCGLIB又是什么？</li>
<li>Spring是在什么时候生成一个强化后的实例的？</li>
</ul>
<p>带着这些疑问，让我们一步步从Spring源码中找到答案。<br><strong>为什么BuyService被强化过而TestDemo没有？</strong><br>这个问题比较简单，我们可以看回上面我对切片的定义</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140737-98698.png" alt="5"></p>
<p>可以从代码中看出，我定义的切点是<em>Service命名的类，而TestDemo很明显不符合这个设定，因此TestDemo逃过被强化的命运。<br>*</em>SpringCGLIB又是什么？**<br>CGLIB其实就是一种实现动态代理的技术，利用了ASM开源包，先将代理对象类的class文件加载进来，之后通过修改其字节码并且生成子类。结合demo来解读便是SpringCGLIB会先将BuyService加载到内存中，之后通过修改字节码生成BuyService的子类，该子类便是强化后的BuyService，上文看到的强化后的实例便是该子类的实例。<br><strong>Spring是在什么时候生成一个强化后的实例的？</strong><br>这个便厉害了，首先，我们要先从Spring如何加载切片入手。</p>
<blockquote>
<p><strong>【思考Time】</strong> 为什么我会选择从切片入手呢？原因很简单，Spring就是因为发现了切片，并且对切片进行解析后才知道了要强化哪些类。</p>
</blockquote>
<p><img src="http://image.winrains.cn/2019/08/20190829140737-9f030.png" alt="6"></p>
<p>切片的处理第一步便是要加上@Aspect注解，学过注解的都知道，注解的作用更多的是标志识别，也就是告诉Spring这个类要做相关特殊处理，因此我们可以基于该认识，反调该注解使用的地方</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140738-1885b.png" alt="7"></p>
<p>可以从截图看出，我反调了@Aspect后定位到了AbstractAspectJAdvisorFactory类中的hasAspectAnnotation函数，并且携带参数clazz，因此我猜测该接口就是用来识别clazz是否使用了注解@Aspect的地方，于是我打上了断点，并且加了条件 clazz == AuthAspect.class ，重新启动后</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140740-97aaf.png" alt="8"></p>
<p>我们看到确实被断点到了，可以得出我的猜测是对的。 我们先看下断点后做了什么事情，之后再看下具体是哪里进行了扫描。在断点处按F8继续往下走，最后发现</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140740-1f21b.png" alt="13"></p>
<p>没错，可以看到最终是构建成了一个Advisor对象 ，并且放入了BeanFactoryAspectJAdvisorsBuilder中的advisorsCache中，<strong>这样意味着Spring最终会将使用了@Aspect注解的类构建成Advisor对象后保存进BeanFactoryAspectJAdvisorsBuilder.advisorsCache中。</strong><br>接下来我们看看具体是哪里进行了使用@Aspect注解的相关类的扫描，这次我断点的地方在BeanFactoryAspectJAdvisorsBuilder中的advisorsCache调用了put的地方。</p>
<blockquote>
<p><strong>【思考Time】</strong> 为什么我会选择在advisorsCache调用了put的地方打断点呢？原因很简单，因为我们上面已经分析出@Aspect注解的类构建成Advisor对象后保存进BeanFactoryAspectJAdvisorsBuilder.advisorsCache中，而我通过反调知道put的地方只有一个，因此我可以断定在此处打断点可以知道到底哪里进行了扫描的操作。</p>
</blockquote>
<p><img src="http://image.winrains.cn/2019/08/20190829140741-95484.png" alt="14"></p>
<p>通过打断点后我从idea的Frames面板中看到</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140742-20566.png" alt="19"></p>
<p>没错，做了扫描@Aspect注解的扫描器是AbstractAutoProxyCreator类</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140743-80ddb.png" alt="11"></p>
<p><img src="http://image.winrains.cn/2019/08/20190829140743-99987.png" alt="12"></p>
<p>我们可以从中看到AbstractAutoProxyCreator最终实现了InstantiationAwareBeanPostProcessor接口。</p>
<blockquote>
<p><strong>【思考Time】</strong> 这个接口有什么作用呢？具体可以看我前阵子写的一篇文章：<a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fr2OEqsap6NgaEnNveO1mVg">mp.weixin.qq.com/s/r2OEqsap6…</a></p>
</blockquote>
<p>现在已经找到了扫描注解的地方，并且我们也看到了最终是生成了Advisor对象 ，并且放入了BeanFactoryAspectJAdvisorsBuilder中的advisorsCache中，那么Spring是在什么时候生成强化后的实例的呢？ 接下来我的切入点是AbstractAutoProxyCreator中的postProcessAfterInitialization接口。</p>
<blockquote>
<p><strong>【思考Time】</strong> 之所以会选择AbstractAutoProxyCreator为切入点，是因为通过命名可以看出这是SpringAop用来构建代理[强化]对象的地方，并且由于SpringCGLIB是先将目标类加载到内存中，之后通过修改字节码生成目标类的子类，因此我猜测强化是在目标类实例化后触发postProcessAfterInitialization的时候进行的。</p>
</blockquote>
<p>因此我在postProcessAfterInitialization接口中做了断点，并且加了调试条件。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140744-e739c.png" alt="14"></p>
<p>可以看到我这里断点到了ChatService这个类。</p>
<blockquote>
<p><strong>【思考Time】</strong> 为什么专门断点ChatService这个类？之所以会专门定位这个类，因为我的切面的目标类就包含了ChatService，通过定位到该类，我们可以一步步捕捉Spring的强化操作。</p>
</blockquote>
<p>我们可以看到，生成强化后的对象就藏在wrapIfNecessary中。</p>
<blockquote>
<p><strong>【思考Time】</strong> 为什么我会知道是生成强化后的对象就藏在wrapIfNecessary中呢？因为我通过调试发现，在调用了wrapIfNecessary接口后，返回的对象是强化后的对象。</p>
</blockquote>
<p>那么问题来了，为什么Spring会知道ChatService类需要进行进行强化呢？我们可以从wrapIfNecessary中走入更深一层，通过调试，可以看到</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140744-61c41.png" alt="16"></p>
<p>在此处会从advisorsCache中根据aspectName取出对应的Advisor。拿到Advisor后，便是进行过滤的地方了，通过F8往后走，可以看到过滤的地方在AopUtils.canApply接口中。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140745-70bb8.png" alt="17"></p>
<p>可以看到此处传进来的targetClass符合切面的要求，因此可以进行构建强化对象。 接下来让我们看下真正产生强化对象的地方了</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140746-c6df7.png" alt="18"></p>
<p>我们可以看到在AbstractAutoProxyCreator的createProxy函数中看到，最后会构造出一个强化后的chatService。 那么createProxy又做了什么呢？通过断点一层层深入后，发现最后会到达</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140747-61a37.png" alt="18"></p>
<p>通过源码分析，我们发现在AbstractAutoProxyCreator构建强化对象的时候是调用了createAopProxy函数，重点来了，我们可以看到针对targetClass，也就是ChatService做了判断，如果targetClass有实现接口或者targetClass是Proxy的子类，那么使用的是JDK的动态代理实现AOP，如果不是才会使用CGLIB实现动态代理。<br><strong>那么JDK实现的动态代理和CGLIB实现的动态代理有什么区别吗？</strong> 首先动态代理可以分为两种：JDK动态代理和CGLIB动态代理。从文中我们也可以看出，当目标类有接口的时候才会使用JDK动态代理，其实是因为JDK动态代理无法代理一个没有接口的类。JDK动态代理是利用反射机制生成一个实现代理接口的匿名类，而CGLIB是针对类实现代理，主要是对指定的类生成一个子类，并且覆盖其中的方法。</p>
<h3 id="Aop实现机制之代理模式"><a href="#Aop实现机制之代理模式" class="headerlink" title="Aop实现机制之代理模式"></a>Aop实现机制之代理模式</h3><p>本来想一篇文章说完源码跟踪分析Aop和Aop的实现机制代理模式，发现源码跟踪分析已经很占篇幅了，因此没办法只能再开一篇文章专门阐述Aop的实现机制代理模式，期待下篇文章。<br>大家都知道，我有个习惯，在动手写一篇文章之前会先将该文章相关的资料仔细琢磨一遍，然后再结合源码再调试一遍，结果，说好的</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140748-b1917.png" alt="img"></p>
<p>看源码也确实是</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140748-23b5b.png" alt="img"></p>
<p>源码确实有进行了是否是接口的判断，但是问题来了，我调试的时候发现无论代理类是否有接口，最终都会被强制使用CGLIB代理，没办法，只能翻看SpringBoot的相关文档，最终发现原来SpringBoot从2.0开始就默认使用Cglib代理了，好家伙，怪不得我调试半天找不到原因。<br>那么如何解决呢？肯定是通过配置啦，按照如下配置即可</p>
<blockquote>
<p>在application.properties文件中配置 spring.aop.proxy-target-class=false</p>
</blockquote>
<p>即可。</p>
<blockquote>
<p><strong>【划重点】</strong> 曾经遇见过面试官问，SpringBoot默认代理类型是什么？看完该篇文章，我们就可以果断的回答是Cglib代理了。通过调试代码发现的规则，我想我这辈子都不会忘记这个默认规则。</p>
</blockquote>
<h3 id="动态代理原理剖析"><a href="#动态代理原理剖析" class="headerlink" title="动态代理原理剖析"></a>动态代理原理剖析</h3><h4 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h4><p>简单来说，就是在运行的时候为目标类动态生成代理类，而在操作的时候都是操作代理类，代理模式有个显而易见的好处，那便是可以在不改变对象方法的情况下对方法进行增强。试想下，我们在<a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FtQLO-lF_HiG6YK1kGQeD9w">你必须要懂的Spring-Aop之应用篇</a>有提到使用Aop来做权限认证，如果不用Aop，那么我们就必须要为所有需要权限认证的方法都加上权限认证代码，听起来就觉得<strong>蛋疼</strong>，你觉得对不对？</p>
<h4 id="为什么不用静态代理"><a href="#为什么不用静态代理" class="headerlink" title="为什么不用静态代理"></a>为什么不用静态代理</h4><p>静态代理类不是说不可以用，如果只有一个类需要被代理，那么自然可以用，如 这是在<a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FtQLO-lF_HiG6YK1kGQeD9w">你必须要懂的Spring-Aop之应用篇</a>使用的一个例子类，该类的作用只是打印出我要买东西。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140748-979ec.png" alt="3"></p>
<p>代理类如下</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140749-8c4a0.png" alt="4"></p>
<p>可以看到这个BuyProxy代理类只是塞了一个IBuyServcie接口进行，而且自身也实现了接口IBuyService，而在buyItem方法被调用的时候会先做自己的操作，再调用塞进去的接口的buyItem方法。 测试类很简单，如下</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140750-74a87.png" alt="5"></p>
<p>运行后很自然而然的打印出</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140751-89b3c.png" alt="6"></p>
<p>静态代理就是简单，但是<strong>弊端</strong>也很明显，如果有多个类都需要同样的代理，都实现了同样的接口，那么如果使用静态代理的话，我们就要构造多个Proxy类，就会造成<strong>类爆炸</strong>。 而使用了Aop后，也就是动态代理后，便可以一次性解决该问题了，具体可以看<a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FtQLO-lF_HiG6YK1kGQeD9w">你必须要懂的Spring-Aop之应用篇</a>中的操作方法。</p>
<h4 id="JDK动态代理原理"><a href="#JDK动态代理原理" class="headerlink" title="JDK动态代理原理"></a>JDK动态代理原理</h4><p>这里给出一个JDK动态代理的demo 首先给出一个简单的业务类，Hello类和接口</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140751-69aba.png" alt="7"></p>
<p><img src="http://image.winrains.cn/2019/08/20190829140751-de9d6.png" alt="8"></p>
<p>真正实现了类的代理功能的其实就是这个实现了接口InvocationHandler的JdkProxy类</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140752-d5d78.png" alt="9"></p>
<p>我们可以看到其中必须实现的方法是invoke，可以看到invoke方法的参数带有Method对象，这个就是我们的目标Method，现在我们的目的就是要在这个Method在被调用前后实现我们的业务，可以看到在method.invoke反调前后实现了before和after业务。<br>这里再给出一个Main测试类，作用是取得Hello的代理类，然后调用其中的say方法。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140753-a95d2.png" alt="10"></p>
<p>运行结果如下</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140754-ab525.png" alt="11"></p>
<p><strong>原理很简单</strong> 在JdkProxyMain中hello调用say的时候，由于Hello已经被“代理”了，所以在调用say函数的时候其实是调用JdkProxy类中的invoke函数，而在invoke函数中先是实现了before函数才实现Object result = method.invoke(target, args)，这一句其实是调用say函数，而后才实现after函数，于是这样就可以不必在改动目标类的前提下实现代理了，并且不会像静态代理那样导致类爆炸。</p>
<h4 id="CGLIB动态代理原理"><a href="#CGLIB动态代理原理" class="headerlink" title="CGLIB动态代理原理"></a>CGLIB动态代理原理</h4><p>先给出一个Cglib动态代理的demo</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140754-4e272.png" alt="13"></p>
<p>核心类是实现了MethodInterceptor的CGlibProxy类</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140754-3e363.png" alt="14"></p>
<p>可以看到其中实现了方法intercept，先是在目标函数被调用前实现自己的业务，比如before()和after()，之后再通过 proxy.invokeSuper(obj, args) 触发目标函数。<br>最后给出入口类</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140755-ec283.png" alt="15"></p>
<p>最后给出运行类，运行类如下</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140756-563b0.png" alt="15"></p>
<p>可以看到运行结果</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140756-eeee5.png" alt="16"></p>
<p><strong>原理很简单</strong> 在CglibProxyMain中hello调用say的时候，由于Hello已经被“代理”了，所以在调用say函数的时候其实是调用CGlibProxy类中的intercept函数。</p>
<blockquote>
<p>作者：饭谈编程</p>
<p>来源：<a href="https://juejin.im/post/5d558819e51d45620b21c3a7" target="_blank" rel="noopener">https://juejin.im/post/5d558819e51d45620b21c3a7</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring7大知识点</title>
    <url>/2019/12/26/Spring7%E5%A4%A7%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>Spring框架自诞生以来一直备受开发者青睐，有人亲切的称之为：Spring 全家桶。它包括SpringMVC、SpringBoot、Spring Cloud、Spring Cloud Dataflow等解决方案。<br>很多研发人员把spring看作心目中最好的java项目，没有之一。<br>所以这是重点也是难点，工作中必须会，面试时肯定考。<br><strong>那么，今天花费10分钟，梳理Spring框架相关知识</strong>。</p>
<a id="more"></a>

<h1 id="一、Spring知识点-汇总"><a href="#一、Spring知识点-汇总" class="headerlink" title="一、Spring知识点-汇总"></a>一、Spring知识点-汇总</h1><hr>
<p>spring系列包含非常多的项目，可以满足java开发中的方方面面。<br>先来看常用框架的知识点汇总，如图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829141013-a68f8.png" alt="img"></p>
<h2 id="Ⅰ、5个常用的spring框架"><a href="#Ⅰ、5个常用的spring框架" class="headerlink" title="Ⅰ、5个常用的spring框架"></a>Ⅰ、5个常用的spring框架</h2><hr>
<h3 id="1-spring-framework"><a href="#1-spring-framework" class="headerlink" title="1.spring framework"></a>1.spring framework</h3><p>也就是我们经常说的spring框架，包括了ioc依赖注入，Context上下文、bean管理、springmvc等众多功能模块，其它spring项目比如spring boot也会依赖spring框架。</p>
<h3 id="2-spring-boot"><a href="#2-spring-boot" class="headerlink" title="2.spring boot"></a>2.spring boot</h3><p>它的目标是简化Spring应用和服务的创建、开发与部署，简化了配置文件，使用嵌入式web服务器，含有诸多开箱即用的微服务功能，可以和spring cloud联合部署。<br>Spring Boot的核心思想是约定大于配置，应用只需要很少的配置即可，简化了应用开发模式。</p>
<h3 id="3-Spring-Data"><a href="#3-Spring-Data" class="headerlink" title="3.Spring Data"></a>3.Spring Data</h3><p>是一个数据访问及操作的工具集，封装了多种数据源的操作能力，包括：jdbc、Redis、MongoDB等。</p>
<h3 id="4-Spring-Cloud"><a href="#4-Spring-Cloud" class="headerlink" title="4.Spring Cloud"></a>4.Spring Cloud</h3><p>是一套完整的微服务解决方案，是一系列不同功能的微服务框架的集合。Spring Cloud基于Spring Boot，简化了分布式系统的开发，集成了服务发现、配置管理、消息总线、负载均衡、断路器、数据监控等各种服务治理能力。比如sleuth提供了全链路追踪能力，Netflix套件提供了hystrix熔断器、zuul网关等众多的治理组件。config组件提供了动态配置能力，bus组件支持使用RabbitMQ、kafka、Activemq等消息队列，实现分布式服务之间的事件通信。</p>
<h3 id="5-Spring-Security"><a href="#5-Spring-Security" class="headerlink" title="5. Spring Security"></a>5. Spring Security</h3><p>主要用于快速构建安全的应用程序和服务，在Spring Boot和Spring Security OAuth2的基础上，可以快速实现常见安全模型，如单点登录，令牌中继和令牌交换。你可以了解一下oauth2授权机制和jwt认证方式。oauth2是一种授权机制，规定了完备的授权、认证流程。JWT全称是JSON Web Token，是一种把认证信息包含在token中的认证实现，oauth2授权机制中就可以应用jwt来作为认证的具体实现方法。</p>
<h2 id="Ⅱ、Struts的具体作用"><a href="#Ⅱ、Struts的具体作用" class="headerlink" title="Ⅱ、Struts的具体作用"></a>Ⅱ、Struts的具体作用</h2><hr>
<p>struts是曾经非常火爆的web组合ssh中的控制层。我们知道web服务一般都采用MVC分层模型构建，就是model层负责内部数据模型，controller负责请求的分发控制，view层负责返回给用户展示的视图。struts实现的就是其中控制层的角色。<br>Struts采用Filter实现，针对类进行拦截，每次请求就会创建一个Action。使用struts的SSH组合已经逐渐被使用springMVC的SSM组合代替，也就是Spring-MVC+Spring+MyBatis的组合，一方面原因是由于struts对几次安全漏洞的处理，让大家对struts的信心受到影响；另一方面，springmvc更加的灵活，不需要额外配置，不存在和spring整合等问题，使用更加方便，所以建议以SSM框架的学习为主。</p>
<h2 id="Ⅲ、常用的ORM框架"><a href="#Ⅲ、常用的ORM框架" class="headerlink" title="Ⅲ、常用的ORM框架"></a>Ⅲ、常用的ORM框架</h2><hr>
<p>ORM就是对象关系匹配，是为了解决面向对象与关系数据库存在的互不匹配的问题。简单来说，就是把关系数据库中的数据转换成面向对象程序中的对象。<br>常用的ORM框架有Hibernate和MyBatis，也就是ssh组合和ssm组合中的h与m。<br><strong>它们的特点和区别如下</strong>：<br>Hibernate对数据库结构提供了完整的封装，实现了POJO对象与数据库表之间的映射，能够自动生成并执行SQL语句。只要定义了POJO 到数据库表的映射关系，就可以通过Hibernate提供的方法完成数据库操作。Hibernate符合JPA规范，就是Java持久层API。<br>mybatis通过映射配置文件，将SQL所需的参数和返回的结果字段映射到指定对象，mybatis不会自动生成sql，需要自己定义sql语句，不过更方便对sql语句进行优化。<br><strong>总结起来</strong>：</p>
<ol>
<li>hibernate配置要比mybatis复杂的多，学习成本也比mybatis高。mybatis，简单、高效、灵活，但是需要自己维护sql；</li>
<li>hibernate功能强大、全自动、适配不同数据库，但是非常复杂，灵活性稍差。</li>
</ol>
<h2 id="Ⅳ、Netty简介"><a href="#Ⅳ、Netty简介" class="headerlink" title="Ⅳ、Netty简介"></a>Ⅳ、Netty简介</h2><hr>
<p>Netty是一个高性能的异步事件驱动的网络通信框架，Netty对JDK原生NIO进行封装，简化了网络服务的开发。下文会详细讲解<br>另外，同类型的框架还有mina、grizzly，不过目前使用的相对较少，一般不会在面试中出现，可以作为兴趣简单了解。</p>
<h2 id="Ⅴ、RPC服务"><a href="#Ⅴ、RPC服务" class="headerlink" title="Ⅴ、RPC服务"></a>Ⅴ、RPC服务</h2><hr>
<p>Motan、Dubbo、gRPC都是比较常用的高性能rpc框架，可以提供完善的服务治理能力，java版本的通信层都是基于前面提到的Netty实现。它们的特点稍后介绍。</p>
<h2 id="Ⅵ、其他常用框架"><a href="#Ⅵ、其他常用框架" class="headerlink" title="Ⅵ、其他常用框架"></a>Ⅵ、其他常用框架</h2><hr>
<p>jersy和restEasy都是可以快速开发restful服务的框架。<br>和springmvc相比，这两个框架都是基于jax-rs标准，而springmvcs基于servlet，使用自己构建的API，是两个不同的标准。<br>shiro框架是一个与spring security类似的开源的权限管理框架，用于访问授权、认证、加密及会话管理。能够支持单机与分布式session管理。<br>相比security，shiro更加简单易用。</p>
<h1 id="二、Spring知识点-详解"><a href="#二、Spring知识点-详解" class="headerlink" title="二、Spring知识点-详解"></a>二、Spring知识点-详解</h1><hr>
<h2 id="Ⅰ、spring基本概念"><a href="#Ⅰ、spring基本概念" class="headerlink" title="Ⅰ、spring基本概念"></a>Ⅰ、spring基本概念</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141014-5112a.png" alt="Sping中的基本概念"></p>
<p>本文涉及的流程与实现默认都是基于最新的5.x版本。<br>spring中的几个重要概念如下：</p>
<h3 id="1-IOC"><a href="#1-IOC" class="headerlink" title="1.IOC"></a>1.IOC</h3><p>IOC，就是控制反转，如最左边，拿公司招聘岗位来举例：<br>假设一个公司有产品、研发、测试等岗位。如果是公司根据岗位要求，逐个安排人选，如图中向下的箭头，这是正向流程。如果反过来，不用公司来安排候选人，而是由第三方猎头来匹配岗位和候选人，然后进行推荐，如图中向上的箭头，这就是控制反转。<br>在spring中，对象的属性是由对象自己创建的，就是正向流程；如果属性不是对象创建，而是由spring来自动进行装配，就是控制反转。这里的DI也就是依赖注入，就是实现控制反转的方式。正向流程导致了对象于对象之间的高耦合，IOC可以解决对象耦合的问题，有利于功能的复用，能够使程序的结构变得非常灵活。</p>
<h3 id="2-context上下文和bean"><a href="#2-context上下文和bean" class="headerlink" title="2.context上下文和bean"></a>2.context上下文和bean</h3><p>spring进行IOC实现时使用的有两个概念：context上下文和bean。<br>如中间图所示，所有被spring管理的、由spring创建的、用于依赖注入的对象，就叫做一个bean。Spring创建并完成依赖注入后，所有bean统一放在一个叫做context的上下文中进行管理。</p>
<h3 id="3-AOP"><a href="#3-AOP" class="headerlink" title="3.AOP"></a>3.AOP</h3><p>AOP就是面向切面编程。如右面的图，一般程序执行流程是从controller层调用service层、然后service层调用DAO层访问数据，最后在逐层返回结果。<br>这个是图中向下箭头所示的按程序执行顺序的纵向处理。但是，一个系统中会有多个不同的服务，例如用户服务、商品信息服务等等，每个服务的controller层都需要验证参数，都需要处理异常，如果按照图中红色的部分，对不同服务的纵向处理流程进行横切，在每个切面上完成通用的功能，例如身份认证、验证参数、处理异常等等、这样就不用在每个服务中都写相同的逻辑了，这就是AOP思想解决的问题。<br>AOP以功能进行划分，对服务顺序执行流程中的不同位置进行横切，完成各服务共同需要实现的功能。</p>
<h2 id="Ⅱ、spring框架"><a href="#Ⅱ、spring框架" class="headerlink" title="Ⅱ、spring框架"></a>Ⅱ、spring框架</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141015-b9e55.png" alt="Spring框架组件"></p>
<p>上图列出了spring框架主要包含的组件。这张图来自spring4.x的文档。目前最新的5.x版本中右面的portlet组件已经被废弃掉，同时增加了用于异步响应式处理的WebFlux组件。<br>并不需要对所有的组件都详细了解，只需重点了解最常用的几个组件实现，以及知道每个组件用来实现哪一类功能。<br>图中红框是比较重要的组件，core组件是spring所有组件的核心；bean组件和context组件我刚才提到了，是实现IOC和依赖注入的基础；AOP组件用来实现面向切面编程；web组件包括springmvc是web服务的控制层实现。</p>
<h2 id="Ⅲ、spring中机制和实现"><a href="#Ⅲ、spring中机制和实现" class="headerlink" title="Ⅲ、spring中机制和实现"></a>Ⅲ、spring中机制和实现</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141015-66563.png" alt="img"></p>
<h3 id="1-AOP"><a href="#1-AOP" class="headerlink" title="1.AOP"></a>1.AOP</h3><p>AOP的实现是通过代理模式，在调用对象的某个方法时，执行插入的切面逻辑。实现的方式有动态代理也叫运行时增强，比如jdk代理、CGLIB；静态代理是在编译时进行织入或类加载时进行织入，比如AspectJ。<br>关于AOP还需要了解一下对应的Aspect、pointcut、advice等注解和具体使用方式。</p>
<h3 id="2-placeHolder动态替换"><a href="#2-placeHolder动态替换" class="headerlink" title="2.placeHolder动态替换"></a>2.placeHolder动态替换</h3><p>主要需要了解替换发生的时间，是在bean definition创建完成后，bean初始化之前，是通过实现<code>BeanFactoryPostProcessor</code>接口实现的。主要实现方式有<code>PropertyPlaceholderConfigurer</code>和<code>PropertySourcesPlaceholderConfigurer</code>。这两个类实现逻辑不一样，spring boot使用<code>PropertySourcesPlaceholderConfigurer</code>实现。</p>
<h3 id="3-事务"><a href="#3-事务" class="headerlink" title="3.事务"></a>3.事务</h3><p>需要了解spring 中对事务规定的隔离类型和事务传播类型。要知道事务的隔离级别是由具体的数据库来实现的，在数据库部分我会详细介绍。<br>事务的传播类型，可以重点了解最常用的REQUIRED和SUPPORTS类型。</p>
<h3 id="4-核心接口类"><a href="#4-核心接口类" class="headerlink" title="4.核心接口类"></a>4.核心接口类</h3><ul>
<li>ApplicationContext保存了ioc的整个应用上下文，可以通过其中的beanfactory获取到任意到bean；</li>
<li>BeanFactory主要的作用是根据bean definition来创建具体的bean；</li>
<li>BeanWrapper是对Bean的包装，一般情况下是在spring ioc内部使用，提供了访问bean的属性值、属性编辑器注册、类型转换等功能，方便ioc容器用统一的方式来访问bean的属性；</li>
<li>FactoryBean通过getObject方法返回实际的bean对象，例如motan框架中referer对service的动态代理就是通过FactoryBean来实现的。</li>
</ul>
<h3 id="5-Scope"><a href="#5-Scope" class="headerlink" title="5.Scope"></a>5.Scope</h3><p>bean的scope是指bean的作用域，默认情况下是单例模式，这也是使用最多的一种方式；多例模式，即每次从beanFactory中获取bean都会创建一个新的bean。<br>request、session、global-session是在web服务中使用的scope，request每次请求都创建一个实例，session是在一个会话周期内保证只有一个实例。<br>global-session在5.x版本中已经不在使用，同时增加了Application和Websocket两种scope，分别保证在一个ServletContext与一个WebSocket中只创建一个实例。</p>
<h3 id="6-事件机制"><a href="#6-事件机制" class="headerlink" title="6.事件机制"></a>6.事件机制</h3><p>spring的事件机制需要知道spring定义的五种标准事件，具体事件可见上图，了解如何自定义事件和实现对应的applicationListener来处理自定义事件。</p>
<h2 id="Ⅳ、spring应用相关"><a href="#Ⅳ、spring应用相关" class="headerlink" title="Ⅳ、spring应用相关"></a>Ⅳ、spring应用相关</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141016-e1017.png" alt="img"></p>
<h3 id="1-常用注释"><a href="#1-常用注释" class="headerlink" title="1.常用注释"></a>1.常用注释</h3><h4 id="a-类型类注释："><a href="#a-类型类注释：" class="headerlink" title="a.类型类注释："></a><strong>a.类型类注释</strong>：</h4><p>类型类注释包括<code>controller</code>、<code>service</code>等，需要重点了解<br>其中<code>component</code>和<code>bean</code>注解的区别如下：</p>
<ul>
<li><code>@Component</code>注解在类上使用表明这个类是个组件类，需要Spring为这个类创建bean。</li>
<li><code>@Bean</code>注解使用在方法上，告诉Spring这个方法将会返回一个Bean对象，需要把返回的对象注册到Spring的应用上下文中。</li>
</ul>
<h4 id="b-设置类注解"><a href="#b-设置类注解" class="headerlink" title="b.设置类注解"></a><strong>b.设置类注解</strong></h4><p>重点了解<code>@Autowire</code>和<code>@Qualifier</code>以及bytype、byname等不同的自动装配机制。</p>
<h4 id="c-web类注解"><a href="#c-web类注解" class="headerlink" title="c.web类注解"></a><strong>c.web类注解</strong></h4><p>主要以了解为主，关注<code>@RequestMapping</code>、<code>@GetMapping</code>、<code>@PostMapping</code>等路径匹配注解，以及<code>@PathVariable</code>、<code>@RequestParam</code> 等参数获取注解。</p>
<h4 id="d-功能类注解"><a href="#d-功能类注解" class="headerlink" title="d.功能类注解"></a><strong>d.功能类注解</strong></h4><p>包括<code>@ImportResource</code>引用配置、<code>@ComponentScan</code>注解自动扫描、<code>@Transactional</code>事务注解等等，这里不一一介绍了。</p>
<h3 id="2-配置方式"><a href="#2-配置方式" class="headerlink" title="2.配置方式"></a>2.配置方式</h3><p>需要了解配置spring的几种方式，xml文件配置、注解配置和使用api进行配置。<br>自动装配机制需要了解按类型匹配进行自动装配，按bean名称进行自动装配，构造器中的自动装配和自动检测等主要的四种方式。<br>还需要了解一下list、set、map等集合类属性的配置方式以及内部bean的使用。</p>
<h2 id="Ⅴ、Spring的Context的初始化流程"><a href="#Ⅴ、Spring的Context的初始化流程" class="headerlink" title="Ⅴ、Spring的Context的初始化流程"></a>Ⅴ、Spring的Context的初始化流程</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141016-37f83.png" alt="Spring Context初始化流程"></p>
<p>图中左上角是三种类型的context，xml配置方式的context、springboot的context和web服务的context。不论哪种context，创建后都会调用到AbstractApplicationContext类的refresh方法，这个方法是我们要重点分析的。<br><strong>refresh方法中，操作共分13步</strong>：<br><strong>第1步</strong>：对刷新进行准备，包括设置开始时间、设置激活状态、初始化context环境中的占位符，这个动作根据子类的需求由子类来执行，然后验证是否缺失必要的properties；<br><strong>第2步</strong>：刷新并获得内部的bean factory；<br><strong>第3步</strong>：对bean factory进行准备工作，比如设置类加载器和后置处理器、配置不进行自动装配的类型、注册默认的环境bean；<br><strong>第4步</strong>：为context的子类提供后置处理bean factory的扩展能力。如果子类想在bean定义加载完成后，开始初始化上下文之前做一些特殊逻辑，可以复写这个方法；<br><strong>第5步</strong>，执行context中注册的bean factory后缀处理器；</p>
<blockquote>
<p>注：这里有两种后置处理器，一种是可以注册bean的后缀处理器，另一种是针对bean factory进行处理的后置处理器。执行的顺序是，先按优先级执行可注册bean的处理器，在按优先级执行针对beanfactory的处理器。</p>
</blockquote>
<blockquote>
<p>对springboot来说，这一步会进行注解bean definition的解析。流程如右面小框中所示，由ConfigurationClassPostProcessor触发、由ClassPathBeanDefinitionScanner解析并注册到bean factory。</p>
</blockquote>
<p><strong>第6步</strong>：按优先级顺序在beanfactory中注册bean的后缀处理器，bean后置处理器可以在bean初始化前、后执行处理；<br><strong>第7步</strong>：初始化消息源，消息源用来支持消息的国际化；<br><strong>第8步</strong>：初始化应用事件广播器。事件广播器用来向applicationListener通知各种应用产生的事件，是一个标准的观察者模式；<br><strong>第9步</strong>：是留给子类的扩展步骤，用来让特定的context子类初始化其他的bean；<br><strong>第10步</strong>：把实现了ApplicationListener的bean注册到事件广播器，并对广播器中的早期未广播事件进行通知；<br><strong>第11步</strong>：冻结所有bean描述信息的修改，实例化非延迟加载的单例bean；<br><strong>第12步</strong>：完成上下文的刷新工作，调用LifecycleProcessor的onFresh()方法以及发布ContextRefreshedEvent事件；<br><strong>第13步</strong>：在finally中，执行第十三步，重置公共的缓存，比如ReflectionUtils中的缓存、AnnotationUtils中的缓存等等；<br>至此，spring的context初始化完成。这里仅介绍了最主要的主流程，建议课后阅读源码来复习这个知识点，补全细节。</p>
<h2 id="Ⅵ、Spring中bean的生命周期"><a href="#Ⅵ、Spring中bean的生命周期" class="headerlink" title="Ⅵ、Spring中bean的生命周期"></a>Ⅵ、Spring中bean的生命周期</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141016-8d203.png" alt="Spring中bean的生命周期"></p>
<p><strong>面试中经常问到的bean的生命周期，先看绿色的部分，bean的创建过程</strong>：<br><strong>第1步</strong>：调用bean的构造方法创建bean；<br><strong>第2步</strong>：通过反射调用setter方法进行属性的依赖注入；<br><strong>第3步</strong>：如果实现BeanNameAware接口的话，会设置bean的name；<br><strong>第4步</strong>：如果实现了BeanFactoryAware，会把bean factory设置给bean；<br><strong>第5步</strong>：如果实现了ApplicationContextAware，会给bean设置ApplictionContext；<br><strong>第6步</strong>：如果实现了BeanPostProcessor接口，则执行前置处理方法；<br><strong>第7步</strong>：实现了InitializingBean接口的话，执行afterPropertiesSet方法；<br><strong>第8步</strong>：执行自定义的init方法；<br><strong>第9步</strong>：执行BeanPostProcessor接口的后置处理方法。<br>这时，就完成了bean的创建过程。<br>在使用完bean需要销毁时，会先执行DisposableBean接口的destroy方法，然后在执行自定义的destroy方法。<br>这部分也建议阅读源码加深理解。</p>
<h2 id="Ⅶ、Spring扩展接口"><a href="#Ⅶ、Spring扩展接口" class="headerlink" title="Ⅶ、Spring扩展接口"></a>Ⅶ、Spring扩展接口</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141018-3633a.png" alt="Spring扩展接口"></p>
<p>对spring进行定制化功能扩展时，可以选择如下一些扩展点：</p>
<h3 id="1-BeanFactoryPostProcessor"><a href="#1-BeanFactoryPostProcessor" class="headerlink" title="1.BeanFactoryPostProcessor"></a>1.BeanFactoryPostProcessor</h3><p>是beanFactory后置处理器，支持在bean factory标准初始化完成后，对bean factory进行一些额外处理。在讲context初始化流程时介绍过，这时所有的bean的描述信息已经加载完毕，但是还没有进行bean初始化。例如前面提到的PropertyPlaceholderConfigurer，就是在这个扩展点上对bean属性中的占位符进行替换。</p>
<h3 id="2-BeanDefinitionRegistryPostProcessor"><a href="#2-BeanDefinitionRegistryPostProcessor" class="headerlink" title="2.BeanDefinitionRegistryPostProcessor"></a>2.BeanDefinitionRegistryPostProcessor</h3><p>它扩展自BeanFactoryPostProcessor，在执行BeanFactoryPostProcessor的功能前，提供了可以添加bean definition的能力，允许在初始化一般bean前，注册额外的bean。例如可以在这里根据bean的scope创建一个新的代理bean。</p>
<h3 id="3-BeanPostProcessor"><a href="#3-BeanPostProcessor" class="headerlink" title="3.BeanPostProcessor"></a>3.BeanPostProcessor</h3><p>提供了在bean初始化之前和之后插入自定义逻辑的能力。与BeanFactoryPostProcessor的区别是处理的对象不同，BeanFactoryPostProcessor是对beanfactory进行处理，BeanPostProcessor是对bean进行处理。</p>
<blockquote>
<p>注：上面这三个扩展点，可以通过实现Ordered和PriorityOrdered接口来指定执行顺序。实现PriorityOrdered接口的processor会先于实现Ordered接口的执行。</p>
</blockquote>
<h3 id="4-ApplicationContextAware"><a href="#4-ApplicationContextAware" class="headerlink" title="4.ApplicationContextAware"></a>4.ApplicationContextAware</h3><p>可以获得ApplicationContext及其中的bean，当需要在代码中动态获取bean时，可以通过实现这个接口来实现。</p>
<h3 id="5-InitializingBean"><a href="#5-InitializingBean" class="headerlink" title="5.InitializingBean"></a>5.InitializingBean</h3><p>可以在bean初始化完成，所有属性设置完成后执行特定逻辑，例如对自动装配对属性进行验证等等。</p>
<h3 id="6-DisposableBean"><a href="#6-DisposableBean" class="headerlink" title="6.DisposableBean"></a>6.DisposableBean</h3><p>用于在bean被销毁前执行特定的逻辑，例如做一些回收工作等。</p>
<h3 id="7-ApplicationListener"><a href="#7-ApplicationListener" class="headerlink" title="7.ApplicationListener"></a>7.ApplicationListener</h3><p>用来监听spring的标准应用事件或者自定义事件。</p>
<h2 id="Ⅷ、springboot相关的知识点"><a href="#Ⅷ、springboot相关的知识点" class="headerlink" title="Ⅷ、springboot相关的知识点"></a>Ⅷ、springboot相关的知识点</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141019-666c3.png" alt="img"></p>
<h3 id="1-启动流程"><a href="#1-启动流程" class="headerlink" title="1.启动流程"></a>1.启动流程</h3><p>主要步骤首先要配置environment，然后准备context上下文，包括执行applicationContext的后置处理、初始化initializer、通知listener处理contextPrepared和contextLoaded事件。最后执行refreshContext，也就是前面介绍过的AbstractApplicationContext类的refresh方法。</p>
<h3 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2.配置文件"></a>2.配置文件</h3><p>然后要知道在Spring Boot中有两种上下文，一种是bootstrap, 另外一种是application。<br>bootstrap是应用程序的父上下文，也就是说bootstrap会先于applicaton加载。bootstrap主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。bootstrap里面的属性会优先加载，默认也不能被本地相同配置覆盖。</p>
<h3 id="3-注解"><a href="#3-注解" class="headerlink" title="3.注解"></a>3.注解</h3><p><code>@SpringBootApplication</code>包含了<code>@ComponentScan</code>、<code>@EnableAutoConfiguration</code>、<code>@SpringBootConfiguration</code>三个注解<br>而<code>@SpringBootConfiguration</code>注解包含了<code>@Configuration</code>注解。也就是springboot的自动配置功能。<br><code>@Conditional</code>注解就是控制自动配置的生效条件的注解，例如bean或class存在、不存在时进行配置，当满足条件时进行配置等等。</p>
<h3 id="4-特色模块"><a href="#4-特色模块" class="headerlink" title="4.特色模块"></a>4.特色模块</h3><ul>
<li>starter是springboot提供的无缝集成功能的一种方式，使用某个功能时开发者不需要关注各种依赖库的处理，不需要具体的配置信息，由Spring Boot自动配置进行bean的创建。例如需要使用web功能时，只需要在依赖中引入spring-boot-starter-web即可。</li>
<li>actuator是用来对应用程序进行监视和管理，通过restful api请求来监管、审计、收集应用的运行情况。</li>
<li>devtools提供了一系列开发工具的支持，来提高开发效率。例如热部署能力等。</li>
<li>CLI就是命令行接口，是一个命令行工具，支持使用Groovy脚本，可以快速搭建spring原型项目。</li>
</ul>
<p>以上为Spring框架需要掌握的内容，前面提到的核心机制、核心流程，建议阅读源码加深理解。</p>
<blockquote>
<p>作者：Java_苏先生</p>
<p>来源：<a href="https://juejin.im/post/5cc175e2e51d456e2e656d7b" target="_blank" rel="noopener">https://juejin.im/post/5cc175e2e51d456e2e656d7b</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>BeanFactory和ApplicationContext的区别</title>
    <url>/2019/12/26/BeanFactory%E5%92%8CApplicationContext%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>接口 BeanFactory 和 ApplicationContext 都是用来从容器中获取 Spring beans 的，但是，他们二者有很大不同</p>
</blockquote>
<p>我看到过很多问 BeanFactory 和 ApplicationContext 不同点的问题，考虑到这，我应该使用前者还是后者从 Spring 容器中获取 beans 呢？请向下看</p>
<a id="more"></a>

<h2 id="什么是-Spring-Bean"><a href="#什么是-Spring-Bean" class="headerlink" title="什么是 Spring Bean"></a>什么是 Spring Bean</h2><p>这是一个非常简单而又很复杂的问题，通常来说，Spring beans 就是被 Spring 容器所管理的 Java 对象，来看一个简单的例子</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package com.zoltanraffai;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">String</span> message;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(<span class="keyword">String</span> message)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">this</span>.message  = message;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMessage</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      System.out.<span class="built_in">println</span>(<span class="string">"My Message : "</span> + message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在基于 XML 的配置中， beans.xml 为 Spring 容器管理 bean 提供元数据</p>
<h2 id="什么是-Spring-容器"><a href="#什么是-Spring-容器" class="headerlink" title="什么是 Spring 容器"></a>什么是 Spring 容器</h2><p>Spring 容器负责实例化，配置和装配 Spring beans，下面来看如何为 IoC 容器配置我们的 HelloWorld POJO</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version = "1.0" encoding = "UTF-8"?&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span> = <span class="string">"http://www.springframework.org/schema/beans"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span> = <span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span> = <span class="string">"http://www.springframework.org/schema/beans</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"helloWorld"</span> <span class="attr">class</span> = <span class="string">"com.zoltanraffai.HelloWorld"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"message"</span> <span class="attr">value</span> = <span class="string">"Hello World!"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<p>现在，它已经被 Spring 容器管理了，接下来的问题是：我们怎样获取它？</p>
<h2 id="BeanFactory-和-ApplicationContext-的不同点"><a href="#BeanFactory-和-ApplicationContext-的不同点" class="headerlink" title="BeanFactory 和 ApplicationContext 的不同点"></a>BeanFactory 和 ApplicationContext 的不同点</h2><h3 id="BeanFactory-接口"><a href="#BeanFactory-接口" class="headerlink" title="BeanFactory 接口"></a>BeanFactory 接口</h3><p>这是一个用来访问 Spring 容器的 root 接口，要访问 Spring 容器，我们将使用 Spring 依赖注入功能，使用 BeanFactory 接口和它的子接口 <strong>特性：</strong></p>
<ul>
<li>Bean 的实例化/串联 通常情况，BeanFactory 的实现是使用懒加载的方式，这意味着 beans 只有在我们通过 getBean() 方法直接调用它们时才进行实例化 实现 BeanFactory 最常用的 API 是 XMLBeanFactory 这里是如何通过 BeanFactory 获取一个 bean 的例子：</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">package com.zoltanraffai;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.<span class="keyword">factory</span>.InitializingBean;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.<span class="keyword">factory</span>.xml.XmlBeanFactory;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldApp</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      XmlBeanFactory <span class="keyword">factory</span> = <span class="keyword">new</span> XmlBeanFactory (<span class="keyword">new</span> ClassPathResource(<span class="string">"beans.xml"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">      HelloWorld obj = (HelloWorld) <span class="keyword">factory</span>.getBean(<span class="string">"helloWorld"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      obj.getMessage();</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="ApplicationContext-接口"><a href="#ApplicationContext-接口" class="headerlink" title="ApplicationContext 接口"></a>ApplicationContext 接口</h3><p>ApplicationContext 是 Spring 应用程序中的中央接口，用于向应用程序提供配置信息 它继承了 BeanFactory 接口，所以 ApplicationContext 包含 BeanFactory 的所有功能以及更多功能！它的主要功能是支持大型的业务应用的创建 <strong>特性：</strong></p>
<ul>
<li>Bean instantiation/wiring</li>
<li>Bean 的实例化/串联</li>
<li>自动的 BeanPostProcessor 注册</li>
<li>自动的 BeanFactoryPostProcessor 注册</li>
<li>方便的 MessageSource 访问（i18n）</li>
<li>ApplicationEvent 的发布 与 BeanFactory 懒加载的方式不同，它是预加载，所以，每一个 bean 都在 ApplicationContext 启动之后实例化 这里是 ApplicationContext 的使用例子：</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package com.zoltanraffai;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.xml.XmlBeanFactory;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldApp</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ApplicationContext context=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      HelloWorld obj = (HelloWorld) context.getBean(<span class="string">"helloWorld"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      obj.getMessage();</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>ApplicationContext 包含 BeanFactory 的所有特性，通常推荐使用前者。但是也有一些限制情形，比如移动应用内存消耗比较严苛，在那些情景中，使用更轻量级的 BeanFactory 是更合理的。然而，在大多数企业级的应用中，ApplicationContext 是你的首选。</p>
</blockquote>
<blockquote>
<p>作者：日拱一兵</p>
<p>来源：<a href="https://juejin.im/post/5d195530f265da1bb80c4560" target="_blank" rel="noopener">https://juejin.im/post/5d195530f265da1bb80c4560</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>面试中常问的Spring方面问题</title>
    <url>/2019/12/26/%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%B8%B8%E9%97%AE%E7%9A%84Spring%E6%96%B9%E9%9D%A2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>Spring Framework 现在几乎已成为 Java Web 开发的标配框架。那么，作为 Java 程序员，你对 Spring 的主要技术点又掌握了多少呢？不妨用本文的问题来检测一下。</p>
<a id="more"></a>

<h2 id="1、一般问题"><a href="#1、一般问题" class="headerlink" title="1、一般问题"></a>1、一般问题</h2><h3 id="1-1-不同版本的-Spring-Framework-有哪些主要功能？"><a href="#1-1-不同版本的-Spring-Framework-有哪些主要功能？" class="headerlink" title="1.1. 不同版本的 Spring Framework 有哪些主要功能？"></a>1.1. 不同版本的 Spring Framework 有哪些主要功能？</h3><p>VersionFeatureSpring 2.5发布于 2007 年。这是第一个支持注解的版本。Spring 3.0发布于 2009 年。它完全利用了 Java5 中的改进，并为 JEE6 提供了支持。Spring 4.0发布于 2013 年。这是第一个完全支持 JAVA8 的版本。</p>
<h3 id="1-2-什么是-Spring-Framework？"><a href="#1-2-什么是-Spring-Framework？" class="headerlink" title="1.2. 什么是 Spring Framework？"></a>1.2. 什么是 Spring Framework？</h3><ul>
<li>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</li>
<li>它是轻量级、松散耦合的。</li>
<li>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</li>
<li>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。</li>
</ul>
<h3 id="1-3-列举-Spring-Framework-的优点。"><a href="#1-3-列举-Spring-Framework-的优点。" class="headerlink" title="1.3. 列举 Spring Framework 的优点。"></a>1.3. 列举 Spring Framework 的优点。</h3><ul>
<li>由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。</li>
<li>Spring Framework 支持 POJO(Plain Old Java Object) 编程，从而具备持续集成和可测试性。</li>
<li>由于依赖注入和控制反转，JDBC 得以简化。</li>
<li>它是开源免费的。</li>
</ul>
<h3 id="1-4-Spring-Framework-有哪些不同的功能？"><a href="#1-4-Spring-Framework-有哪些不同的功能？" class="headerlink" title="1.4. Spring Framework 有哪些不同的功能？"></a>1.4. Spring Framework 有哪些不同的功能？</h3><ul>
<li><strong>轻量级</strong> - Spring 在代码量和透明度方面都很轻便。</li>
<li><strong>IOC</strong> - 控制反转</li>
<li><strong>AOP</strong> - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。</li>
<li><strong>容器</strong> - Spring 负责创建和管理对象（Bean）的生命周期和配置。</li>
<li><strong>MVC</strong> - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</li>
<li><strong>事务管理</strong> - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。</li>
<li><strong>JDBC 异常</strong> - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</li>
</ul>
<h3 id="1-5-Spring-Framework-中有多少个模块，它们分别是什么？"><a href="#1-5-Spring-Framework-中有多少个模块，它们分别是什么？" class="headerlink" title="1.5. Spring Framework 中有多少个模块，它们分别是什么？"></a>1.5. Spring Framework 中有多少个模块，它们分别是什么？</h3><p><img src="http://image.winrains.cn/2019/08/641e0-2c9c6daadf8154be46afbfd87d3e5824.jpeg-wh_651x-s_919540347.jpeg" alt="http://image.winrains.cn/2019/08/641e0-2c9c6daadf8154be46afbfd87d3e5824.jpeg-wh_651x-s_919540347.jpeg"></p>
<ul>
<li><p>Spring 核心容器</p>
<p> – 该层基本上是 Spring Framework 的核心。它包含以下模块：</p>
<ul>
<li>Spring Core</li>
<li>Spring Bean</li>
<li>SpEL (Spring Expression Language)</li>
<li>Spring Context</li>
</ul>
</li>
<li><p>数据访问/集成</p>
<p> – 该层提供与数据库交互的支持。它包含以下模块：</p>
<ul>
<li>JDBC (Java DataBase Connectivity)</li>
<li>ORM (Object Relational Mapping)</li>
<li>OXM (Object XML Mappers)</li>
<li>JMS (Java Messaging Service)</li>
<li>Transaction</li>
</ul>
</li>
<li><p>Web</p>
<p> – 该层提供了创建 Web 应用程序的支持。它包含以下模块：</p>
<ul>
<li>Web</li>
<li>Web – Servlet</li>
<li>Web – Socket</li>
<li>Web – Portlet</li>
</ul>
</li>
<li><p><strong>AOP</strong> – 该层支持面向切面编程</p>
</li>
<li><p><strong>Instrumentation</strong> – 该层为类检测和类加载器实现提供支持。</p>
</li>
<li><p><strong>Test</strong> – 该层为使用 JUnit 和 TestNG 进行测试提供支持。</p>
</li>
<li><p>几个杂项模块:</p>
<ul>
<li>Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。</li>
<li>Aspects – 该模块为与 AspectJ 的集成提供支持。</li>
</ul>
</li>
</ul>
<h3 id="1-6-什么是-Spring-配置文件？"><a href="#1-6-什么是-Spring-配置文件？" class="headerlink" title="1.6. 什么是 Spring 配置文件？"></a>1.6. 什么是 Spring 配置文件？</h3><p>Spring 配置文件是 XML 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。但是，XML 配置文件冗长且更加干净。如果没有正确规划和编写，那么在大项目中管理变得非常困难。</p>
<h3 id="1-7-Spring-应用程序有哪些不同组件？"><a href="#1-7-Spring-应用程序有哪些不同组件？" class="headerlink" title="1.7. Spring 应用程序有哪些不同组件？"></a>1.7. Spring 应用程序有哪些不同组件？</h3><p>Spring 应用一般有以下组件：</p>
<ul>
<li><strong>接口</strong> - 定义功能。</li>
<li><strong>Bean 类</strong> - 它包含属性，setter 和 getter 方法，函数等。</li>
<li><strong>Spring 面向切面编程（AOP）</strong> - 提供面向切面编程的功能。</li>
<li><strong>Bean 配置文件</strong> - 包含类的信息以及如何配置它们。</li>
<li><strong>用户程序</strong> - 它使用接口。</li>
</ul>
<h3 id="1-8-使用-Spring-有哪些方式？"><a href="#1-8-使用-Spring-有哪些方式？" class="headerlink" title="1.8. 使用 Spring 有哪些方式？"></a>1.8. 使用 Spring 有哪些方式？</h3><p>使用 Spring 有以下方式：</p>
<ul>
<li>作为一个成熟的 Spring Web 应用程序。</li>
<li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li>
<li>用于远程使用。</li>
<li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li>
</ul>
<h2 id="2、依赖注入（Ioc）"><a href="#2、依赖注入（Ioc）" class="headerlink" title="2、依赖注入（Ioc）"></a>2、依赖注入（Ioc）</h2><h3 id="2-1-什么是-Spring-IOC-容器？"><a href="#2-1-什么是-Spring-IOC-容器？" class="headerlink" title="2.1. 什么是 Spring IOC 容器？"></a>2.1. 什么是 Spring IOC 容器？</h3><p>Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过 XML，Java 注解或 Java 代码提供。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829143756-2ecdd.jpeg" alt="img"></p>
<h3 id="2-2-什么是依赖注入？"><a href="#2-2-什么是依赖注入？" class="headerlink" title="2.2. 什么是依赖注入？"></a>2.2. 什么是依赖注入？</h3><p>在依赖注入中，您不必创建对象，但必须描述如何创建它们。您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。由 IoC 容器将它们装配在一起。</p>
<h3 id="2-3-可以通过多少种方式完成依赖注入？"><a href="#2-3-可以通过多少种方式完成依赖注入？" class="headerlink" title="2.3. 可以通过多少种方式完成依赖注入？"></a>2.3. 可以通过多少种方式完成依赖注入？</h3><p>通常，依赖注入可以通过三种方式完成，即：</p>
<ul>
<li>构造函数注入</li>
<li>setter 注入</li>
<li>接口注入</li>
</ul>
<p>在 Spring Framework 中，仅使用构造函数和 setter 注入。</p>
<h3 id="2-4-区分构造函数注入和-setter-注入。"><a href="#2-4-区分构造函数注入和-setter-注入。" class="headerlink" title="2.4. 区分构造函数注入和 setter 注入。"></a>2.4. 区分构造函数注入和 setter 注入。</h3><p>构造函数注入setter 注入没有部分注入有部分注入不会覆盖 setter 属性会覆盖 setter 属性任意修改都会创建一个新实例任意修改不会创建一个新实例适用于设置很多属性适用于设置少量属性</p>
<h3 id="2-5-spring-中有多少种-IOC-容器？"><a href="#2-5-spring-中有多少种-IOC-容器？" class="headerlink" title="2.5. spring 中有多少种 IOC 容器？"></a>2.5. spring 中有多少种 IOC 容器？</h3><ul>
<li>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。</li>
<li>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。</li>
</ul>
<h3 id="2-6-区分-BeanFactory-和-ApplicationContext。"><a href="#2-6-区分-BeanFactory-和-ApplicationContext。" class="headerlink" title="2.6. 区分 BeanFactory 和 ApplicationContext。"></a>2.6. 区分 BeanFactory 和 ApplicationContext。</h3><p>BeanFactoryApplicationContext它使用懒加载它使用即时加载它使用语法显式提供资源对象它自己创建和管理资源对象不支持国际化支持国际化不支持基于依赖的注解支持基于依赖的注解</p>
<h3 id="2-7-列举-IoC-的一些好处。"><a href="#2-7-列举-IoC-的一些好处。" class="headerlink" title="2.7. 列举 IoC 的一些好处。"></a>2.7. 列举 IoC 的一些好处。</h3><p>IoC 的一些好处是：</p>
<ul>
<li>它将最小化应用程序中的代码量。</li>
<li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li>
<li>它以最小的影响和最少的侵入机制促进松耦合。</li>
<li>它支持即时的实例化和延迟加载服务。</li>
</ul>
<h3 id="2-8-Spring-IoC-的实现机制。"><a href="#2-8-Spring-IoC-的实现机制。" class="headerlink" title="2.8. Spring IoC 的实现机制。"></a>2.8. Spring IoC 的实现机制。</h3><p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。<br>示例：</p>
<p><img src="http://image.winrains.cn/2019/08/a4f36-223b876d39a7bd0d001271c445d56aa7.jpeg" alt="http://image.winrains.cn/2019/08/a4f36-223b876d39a7bd0d001271c445d56aa7.jpeg"></p>
<h2 id="3-Beans"><a href="#3-Beans" class="headerlink" title="3. Beans"></a>3. Beans</h2><h3 id="3-1-什么是-spring-bean？"><a href="#3-1-什么是-spring-bean？" class="headerlink" title="3.1. 什么是 spring bean？"></a>3.1. 什么是 spring bean？</h3><ul>
<li>它们是构成用户应用程序主干的对象。</li>
<li>Bean 由 Spring IoC 容器管理。</li>
<li>它们由 Spring IoC 容器实例化，配置，装配和管理。</li>
<li>Bean 是基于用户提供给容器的配置元数据创建。</li>
</ul>
<h3 id="3-2-spring-提供了哪些配置方式？"><a href="#3-2-spring-提供了哪些配置方式？" class="headerlink" title="3.2. spring 提供了哪些配置方式？"></a>3.2. spring 提供了哪些配置方式？</h3><ul>
<li><ul>
<li>基于 xml 配置</li>
</ul>
</li>
</ul>
<p>bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">"studentbean"</span> <span class="built_in">class</span>=<span class="string">"org.edureka.firstSpring.StudentBean"</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"name"</span> value=<span class="string">"Edureka"</span>&gt;&lt;/<span class="keyword">property</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;/bean&gt;</span></pre></td></tr></table></figure>

<ul>
<li>基于注解配置</li>
</ul>
<p>您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bean definitions go here --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<ul>
<li>基于 Java API 配置</li>
</ul>
<p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>
<ol>
<li>@Bean 注解扮演与 <bean /> 元素相同的角色。</li>
<li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="3-3-spring-支持集中-bean-scope？"><a href="#3-3-spring-支持集中-bean-scope？" class="headerlink" title="3.3. spring 支持集中 bean scope？"></a>3.3. spring 支持集中 bean scope？</h3><p>Spring bean 支持 5 种 scope：</p>
<ul>
<li><strong>Singleton</strong> - 每个 Spring IoC 容器仅有一个单实例。</li>
<li><strong>Prototype</strong> - 每次请求都会产生一个新的实例。</li>
<li><strong>Request</strong> - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。</li>
<li><strong>Session</strong> - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。</li>
<li><strong>Global-session</strong> - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。</li>
</ul>
<p>仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。</p>
<h3 id="3-4-spring-bean-容器的生命周期是什么样的？"><a href="#3-4-spring-bean-容器的生命周期是什么样的？" class="headerlink" title="3.4. spring bean 容器的生命周期是什么样的？"></a>3.4. spring bean 容器的生命周期是什么样的？</h3><p>spring bean 容器的生命周期流程如下：</p>
<ol>
<li>Spring 容器根据配置中的 bean 定义中实例化 bean。</li>
<li>Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。</li>
<li>如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。</li>
<li>如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。</li>
<li>如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。</li>
<li>如果为 bean 指定了 init 方法（<bean> 的 init-method 属性），那么将调用它。</li>
<li>最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。</li>
<li>如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。</li>
<li>如果为 bean 指定了 destroy 方法（<bean> 的 destroy-method 属性），那么将调用它。<img src="http://image.winrains.cn/2019/08/af3ef-41bc3485d75dc4aabe3d843ac2048790.jpeg" alt="http://image.winrains.cn/2019/08/af3ef-41bc3485d75dc4aabe3d843ac2048790.jpeg"></li>
</ol>
<h3 id="3-5-什么是-spring-的内部-bean？"><a href="#3-5-什么是-spring-的内部-bean？" class="headerlink" title="3.5. 什么是 spring 的内部 bean？"></a>3.5. 什么是 spring 的内部 bean？</h3><p>只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean。为了定义 bean，Spring 的基于 XML 的配置元数据在 <property> 或 <constructor-arg>中提供了 <bean> 元素的使用。内部 bean 总是匿名的，它们总是作为原型。<br>例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。<br>Student.java</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Student</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Person person;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//Setters and Getters</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Person</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> String name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> String address;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//Setters and Getters</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>bean.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“StudentBean</span>" <span class="attr">class</span>=<span class="string">"com.edureka.Student"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"person"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!--This is inner bean --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.edureka.Person"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">“Scott</span>"&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">value</span>=<span class="string">“Bangalore</span>"&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>

<h3 id="3-6-什么是-spring-装配？"><a href="#3-6-什么是-spring-装配？" class="headerlink" title="3.6. 什么是 spring 装配？"></a>3.6. 什么是 spring 装配？</h3><p>当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。 Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。</p>
<h3 id="3-7-自动装配有哪些方式？"><a href="#3-7-自动装配有哪些方式？" class="headerlink" title="3.7. 自动装配有哪些方式？"></a>3.7. 自动装配有哪些方式？</h3><p>Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。<br>自动装配的不同模式：</p>
<ul>
<li><strong>no</strong> - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li>
<li><strong>byName</strong> - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</li>
<li><strong>byType</strong> - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</li>
<li><strong>构造函数</strong> - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li>
<li><strong>autodetect</strong> - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li>
</ul>
<h3 id="3-8-自动装配有什么局限？"><a href="#3-8-自动装配有什么局限？" class="headerlink" title="3.8. 自动装配有什么局限？"></a>3.8. 自动装配有什么局限？</h3><ul>
<li>覆盖的可能性 - 您始终可以使用 <constructor-arg> 和 <property> 设置指定依赖项，这将覆盖自动装配。</li>
<li>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</li>
<li>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</li>
</ul>
<h2 id="4、注解"><a href="#4、注解" class="headerlink" title="4、注解"></a>4、注解</h2><h3 id="4-1-什么是基于注解的容器配置？"><a href="#4-1-什么是基于注解的容器配置？" class="headerlink" title="4.1. 什么是基于注解的容器配置？"></a>4.1. 什么是基于注解的容器配置？</h3><p>不使用 XML 来描述 bean 装配，开发人员通过在相关的类，方法或字段声明上使用注解将配置移动到组件类本身。它可以作为 XML 设置的替代方案。例如：<br>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>
<ul>
<li>@Bean 注解扮演与</li>
<li>元素相同的角色。</li>
<li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="4-2-如何在-spring-中启动注解装配？"><a href="#4-2-如何在-spring-中启动注解装配？" class="headerlink" title="4.2. 如何在 spring 中启动注解装配？"></a>4.2. 如何在 spring 中启动注解装配？</h3><p>默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置&lt;context：annotation-config /&gt; 元素在 Spring 配置文件中启用它。</p>
<h3 id="4-3-Component-Controller-Repository-Service-有何区别？"><a href="#4-3-Component-Controller-Repository-Service-有何区别？" class="headerlink" title="4.3. @Component, @Controller, @Repository, @Service 有何区别？"></a>4.3. @Component, @Controller, @Repository, @Service 有何区别？</h3><ul>
<li>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li>
<li>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</li>
<li>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</li>
<li>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li>
</ul>
<h3 id="4-4-Required-注解有什么用？"><a href="#4-4-Required-注解有什么用？" class="headerlink" title="4.4. @Required 注解有什么用？"></a>4.4. @Required 注解有什么用？</h3><p>@Required 应用于 bean 属性 setter 方法。此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性。如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。<br>示例：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Required</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name=name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">return</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="4-5-Autowired-注解有什么用？"><a href="#4-5-Autowired-注解有什么用？" class="headerlink" title="4.5. @Autowired 注解有什么用？"></a>4.5. @Autowired 注解有什么用？</h3><p>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是类型驱动的注入。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name=name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="4-6-Qualifier-注解有什么用？"><a href="#4-6-Qualifier-注解有什么用？" class="headerlink" title="4.6. @Qualifier 注解有什么用？"></a>4.6. @Qualifier 注解有什么用？</h3><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。<br>例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount 中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。<br>Employee.java</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>EmpAccount.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpAccount</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Employee emp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Qualifier</span>(emp1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showName</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Employee name : "</span> + emp.getName);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="4-7-RequestMapping-注解有什么用？"><a href="#4-7-RequestMapping-注解有什么用？" class="headerlink" title="4.7. @RequestMapping 注解有什么用？"></a>4.7. @RequestMapping 注解有什么用？</h3><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：</p>
<ul>
<li>类级别：映射请求的 URL</li>
<li>方法级别：映射 URL 以及 HTTP 请求方法</li>
</ul>
<h2 id="5、数据访问"><a href="#5、数据访问" class="headerlink" title="5、数据访问"></a>5、数据访问</h2><h3 id="5-1-spring-DAO-有什么用？"><a href="#5-1-spring-DAO-有什么用？" class="headerlink" title="5.1. spring DAO 有什么用？"></a>5.1. spring DAO 有什么用？</h3><p>Spring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p>
<h3 id="5-2-列举-Spring-DAO-抛出的异常。"><a href="#5-2-列举-Spring-DAO-抛出的异常。" class="headerlink" title="5.2. 列举 Spring DAO 抛出的异常。"></a>5.2. 列举 Spring DAO 抛出的异常。</h3><p><img src="http://image.winrains.cn/2019/08/caa7f-d6ebd1c162702b14bf48320d0ce48921.jpeg" alt="http://image.winrains.cn/2019/08/caa7f-d6ebd1c162702b14bf48320d0ce48921.jpeg"></p>
<h3 id="5-3-spring-JDBC-API-中存在哪些类？"><a href="#5-3-spring-JDBC-API-中存在哪些类？" class="headerlink" title="5.3. spring JDBC API 中存在哪些类？"></a>5.3. spring JDBC API 中存在哪些类？</h3><ul>
<li>JdbcTemplate</li>
<li>SimpleJdbcTemplate</li>
<li>NamedParameterJdbcTemplate</li>
<li>SimpleJdbcInsert</li>
<li>SimpleJdbcCall</li>
</ul>
<h3 id="5-4-使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#5-4-使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="5.4. 使用 Spring 访问 Hibernate 的方法有哪些？"></a>5.4. 使用 Spring 访问 Hibernate 的方法有哪些？</h3><p>我们可以通过两种方式使用 Spring 访问 Hibernate：</p>
<ol>
<li>使用 Hibernate 模板和回调进行控制反转</li>
<li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li>
</ol>
<h3 id="5-5-列举-spring-支持的事务管理类型"><a href="#5-5-列举-spring-支持的事务管理类型" class="headerlink" title="5.5. 列举 spring 支持的事务管理类型"></a>5.5. 列举 spring 支持的事务管理类型</h3><p>Spring 支持两种类型的事务管理：</p>
<ol>
<li>程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。</li>
<li>声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。</li>
</ol>
<h3 id="5-6-spring-支持哪些-ORM-框架？"><a href="#5-6-spring-支持哪些-ORM-框架？" class="headerlink" title="5.6. spring 支持哪些 ORM 框架？"></a>5.6. spring 支持哪些 ORM 框架？</h3><ul>
<li>Hibernate</li>
<li>iBatis</li>
<li>JPA</li>
<li>JDO</li>
<li>OJB</li>
</ul>
<h2 id="6、AOP"><a href="#6、AOP" class="headerlink" title="6、AOP"></a>6、AOP</h2><h3 id="6-1-什么是-AOP？"><a href="#6-1-什么是-AOP？" class="headerlink" title="6.1. 什么是 AOP？"></a>6.1. 什么是 AOP？</h3><p>AOP(Aspect-Oriented Programming), 即 <strong>面向切面编程</strong>, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角.<br>在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 <strong>Aspect(切面)</strong></p>
<h3 id="6-2-什么是-Aspect？"><a href="#6-2-什么是-Aspect？" class="headerlink" title="6.2. 什么是 Aspect？"></a>6.2. 什么是 Aspect？</h3><p>aspect 由 pointcount 和 advice 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.<br>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p>
<ol>
<li>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上</li>
<li>如何在 advice 中编写切面代码.</li>
</ol>
<p><strong>可以简单地认为, 使用 @Aspect 注解的类就是切面.</strong><br><img src="http://image.winrains.cn/2019/08/2a040-bc1af77af5b09fb02a8920292ff4f8e1.jpeg" alt="http://image.winrains.cn/2019/08/2a040-bc1af77af5b09fb02a8920292ff4f8e1.jpeg"></p>
<h3 id="6-3-什么是切点（JoinPoint）"><a href="#6-3-什么是切点（JoinPoint）" class="headerlink" title="6.3. 什么是切点（JoinPoint）"></a>6.3. 什么是切点（JoinPoint）</h3><p>程序运行中的一些时间点, 例如一个方法的执行, 或者是一个异常的处理.<br>在 Spring AOP 中, join point 总是方法的执行点。</p>
<h3 id="6-4-什么是通知（Advice）？"><a href="#6-4-什么是通知（Advice）？" class="headerlink" title="6.4. 什么是通知（Advice）？"></a>6.4. 什么是通知（Advice）？</h3><p>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice。Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的拦截器。</p>
<h3 id="6-5-有哪些类型的通知（Advice）？"><a href="#6-5-有哪些类型的通知（Advice）？" class="headerlink" title="6.5. 有哪些类型的通知（Advice）？"></a>6.5. 有哪些类型的通知（Advice）？</h3><ul>
<li><strong>Before</strong> - 这些类型的 Advice 在 joinpoint 方法之前执行，并使用 @Before 注解标记进行配置。</li>
<li><strong>After Returning</strong> - 这些类型的 Advice 在连接点方法正常执行后执行，并使用@AfterReturning 注解标记进行配置。</li>
<li><strong>After Throwing</strong> - 这些类型的 Advice 仅在 joinpoint 方法通过抛出异常退出并使用 @AfterThrowing 注解标记配置时执行。</li>
<li><strong>After (finally)</strong> - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @After 注解标记进行配置。</li>
<li><strong>Around</strong> - 这些类型的 Advice 在连接点之前和之后执行，并使用 @Around 注解标记进行配置。</li>
</ul>
<h3 id="6-6-指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处"><a href="#6-6-指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处" class="headerlink" title="6.6. 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处"></a>6.6. 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处</h3><p>concern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。<br>cross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。</p>
<h3 id="6-7-AOP-有哪些实现方式"><a href="#6-7-AOP-有哪些实现方式" class="headerlink" title="6.7. AOP 有哪些实现方式"></a>6.7. AOP 有哪些实现方式</h3><p>实现 AOP 的技术，主要分为两大类：</p>
<ul>
<li>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；</li>
<li>编译时编织（特殊编译器实现）</li>
<li>类加载时编织（特殊的类加载器实现）。</li>
<li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</li>
<li>JDK 动态代理</li>
<li>CGLIB</li>
</ul>
<h3 id="6-8-Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#6-8-Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="6.8. Spring AOP and AspectJ AOP 有什么区别？"></a>6.8. Spring AOP and AspectJ AOP 有什么区别？</h3><p>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。<br>Spring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。</p>
<h3 id="6-9-如何理解-Spring-中的代理？"><a href="#6-9-如何理解-Spring-中的代理？" class="headerlink" title="6.9. 如何理解 Spring 中的代理？"></a>6.9. 如何理解 Spring 中的代理？</h3><p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。<br>Advice + Target Object = Proxy</p>
<h3 id="6-10-什么是编织（Weaving）？"><a href="#6-10-什么是编织（Weaving）？" class="headerlink" title="6.10. 什么是编织（Weaving）？"></a>6.10. 什么是编织（Weaving）？</h3><p>为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）。在 Spring AOP 中，编织在运行时执行。请参考下图：<br><img src="http://image.winrains.cn/2019/08/dfa9f-801b410c598b76a9ac602373008c90e1.jpeg" alt="http://image.winrains.cn/2019/08/dfa9f-801b410c598b76a9ac602373008c90e1.jpeg"></p>
<h2 id="7、MVC"><a href="#7、MVC" class="headerlink" title="7、MVC"></a>7、MVC</h2><h3 id="7-1-Spring-MVC-框架有什么用？"><a href="#7-1-Spring-MVC-框架有什么用？" class="headerlink" title="7.1. Spring MVC 框架有什么用？"></a>7.1. Spring MVC 框架有什么用？</h3><p>Spring Web MVC 框架提供 <strong>模型-视图-控制器</strong> 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。 MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。</p>
<h3 id="7-2-描述一下-DispatcherServlet-的工作流程"><a href="#7-2-描述一下-DispatcherServlet-的工作流程" class="headerlink" title="7.2. 描述一下 DispatcherServlet 的工作流程"></a><strong>7.2. 描述一下 DispatcherServlet 的工作流程</strong></h3><p>DispatcherServlet 的工作流程可以用一幅图来说明：<br><img src="http://image.winrains.cn/2019/08/62864-0a2ce874e9e8b25d524d2fe7b4da8770.jpeg" alt="http://image.winrains.cn/2019/08/62864-0a2ce874e9e8b25d524d2fe7b4da8770.jpeg"></p>
<ol>
<li>向服务器发送 HTTP 请求，请求被前端控制器 DispatcherServlet 捕获。</li>
<li>DispatcherServlet 根据 <strong>-servlet.xml</strong> 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以HandlerExecutionChain 对象的形式返回。</li>
<li>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的 preHandler(…)方法）。</li>
<li>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：</li>
</ol>
<ul>
<li>HttpMessageConveter： 将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。</li>
<li>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等。</li>
<li>数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。</li>
<li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中。</li>
</ul>
<ol>
<li>Handler(Controller)执行完成后，向 DispatcherServlet 返回一个ModelAndView 对象；</li>
<li>根据返回的ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的ViewResolver)返回给DispatcherServlet。</li>
<li>ViewResolver 结合Model和View，来渲染视图。</li>
<li>视图负责将渲染结果返回给客户端。</li>
</ol>
<h3 id="7-3-介绍一下-WebApplicationContext"><a href="#7-3-介绍一下-WebApplicationContext" class="headerlink" title="7.3. 介绍一下 WebApplicationContext"></a><strong>7.3. 介绍一下 WebApplicationContext</strong></h3><p>WebApplicationContext 是 ApplicationContext 的扩展。它具有 Web 应用程序所需的一些额外功能。它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。</p>
<blockquote>
<p>作者：51CTO</p>
<p>来源：<a href="http://developer.51cto.com/art/201808/580655.htm" target="_blank" rel="noopener">http://developer.51cto.com/art/201808/580655.htm</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring使用注解式声明与使用切面</title>
    <url>/2019/12/26/Spring%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%A3%B0%E6%98%8E%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%88%87%E9%9D%A2/</url>
    <content><![CDATA[<h3 id="1-什么是面向切面"><a href="#1-什么是面向切面" class="headerlink" title="1 什么是面向切面"></a>1 什么是面向切面</h3><p>这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。<br>AOP是Spring提供的关键特性之一。AOP即面向切面编程，是OOP编程的有效补充。使用AOP技术，可以将一些系统性相关的编程工作，独立提取出来，独立实现，然后通过切面切入进系统。从而避免了在业务逻辑的代码中混入很多的系统相关的逻辑——比如权限管理，事物管理，日志记录等等。这些系统性的编程工作都可以独立编码实现，然后通过AOP技术切入进系统即可。从而达到了 将不同的关注点分离出来的效果。</p>
<a id="more"></a>

<h3 id="2-AOP术语"><a href="#2-AOP术语" class="headerlink" title="2 AOP术语"></a>2 AOP术语</h3><h4 id="2-1-通知（Advice）"><a href="#2-1-通知（Advice）" class="headerlink" title="2.1 通知（Advice）"></a>2.1 通知（Advice）</h4><p>切面必须要完成的工作即称为通知。通知定义了切面是什么以及什么时候实用。<br>spring切面可以实用的5种类型通知：</p>
<ul>
<li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li>
<li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li>
<li>返回通知（After-returning）：在目标方法成功执行之后调用通知；</li>
<li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li>
<li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li>
</ul>
<h4 id="2-2-连接点（Join-point）"><a href="#2-2-连接点（Join-point）" class="headerlink" title="2.2 连接点（Join point）"></a>2.2 连接点（Join point）</h4><p>我们的应用可能有数以千计的时机应用通知。这些时机被称 为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p>
<h4 id="2-3-切点（Poincut）"><a href="#2-3-切点（Poincut）" class="headerlink" title="2.3 切点（Poincut）"></a>2.3 切点（Poincut）</h4><p>切点定义了从何处切入。切点的定义会匹配通知所要织入的一个或多个连接点。通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p>
<h4 id="2-4-切面（Aspect）"><a href="#2-4-切面（Aspect）" class="headerlink" title="2.4 切面（Aspect）"></a>2.4 切面（Aspect）</h4><p>切面是通知和切点的结合。通知和切点共同定义了切面的全部内容—-它是什么，在何时和何处完成其功能。</p>
<h4 id="2-5-引入（Introduction）"><a href="#2-5-引入（Introduction）" class="headerlink" title="2.5 引入（Introduction）"></a>2.5 引入（Introduction）</h4><p>引入允许我们向现有的类添加新方法或属性。</p>
<h4 id="2-6-织入（Weaving）"><a href="#2-6-织入（Weaving）" class="headerlink" title="2.6 织入（Weaving）"></a>2.6 织入（Weaving）</h4><p>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。</p>
<ul>
<li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li>
<li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ 5的加载时织入（load-timeweaving，LTW）就支持以这种方式织入切面。</li>
<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。</li>
</ul>
<h3 id="3-Spring对切面的支持"><a href="#3-Spring对切面的支持" class="headerlink" title="3 Spring对切面的支持"></a>3 Spring对切面的支持</h3><p>Spring提供了4种类型的AOP支持：</p>
<ul>
<li>基于代理的经典Spring AOP；</li>
<li>纯POJO切面；</li>
<li>@AspectJ注解驱动的切面；</li>
<li>注入式AspectJ切面（适用于Spring各版本）。</li>
</ul>
<p>前三种都是Spring AOP实现的变体，Spring AOP构建在动态代理基础之上，因此，Spring对AOP的支持局限于方法拦截。</p>
<h3 id="4-认识切点"><a href="#4-认识切点" class="headerlink" title="4 认识切点"></a>4 认识切点</h3><p>在Spring AOP中，要使用AspectJ的切点表达式语言来定义切点。<br>首先定义一个接口来作为切点：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> interface Performance &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="type">void</span> <span class="keyword">perform</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>假设我们想编写Performance的perform()方法触发的通 知。下面的表达式能够设置当perform()方法执行时触发通知的调用。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">execution(* com.wtj.springlearn.aop.Performance.<span class="keyword">perform</span>(..))</span></pre></td></tr></table></figure>

<p>execution()指示器选择Performance的perform()方法。方法表达式以“*”号开始，表明了不关心方法返回值的类型。然后指定了全限定类名和方法名。对于方法参数列表，使用两个点号（..）表明切点要选择任意的perform()方法，无论该方法的入参是什么。<br>如果我们需要设置切点匹配com.wtj.springlearn.aop包，可以使用within()来限定匹配。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">execution(* com.wtj.springlearn.aop.Performance.<span class="keyword">perform</span>(..)） &amp;&amp; <span class="keyword">within</span>(com.wtj.springlearn.aop.*)</span></pre></td></tr></table></figure>

<p>表示com.wtj.springlearn.aop包下任意类的方法被调用时。<br>使用“&amp;&amp;”操作符把execution()和within()指示器连接在一起形成与（and）关系（切点必须匹配所有的指示器）。类似地，我们可以使用“||”操作符来标识或（or）关系，而使用“!”操作符来标识非（not）操作。<br>因为“&amp;”在XML中有特殊含义，所以在Spring的XML配置里面描述切点时，我们可以使用and来代替“&amp;&amp;”。同样，or和not可以分别用来代替“||”和“!”。<br>还可以使用bean的ID来标识bean。bean()使用bean ID或bean名称作为参数来限制切点只匹配特定的bean。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">execution(* com.wtj.springlearn.aop.Performance.<span class="keyword">perform</span>(..)) &amp;&amp; bean(<span class="string">'book'</span>)</span></pre></td></tr></table></figure>

<p>这里表示执行perform方法时通知，但是只限于bean的ID为book。</p>
<h3 id="5-通过注解创建切面"><a href="#5-通过注解创建切面" class="headerlink" title="5 通过注解创建切面"></a>5 通过注解创建切面</h3><blockquote>
<p>本篇主要介绍注解方式的切面定义方式</p>
</blockquote>
<p>通过@Aspect进行标注，表示该Audience不仅是一个POJO还是一个切面。类中的方法表示了切面的具体行为。<br>Spring提供了五种注解来定义通知时间：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829144905-e7439.png" alt="img"></p>
<p>首先创建一个切面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//表演前 手机静音</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.wtj.springlearn.aop.Performance.perform(..))"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhone</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"silence Cell Phone"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//表演成功-clap</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"execution(** com.wtj.springlearn.aop.Performance.perform(..))"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clap</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"clap clap clap"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//表演失败-退款</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"execution(** com.wtj.springlearn.aop.Performance.perform(..))"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refund</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"refund refund refund"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Performance的实现类：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@Component</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> PerformanceImpl implements Performance &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">public</span> <span class="type">void</span> <span class="keyword">perform</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("the perform is good");</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>最后还需要开启自动代理功能</strong>，通过JavaConfig进行配置，使用<code>@EnableAspectJAutoProxy</code>标签开启。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@EnableAspectJAutoProxy</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@ComponentScan</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class AudienceConfig &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Audience audience()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">Audience</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>最后通过一个简单的测试用例就可以来验证了。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.<span class="keyword">class</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">@ContextConfiguration(classes = AudienceConfig.<span class="keyword">class</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> PerformanceTest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Performance performance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Test</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">public</span> <span class="type">void</span> perTest()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        performance.<span class="keyword">perform</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">silence Cell Phone</span></pre></td></tr><tr><td class="code"><pre><span class="line">the <span class="keyword">perform</span> <span class="keyword">is</span> good</span></pre></td></tr><tr><td class="code"><pre><span class="line">clap clap clap</span></pre></td></tr></table></figure>

<h4 id="5-1-PointCut声明切点"><a href="#5-1-PointCut声明切点" class="headerlink" title="5.1 @PointCut声明切点"></a>5.1 @PointCut声明切点</h4><p>你会发现上面切面的方法中，切点的声明都是一样的，这种情况下可以使用<code>@Pointcut</code>注解来定义切点。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.wtj.springlearn.aop.Performance.perform(..))"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">per</span><span class="params">()</span></span>&#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表演前 手机静音</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"per()"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">silenceCellPhone</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"silence Cell Phone"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>per()方法本身并不重要，该方法只是一个标识，供@PointCut注解依附。</p>
<h4 id="5-2-环绕通知"><a href="#5-2-环绕通知" class="headerlink" title="5.2 环绕通知"></a>5.2 环绕通知</h4><p>环绕通知是最为强大的通知类型。它能够让你所编写的逻辑将被通知的目标方法完全包装起来。实际上就像在一个通知方法中同时编写前置通知和后置通知。<br>重写Audience切面，使用环绕通知替代之前多个不同的前置通知和后置通知。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@Around("per()")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> watch(ProceedingJoinPoint <span class="type">point</span>) throws Throwable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    try&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("silence Cell Phone");</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="type">point</span>.proceed();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("clap clap clap");</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;catch (<span class="keyword">Exception</span> e)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("refund refund refund");</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>首先注意到的可能是它接受ProceedingJoinPoint作为参数。这个对象是必须要有的，因为你要在通知中通过它来调用被通知的方法。通知方法中可以做任何的事情，当要将控制权交给被通知的方法时，它需要调用ProceedingJoinPoint的proceed()方法。<br>如果不调proceed()这个方法的话，那么你的通知实际上会阻塞对被通知方法的调用。同样的，你也可以调用多次。</p>
<h4 id="5-3-向通知中传入参数"><a href="#5-3-向通知中传入参数" class="headerlink" title="5.3 向通知中传入参数"></a>5.3 向通知中传入参数</h4><p>上面我们创建的切面都很简单，没有任何参数。那么切面能访问和使用传递给被通知方法的参数么？<br>Performance中新增方法：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="keyword">perform</span>(String <span class="type">name</span>);</span></pre></td></tr></table></figure>

<p>实现类：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> <span class="keyword">perform</span>(String <span class="type">name</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("下面请 "+<span class="type">name</span>+" 开始他的表演");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>修改Audience中的切点和切面</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@Pointcut("execution(* com.wtj.springlearn.aop.Performance.perform(String)) &amp;&amp; args(name)")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> per(String <span class="type">name</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Around("per(name)")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> toWatch(ProceedingJoinPoint <span class="type">point</span>, String <span class="type">name</span>) throws Throwable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    try &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="type">point</span>.proceed();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span> + " 上场啦");</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span> + " 演出结束");</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; catch (<span class="keyword">Exception</span> e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("refund refund refund");</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>表达式<code>args(name)</code>限定符，它表示传递给perform(String name)方法的String类型参数也会传到通知中去，参数名与切点中的参数名相同。<code>perform(String)</code>指明了传入参数的类型。<br>然后在<code>@Around</code>注解中指明切点与参数名，这样就完成了参数转移。<br>最后修改一下测试用例就完成了</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@Test</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> perTest()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    performance.<span class="keyword">perform</span>("渣渣辉");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>打印输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下面请 渣渣辉 开始他的表演</span></pre></td></tr><tr><td class="code"><pre><span class="line">渣渣辉 上场啦</span></pre></td></tr><tr><td class="code"><pre><span class="line">渣渣辉 演出结束</span></pre></td></tr></table></figure>

<h4 id="5-4-通过注解-DeclareParents引入新方法"><a href="#5-4-通过注解-DeclareParents引入新方法" class="headerlink" title="5.4 通过注解@DeclareParents引入新方法"></a>5.4 通过注解@DeclareParents引入新方法</h4><p>如果我们想在一个类上新增方法，通常情况下我们会怎么做呢？最简单的办法就是在此目标类上增加此方法，但是如果原目标类非常复杂，动一发而牵全身。并且有些时候我们是没有目标类的源码的，哪这个时候怎么办呢？<br>我们可以为需要添加的方法建立一个类，然后建一个代理类，同时代理该类和目标类。用一个图来表示</p>
<p><img src="http://image.winrains.cn/2019/08/20190829144906-93ff8.png" alt="img"></p>
<p>当引入接口的方法被调用时，代理会把此调用委托给实现了新接口的某个其他对象。<br>还是上面的例子，假设我们需要让表演者跳起来。<br>新建Jump接口以及实现类：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">Jump</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">void</span> duJump();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">JumpImpl</span> <span class="symbol">implements</span> <span class="symbol">Jump</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> duJump() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"do Jump"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后我们代理两个类：</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@Aspect</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> JumpIntroducer &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">@DeclareParents</span>(value = <span class="string">"com.wtj.springlearn.aop.Performance+"</span>,defaultImpl = JumpImpl.<span class="keyword">class</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jump jump;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>@DeclareParents注解由三部分组成：</p>
<ul>
<li>value属性指定了哪种类型的bean要引入该接口。在本例中，也就是所有实现Performance的类型。（标记符后面的加号表示是Performance的所有子类型，而不是Performance本 身。）</li>
<li>defaultImpl属性指定了为引入功能提供实现的类。</li>
<li>@DeclareParents注解所标注的静态属性指明了要引入了接 口。</li>
</ul>
<p><strong>通过配置将JumpIntroducer声明</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@ComponentScan</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@EnableAspectJAutoProxy</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class JumpConfig &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public JumpIntroducer jumpIntroducer()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">JumpIntroducer</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>或者你也可以在JumpIntroducer类上加入<code>@Component</code>注解，就可以不用声明bean了。<br>最后通过测试用例进行测试：</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@RunWith</span>(SpringJUnit4ClassRunner.<span class="keyword">class</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@ContextConfiguration</span>(classes = JumpConfig.<span class="keyword">class</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> PerformanceTest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Performance performance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">@Test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> perTest()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//类型转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Jump jump = (Jump) performance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        jump.duJump();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> Jump</span></pre></td></tr></table></figure>

<blockquote>
<p>作者：爱西考的王同学</p>
<p>来源：<a href="https://juejin.im/post/5d394d4ce51d4550a629b35a" target="_blank" rel="noopener">https://juejin.im/post/5d394d4ce51d4550a629b35a</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud介绍</title>
    <url>/2019/12/26/Spring-Cloud%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><blockquote>
<p>只有光头才能变强</p>
</blockquote>
<p>认识我的朋友可能都知道我这阵子去实习啦，去的公司说是用SpringCloud(但我觉得使用的力度并不大啊<del>)…<br>所以，这篇主要来讲讲SpringCloud的一些基础的知识。(我就是现学现卖了，主要当做我学习SpringCloud的笔记吧！)当然了，我的水平是有限的，可能会有一些理解错的的概念/知识点，还请大家不吝在评论区指正啊</del></p>
<a id="more"></a>

<p>SpringCloud GitHub Demo(看完文章的同学可以自己练手玩玩)：</p>
<ul>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FZhongFuCheng3y%2Fmsc-Demo">github.com/ZhongFuChen…</a></li>
</ul>
<p>项目结构图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151036-c9caa.png" alt="img"></p>
<h1 id="二、集群-分布式-微服务-SOA是什么？"><a href="#二、集群-分布式-微服务-SOA是什么？" class="headerlink" title="二、集群/分布式/微服务/SOA是什么？"></a>二、集群/分布式/微服务/SOA是什么？</h1><p>像我这种技术小白，看到这些词(<code>集群/分布式/微服务/SOA</code>)的时候，感觉就是遥不可及的(高大尚的技术！！)。就好像刚学Java面向对象的时候，在论坛上翻阅资料的时候，无意看到”面向切面编程”，也认为这是遥不可及的(高大尚的技术！！)。<br>但真正接触到”面向切面编程”的时候，发现原来就是如此啊，也没什么大不了的。只不过当时被它的名字给唬住了…<br>不知道各位在刚接触这些名字<code>集群/分布式/微服务/SOA</code>的时候，有没有被唬住了呢？？</p>
<ul>
<li>下面我就<strong>简单</strong>说说这些名词的意思</li>
</ul>
<h2 id="2-1什么是集群"><a href="#2-1什么是集群" class="headerlink" title="2.1什么是集群"></a>2.1什么是集群</h2><p>以下内容来源维基百科：</p>
<blockquote>
<p>计算机集群简称集群是一种计算机系统，它通过一组松散集成的计算机软件和/或硬件连接起来高度紧密地协作完成计算工作。在某种意义上，他们可以被看作是一台计算机。集群系统中的单个计算机通常称为节点，通常通过局域网连接，但也有其它的可能连接方式。集群计算机通常用来改进单个计算机的计算速度和/或可靠性。一般情况下集群计算机比单个计算机，比如工作站或超级计算机性能价格比要高得多</p>
</blockquote>
<p>集群技术特点：</p>
<ul>
<li>通过<strong>多台计算机完成同一个工作</strong>，达到更高的效率。</li>
<li><strong>两机或多机内容、工作过程等完全一样</strong>。如果一台死机，另一台可以起作用。</li>
</ul>
<p>在维基百科上说得也挺明白的了，我来举个<strong>例子</strong>吧。</p>
<ul>
<li><p>小周在公司写Java程序，但公司业务在发展，一个Java开发者可能</p>
<p>忙不过来</p>
<p>，小周有的时候也得</p>
<p>请个假呀</p>
<p>。于是请了3y过去</p>
<p>一起做Java开发</p>
<p>。平时小周和3y就写Java程序，但3y可能</p>
<p>有事</p>
<p>要回学校一趟。没事，公司还有小周做Java开发呢，公司开发还能继续运作。</p>
<ul>
<li>3y跟小周<strong>都是做Java开发</strong>。</li>
<li>3y来了，小周的工作可以<strong>分担</strong>一些。</li>
<li>3y请假了，还有小周在呢。</li>
</ul>
</li>
</ul>
<p>我写了一个910便利网发布到服务器去了，现在越来越多的人访问了，访问有点慢，怎么办？？？很简单，(只有充钱才能变强)，加配置吧(加cpu，加内存)。升级完配置之后，访问人数越来越多，于是发现又不禁用啦，在这台机器上加配置已经解决不了了，怎么办？？？很简单，(只有充钱才能变强)，我<strong>再买一台服务器，将910便利网也发布到新买的这台服务器上去</strong>。<br>特点：</p>
<ul>
<li>这两台服务器都是运行<strong>同一个系统</strong>—&gt;910便利网</li>
</ul>
<p>好处：</p>
<ul>
<li>本来只有一台机器处理访问，现在有两台机器处理访问了，<strong>分担了压力</strong>。</li>
<li>如果其中一台忘记缴费了，暂时用不了了。没关系，还有另一台可以用呢。</li>
</ul>
<p><strong>集群</strong>：同一个业务，部署在多个服务器上(不同的服务器运行同样的代码，干同一件事)</p>
<h2 id="2-2什么是分布式"><a href="#2-2什么是分布式" class="headerlink" title="2.2什么是分布式"></a>2.2什么是分布式</h2><p>以下内容来源维基百科：</p>
<blockquote>
<p>分布式系统是一组计算机，通过网络相互连接传递消息与通信后并协调它们的行为而形成的系统。<strong>组件之间彼此进行交互以实现一个共同的目标</strong>。</p>
</blockquote>
<p>我也来举个例子来说明一下吧：</p>
<ul>
<li><p>现在公司有小周和3y一起做Java开发，做Java开发一般jQuery，AJAX都能写一点，所以这些活都由我们来干。可是呢，3y对前端不是很熟，有的时候调试半天都调不出来。老板认为3y是真的菜！于是让小周</p>
<p>专门来处理前端</p>
<p>的事情。这样3y就高兴了，可以</p>
<p>专心写自己的Java</p>
<p>，前端就</p>
<p>专门</p>
<p>交由小周负责了。于是，小周和3y就变成了</p>
<p>协作开发</p>
<p>。</p>
<ul>
<li>3y对前端不熟(能写出来)，但在调试的时候可能会花费很多时间</li>
<li>小周来<strong>专门做前端</strong>的事，3y可以<strong>专心写自己的Java程序</strong>了。</li>
<li>都是为了项目正常运行以及迭代。</li>
</ul>
</li>
</ul>
<p>我的910便利网已经部署到两台服务器去了，但是越来越多的人去访问。现在也逐渐承受不住啦。那现在怎么办啊？？那继续充钱变强？？作为一个理智的我，肯定得想想是哪里有问题。现在910便利网的模块有好几个，全都丢在同一个Tomcat里边。<br>其实有些模块的访问是很低的(比如后台管理)，那我可不可以这样做：将每个模块<strong>抽取独立</strong>出来，访问量大的模块用好的服务器装着，没啥人访问的模块用差的服务器装着。这样的好处是：一、<strong>资源合理利用了</strong>(没人访问的模块用性能差的服务器，访问量大的模块<strong>单独提升性能</strong>就好了)。二、<strong>耦合度降低了</strong>：每个模块独立出来，各干各的事(专业的人做专业的事)，便于扩展<br>特点：</p>
<ul>
<li>将910便利网的<strong>功能拆分，模块之间独立</strong>，在使用的时候再将这些<strong>独立的模块组合起来</strong>就是一个系统了。</li>
</ul>
<p>好处：</p>
<ul>
<li>模块之间独立，各做各的事，<strong>便于扩展，复用性高</strong></li>
<li><strong>高吞吐量</strong>。某个任务需要一个机器运行10个小时，将该任务用10台机器的分布式跑(将这个任务拆分成10个小任务)，可能2个小时就跑完了</li>
</ul>
<p><strong>分布式</strong>：一个业务分拆多个子业务，部署在不同的服务器上(不同的服务器，运行不同的代码，为了同一个目的)</p>
<h2 id="2-3集群-分布式"><a href="#2-3集群-分布式" class="headerlink" title="2.3集群/分布式"></a>2.3集群/分布式</h2><p>集群和分布式并不冲突，可以有<strong>分布式集群</strong><br>现在3y的公司规模变大了，有5个小伙子写Java，4个小伙子写前端，2个小伙子做测试，1个小伙子做DBA。</p>
<ul>
<li>Java，前端，测试，DBA的关系看作是分布式的</li>
<li>5个Java看作是集群的(前端，测试同理)…</li>
</ul>
<h2 id="2-4分布式-微服务-SOA"><a href="#2-4分布式-微服务-SOA" class="headerlink" title="2.4分布式/微服务/SOA"></a>2.4分布式/微服务/SOA</h2><p>其实我认为分布式/微服务/SOA这三个概念是差不多的，了解了其中的一个，然后将自己的理解往上面套就好了。<strong>没必要细分每个的具体概念</strong>~~(当然了，我很期待有大佬可以在评论区留言说下自己的看法哈)<br>参考资料：</p>
<ul>
<li>分布式与集群的区别是什么？<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F20004877">www.zhihu.com/question/20…</a></li>
<li>分布式、集群、微服务、SOA 之间的区别<a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fheatdeath%2Farticle%2Fdetails%2F79038795">blog.csdn.net/heatdeath/a…</a></li>
</ul>
<h1 id="三、CAP理论"><a href="#三、CAP理论" class="headerlink" title="三、CAP理论"></a>三、CAP理论</h1><p>从上面所讲的分布式概念我们已经知道，分布式简单理解就是：<strong>一个业务分拆多个子业务，部署在不同的服务器上</strong></p>
<ul>
<li>一般来说，一个子业务我们称为<strong>节点</strong>。</li>
</ul>
<p>如果你接触过一些分布式的基础概念，那肯定会听过CAP这个理论。就比如说：你学了MySQL的InnoDB存储引擎相关知识，你肯定听过ACID！<br>首先，我们来看一下CAP分别代表的是什么意思：</p>
<ul>
<li>C：数据一致性(consistency)<ul>
<li><strong>所有</strong>节点拥有数据的最新版本</li>
</ul>
</li>
<li>A：可用性(availability)<ul>
<li>数据具备高可用性</li>
</ul>
</li>
<li>P：分区容错性(partition-tolerance)<ul>
<li><strong>容忍网络出现分区</strong>，分区之间网络不可达。</li>
</ul>
</li>
</ul>
<p>下面有三个节点(它们是集群的)，此时三个节点都能够相互通信：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151037-626c9.png" alt="img"></p>
<p>由于我们的系统是分布式的，节点之间的通信是通过网络来进行的。<strong>只要是分布式系统</strong>，那很有可能会出现一种情况：因为一些<strong>故障</strong>，使得有些<strong>节点之间不连通</strong>了，整个网络就分成了<strong>几块区域</strong>。</p>
<ul>
<li>数据就散布在了这些不连通的区域中，这就叫<strong>分区</strong></li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829151038-3bfa5.png" alt="img"></p>
<p>现在出现了网络分区后，此时有一个请求过来了，想要注册一个账户。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151038-1e806.png" alt="img"></p>
<p>此时我们<strong>节点一和节点三是不可通信的</strong>，这就有了抉择：</p>
<ul>
<li><p>如果</p>
<p>允许</p>
<p>当前用户注册一个账户，此时注册的记录数据只会在节点一和节点二或者节点二和节点三</p>
<p>同步</p>
<p>，因为节点一和节点三的记录不能同步的。</p>
<ul>
<li>这种情况其实就是选择了可用性(availability)，抛弃了数据一致性(consistency)</li>
</ul>
</li>
<li><p>如果</p>
<p>不允许</p>
<p>当前用户注册一个账户(就是要</p>
<p>等到</p>
<p>节点一和节点三恢复通信)。节点一和节点三一旦恢复通信，我们就可以</p>
<p>保证节点拥有的数据是最新版本</p>
<p>。</p>
<ul>
<li>这种情况其实就是抛弃了可用性(availability)，选择了数据一致性(consistency)</li>
</ul>
</li>
</ul>
<h2 id="3-1再次梳理一下CAP理论"><a href="#3-1再次梳理一下CAP理论" class="headerlink" title="3.1再次梳理一下CAP理论"></a>3.1再次梳理一下CAP理论</h2><p>一般我们说的分布式系统，P：分区容错性(partition-tolerance)这个是<strong>必需</strong>的，这是客观存在的。<br>CAP是无法完全兼顾的，从上面的例子也可以看出，我们可以选AP，也可以选CP。但是，要<strong>注意的是</strong>：不是说选了AP，C就完全抛弃了。不是说选了CP，A就完全抛弃了！<br>在CAP理论中，<strong>C所表示的一致性是强一致性</strong>(每个节点的数据都是最新版本)，其实一致性还有其他级别的：</p>
<ul>
<li>弱一致性：弱一致性是相对于强一致性而言，它不保证总能得到最新的值；</li>
<li>最终一致性(eventual consistency)：放宽对时间的要求，在被调完成操作响应后的某个时间点，被调多个节点的数据最终达成一致</li>
</ul>
<p>可用性的值域可以定义成<strong>0到100%的连续区间</strong>。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151039-cf259.png" alt="img"></p>
<p>所以，<strong>CAP理论定义的其实是在容忍网络分区的条件下，“强一致性”和“极致可用性”无法同时达到</strong>。<br>参考资料：</p>
<ul>
<li>CAP理论中的P到底是个什么意思？<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F54105974">www.zhihu.com/question/54…</a></li>
<li>浅谈分布式系统的基本问题：可用性与一致性：<a href="https://link.juejin.im?target=https%3A%2F%2Fm.aliyun.com%2Fyunqi%2Farticles%2F2709">m.aliyun.com/yunqi/artic…</a></li>
<li>分布式系统的CAP理论：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F666">www.hollischuang.com/archives/66…</a></li>
<li>为什么CAP理论在舍弃P的情况下，可以有完美的CA？<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F285878189">www.zhihu.com/question/28…</a></li>
<li>不懂点CAP理论，你好意思说你是做分布式的吗？<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.yunweipai.com%2Farchives%2F8432.html">www.yunweipai.com/archives/84…</a></li>
</ul>
<p>扩展阅读：</p>
<ul>
<li>浅谈分布式事务：<a href="https://link.juejin.im?target=https%3A%2F%2Fm.aliyun.com%2Fyunqi%2Farticles%2F230242">m.aliyun.com/yunqi/artic…</a></li>
</ul>
<h1 id="四、SpringCloud就是这么简单"><a href="#四、SpringCloud就是这么简单" class="headerlink" title="四、SpringCloud就是这么简单"></a>四、SpringCloud就是这么简单</h1><p>相信大家读到这里，对分布式/微服务已经有一定的了解了，其实单从概念来说，是非常容易理解的。只是很可能被它的名字给唬住了。<br>下面我就来讲讲SpringCloud<strong>最基础</strong>的知识~</p>
<h2 id="4-1为什么需要SpringCloud？"><a href="#4-1为什么需要SpringCloud？" class="headerlink" title="4.1为什么需要SpringCloud？"></a>4.1为什么需要SpringCloud？</h2><p>前面也讲了，从分布式/微服务的角度而言：就是把我们一<strong>大</strong>的项目，<strong>分解</strong>成多个<strong>小</strong>的模块。这些小的模块组合起来，完成功能。<br>举个可能不太恰当的例子(现实可能不会这么拆分，但意思到位就好了)：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151040-e70c0.png" alt="img"></p>
<p>拆分出多个模块以后，就会出现<strong>各种各样</strong>的问题，而SpringCloud提供了<strong>一整套</strong>的解决方案！</p>
<ul>
<li>注：这些模块是<strong>独立</strong>成一个子系统的(不同主机)。</li>
</ul>
<p>SpringCloud的<strong>基础功能</strong>：</p>
<ul>
<li>服务治理： Spring Cloud Eureka</li>
<li>客户端负载均衡： Spring Cloud Ribbon</li>
<li>服务容错保护： Spring Cloud Hystrix</li>
<li>声明式服务调用： Spring Cloud Feign</li>
<li>API网关服务：Spring Cloud Zuul</li>
<li>分布式配置中心： Spring Cloud Config</li>
</ul>
<p>SpringCloud的高级功能(本文不讲)：</p>
<ul>
<li>消息总线： Spring Cloud Bus</li>
<li>消息驱动的微服务： Spring Cloud Stream</li>
<li>分布式服务跟踪： Spring Cloud Sleuth</li>
</ul>
<h1 id="五、引出Eureka"><a href="#五、引出Eureka" class="headerlink" title="五、引出Eureka"></a>五、引出Eureka</h1><p>那会出现什么问题呢？？首当其冲的就是子系统之间的<strong>通讯</strong>问题。子系统与子系统之间不是在同一个环境下，那就需要<strong>远程调用</strong>。远程调用可能就会想到httpClient，WebService等等这些技术来实现。<br>既然是远程调用，就必须知道ip地址，我们可能有以下的场景。</p>
<ul>
<li>功能实现一：A服务需要调用B服务<ul>
<li>在A服务的代码里面调用B服务，<strong>显式通过IP地址调用</strong>：<code>http://123.123.123.123:8888/java3y/3</code></li>
</ul>
</li>
<li>功能实现二：A服务调用B服务，B服务调用C服务，C服务调用D服务<ul>
<li>在A服务的代码里面调用B服务，显式通过IP地址调用：<code>http://123.123.123.123:8888/java3y/3</code>，(同样地)B-&gt;C，C-&gt;D</li>
</ul>
</li>
<li>功能实现三：D服务调用B服务，B服务调用C服务<ul>
<li>在D服务的代码里面调用B服务，显式通过IP地址调用：<code>http://123.123.123.123:8888/java3y/3</code>，(同样地)B-&gt;C</li>
</ul>
</li>
<li>…..等等等等</li>
</ul>
<p>万一，我们<strong>B服务的IP地址变了</strong>，想想会出现什么问题：A服务,D服务(等等)需要<strong>手动更新</strong>B服务的地址</p>
<ul>
<li>在服务多的情况下，手动来维护这些静态配置就是噩梦！</li>
</ul>
<blockquote>
<p>为了解决微服务架构中的<strong>服务实例维护问题(ip地址)</strong>， 产生了大量的<strong>服务治理</strong>框架和产品。 这些框架和产品的实现都围绕着服务注册与服务发现机制来完成对微服务应用实例的<strong>自动化管理</strong>。</p>
</blockquote>
<p>在SpringCloud中我们的服务治理框架一般使用的就是Eureka。<br>我们的问题：</p>
<ul>
<li>现在有A、B、C、D四个服务，它们之间会互相调用(而且IP地址很可能会发生变化)，一旦某个服务的IP地址变了，那服务中的代码要跟着变，手动维护这些静态配置(IP)非常麻烦！</li>
</ul>
<p>Eureka是这样解决上面所说的情况的：</p>
<ul>
<li>创建一个E服务，将A、B、C、D四个服务的信息都<strong>注册</strong>到E服务上，E服务维护这些已经注册进来的信息</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829151040-c277f.png" alt="img"></p>
<p>A、B、C、D四个服务都可以<strong>拿到</strong>Eureka(服务E)那份<strong>注册清单</strong>。A、B、C、D四个服务互相调用不再通过具体的IP地址，而是<strong>通过服务名来调用</strong>！</p>
<ul>
<li>拿到注册清单—&gt;注册清单上有服务名—&gt;自然就能够拿到服务具体的位置了(IP)。</li>
<li>其实简单来说就是：代码中通过<strong>服务名找到对应的IP地址</strong>(IP地址会变，但服务名一般不会变)</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829151042-3b61f.png" alt="img"></p>
<h2 id="5-1Eureka细节"><a href="#5-1Eureka细节" class="headerlink" title="5.1Eureka细节"></a>5.1Eureka细节</h2><p>Eureka专门用于给其他服务注册的称为Eureka Server(服务注册中心)，其余注册到Eureka Server的服务称为Eureka Client。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151042-81de6.png" alt="img"></p>
<p>在Eureka Server一般我们会这样配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">register-with-eureka:</span> <span class="literal">false</span>     <span class="comment">#false表示不向注册中心注册自己。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">fetch-registry:</span> <span class="literal">false</span>     <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span></pre></td></tr></table></figure>

<p>Eureka Client<strong>分为服务提供者和服务消费者</strong>。</p>
<ul>
<li>但很可能，某服务<strong>既是服务提供者又是服务消费者</strong>。</li>
</ul>
<p>如果在网上看到SpringCloud的<strong>某个服务配置没有”注册”到Eureka-Server也不用过于惊讶</strong>(但是它是可以获取Eureka服务清单的)</p>
<ul>
<li>很可能只是作者把该服务认作为<strong>单纯的服务消费者</strong>，单纯的服务消费者无需对外提供服务，也就无须注册到Eureka中了</li>
</ul>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="symbol">eureka:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="symbol">client:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    register-<span class="keyword">with</span>-<span class="symbol">eureka:</span> <span class="literal">false</span>  <span class="comment"># 当前微服务不注册到eureka中(消费端)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    service-<span class="symbol">url:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="symbol">defaultZone:</span> <span class="symbol">http:</span>/<span class="regexp">/eureka7001.com:7001/eureka</span><span class="regexp">/,http:/</span><span class="regexp">/eureka7002.com:7002/eureka</span><span class="regexp">/,http:/</span><span class="regexp">/eureka7003.com:7003/eureka</span><span class="regexp">/</span></span></pre></td></tr></table></figure>

<p>下面是Eureka的治理机制：</p>
<ul>
<li>服务提供者<ul>
<li><strong>服务注册：启动的时候会通过发送REST请求的方式将自己注册到Eureka Server上</strong>，同时带上了自身服务的一些元数据信息。</li>
<li><strong>服务续约：</strong>在注册完服务之后，<strong>服务提供者会维护一个心跳</strong>用来持续告诉Eureka Server: “我还活着 ” 、</li>
<li><strong>服务下线：当服务实例进行正常的关闭操作时，它会触发一个服务下线的REST请求</strong>给Eureka Server, 告诉服务注册中心：“我要下线了 ”。</li>
</ul>
</li>
<li>服务消费者<ul>
<li><strong>获取服务：当我们启动服务消费者</strong>的时候，它会发送一个REST请求给服务注册中心，来获取上面注册的服务清单</li>
<li><strong>服务调用：服务消费者在获取服务清单后，通过服务名</strong>可以获得具体提供服务的实例名和该实例的元数据信息。在进行服务调用的时候，<strong>优先访问同处一个Zone中的服务提供方</strong>。</li>
</ul>
</li>
<li>Eureka Server(服务注册中心)：<ul>
<li><strong>失效剔除：</strong>默认每隔一段时间（默认为60秒） 将当前清单中超时（默认为90秒）<strong>没有续约的服务剔除出去</strong>。</li>
<li><strong>自我保护：</strong>。EurekaServer 在运行期间，会统计心跳失败的比例在15分钟之内是否低于85%(通常由于网络不稳定导致)。 Eureka Server会将当前的<strong>实例注册信息保护起来</strong>， 让这些实例不会过期，尽可能<strong>保护这些注册信息</strong>。</li>
</ul>
</li>
</ul>
<p>最后，我们就有了这张图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151043-cdb68.png" alt="img"></p>
<p>举个例子：</p>
<ul>
<li>3y跟女朋友去东站的东方宝泰逛街，但不知道东方宝泰有什么好玩的。于是就去<strong>物业</strong>搜了一下<strong>东方宝泰商户清单</strong>，发现一楼有优衣库，二楼有星巴克，三楼有麦当劳。</li>
<li>在优衣库旁边，有新开张的KFC，在墙壁打上了很大的标识“欢迎KFC<strong>入驻</strong>东方宝泰”。</li>
<li>商家们需要定时<strong>交物业费</strong>给物业。</li>
<li><strong>物业维持</strong>东方宝泰的稳定性。如果某个商家不想在东方宝泰运营了，告诉了物业。物业自然就会将其在东方宝泰商户清单去除。</li>
</ul>
<p>优秀博文：</p>
<ul>
<li>Spring Cloud Eureka详解：<a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fsunhuiliang85%2Farticle%2Fdetails%2F76222517">blog.csdn.net/sunhuiliang…</a></li>
<li>《Spring Cloud Netflix》 – 服务注册和服务发现-Eureka 的使用：<a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F26472547">zhuanlan.zhihu.com/p/26472547</a></li>
<li>微服务架构：Eureka参数配置项详解：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Ffangfuhai%2Fp%2F7070325.html">www.cnblogs.com/fangfuhai/p…</a></li>
</ul>
<h1 id="六、引出RestTemplate和Ribbon"><a href="#六、引出RestTemplate和Ribbon" class="headerlink" title="六、引出RestTemplate和Ribbon"></a>六、引出RestTemplate和Ribbon</h1><p>通过Eureka服务治理框架，我们可以通过服务名来获取具体的服务实例的位置了(IP)。一般在使用SpringCloud的时候<strong>不需要自己手动创建</strong>HttpClient来进行远程调用。<br>可以使用Spring封装好的<strong>RestTemplate</strong>工具类，使用起来很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统的方式，直接显示写死IP是不好的！</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// private static final String REST_URL_PREFIX = "http://localhost:8001";</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 服务实例名</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REST_URL_PREFIX = <span class="string">"http://MICROSERVICECLOUD-DEPT"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 使用 使用restTemplate访问restful接口非常的简单粗暴无脑。 (url, requestMap,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * ResponseBean.class)这三个参数分别代表 REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/consumer/dept/add"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Dept dept)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> restTemplate.postForObject(REST_URL_PREFIX + <span class="string">"/dept/add"</span>, dept, Boolean<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>为了实现服务的<strong>高可用</strong>，我们可以将<strong>服务提供者集群</strong>。比如说，现在一个秒杀系统设计出来了，准备上线了。在11月11号时为了能够支持高并发，我们开多台机器来支持并发量。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151044-6ca5a.png" alt="img"></p>
<p>现在想要这三个秒杀系统<strong>合理摊分</strong>用户的请求(专业来说就是负载均衡)，可能你会想到nginx。<br>其实SpringCloud也支持的负载均衡功能，只不过它是<strong>客户端的负载均衡</strong>，这个功能实现就是Ribbon！<br>负载均衡又区分了两种类型：</p>
<ul>
<li>客户端负载均衡(Ribbon)<ul>
<li>服务实例的<strong>清单在客户端</strong>，客户端进行负载均衡算法分配。</li>
<li>(从上面的知识我们已经知道了：客户端可以从Eureka Server中得到一份服务清单，在发送请求时通过负载均衡算法，<strong>在多个服务器之间选择一个进行访问</strong>)</li>
</ul>
</li>
<li>服务端负载均衡(Nginx)<ul>
<li>服务实例的<strong>清单在服务端</strong>，服务器进行负载均衡算法分配</li>
</ul>
</li>
</ul>
<p>所以，我们的图可以画成这样：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151045-bac78.png" alt="img"></p>
<h2 id="6-1Ribbon细节"><a href="#6-1Ribbon细节" class="headerlink" title="6.1Ribbon细节"></a>6.1Ribbon细节</h2><p>Ribbon是支持负载均衡，默认的负载均衡策略是轮询，我们也是可以根据自己实际的需求自定义负载均衡策略的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelfRule</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">myRule</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// return new RandomRule();// Ribbon默认是轮询，我自定义为随机</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// return new RoundRobinRule();// Ribbon默认是轮询，我自定义为随机</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule_ZY();<span class="comment">// 我自定义为每台机器5次</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>实现起来也很简单：继承AbstractLoadBalancerRule类，重写<code>public Server choose(ILoadBalancer lb, Object key)</code>即可。<br>SpringCloud 在CAP理论是选择了AP的，在Ribbon中还可以配置<strong>重试机制</strong>的(有兴趣的同学可以去搜搜)~<br>举个例子：</p>
<ul>
<li>3y跟女朋友过了几个月，又去东方宝泰了。由于记性不好，又去物业那弄了一份东方宝泰商户清单。</li>
<li>这次看到东方宝泰又开了一间麦当劳，一间在二楼，一间在三楼。原来生意太好了，为了能提高用户体验，在二楼<strong>多开了一间麦当劳</strong>。</li>
<li>这时，3y问女朋友：“去哪间麦当劳比较好？要不我们抛硬币决定？”3y女朋友说：”你是不是傻，肯定哪间近去哪间啊“</li>
</ul>
<p>优秀博文：</p>
<ul>
<li>撸一撸Spring Cloud Ribbon的原理-负载均衡策略：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fkongxianghai%2Fp%2F8477781.html">www.cnblogs.com/kongxiangha…</a></li>
</ul>
<h1 id="七、引出Hystrix"><a href="#七、引出Hystrix" class="headerlink" title="七、引出Hystrix"></a>七、引出Hystrix</h1><p>到目前为止，我们的服务看起来好像挺好的了：能够根据服务名来远程调用其他的服务，可以实现客户端的负载均衡。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151046-2109a.png" alt="img"></p>
<p>但是，如果我们在<strong>调用多个远程服务时，某个服务出现延迟</strong>，会怎么样？？</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151047-90a16.jpeg" alt="img"></p>
<p>在<strong>高并发</strong>的情况下，由于单个服务的延迟，可能导致<strong>所有的请求都处于延迟状态</strong>，甚至在几秒钟就使服务处于负载饱和的状态，资源耗尽，直到不可用，最终导致这个分布式系统都不可用，这就是“雪崩”。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151047-1ef55.jpeg" alt="img"></p>
<p>针对上述问题， Spring Cloud Hystrix实现了<strong>断路器、线程隔离</strong>等一系列服务保护功能。</p>
<ul>
<li>Fallback(失败快速返回)：当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝）， <strong>向调用方返回一个错误响应， 而不是长时间的等待</strong>。这样就不会使得线程因调用故障服务被长时间占用不释放，<strong>避免</strong>了故障在分布式系统中的<strong>蔓延</strong>。</li>
<li>资源/依赖隔离(线程池隔离)：它会为<strong>每一个依赖服务创建一个独立的线程池</strong>，这样就算某个依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响， 而<strong>不会拖慢其他的依赖服务</strong>。</li>
</ul>
<p>Hystrix提供几个熔断关键参数：<code>滑动窗口大小（20）、 熔断器开关间隔（5s）、错误率（50%）</code></p>
<ul>
<li>每当20个请求中，有50%失败时，熔断器就会打开，此时再调用此服务，将会<strong>直接返回失败</strong>，不再调远程服务。</li>
<li>直到5s钟之后，重新检测该触发条件，<strong>判断是否把熔断器关闭，或者继续打开</strong>。</li>
</ul>
<p>Hystrix还有请求合并、请求缓存这样强大的功能，在此我就不具体说明了，有兴趣的同学可继续深入学习~</p>
<h2 id="7-1Hystrix仪表盘"><a href="#7-1Hystrix仪表盘" class="headerlink" title="7.1Hystrix仪表盘"></a>7.1Hystrix仪表盘</h2><p>Hystrix仪表盘：它主要用来<strong>实时监控Hystrix的各项指标信息</strong>。通过Hystrix Dashboard反馈的实时信息，可以帮助我们快速发现系统中存在的问题，从而及时地采取应对措施。<br>启动时的页面：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151048-d634c.png" alt="img"></p>
<p><strong>监控单服务</strong>的页面：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151049-6494b.png" alt="img"></p>
<p>我们现在的服务是这样的：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151050-b2592.png" alt="img"></p>
<p>除了可以开启单个实例的监控页面之外，还有一个监控端点 <code>/turbine.stream</code>是对<strong>集群</strong>使用的。 从端点的命名中，可以引入Turbine, 通过它来<strong>汇集监控信息</strong>，并将聚合后的信息提供给 HystrixDashboard 来<strong>集中展示和监控</strong>。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151051-75606.png" alt="img"></p>
<p>举个例子：</p>
<ul>
<li>3y和女朋友决定去万达玩，去到万达的停车场发现在负一层已经大大写上“负一层已停满，请下负二层，负二层空余停车位还有100个！”</li>
<li>这时，3y就跟女朋友说：“万达停车场是做得挺好的，如果它没有<strong>直接</strong>告知我负一层已满，可能我就去负一层找位置了，要是一堆人跑去负一层但都找不到车位的话，恐怕就塞死了”。3y接着说：“看停车位的状态也做得不错，在停车位上头有一个<strong>感应(监控)</strong>，如果是红色就代表已被停了，如果是绿色就说明停车位是空的”。</li>
<li>3y女朋友不屑的说：“你话是真的多”</li>
</ul>
<p>参考资料：</p>
<ul>
<li>Hystrix ，为什么说它是每个系统不可或缺的开源框架？<a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F34304136">zhuanlan.zhihu.com/p/34304136</a></li>
<li>深入理解Hystrix之文档翻译：<a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F28523060">zhuanlan.zhihu.com/p/28523060</a></li>
<li>谈谈我对服务熔断、服务降级的理解：<a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fguwei9111986%2Farticle%2Fdetails%2F51649240">blog.csdn.net/guwei911198…</a></li>
<li>Hystrix几篇文章《青芒》：<a href="https://link.juejin.im?target=https%3A%2F%2Fsegmentfault.com%2Fu%2Fyedge%2Farticles">segmentfault.com/u/yedge/art…</a></li>
</ul>
<h1 id="八、引出Feign"><a href="#八、引出Feign" class="headerlink" title="八、引出Feign"></a>八、引出Feign</h1><p>上面已经介绍了Ribbon和Hystrix了，可以发现的是：他俩作为基础工具类框架<strong>广泛地应用</strong>在各个微服务的实现中。我们会发现对这两个框架的<strong>使用几乎是同时出现</strong>的。<br>为了<strong>简化</strong>我们的开发，Spring Cloud Feign出现了！它基于 Netflix Feign 实现，<strong>整合</strong>了 Spring Cloud Ribbon 与 Spring Cloud Hystrix, 除了整合这两者的强大功能之外，它还提 供了<strong>声明式的服务调用</strong>(不再通过RestTemplate)。</p>
<blockquote>
<p>Feign是一种声明式、模板化的HTTP客户端。在Spring Cloud中使用Feign, 我们可以做到使用HTTP请求远程服务时能与调用本地方法一样的编码体验，开发者完全感知不到这是远程方法，更感知不到这是个HTTP请求。</p>
</blockquote>
<p>下面就简单看看Feign是怎么优雅地实现远程调用的：<br>服务绑定：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// value ---&gt;指定调用哪个服务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// fallbackFactory---&gt;熔断器的降级提示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@FeignClient</span>(value = <span class="string">"MICROSERVICECLOUD-DEPT"</span>, fallbackFactory = DeptClientServiceFallbackFactory.class)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public interface DeptClientService &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 采用Feign我们可以使用SpringMVC的注解来对服务进行绑定！</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@RequestMapping</span>(value = <span class="string">"/dept/get/&#123;id&#125;"</span>, method = RequestMethod.GET)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Dept get(<span class="variable">@PathVariable</span>(<span class="string">"id"</span>) long id);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@RequestMapping</span>(value = <span class="string">"/dept/list"</span>, method = RequestMethod.GET)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public List&lt;Dept&gt; list();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@RequestMapping</span>(value = <span class="string">"/dept/add"</span>, method = RequestMethod.POST)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public boolean add(Dept dept);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Feign中使用熔断器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Feign中使用断路器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 这里主要是处理异常出错的情况(降级/熔断时服务不可用，fallback就会找到这里来)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 不要忘记添加，不要忘记添加</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptClientServiceFallbackFactory</span> <span class="keyword">implements</span> <span class="title">FallbackFactory</span>&lt;<span class="title">DeptClientService</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> DeptClientService <span class="title">create</span><span class="params">(Throwable throwable)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DeptClientService() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">public</span> Dept <span class="title">get</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Dept().setDeptno(id).setDname(<span class="string">"该ID："</span> + id + <span class="string">"没有没有对应的信息,Consumer客户端提供的降级信息,此刻服务Provider已经关闭"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        .setDb_source(<span class="string">"no this database in MySQL"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">public</span> List&lt;Dept&gt; <span class="title">list</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Dept dept)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>调用：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151052-9a6e4.png" alt="img"></p>
<h1 id="九、引出Zuul"><a href="#九、引出Zuul" class="headerlink" title="九、引出Zuul"></a>九、引出Zuul</h1><p>基于上面的学习，我们现在的架构很可能会设计成这样：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151052-a2fbe.png" alt="img"></p>
<p>这样的架构会有两个比较麻烦的问题：</p>
<ol>
<li><strong>路由规则与服务实例的维护间题</strong>：外层的负载均衡(nginx)需要<strong>维护</strong>所有的服务实例清单(图上的OpenService)</li>
<li><strong>签名校验、 登录校验冗余问题</strong>：为了保证对外服务的安全性， 我们在服务端实现的微服务接口，往往都会有一定的<strong>权限校验机制</strong>，但我们的服务是独立的，我们<strong>不得不在这些应用中都实现这样一套校验逻辑</strong>，这就会造成校验逻辑的冗余。</li>
</ol>
<p>还是画个图来理解一下吧：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151053-1d37f.png" alt="img"></p>
<p>每个服务都有自己的IP地址，Nginx想要正确请求转发到服务上，就必须<strong>维护着每个服务实例的地址</strong>！</p>
<ul>
<li>更是灾难的是：这些服务实例的IP地址还有可能会变，服务之间的划分也很可能会变。</li>
</ul>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//123.123.123.123</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//123.123.123.124</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//123.123.123.125</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//123.123.123.126</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//123.123.123.127</span></span></pre></td></tr></table></figure>

<p>购物车和订单模块都需要用户登录了才可以正常访问，基于现在的架构，只能在<strong>购物车和订单模块都编写校验逻辑</strong>，这无疑是冗余的代码。<br>为了解决上面这些常见的架构问题，<strong>API网关</strong>的概念应运而生。在SpringCloud中了提供了基于Netfl ix Zuul实现的API网关组件<strong>Spring Cloud Zuul</strong>。<br>Spring Cloud Zuul是这样解决上述两个问题的：</p>
<ul>
<li>SpringCloud Zuul通过与SpringCloud Eureka进行整合，将自身注册为Eureka服务治理下的应用，同时从Eureka中获得了所有其他微服务的实例信息。<strong>外层调用都必须通过API网关</strong>，使得<strong>将维护服务实例的工作交给了服务治理框架自动完成</strong>。</li>
<li>在API网关服务上进行统一调用来<strong>对微服务接口做前置过滤</strong>，以实现对微服务接口的<strong>拦截和校验</strong>。</li>
</ul>
<p>Zuul天生就拥有线程隔离和断路器的自我保护功能，以及对服务调用的客户端负载均衡功能。也就是说：<strong>Zuul也是支持Hystrix和Ribbon</strong>。<br>关于Zuul还有很多知识点(由于篇幅问题，这里我就不细说了)：</p>
<ul>
<li>路由匹配(动态路由)</li>
<li>过滤器实现(动态过滤器)</li>
<li>默认会过滤掉Cookie与敏感的HTTP头信息(额外配置)</li>
</ul>
<h2 id="9-1可能对Zuul的疑问"><a href="#9-1可能对Zuul的疑问" class="headerlink" title="9.1可能对Zuul的疑问"></a>9.1可能对Zuul的疑问</h2><p>Zuul支持Ribbon和Hystrix，也能够实现客户端的负载均衡。我们的Feign不也是实现客户端的负载均衡和Hystrix的吗？既然Zuul已经能够实现了，那我们的Feign还有必要吗？</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151054-d6685.png" alt="img"></p>
<p>或者可以这样理解：</p>
<ul>
<li>zuul是对外暴露的唯一接口相当于路由的是controller的请求，而Ribbonhe和Fegin路由了service的请求</li>
<li>zuul做最外层请求的负载均衡 ，而Ribbon和Fegin做的是系统内部各个微服务的service的调用的负载均衡</li>
</ul>
<p>有了Zuul，还需要Nginx吗？他俩可以一起使用吗？</p>
<ul>
<li>我的理解：Zuul和Nginx是可以一起使用的(毕竟我们的Zuul也是可以搭成集群来实现高可用的)，要不要一起使用得看架构的复杂度了(业务)<del>~</del></li>
</ul>
<p>参考资料：</p>
<ul>
<li>微服务与API网关（上）: 为什么需要API网关？：<a href="https://link.juejin.im?target=http%3A%2F%2Fblog.didispace.com%2Fhzf-ms-apigateway-1%2F">blog.didispace.com/hzf-ms-apig…</a></li>
<li>谈谈 API 网关：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fb52a2773e75f">www.jianshu.com/p/b52a2773e…</a></li>
<li>谈谈微服务中的 API 网关（API Gateway）：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fsavorboard%2Fp%2Fapi-gateway.html">www.cnblogs.com/savorboard/…</a></li>
<li>API网关性能比较：NGINX vs. ZUUL vs. Spring Cloud Gateway ：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.360doc.com%2Fcontent%2F18%2F0208%2F05%2F46368139_728502763.shtml">www.360doc.com/content/18/…</a></li>
<li>谈API网关的背景、架构以及落地方案：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.infoq.com%2Fcn%2Fnews%2F2016%2F07%2FAPI-background-architecture-floo">www.infoq.com/cn/news/201…</a></li>
<li>zuul和nginx：<a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F37385481">zhuanlan.zhihu.com/p/37385481</a></li>
</ul>
<h1 id="十、引出SpringCloud-Config"><a href="#十、引出SpringCloud-Config" class="headerlink" title="十、引出SpringCloud Config"></a>十、引出SpringCloud Config</h1><p>随着业务的扩展，我们的服务会越来越多，越来越多。每个服务都有自己的配置文件。<br>既然是配置文件，给我们配置的东西，那<strong>难免会有些改动</strong>的。<br>比如我们的Demo中，每个服务都写上<strong>相同</strong>的配置文件。万一我们有一天，配置文件中的密码需要更换了，那就得<strong>三个都要重新更改</strong>。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151055-7a0e8.png" alt="img"></p>
<blockquote>
<p>在分布式系统中，某一个基础服务信息变更，都<strong>很可能</strong>会引起一系列的更新和重启</p>
</blockquote>
<p>Spring Cloud Config项目是一个解决分布式系统的配置管理方案。它包含了Client和Server两个部分，<strong>server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，client通过接口获取数据、并依据此数据初始化自己的应用</strong>。</p>
<ul>
<li>简单来说，使用Spring Cloud Config就是将配置文件放到<strong>统一的位置管理</strong>(比如GitHub)，客户端通过接口去获取这些配置文件。</li>
<li>在GitHub上修改了某个配置文件，应用加载的就是修改后的配置文件。</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829151056-71b18.png" alt="img"></p>
<p>SpringCloud Config其他的知识：</p>
<ul>
<li>在SpringCloud Config的服务端， 对于配置仓库的默认<strong>实现采用了Git</strong>，我们也可以配置SVN。</li>
<li>配置文件内的信息<strong>加密和解密</strong></li>
<li>修改了配置文件，希望不用重启来<strong>动态刷新配置</strong>，配合Spring Cloud Bus 使用~</li>
</ul>
<p>使用SpringCloud Config可能的疑问：application.yml和 bootstrap.yml区别</p>
<ul>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2FBlogNetSpace%2Fp%2F8469033.html">www.cnblogs.com/BlogNetSpac…</a></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要写了SpringCloud的基础知识，希望大家看完能有所帮助~<br>SpringCloud的资料也很多，我整理一些我认为比较好，想要深入的同学不妨看看下边的资源<del>~</del><br>SpringCloud系列文章参考资料：</p>
<ul>
<li>史上最简单的 SpringCloud 教程 | 终章<a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fforezp%2Farticle%2Fdetails%2F70148833">blog.csdn.net/forezp/arti…</a></li>
<li>Spring Cloud基础教程《程序员DD》<a href="https://link.juejin.im?target=http%3A%2F%2Fblog.didispace.com%2FSpring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%2F">blog.didispace.com/Spring-Clou…</a></li>
<li>Spring Cloud 系列文章《纯洁的微笑》：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.ityouknow.com%2Fspring-cloud.html">www.ityouknow.com/spring-clou…</a></li>
<li>SpringCloud系列文章：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fwoshimrf%2Ftag%2FSpringCloud%2F">www.cnblogs.com/woshimrf/ta…</a></li>
<li>SpringCloud系列文章《狂小白》：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fhuangjuncong%2Ftag%2FSpringCloud%2F">www.cnblogs.com/huangjuncon…</a></li>
<li>SpringCloud官方文档：<a href="https://link.juejin.im?target=http%3A%2F%2Fprojects.spring.io%2Fspring-cloud%2F">projects.spring.io/spring-clou…</a></li>
<li>Spring Cloud 中文文档：<a href="https://link.juejin.im?target=https%3A%2F%2Fspringcloud.cc%2Fspring-cloud-dalston.html%23_appendix_compendium_of_configuration_properties">springcloud.cc/spring-clou…</a></li>
</ul>
<p>参考书籍：</p>
<ul>
<li>《SpringCloud 微服务实战》</li>
</ul>
<p>SpringCloud GitHub Demo(看完文章的同学可以自己练手玩玩，写好了ReadMe了)：</p>
<ul>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FZhongFuCheng3y%2Fmsc-Demo">github.com/ZhongFuChen…</a></li>
</ul>
<blockquote>
<p>作者：Java3y</p>
<p>来源：<a href="https://juejin.im/post/5b83466b6fb9a019b421cecc" target="_blank" rel="noopener">https://juejin.im/post/5b83466b6fb9a019b421cecc</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring Cloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringMVC 源码解析</title>
    <url>/2019/12/26/SpringMVC-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>年初面试时接触到一道面试题，在聊到SpringMVC时提到了SpringMVC的开发者为何要设计父子容器呢，又或者说是父子容器的设计有什么更实际的作用呢？ 首先要理解对于一个web应用，当期部署在web容器上时，容器会为其提供一个全局上下文环境ServletContext，这个上下文环境将为后续的Spring提供宿主环境。</p>
<a id="more"></a>

<h2 id="SpringMVC工作流程"><a href="#SpringMVC工作流程" class="headerlink" title="SpringMVC工作流程"></a>SpringMVC工作流程</h2><p><img src="http://image.winrains.cn/2019/08/20190829153349-d1b15.png" alt="20180708224853769.png"></p>
<h2 id="DispatcherServlet上下文继承关系"><a href="#DispatcherServlet上下文继承关系" class="headerlink" title="DispatcherServlet上下文继承关系"></a>DispatcherServlet上下文继承关系</h2><p><img src="http://image.winrains.cn/2019/08/20190829153350-5d564.png" alt="mvc-context-hierarchy.png"></p>
<h2 id="SpringMVC设计的父子容器"><a href="#SpringMVC设计的父子容器" class="headerlink" title="SpringMVC设计的父子容器"></a>SpringMVC设计的父子容器</h2><h3 id="父子容器配置文件"><a href="#父子容器配置文件" class="headerlink" title="父子容器配置文件"></a>父子容器配置文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在web.xml中配置，两个重要的xml:applicationContext.xml和SpringMVC-conf.xml--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:applictionContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher-servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:springMVC-conf.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher-servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span></pre></td></tr></table></figure>

<h3 id="父子容器的设计目的"><a href="#父子容器的设计目的" class="headerlink" title="父子容器的设计目的"></a>父子容器的设计目的</h3><p>根据SpringMVC的官方解释，父（根）容器主要包括一些基础脚手架的bean，比如Pool、DataSource、Dao、Service。目的是在不同的Servlet实例之间共享。这些不同的bean可以在子容器中重写。 而子容器主要包括一些Controller、View等一些web相关的bean。</p>
<h2 id="DispatcherServlet源码分析"><a href="#DispatcherServlet源码分析" class="headerlink" title="DispatcherServlet源码分析"></a>DispatcherServlet源码分析</h2><p>既然SpringMVC中同时包含Spring容器和SpringMVC容器，那么这两个容器都是在什么时候初始化呢？</p>
<h3 id="根容器初始化"><a href="#根容器初始化" class="headerlink" title="根容器初始化"></a>根容器初始化</h3><p>首先，根容器是通过ServletContext监听器进行创建，默认的监听器为ContextLoaderListener，当web应用启动时，会调用监听器的<strong>contextInitialized</strong>方法。 那么根容器的初始化就从<strong>ContextLoaderListener</strong>类说起吧，，Spring官方对该类的描述是启动监听器去启动和关闭Spring的root WebApplicationContext（翻译的实在有点蹩脚）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">(WebApplicationContext context)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">super</span>(context);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// ===初始化root WebApplicationContext===</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        initWebApplicationContext(event.getServletContext());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        closeWebApplicationContext(event.getServletContext());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ContextCleanupListener.cleanupAttributes(event.getServletContext());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// ContextLoader.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 初始化Spring容器时如果发现servlet</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 容器中已存在根Spring容根器则抛出异常，证明rootWebApplicationContext只能有一个。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="string">"Cannot initialize context because there is already a root application context present - "</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                        + <span class="string">"check whether you have multiple ContextLoader* definitions in your web.xml!"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 创建webApplicationContext实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.context == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.context = createWebApplicationContext(servletContext);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class="keyword">this</span>.context;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    ApplicationContext parent = loadParentContext(servletContext);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    cwac.setParent(parent);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// 配置WebApplicationContext</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                configureAndRefreshWebApplicationContext(cwac, servletContext);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 把生成的webApplicationContext设置成root</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * WebApplicationContext。保存在ServletContext上下文中。 下一步初始化MVC</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * ApplicationContext时需要从ServletContext取出根上下文作为其父上下文。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         **/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.context);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (ccl == ContextLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()) </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            currentContext = <span class="keyword">this</span>.context;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ccl != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            currentContextPerThread.put(ccl, <span class="keyword">this</span>.context);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.context;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> ex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>以上代码主要完成两个功能：创建实例WebApplicationContext实例、把所创建的WebApplicationContext设置为根上下文，也就是设置成为ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE的值。</p>
<h3 id="MVC容器初始化"><a href="#MVC容器初始化" class="headerlink" title="MVC容器初始化"></a>MVC容器初始化</h3><p>大家知道Servlet生命周期都是从init方法开始，desctory方法结束，由jvm负责垃圾回收。而DispatcherServlet也是一个普通的Servlet，先看一下DispatcherServlet的继承关系图，对整个继承关系有个了解。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829153351-f1d00.jpeg" alt="1946613-f6892f5c658de75c.jpg"></p>
<p>既然说起Servlet，那就从Servlet的初始化（init）方法入手</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HttpServletBean.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            bw.registerCustomEditor(Resource<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">ResourceEditor</span>(<span class="title">resourceLoader</span>, <span class="title">getEnvironment</span>()))</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            initBeanWrapper(bw);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> ex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 交给子类重写</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    initServletBean();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//FrameworkServlet.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        initFrameworkServlet();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">catch</span> (ServletException | RuntimeException ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> ex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//FrameworkServlet.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化MVC容器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 从ServletContext取出根上下文</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    WebApplicationContext wac = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wac = <span class="keyword">this</span>.webApplicationContext;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    cwac.setParent(rootContext);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                configureAndRefreshWebApplicationContext(cwac);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wac = findWebApplicationContext();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果还没有webApplicatioinContext，创建webApplicationContext</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wac = createWebApplicationContext(rootContext);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 子类自定义对servlet子上下文后续操作，在DispatcherServlet中实现</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.onRefreshMonitor) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 执行子类扩展方法onRefresh，在DispatcherServlet内初始化所有web相关组件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            onRefresh(wac);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 发布servlet子上下文到ServletContext</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String attrName = getServletContextAttributeName();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 将servlet子上下文以org.springframework.web.servlet.FrameworkServlet.CONTEXT.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// + servletName的属性名称注册到ServletContext中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        getServletContext().setAttribute(attrName, wac);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> wac;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(@Nullable WebApplicationContext parent)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> createWebApplicationContext((ApplicationContext) parent);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(@Nullable ApplicationContext parent)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 获取WebApplicationContext实现类，此处其实就是XmlWebApplicationContext</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Class&lt;?&gt; contextClass = getContextClass();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!ConfigurableWebApplicationContext<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">contextClass</span>)) </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Fatal initialization error in servlet with name '"</span> + getServletName()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                + <span class="string">"': custom WebApplicationContext class ["</span> + contextClass.getName()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                + <span class="string">"] is not of type ConfigurableWebApplicationContext"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 生成XmlWebApplicationContext实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ConfigurableWebApplicationContext wac = (ConfigurableWebApplicationContext) BeanUtils</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .instantiateClass(contextClass);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    wac.setEnvironment(getEnvironment());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 设置根容器为父容器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    wac.setParent(parent);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    String configLocation = getContextConfigLocation();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (configLocation != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 设置配置文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        wac.setConfigLocation(configLocation);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 配置webApplicationContext</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    configureAndRefreshWebApplicationContext(wac);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> wac;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureAndRefreshWebApplicationContext</span><span class="params">(ConfigurableWebApplicationContext wac)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.contextId != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            wac.setId(<span class="keyword">this</span>.contextId);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    + ObjectUtils.getDisplayString(getServletContext().getContextPath()) + <span class="string">'/'</span> + getServletName());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    wac.setServletContext(getServletContext());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    wac.setServletConfig(getServletConfig());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    wac.setNamespace(getNamespace());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    wac.addApplicationListener(<span class="keyword">new</span> SourceFilteringListener(wac, <span class="keyword">new</span> ContextRefreshListener()));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ConfigurableEnvironment env = wac.getEnvironment();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (env <span class="keyword">instanceof</span> ConfigurableWebEnvironment) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    postProcessWebApplicationContext(wac);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    applyInitializers(wac);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 开始处理bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    wac.refresh();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面的关键代码都在FrameworkServlet类中，有几个关键点：取除根上下文，创建子上下文并设置父上下文，完成刷新，把子上下文发布到ServletContext中。 到这里可以说子容器（子上下文）已经创建完成。 并把其他初始化web组件的相关工作交给onRefresh方法完成，由DispatcherServlet来重写onRefresh方法，这就又回到了我们熟悉的initStrategies方法。</p>
<h3 id="web组件初始化"><a href="#web组件初始化" class="headerlink" title="web组件初始化"></a>web组件初始化</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">protected void on<span class="constructor">Refresh(ApplicationContext <span class="params">context</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">Strategies(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">protected void init<span class="constructor">Strategies(ApplicationContext <span class="params">context</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//文件上传解析器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">MultipartResolver(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//本地化解析器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">LocaleResolver(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//主题解析器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">ThemeResolver(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//处理器映射器(url和Controller方法的映射)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">HandlerMappings(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//处理器适配器(实际执行Controller方法)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">HandlerAdapters(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//处理器异常解析器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">HandlerExceptionResolvers(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//RequestToViewName解析器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">RequestToViewNameTranslator(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//视图解析器(视图的匹配和渲染)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">ViewResolvers(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//FlashMap管理者</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">FlashMapManager(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里我们主要关注一下三个重要组件：HandlerMapping、HandlerAdapter、ViewResolver。分析这3个组件之前，我们先看一下我们的springMVC-conf.xml配置文件，mvc的配置文件中，我们配置了两行代码：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">&lt;<span class="symbol">context:</span>component-scan base-package=<span class="string">"com.zhangfei"</span>/&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;<span class="symbol">mvc:</span><span class="keyword">annotation</span>-<span class="title">driven</span>&gt;</span></pre></td></tr></table></figure>

<p>第二行代码主要是添加了默认的HandleMapping,ViewResolver,HandleAdapter。我们看看annotation-driven的源码定义，根据spring自定义schema定义，我们找到如下代码，如图所示：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829153351-eab5e.jpeg" alt="QQ截图20190822131726.jpg"></p>
<p>该文件就一行代码：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">http:<span class="type"></span>//www.springframework.org/schema/mvc=org.springframework.web.servlet.config.MvcNamespaceHandler</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//MVC所有的标签解析器都定义在此</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcNamespaceHandler</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">NamespaceHandlerSupport</span></span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> void init() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"annotation-driven"</span>, <span class="keyword">new</span> <span class="type">AnnotationDrivenBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"default-servlet-handler"</span>, <span class="keyword">new</span> <span class="type">DefaultServletHandlerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"interceptors"</span>, <span class="keyword">new</span> <span class="type">InterceptorsBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"resources"</span>, <span class="keyword">new</span> <span class="type">ResourcesBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"view-controller"</span>, <span class="keyword">new</span> <span class="type">ViewControllerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"redirect-view-controller"</span>, <span class="keyword">new</span> <span class="type">ViewControllerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"status-controller"</span>, <span class="keyword">new</span> <span class="type">ViewControllerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"view-resolvers"</span>, <span class="keyword">new</span> <span class="type">ViewResolversBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"tiles-configurer"</span>, <span class="keyword">new</span> <span class="type">TilesConfigurerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"freemarker-configurer"</span>, <span class="keyword">new</span> <span class="type">FreeMarkerConfigurerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"groovy-configurer"</span>, <span class="keyword">new</span> <span class="type">GroovyMarkupConfigurerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"script-template-configurer"</span>, <span class="keyword">new</span> <span class="type">ScriptTemplateConfigurerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"cors"</span>, <span class="keyword">new</span> <span class="type">CorsBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>那么通过分析AnnotationDrivenBeanDefinitionParser类，主要完成以下三大组件的装配工作：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829153351-7caf6.jpeg" alt="QQ截图20190822132044.jpg"></p>
<h4 id="初始化处理器映射器"><a href="#初始化处理器映射器" class="headerlink" title="初始化处理器映射器"></a>初始化处理器映射器</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void initHandlerMappings(ApplicationContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">this</span>.handlerMappings = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 这里detectAllHandlerMappings默认值为true，可以通过配置文件设置为false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerMappings) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 从上下文(包含父上下文)中查找所有HandlerMapping实现类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Map&lt;String, HandlerMapping&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                HandlerMapping<span class="class">.<span class="keyword">class</span>, <span class="type">true</span>, <span class="type">false);</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.handlerMappings = new ArrayList&lt;&gt;(matchingBeans.values());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerMappings);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 这里只取固定的bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping<span class="class">.<span class="keyword">class</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.handlerMappings = Collections.singletonList(hm);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/***</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 确保至少有一个HandlerMapping，如果没能找到，注册一个默认的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 默认规则在DispatcherServlet.properties中，这里也就是取BeanNameUrlHandlerMapping、</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * RequestMappingHandlerMapping</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     ***/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="literal">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping<span class="class">.<span class="keyword">class</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="初始化处理器适配器"><a href="#初始化处理器适配器" class="headerlink" title="初始化处理器适配器"></a>初始化处理器适配器</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void initHandlerAdapters(ApplicationContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">this</span>.handlerAdapters = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerAdapters) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 从上下文（包括父上下文）中查找所有HandlerAdapter实现类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Map&lt;String, HandlerAdapter&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                HandlerAdapter<span class="class">.<span class="keyword">class</span>, <span class="type">true</span>, <span class="type">false);</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.handlerAdapters = new ArrayList&lt;&gt;(matchingBeans.values());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerAdapters);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 这里取bean名字为handlerAdapter，类型为HandlerAdapter的处理器适配器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            HandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter<span class="class">.<span class="keyword">class</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.handlerAdapters = Collections.singletonList(ha);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 如果没找到，则从默认规则里取出指定的三个实现类：HttpRequestHandlerAdapter、</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * SimpleControllerHandlerAdapter、RequestMappingHandlerAdapter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     **/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerAdapters == <span class="literal">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.handlerAdapters = getDefaultStrategies(context, HandlerAdapter<span class="class">.<span class="keyword">class</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="初始化试图解析器"><a href="#初始化试图解析器" class="headerlink" title="初始化试图解析器"></a>初始化试图解析器</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void initViewResolvers(ApplicationContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">this</span>.viewResolvers = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.detectAllViewResolvers) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 从上下文（包括父上下文）中查找所有ViewResolver实现类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Map&lt;String, ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ViewResolver<span class="class">.<span class="keyword">class</span>, <span class="type">true</span>, <span class="type">false);</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.viewResolvers = new ArrayList&lt;&gt;(matchingBeans.values());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.viewResolvers);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ViewResolver vr = context.getBean(VIEW_RESOLVER_BEAN_NAME, ViewResolver<span class="class">.<span class="keyword">class</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.viewResolvers = Collections.singletonList(vr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 如果没找到，则从默认规则里取出指定的实现类：InternalResourceViewResolver</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     **/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.viewResolvers == <span class="literal">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.viewResolvers = getDefaultStrategies(context, ViewResolver<span class="class">.<span class="keyword">class</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>三大组件的初始化最后判断为NULL时都会调用getDefaultStrategies方法，也就是从DispatcherServlet.properties中取出指定默认值。</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; List&lt;T&gt; getDefaultStrategies(ApplicationContext context, Class&lt;T&gt; strategyInterface) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">String</span> <span class="built_in">key</span> = strategyInterface.getName();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">String</span> value = defaultStrategies.getProperty(<span class="built_in">key</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">String</span>[] classNames = StringUtils.commaDelimitedListToStringArray(value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;T&gt; strategies = <span class="keyword">new</span> ArrayList&lt;&gt;(classNames.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">String</span> className : classNames) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Class&lt;?&gt; clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">Object</span> strategy = createDefaultStrategy(context, clazz);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                strategies.<span class="built_in">add</span>((T) strategy);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">"Could not find DispatcherServlet's default strategy class ["</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                        + className + <span class="string">"] for interface ["</span> + <span class="built_in">key</span> + <span class="string">"]"</span>, ex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">catch</span> (LinkageError err) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="string">"Unresolvable class definition for DispatcherServlet's default strategy class ["</span> + className</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                + <span class="string">"] for interface ["</span> + <span class="built_in">key</span> + <span class="string">"]"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        err);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> strategies;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="DispatcherServlet请求处理过程"><a href="#DispatcherServlet请求处理过程" class="headerlink" title="DispatcherServlet请求处理过程"></a>DispatcherServlet请求处理过程</h2><p>提到请求处理过程，我们再来回顾一下Servlet生命周期，处理请求都放在service方法中处理，那么也从DispatcherServlet的service方法入手。DispatcherServlet继承FrameworkServlet，在FrameworkServlet中重写了service、doGet、doPost、doPut、doDelete方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FrameworkServlet.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (httpMethod == HttpMethod.PATCH || httpMethod == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        processRequest(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">super</span>.service(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    processRequest(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    processRequest(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPut</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    processRequest(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    processRequest(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Throwable failureCause = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LocaleContext localeContext = buildLocaleContext(request);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    asyncManager.registerCallableInterceptor(FrameworkServlet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">new</span> <span class="title">RequestBindingInterceptor</span>())</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 把新构造的LocaleContext对象和ServletRequestAttributes对象和当前请求线程绑定（后面要解除绑定）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    initContextHolders(request, localeContext, requestAttributes);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 抽象方法，交给DispatcherServlet方法实现</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        doService(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (ServletException | IOException ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        failureCause = ex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> ex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        failureCause = ex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NestedServletException(<span class="string">"Request processing failed"</span>, ex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 重置LocaleContext和RequestAttributes对象，也就是解除LocaleContext对象和ServletRequestAttributes对象和当前请求线程的绑定</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        resetContextHolders(request, previousLocaleContext, previousAttributes);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (requestAttributes != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            requestAttributes.requestCompleted();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 发布ServletRequestHandledEvent事件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        publishRequestHandledEvent(request, response, startTime, failureCause);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// DispatcherServlet.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        attributesSnapshot = <span class="keyword">new</span> HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            String attrName = (String) attrNames.nextElement();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                attributesSnapshot.put(attrName, request.getAttribute(attrName));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 在当前request对象中填充4个属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.flashMapManager != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 主要处理分发请求</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        doDispatch(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (attributesSnapshot != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                restoreAttributesAfterInclude(request, attributesSnapshot);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    HttpServletRequest processedRequest = request;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            processedRequest = checkMultipart(request);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            multipartRequestParsed = (processedRequest != request);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 调用handlerMapping获取handlerChain</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            mappedHandler = getHandler(processedRequest);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                noHandlerFound(processedRequest, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 获取支持该handler解析的HandlerAdapter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            String method = request.getMethod();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 使用HandlerAdapter完成handler处理</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 视图处理(页面渲染)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            applyDefaultViewName(processedRequest, mv);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            dispatchException = ex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable err) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Throwable err) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                cleanupMultipart(processedRequest);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>DispatcherServlet的doDispatch方法概括起来大致就是以下几点：首先根据当前请求路径找到对应的HandlerMethod，一个HandlerMethod和若干个拦截器构造一个<strong>HandlerExecutionChain.通过HandlerExecutionChain</strong>得到<strong>HandlerAdapter</strong>对象<strong>，</strong>通过执行<strong>HandlerAdapter</strong>的handle方法得到<strong>ModelAndView</strong>对象，调用ModelAndView解析视图，渲染视图，Response结束。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5cb89dae6fb9a0686b47306d" target="_blank" rel="noopener">juejin.im/post/5cb89d…</a> <a href="https://juejin.im/post/5cbc10b46fb9a0689f4c2c22" target="_blank" rel="noopener">juejin.im/post/5cbc10…</a> <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Ffangjian0423%2Fp%2FspringMVC-dispatcherServlet.html">www.cnblogs.com/fangjian042…</a></p>
<blockquote>
<p>作者：garfieldzf8</p>
<p>来源：<a href="https://juejin.im/post/5d5e3e70e51d453b5d4d8d75" target="_blank" rel="noopener">https://juejin.im/post/5d5e3e70e51d453b5d4d8d75</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring MVC</category>
      </categories>
  </entry>
  <entry>
    <title>Spring AOP使用讲解</title>
    <url>/2019/12/26/Spring%20AOP%E4%BD%BF%E7%94%A8%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="1-什么是AOP"><a href="#1-什么是AOP" class="headerlink" title="1. 什么是AOP?"></a>1. 什么是AOP?</h2><p>AOP是Aspect Oriented Programming的缩写，意思是：面向切面编程，它是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。<br>可以认为AOP是对OOP(Object Oriented Programming 面向对象编程)的补充，主要使用在日志记录，性能统计，安全控制等场景，使用AOP可以使得业务逻辑各部分之间的耦合度降低，只专注于各自的业务逻辑实现，从而提高程序的可读性及维护性。<br>比如，我们需要记录项目中所有对外接口的入参和出参，以便出现问题时定位原因，在每一个对外接口的代码中添加代码记录入参和出参当然也可以达到目的，但是这种硬编码的方式非常不友好，也不够灵活，而且记录日志本身和接口要实现的核心功能没有任何关系。</p>
<a id="more"></a>

<p>此时，我们可以将记录日志的功能定义到1个切面中，然后通过声明的方式定义要在何时何地使用这个切面，而不用修改任何1个外部接口。<br>在讲解具体的实现方式之前，我们先了解几个AOP中的术语。</p>
<h3 id="1-1-通知-Advice"><a href="#1-1-通知-Advice" class="headerlink" title="1.1 通知(Advice)"></a>1.1 通知(Advice)</h3><p>在AOP术语中，切面要完成的工作被称为通知，通知定义了切面是什么以及何时使用。<br>Spring切面有5种类型的通知，分别是：</p>
<ul>
<li>前置通知(Before)：在目标方法被调用之前调用通知功能</li>
<li>后置通知(After)：在目标方法完成之后调用通知，此时不关心方法的输出结果是什么</li>
<li>返回通知(After-returning)：在目标方法成功执行之后调用通知</li>
<li>异常通知(After-throwing)：在目标方法抛出异常后调用通知</li>
<li>环绕通知(Around)：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为</li>
</ul>
<h3 id="1-2-连接点-Join-point"><a href="#1-2-连接点-Join-point" class="headerlink" title="1.2 连接点(Join point)"></a>1.2 连接点(Join point)</h3><p>连接点是在应用执行过程中能够插入切面的一个点，这个点可以是调用方法时、抛出异常时、修改某个字段时。</p>
<h3 id="1-3-切点-Pointcut"><a href="#1-3-切点-Pointcut" class="headerlink" title="1.3 切点(Pointcut)"></a>1.3 切点(Pointcut)</h3><p>切点是为了缩小切面所通知的连接点的范围，即切面在何处执行。我们通常使用明确的类和方法名称，或者利用正则表达式定义所匹配的类和方法名称来指定切点。</p>
<h3 id="1-4-切面-Aspect"><a href="#1-4-切面-Aspect" class="headerlink" title="1.4 切面(Aspect)"></a>1.4 切面(Aspect)</h3><p>切面是通知和切点的结合。通知和切点共同定义了切面的全部内容：它是什么，在何时和何处完成其功能。</p>
<h3 id="1-5-引入-Introduction"><a href="#1-5-引入-Introduction" class="headerlink" title="1.5 引入(Introduction)"></a>1.5 引入(Introduction)</h3><p>引入允许我们在不修改现有类的基础上，向现有类添加新方法或属性。</p>
<h3 id="1-6-织入-Weaving"><a href="#1-6-织入-Weaving" class="headerlink" title="1.6 织入(Weaving)"></a>1.6 织入(Weaving)</h3><p>织入是把切面应用到目标对象并创建新的代理对象的过程。<br>切面在指定的连接点被织入到目标对象中，在目标对象的生命周期里，有以下几个点可以进行织入：</p>
<ul>
<li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li>
<li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器(ClassLoader)，它可以在目标类被引入应用之前增强该目标类的字节码。</li>
<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。</li>
</ul>
<h2 id="2-Spring-对AOP的支持"><a href="#2-Spring-对AOP的支持" class="headerlink" title="2. Spring 对AOP的支持"></a>2. Spring 对AOP的支持</h2><h3 id="2-1-动态代理"><a href="#2-1-动态代理" class="headerlink" title="2.1 动态代理"></a>2.1 动态代理</h3><p><strong>Spring AOP构建在动态代理之上</strong>，也就是说，Spring运行时会为目标对象动态创建代理对象。<br>代理类封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。<br>当代理类拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829154615-53d0a.png" alt="img"></p>
<h3 id="2-2-织入切面时机"><a href="#2-2-织入切面时机" class="headerlink" title="2.2 织入切面时机"></a>2.2 织入切面时机</h3><p>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring 管理的bean中，也就是说，直到应用需要被代理的bean时，Spring才会创建代理对象。<br>因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入Spring AOP切面。</p>
<h3 id="2-3-连接点限制"><a href="#2-3-连接点限制" class="headerlink" title="2.3 连接点限制"></a>2.3 连接点限制</h3><p>Spring只支持方法级别的连接点，如果需要字段级别或者构造器级别的连接点，可以利用AspectJ来补充Spring AOP的功能。</p>
<h2 id="3-Spring-AOP使用"><a href="#3-Spring-AOP使用" class="headerlink" title="3. Spring AOP使用"></a>3. Spring AOP使用</h2><p>假设我们有个现场表演的接口Performance和它的实现类SleepNoMore：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package chapter04.concert;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 现场表演,如舞台剧,电影,音乐会</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> interface Performance &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="type">void</span> <span class="keyword">perform</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">package chapter04.concert;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 戏剧:《不眠之夜Sleep No More》</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Component</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> SleepNoMore implements Performance &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">public</span> <span class="type">void</span> <span class="keyword">perform</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("戏剧《不眠之夜Sleep No More》");</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>既然是演出，就需要观众，假设我们的需求是：在看演出之前，观众先入座并将手机调整至静音，在观看演出之后观众鼓掌，如果演出失败观众退票，我们当然可以把这些逻辑写在上面的perform()方法中，但不推荐这么做，因为这些逻辑理论上和演出的核心无关，就算观众不将手机调整至静音或者看完演出不鼓掌，都不影响演出的进行。<br>针对这个需求，我们可以使用AOP来实现。</p>
<h3 id="3-1-定义切面"><a href="#3-1-定义切面" class="headerlink" title="3.1 定义切面"></a>3.1 定义切面</h3><p>首先，在pom.xml文件中添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring aop支持--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--aspectj支持--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure>

<p>然后，定义一个观众的切面如下：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">package chapter04.concert;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.aspectj.lang.<span class="keyword">annotation</span>.<span class="title">Aspect</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">/**</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * 观众</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * 使用@Aspect注解定义为切面</span></pre></td></tr><tr><td class="code"><pre><span class="line"> *<span class="regexp">/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">@Aspect</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">public class Audience &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">&#125;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：<code>@Aspect</code>注解表明Audience类是一个切面。</p>
</blockquote>
<h3 id="3-2-定义前置通知"><a href="#3-2-定义前置通知" class="headerlink" title="3.2 定义前置通知"></a>3.2 定义前置通知</h3><p>在Audience切面中定义前置通知如下所示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演之前,观众就座</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="keyword">Before</span>("execution(* chapter04.concert.Performance.perform(..))")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> takeSeats() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("Taking seats");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演之前,将手机调至静音</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="keyword">Before</span>("execution(* chapter04.concert.Performance.perform(..))")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> silenceCellPhones() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("Silencing cell phones");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里的重点代码是<code>@Before(&quot;execution(* chapter04.concert.Performance.perform(..))&quot;)</code>，它定义了1个前置通知，其中<code>execution(* chapter04.concert.Performance.perform(..))</code>被称为AspectJ切点表达式，每一部分的讲解如下：</p>
<ul>
<li>@Before：该注解用来定义前置通知，通知方法会在目标方法调用之前执行</li>
<li>execution：在方法执行时触发</li>
<li>*：表明我们不关心方法返回值的类型，即可以是任意类型</li>
<li>chapter04.concert.Performance.perform：使用全限定类名和方法名指定要添加前置通知的方法</li>
<li>(..)：方法的参数列表使用(..)，表明我们不关心方法的入参是什么，即可以是任意类型</li>
</ul>
<h3 id="3-3-定义后置通知"><a href="#3-3-定义后置通知" class="headerlink" title="3.3 定义后置通知"></a>3.3 定义后置通知</h3><p>在Audience切面中定义后置通知如下所示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演结束,不管表演成功或者失败</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="keyword">After</span>("execution(* chapter04.concert.Performance.perform(..))")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> finish() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("perform finish");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：@After注解用来定义后置通知，通知方法会在目标方法返回或者抛出异常后调用</p>
</blockquote>
<h3 id="3-4-定义返回通知"><a href="#3-4-定义返回通知" class="headerlink" title="3.4 定义返回通知"></a>3.4 定义返回通知</h3><p>在Audience切面中定义返回通知如下所示：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演之后,鼓掌</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@AfterReturning(<span class="string">"execution(* chapter04.concert.Performance.perform(..))"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"CLAP CLAP CLAP!!!"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：@AfterReturning注解用来定义返回通知，通知方法会在目标方法返回后调用</p>
</blockquote>
<h3 id="3-5-定义异常通知"><a href="#3-5-定义异常通知" class="headerlink" title="3.5 定义异常通知"></a>3.5 定义异常通知</h3><p>在Audience切面中定义异常通知如下所示：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演失败之后,观众要求退款</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@AfterThrowing(<span class="string">"execution(* chapter04.concert.Performance.perform(..))"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demandRefund</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Demanding a refund"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：@AfterThrowing注解用来定义异常通知，通知方法会在目标方法抛出异常后调用</p>
</blockquote>
<h3 id="3-6-定义可复用的切点表达式"><a href="#3-6-定义可复用的切点表达式" class="headerlink" title="3.6 定义可复用的切点表达式"></a>3.6 定义可复用的切点表达式</h3><p>细心的你可能会发现，我们上面定义的5个切点中，切点表达式都是一样的，这显然是不好的，好在我们可以使用<code>@Pointcut</code>注解来定义可重复使用的切点表达式：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 可复用的切点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Pointcut("execution(* chapter04.concert.Performance.perform(..))")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> <span class="keyword">perform</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后之前定义的5个切点都可以引用这个切点表达式：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演之前,观众就座</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="keyword">Before</span>("perform()")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> takeSeats() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("Taking seats");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演之前,将手机调至静音</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="keyword">Before</span>("perform()")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> silenceCellPhones() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("Silencing cell phones");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演结束,不管表演成功或者失败</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="keyword">After</span>("perform()")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> finish() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("perform finish");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演之后,鼓掌</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@AfterReturning("perform()")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> applause() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("CLAP CLAP CLAP!!!");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演失败之后,观众要求退款</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@AfterThrowing("perform()")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> demandRefund() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("Demanding a refund");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="3-7-单元测试"><a href="#3-7-单元测试" class="headerlink" title="3.7 单元测试"></a>3.7 单元测试</h3><p>新建配置类ConcertConfig如下所示：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">package chapter04.concert;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">Bean</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">ComponentScan</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">Configuration</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">EnableAspectJAutoProxy</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableAspectJAutoProxy</span></pre></td></tr><tr><td class="code"><pre><span class="line">@ComponentScan</span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcertConfig</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Audience audience() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> new Audience();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：和以往不同的是，我们使用了<code>@EnableAspectJAutoProxy</code>注解，该注解用来启用自动代理功能。</p>
</blockquote>
<p>新建Main类，在其main()方法中添加如下测试代码：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package chapter04.concert;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Main &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        AnnotationConfigApplicationContext context = <span class="built_in">new</span> AnnotationConfigApplicationContext(ConcertConfig.<span class="keyword">class</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Performance performance = context.getBean(Performance.<span class="keyword">class</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        performance.<span class="keyword">perform</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        context.<span class="keyword">close</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>运行代码，输出结果如下所示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Silencing cell phones</span></pre></td></tr><tr><td class="code"><pre><span class="line">Taking seats</span></pre></td></tr><tr><td class="code"><pre><span class="line">戏剧《不眠之夜Sleep <span class="keyword">No</span> More》</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">perform</span> finish</span></pre></td></tr><tr><td class="code"><pre><span class="line">CLAP CLAP CLAP!!!</span></pre></td></tr></table></figure>

<p>稍微修改下SleepNoMore类的perform()方法，让它抛出一个异常：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@Override</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> <span class="keyword">perform</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="type">int</span> number = <span class="number">3</span> / <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("戏剧《不眠之夜Sleep No More》");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>再次运行代码，输出结果如下所示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Silencing cell phones</span></pre></td></tr><tr><td class="code"><pre><span class="line">Taking seats</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">perform</span> finish</span></pre></td></tr><tr><td class="code"><pre><span class="line">Demanding a refund</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Exception</span> <span class="keyword">in</span> thread "main" java.lang.ArithmeticException: / <span class="keyword">by</span> zero</span></pre></td></tr></table></figure>

<p><img src="http://image.winrains.cn/2019/08/20190829154615-ecdb8.png" alt="img"></p>
<p>由此也可以说明，不管目标方法是否执行成功，@After注解都会执行，但@AfterReturning注解只会在目标方法执行成功时执行。<br>值得注意的是，使用<code>@Aspect</code>注解的切面类必须是一个bean(不管以何种方式声明)，否则切面不会生效，因为AspectJ自动代理只会为使用<code>@Aspect</code>注解的bean创建代理类。<br>也就是说，如果我们将ConcertConfig配置类中的以下代码删除或者注释掉：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">Audience <span class="title">audience</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Audience();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>运行结果将变为：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">戏剧《不眠之夜<span class="keyword">Sleep</span> <span class="keyword">No</span> <span class="keyword">More</span>》</span></pre></td></tr></table></figure>

<h3 id="3-8-创建环绕通知"><a href="#3-8-创建环绕通知" class="headerlink" title="3.8 创建环绕通知"></a>3.8 创建环绕通知</h3><p>我们可以使用<code>@Around</code>注解创建环绕通知，该注解能够让你在调用目标方法前后，自定义自己的逻辑。<br>因此，我们之前定义的5个切点，现在可以定义在一个切点中，为不影响之前的切面，我们新建切面AroundAudience，如下所示：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">package chapter04.concert;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.aspectj.lang.<span class="keyword">annotation</span>.<span class="title">Around</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.aspectj.lang.<span class="keyword">annotation</span>.<span class="title">Aspect</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.aspectj.lang.<span class="keyword">annotation</span>.<span class="title">Pointcut</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Aspect</span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AroundAudience</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    /**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 可重用的切点</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *<span class="regexp">/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    @Pointcut("execution(* chapter04.concert.Performance.perform(..))")</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    public void perform() &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    @Around("perform()")</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    public void watchPerform(ProceedingJoinPoint joinPoint) &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">        try &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">            System.out.println("Taking seats");</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">            System.out.println("Silencing cell phones");</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">            joinPoint.proceed();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">            System.out.println("CLAP CLAP CLAP!!!");</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">        &#125; catch (Throwable throwable) &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">            System.out.println("Demanding a refund");</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">        &#125; finally &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">            System.out.println("perform finish");</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">        &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">&#125;</span></span></pre></td></tr></table></figure>

<p>这里要注意的是，该方法有个ProceedingJoinPoint类型的参数，在方法中可以通过调用它的proceed()方法来调用目标方法。<br>然后修改下ConcertConfig类的代码：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">package chapter04.concert;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">Bean</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">ComponentScan</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">Configuration</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">EnableAspectJAutoProxy</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableAspectJAutoProxy</span></pre></td></tr><tr><td class="code"><pre><span class="line">@ComponentScan</span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcertConfig</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    /*@Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Audience audience() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> new Audience();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;*<span class="regexp">/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    @Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    public AroundAudience aroundAudience() &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">        return new AroundAudience();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">&#125;</span></span></pre></td></tr></table></figure>

<p>运行结果如下所示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Taking seats</span></pre></td></tr><tr><td class="code"><pre><span class="line">Silencing cell phones</span></pre></td></tr><tr><td class="code"><pre><span class="line">戏剧《不眠之夜Sleep <span class="keyword">No</span> More》</span></pre></td></tr><tr><td class="code"><pre><span class="line">CLAP CLAP CLAP!!!</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">perform</span> finish</span></pre></td></tr></table></figure>

<h2 id="4-源码及参考"><a href="#4-源码及参考" class="headerlink" title="4. 源码及参考"></a>4. 源码及参考</h2><p>源码地址：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fzwwhnly%2Fspring-action.git">github.com/zwwhnly/spr…</a>，欢迎下载。<br>Craig Walls 《Spring实战（第4版）》<br><a href="https://link.juejin.im?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2FAOP%2F1332219">AOP（面向切面编程）_百度百科</a></p>
<blockquote>
<p>作者：申城异乡人</p>
<p>来源：<a href="https://juejin.im/post/5d648403f265da03f564f291" target="_blank" rel="noopener">https://juejin.im/post/5d648403f265da03f564f291</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引数据结构详解与索引优化</title>
    <url>/2019/12/26/MySQL%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>本篇文章主要学习了MySQL的索引的数据结构的认识，做一个大概的了解即可。</p>
<h2 id="一、索引"><a href="#一、索引" class="headerlink" title="一、索引"></a>一、索引</h2><p>在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行<strong>排序</strong>的一种存储<strong>数据结构</strong>，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑<a href="https://link.juejin.im?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E6%8C%87%E9%92%88%2F2878304">指针</a>清单。索引的作用相当于图书的目录，可以根据目录中的页码快速查找到所需的内容。<br>在MySQL中，存储引擎用类似的方法使用索引，先在索引中找到对应值，然后根据匹配的索引记录找到对应的行。<br>首先说明下MySQL的索引主要是基于Hash表或者B+树。</p>
<a id="more"></a>

<h2 id="二、索引数据结构"><a href="#二、索引数据结构" class="headerlink" title="二、索引数据结构"></a>二、索引数据结构</h2><p>了解索引就需要从索引常见的数据结构开始了解学习，这里有集中常见的的索引数据结构。</p>
<h3 id="二叉树（Binary-Trees）"><a href="#二叉树（Binary-Trees）" class="headerlink" title="二叉树（Binary Trees）"></a>二叉树（Binary Trees）</h3><p>二叉树是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常被称之为“左子树”和“右子树”</p>
<p><img src="http://image.winrains.cn/2019/08/20190829160230-5df25.jpeg" alt="http://image.winrains.cn/2019/08/20190829160230-5df25.jpeg"></p>
<p><strong>左子树&lt;父节点&lt;=右子树</strong><br>二叉树的第i层至多有有2^(i-1)个节点，<br>深度为K的二叉树至多总共有个2^k-1节点（定义根节点所在深度 k0=0），而总计拥有节点数符合的，称为“满二叉树”；<br>二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现<a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9">二叉搜索树</a>和<a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E4%BA%8C%E5%85%83%E5%A0%86%E7%A9%8D">二叉堆</a>，并应用于高效率的搜索和排序。<br>同时学习数据结构，这里还推荐<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cs.usfca.edu%2F~galles%2Fvisualization%2FAlgorithms.html">Data Structure Visualizations</a>进行学习，可以非常直观的看到数据结构允许的过程，一步一步的怎么走的都可以很清晰看得到。<br>找到其中的<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cs.usfca.edu%2F~galles%2Fvisualization%2FBST.html">Binary Search Trees</a>二叉树</p>
<p><img src="http://image.winrains.cn/2019/08/20190829160230-b696d.png" alt="http://image.winrains.cn/2019/08/20190829160230-b696d.png"></p>
<p>可以直观的看到二叉树的数据插入过程，如下：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829160232-1b122.gif" alt="http://image.winrains.cn/2019/08/20190829160232-1b122.gif"></p>
<p>可以看到二叉树不适合用作当作索引的，数据量庞大的话，二叉树的层数会很大，查找效率固然也很慢了。<br>推荐阅读：<a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E4%BA%8C%E5%8F%89%E6%A0%91">维基百科-二叉树</a></p>
<h3 id="红黑树（Red-Black-Trees）"><a href="#红黑树（Red-Black-Trees）" class="headerlink" title="红黑树（Red-Black Trees）"></a>红黑树（Red-Black Trees）</h3><p>是一种自平衡二叉查找树，典型用途是实现关联数组。<br>红黑树的结构复杂，但它的操作有着良好的最坏情况<a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90">运行时间</a>，并且在实践中高效：它可以在O(log n)时间内完成查找，插入和删除，这里的n是树中元素的数目。<br>红黑树遵行以下原则：</p>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有<a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E9%81%93%E8%B7%AF_(%E5%9B%BE%E8%AE%BA)">简单路径</a>都包含相同数目的黑色节点。</li>
</ol>
<p>下面是一个具体的红黑树的图例：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829160233-a9fa9.png" alt="http://image.winrains.cn/2019/08/20190829160233-a9fa9.png"></p>
<p>这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的<a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">二叉查找树</a>。<br>要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。<br>同样在<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cs.usfca.edu%2F~galles%2Fvisualization%2FAlgorithms.html">Data Structure Visualizations</a>中选择<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cs.usfca.edu%2F~galles%2Fvisualization%2FRedBlack.html">Red-Black Trees</a>红黑树进行插入操作可以直观的看到红黑树的插入过程</p>
<p><img src="http://image.winrains.cn/2019/08/20190829160233-7ea03.gif" alt="http://image.winrains.cn/2019/08/20190829160233-7ea03.gif"></p>
<p>同样红黑树也不适用于MySQL的索引，数据量庞大之后，数层也会变大。<br>推荐阅读：<br><a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E7%BA%A2%E9%BB%91%E6%A0%91">维基百科-红黑树</a><br><a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fjz1ajDUygZ7sXLQFHyfjWA">程序员小灰-红黑树</a></p>
<h3 id="其他结构的问题"><a href="#其他结构的问题" class="headerlink" title="其他结构的问题"></a>其他结构的问题</h3><p>由于无法装入内存，则必然依赖磁盘（或SSD）存储。而内存的读写速度是磁盘的成千上万倍（与具体实现有关），因此，核心问题是“如何减少磁盘读写次数”。<br>首先不考虑页表机制，假设每次读、写都直接穿透到磁盘，那么：</p>
<ul>
<li>线性结构：读/写平均O(n)次</li>
<li>二叉搜索树（<code>BST</code>）：读/写平均O(log2(n))次；如果树不平衡，则最差读/写O(n)次</li>
<li>自平衡二叉搜索树（<code>AVL</code>）：在BST的基础上加入了自平衡算法，读/写最大O(log2(n))次</li>
<li>红黑树（<code>RBT</code>）：另一种自平衡的查找树，读/写最大O(log2(n))次</li>
</ul>
<p><code>BST</code>、<code>AVL</code>、<code>RBT</code>很好的将读写次数从O(n)优化到O(log2(n))；其中，<code>AVL</code>和<code>RBT</code>都比<code>BST</code>多了自平衡的功能，将读写次数降到最大O(log2(n))。<br>假设使用自增主键，则主键本身是有序的，树结构的读写次数能够优化到树高，树高越低读写次数越少；自平衡保证了树结构的稳定。如果想进一步优化，可以引入<code>B树</code>和<code>B+树</code>。</p>
<h3 id="B树（B-Trees）"><a href="#B树（B-Trees）" class="headerlink" title="B树（B-Trees）"></a>B树（B-Trees）</h3><p>又称：多路平衡查找树。大多数存储引擎都支持B树索引。b树通常意味着所有的值都是按顺序存储的，并且每一个叶子节点到根的距离相同。B树索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取数据。下图就是一颗简单的B树。<br>在B树中，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）。当数据被插入或从一个节点中移除，它的子节点数量发生变化。为了维持在预先设定的数量范围内，内部节点可能会被合并或者分离。<br>如下图所示：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829160234-35182.png" alt="http://image.winrains.cn/2019/08/20190829160234-35182.png"></p>
<ul>
<li>叶节点具有相同的深度，叶节点的指针为空</li>
<li>所有索引元素不重复</li>
<li>节点中的数据索引从左到右递增排列</li>
<li>无论中间节点还是叶子节点都带有卫星数据data（索引元素所指向的数据记录）</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829160235-9e2bd.gif" alt="http://image.winrains.cn/2019/08/20190829160235-9e2bd.gif"></p>
<p>只演示了插入的过程，其中可以通过delete、find执行删除和查找操作。直观的感受到B树的执行过程。<br>每个节点存储了多个Key和子树，子树与Key按顺序排列。</p>
<blockquote>
<p>同二叉搜索树类似，每个节点存储了多个key和子树，子树与key按顺序排列。<br>页表的目录是扩展外存+加速磁盘读写，一个页（Page）通常4K（等于磁盘数据块block的大小，见inode与block的分析），操作系统每次以页为单位将内容从磁盘加载到内存（以摊分寻道成本），修改页后，再择期将该页写回磁盘。考虑到页表的良好性质，可以使每个节点的大小约等于一个页（使m非常大），这每次加载的一个页就能完整覆盖一个节点，以便选择下一层子树；对子树同理。对于页表来说，AVL（或RBT）相当于1个key+2个子树的B树，由于逻辑上相邻的节点，物理上通常不相邻，因此，读入一个4k页，页面内绝大部分空间都将是无效数据。</p>
</blockquote>
<p>假设key、子树节点指针均占用4B，则B树节点最大<code>m * (4 + 4) = 8m B</code>；页面大小4KB。则<code>m = 4 * 1024 / 8m = 512</code>，一个512叉的B树，1000w的数据，深度最大 <code>log(512/2)(10^7) = 3.02 ~= 4</code>。对比二叉树如AVL的深度为<code>log(2)(10^7) = 23.25 ~= 24</code>，相差了5倍以上。震惊！B树索引深度竟然如此！<br>那为什么B数这么厉害了，还有B+树的出现呢，必然是解决B树存在的问题<br>1、为定位行数<br>2、无法处理范围查询<br><strong>问题1：为定位行数</strong><br>数据表的记录有多个字段，仅仅定位到主键是不够的，还需要定位到数据行。有3个方案解决：</p>
<ol>
<li>直接将key对应的数据行（可能对应多行）存储子节点中。</li>
<li>数据行单独存储；节点中增加一个字段，定位key对应数据行的位置。</li>
<li>修改key与子树的判断逻辑，使子树大于等于上一key小于下一key，最终所有访问都将落于叶子节点；叶子节点中直接存储数据行或数据行的位置。</li>
</ol>
<p>方案1直接pass，存储数据行将减少页面中的子树个数，m减小树高增大。<br>方案2的节点中增加了一个字段，假设是4B的指针，则新的<code>m = 4 * 1024 / 12m = 341.33 ~= 341</code>，深度最大 <code>log(341/2)(10^7) = 3.14 ~= 4</code>。<br>方案3的节点m与深度不变，但时间复杂度变为稳定的O(logm(n))。<br>方案3可以考虑。<br><strong>问题2：无法处理范围查询</strong><br>实际业务中，范围查询的频率非常高，B树只能定位到一个索引位置（可能对应多行），很难处理范围查询。改动较小的是2个方案：</p>
<ol>
<li>不改动；查询的时候先查到左界，再查到右界，然后DFS（或BFS）遍历左界、右界之间的节点。</li>
<li>在“问题1-方案3”的基础上，由于所有数据行都存储在叶子节点，B树的叶子节点本身也是有序的，可以增加一个指针，指向当前叶子节点按主键顺序的下一叶子节点；查询时先查到左界，再查到右界，然后从左界到有界线性遍历。</li>
</ol>
<p>乍一看感觉方案1比方案2好——时间复杂度和常数项都一样，方案1还不需要改动。但是别忘了局部性原理，不管节点中存储的是数据行还是数据行位置，方案2的好处在于，依然可以利用页表和缓存预读下一节点的信息。而方案1则面临节点逻辑相邻、物理分离的缺点。 推荐阅读：<br><a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FB%E6%A0%91">维基百科-B树</a><br><a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FrDCEFzoKHIjyHfI_bsz5Rw">程序员小灰-B树</a></p>
<h3 id="B-树（B-Trees）"><a href="#B-树（B-Trees）" class="headerlink" title="B+树（B+Trees）"></a>B+树（B+Trees）</h3><p>主要变动如上所述：</p>
<ul>
<li>修改key与子树的组织逻辑，将索引访问都落到叶子节点</li>
<li>按顺序将叶子节点串起来（方便范围查询）</li>
</ul>
<p>回顾上一个B树，<strong>一个m阶的B树具有如下几个特征：</strong><br>1.根结点至少有两个子女。<br>2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m<br>3.每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m<br>4.所有的叶子结点都位于同一层。<br>5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。<br><strong>一个m阶的B+树具有如下几个特征：</strong><br>1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。<br>2.所有的叶子结点包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。<br>3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。<br><strong>B+树特性总结</strong><br><strong>B+树是B树的升级版</strong>，其有如下特性</p>
<ul>
<li>非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引</li>
<li>叶子节点包含所有索引字段</li>
<li>叶子节点用指针连接，提高区间访问的性能</li>
<li>只有叶子节点带有卫星数据data（索引元素所指向的数据记录）</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829160236-e80c3.png" alt="http://image.winrains.cn/2019/08/20190829160236-e80c3.png"></p>
<p>同样在<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cs.usfca.edu%2F~galles%2Fvisualization%2FAlgorithms.html">Data Structure Visualizations</a>中选择<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cs.usfca.edu%2F~galles%2Fvisualization%2FBPlusTree.html">B+ Trees</a>B+树进行插入操作可以直观的看到插入过程</p>
<p><img src="http://image.winrains.cn/2019/08/20190829160237-38799.gif" alt="http://image.winrains.cn/2019/08/20190829160237-38799.gif"></p>
<p>在动图中可以看出，B+树的每一个叶子节点都有一个指针指向下一个节点，把所有的叶子节点串在一起。索引数据都存储在叶子节点中。<br>B+树相比于B树，有什么优势呢：<br>1.单一节点存储更多的元素，使得查询的IO次数更少。<br>2.所有查询都要查找到叶子节点，查询性能稳定。<br>3.所有叶子节点形成有序链表，便于范围查询。<br>总结，B+树相比B树的优势有三：1.IO次数更少；2.查询性能稳定；3.范围查询简便。<br>推荐阅读：<br><a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FB%2B%E6%A0%91">维基百科-B+树</a><br><a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FjRZMMONW3QP43dsDKIV9VQ">程序员小灰-B+树</a></p>
<h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p>hash索引基于hash表实现，<strong>Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中</strong>。只有精准匹配索引所有列的查询才有效。索引的检索可以一次定位，不像B-Tree索引需要从根节点出发到目标节点。虽然Hash索引很快，远高于B-tree索引，但是也有其弊端。</p>
<ol>
<li>Hash索引仅仅能满足’=’,’IN’,’&lt;=&gt;’查询，也就是等值查询，不能使用范围查询。很受限<ol>
<li>由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。</li>
</ol>
</li>
<li>由于Hash索引是通过hash表实现，其本身是没有排序的。<ol>
<li>由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；</li>
</ol>
</li>
<li>Hash索引不能利用部分索引键查询<ol>
<li>对于组合索引，Hash索引在计算hash值的时候是组合索引键合并后再一起计算hash值，而不是单独计算hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。</li>
</ol>
</li>
<li>Hash 索引在任何时候都不能避免表扫描<ol>
<li>前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。</li>
</ol>
</li>
<li>Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。<ol>
<li>对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。</li>
</ol>
</li>
</ol>
<h2 id="三、MySQL数据库引擎"><a href="#三、MySQL数据库引擎" class="headerlink" title="三、MySQL数据库引擎"></a>三、MySQL数据库引擎</h2><p>通过navicat工具查看表设计选项中，从引擎中可以看到MySQL又这么多引擎。具体细分到每个表，不同的表引擎可以不一样。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155930-985f7.png" alt="MySQL数据库引擎"></p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>新建一张表t_test_myisam，引擎使用MyISAM，查看原文件可以看到有3个文件</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155931-943cb.png" alt="MyISAM索引结构原文件"></p>
<p>可以看到索引和数据是分开的，其中索引文件仅仅保存数据记录的地址，故属于<strong>非聚簇索引</strong>。</p>
<h4 id="主键索引（Primary-Index）"><a href="#主键索引（Primary-Index）" class="headerlink" title="主键索引（Primary Index）"></a>主键索引（Primary Index）</h4><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data存放的是数据记录的地址。如下图是MyISAM主键索引的原理图。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155931-a8365.png" alt="MyISAM主键索引"></p>
<p>其中Col1为主键，可以看出看出MyISAM的索引文件仅保存数据记录的地址。</p>
<h4 id="辅助索引（Secondary-Index）"><a href="#辅助索引（Secondary-Index）" class="headerlink" title="辅助索引（Secondary Index）"></a>辅助索引（Secondary Index）</h4><p>在Col2上建立一个辅助索引，如下图辅助索引原理图。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155932-6e0c5.png" alt="MyISAM辅助索引"></p>
<p>可以看到与主键索引没有任何区别，只不过主键索引的key是唯一的，而辅助索引的key可以重复。<br><strong>MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</strong></p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>新建一张表t_test_innodb，引擎使用InnoDB，查看原文件可以看到有2个文件</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155932-cea23.png" alt="InnoDB索引结构原文件"></p>
<h4 id="主键索引（Primary-Index）-1"><a href="#主键索引（Primary-Index）-1" class="headerlink" title="主键索引（Primary Index）"></a>主键索引（Primary Index）</h4><p>InnoDB的索引和数据在一个文件当中。<br>按照B+Tree组织的一个索引结构。<br>叶节点保存了完整的数据记录和索引。这种索引就叫做<strong>聚簇索引</strong>。<br>索引的Key是数据的主键，因此InnoDB表数据文件本身就是主索引。<br>如下图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155932-35591.png" alt="InnoDB主键索引"></p>
<p>可以看到叶节点包含了完整的数据记录。<br>因为InnoDB的数据文件本身要按照主键聚集，所以InnoDB要求<strong>必须有主键</strong>。如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段rowid作为主键，这个字段长度为6个字节，类型为长整形。</p>
<h4 id="辅助索引（Secondary-Index）-1"><a href="#辅助索引（Secondary-Index）-1" class="headerlink" title="辅助索引（Secondary Index）"></a>辅助索引（Secondary Index）</h4><p>辅助索引，将途中的第二行name，作为索引如图</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155932-4d106.png" alt="InnoDB辅助索引"></p>
<p>聚簇索引这种实现方式使得按照主键的搜索十分高效，但是<strong>首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录</strong>。<br>由于InnoDB索引的实现特性，推荐使用整形的自增主键。<br>有三点好处：</p>
<ol>
<li>自增key一般为int等整数型，key比较紧凑，这样m可以非常大，而且索引占用空间小。最极端的例子，如果使用50B的varchar（包括长度），那么<code>m = 4 * 1024 / 54m = 75.85 ~= 76</code>，深度最大<code>log(76/2)(10^7) = 4.43 ~= 5</code>，再加上cache缺失、字符串比较的成本，时间成本增加较大。同时，key由4B增长到50B，整棵索引树的空间占用增长也是极为恐怖的（如果二级索引使用主键定位数据行，则空间增长更加严重）。</li>
<li>MySQL索引底层的数据比较都是整数型比较，如果主键时字符串类型的，里面还有英文，还得转换ASCII码进行比较。所以不建议使用uuid作为主键。</li>
<li>自增的主键使得数据行的插入比如落到索引数的最右侧，发生节点分裂的频率较低。<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cs.usfca.edu%2F~galles%2Fvisualization%2FBPlusTree.html">B+Tree</a>实际操作插入过程。如果不是非单调主键，插入过程很大程度会发生节点重排，不利于索引优化的初衷。</li>
</ol>
<h3 id="InnoDB索引和MyISAM索引的区别"><a href="#InnoDB索引和MyISAM索引的区别" class="headerlink" title="InnoDB索引和MyISAM索引的区别"></a>InnoDB索引和MyISAM索引的区别</h3><p>一是主索引的区别：InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。<br>二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。</p>
<h2 id="四、覆盖索引"><a href="#四、覆盖索引" class="headerlink" title="四、覆盖索引"></a>四、覆盖索引</h2><p>InnoDB存储引擎支持覆盖索引，即从辅助索引中就可以得到查询的记录，不需要查询聚簇索引中的记录了。可以减少大量的IO操作。<br>如果要查询辅助索引中不含有的字段，得先遍历辅助索引，再遍历聚集索引，而如果要查询的字段值在辅助索引上就有，就不用再查聚集索引了，这显然会减少IO操作。</p>
<h2 id="五、联合索引"><a href="#五、联合索引" class="headerlink" title="五、联合索引"></a>五、联合索引</h2><p>两个或以上的列上的索引。如下图联合索引的原理图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155933-ebb18.png" alt="联合索引原理图"></p>
<p>上图中的联合索引有三个，从上到下，严格按照排序。</p>
<h2 id="六、优化建议"><a href="#六、优化建议" class="headerlink" title="六、优化建议"></a>六、优化建议</h2><h3 id="最左前缀匹配"><a href="#最左前缀匹配" class="headerlink" title="最左前缀匹配"></a>最左前缀匹配</h3><p>索引可以简单如一个列(a)，也可以复杂如多个列(a, b, c, d)，即<code>联合索引</code>。如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否存在（相等），遇到范围查询(&gt;、&lt;、between、like左匹配)等就不能进一步匹配了，后续退化为线性查找。因此，列的排列顺序决定了可命中索引的列数。<br>如有索引(a, b, c, d)，查询条件<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>，则会在每个节点依次命中a、b、c，无法命中d。也就是最左前缀匹配原则。</p>
<h3 id="、in自动优化顺序"><a href="#、in自动优化顺序" class="headerlink" title="=、in自动优化顺序"></a>=、in自动优化顺序</h3><p>不需要考虑=、in等的顺序，mysql会自动优化这些条件的顺序，以匹配尽可能多的索引列。<br>如有索引(a, b, c, d)，查询条件<code>c &gt; 3 and b = 2 and a = 1 and d &lt; 4</code>与<code>a = 1 and c &gt; 3 and b = 2 and d &lt; 4</code>等顺序都是可以的，MySQL会自动优化为<code>a = 1 and b = 2 and c &gt; 3 and d &lt; 4</code>，依次命中a、b、c。</p>
<h3 id="索引列不能参与计算"><a href="#索引列不能参与计算" class="headerlink" title="索引列不能参与计算"></a>索引列不能参与计算</h3><p>有索引列参与计算的查询条件对索引不友好（甚至无法使用索引），如<code>from_unixtime(create_time) = &#39;2014-05-29&#39;</code>。<br>原因很简单，如何在节点中查找到对应key？如果线性扫描，则每次都需要重新计算，成本太高；如果二分查找，则需要针对from_unixtime方法确定大小关系。<br>因此，索引列不能参与计算。上述<code>from_unixtime(create_time) = &#39;2014-05-29&#39;</code>语句应该写成<code>create_time = unix_timestamp(&#39;2014-05-29&#39;)</code>。</p>
<h3 id="能扩展就不要新建索引"><a href="#能扩展就不要新建索引" class="headerlink" title="能扩展就不要新建索引"></a>能扩展就不要新建索引</h3><p>如果已有索引(a)，想建立索引(a, b)，尽量选择修改索引(a)为索引(a, b)。<br>新建索引的成本很容易理解。而基于索引(a)修改为索引(a, b)的话，MySQL可以直接在索引a的B+树上，经过分裂、合并等修改为索引(a, b)。</p>
<h3 id="不需要建立前缀有包含关系的索引"><a href="#不需要建立前缀有包含关系的索引" class="headerlink" title="不需要建立前缀有包含关系的索引"></a>不需要建立前缀有包含关系的索引</h3><p>如果已有索引(a, b)，则不需要再建立索引(a)，但是如果有必要，则仍然需考虑建立索引(b)。</p>
<blockquote>
<p>作者：鸟不拉屎</p>
<p>来源：<a href="https://juejin.im/post/5d63348ae51d453b1e478ae3" target="_blank" rel="noopener">https://juejin.im/post/5d63348ae51d453b1e478ae3</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>理解JVM虚拟机</title>
    <url>/2019/12/26/%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="一-JVM内存区域的划分"><a href="#一-JVM内存区域的划分" class="headerlink" title="一. JVM内存区域的划分"></a>一. JVM内存区域的划分</h2><h3 id="1-1-java虚拟机运行时数据区"><a href="#1-1-java虚拟机运行时数据区" class="headerlink" title="1.1 java虚拟机运行时数据区"></a>1.1 java虚拟机运行时数据区</h3><p><strong>java虚拟机运行时数据区分布图：</strong></p>
<p><img src="http://image.winrains.cn/2019/08/20190829183219-8c64b.png" alt="img"></p>
<a id="more"></a>

<ul>
<li><strong>JVM栈（Java Virtual Machine Stacks）：</strong> Java中一个线程就会相应有一个线程栈与之对应，因为不同的线程执行逻辑有所不同，因此需要一个独立的线程栈，因此栈存储的信息都是跟当前线程（或程序）相关信息的，包括<strong>局部变量</strong>、<strong>程序运行状态</strong>、<strong>方法返回值</strong>、<strong>方法出口</strong>等等。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
<li><strong>堆（Heap）：</strong> 堆是所有线程共享的，主要是存放对象实例和数组。处于<strong>物理上不连续</strong>的内存空间，只要<strong>逻辑连续</strong>即可</li>
<li><strong>方法区（Method Area）：</strong> 属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</li>
<li><strong>常量池（Runtime Constant Pool）：</strong> 它是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。</li>
<li><strong>本地方法栈（Native Method Stacks）：</strong></li>
</ul>
<p>其中，<strong>堆(Heap)和JVM栈</strong>是<strong>程序运行的关键</strong>,因为：</p>
<ol>
<li>栈是运行时的单位（解决程序的运行问题，即程序如何执行，或者说如何处理数据），而堆是存储的单位（解决的是数据存储的问题，即数据怎么放、放在哪儿）。</li>
<li>堆存储的是对象。栈存储的是基本数据类型和堆中对象的引用；（参数传递的值传递和引用传递）</li>
</ol>
<p><strong>那为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？</strong></p>
<ol>
<li>从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据，分工明确，处理逻辑更为清晰体现了“分而治之”以及“隔离”的思想。</li>
<li>堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这样共享的方式有很多收益：提供了一种有效的数据交互方式(如：共享内存)；堆中的共享常量和缓存可以被所有栈访问，节省了空间。</li>
<li>栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。</li>
<li>堆和栈的结合完美体现了面向对象的设计。当我们将对象拆开，你会发现，对象的属性即是数据，存放在堆中；而对象的行为（方法）即是运行逻辑，放在栈中。因此编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。</li>
</ol>
<h3 id="1-2-堆-Heap-和JVM栈："><a href="#1-2-堆-Heap-和JVM栈：" class="headerlink" title="1.2 堆(Heap)和JVM栈："></a>1.2 堆(Heap)和JVM栈：</h3><h4 id="1-2-1-堆-Heap"><a href="#1-2-1-堆-Heap" class="headerlink" title="1.2.1 堆(Heap)"></a>1.2.1 堆(Heap)</h4><p><strong>Java堆</strong>是java虚拟机所管理内存中<strong>最大的一块内存空间</strong>，处于<strong>物理上不连续</strong>的内存空间，只要<strong>逻辑连续</strong>即可，主要用于存放各种类的实例对象。该区域被所有线程共享，在虚拟机启动时创建，用来存放对象的实例，几乎所有的对象以及数组都在这里分配内存（栈上分配、标量替换优化技术的例外）。<br>在 Java 中，堆被划分成两个不同的区域：<strong>新生代 ( Young )</strong>、<strong>老年代 ( Old )</strong>。<strong>新生代 ( Young )</strong> 又被划分为三个区域：<strong>Eden</strong>、<strong>From Survivor(S0)</strong>、<strong>To Survivor(S1)</strong>。如图所示：<br><strong>堆的内存布局:</strong></p>
<p><img src="http://image.winrains.cn/2019/08/20190829183221-9ca8c.png" alt="img"></p>
<p>这样划分的目的是为了使jvm能够更好的管理内存中的对象，包括内存的分配以及回收。 而新生代按eden和两个survivor的分法，是为了</p>
<ul>
<li>有效空间增大，eden+1个survivor；</li>
<li>有利于对象代的计算，当一个对象在S0/S1中达到设置的XX:MaxTenuringThreshold值后，会将其挪到老年代中，即只需扫描其中一个survivor。如果没有S0/S1,直接分成两个区，该如何计算对象经过了多少次GC还没被释放。</li>
<li>两个Survivor区可解决内存碎片化</li>
</ul>
<h4 id="1-2-2-堆栈相关的参数"><a href="#1-2-2-堆栈相关的参数" class="headerlink" title="1.2.2 堆栈相关的参数"></a>1.2.2 堆栈相关的参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms</td>
<td>堆内存初始大小，单位m、g</td>
</tr>
<tr>
<td>-Xmx</td>
<td>堆内存最大允许大小，一般不要大于物理内存的80%</td>
</tr>
<tr>
<td>-Xmn</td>
<td>年轻代内存初始大小</td>
</tr>
<tr>
<td>-Xss</td>
<td>每个线程的堆栈大小，即JVM栈的大小</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>年轻代(包括Eden和两个Survivor区)与年老代的比值</td>
</tr>
<tr>
<td>-XX:NewSzie(-Xns)</td>
<td>年轻代内存初始大小,可以缩写-Xns</td>
</tr>
<tr>
<td>-XX:MaxNewSize(-Xmx)</td>
<td>年轻代内存最大允许大小，可以缩写-Xmx</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>年轻代中Eden区与Survivor区的容量比例值，默认为8，即8:1</td>
</tr>
<tr>
<td>-XX:MinHeapFreeRatio</td>
<td>GC后，如果发现空闲堆内存占到整个预估堆内存的40%，则放大堆内存的预估最大值，但不超过固定最大值。</td>
</tr>
<tr>
<td>-XX:MaxHeapFreeRatio</td>
<td>预估堆内存是堆大小动态调控的重要选项之一。堆内存预估最大值一定小于或等于固定最大值(-Xmx指定的数值)。前者会根据使用情况动态调大或缩小，以提高GC回收的效率，默认70%</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>垃圾最大年龄，设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代。对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率</td>
</tr>
<tr>
<td>-XX:InitialTenuringThreshold</td>
<td>可以设定老年代阀值的初始值</td>
</tr>
<tr>
<td>-XX:+PrintTenuringDistribution</td>
<td>查看每次minor GC后新的存活周期的阈值</td>
</tr>
</tbody></table>
<p><strong>Note：</strong> 每次GC 后会调整堆的大小，为了<strong>防止动态调整带来的性能损耗</strong>，一般设置-<strong>Xms、-Xmx 相等</strong>。<br>新生代的三个设置参数：-Xmn，-XX:NewSize，-XX:NewRatio的优先级：<br>（1）.最高优先级： -XX:NewSize=1024m和-XX:MaxNewSize=1024m<br>（2）.次高优先级： -Xmn1024m （默认等效效果是：-XX:NewSize==-XX:MaxNewSize==1024m）<br>（3）.最低优先级：-XX:NewRatio=2<br>推荐使用的是-Xmn参数，原因是这个参数很简洁，相当于一次性设定NewSize和MaxNewSIze，而且两者相等。</p>
<h3 id="1-3-jvm对象"><a href="#1-3-jvm对象" class="headerlink" title="1.3 jvm对象"></a>1.3 jvm对象</h3><h4 id="1-3-1-创建对象的方式"><a href="#1-3-1-创建对象的方式" class="headerlink" title="1.3.1 创建对象的方式"></a>1.3.1 创建对象的方式</h4><p><img src="http://image.winrains.cn/2019/08/20190829183222-b1608.png" alt="img"></p>
<p>各个方式的实质操作如下：</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>实质</th>
</tr>
</thead>
<tbody><tr>
<td>使用new关键</td>
<td>调用无参或有参构造器函数创建</td>
</tr>
<tr>
<td>使用Class的newInstance方法</td>
<td>调用无参或有参构造器函数创建，且需要是public的构造函数</td>
</tr>
<tr>
<td>使用Constructor类的newInstance方法</td>
<td>调用有参和私有private构造器函数创建，实用性更广</td>
</tr>
<tr>
<td>使用Clone方法</td>
<td>不调用任何参构造器函数，且对象需要实现Cloneable接口并实现其定义的clone方法，且默认为浅复制</td>
</tr>
<tr>
<td>第三方库Objenesis</td>
<td>利用了asm字节码技术，动态生成Constructor对象</td>
</tr>
</tbody></table>
<h4 id="1-3-2-jvm对象分配"><a href="#1-3-2-jvm对象分配" class="headerlink" title="1.3.2 jvm对象分配"></a>1.3.2 jvm对象分配</h4><p>在虚拟机层面上创建对象的步骤：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829183222-54375.png" alt="img"></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>解析</th>
</tr>
</thead>
<tbody><tr>
<td>1、判断对象对应的类是否加载、链接、初始化</td>
<td>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。如果没有，那么必须先执行类的加载、解释、初始化（类的clinit方法）。</td>
</tr>
<tr>
<td>2、为对象分配内存</td>
<td>类加载检查通过后，虚拟机为新生对象分配内存。对象所需内存大小在类加载完成后便可以完全确定，为对象分配空间无非就是从Java堆中划分出一块确定大小的内存而已。</td>
</tr>
<tr>
<td>3、处理并发安全问题</td>
<td>另外一个问题及时保证new对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发问题。 虚拟机采用了两种方式解决并发问题: （1）CAS配上失败重试的方式保证指针更新操作的原子性; （2）TLAB 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区，（TLAB ，Thread Local Allocation Buffer）虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。</td>
</tr>
<tr>
<td>4、初始化分配到的空间</td>
<td>内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值</td>
</tr>
<tr>
<td>5、设置对象的对象头</td>
<td>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC分代年龄等数据存储在对象的对象头中</td>
</tr>
<tr>
<td>6、执行init方法进行初始化</td>
<td>在Java程序的视角看来，初始化才正式开始，开始调用方法完成初始赋值和构造函数，所有的字段都为零值。因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执 行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。</td>
</tr>
</tbody></table>
<h4 id="1-3-3-对象分配内存方式"><a href="#1-3-3-对象分配内存方式" class="headerlink" title="1.3.3 对象分配内存方式"></a>1.3.3 对象分配内存方式</h4><p><strong>分配对象内存</strong>，<strong>有两种分配方式</strong>，<strong>指针碰撞</strong>和<strong>空闲列表</strong>：<br>（1）如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Pointer）来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。 如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。 一般使用带有compact（整理）过程的收集器时，使用指针碰撞。<br>（2）如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为“空闲列表（Free List）”。<br><strong>Note：</strong> 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<h4 id="1-3-4-那什么样的对象能够进入老年代-Old"><a href="#1-3-4-那什么样的对象能够进入老年代-Old" class="headerlink" title="1.3.4 那什么样的对象能够进入老年代(Old)"></a>1.3.4 那什么样的对象能够进入老年代(Old)</h4><p><strong>那什么样的对象能够进入老年代(Old)？</strong></p>
<p><img src="http://image.winrains.cn/2019/08/20190829183223-9dcb9.png" alt="img"></p>
<h3 id="1-4-内存分配与回收策略"><a href="#1-4-内存分配与回收策略" class="headerlink" title="1.4 内存分配与回收策略"></a>1.4 内存分配与回收策略</h3><table>
<thead>
<tr>
<th>情况</th>
<th>解析</th>
</tr>
</thead>
<tbody><tr>
<td>1.对象优先在Eden分配</td>
<td>大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC；虚拟机提供了-XX:PrintGCDetails参数，发生垃圾回收时打印内存回收日志，并且在进程退出时输出当前内存各区域的分配情况。</td>
</tr>
<tr>
<td>2.大对象直接进入老年代</td>
<td>所谓的大对象就是指，需要大量连续内存空间的java对象，最典型的大对象就是那种很长的字符串及数组。虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值得对象直接在老年代中分配（这样做的目的是避免在Eden区及两个Survivor之间发生大量的内存拷贝）</td>
</tr>
<tr>
<td>3.长期存活的对象将直接进入老年代</td>
<td>对象年龄计数器。-XX:MaxTenuringThreshold</td>
</tr>
<tr>
<td>4、动态对象年龄判定</td>
<td>虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。</td>
</tr>
<tr>
<td>5、空间分配担保</td>
<td>在发生Minor GC时（前），虚拟机会检测之前每次晋升到老年代的平均大小（因为当次会有多少对象会存活是无法确定的，所以取之前的平均值/经验值）是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于，则查看HandlePromotionFailure设置是否允许担保失败；如果允许，那只会进行Minor GC；如果不允许，则也要改为进行一次Full GC。取平均值进行比较其实仍然是一种动态概率手段，也就是说如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure），这样会触发Full GC。</td>
</tr>
</tbody></table>
<h2 id="二-垃圾回收算法分类"><a href="#二-垃圾回收算法分类" class="headerlink" title="二 垃圾回收算法分类"></a>二 垃圾回收算法分类</h2><h3 id="2-1-引用"><a href="#2-1-引用" class="headerlink" title="2.1 引用"></a>2.1 引用</h3><p><img src="http://image.winrains.cn/2019/08/20190829183224-a964f.png" alt="img"></p>
<h3 id="2-2-GC-Root的对象"><a href="#2-2-GC-Root的对象" class="headerlink" title="2.2 GC Root的对象"></a>2.2 GC Root的对象</h3><p><img src="http://image.winrains.cn/2019/08/20190829183225-a0343.png" alt="img"></p>
<h3 id="2-3-标记-清除（Mark—Sweep）"><a href="#2-3-标记-清除（Mark—Sweep）" class="headerlink" title="2.3 标记-清除（Mark—Sweep）"></a>2.3 标记-清除（Mark—Sweep）</h3><p>被誉为现代垃圾回收算法的思想基础。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829183225-8ae9d.png" alt="img"></p>
<p><strong>标记-清除算法</strong>采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。</p>
<h3 id="2-4-复制算法（Copying）"><a href="#2-4-复制算法（Copying）" class="headerlink" title="2.4 复制算法（Copying）"></a>2.4 复制算法（Copying）</h3><p>该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。建立在存活对象少，垃圾对象多的前提下。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去后还能进行相应的内存整理，不会出现碎片问题。但缺点也是很明显，就是需要两倍内存空间。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829183226-687ca.png" alt="img"></p>
<p>它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象面和空闲区域面，在对象面与空闲区域面的切换过程中，程序暂停执行。</p>
<h3 id="2-5-标记-整理（或标记-压缩算法，Mark-Compact，又或者叫标记清除压缩MarkSweepCompact）"><a href="#2-5-标记-整理（或标记-压缩算法，Mark-Compact，又或者叫标记清除压缩MarkSweepCompact）" class="headerlink" title="2.5 标记-整理（或标记-压缩算法，Mark-Compact，又或者叫标记清除压缩MarkSweepCompact）"></a>2.5 标记-整理（或标记-压缩算法，Mark-Compact，又或者叫标记清除压缩MarkSweepCompact）</h3><p>此算法是结合了“标记-清除”和“复制算法”两个算法的优点。避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829183226-4c3a5.png" alt="img"></p>
<p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。</p>
<h3 id="2-6-分代回收策略（Generational-Collecting）"><a href="#2-6-分代回收策略（Generational-Collecting）" class="headerlink" title="2.6 分代回收策略（Generational Collecting）"></a>2.6 分代回收策略（Generational Collecting）</h3><p>基于这样的事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。<br>新生代由于其对象存活时间短，且需要经常gc，因此采用效率较高的复制算法，其将内存区分为一个eden区和两个suvivor区，默认eden区和survivor区的比例是8:1，分配内存时先分配eden区，当eden区满时，使用复制算法进行gc，将存活对象复制到一个survivor区，当一个survivor区满时，将其存活对象复制到另一个区中，当对象存活时间大于某一阈值时，将其放入老年代。老年代和永久代因为其存活对象时间长，因此使用标记清除或标记整理算法<br><strong>总结：</strong></p>
<ul>
<li>新生代：复制算法（新生代回收的频率很高，每次回收的耗时很短，为了支持高频率的新生代回收，虚拟机可能使用一种叫做卡表（Card Table）的数据结构，卡表为一个比特位集合，每个比特位可以用来表示老年代的某一区域中的所有对象是否持有新生代对,</li>
</ul>
<h3 id="2-7-垃圾回收器"><a href="#2-7-垃圾回收器" class="headerlink" title="2.7 垃圾回收器"></a>2.7 垃圾回收器</h3><p><img src="http://image.winrains.cn/2019/08/20190829183227-3e6e1.png" alt="img"></p>
<p><strong>垃圾回收器</strong>的任务是识别和回收垃圾对象进行内存清理，不同代可使用不同的收集器：</p>
<ul>
<li><strong>新生代收集器</strong>使用的收集器：<strong>Serial、ParNew、Parallel Scavenge</strong>；</li>
<li><strong>老年代收集器</strong>使用的收集器：<strong>Serial Old（MSC）、Parallel Old、CMS。</strong></li>
</ul>
<p><strong>总结：</strong></p>
<ol>
<li><strong>Serial old和新生代的所有回收器都能搭配；也可以作为CMS回收器的备用回收器；</strong></li>
<li><strong>CMS只能和新生代的Serial和ParNew搭配，而且ParNew是CMS默认的新生代回收器；</strong></li>
<li><strong>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态</strong></li>
<li><strong>并发（Concurrent）：指用户线程和垃圾收集线程同时执行（但不一定是并行的，可能是交替执行），用户程序继续运行，而垃圾收集程序运行在另外的CPU上。</strong></li>
</ol>
<h2 id="三-GC的执行机制"><a href="#三-GC的执行机制" class="headerlink" title="三. GC的执行机制"></a>三. GC的执行机制</h2><p>Java 中的<strong>堆(deap)</strong> 也是 GC 收集垃圾的主要区域。 由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：<strong>Scavenge GC（Minor GC）和Full GC（Major GC）</strong>。</p>
<ul>
<li><strong>Scavenge GC(Minor GC):</strong> 一般情况下，当新对象生成（age=0），并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区（age+1）。然后整理（其实是复制过去就顺便整理了）Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法（即复制-清理算法），使Eden去能尽快空闲出来。Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。</li>
<li><strong>Full GC:</strong> 对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。</li>
</ul>
<h3 id="3-1-触发Full-GC执行的场景"><a href="#3-1-触发Full-GC执行的场景" class="headerlink" title="3.1 触发Full GC执行的场景"></a>3.1 触发Full GC执行的场景</h3><p><img src="http://image.winrains.cn/2019/08/20190829183228-85964.png" alt="img"></p>
<h3 id="3-2-Young-GC触发条件"><a href="#3-2-Young-GC触发条件" class="headerlink" title="3.2 Young GC触发条件"></a>3.2 Young GC触发条件</h3><p><img src="http://image.winrains.cn/2019/08/20190829183229-c67c1.png" alt="img"></p>
<h3 id="3-3-新生对象GC收回流程"><a href="#3-3-新生对象GC收回流程" class="headerlink" title="3.3 新生对象GC收回流程"></a>3.3 新生对象GC收回流程</h3><p>基于大多数新生对象都会在GC中被收回的假设。新生代的GC 使用复制算法，（将年轻代分为3部分，主要是为了生命周期短的对象尽量留在年轻代。老年代主要存放生命周期比较长的对象，比如缓存）。可能经历过程：</p>
<ol>
<li><strong>对象创建时，一般在Eden区完成内存分配（有特殊）；</strong></li>
<li><strong>当Eden区满了，再创建对象，会因为申请不到空间，触发minorGC，进行young(eden+1survivor)区的垃圾回收；</strong></li>
<li><strong>minorGC时，Eden和survivor A不能被GC回收且年龄没有达到阈值（tenuring threshold）的对象，会被放入survivor B，始终保证一个survivor是空的；</strong></li>
<li><strong>当做第3步的时候，如果发现survivor满了，将这些对象copy到old区（分配担保机制）；或者survivor并没有满，但是有些对象已经足够Old，也被放入Old区 XX:MaxTenuringThreshold；（回顾下对象进入老年代的情况）</strong></li>
<li><strong>直接清空eden和survivor A；</strong></li>
<li><strong>当Old区被放满的之后，进行fullGC。</strong></li>
</ol>
<h3 id="3-4-GC日志"><a href="#3-4-GC日志" class="headerlink" title="3.4 GC日志"></a>3.4 GC日志</h3><p><strong>GC日志相关参数:</strong></p>
<ul>
<li>-XX:+PrintGC：输出GC日志</li>
<li>-XX:+PrintGCDetails：输出GC的详细日志</li>
<li>-XX:+PrintGCTimeStamps：输出GC的时间戳（以基准时间的形式）</li>
<li>-XX:+PrintGCApplicationStoppedTime：打印垃圾回收期间程序暂停的时间</li>
<li>-XX:+PrintGCApplicationConcurrentTime：打印每次垃圾回收前，程序未中断的执行时间</li>
<li>-XX:+PrintHeapAtGC：在进行GC的前后打印出堆的信息</li>
<li>-XX:+PrintTLAB：查看TLAB空间的使用情况</li>
<li>-XX:PrintTenuingDistribution：查看每次minor GC后新的存活周期的阈值</li>
<li>-XX:PrintReferenceFC：用来跟踪系统内的(softReference)软引用，(weadReference)弱引用,(phantomReference)虚引用，显示引用过程</li>
</ul>
<p>案例分析：-XX:+PrintGCApplicationStoppedTime -XX:+PrintGCApplicationConcurrentTime一起使用</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Application <span class="built_in">time</span>: <span class="number">0.3440086</span> <span class="built_in">seconds</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which application threads were stopped: <span class="number">0.0620105</span> <span class="built_in">seconds</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Application <span class="built_in">time</span>: <span class="number">0.2100691</span> <span class="built_in">seconds</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which application threads were stopped: <span class="number">0.0890223</span> <span class="built_in">seconds</span></span></pre></td></tr></table></figure>

<p>得知应用程序在前344毫秒中是在处理实际工作的，然后将所有线程暂停了62毫秒，紧接着又工作了210ms，然后又暂停了89ms。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2796146</span>K-&gt;<span class="number">2049</span>K(<span class="number">1784832</span>K)] <span class="number">4171400</span>K-&gt;<span class="number">2049</span>K(<span class="number">3171840</span>K), [Metaspace: <span class="number">3134</span>K-&gt;<span class="number">3134</span>K(<span class="number">1056768</span>K)], <span class="number">0.0571841</span> secs] [Times: user=<span class="number">0.02</span> sys=<span class="number">0.04</span>, real=<span class="number">0.06</span> secs]</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total time <span class="keyword">for</span> which application threads were stopped: <span class="number">0.0572646</span> seconds, Stopping threads took: <span class="number">0.0000088</span> seconds</span></pre></td></tr></table></figure>

<p>应用线程被强制暂停了57ms来进行垃圾回收。其中又有8ms是用来等待所有的应用线程都到达安全点。<br>只要设置-XX:+PrintGCDetails 就会自动带上-verbose:gc和-XX:+PrintGC</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">33.125</span>: [GC [DefNew: <span class="number">3324</span>K-&gt;<span class="number">152</span>K(<span class="number">3712</span>K), <span class="number">0.0025925</span> secs] <span class="number">3324</span>K-&gt;<span class="number">152</span>K(<span class="number">11904</span>K), <span class="number">0.0031680</span> secs]</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">100.667</span>: [Full GC [Tenured: <span class="number">0</span>K-&gt;<span class="number">210</span>K(<span class="number">10240</span>K), <span class="number">0.0149142</span> secs] <span class="number">4603</span>K-&gt;<span class="number">210</span>K(<span class="number">19456</span>K), [Perm : <span class="number">2999</span>K-&gt;<span class="number">2999</span>K(<span class="number">21248</span>K)], <span class="number">0.0150007</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs]</span></pre></td></tr></table></figure>

<ol>
<li>最前面的数字“33.125：”和“100.667：”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。</li>
<li>GC日志开头的“［GC”和“［Full GC”说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有“Full”，说明这次GC是发生了Stop-The-World的。</li>
<li>接下来的“［DefNew”、“［Tenured”、“［Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的，例如上面样例所使用的Serial收集器中的新生代名为“Default New Generation”，所以显示的是“［DefNew”。如果是ParNew收集器，新生代名称就会变为“［ParNew”，意为“Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代称为“PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。</li>
<li>后面方括号内部的“3324K-&gt;152K(3712K)”含义是“GC前该内存区域已使用容量-&gt; GC后该内存区域已使用容量 (该内存区域总容量)”。而在方括号之外的“3324K-&gt;152K(11904K)”表示“GC前Java堆已使用容量 -&gt; GC后Java堆已使用容量 (Java堆总容量)”。</li>
<li>再往后，“0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据</li>
<li>[Full GC 283.736: [ParNew: 261599K-&gt;261599K(261952K), 0.0000288 secs] 新生代收集器ParNew的日志也会出现“［Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc()方法所触发的收集，那么在这里将显示“［Full GC (System)”。</li>
</ol>
<h3 id="3-5-减少GC开销的措施"><a href="#3-5-减少GC开销的措施" class="headerlink" title="3.5 减少GC开销的措施"></a>3.5 减少GC开销的措施</h3><p>从代码上：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829183230-18b22.png" alt="img"></p>
<p>从JVM参数上调优上：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829183231-7f999.png" alt="img"></p>
<h3 id="3-6-内存溢出分类"><a href="#3-6-内存溢出分类" class="headerlink" title="3.6 内存溢出分类"></a>3.6 内存溢出分类</h3><p><img src="http://image.winrains.cn/2019/08/20190829183232-a9393.png" alt="img"></p>
<h2 id="四-总结-JVM调优相关"><a href="#四-总结-JVM调优相关" class="headerlink" title="四. 总结-JVM调优相关"></a>四. 总结-JVM调优相关</h2><h3 id="4-1-调优目的"><a href="#4-1-调优目的" class="headerlink" title="4.1 调优目的"></a>4.1 调优目的</h3><p><img src="http://image.winrains.cn/2019/08/20190829183233-1dbfb.png" alt="img"></p>
<h3 id="4-2-JVM性能调优所处的层次"><a href="#4-2-JVM性能调优所处的层次" class="headerlink" title="4.2 JVM性能调优所处的层次"></a>4.2 JVM性能调优所处的层次</h3><p><img src="http://image.winrains.cn/2019/08/20190829183233-87064.png" alt="img"></p>
<h3 id="4-3-JVM调优流程"><a href="#4-3-JVM调优流程" class="headerlink" title="4.3 JVM调优流程"></a>4.3 JVM调优流程</h3><p><img src="http://image.winrains.cn/2019/08/20190829183234-4caaa.png" alt="img"></p>
<h3 id="4-4-性能监控工具"><a href="#4-4-性能监控工具" class="headerlink" title="4.4 性能监控工具"></a>4.4 性能监控工具</h3><p><img src="http://image.winrains.cn/2019/08/20190829183234-b5031.png" alt="img"></p>
<p>调优的最终目的都是为了令应用程序使用最小的硬件消耗来承载更大的吞吐。jvm的调优也不例外，jvm调优主要是针对垃圾收集器的收集性能优化，令运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量。</p>
<blockquote>
<p>作者：Ccww</p>
<p>来源：<a href="https://juejin.im/post/5d200b54f265da1bac40384a" target="_blank" rel="noopener">https://juejin.im/post/5d200b54f265da1bac40384a</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>小而美的Shiro安全框架</title>
    <url>/2019/12/26/%E5%B0%8F%E8%80%8C%E7%BE%8E%E7%9A%84Shiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在一款应用的整个生命周期，我们都会谈及该应用的数据安全问题。用户的合法性与数据的可见性是数据安全中非常重要的一部分。但是，一方面，不同的应用对于数据的合法性和可见性要求的维度与粒度都有所区别；另一方面，以当前微服务、多服务的架构方式，如何共享Session，如何缓存认证和授权数据应对高并发访问都迫切需要我们解决。Shiro的出现让我们可以快速和简单的应对我们应用的数据安全问题。</p>
<a id="more"></a>

<h2 id="Shiro介绍"><a href="#Shiro介绍" class="headerlink" title="Shiro介绍"></a>Shiro介绍</h2><h3 id="Shiro简介"><a href="#Shiro简介" class="headerlink" title="Shiro简介"></a>Shiro简介</h3><p>这个官网解释不抽象，所以直接用官网解释：Apache Shiro™是一个强大且易用的 Java 安全框架，可以执行身份验证、授权、加密和会话管理等。基于 Shiro 的易于理解的API，您可以快速、轻松地使任何应用程序变得安全（从最小的移动应用到最大的网络和企业应用）。<br>谈及安全，多数 Java 开发人员都离不开 Spring 框架的支持，自然也就会先想到 Spring Security，那我们先来看二者的差别</p>
<table>
<thead>
<tr>
<th>Shiro</th>
<th>Spring Security</th>
</tr>
</thead>
<tbody><tr>
<td>简单、灵活</td>
<td>复杂、笨重</td>
</tr>
<tr>
<td>可脱离Spring</td>
<td>不可脱离Spring</td>
</tr>
<tr>
<td>粒度较粗</td>
<td>粒度较细</td>
</tr>
</tbody></table>
<p>虽然 Spring Security 属于名震中外 Spring 家族的一部分，但是了解 Shiro 之后，你不会想 “嫁入豪门”，而是选择追求「诗和远方」冲动。<br>横看成岭侧成峰，远近高低各不同 (依旧是先了解概念就好)</p>
<h3 id="远看-Shiro-看轮廓"><a href="#远看-Shiro-看轮廓" class="headerlink" title="远看 Shiro 看轮廓"></a>远看 Shiro 看轮廓</h3><p><img src="http://image.winrains.cn/2019/08/20190829192223-d2934.png" alt="img"></p>
<h4 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h4><p>它是一个主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者</p>
<h4 id="SecurityManager"><a href="#SecurityManager" class="headerlink" title="SecurityManager"></a>SecurityManager</h4><p>安全管理器；即所有与安全有关的操作都会与 SecurityManager 交互；且它管理着所有 Subject；可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet前端控制器</p>
<h4 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h4><p>域，Shiro 从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。</p>
<h3 id="近看-Shiro-看细节"><a href="#近看-Shiro-看细节" class="headerlink" title="近看 Shiro 看细节"></a>近看 Shiro 看细节</h3><p>看图瞬间懵逼？别慌，会为你拆解来看，结合着图看下面的解释，这不是啥大问题，且看:</p>
<p><img src="http://image.winrains.cn/2019/08/20190829192224-bcb0d.png" alt="img"></p>
<h4 id="Subject-1"><a href="#Subject-1" class="headerlink" title="Subject"></a>Subject</h4><p>主体，可以看到主体可以是任何可以与应用交互的 “用户”</p>
<h4 id="SecurityManager-1"><a href="#SecurityManager-1" class="headerlink" title="SecurityManager"></a>SecurityManager</h4><p>相当于 SpringMVC 中的 DispatcherServlet；是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理</p>
<h4 id="Authenticator"><a href="#Authenticator" class="headerlink" title="Authenticator"></a>Authenticator</h4><p>认证器，负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；需要自定义认证策略（Authentication Strategy），即什么情况下算用户认证通过了</p>
<h4 id="Authrizer"><a href="#Authrizer" class="headerlink" title="Authrizer"></a>Authrizer</h4><p>授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能</p>
<h4 id="Realm-1"><a href="#Realm-1" class="headerlink" title="Realm"></a>Realm</h4><p>可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC实现，也可以是LDAP实现，或者内存实现等等；由用户提供；注意：Shiro 不知道你的用户/权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的Realm</p>
<h4 id="SessionManager"><a href="#SessionManager" class="headerlink" title="SessionManager"></a>SessionManager</h4><p>如果写过 Servlet 就应该知道 Session 的概念，Session 需要有人去管理它的生命周期，这个组件就是 SessionManager；而Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境、EJB等环境；所以，Shiro 就抽象了一个自己的Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台Web服务器；接着又上了台EJB 服务器；这时又想把两台服务器的会话数据放到一个地方，我们就可以实现自己的分布式会话（如把数据放到Memcached 服务器）</p>
<h4 id="SessionDAO"><a href="#SessionDAO" class="headerlink" title="SessionDAO"></a>SessionDAO</h4><p>DAO大家都用过，数据访问对象，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的SessionDAO，通过如JDBC写到数据库；比如想把 Session 放到 Memcached 中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能；</p>
<h4 id="CacheManager"><a href="#CacheManager" class="headerlink" title="CacheManager"></a>CacheManager</h4><p>缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能</p>
<h4 id="Cryptography"><a href="#Cryptography" class="headerlink" title="Cryptography"></a>Cryptography</h4><p>密码模块，Shiro提高了一些常见的加密组件用于如密码「加密/解密」的<br><strong>注意上图的结构，我们会根据这张图来逐步拆分讲解，记住这张图也更有助于我们理解 Shiro 的工作原理</strong>，所以依旧是打开两个网页一起看就好喽</p>
<h2 id="搭建概览"><a href="#搭建概览" class="headerlink" title="搭建概览"></a>搭建概览</h2><p>多数小伙伴都在使用 Spring Boot， Shiro 也很应景的定义了 starter，做了更好的封装，对于我们来说使用起来也就更加方便，来看选型概览</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Springboot</td>
<td>2.0.4</td>
</tr>
<tr>
<td>2</td>
<td>JPA</td>
<td>2.0.4</td>
</tr>
<tr>
<td>3</td>
<td>Mysql</td>
<td>8.0.12</td>
</tr>
<tr>
<td>4</td>
<td>Redis</td>
<td>2.0.4</td>
</tr>
<tr>
<td>5</td>
<td>Lombok</td>
<td>1.16.22</td>
</tr>
<tr>
<td>6</td>
<td>Guava</td>
<td>26.0-jre</td>
</tr>
<tr>
<td>7</td>
<td>Shiro</td>
<td>1.4.0</td>
</tr>
</tbody></table>
<p>使用 Spring Boot，大多都是通过添加 starter 依赖，会自动解决依赖包版本，所以自己尝试的时候用最新版本不会有什么问题，比如 Shiro 现在的版本是 1.5.0 了，整体问题不大，大家自行尝试就好</p>
<h3 id="添加-Gradle-依赖管理"><a href="#添加-Gradle-依赖管理" class="headerlink" title="添加 Gradle 依赖管理"></a>添加 Gradle 依赖管理</h3><p><img src="http://image.winrains.cn/2019/10/20191025224019-68039.png" alt="img"></p>
<h3 id="大体目录结构"><a href="#大体目录结构" class="headerlink" title="大体目录结构"></a>大体目录结构</h3><p><img src="http://image.winrains.cn/2019/10/20191025224022-423fe.png" alt="img"></p>
<h3 id="application-yml-配置"><a href="#application-yml-配置" class="headerlink" title="application.yml 配置"></a>application.yml 配置</h3><p><img src="http://image.winrains.cn/2019/10/20191025224023-262fc.png" alt="img"></p>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p><img src="http://image.winrains.cn/2019/10/20191025224025-d9011.png" alt="img"></p>
<p>你就让我看这？这只是一个概览，先做到心中有数，我们来看具体配置，逐步完成搭建<br>其中 shiroFilter bean 部分指定了拦截路径和相应的过滤器，”/user/login”, ”/user”, ”/user/loginout” 可以匿名访问，其他路径都需要授权访问，shiro 提供和多个默认的过滤器，我们可以用这些过滤器来配置控制指定url的权限(先了解个大概即可)：</p>
<table>
<thead>
<tr>
<th>配置缩写</th>
<th>对应的过滤器</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>anon</td>
<td>AnonymousFilter</td>
<td>指定url可以匿名访问</td>
</tr>
<tr>
<td>authc</td>
<td>FormAuthenticationFilter</td>
<td>指定url需要form表单登录，默认会从请求中获取username、password,rememberMe等参数并尝试登录，如果登录不了就会跳转到loginUrl配置的路径。我们也可以用这个过滤器做默认的登录逻辑，但是一般都是我们自己在控制器写登录逻辑的，自己写的话出错返回的信息都可以定制嘛。</td>
</tr>
<tr>
<td>authcBasic</td>
<td>BasicHttpAuthenticationFilter</td>
<td>指定url需要basic登录</td>
</tr>
<tr>
<td>Logout</td>
<td>LogoutFilter</td>
<td>登出过滤器，配置指定url就可以实现退出功能，非常方便</td>
</tr>
<tr>
<td>noSessionCreation</td>
<td>NoSessionCreationFilter</td>
<td>禁止创建会话</td>
</tr>
<tr>
<td>perms</td>
<td>PermissionsAuthorizationFilter</td>
<td>需要指定权限才能访问</td>
</tr>
<tr>
<td>port</td>
<td>PortFilter</td>
<td>需要指定端口才能访问</td>
</tr>
<tr>
<td>rest</td>
<td>HttpMethodPermissionFilter</td>
<td>将http请求方法转化成相应的动词来构造一个权限字符串，这个感觉意义不大，有兴趣自己看源码的注释</td>
</tr>
<tr>
<td>roles</td>
<td>RolesAuthorizationFilter</td>
<td>需要指定角色才能访问</td>
</tr>
<tr>
<td>ssl</td>
<td>SslFilter</td>
<td>需要https请求才能访问</td>
</tr>
<tr>
<td>user</td>
<td>UserFilter</td>
<td>需要已登录或“记住我”的用户才能访问</td>
</tr>
</tbody></table>
<h3 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h3><p>数据库表设计请参考 entity package下的 bean，通过@Entity 注解与 JPA 的设置自动生成表结构 (你需要简单的了解一下 JPA 的功能)。<br>我们要说重点啦～～～</p>
<h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><p>身份认证是一个证明 “李雷是李雷，韩梅梅是韩梅梅” 的过程，回看上图，Realm 模块就是用来做这件事的，Shiro 提供了 IniRealm，JdbcReaml，LDAPReam等认证方式，但自定义的 Realm 通常是最适合我们业务需要的，认证通常是校验登录用户是否合法。</p>
<h3 id="新建用户-User"><a href="#新建用户-User" class="headerlink" title="新建用户 User"></a>新建用户 User</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Id</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@GeneratedValue</span>(strategy=GenerationType.AUTO)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Long id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(unique =true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String username;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">String</span> <span class="selector-tag">password</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">String</span> <span class="selector-tag">salt</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="定义-Repository"><a href="#定义-Repository" class="headerlink" title="定义 Repository"></a>定义 Repository</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">@Repository</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">UserRepository</span> <span class="symbol">extends</span> <span class="symbol">JpaRepository</span>&lt;<span class="symbol">User</span>, <span class="symbol">Long</span>&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> User findUserByUsername(String username);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="编写UserController："><a href="#编写UserController：" class="headerlink" title="编写UserController："></a>编写UserController：</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@<span class="constructor">GetMapping(<span class="string">"/login"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public void login(String username, String password) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UsernamePasswordToken token = <span class="keyword">new</span> <span class="constructor">UsernamePasswordToken(<span class="params">username</span>, <span class="params">password</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    token.set<span class="constructor">RememberMe(<span class="params">true</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Subject currentUser = <span class="module-access"><span class="module"><span class="identifier">SecurityUtils</span>.</span></span>get<span class="constructor">Subject()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    currentUser.login(token);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="自定义-Realm"><a href="#自定义-Realm" class="headerlink" title="自定义 Realm"></a>自定义 Realm</h3><p>自定义 Realm，主要是为了重写 doGetAuthenticationInfo(…)方法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">protected AuthenticationInfo <span class="keyword">do</span><span class="constructor">GetAuthenticationInfo(AuthenticationToken <span class="params">authenticationToken</span>)</span> throws AuthenticationException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    String username = token.get<span class="constructor">Username()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    User user = userRepository.find<span class="constructor">UserByUsername(<span class="params">username</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    SimpleAuthenticationInfo simpleAuthenticationInfo = <span class="keyword">new</span> <span class="constructor">SimpleAuthenticationInfo(<span class="params">user</span>, <span class="params">user</span>.<span class="params">getPassword</span>()</span>, get<span class="constructor">Name()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    simpleAuthenticationInfo.set<span class="constructor">CredentialsSalt(ByteSource.Util.<span class="params">bytes</span>(<span class="params">user</span>.<span class="params">getSalt</span>()</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return simpleAuthenticationInfo;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这些代码我需要做一个说明，你可能也满肚子疑惑:</p>
<ol>
<li>这段代码怎么应用了 shiro？</li>
<li>controller 是怎么调用到 custom realm 的？</li>
<li>重写的 doGetAuthenticationInfo(…) 方法目的是什么？</li>
</ol>
<h3 id="认证流程说明"><a href="#认证流程说明" class="headerlink" title="认证流程说明"></a>认证流程说明</h3><p>用户访问<code>/user/login</code> 路径，生成 UsernamePasswordToken, 通过SecurityUtils.getSubject()获取Subject（currentUser），调用 login 方法进行验证，让我们跟踪一下代码，瞧一瞧就知道自定义的CustomRealm怎样起作用的，一起来看源码：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829192228-5bb11.png" alt="img"></p>
<p>到这里我们要停一停了，请回看 Shiro 近景图，将源码追踪路径与其对比，是完全一致的</p>
<h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>身份认证是验证你是谁的问题，而授权是你能干什么的问题，</p>
<blockquote>
<p>产品经理：申购模块只能科室看 程序员：好的 产品经理：科长权限大一些，他也能看申购模块 程序员：好的(黑脸) 产品经理：科长不但能看，还能修改数据 程序员：关公提大刀，拿命来 …</p>
</blockquote>
<p>作为程序员，我们的宗旨是：「能动手就不吵吵」; 硝烟怒火拔地起，耳边响起驼铃声（Shiro）：「放下屠刀，立地成佛」授权没有那么麻烦，大家好商量…<br>整个过程和身份认证基本是一毛一样，你对比看看</p>
<h3 id="角色实体创建"><a href="#角色实体创建" class="headerlink" title="角色实体创建"></a>角色实体创建</h3><p>涉及到授权，自然要和角色相关，所以我们创建 Role 实体:</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class Role &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Id</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@GeneratedValue</span>(strategy=GenerationType.AUTO)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Long id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(unique =true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String roleCode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">String</span> <span class="selector-tag">roleName</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="新建-Role-Repository"><a href="#新建-Role-Repository" class="headerlink" title="新建 Role Repository"></a>新建 Role Repository</h3><figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">@Repository</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RoleRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Role</span>, <span class="title">Long</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Query(value = <span class="string">"select roleId from UserRoleRel ur where ur.userId = ?1"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">List</span>&lt;<span class="keyword">Long</span>&gt; findUserRole(<span class="keyword">Long</span> userId);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">List</span>&lt;Role&gt; findByIdIn(<span class="keyword">List</span>&lt;<span class="keyword">Long</span>&gt; ids);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="定义权限实体-Permission"><a href="#定义权限实体-Permission" class="headerlink" title="定义权限实体 Permission"></a>定义权限实体 Permission</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class Permission &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Id</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@GeneratedValue</span>(strategy=GenerationType.AUTO)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Long id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(unique =true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String permCode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">String</span> <span class="selector-tag">permName</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="定义-Permission-Repository"><a href="#定义-Permission-Repository" class="headerlink" title="定义 Permission Repository"></a>定义 Permission Repository</h3><figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">@Repository</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PermissionRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Permission</span>, <span class="title">Long</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Query(value = <span class="string">"select permId from RolePermRel pr where pr.roleId in ?1"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">List</span>&lt;<span class="keyword">Long</span>&gt; findRolePerm(<span class="keyword">List</span>&lt;<span class="keyword">Long</span>&gt; roleIds);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">List</span>&lt;Permission&gt; findByIdIn(<span class="keyword">List</span>&lt;<span class="keyword">Long</span>&gt; ids);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="建立用户与角色关系"><a href="#建立用户与角色关系" class="headerlink" title="建立用户与角色关系"></a>建立用户与角色关系</h3><p>其实可以通过 JPA 注解来制定关系的，这里为了说明问题，以单独外键形式说明</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class UserRoleRel &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Id</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@GeneratedValue</span>(strategy=GenerationType.AUTO)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Long id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">Long</span> <span class="selector-tag">userId</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">Long</span> <span class="selector-tag">roleId</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="建立角色与权限关系"><a href="#建立角色与权限关系" class="headerlink" title="建立角色与权限关系"></a>建立角色与权限关系</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class RolePermRel &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Id</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@GeneratedValue</span>(strategy=GenerationType.AUTO)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Long id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">Long</span> <span class="selector-tag">permId</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">Long</span> <span class="selector-tag">roleId</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="编写-UserController"><a href="#编写-UserController" class="headerlink" title="编写 UserController"></a>编写 UserController</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequiresPermissions</span>(<span class="string">"user:list:view"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">getAllUsers</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;User&gt; users = userRepository.findAll();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>@RequiresPermissions(&quot;user:list:view&quot;)</code> 注解说明具有用户：列表：查看权限的才可以访问），官网明确给出权限定义格式，包括通配符等，我希望你自行去查看<br>自定义 CustomRealm (主要重写 doGetAuthorizationInfo) 方法:</p>
<p><img src="http://image.winrains.cn/2019/10/20191025224030-8db56.png" alt="img"></p>
<p>与认证流程如出一辙，只不过多了用户，角色，权限的关系罢了</p>
<h3 id="授权流程说明"><a href="#授权流程说明" class="headerlink" title="授权流程说明"></a>授权流程说明</h3><p>这里通过过滤器（见Shiro配置）和注解二者结合的方式来进行授权，和认证流程一样，最终会走到我们自定义的 CustomRealm 中，同样 Shiro 默认提供了许多注解用来处理不同的授权情况</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>@RequiresGuest</td>
<td>只有游客可以访问</td>
</tr>
<tr>
<td>@RequiresAuthentication</td>
<td>需要登录才能访问</td>
</tr>
<tr>
<td>@RequiresUser</td>
<td>已登录的用户或“记住我”的用户能访问</td>
</tr>
<tr>
<td>@RequiresRoles</td>
<td>已登录的用户需具有指定的角色才能访问</td>
</tr>
<tr>
<td>@RequiresPermissions</td>
<td>已登录的用户需具有指定的权限才能访问（如果不想和产品经理华山论剑，推荐用这个注解）</td>
</tr>
</tbody></table>
<p>授权官网给出明确的授权策略与案例，请查看：<a href="https://link.juejin.im?target=http%3A%2F%2Fshiro.apache.org%2Fpermissions.html">shiro.apache.org/permissions…</a><br>上面的例子我们通过一直在通过访问 Mysql 获取用户认证和授权信息，这中方式明显不符合生产环境的需求</p>
<h2 id="Session会话管理"><a href="#Session会话管理" class="headerlink" title="Session会话管理"></a>Session会话管理</h2><p>做过 Web 开发的同学都知道 Session 的概念，最常用的是 Session 过期时间，数据在 Session 的 CRUD，同样看上图，我们需要关注 SessionManager 和 SessionDAO 模块，Shiro starter 已经提供了基本的 Session配置信息，我们按需在YAML中配置就好（官网<a href="https://shiro.apache.org/spring-boot.html" target="_blank" rel="noopener">https://shiro.apache.org/spring-boot.html</a> 已经明确给出Session的配置信息）</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Default Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>shiro.enabled</td>
<td>true</td>
<td>Enables Shiro’s Spring module</td>
</tr>
<tr>
<td>shiro.web.enabled</td>
<td>true</td>
<td>Enables Shiro’s Spring web module</td>
</tr>
<tr>
<td>shiro.annotations.enabled</td>
<td>true</td>
<td>Enables Spring support for Shiro’s annotations</td>
</tr>
<tr>
<td>shiro.sessionManager.deleteInvalidSessions</td>
<td>true</td>
<td>Remove invalid session from session storage</td>
</tr>
<tr>
<td>shiro.sessionManager.sessionIdCookieEnabled</td>
<td>true</td>
<td>Enable session ID to cookie, for session tracking</td>
</tr>
<tr>
<td>shiro.sessionManager.sessionIdUrlRewritingEnabled</td>
<td>true</td>
<td>Enable session URL rewriting support</td>
</tr>
<tr>
<td>shiro.userNativeSessionManager</td>
<td>false</td>
<td>If enabled Shiro will manage the HTTP sessions instead of the container</td>
</tr>
<tr>
<td>shiro.sessionManager.cookie.name</td>
<td>JSESSIONID</td>
<td>Session cookie name</td>
</tr>
<tr>
<td>shiro.sessionManager.cookie.maxAge</td>
<td>-1</td>
<td>Session cookie max age</td>
</tr>
<tr>
<td>shiro.sessionManager.cookie.domain</td>
<td>null</td>
<td>Session cookie domain</td>
</tr>
<tr>
<td>shiro.sessionManager.cookie.path</td>
<td>null</td>
<td>Session cookie path</td>
</tr>
<tr>
<td>shiro.sessionManager.cookie.secure</td>
<td>false</td>
<td>Session cookie secure flag</td>
</tr>
<tr>
<td>shiro.rememberMeManager.cookie.name</td>
<td>rememberMe</td>
<td>RememberMe cookie name</td>
</tr>
<tr>
<td>shiro.rememberMeManager.cookie.maxAge</td>
<td>one year</td>
<td>RememberMe cookie max age</td>
</tr>
<tr>
<td>shiro.rememberMeManager.cookie.domain</td>
<td>null</td>
<td>RememberMe cookie domain</td>
</tr>
<tr>
<td>shiro.rememberMeManager.cookie.path</td>
<td>null</td>
<td>RememberMe cookie path</td>
</tr>
<tr>
<td>shiro.rememberMeManager.cookie.secure</td>
<td>false</td>
<td>RememberMe cookie secure flag</td>
</tr>
<tr>
<td>shiro.loginUrl</td>
<td>/login.jsp</td>
<td>Login URL used when unauthenticated users are redirected to login page</td>
</tr>
<tr>
<td>shiro.successUrl</td>
<td>/</td>
<td>Default landing page after a user logs in (if alternative cannot be found in the current session)</td>
</tr>
<tr>
<td>shiro.unauthorizedUrl</td>
<td>null</td>
<td>Page to redirect user to if they are unauthorized (403 page)</td>
</tr>
</tbody></table>
<p>分布式服务中，我们通常需要将Session信息放入Redis中来管理，来应对高并发的访问需求，这时只需重写SessionDAO即可完成自定义的Session管理</p>
<h3 id="整合Redis"><a href="#整合Redis" class="headerlink" title="整合Redis"></a>整合Redis</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> RedisConnectionFactory redisConnectionFactory;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;<span class="keyword">String</span>, Object&gt; stringObjectRedisTemplate() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        RedisTemplate&lt;<span class="keyword">String</span>, Object&gt; <span class="keyword">template</span> = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span>.setConnectionFactory(redisConnectionFactory);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span>.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span>.setValueSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">template</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="重写SessionDao"><a href="#重写SessionDao" class="headerlink" title="重写SessionDao"></a>重写SessionDao</h3><p><img src="http://image.winrains.cn/2019/10/20191025224031-5691e.png" alt="img"></p>
<p>查看源码，可以看到调用默认SessionManager的retriveSession方法，我们重写该方法，将Session放入HttpRequest中，进一步提高session访问效率</p>
<p><img src="http://image.winrains.cn/2019/10/20191025224035-220fc.png" alt="img"></p>
<h3 id="向ShiroConfig中添加配置"><a href="#向ShiroConfig中添加配置" class="headerlink" title="向ShiroConfig中添加配置"></a>向ShiroConfig中添加配置</h3><p>其实在概览模块已经给出代码展示，这里单独列出来做说明:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 自定义RedisSessionDao用来管理Session在Redis中的CRUD</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * @return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">Bean(<span class="params">name</span> = <span class="string">"redisSessionDao"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public RedisSessionDao redis<span class="constructor">SessionDao()</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return <span class="keyword">new</span> <span class="constructor">RedisSessionDao()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 自定义SessionManager,应用自定义SessionDao</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * @return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">Bean(<span class="params">name</span> = <span class="string">"customerSessionManager"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public CustomerWebSessionManager customer<span class="constructor">WebSessionManager()</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    CustomerWebSessionManager customerWebSessionManager = <span class="keyword">new</span> <span class="constructor">CustomerWebSessionManager()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    customerWebSessionManager.set<span class="constructor">SessionDAO(<span class="params">redisSessionDao</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return customerWebSessionManager;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 定义Security manager</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * @param customRealm</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * @return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">Bean(<span class="params">name</span> = <span class="string">"securityManager"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public DefaultWebSecurityManager default<span class="constructor">WebSecurityManager(CustomRealm <span class="params">customRealm</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    DefaultWebSecurityManager  securityManager = <span class="keyword">new</span> DefaultWebSecurityManager <span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    securityManager.set<span class="constructor">Realm(<span class="params">customRealm</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    securityManager.set<span class="constructor">SessionManager(<span class="params">customerWebSessionManager</span>()</span>); <span class="comment">// 可不指定，Shiro会用默认Session manager</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    securityManager.set<span class="constructor">CacheManager(<span class="params">redisCacheManagers</span>()</span>);  <span class="comment">//可不指定，Shiro会用默认CacheManager</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//        securityManager.setSessionManager(defaultWebSessionManager());</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    return securityManager;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 定义session管理器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * @return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">Bean(<span class="params">name</span> = <span class="string">"sessionManager"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public DefaultWebSessionManager default<span class="constructor">WebSessionManager()</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    DefaultWebSessionManager defaultWebSessionManager = <span class="keyword">new</span> <span class="constructor">DefaultWebSessionManager()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    defaultWebSessionManager.set<span class="constructor">SessionDAO(<span class="params">redisSessionDao</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return defaultWebSessionManager;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>至此，将 session 信息由 redis 管理功能就这样完成了</p>
<h2 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h2><p>应对分布式服务，对于高并发访问数据库权限内容是非常低效的方式，同样我们可以利用Redis来解决这一问题，将授权数据缓存到Redis中</p>
<h3 id="新建-RedisCache"><a href="#新建-RedisCache" class="headerlink" title="新建 RedisCache"></a>新建 RedisCache</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Cache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SHIRO_PREFIX = <span class="string">"shiro-cache:"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Resource</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; stringObjectRedisTemplate;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getKey</span><span class="params">(K key)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (key <span class="keyword">instanceof</span> String)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> (SHIRO_PREFIX + key);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> key.toString();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        log.info(<span class="string">"read from redis..."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        V v = (V) stringObjectRedisTemplate.opsForValue().get(getKey(k));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K k, V v)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        stringObjectRedisTemplate.opsForValue().set(getKey(k), v);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        stringObjectRedisTemplate.expire(getKey(k), <span class="number">100</span>, TimeUnit.SECONDS);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K k)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        V v = (V) stringObjectRedisTemplate.opsForValue().get(getKey(k));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        stringObjectRedisTemplate.delete((String) get(k));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> <span class="keyword">throws</span> CacheException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//不要重写，如果只保存shiro数据无所谓</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="新建-RedisCacheManager"><a href="#新建-RedisCacheManager" class="headerlink" title="新建 RedisCacheManager"></a>新建 RedisCacheManager</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheManager</span> <span class="keyword">implements</span> <span class="title">CacheManager</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Resource</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> &lt;K, V&gt; <span class="function">Cache&lt;K, V&gt; <span class="title">getCache</span><span class="params">(String s)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> redisCache;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>至此，我们不用每次访问 Mysql DB 来获取认证和授权信息，而是通过 Redis 来缓存这些信息，大大提升了效率，也满足分布式系统的设计需求</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回复公众号 「demo」获取 demo 代码。这里只是梳理了Springboot整合Shiro的流程，以及应用Redis最大化利用Shiro，Shiro的使用细节还很多，官网说的也很明确，带着上面的架构图来理解Shiro会事半功倍，感觉这里面的代码挺多挺头大的？那是你没有自己动手去尝试，结合官网与 demo 相信你会对 Shiro 有更好的理解，另外你可以理解 Shiro 是 mini 版本的 Spring Security，我希望以小见大，当需要更细粒度的认证授权时，也会对理解 Spring Security 有很大帮助，点击文末「阅读原文」，效果更好<br>落霞与孤鹜齐飞 秋水共长天一色，产品经理和程序员一片祥和…</p>
<h2 id="灵魂追问"><a href="#灵魂追问" class="headerlink" title="灵魂追问"></a>灵魂追问</h2><ol>
<li>都说 Redis 是单线程，但是很快，你知道为什么吗？</li>
<li>你们项目中是怎样控制认证授权的呢？当授权有变化，对于程序员来说，这个修改是灾难吗？</li>
</ol>
<blockquote>
<p>作者：日拱一兵</p>
<p>来源：<a href="https://juejin.im/post/5d4b7425e51d4561bb33fafd" target="_blank" rel="noopener">https://juejin.im/post/5d4b7425e51d4561bb33fafd</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
        <category>Shiro</category>
      </categories>
  </entry>
  <entry>
    <title>如何设计好的RESTful API</title>
    <url>/2019/12/26/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%A5%BD%E7%9A%84RESTful-API/</url>
    <content><![CDATA[<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>现阶段的开发模式多以前后端分离形式存在，前后端开发人员需要通过大量 API 来进行数据交互，如果在交互过程中前后端人员经常遭遇如下问题：</p>
<ul>
<li>前端人员不能快速理解接口字段含义及接口字段变化</li>
<li>后端人员想复用某些接口，但是不能快速从接口 URL 的定义中明确该接口的含义，需要进一步读代码确认</li>
<li>URL中的英文单词使用五花八门，搜索某个接口不知道具体的关键字</li>
<li>请求方法动词如 POST GET 随意使用</li>
<li>完成当前业务接口对接，前端人员经常会询问下一步业务流程的接口定义在哪里，对接形式是什么样的</li>
</ul>
<a id="more"></a>

<p>以上只是前后端人员通过接口交互的一小部分问题，这些问题就好比”牙痛”，不致命，但是在整个软件开发的生命周期内，天天”牙痛”是很要命的, 需要解决上述的问题，需要前后端人员都能认识与了解接口设计规范的重要性。</p>
<h2 id="什么是REST"><a href="#什么是REST" class="headerlink" title="什么是REST"></a>什么是REST</h2><p>在 2000 年，Roy Fielding 提出 Representational State Transfer (REST) 的概念，中文翻译过来”表述性状态传递”，感兴趣的朋友可以去维基百科看看原始概念，乍一看是一个挺抽象的概念，但其实，这个概念就像交通灯规则一样简单，就看如何看待相关规范. 当我们谈及 RESTful 设计规范，多数人能了解设计的大原则，但是不了解小细节，而对这些细节的了解与否，是能否治好”牙痛病”的关键</p>
<h2 id="REST术语介绍"><a href="#REST术语介绍" class="headerlink" title="REST术语介绍"></a>REST术语介绍</h2><p>现实世界交通灯有红绿黄，REST相关的概念也是三个：资源，集合，URL</p>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>资源是某种东西的对象或表示，它具有一些与之相关的数据，并且可以有一组方法对其进行操作。 例如, 动物，学校和员工是资源; 删除，添加，更新是对这些资源执行的相关操作</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合是资源集合，例如，公司是公司资源的集合</p>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>URL（统一资源定位符）是可以通过其定位资源的路径，并且可以对其执行某些操作<br>了解到以上内容， 那REST 世界的”交通灯”规则是什么样的？我们来了解一下</p>
<h2 id="如何设计和开发一个高可用的-REST-APIs"><a href="#如何设计和开发一个高可用的-REST-APIs" class="headerlink" title="如何设计和开发一个高可用的 REST APIs"></a>如何设计和开发一个高可用的 REST APIs</h2><blockquote>
<p>网上一直有关于”最好的Restful API的设计”争论，何为最好，至今没有一个官方的指导。本文总结 RESTful 的设计细节，介绍如何设计出易于理解和使用的 API。在 Restful API 设计标准之上，我们可以为我们的设计增加一些弹性（团队都认可的方式），每个项目的情况不同，最重要的是项目组成员达成一致的Restful API 设计规则，达到高可用即可</p>
</blockquote>
<h3 id="URL-设计"><a href="#URL-设计" class="headerlink" title="URL 设计"></a>URL 设计</h3><p>学英语，名词（car/animal/teacher）都很好记忆，但是如何用动词和这些名词组合来准确的表达特定的含义却很困难，庆幸的是在 REST 的世界，动词寥寥无几，并且含义单一 ，RESTful 的核心思想也是通过这些<strong>动词 + 名词</strong>完成对资源的操作与访问，但我们经常看到这样的动词与名词的 URL 组合：</p>
<ul>
<li>/getAllUsers</li>
<li>/createNewCompany</li>
<li>/updateUserInfo</li>
<li>/deleteUser?name=zhangsan</li>
</ul>
<p>这些 URL 的设计会导致文章开头所说的很多问题，我们进一步来了解如何应用所谓的<strong>动词 + 名词</strong></p>
<h4 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h4><p>动词通常就是 5 种 HTTP 方法，对应我们常见的 CRUD 操作：</p>
<ul>
<li>POST：新建（Create）</li>
<li>GET：读取（Read）</li>
<li>PUT：更新（Update）</li>
<li>PATCH：更新（Update），通常不分更新，也很少用到</li>
<li>DELETE：删除（Delete）</li>
</ul>
<p>根据 HTTP 规范，动词一律大写，另外根据RESTful 幂等性（多次调用是否会对资源产生影响）原则，我们不能乱用动词，GET/PUT/DELETE 是幂等的，POST/PATCH 不是幂等的<br>有些客户端只能使用 <code>GET</code>和 <code>POST</code>这两种方法。服务器必须接受 <code>POST</code>模拟其他三个方法（ <code>PUT</code>、 <code>PATCH</code>、 <code>DELETE</code>）。<br>这时，客户端发出的 HTTP 请求，要加上 <code>X-HTTP-Method-Override</code>属性，告诉服务器应该使用哪一个动词，覆盖 <code>POST</code>方法。</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">POST /users/<span class="number">12</span> HTTP/<span class="number">1.1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">X-HTTP-<span class="function"><span class="keyword">Method</span>-<span class="title">Override</span>:</span> PUT</span></pre></td></tr></table></figure>

<p>上面代码中， <code>X-HTTP-Method-Override</code>指定本次请求的方法是 <code>PUT</code>，而不是 <code>POST</code></p>
<h4 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h4><p>名词就是表示一个资源或者服务，如 /users，/teachers，这里看到我用名词复数的形式描述某一资源，至于用单数还是复数每个人都有自己的见解，我在这里推荐使用复数，因为在现实世界中，资源多数是以集合的形式存在的</p>
<h4 id="动词-名词"><a href="#动词-名词" class="headerlink" title="动词 + 名词"></a>动词 + 名词</h4><p><img src="http://image.winrains.cn/2019/08/20190829193552-61f08.jpeg" alt="http://image.winrains.cn/2019/08/20190829193552-61f08.jpeg"></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">POST /users</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /users</span></pre></td></tr><tr><td class="code"><pre><span class="line">PUT /users</span></pre></td></tr><tr><td class="code"><pre><span class="line">DELETE /users</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /users/12</span></pre></td></tr><tr><td class="code"><pre><span class="line">PUT /users/12</span></pre></td></tr><tr><td class="code"><pre><span class="line">DELETE /users/12</span></pre></td></tr></table></figure>

<p>上述<strong>动词 + 名词</strong>的组合是不是清晰多了，没有杂乱的动词在 URL 中，大家的理解含义相同</p>
<h4 id="URL-层级"><a href="#URL-层级" class="headerlink" title="URL 层级"></a>URL 层级</h4><p>现实中哪有这么简单的 CRUD，资源的相互关联与嵌套很常见，查找 id 是 12 的用户的所有帖子， 如何设计这个 URL，下面两种设计也会有争论：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /users/12/posts</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /posts?<span class="attribute">userId</span>=12</span></pre></td></tr></table></figure>

<p>第一种出现两个名词主题（users/posts），会让人有几秒钟的猜想，这到底请求的是用户资源还是帖子资源，当存在更深浅套的时候也不容易扩展，所以我推荐第二种方式，主体名词 posts 资源明显，其他过滤条件也更容易扩展，比如 /posts?userName=zhangsan，我们可以复用同样的接口</p>
<h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>我们看到过很多如下 URL 设计，用来区分 API 版本：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">POST /v2/users</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /V1/users/12</span></pre></td></tr></table></figure>

<p>我们都指向同样的资源 users，URL 中为什么要加版本号呢？ 针对这个问题，答案依旧没有统一标准，如果多个版本的API版本返回数据结果结构一样，那没必要区分版本，如果结构已经发生变化，而且要向下兼容，那版本号是很好的区分方式，而且通过 URL 加版本的方式可以更好的发现资源</p>
<h4 id="过滤-分页-排序"><a href="#过滤-分页-排序" class="headerlink" title="过滤/分页/排序"></a>过滤/分页/排序</h4><p>实际的业务场景中会经常对请求资源做条件筛选，分页显示，以及排序，我们不要为这些业务要求创建不同步的 API，我们应该尽量保持 URL 的信息简单，只需添加查询条件参数来实现上述功能，同时符合”望 URL 知意”的原则</p>
<h5 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h5><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /users/12/posts?<span class="attribute">state</span>=published</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /users/12/posts?<span class="attribute">published</span>=<span class="literal">true</span></span></pre></td></tr></table></figure>

<p>上述两种方式都可以实现资源的过滤</p>
<h5 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h5><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /users?<span class="attribute">pageNo</span>=1&amp;pageSize=20</span></pre></td></tr></table></figure>

<p>以分页方式查询用户列表，显示第 2 页内容，每页显示 20 条信息</p>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /users?<span class="attribute">sort</span>=score_desc</span></pre></td></tr></table></figure>

<p>按照学生分数降序进行排序<br>上述所有的方式我们都可以做到”望 URL 知意”，这就是好的设计</p>
<h3 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h3><p>RESTful API 的返回结果也是设计环节中重要的一环</p>
<h4 id="响应数据格式"><a href="#响应数据格式" class="headerlink" title="响应数据格式"></a>响应数据格式</h4><p>API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的 <code>Content-Type</code>属性要设为 <code>application/json</code>。同时客户端也应作出相应的配合，客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的 <code>ACCEPT</code>属性也要设成 <code>application/json</code>，多渠道调用可能会存在相同资源需要有不同的 producer 类型的情况存在</p>
<h4 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h4><p>很多后端开发人员可能受开发框架所限，或者返回数据封装形式不够好，经常会给前端人员不是很友好的 HTTP 状态码，比如 response 有 error，却给出 <code>200HTTP.OK</code> 的状态码 (明明吃了三碗粉，却给两碗粉的钱)</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span></pre></td></tr><tr><td class="code"><pre><span class="line">Content-<span class="keyword">Type</span>: application/<span class="type">json</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    "status": "-1",</span></pre></td></tr><tr><td class="code"><pre><span class="line">    "result": &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        "error": "分数应小于150"</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>有人说，我已经标记返回内容 status 是 -1（表示failure）, 用 200 作为状态码也无妨吧？这是一个很错误的观念，RESTful 的设计理念之一是简单直观，试想一下，前端开发人员打开开发者工具，所有请求都是200的状态码，但是页面数据就是没有显示出来，难道前端开发人员还要每个接口调用点开看一看，是哪个 status 是 -1 导致的吗？ 很显然我们不希望这样的情况发生，正确的做法应该类似这样的：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">400</span> Bad Request</span></pre></td></tr><tr><td class="code"><pre><span class="line">Content-<span class="keyword">Type</span>: application/<span class="type">json</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    "status": "-1",</span></pre></td></tr><tr><td class="code"><pre><span class="line">    "result": &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        "error": "分数应小于150"</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>下面页列举出来常用的状态码以及表示的含义：</p>
<h5 id="2xx-状态码"><a href="#2xx-状态码" class="headerlink" title="2xx 状态码"></a>2xx 状态码</h5><p>200表示成功，同时我们可以表示的更加精确</p>
<blockquote>
<ul>
<li><code>GET:200OK</code> 请求成功</li>
<li><code>POST:201Created</code> 创建成功</li>
<li><code>PUT:200OK</code> 更新成功</li>
<li><code>DELETE:204NoContent</code> 找不到要删除的内容</li>
</ul>
</blockquote>
<p>使用状态码 202 有时候会比 使用状态啊吗 201 是更好的选择，状态码 202 的意思是：服务端已接收到了请求，但是还没有创建任何资源，但结果一切正常。 比如：</p>
<blockquote>
<ul>
<li>异步操作：服务器已接收到请求，但是还未处理，但是会在未来处理</li>
<li>资源已经存在，没有创建新的资源 （有些业务可能会返回错误信息”您创建的数据已存在”，所以这种情景没有明确的规定，符合自己的业务需求即可）</li>
</ul>
</blockquote>
<h5 id="4xx-状态码"><a href="#4xx-状态码" class="headerlink" title="4xx 状态码"></a>4xx 状态码</h5><p>4xx 状态码表示客户端的错误，主要有以下几种：</p>
<blockquote>
<ul>
<li><code>400BadRequest</code>：服务器不理解客户端的请求，未做任何处理</li>
<li><code>401Unauthorized</code>：用户未提供身份验证凭据，或者没有通过身份验证</li>
<li><code>403Forbidden</code>：用户通过了身份验证，但是不具有访问资源所需的权限</li>
<li><code>404NotFound</code>：所请求的资源不存在，或不可用</li>
<li><code>415UnsupportedMediaType</code>：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式</li>
</ul>
</blockquote>
<p>这里要注意状态码 401 和 403 的区别</p>
<h5 id="5xx-状态码"><a href="#5xx-状态码" class="headerlink" title="5xx 状态码"></a>5xx 状态码</h5><p>5xx 状态码表示服务端错误，通常只会用到两个：</p>
<blockquote>
<ul>
<li><code>500InternalServerError</code>：客户端请求有效，服务器处理时发生了意外</li>
<li><code>503ServiceUnavailable</code>：服务器无法处理请求，一般用于网站维护状态</li>
</ul>
</blockquote>
<h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>过去开发人员通常会将活动的用户信息存储在服务端的 session 中， 这种形式很显然不适用于现在分布式微服务架构的模式，我们可以使用 JWT (JSON Web Token) 如 OAuth2 来实现，这样每次在 Httpheader 中添加 token 来做验证即可</p>
<h4 id="API-文档"><a href="#API-文档" class="headerlink" title="API 文档"></a>API 文档</h4><p>Swagger是一种广泛使用的工具来用来记录与呈现 REST API，它提供了一种探索特定 API 使用的方法，因此允许开发人员理解底层的语义行为。 这是一种使用注释添加文档的声明性方法，它进一步生成描述 API 及其用法的 JSON，可以实时应对 API 的更新，具体请参考 Swagger 官网 , 同时使用 Spring Boot 的小伙伴也可以很轻松的集成 Swagger，只需引入Swagger Starter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spring4all<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure>

<h4 id="HATEOAS"><a href="#HATEOAS" class="headerlink" title="HATEOAS"></a>HATEOAS</h4><p>HATEOAS (Hypermedia As Transfer Engine Of Application State), API 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做 HATEOAS , 举个例子，列表页数据通常会有查看操作，这样我们在返回列表页的数据的时候同样返回如何操作查看具体数据详情的 API 接口：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">"status"</span>: <span class="string">"-1"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">"result"</span>: [&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">"id"</span>: <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">"name"</span>: <span class="string">"zhangsan"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">"links"</span>:[</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="attr">"href"</span>: <span class="string">"http://localhost:8080/user/&#123;id&#125;"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用 Spring 框架的小伙伴可以快速的体验一下这种方式，Spring 官网项目 Spring HATEOAS , 会快速的将参数都做替换, 将查看 API URL 中的 id 直接替换成 1。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">"status"</span>: <span class="string">"-1"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">"result"</span>: [&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">"id"</span>: <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">"name"</span>: <span class="string">"zhangsan"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">"links"</span>:[</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="attr">"href"</span>: <span class="string">"http://localhost:8080/user/1"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="提升效率工具"><a href="#提升效率工具" class="headerlink" title="提升效率工具"></a>提升效率工具</h2><h3 id="RestfulToolkit"><a href="#RestfulToolkit" class="headerlink" title="RestfulToolkit"></a>RestfulToolkit</h3><p>后端开发人员可以安装 IntellJ idea 插件 RestfulToolkit, Mac 环境使用快捷键 <code>CMD+\</code> 输入关键字快速定位到 API 位置<br><img src="http://image.winrains.cn/2019/08/20190829193553-5ae2b.jpeg" alt="http://image.winrains.cn/2019/08/20190829193553-5ae2b.jpeg"><br>同时在右侧工具栏打开 API，会自动生成 demoData 请求参数，实现快速调用测试：<br><img src="http://image.winrains.cn/2019/08/20190829193553-64b76.png" alt="http://image.winrains.cn/2019/08/20190829193553-64b76.png"><br>JSON-Viewer<br>JSON-Viewer 是 Chrome 浏览器的插件，用于快速解析及格式化 json 内容，在 Chrome omnibox（多功能输入框）输入 <code>json-viewer+TAB</code> ，将 json 内容拷贝进去，然后输入回车键，将看到结构清晰的 json 数据，同时可以自定义主题<br><img src="http://image.winrains.cn/2019/08/20190829193553-d6f5d.jpeg" alt="http://image.winrains.cn/2019/08/20190829193553-d6f5d.jpeg"><br>另外，前端人员打开开发者工具，双击请求链接，会自动将 response 中的 json 数据解析出来，非常方便</p>
<h3 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h3><p>Postman 功能十分强大， 搜索 <code>Postman自定义环境变量</code>，会打开新世界的大门</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>如何设计出最好的 RESTful API 永远不会有结论，设计出高可用，团队认可，简单清晰明了的 RESTful API 就是好的。</p>
<blockquote>
<p>作者：日拱一兵</p>
<p>来源：<a href="https://mp.weixin.qq.com/s/hR1TqkVzwZ_T8fuMnsM4hQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/hR1TqkVzwZ_T8fuMnsM4hQ</a></p>
</blockquote>
]]></content>
      <categories>
        <category>其它技术</category>
        <category>Restful</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL锁机制</title>
    <url>/2019/12/26/MySQL%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="一、锁的类型"><a href="#一、锁的类型" class="headerlink" title="一、锁的类型"></a>一、锁的类型</h2><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><ul>
<li>共享锁（S Lock）允许事务读一行数据</li>
<li>排它锁 （X Lock） 允许事务读一行数据</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829194616-b39aa.jpeg" alt="img"></p>
<a id="more"></a>

<h3 id="表锁-意向锁"><a href="#表锁-意向锁" class="headerlink" title="表锁(意向锁)"></a>表锁(意向锁)</h3><p>锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式</p>
<ul>
<li>意向共享锁（IS Lock）事务想要获得一张表中某几行的共享锁</li>
<li>意向排他锁（IX Lock）事务想要获得一张表中某几行的排他锁</li>
</ul>
<p>由于InnoDB存储引擎支持的是行级别的锁，因此意向锁其实不会阻塞除全表扫以外的任何请求。故表级意向锁与行级锁的兼容性如下所示</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194616-95e79.jpeg" alt="img"></p>
<p><img src="http://image.winrains.cn/2019/08/20190829194616-bdd47.jpeg" alt="img"></p>
<p>若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。例上图，如果需要对页上的记录r进行上X锁，那么分别需要对数据库A、表、页上意向锁IX，最后对记录r上X锁。若其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成。举例来说，在对记录r加X锁之前，已经有事务对表1进行了S表锁，那么表1上已存在S锁，之后事务需要对记录r在表1上加上IX，由于不兼容，所以该事务需要等待表锁操作的完成。</p>
<h3 id="意向锁到底有什么作用？"><a href="#意向锁到底有什么作用？" class="headerlink" title="意向锁到底有什么作用？"></a>意向锁到底有什么作用？</h3><p>innodb的意向锁主要用户多粒度的锁并存的情况。比如事务A要在一个表上加S锁，如果表中的一行已被事务B加了X锁，那么该锁的申请也应被阻塞。如果表中的数据很多，逐行检查锁标志的开销将很大，系统的性能将会受到影响。为了解决这个问题，可以在表级上引入新的锁类型来表示其所属行的加锁情况，这就引出了“意向锁”的概念。<br>举个例子，如果表中记录1亿，事务A把其中有几条记录上了行锁了，这时事务B需要给这个表加表级锁，如果没有意向锁的话，那就要去表中查找这一亿条记录是否上锁了。如果存在意向锁，那么假如事务Ａ在更新一条记录之前，先加意向锁，再加Ｘ锁，事务B先检查该表上是否存在意向锁，存在的意向锁是否与自己准备加的锁冲突，如果有冲突，则等待直到事务Ａ释放，而无须逐条记录去检测。事务Ｂ更新表时，其实无须知道到底哪一行被锁了，它只要知道反正有一行被锁了就行了。<br><strong>主要作用是处理行锁和表锁之间的矛盾，能够显示“某个事务正在某一行上持有了锁，或者准备去持有锁”</strong></p>
<h2 id="二、锁的算法"><a href="#二、锁的算法" class="headerlink" title="二、锁的算法"></a>二、锁的算法</h2><ul>
<li>Record Lock：单个行记录上的锁</li>
<li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身</li>
<li>Next-Key Lock∶Gap Lock+Record Lock，锁定一个范围、索引之间的间隙，并且锁定记录本身；目的是为了防止幻读</li>
</ul>
<h2 id="三、mysql如何做到读写并行（多版本控制）？"><a href="#三、mysql如何做到读写并行（多版本控制）？" class="headerlink" title="三、mysql如何做到读写并行（多版本控制）？"></a>三、mysql如何做到读写并行（多版本控制）？</h2><p>多版本并发控制 MVCC，是行级锁的一个变种，通过保存数据在某个时间节点的快照(snapshot)，类似实现了行级锁。由此不同事务对同一表，同一时刻看到的数据可能是不一样的。 实现上通过在不同的数据行后增加创建日期版本号和删除日期版本号，且版本号不断递增，进而实现了数据快照</p>
<h3 id="读的类型"><a href="#读的类型" class="headerlink" title="读的类型"></a>读的类型</h3><ul>
<li>一致性非锁定读（快照读）<ul>
<li>在事务隔离级别提交读（RC）和可重复读（RR）下，InnoDB存储引擎使用非锁定的一致性读<ul>
<li>RC模式下，读取最新的快照</li>
<li>RR模式下，读取事务开始时的快照</li>
</ul>
</li>
</ul>
</li>
<li>一致性锁定读 （当前读）<ul>
<li>隔离级别为未提交读(RN）时读取都是当前读</li>
<li>SELECT…FOR UPDATE （加写锁）</li>
<li>SELECT…LOCK IN SHARE MODE （加读锁）</li>
</ul>
</li>
</ul>
<h2 id="四、加锁处理分析"><a href="#四、加锁处理分析" class="headerlink" title="四、加锁处理分析"></a>四、加锁处理分析</h2><p>下面两条简单的SQL，他们加什么锁？<br><strong>select * from t1 where id = 10</strong><br><strong>delete from t1 where id = 10</strong><br>如果要分析加锁情况，必须还要知道以下的一些前提，前提不同，加锁处理的方式也不同</p>
<ul>
<li><strong>前提一</strong>:id列是不是主键？</li>
<li><strong>前提二</strong>:当前系统的隔离级别是什么？</li>
<li><strong>前提三</strong>:id列如果不是主键，那么id列上有索引吗？</li>
<li><strong>前提四</strong>:id列上如果有二级索引，那么这个索引是唯一索引吗？</li>
<li><strong>前提五</strong>:两个SQL的执行计划是什么？索引扫描？全表扫描？</li>
</ul>
<p>根据上述情况，有以下几种组合</p>
<ul>
<li><strong>组合一</strong>:id列是主键，RC隔离级别</li>
<li><strong>组合二</strong>:id列是二级唯一索引，RC隔离级别</li>
<li><strong>组合三</strong>:id列是二级非唯一索引，RC隔离级别</li>
<li><strong>组合四</strong>:id列上没有索引，RC隔离级别</li>
<li><strong>组合五</strong>:id列是主键，RR隔离级别</li>
<li><strong>组合六</strong>:id列是二级唯一索引，RR隔离级别</li>
<li><strong>组合七</strong>:id列是二级非唯一索引，RR隔离级别</li>
<li><strong>组合八</strong>:id列上没有索引，RR隔离级别</li>
<li><strong>组合九</strong>:Serializable隔离级别</li>
</ul>
<p>排列组合还没有列举完全，但是看起来，已经很多了。真的有必要这么复杂吗？事实上，要分析加锁，就是需要这么复杂。但是从另一个角度来说，只要你选定了一种组合，SQL需要加哪些锁，其实也就确定了。接下来挑几个比较经典的组合</p>
<h3 id="组合一：id主键-RC"><a href="#组合一：id主键-RC" class="headerlink" title="组合一：id主键+RC"></a>组合一：id主键+RC</h3><p>这个组合，是最简单，最容易分析的组合。id是主键，Read Committed隔离级别，给定SQL：delete from t1 where id = 10; 只需要将主键上，id = 10的记录加上X锁即可。如下图所示：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194616-d6aa4.jpeg" alt="img"></p>
<p><strong>结论：id是主键时，此SQL只需要在id=10这条记录上加X锁即可。</strong></p>
<h3 id="组合二：id唯一索引-RC"><a href="#组合二：id唯一索引-RC" class="headerlink" title="组合二：id唯一索引+RC"></a>组合二：id唯一索引+RC</h3><p>这个组合，id不是主键，而是一个Unique的二级索引键值。那么在RC隔离级别下，delete from t1 where id = 10; 需要加什么锁呢？见下图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194617-c3318.jpeg" alt="img"></p>
<p>此组合中，id是unique索引，而主键是name列。此时，加锁的情况由于组合一有所不同。由于id是unique索引，因此delete语句会选择走id列的索引进行where条件的过滤，在找到id=10的记录后，首先会将unique索引上的id=10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name = ‘d’ 对应的主键索引项加X锁。为什么聚簇索引上的记录也要加锁？试想一下，如果并发的一个SQL，是通过主键索引来更新：update t1 set id = 100 where name = ‘d’; 此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新/删除需要串行执行的约束。<br><strong>结论：若id列是unique列，其上有unique索引。那么SQL需要加两个X锁，一个对应于id unique索引上的id = 10的记录，另一把锁对应于聚簇索引上的[name=’d’,id=10]的记录。</strong></p>
<h3 id="组合三：id非唯一索引-RC"><a href="#组合三：id非唯一索引-RC" class="headerlink" title="组合三：id非唯一索引+RC"></a>组合三：id非唯一索引+RC</h3><p><strong>相对于组合一、二，组合三又发生了变化，隔离级别仍旧是RC不变，但是id列上的约束又降低了，id列不再唯一，只有一个普通的索引。假设delete from t1 where id = 10; 语句，仍旧选择id列上的索引进行过滤where条件，那么此时会持有哪些锁？同样见下图：</strong></p>
<p><img src="http://image.winrains.cn/2019/08/20190829194617-bf55f.jpeg" alt="img"></p>
<p>根据此图，可以看到，首先，id列索引上，满足id = 10查询条件的记录，均已加锁。同时，这些记录对应的主键索引上的记录也都加上了锁。与组合二唯一的区别在于，组合二最多只有一个满足等值查询的记录，而组合三会将所有满足查询条件的记录都加锁。<br><strong>结论：若id列上有非唯一索引，那么对应的所有满足SQL查询条件的记录，都会被加锁。同时，这些记录在主键索引上的记录，也会被加锁。</strong></p>
<h3 id="组合四：id无索引-RC"><a href="#组合四：id无索引-RC" class="headerlink" title="组合四：id无索引+RC"></a>组合四：id无索引+RC</h3><p><strong>相对于前面三个组合，这是一个比较特殊的情况。id列上没有索引，where id = 10;这个过滤条件，没法通过索引进行过滤，那么只能走全表扫描做过滤。对应于这个组合，SQL会加什么锁？或者是换句话说，全表扫描时，会加什么锁？这个答案也有很多：有人说会在表上加X锁；有人说会将聚簇索引上，选择出来的id = 10;的记录加上X锁。那么实际情况呢？请看下图：</strong></p>
<p><img src="http://image.winrains.cn/2019/08/20190829194617-e2541.jpeg" alt="img"></p>
<p>由于id列上没有索引，因此只能走聚簇索引，进行全部扫描。从图中可以看到，满足删除条件的记录有两条，但是，聚簇索引上所有的记录，都被加上了X锁。无论记录是否满足条件，全部被加上X锁。既不是加表锁，也不是在满足条件的记录上加行锁。<br>有人可能会问？为什么不是只在满足条件的记录上加锁呢？这是由于MySQL的实现决定的。如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由MySQL Server层进行过滤。因此也就把所有的记录，都锁上了。<br>注：在实际的实现中，MySQL有一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁 (违背了2PL的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。<br><strong>结论：若id列上没有索引，SQL会走聚簇索引的全扫描进行过滤，由于过滤是由MySQL Server层面进行的。因此每条记录，无论是否满足条件，都会被加上X锁。但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁/放锁动作不会省略。同时，优化也违背了2PL的约束。</strong></p>
<h3 id="组合五：id主键-RR"><a href="#组合五：id主键-RR" class="headerlink" title="组合五：id主键+RR"></a>组合五：id主键+RR</h3><p>上面的四个组合，都是在Read Committed隔离级别下的加锁行为，接下来的四个组合，是在Repeatable Read隔离级别下的加锁行为。<br>组合五，id列是主键列，Repeatable Read隔离级别，针对delete from t1 where id = 10; 这条SQL，加锁与组合一：[<a href="https://link.juejin.im?target=http%3A%2F%2Fhedengcheng.com%2F%3Fp%3D771%23_%E7%BB%84%E5%90%88%E4%B8%80%EF%BC%9Aid%E4%B8%BB%E9%94%AE%2BRC">id主键，Read Committed</a>]一致。</p>
<h3 id="组合六：id唯一索引-RR"><a href="#组合六：id唯一索引-RR" class="headerlink" title="组合六：id唯一索引+RR"></a>组合六：id唯一索引+RR</h3><p><strong>与组合五类似，组合六的加锁，与组合二：[id唯一索引，Read Committed]一致。两个X锁，id唯一索引满足条件的记录上一个，对应的聚簇索引上的记录一个。</strong></p>
<h3 id="组合七：id非唯一索引-RR"><a href="#组合七：id非唯一索引-RR" class="headerlink" title="组合七：id非唯一索引+RR"></a>组合七：id非唯一索引+RR</h3><p>还记得前面提到的MySQL的四种隔离级别的区别吗？RC隔离级别允许幻读，而RR隔离级别，不允许存在幻读。但是在组合五、组合六中，加锁行为又是与RC下的加锁行为完全一致。那么RR隔离级别下，<br>组合七，Repeatable Read隔离级别，id上有一个非唯一索引，执行delete from t1 where id = 10; 假设选择id列上的索引进行条件过滤，最后的加锁行为，是怎么样的呢？同样看下面这幅图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194617-a6c84.jpeg" alt="img"></p>
<p>此图，相对于组合三：[<a href="https://link.juejin.im?target=http%3A%2F%2Fhedengcheng.com%2F%3Fp%3D771%23_%E7%BB%84%E5%90%88%E4%B8%89%EF%BC%9Aid%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%2BRC">id列上非唯一锁，Read Committed</a>]看似相同，其实却有很大的区别。最大的区别在于，这幅图中多了一个GAP锁，而且GAP锁看起来也不是加在记录上的，倒像是加载两条记录之间的位置，GAP锁有何用？<br>其实这个多出来的GAP锁，就是RR隔离级别，相对于RC隔离级别，不会出现幻读的关键。确实，GAP锁锁住的位置，也不是记录本身，而是两条记录之间的GAP。<br>如何保证两次当前读返回一致的记录，那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交。为了实现这个功能，GAP锁应运而生。<br>如图中所示，有哪些位置可以插入新的满足条件的项 (id = 10)，考虑到B+树索引的有序性，满足条件的项一定是连续存放的。记录[6,c]之前，不会插入id=10的记录；[6,c]与[10,b]间可以插入[10, aa]；[10,b]与[10,d]间，可以插入新的[10,bb],[10,c]等；[10,d]与[11,f]间可以插入满足条件的[10,e],[10,z]等；而[11,f]之后也不会插入满足条件的记录。因此，为了保证[6,c]与[10,b]间，[10,b]与[10,d]间，[10,d]与[11,f]不会插入新的满足条件的记录，MySQL选择了用GAP锁，将这三个GAP给锁起来。<br>Insert操作，如insert [10,aa]，首先会定位到[6,c]与[10,b]间，然后在插入前，会检查这个GAP是否已经被锁上，如果被锁上，则Insert不能插入记录。因此，通过第一遍的当前读，不仅将满足条件的记录锁上 (X锁)，与组合三类似。同时还是增加3把GAP锁，将可能插入满足条件记录的3个GAP给锁上，保证后续的Insert不能插入新的id=10的记录，也就杜绝了同一事务的第二次当前读，出现幻象的情况。<br>有心的朋友看到这儿，可以会问：既然防止幻读，需要靠GAP锁的保护，为什么组合五、组合六，也是RR隔离级别，却不需要加GAP锁呢？<br>首先，这是一个好问题。其次，回答这个问题，也很简单。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。而组合五，id是主键；组合六，id是unique键，都能够保证唯一性。一个等值查询，最多只能返回一条记录，而且新的相同取值的记录，一定不会在新插入进来，因此也就避免了GAP锁的使用。其实，针对此问题，还有一个更深入的问题：如果组合五、组合六下，针对SQL：select * from t1 where id = 10 for update; 第一次查询，没有找到满足查询条件的记录，那么GAP锁是否还能够省略？此问题留给大家思考。<br><strong>结论：Repeatable Read隔离级别下，id列上有一个非唯一索引，对应SQL：delete from t1 where id = 10; 首先，通过id索引定位到第一条满足查询条件的记录，加记录上的X锁，加GAP上的GAP锁，然后加主键聚簇索引上的记录X锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录X锁，但是仍旧需要加GAP锁，最后返回结束。</strong><br><strong>什么时候会取得gap lock或nextkey lock 这和隔离级别有关,只在REPEATABLE READ或以上的隔离级别下的特定操作才会取得gap lock或nextkey lock。</strong></p>
<h3 id="组合八：id无索引-RR"><a href="#组合八：id无索引-RR" class="headerlink" title="组合八：id无索引+RR"></a>组合八：id无索引+RR</h3><p>组合八，Repeatable Read隔离级别下的最后一种情况，id列上没有索引。此时SQL：delete from t1 where id = 10; 没有其他的路径可以选择，只能进行全表扫描。最终的加锁情况，如下图所示：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194618-de6cf.jpeg" alt="img"></p>
<p>如图，这是一个很恐怖的现象。首先，聚簇索引上的所有记录，都被加上了X锁。其次，聚簇索引每条记录间的间隙(GAP)，也同时被加上了GAP锁。这个示例表，只有6条记录，一共需要6个记录锁，7个GAP锁。试想，如果表上有1000万条记录呢？<br>在这种情况下，这个表上，除了不加锁的快照度，其他任何加锁的并发SQL，均不能执行，不能更新，不能删除，不能插入，全表被锁死。<br>当然，跟组合四：[<a href="https://link.juejin.im?target=http%3A%2F%2Fhedengcheng.com%2F%3Fp%3D771%23_%E7%BB%84%E5%90%88%E5%9B%9B%EF%BC%9Aid%E6%97%A0%E7%B4%A2%E5%BC%95%2BRC">id无索引, Read Committed</a>]类似，这个情况下，MySQL也做了一些优化，就是所谓的semi-consistent read。semi-consistent read开启的情况下，对于不满足查询条件的记录，MySQL会提前放锁。针对上面的这个用例，就是除了记录[d,10]，[g,10]之外，所有的记录锁都会被释放，同时不加GAP锁。semi-consistent read如何触发：要么是read committed隔离级别；要么是Repeatable Read隔离级别，同时设置了<a href="https://link.juejin.im?target=http%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.5%2Fen%2Finnodb-parameters.html">innodb_locks_unsafe_for_binlog</a> 参数。更详细的关于semi-consistent read的介绍，可参考我之前的一篇博客：<a href="https://link.juejin.im?target=http%3A%2F%2Fhedengcheng.com%2F%3Fp%3D220">MySQL+InnoDB semi-consitent read原理及实现分析</a> 。<br><strong>结论：在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新/删除/插入 操作。当然，也可以通过触发semi-consistent read，来缓解加锁开销与并发影响，但是semi-consistent read本身也会带来其他问题，不建议使用。</strong></p>
<h3 id="组合九：Serializable"><a href="#组合九：Serializable" class="headerlink" title="组合九：Serializable"></a>组合九：Serializable</h3><p>针对前面提到的简单的SQL，最后一个情况：Serializable隔离级别。对于SQL2：delete from t1 where id = 10; 来说，Serializable隔离级别与Repeatable Read隔离级别完全一致，因此不做介绍。<br>Serializable隔离级别，影响的是SQL1：select * from t1 where id = 10; 这条SQL，在RC，RR隔离级别下，都是快照读，不加锁。但是在Serializable隔离级别，SQL1会加读锁，也就是说快照读不复存在，MVCC并发控制降级为Lock-Based CC。<br><strong>结论：在MySQL/InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读。</strong></p>
<h2 id="五、死锁案例"><a href="#五、死锁案例" class="headerlink" title="五、死锁案例"></a>五、死锁案例</h2><h3 id="1-不同表相同记录行锁冲突"><a href="#1-不同表相同记录行锁冲突" class="headerlink" title="1. 不同表相同记录行锁冲突"></a>1. 不同表相同记录行锁冲突</h3><p>这种情况很好理解，事务A和事务B操作两张表，但出现循环等待锁情况。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194618-5c095.png" alt="img"></p>
<h3 id="2-相同表记录行锁冲突"><a href="#2-相同表记录行锁冲突" class="headerlink" title="2. 相同表记录行锁冲突"></a>2. 相同表记录行锁冲突</h3><p>这种情况比较常见，之前遇到两个job在执行数据批量更新时，jobA处理的的id列表为[1,2,3,4]，而job处理的id列表为[8,9,10,4,2]，这样就造成了死锁。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194618-a8e69.png" alt="img"></p>
<h3 id="3-不同索引锁冲突"><a href="#3-不同索引锁冲突" class="headerlink" title="3. 不同索引锁冲突"></a>3. 不同索引锁冲突</h3><p>这种情况比较隐晦，事务A在执行时，除了在二级索引加锁外，还会在聚簇索引上加锁，在聚簇索引上加锁的顺序是[1,4,2,3,5]，而事务B执行时，只在聚簇索引上加锁，加锁顺序是[1,2,3,4,5]，这样就造成了死锁的可能性。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194619-b0144.png" alt="img"></p>
<h3 id="4-gap锁冲突"><a href="#4-gap锁冲突" class="headerlink" title="4. gap锁冲突"></a>4. gap锁冲突</h3><p>innodb在RR级别下，如下的情况也会产生死锁，比较隐晦。不清楚的同学可以自行根据上节的gap锁原理分析下。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194619-5e115.png" alt="img"></p>
<h2 id="六、如何尽可能避免死锁"><a href="#六、如何尽可能避免死锁" class="headerlink" title="六、如何尽可能避免死锁"></a>六、如何尽可能避免死锁</h2><ol>
<li>以固定的顺序访问表和行。比如对第2节两个job批量更新的情形，简单方法是对id列表先排序，后执行，这样就避免了交叉等待锁的情形；又比如对于3.1节的情形，将两个事务的sql顺序调整为一致，也能避免死锁。</li>
<li>大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。</li>
<li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。</li>
<li>降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。</li>
<li>为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。=</li>
</ol>
<h2 id="七、如何查看锁"><a href="#七、如何查看锁" class="headerlink" title="七、如何查看锁"></a>七、如何查看锁</h2><p>从InnoDB1.0开始，在INFORMATION_SCHEMA架构下添加了表INNODB_TRX、INNODB_LOCKS、INNODB_LOCK_WAITS。（详情见附录）通过这三张表，用户可以更简单地监控当前事务并分析可能存在的锁问题。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#全局分析系统上中行锁的争夺情况</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'innodb_row_lock%'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#查看事务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.INNODB_TRX;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#查看锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.INNODB_LOCKS;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#查看锁等待情况</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.INNODB_LOCK_WAITS;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#通过联合查询可以比较直观的查看哪个事务阻塞了哪个事务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> r.trx_id              <span class="string">'等待事务ID'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       r.trx_mysql_thread_id <span class="string">'等待线程ID'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       r.trx_query           <span class="string">'等待事务运行语句'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       b.trx_id              <span class="string">'阻塞事务ID'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       b.trx_mysql_thread_id <span class="string">'阻塞线程ID'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       b.trx_query           <span class="string">'阻塞事务运行语句'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> information_schema.innodb_lock_waits w</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">INNER</span> <span class="keyword">JOIN</span> information_schema.innodb_trx b</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">ON</span> b.trx_id = w.blocking_trx_id</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">INNER</span> <span class="keyword">JOIN</span> information_schema.innodb_trx r</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">ON</span> r.trx_id = w.requesting_trx_id;</span></pre></td></tr></table></figure>

<h2 id="八、mysql是如何预防死锁的？"><a href="#八、mysql是如何预防死锁的？" class="headerlink" title="八、mysql是如何预防死锁的？"></a>八、mysql是如何预防死锁的？</h2><h3 id="innodb-lock-wait-timeout-等待锁超时回滚事务"><a href="#innodb-lock-wait-timeout-等待锁超时回滚事务" class="headerlink" title="innodb_lock_wait_timeout 等待锁超时回滚事务"></a>innodb_lock_wait_timeout 等待锁超时回滚事务</h3><p>直观方法是在两个事务相互等待时，当一个等待时间超过设置的某一阀值时，对其中一个事务进行回滚，另一个事务就能继续执行。</p>
<h3 id="wait-for-graph算法来主动进行死锁检测"><a href="#wait-for-graph算法来主动进行死锁检测" class="headerlink" title="wait-for graph算法来主动进行死锁检测"></a>wait-for graph算法来主动进行死锁检测</h3><p>每当加锁请求无法立即满足需要并进入等待时，wait-for graph算法都会被触发。<br>wait-for graph要求数据库保存以下两种信息：</p>
<ul>
<li>锁的信息链表</li>
<li>事务等待链表</li>
</ul>
<p>通过上述链表可以构造出一张图，而在这个图中若存在回路，就代表存在死锁，因此资源间相互发生等待。在wait-for graph中，事务为图中的节点。而在图中，事务T1指向T2边的定义为：</p>
<ul>
<li>事务T1等待事务T2所占用的资源</li>
<li>事务T1最终等待T2所占用的资源，也就是事务之间在等待相同的资源，而事务T1发生在事务T2的后面</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829194619-3a057.jpeg" alt="img"></p>
<p>示例事务状态和锁的信息<br>在Transaction Wait Lists中可以看到共有4个事务t1、t2、t3、t4，故在wait-for graph中应有4个节点。而事务t2对row1占用x锁，事务t1对row2占用s锁。事务t1需要等待事务t2中row1的资源，因此在wait-for graph中有条边从节点t1指向节点t2。事务t2需要等待事务t1、t4所占用的row2对象，故而存在节点t2到节点t1、t4的边。同样，存在节点t3到节点t1、t2、t4的边，因此最终的wait-for graph如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194619-bc75d.jpeg" alt="img"></p>
<p>ps:若存在则有死锁，通常来说InnoDB存储引擎选择回滚undo量最小的事务并从新开始</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="INNODB-ROW-LOCK"><a href="#INNODB-ROW-LOCK" class="headerlink" title="INNODB_ROW_LOCK"></a>INNODB_ROW_LOCK</h3><table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>innodb_row_lock_current_waits</td>
<td>当前正在等待锁定的数量</td>
</tr>
<tr>
<td><strong>innodb_row_lock_time</strong></td>
<td>从系统启动到现在锁定总时间长度</td>
</tr>
<tr>
<td><strong>innodb_row_lock_time_avg</strong></td>
<td>每次等待所花平均时间</td>
</tr>
<tr>
<td>innodb_row_lock_time_max</td>
<td>从系统启动到现在等待最常的一次所花的时间</td>
</tr>
<tr>
<td><strong>innodb_row_lock_waits</strong></td>
<td>系统启动后到现在总共等待的次数；直接决定优化的方向和策略</td>
</tr>
</tbody></table>
<h3 id="INNODB-TRX"><a href="#INNODB-TRX" class="headerlink" title="INNODB_TRX"></a>INNODB_TRX</h3><p>提供有关当前正在内部执行的每个事务的信息 InnoDB，包括事务是否在等待锁定，事务何时启动以及事务正在执行的SQL语句（如果有）。详见<a href="https://link.juejin.im?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Finnodb-trx-table.html">dev.mysql.com/doc/refman/…</a></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>TRX_ID</strong></td>
<td><a href="https://link.juejin.im?target=http%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Finnodb-performance-ro-txn.html">事务Id</a></td>
</tr>
<tr>
<td><strong>TRX_WEIGHT</strong></td>
<td>事务的权重，反映（但不一定是确切的计数）更改的行数和事务锁定的行数。要解决死锁，请 InnoDB``选择权重最小的事务作为回滚的“ 受害者 ”。无论更改和锁定行的数量如何，已更改非事务表的事务都被认为比其他事务更重。</td>
</tr>
<tr>
<td><strong>TRX_STATE</strong></td>
<td>事务执行状态。允许值是 RUNNING<code>，LOCK WAIT</code>， ROLLING BACK<code>，和 COMMITTING</code>。</td>
</tr>
<tr>
<td>TRX_STARTED</td>
<td>交易开始时间。</td>
</tr>
<tr>
<td><strong>TRX_REQUESTED_LOCK_ID</strong></td>
<td>事务当前正在等待的锁的ID，如果TRX_STATE<code>是LOCK WAIT</code>; 否则NULL``。</td>
</tr>
<tr>
<td><strong>TRX_WAIT_STARTED</strong></td>
<td>交易开始等待锁定的时间，如果 TRX_STATE<code>是LOCK WAIT</code>; 否则NULL``。</td>
</tr>
<tr>
<td><strong>TRX_MYSQL_THREAD_ID</strong></td>
<td>MySQL线程ID，与show processlist中的ID值相对应</td>
</tr>
<tr>
<td><strong>TRX_QUERY</strong></td>
<td>事务正在执行的SQL语句</td>
</tr>
<tr>
<td>TRX_OPERATION_STATE</td>
<td>交易的当前操作，如果有的话; 否则 NULL``。</td>
</tr>
<tr>
<td>TRX_TABLES_IN_USE</td>
<td>InnoDB``处理此事务的当前SQL语句时使用 的表数。</td>
</tr>
<tr>
<td>TRX_TABLES_LOCKED</td>
<td>InnoDB``当前SQL语句具有行锁定 的表的数量。（因为这些是行锁，而不是表锁，所以通常仍可以通过多个事务读取和写入表，尽管某些行被锁定。）</td>
</tr>
<tr>
<td>TRX_LOCK_STRUCTS</td>
<td>事务保留的锁数。</td>
</tr>
<tr>
<td>TRX_LOCK_MEMORY_BYTES</td>
<td>内存中此事务的锁结构占用的总大小</td>
</tr>
<tr>
<td>TRX_ROWS_LOCKED</td>
<td>此交易锁定的大致数字或行数。该值可能包括实际存在但对事务不可见的删除标记行</td>
</tr>
<tr>
<td>TRX_ROWS_MODIFIED</td>
<td>此事务中已修改和插入的行数。</td>
</tr>
<tr>
<td>TRX_CONCURRENCY_TICKETS</td>
<td>一个值，指示当前事务在被换出之前可以执行多少工作</td>
</tr>
<tr>
<td>TRX_ISOLATION_LEVEL</td>
<td>当前事务的隔离级别。</td>
</tr>
<tr>
<td>TRX_UNIQUE_CHECKS</td>
<td>是否为当前事务打开或关闭唯一检查。例如，在批量数据加载期间可能会关闭它们</td>
</tr>
<tr>
<td>TRX_FOREIGN_KEY_CHECKS</td>
<td>是否为当前事务打开或关闭外键检查。例如，在批量数据加载期间可能会关闭它们</td>
</tr>
<tr>
<td>TRX_LAST_FOREIGN_KEY_ERROR</td>
<td>最后一个外键错误的详细错误消息（如果有）; 否则NULL``</td>
</tr>
<tr>
<td>TRX_ADAPTIVE_HASH_LATCHED</td>
<td>自适应哈希索引是否被当前事务锁定。当自适应哈希索引搜索系统被分区时，单个事务不会锁定整个自适应哈希索引。自适应哈希索引分区由<a href="https://link.juejin.im?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Finnodb-parameters.html%23sysvar_innodb_adaptive_hash_index_parts">innodb_adaptive_hash_index_parts``</a>，默认设置为8。</td>
</tr>
<tr>
<td>TRX_ADAPTIVE_HASH_TIMEOUT</td>
<td>是否立即为自适应哈希索引放弃搜索锁存器，或者在MySQL的调用之间保留它。当没有自适应哈希索引争用时，该值保持为零，语句保留锁存器直到它们完成。在争用期间，它倒计时到零，并且语句在每次行查找后立即释放锁存器。当自适应散列索引搜索系统被分区（受控制 <a href="https://link.juejin.im?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Finnodb-parameters.html%23sysvar_innodb_adaptive_hash_index_parts">innodb_adaptive_hash_index_parts``</a>）时，该值保持为0。</td>
</tr>
<tr>
<td>TRX_IS_READ_ONLY</td>
<td>值为1表示事务是只读的。</td>
</tr>
<tr>
<td>TRX_AUTOCOMMIT_NON_LOCKING</td>
<td>值为1表示事务是 <a href="https://link.juejin.im?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Fserver-system-variables.html%23sysvar_autocommit">SELECT<code>](https://dev.mysql.com/doc/refman/5.7/en/select.html)不使用FOR UPDATE</code>or或 LOCK IN SHARED MODE<code>子句的语句，并且正在执行， [autocommit</code></a>因此事务将仅包含此一个语句。当此列和TRX_IS_READ_ONLY<code>都为1时，InnoDB</code>优化事务以减少与更改表数据的事务关联的开销</td>
</tr>
</tbody></table>
<h3 id="INNODB-LOCKS"><a href="#INNODB-LOCKS" class="headerlink" title="INNODB_LOCKS"></a>INNODB_LOCKS</h3><p>提供有关InnoDB 事务已请求但尚未获取的每个锁的信息，以及事务持有的阻止另一个事务的每个锁。详见<a href="https://link.juejin.im?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Finnodb-locks-table.html">dev.mysql.com/doc/refman/…</a></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>LOCK_ID</td>
<td>一个唯一的锁ID号，内部为 InnoDB``。</td>
</tr>
<tr>
<td>LOCK_TRX_ID</td>
<td>持有锁的交易的ID</td>
</tr>
<tr>
<td>LOCK_MODE</td>
<td>如何请求锁定。允许锁定模式描述符 S<code>，X</code>， IS<code>，IX</code>， GAP<code>，AUTO_INC</code>，和 UNKNOWN``。锁定模式描述符可以组合使用以识别特定的锁定模式。</td>
</tr>
<tr>
<td>LOCK_TYPE</td>
<td>锁的类型</td>
</tr>
<tr>
<td>LOCK_TABLE</td>
<td>已锁定或包含锁定记录的表的名称</td>
</tr>
<tr>
<td>LOCK_INDEX</td>
<td>索引的名称，如果LOCK_TYPE是 RECORD; 否则NULL</td>
</tr>
<tr>
<td>LOCK_SPACE</td>
<td>锁定记录的表空间ID，如果 LOCK_TYPE<code>是RECORD</code>; 否则NULL``</td>
</tr>
<tr>
<td>LOCK_PAGE</td>
<td>锁定记录的页码，如果 LOCK_TYPE<code>是RECORD</code>; 否则NULL``。</td>
</tr>
<tr>
<td>LOCK_REC</td>
<td>页面内锁定记录的堆号，如果 LOCK_TYPE<code>是RECORD</code>; 否则NULL``。</td>
</tr>
<tr>
<td>LOCK_DATA</td>
<td>与锁相关的数据（如果有）。如果 LOCK_TYPE<code>是RECORD</code>，是锁定的记录的主键值，否则NULL<code>。此列包含锁定行中主键列的值，格式为有效的SQL字符串。如果没有主键，LOCK_DATA</code>则是唯一的InnoDB<code>内部行ID号。如果对键值或范围高于索引中的最大值的间隙锁定，则LOCK_DATA</code> 报告<em>supremum</em> <em>pseudo-record</em>。当包含锁定记录的页面不在缓冲池中时（如果在保持锁定时将其分页到磁盘），InnoDB<code>不从磁盘获取页面，以避免不必要的磁盘操作。相反， LOCK_DATA</code>设置为 NULL``。</td>
</tr>
</tbody></table>
<h3 id="INNODB-LOCK-WAITS"><a href="#INNODB-LOCK-WAITS" class="headerlink" title="INNODB_LOCK_WAITS"></a>INNODB_LOCK_WAITS</h3><p>包含每个被阻止InnoDB 事务的一个或多个行，指示它已请求的锁以及阻止该请求的任何锁。详见<a href="https://link.juejin.im?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Finnodb-lock-waits-table.html">dev.mysql.com/doc/refman/…</a></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>REQUESTING_TRX_ID</td>
<td>请求（阻止）事务的ID。</td>
</tr>
<tr>
<td>REQUESTED_LOCK_ID</td>
<td>事务正在等待的锁的ID。</td>
</tr>
<tr>
<td>BLOCKING_TRX_ID</td>
<td>阻止事务的ID。</td>
</tr>
<tr>
<td>BLOCKING_LOCK_ID</td>
<td>由阻止另一个事务继续进行的事务所持有的锁的ID</td>
</tr>
</tbody></table>
<h2 id="引用文献"><a href="#引用文献" class="headerlink" title="引用文献"></a>引用文献</h2><p>《MySQL技术内幕：InnoDB存储引擎》<br><a href="https://link.juejin.im?target=http%3A%2F%2Fhedengcheng.com%2F%3Fp%3D771">何登成MySQL 加锁处理分析</a><br><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fcrazylqy%2Fp%2F7611069.html">Mysql加锁过程详解</a><br><a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fyuyinghua0302%2Farticle%2Fdetails%2F82318408">数据库事务和锁（三）</a><br><a href="https://juejin.im/post/5d04b33e6fb9a07ee1692653#heading-7" target="_blank" rel="noopener">针对MySQL死锁问题的思路分析</a></p>
<blockquote>
<p>作者：白山丶</p>
<p>来源：<a href="https://juejin.im/post/5d3e8b63f265da1bce3e1988" target="_blank" rel="noopener">https://juejin.im/post/5d3e8b63f265da1bce3e1988</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>git操作（13）：remote</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%8813%EF%BC%89%EF%BC%9Aremote/</url>
    <content><![CDATA[<p>git是分布式版本管理工具，它没有中央仓库。但多人协作时，我们依然需要一个集散地，让协作成员之间统一往集散地推送和拉取更新。否则，点对点的沟通，效率会很低。<br>所以就引出了git中远端仓库的概念。</p>
<a id="more"></a>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>我们之前所有的操作都是在本地仓库完成的，和本地仓库对应的是远端仓库。那么本地有若干分支，远端仓库是不是也有对应的若干分支呢？<br>当然。<br>我们探讨一个问题，在离线状态下，git是不是无从知道远端仓库的任何状态？<br>我让网络下线，查询从github克隆下来的本地仓库的状态，结果它告诉我本地仓库的master分支是<code>up to date with &#39;origin/master&#39;</code>。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Your branch <span class="keyword">is</span> up <span class="keyword">to</span> <span class="type">date</span> <span class="keyword">with</span> <span class="string">'origin/master'</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">nothing</span> <span class="keyword">to</span> <span class="keyword">commit</span>, working tree clean</span></pre></td></tr></table></figure>

<p>实际上，git的分支有三种：</p>
<ul>
<li>本地分支，我们可以通过``写法访问它。</li>
<li>远端分支，我们可以通过``写法访问它。</li>
<li>远端分支引用，我们可以通过``写法访问它。实际上它也是本地分支，只不过我们无法操作它，只有git的网络操作才可以更新它。离线状态下，git给的状态就是本地分支和远端分支引用的比较结果。</li>
</ul>
<blockquote>
<p>git官方把我所说的<code>远端分支引用</code>称为<code>远端分支</code>。知道谁是谁就行了，名字不重要🤔<br>我是马蹄疾</p>
</blockquote>
<p>我们看一下本地的远端分支引用。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">.git/</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git<span class="meta-keyword">/refs/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">.git<span class="meta-keyword">/refs/</span>remotes/</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git<span class="meta-keyword">/refs/</span>remotes<span class="meta-keyword">/origin/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">.git<span class="meta-keyword">/refs/</span>remotes<span class="meta-keyword">/origin/</span>HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git<span class="meta-keyword">/refs/</span>remotes<span class="meta-keyword">/origin/</span>master</span></pre></td></tr></table></figure>

<p>默认的远端仓库名就叫<code>origin</code>。它也有master分支指针，也有HEAD指针。</p>
<h2 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h2><p>如果远端仓库有新的提交或者新的分支，我们需要运行<code>git fetch</code>命令来拉取更新。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git fetch</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Enumerating objects: <span class="number">5</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Counting objects: <span class="number">100</span>% (<span class="number">5</span>/<span class="number">5</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>), pack-reused <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Unpacking objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">From github.com:veedrin/git</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">3893459.</span><span class="number">.0f</span>80eeb  master     -&gt; origin/master</span></pre></td></tr></table></figure>

<p>这个命令是<code>git fetch origin</code>的缩写。因为<code>origin</code>是远端仓库的默认名称，所以可以省略。如果有手动添加的远端仓库，那就必须指定远端仓库的名称了。<br>这个命令做了什么呢？<br>它会把新的提交和新的分支拉取到本地，然后更新本地的远端分支引用到最新的提交。<br><code>git fetch</code>仅仅是将远端的更新拉取下来，同步本地的远端分支引用，不会对本地分支有任何影响。我们需要手动执行合并操作才能更新本地分支。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">merge</span> origin/<span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Your branch <span class="keyword">is</span> up <span class="keyword">to</span> <span class="built_in">date</span> <span class="keyword">with</span> <span class="string">'origin/master'</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">nothing</span> <span class="keyword">to</span> <span class="keyword">commit</span>, working tree clean</span></pre></td></tr></table></figure>

<p>当然，有一个更简单的操作。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git pull</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Enumerating objects: <span class="number">5</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Counting objects: <span class="number">100</span>% (<span class="number">5</span>/<span class="number">5</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Unpacking objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>), pack-reused <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">From github.com:veedrin/git</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">4f</span>bd1d4..d9785d7  master     -&gt; origin/master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Updating <span class="number">4f</span>bd1d4..d9785d7</span></pre></td></tr><tr><td class="code"><pre><span class="line">Fast-forward</span></pre></td></tr><tr><td class="code"><pre><span class="line"> README.md | <span class="number">2</span> ++</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">2</span> insertions(+)</span></pre></td></tr></table></figure>

<p><code>git pull</code>就是<code>git fetch</code>和<code>git merge</code>的一键操作。</p>
<h2 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h2><p>推送到远端的命令是<code>git push</code>。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Counting objects: <span class="number">3</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="number">261</span> bytes | <span class="number">261.00</span> KiB/s, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">To github.com:veedrin/git.git</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">3</span>eaa1ae.<span class="number">.2</span>bd3c9d  master -&gt; master</span></pre></td></tr></table></figure>

<p>如果当前分支对远端分支设置了追踪的话，也可以省略分支名。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git push</span></pre></td></tr><tr><td class="code"><pre><span class="line">Counting objects: <span class="number">3</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="number">261</span> bytes | <span class="number">261.00</span> KiB/s, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">To github.com:veedrin/git.git</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">3</span>eaa1ae.<span class="number">.2</span>bd3c9d  master -&gt; master</span></pre></td></tr></table></figure>

<p>有时候本地分支和远端分支同时有新的提交，直接<code>push</code>是不行的。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git push</span></pre></td></tr><tr><td class="code"><pre><span class="line">To github.<span class="keyword">com</span>:veedrin/git.git</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ! [rejected]        master -&gt; master (fetch <span class="keyword">first</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">error: failed <span class="keyword">to</span> push some refs <span class="keyword">to</span> <span class="string">'git@github.com:veedrin/git.git'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">hin<span class="variable">t:</span> Updates were rejected because the remote contains work that you <span class="keyword">do</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">hin<span class="variable">t:</span> not have locally. This <span class="keyword">is</span> usually caused by another repository pushing</span></pre></td></tr><tr><td class="code"><pre><span class="line">hin<span class="variable">t:</span> <span class="keyword">to</span> the same ref. You may want <span class="keyword">to</span> <span class="keyword">first</span> integrate the remote <span class="keyword">changes</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">hin<span class="variable">t:</span> (<span class="keyword">e</span>.g., <span class="string">'git pull ...'</span>) before pushing again.</span></pre></td></tr><tr><td class="code"><pre><span class="line">hin<span class="variable">t:</span> See the <span class="string">'Note about fast-forwards'</span> in <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span></pre></td></tr></table></figure>

<p>有两种方式解决。<br>第一是先把远端的更新拉下来，有冲突则解决冲突，没冲突则再推送。<br>第二是强推。有时候我们就是想覆盖远端对吧，也不是不行，但是必须十分谨慎。而且不要在公共分支上强制推送。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git push -f</span></pre></td></tr><tr><td class="code"><pre><span class="line">Counting objects: <span class="number">24</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Delta compression using up to <span class="number">4</span> threads.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">8</span>/<span class="number">8</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">24</span>/<span class="number">24</span>), <span class="number">3.72</span> KiB | <span class="number">1.24</span> MiB/s, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="number">24</span> (delta <span class="number">0</span>), reused <span class="number">3</span> (delta <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">To github.com:veedrin/git.git</span></pre></td></tr><tr><td class="code"><pre><span class="line"> + <span class="number">54</span>d741b..<span class="number">.2</span>db10e0 master -&gt; master (forced update)</span></pre></td></tr></table></figure>

<p>实际开发时我们会建很多特性分支，推送到远端，通过测试后再合入主分支。使用<code>git push</code>每次都要指定远端分支名，如果会有多次推送，我们可以在推送时设置本地分支追踪远端分支，这样下次就可以直接推送了。<br>也可以简写成<code>git push -u</code>。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git push --<span class="keyword">set</span>-upstream origin dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Counting object<span class="variable">s:</span> <span class="number">3</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Delta compression using <span class="keyword">up</span> <span class="keyword">to</span> <span class="number">4</span> threads.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Compressing object<span class="variable">s:</span> <span class="number">100</span>% (<span class="number">2</span>/<span class="number">2</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Writing object<span class="variable">s:</span> <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="number">255</span> bytes | <span class="number">255.00</span> KiB/s, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote:</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Create <span class="keyword">a</span> pull request <span class="keyword">for</span> <span class="string">'dev'</span> <span class="keyword">on</span> GitHub by visitin<span class="variable">g:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">remote:      http<span class="variable">s:</span>//github.<span class="keyword">com</span>/veedrin/git/pull/<span class="keyword">new</span>/dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote:</span></pre></td></tr><tr><td class="code"><pre><span class="line">To github.<span class="keyword">com</span>:veedrin/git.git</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * [<span class="keyword">new</span> branch]      dev -&gt; dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Branch <span class="string">'dev'</span> <span class="keyword">set</span> <span class="keyword">up</span> <span class="keyword">to</span> track remote branch <span class="string">'dev'</span> from <span class="string">'origin'</span>.</span></pre></td></tr></table></figure>

<p>然后我们在<code>.git/config</code>文件中能看到多了一条配置。</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">[branch <span class="string">"dev"</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">remote</span> = origin</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">merge</span> = refs/heads/dev</span></pre></td></tr></table></figure>

<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>查看远端仓库的命令是<code>git remote</code>。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote</span></pre></td></tr><tr><td class="code"><pre><span class="line">origin</span></pre></td></tr></table></figure>

<p>加<code>-v</code>参数可以查看更为详细的信息，<code>-v</code>是<code>--verbose</code>的缩写。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span></pre></td></tr><tr><td class="code"><pre><span class="line">origin	git<span class="meta">@github</span>.<span class="string">com:</span>veedrin/git.git (fetch)</span></pre></td></tr><tr><td class="code"><pre><span class="line">origin	git<span class="meta">@github</span>.<span class="string">com:</span>veedrin/git.git (push)</span></pre></td></tr></table></figure>

<p>查看某个远端仓库的信息，可以使用命令<code>git remote show</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git remote <span class="keyword">show</span> origin</span></pre></td></tr><tr><td class="code"><pre><span class="line">* remote origin</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">Fetch</span> <span class="keyword">URL</span>: git@github.com:veedrin/git<span class="number">-1.</span>git</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Push  <span class="keyword">URL</span>: git@github.com:veedrin/git<span class="number">-1.</span>git</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">HEAD</span> branch: <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Remote branches:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dev    tracked</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">master</span> tracked</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">Local</span> branches configured <span class="keyword">for</span> <span class="string">'git pull'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dev    merges <span class="keyword">with</span> remote dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">master</span> merges <span class="keyword">with</span> remote <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">Local</span> refs configured <span class="keyword">for</span> <span class="string">'git push'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">master</span> pushes <span class="keyword">to</span> <span class="keyword">master</span> (up <span class="keyword">to</span> <span class="built_in">date</span>)</span></pre></td></tr></table></figure>

<h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><p>添加新的远端仓库，使用<code>git remote add</code>命令。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git remote <span class="built_in">add</span> horseshoe http<span class="variable">s:</span>//github.<span class="keyword">com</span>/veedrin/horseshoe</span></pre></td></tr></table></figure>

<p>然后本地就多了一个远端仓库。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote</span></pre></td></tr><tr><td class="code"><pre><span class="line">horseshoe</span></pre></td></tr><tr><td class="code"><pre><span class="line">origin</span></pre></td></tr></table></figure>

<p>除了添加远端仓库，我们还可以添加本地分支对远端分支的追踪。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Branch <span class="string">'dev'</span> <span class="built_in">set</span> up <span class="built_in">to</span> track remote branch <span class="string">'dev'</span> <span class="built_in">from</span> <span class="string">'origin'</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched <span class="built_in">to</span> <span class="keyword">a</span> <span class="built_in">new</span> branch <span class="string">'dev'</span></span></pre></td></tr></table></figure>

<p>创建dev分支的同时，也设置了对远端分支dev的追踪，这样下次推送的时候就不需要指定了。<br>当然，远端分支引用必须得存在才行。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">fatal: <span class="string">'origin/dev'</span> is <span class="keyword">not</span> <span class="keyword">a</span> commit <span class="keyword">and</span> <span class="keyword">a</span> branch <span class="string">'dev'</span> cannot be created <span class="built_in">from</span> <span class="keyword">it</span></span></pre></td></tr></table></figure>

<p>git也提供了快捷方式。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git checkout <span class="comment">--track origin/dev</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Branch <span class="string">'dev'</span> <span class="built_in">set</span> up <span class="built_in">to</span> track remote branch <span class="string">'dev'</span> <span class="built_in">from</span> <span class="string">'origin'</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched <span class="built_in">to</span> <span class="keyword">a</span> <span class="built_in">new</span> branch <span class="string">'dev'</span></span></pre></td></tr></table></figure>

<h2 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h2><p>有时候你想修改远端仓库的简写名。比如你将女朋友的名字命名为远端仓库的简写名，然后你们分手了。这真是一个令人悲伤(欣喜)的故事。</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">$ git remote <span class="built_in">rename</span> nvpengyou gaoyuanyuan</span></pre></td></tr></table></figure>

<p>查看远端仓库列表。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote</span></pre></td></tr><tr><td class="code"><pre><span class="line">gaoyuanyuan</span></pre></td></tr><tr><td class="code"><pre><span class="line">origin</span></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>一般来说，一个git项目有一个远端仓库就行了，其余的大多是临时性的。所以总有一天要删除它。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote rm horseshoe</span></pre></td></tr></table></figure>

<p>查看远端仓库列表。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote</span></pre></td></tr><tr><td class="code"><pre><span class="line">origin</span></pre></td></tr></table></figure>

<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/remote.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/remote.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（12）：tag</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%8812%EF%BC%89%EF%BC%9Atag/</url>
    <content><![CDATA[<p>git是一个版本管理工具，但在众多版本中，肯定有一些版本是比较重要的，这时候我们希望给这些特定的版本打上标签。比如发布一年以后，程序的各项功能都趋于稳定，可以在圣诞节发布<code>v1.0</code>版本。这个<code>v1.0</code>在git中就可以通过标签实现。<br>而git标签又分为两种，轻量级标签和含附注标签。</p>
<a id="more"></a>

<p>轻量级标签和分支的表现形式是一样的，仅仅是一个指向commit的指针而已。只不过它不能切换，一旦贴上就无法再挪动了。<br>含附注标签才是我们理解的那种标签，它是一个独立的git对象。包含标签的名字，电子邮件地址和日期，以及标签说明。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>创建轻量级标签的命令很简单，运行<code>git tag</code>。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">v0</span>.<span class="number">3</span></span></pre></td></tr></table></figure>

<p>在<code>.git</code>目录中就多了一个指针文件。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/<span class="built_in">ref</span>s/tags/v0<span class="number">.3</span></span></pre></td></tr></table></figure>

<p>创建含附注标签要加一个参数<code>-a</code>，它是<code>--annotated</code>的缩写。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> v1.<span class="number">0</span></span></pre></td></tr></table></figure>

<p>和<code>git commit</code>一样，如果不加<code>-m</code>参数，则会弹出默认或者自定义的编辑器，要求你写标签说明。<br>不写呢？</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">fatal: no <span class="keyword">tag</span> <span class="title">message</span>?</span></pre></td></tr></table></figure>

<p>创建完含附注标签后，<code>.git</code>目录会多出两个文件。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/<span class="built_in">ref</span>s/tags/v0<span class="number">.3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">80</span>/e79e91ce192e22a9fd860182da6649c4614ba1</span></pre></td></tr></table></figure>

<p>含附注标签不仅会创建一个指针，还会创建一个tag对象。<br>我们了解过git有四种对象类型，tag类型是我们认识的最后一种。<br>我们看看该对象的类型。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">cat</span>-<span class="keyword">file</span> -t <span class="number">80</span>e79e9</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">tag</span></span></pre></td></tr></table></figure>

<p>再来看看该对象的内容。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ git cat-file -p 80e79e9</span></pre></td></tr><tr><td class="code"><pre><span class="line">object 359fd95229532cd352aec43aada8e6cea68d87a9</span></pre></td></tr><tr><td class="code"><pre><span class="line">type commit</span></pre></td></tr><tr><td class="code"><pre><span class="line">tag v1.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">tagger veedrin &lt;veedrin@qq.com&gt; 1545878480 +0800</span></pre></td></tr><tr><td class="code"><pre><span class="line">版本 v1.0</span></pre></td></tr></table></figure>

<p>它关联的是一个commit对象，包含标签的名称，打标签的人，打标签的时间以及标签说明。<br>我可不可以给历史commit打标签呢？当然可以。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> v1.<span class="number">0</span> <span class="number">36</span>ff0f5</span></pre></td></tr></table></figure>

<p>只需在后面加上commit的校验和。</p>
<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>查看当前git项目的标签列表，运行<code>git tag</code>命令不带任何参数即可。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">v0.<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">v1.<span class="number">0</span></span></pre></td></tr></table></figure>

<p>注意git标签是按字母顺序排列的，而不是按时间顺序排列。<br>而且我并没有找到分别查看轻量级标签和含附注标签的方法。<br>查看标签详情可以使用<code>git show</code>。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git show v0<span class="number">.3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">36f</span>f0f58c8e6b6a441733e909dc95a6136a4f91b (tag: v0<span class="number">.3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Thu Dec <span class="number">27</span> <span class="number">11</span>:<span class="number">08</span>:<span class="number">09</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    add a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/a.md b/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">new file mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">0000000.</span>.e69de29</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git show v1<span class="number">.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">tag v1<span class="number">.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Tagger: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Thu Dec <span class="number">27</span> <span class="number">11</span>:<span class="number">08</span>:<span class="number">39</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">版本 v1<span class="number">.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">6</span>dfdb65ce65b782a6cb57566bcc1141923059d2b (HEAD -&gt; master, tag: v1<span class="number">.0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Thu Dec <span class="number">27</span> <span class="number">11</span>:<span class="number">08</span>:<span class="number">33</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    add b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/b.md b/b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">new file mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">0000000.</span>.e69de29</span></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>虽然git标签不能移动对吧，但我们可以删除它呀。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-d</span> v0.<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Deleted <span class="keyword">tag</span> <span class="title">'v0</span>.<span class="number">3</span>' (was <span class="number">36</span>ff0f5)</span></pre></td></tr><tr><td class="code"><pre><span class="line">如果标签已经推送到了远端，也是可以删除的。$ git push origin -d v0.<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">To github.com:veedrin/git.git</span></pre></td></tr><tr><td class="code"><pre><span class="line"> - [deleted]         v0.<span class="number">3</span></span></pre></td></tr></table></figure>

<h2 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h2><p>默认情况下，<code>git push</code>推送到远端仓库并不会将标签也推送上去。如果想将标签推送到远端与别人共享，我们得显式的运行命令<code>git push origin</code>。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git push origin v1<span class="number">.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Counting objects: <span class="number">1</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">1</span>/<span class="number">1</span>), <span class="number">160</span> bytes | <span class="number">160.00</span> KiB/s, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="number">1</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">To github.com:veedrin/git.git</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * [new tag]         v1<span class="number">.0</span> -&gt; v1<span class="number">.0</span></span></pre></td></tr></table></figure>

<p>这里并不区分轻量级标签和含附注标签。<br>一次性将本地标签推送到远端仓库也是可以的。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> --tags</span></pre></td></tr></table></figure>

<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/tag.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/tag.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（11）：position</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%8811%EF%BC%89%EF%BC%9Aposition/</url>
    <content><![CDATA[<p>程序遇到bug的时候，我们需要快速定位。<br>定位有两种，第一种是定位bug在哪个提交上，第二种是定位特定文件的某一行是谁最近提交的。</p>
<a id="more"></a>

<h2 id="bisect"><a href="#bisect" class="headerlink" title="bisect"></a>bisect</h2><p>有时候我们发现程序有bug，但是回退几个版本都不解决问题。说明这个bug是一次很老的提交导致的，也不知道当时怎么就没察觉。<br>那怎么办呢？继续一个一个版本的回退？<br>估计<code>Linus Torvalds</code>会鄙视你吧。<br>为了专注于工作，不分心来鄙视你，<code>Linus Torvalds</code>在git中内置了一套定位bug的命令。<br>大家都玩过猜数字游戏吧。主持人悄悄写下一个数，给大家一个数字区间，然后大家轮流开始切割，谁切到主持人写的那个数就要自罚三杯了。<br>对，这就是二分法。git利用二分法定位bug的命令是<code>git bisect</code>。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>假设目前的git项目历史是这样的。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span> -- <span class="built_in">C3</span> -- <span class="built_in">C4</span> -- <span class="built_in">C5</span> -- <span class="built_in">C6</span> -- <span class="built_in">C7</span> -- <span class="built_in">C8</span> -- <span class="built_in">C9</span>(HEAD -&gt; master)</span></pre></td></tr></table></figure>

<p>这里面有一次commit藏了一个bug，但幸运的是，你不知道是哪一次。<br>运行<code>git bisect start</code>命令，后跟你要定位的区间中最新的commit和最老的commit。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git bisect <span class="keyword">start</span> <span class="keyword">HEAD</span> C0</span></pre></td></tr><tr><td class="code"><pre><span class="line">Bisecting: <span class="number">4</span> revisions <span class="keyword">left</span> <span class="keyword">to</span> <span class="keyword">test</span> <span class="keyword">after</span> this (roughly <span class="number">2</span> steps)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[ee27077fdfc6c0c9281c1b7f6957ea2b59a461dd] C4</span></pre></td></tr></table></figure>

<p>然后你就发现HEAD指针自动的指向了<code>C4</code>commit。如果范围是奇数位，那取中间就行了，如果范围是偶数位，则取中间更偏老的那个commit，就比如这里的<code>C4</code>commit。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git bisect good</span></pre></td></tr><tr><td class="code"><pre><span class="line">Bisecting: <span class="number">2</span> revisions left to test after <span class="keyword">this</span> (roughly <span class="number">1</span> step)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">97</span>cc0e879dc09796bd56cfd7c3a54deb41e447f6] C6</span></pre></td></tr></table></figure>

<p>HEAD指针指向<code>C4</code>commit后，你应该运行一下程序，如果没问题，那说明有bug的提交在它之后。我们只需要告诉git当前commit以及更老的commit都是好的。<br>然后HEAD指针就自动指向<code>C6</code>commit。<br>继续在<code>C6</code>commit运行程序，结果复现了bug。说明问题就出在<code>C6</code>commit和<code>C4</code>commit之间。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">bisect </span><span class="keyword">bad</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Bisecting: </span><span class="number">0</span> <span class="keyword">revisions </span>left to test after this (roughly <span class="number">0</span> steps)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[a7e09bd3eab7d1e824c0338233f358cafa682af0] <span class="built_in">C5</span></span></pre></td></tr></table></figure>

<p>将<code>C6</code>commit标记为<code>bad</code>之后，HEAD指针自动指向<code>C5</code>commit。再次运行程序，依然能复现bug。话不多说，标记<code>C5</code>commit为<code>bad</code>。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git bisect <span class="keyword">bad</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">a7e09bd3eab7d1e824c0338233f358cafa682af0 <span class="keyword">is</span> the <span class="keyword">first</span> <span class="keyword">bad</span> commit</span></pre></td></tr></table></figure>

<p>因为<code>C4</code>commit和<code>C5</code>commit之间已经不需要二分了，git会告诉你，<code>C5</code>commit是你标记为<code>bad</code>的最早的commit。问题就应该出在<code>C5</code>commit上。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git bisect <span class="keyword">reset</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Previous <span class="keyword">HEAD</span> <span class="keyword">position</span> was a7e09bd... C5</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched <span class="keyword">to</span> branch <span class="string">'master'</span></span></pre></td></tr></table></figure>

<p>既然找到问题了，那就可以退出<code>git bisect</code>工具了。<br>另外，<code>git bisect old</code>和<code>git bisect good</code>的效果相同，<code>git bisect new</code>和<code>git bisect bad</code>的效果相同，这是因为git考虑到，有时候开发者并不是想定位bug，只是想定位某个commit，这时候用<code>good bad</code>就会有点别扭。</p>
<h3 id="后悔"><a href="#后悔" class="headerlink" title="后悔"></a>后悔</h3><p><code>git bisect</code>确实很强大，但如果我已经<code>bisect</code>若干次，结果不小心把一个<code>good</code>commit标记为<code>bad</code>，或者相反，难道我要<code>reset</code>重来么？<br><code>git bisect</code>还有一个<code>log</code>命令，我们只需要保存<code>bisect</code>日志到一个文件，然后擦除文件中标记错误的日志，然后按新的日志重新开始<code>bisect</code>就好了。</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">git bisect <span class="built_in">log</span> &gt; <span class="built_in">log</span>.txt</span></pre></td></tr></table></figure>

<p>该命令的作用是将日志保存到<code>log.txt</code>文件中。<br>看看<code>log.txt</code>文件中的内容。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"># bad: [<span class="number">4</span>d<span class="number">5e75</span><span class="keyword">c</span><span class="number">7</span>a<span class="number">9e6</span>e<span class="number">65</span>a<span class="number">168</span>d<span class="number">6</span>a<span class="number">2663e95</span>b<span class="number">19</span>da<span class="number">1e2</span>b<span class="number">21</span>] C<span class="number">9</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"># good: [<span class="keyword">c</span><span class="number">2</span>fa<span class="number">7</span>ca<span class="number">426</span>cac<span class="number">9990</span>ba<span class="number">27466520677</span>bf<span class="number">1780</span>af<span class="number">97</span>] <span class="keyword">add</span> a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">git bisect start 'HEAD' '<span class="keyword">c</span><span class="number">2</span>fa<span class="number">7</span>ca<span class="number">426</span>cac<span class="number">9990</span>ba<span class="number">27466520677</span>bf<span class="number">1780</span>af<span class="number">97</span>'</span></pre></td></tr><tr><td class="code"><pre><span class="line"># good: [ee<span class="number">27077</span>fdfc<span class="number">6</span><span class="keyword">c</span><span class="number">0</span><span class="keyword">c</span><span class="number">9281</span><span class="keyword">c</span><span class="number">1</span>b<span class="number">7</span>f<span class="number">6957</span>ea<span class="number">2</span>b<span class="number">59</span>a<span class="number">461</span>dd] C<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">git bisect good ee<span class="number">27077</span>fdfc<span class="number">6</span><span class="keyword">c</span><span class="number">0</span><span class="keyword">c</span><span class="number">9281</span><span class="keyword">c</span><span class="number">1</span>b<span class="number">7</span>f<span class="number">6957</span>ea<span class="number">2</span>b<span class="number">59</span>a<span class="number">461</span>dd</span></pre></td></tr><tr><td class="code"><pre><span class="line"># good: [<span class="number">97</span><span class="keyword">cc</span><span class="number">0e879</span>dc<span class="number">09796</span>bd<span class="number">56</span>cfd<span class="number">7</span><span class="keyword">c</span><span class="number">3</span>a<span class="number">54</span>deb<span class="number">41e447</span>f<span class="number">6</span>] C<span class="number">6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">git bisect good <span class="number">97</span><span class="keyword">cc</span><span class="number">0e879</span>dc<span class="number">09796</span>bd<span class="number">56</span>cfd<span class="number">7</span><span class="keyword">c</span><span class="number">3</span>a<span class="number">54</span>deb<span class="number">41e447</span>f<span class="number">6</span></span></pre></td></tr></table></figure>

<p>将标记错误的内容去掉。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"># bad: [<span class="number">4</span>d<span class="number">5e75</span><span class="keyword">c</span><span class="number">7</span>a<span class="number">9e6</span>e<span class="number">65</span>a<span class="number">168</span>d<span class="number">6</span>a<span class="number">2663e95</span>b<span class="number">19</span>da<span class="number">1e2</span>b<span class="number">21</span>] C<span class="number">9</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"># good: [<span class="keyword">c</span><span class="number">2</span>fa<span class="number">7</span>ca<span class="number">426</span>cac<span class="number">9990</span>ba<span class="number">27466520677</span>bf<span class="number">1780</span>af<span class="number">97</span>] <span class="keyword">add</span> a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">git bisect start 'HEAD' '<span class="keyword">c</span><span class="number">2</span>fa<span class="number">7</span>ca<span class="number">426</span>cac<span class="number">9990</span>ba<span class="number">27466520677</span>bf<span class="number">1780</span>af<span class="number">97</span>'</span></pre></td></tr><tr><td class="code"><pre><span class="line"># good: [ee<span class="number">27077</span>fdfc<span class="number">6</span><span class="keyword">c</span><span class="number">0</span><span class="keyword">c</span><span class="number">9281</span><span class="keyword">c</span><span class="number">1</span>b<span class="number">7</span>f<span class="number">6957</span>ea<span class="number">2</span>b<span class="number">59</span>a<span class="number">461</span>dd] C<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">git bisect good ee<span class="number">27077</span>fdfc<span class="number">6</span><span class="keyword">c</span><span class="number">0</span><span class="keyword">c</span><span class="number">9281</span><span class="keyword">c</span><span class="number">1</span>b<span class="number">7</span>f<span class="number">6957</span>ea<span class="number">2</span>b<span class="number">59</span>a<span class="number">461</span>dd</span></pre></td></tr></table></figure>

<p>然后运行<code>git bisect replay log.txt</code>命令。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">bisect </span>replay log.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">Previous</span> HEAD position was ad95ae3... <span class="built_in">C8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Switched </span>to <span class="keyword">branch </span><span class="string">'master'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Bisecting: </span><span class="number">4</span> <span class="keyword">revisions </span>left to test after this (roughly <span class="number">2</span> steps)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[ee27077fdfc6c0c9281c1b7f6957ea2b59a461dd] <span class="built_in">C4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Bisecting: </span><span class="number">2</span> <span class="keyword">revisions </span>left to test after this (roughly <span class="number">1</span> step)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">97</span>cc0e879dc09796bd56cfd7c3a54deb41e447f6] <span class="built_in">C6</span></span></pre></td></tr></table></figure>

<p>git会根据log从头开始重新<code>bisect</code>，错误的标记就被擦除了。<br>然后就是重新做人啦。</p>
<h2 id="blame"><a href="#blame" class="headerlink" title="blame"></a>blame</h2><p>一个充分协作的项目，每个文件可能都被多个人改动过。当出现问题的时候，大家希望快速的知道，某个文件的某一行是谁最后改动的，以便厘清责任。<br><code>git blame</code>就是这样一个命令。<code>blame</code>翻译成中文是<code>归咎于</code>，这个命令就是用来甩锅的。<br><code>git blame</code>只能作用于单个文件。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git blame a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">705</span>d9622 (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">09</span>:<span class="number">04</span> +<span class="number">0800</span> <span class="number">1</span>) 第一行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">74</span>eff2ee (abby <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">44</span> +<span class="number">0800</span> <span class="number">2</span>) 第二行</span></pre></td></tr><tr><td class="code"><pre><span class="line">a65b29bd (bob <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">17</span>:<span class="number">02</span> +<span class="number">0800</span> <span class="number">3</span>) 第三行</span></pre></td></tr><tr><td class="code"><pre><span class="line">ee27077f (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">05</span> +<span class="number">0800</span> <span class="number">4</span>) 第四行</span></pre></td></tr><tr><td class="code"><pre><span class="line">a7e09bd3 (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">19</span> +<span class="number">0800</span> <span class="number">5</span>) 第五行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">97</span>cc0e87 (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">21</span>:<span class="number">55</span> +<span class="number">0800</span> <span class="number">6</span>) 第六行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">67029</span>a81 (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">22</span>:<span class="number">15</span> +<span class="number">0800</span> <span class="number">7</span>) 第七行</span></pre></td></tr><tr><td class="code"><pre><span class="line">ad95ae3f (zhangsan <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">23</span>:<span class="number">20</span> +<span class="number">0800</span> <span class="number">8</span>) 第八行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span>d5e75c7 (lisi <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">23</span>:<span class="number">37</span> +<span class="number">0800</span> <span class="number">9</span>) 第九行</span></pre></td></tr></table></figure>

<p>它会把每一行的修改者信息都列出来。<br>第一部分是commit哈希值，表示这一行的最近一次修改属于该次提交。<br>第二部分是作者以及修改时间。<br>第三部分是行的内容。<br>如果文件太长，我们可以截取部分行。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git blame -L <span class="number">1</span>,<span class="number">5</span> a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">705</span>d9622 (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">09</span>:<span class="number">04</span> +<span class="number">0800</span> <span class="number">1</span>) 第一行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">74</span>eff2ee (abby <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">44</span> +<span class="number">0800</span> <span class="number">2</span>) 第二行</span></pre></td></tr><tr><td class="code"><pre><span class="line">a65b29bd (bob <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">17</span>:<span class="number">02</span> +<span class="number">0800</span> <span class="number">3</span>) 第三行</span></pre></td></tr><tr><td class="code"><pre><span class="line">ee27077f (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">05</span> +<span class="number">0800</span> <span class="number">4</span>) 第四行</span></pre></td></tr><tr><td class="code"><pre><span class="line">a7e09bd3 (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">19</span> +<span class="number">0800</span> <span class="number">5</span>) 第五行</span></pre></td></tr></table></figure>

<p>或者这样写。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git blame -L <span class="number">1</span>,+<span class="number">4</span> a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">705</span>d9622 (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">09</span>:<span class="number">04</span> +<span class="number">0800</span> <span class="number">1</span>) 第一行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">74</span>eff2ee (abby <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">44</span> +<span class="number">0800</span> <span class="number">2</span>) 第二行</span></pre></td></tr><tr><td class="code"><pre><span class="line">a65b29bd (bob <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">17</span>:<span class="number">02</span> +<span class="number">0800</span> <span class="number">3</span>) 第三行</span></pre></td></tr><tr><td class="code"><pre><span class="line">ee27077f (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">05</span> +<span class="number">0800</span> <span class="number">4</span>) 第四行</span></pre></td></tr></table></figure>

<p>但是结果不是你预期的那样是吧。<code>1,+4</code>的确切意思是从1开始，显示4行。<br>如果有人重名，可以显示邮箱来区分。添加参数<code>-e</code>或者<code>--show-email</code>即可。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git blame -e a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">705</span>d9622 (<span class="symbol">veedrin@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">09</span>:<span class="number">04</span> +<span class="number">0800</span> <span class="number">1</span>) 第一行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">74</span>eff2ee (<span class="symbol">abby@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">44</span> +<span class="number">0800</span> <span class="number">2</span>) 第二行</span></pre></td></tr><tr><td class="code"><pre><span class="line">a65b29bd (<span class="symbol">bob@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">17</span>:<span class="number">02</span> +<span class="number">0800</span> <span class="number">3</span>) 第三行</span></pre></td></tr><tr><td class="code"><pre><span class="line">ee27077f (<span class="symbol">veedrin@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">05</span> +<span class="number">0800</span> <span class="number">4</span>) 第四行</span></pre></td></tr><tr><td class="code"><pre><span class="line">a7e09bd3 (<span class="symbol">veedrin@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">19</span> +<span class="number">0800</span> <span class="number">5</span>) 第五行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">97</span>cc0e87 (<span class="symbol">veedrin@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">21</span>:<span class="number">55</span> +<span class="number">0800</span> <span class="number">6</span>) 第六行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">67029</span>a81 (<span class="symbol">veedrin@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">22</span>:<span class="number">15</span> +<span class="number">0800</span> <span class="number">7</span>) 第七行</span></pre></td></tr><tr><td class="code"><pre><span class="line">ad95ae3f (<span class="symbol">zhangsan@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">23</span>:<span class="number">20</span> +<span class="number">0800</span> <span class="number">8</span>) 第八行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span>d5e75c7 (<span class="symbol">lisi@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">23</span>:<span class="number">37</span> +<span class="number">0800</span> <span class="number">9</span>) 第九行</span></pre></td></tr></table></figure>

<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/position.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/position.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（10）：view</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%8810%EF%BC%89%EF%BC%9Aview/</url>
    <content><![CDATA[<p>有四个git命令可以用来查看git仓库相关信息。</p>
<a id="more"></a>

<h2 id="status"><a href="#status" class="headerlink" title="status"></a>status</h2><p><code>git status</code>命令的作用是同时展示工作区和暂存区的diff、暂存区和当前版本的diff、以及没有被git追踪的文件。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   <span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes not staged <span class="keyword">for</span> commi<span class="variable">t:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will <span class="keyword">be</span> committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard <span class="keyword">changes</span> in working directory)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   <span class="keyword">b</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked <span class="keyword">file</span><span class="variable">s:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> include in what will <span class="keyword">be</span> committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">c</span>.md</span></pre></td></tr></table></figure>

<p>这个命令应该是最常用的git命令之一了，每次提交之前都要看一下。<br><code>git status -v</code>命令相当于<code>git status</code>命令和<code>git diff --staged</code>之和。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status -v</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked files:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">include</span> <span class="keyword">in</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">index</span> <span class="number">5646</span>a65.<span class="number">.4</span>c479de <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-1</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">-apple</span></pre></td></tr><tr><td class="code"><pre><span class="line">+banana</span></pre></td></tr></table></figure>

<p><code>git status -vv</code>命令相当于<code>git status</code>命令和<code>git diff</code>之和。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status -vv</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked files:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">include</span> <span class="keyword">in</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">to</span> be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git c/a.md i/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">index</span> <span class="number">5646</span>a65.<span class="number">.4</span>c479de <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- c/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ i/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-1</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">-apple</span></pre></td></tr><tr><td class="code"><pre><span class="line">+banana</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--------------------------------------------------</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git i/b.md w/b.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">index</span> e69de29.<span class="number">.637</span>a09b <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- i/b.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ w/b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-0</span>,<span class="number">0</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">+<span class="comment">## git is awesome</span></span></pre></td></tr></table></figure>

<p>还有一个<code>-s</code>参数，给出的结果很有意思。</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">$ git status -s</span></pre></td></tr><tr><td class="code"><pre><span class="line">M  a.<span class="built_in">md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> M b.<span class="built_in">md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">?? c.<span class="built_in">md</span></span></pre></td></tr></table></figure>

<p>注意看，前面的字母位置是不一样的。<br>第一个位置是该文件在暂存区的状态，第二个位置是该文件在工作区的状态。比如，以下信息显示<code>a.md</code>文件在暂存区有改动待提交，在工作区也有改动待暂存。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">MM</span> <span class="selector-tag">a</span><span class="selector-class">.md</span></span></pre></td></tr></table></figure>

<p>缩写的状态码主要有这么几种：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>M</td>
<td>文件内容有改动</td>
</tr>
<tr>
<td>A</td>
<td>文件被添加</td>
</tr>
<tr>
<td>D</td>
<td>文件被删除</td>
</tr>
<tr>
<td>R</td>
<td>文件被重命名</td>
</tr>
<tr>
<td>C</td>
<td>文件被复制</td>
</tr>
<tr>
<td>U</td>
<td>文件冲突未解决</td>
</tr>
<tr>
<td>?</td>
<td>文件未被git追踪</td>
</tr>
<tr>
<td>!</td>
<td>文件被git忽略</td>
</tr>
</tbody></table>
<blockquote>
<p><code>?</code>和<code>!</code>所代表的状态因为没有进入git版本系统，所以任何时候两个位置都是一样的。就像<code>??</code>或者<code>!!</code>这样。</p>
</blockquote>
<h2 id="show"><a href="#show" class="headerlink" title="show"></a>show</h2><p><code>git show</code>命令<code>show</code>的是什么呢？git对象。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git show</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">2</span>bd3c9d7de54cec10f0896db9af04c90a41a8160</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Fri Dec <span class="number">28</span> <span class="number">11</span>:<span class="number">23</span>:<span class="number">27</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    update</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/README.md b/README.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">index e8ab145.<span class="number">.75625</span>ce <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">--- a/README.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/README.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-5</span>,<span class="number">3</span> +<span class="number">5</span>,<span class="number">5</span> @@ one</span></pre></td></tr><tr><td class="code"><pre><span class="line"> two</span></pre></td></tr><tr><td class="code"><pre><span class="line"> three</span></pre></td></tr><tr><td class="code"><pre><span class="line">+</span></pre></td></tr><tr><td class="code"><pre><span class="line">+four</span></pre></td></tr></table></figure>

<p><code>git show</code>相当于<code>git show HEAD</code>，显示当前HEAD指向的commit对象的信息。<br>当然，你也可以查看某个git对象的信息，后面跟上git对象的校验和就行。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git show <span class="number">38728</span>d8</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree <span class="number">38728</span>d8</span></pre></td></tr><tr><td class="code"><pre><span class="line">README.md</span></pre></td></tr></table></figure>

<h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p><code>git diff</code>命令可以显示两个主体之间的差异。</p>
<h3 id="工作区与暂存区的差异"><a href="#工作区与暂存区的差异" class="headerlink" title="工作区与暂存区的差异"></a>工作区与暂存区的差异</h3><p>单纯的<code>git diff</code>命令显示工作区与暂存区之间的差异。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git diff</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index e69de29.<span class="number">.5646</span>a65 <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/<span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-0</span>,<span class="number">0</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">+<span class="comment">## git is awesome</span></span></pre></td></tr></table></figure>

<p>因为是两个主体之间的比较，git永远将两个主体分别命名为<code>a</code>和<code>b</code>。<br>也可以只查看某个文件的diff。当然这里依然是工作区与暂存区之间的差异。</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">$ git diff a.<span class="built_in">md</span></span></pre></td></tr></table></figure>

<h3 id="暂存区与当前commit的差异"><a href="#暂存区与当前commit的差异" class="headerlink" title="暂存区与当前commit的差异"></a>暂存区与当前commit的差异</h3><p><code>git diff --staged</code>命令显示暂存区与当前commit的差异。<br><code>git diff --cached</code>也可以达到相同的效果，它比较老，不如<code>--staged</code>语义化。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ git diff --staged</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/<span class="selector-tag">b</span><span class="selector-class">.md</span> b/<span class="selector-tag">b</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">index e69de29..<span class="number">4</span>c479de <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">--- a/<span class="selector-tag">b</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/<span class="selector-tag">b</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ -<span class="number">0</span>,<span class="number">0</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">+apple</span></pre></td></tr></table></figure>

<p>同样，显示某个文件暂存区与当前commit的差异。</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">$ git diff <span class="comment">--staged a.md</span></span></pre></td></tr></table></figure>

<h3 id="两个commit之间的差异"><a href="#两个commit之间的差异" class="headerlink" title="两个commit之间的差异"></a>两个commit之间的差异</h3><p>我们还可以用<code>git diff</code>查看两个commit之间的差异。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git diff C1 C2</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index e69de29.<span class="number">.5646</span>a65 <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/<span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-0</span>,<span class="number">0</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">+<span class="comment">## git is awesome</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/b.md b/b.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">new</span> <span class="built_in">file</span> mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">0000000.</span>.e69de29</span></pre></td></tr></table></figure>

<p>注意先后顺序很重要，假如我改一下顺序。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git diff C2 C1</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">5646</span>a65..e69de29 <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/<span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-1</span> +<span class="number">0</span>,<span class="number">0</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">-<span class="comment">## git is awesome</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/b.md b/b.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">deleted <span class="built_in">file</span> mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index e69de29.<span class="number">.0000000</span></span></pre></td></tr></table></figure>

<p>比较两个commit之间某个文件的差异。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git diff C1:<span class="keyword">a</span>.md C2:<span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index e69de29.<span class="number">.5646</span>a65 <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/<span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-0</span>,<span class="number">0</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">+<span class="comment">## git is awesome</span></span></pre></td></tr></table></figure>

<h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p><code>git log</code>命令显示提交历史。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git log</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">7e2514419</span>ec0f75d1557d3d8165a7e7969f08349</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">53</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">4</span>d346773212b208380f71885979f93da65f07ea6</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">41</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit cde34665b49033d7b8aed3a334c3e2db2200b4dd</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">54</span>:<span class="number">59</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    a.md</span></pre></td></tr></table></figure>

<p>如果要查看每个commit具体的改动，添加<code>-p</code>参数，它是<code>--patch</code>的缩写。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git log -p</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">7e2514419</span>ec0f75d1557d3d8165a7e7969f08349</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">53</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/c.md b/c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">new file mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">0000000.</span>.e69de29</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">4</span>d346773212b208380f71885979f93da65f07ea6</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">41</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/b.md b/b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">new file mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">0000000.</span>.e69de29</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit cde34665b49033d7b8aed3a334c3e2db2200b4dd</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">54</span>:<span class="number">59</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/a.md b/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">new file mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">0000000.</span>.e69de29</span></pre></td></tr></table></figure>

<p>你还可以控制显示最近几条。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git log -p <span class="number">-1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">7e2514419</span>ec0f75d1557d3d8165a7e7969f08349</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">53</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/c.md b/c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">new file mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">0000000.</span>.e69de29</span></pre></td></tr></table></figure>

<p><code>-p</code>有点过于冗余，只是想查看文件修改的统计信息的话，可以使用<code>--stat</code>参数。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git log --stat</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">7e2514419</span>ec0f75d1557d3d8165a7e7969f08349</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">53</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"> c.md | <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">4</span>d346773212b208380f71885979f93da65f07ea6</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">41</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"> b.md | <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit cde34665b49033d7b8aed3a334c3e2db2200b4dd</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">54</span>:<span class="number">59</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"> a.md | <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr></table></figure>

<p>还觉得冗余？只想看提交说明，有一个<code>--oneline</code>可以帮到你。</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">$ git log --oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span>ad50f6 (HEAD -&gt; master) 添加c.<span class="built_in">md</span>文件</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span>d34677 添加b.<span class="built_in">md</span>文件</span></pre></td></tr><tr><td class="code"><pre><span class="line">cde3466 添加a.<span class="built_in">md</span>文件</span></pre></td></tr></table></figure>

<p>想在命令行工具看git提交历史的树形图表，用<code>--graph</code>参数。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git log --graph</span></pre></td></tr><tr><td class="code"><pre><span class="line">* commit <span class="number">7e2514419</span>ec0f75d1557d3d8165a7e7969f08349 (HEAD -&gt; master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">| Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">| Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">53</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|     c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">* commit <span class="number">4</span>d346773212b208380f71885979f93da65f07ea6</span></pre></td></tr><tr><td class="code"><pre><span class="line">| Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">| Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">41</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|     b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">* commit cde34665b49033d7b8aed3a334c3e2db2200b4dd</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">54</span>:<span class="number">59</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      a.md</span></pre></td></tr></table></figure>

<p>我知道你们肯定又觉得冗余，<code>--graph</code>和<code>--oneline</code>食用更佳哟。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span> --graph --oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* 7e25144 (HEAD -&gt; master) c.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* 4d34677 b.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* cde3466 a.md</span></span></pre></td></tr></table></figure>

<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/view.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/view.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（9）：stash</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%889%EF%BC%89%EF%BC%9Astash/</url>
    <content><![CDATA[<p>你在一个分支上开展了一半的工作，突然有一件急事要你去处理。这时候你得切换到一个新的分支，可是手头上的工作你又不想立即提交。<br>这种场景就需要用到git的储藏功能。</p>
<a id="more"></a>

<h2 id="储藏"><a href="#储藏" class="headerlink" title="储藏"></a>储藏</h2><p>想要储藏手头的工作，只需运行<code>git stash</code>命令。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked files:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">include</span> <span class="keyword">in</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git stash</span></pre></td></tr><tr><td class="code"><pre><span class="line">Saved working <span class="keyword">directory</span> <span class="keyword">and</span> <span class="keyword">index</span> state WIP <span class="keyword">on</span> <span class="keyword">master</span>: <span class="number">974</span>a2f2 <span class="keyword">update</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">WIP是<span class="keyword">work</span> <span class="keyword">in</span> progress的缩写，指的是进行中的工作。$ git <span class="keyword">status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked files:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">include</span> <span class="keyword">in</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">nothing</span> added <span class="keyword">to</span> <span class="keyword">commit</span> but untracked files <span class="keyword">present</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">to</span> track)</span></pre></td></tr></table></figure>

<p>可以看到，除了未被git跟踪的文件之外，工作区和暂存区的内容都会被储藏起来。现在你可以切换到其他分支进行下一步工作了。</p>
<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>我们看一下储藏列表。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git stash list</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">stash@</span>&#123;<span class="number">0</span>&#125;: WIP on master: <span class="number">974</span>a2f2 apple</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">stash@</span>&#123;<span class="number">1</span>&#125;: WIP on master: c27b351 banana</span></pre></td></tr></table></figure>

<h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>等我们完成其他工作，肯定要回到这里，继续进行中断的任务。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git stash apply</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes not staged for <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked files:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">include</span> <span class="keyword">in</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span></pre></td></tr></table></figure>

<p>诶，等等。怎么<code>a.md</code>的变更也跑到工作区了？是的，<code>git stash</code>默认会将暂存区和工作区的储藏全部恢复到工作区。如果我就是想原样恢复呢？</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git stash apply --<span class="built_in">index</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   <span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes not staged <span class="keyword">for</span> commi<span class="variable">t:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will <span class="keyword">be</span> committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard <span class="keyword">changes</span> in working directory)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   <span class="keyword">b</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked <span class="keyword">file</span><span class="variable">s:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> include in what will <span class="keyword">be</span> committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">c</span>.md</span></pre></td></tr></table></figure>

<p>加一个参数<code>--index</code>就会让工作区的归工作区，让暂存区的归暂存区。<br>还有一点需要注意，恢复储藏的操作可以应用在任何分支，它也不关心即将恢复储藏的分支上，工作区和暂存区是否干净。如果有冲突，自行解决就是了。<br>我们浏览过储藏列表，说明<code>git stash apply</code>仅仅是恢复了最新的那一次储藏。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git stash apply <span class="symbol">stash@</span>&#123;<span class="number">1</span>&#125;</span></pre></td></tr></table></figure>

<p>指定储藏的名字，我们就可以恢复列表中的任意储藏了。<br>这个时候我们再看一下储藏列表。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git stash list</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">stash@</span>&#123;<span class="number">0</span>&#125;: WIP on master: <span class="number">974</span>a2f2 apple</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">stash@</span>&#123;<span class="number">1</span>&#125;: WIP on master: c27b351 banana</span></pre></td></tr></table></figure>

<p>诶，发现还是两条。我不是已经恢复了一条么？<br><code>apply</code>这个词很巧妙，它只是应用，它可不会清理。</p>
<h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><p>想要清理储藏列表，咱们得显式的运行<code>git stash drop</code>命令。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git stash drop <span class="symbol">stash@</span>&#123;<span class="number">1</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git stash list</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">stash@</span>&#123;<span class="number">0</span>&#125;: WIP on master: <span class="number">974</span>a2f2 apple</span></pre></td></tr></table></figure>

<p>现在就真的没有了。希望你没有喝酒🙃。<br>git还给我们提供了一个快捷操作，运行<code>git stash pop</code>命令，同时恢复储藏和清理储藏。</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">$ git stash <span class="keyword">pop</span></span></pre></td></tr></table></figure>

<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/stash.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/stash.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（8）：revert</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%888%EF%BC%89%EF%BC%9Arevert/</url>
    <content><![CDATA[<p>有时候我们想撤回一个commit，但是这个commit已经在公共的分支上。如果直接修改分支历史，可能会引起一些不必要的混乱。这个时候，<code>git revert</code>命令就派上用场了。<br><code>revert</code>翻译成中文是<code>还原</code>。我觉得称它为对冲更合理。对冲指的是同时进行两笔行情相关、方向相反、数量相当、盈亏相抵的交易，这么理解<code>git revert</code>命令一针见血。<br>因为它的作用就是生成一个新的、完全相反的commit。</p>
<a id="more"></a>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><code>git revert</code>后跟你想要对冲的commit即可。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git revert HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line">Revert <span class="string">"add c.md"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">This reverts commit <span class="number">8a23</span>dad059b60ba847a621b6058fb32fa531b20a.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Please enter the commit message for your changes. Lines starting</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># with '#' will be ignored, and an empty message aborts the commit.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># On branch master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Changes to be committed:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#	deleted:    c.md</span></span></pre></td></tr></table></figure>

<p>git会弹出默认或者自定义的编辑器要求你输入commit信息。然后一个新的commit就生成了。</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">[master a8c4205] Revert <span class="string">"add c.md"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file <span class="section">changed</span>, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> delete mode <span class="number">100644</span> c.md</span></pre></td></tr></table></figure>

<p>可以看到，原本我添加了一个文件<code>a.md</code>，<code>revert</code>操作就会执行删除命令。在工作目录看起来就像添加文件操作被撤销了一样，其实是被对冲了。<br>它不会改变commit历史，只会增加一个新的对冲commit。这是它最大的优点。</p>
<h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>反向操作也会有冲突？你逗我的吧。<br>如果你操作的是最新的commit，那当然不会有冲突了。<br>那要操作的是以前的commit呢？</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span>(HEAD -&gt; master)</span></pre></td></tr></table></figure>

<p>比如<code>a.md</code>在<code>C0</code>内容为空，<code>C1</code>修改文件内容为<code>apple</code>，<code>C2</code>修改文件内容为<code>banana</code>。这时候你想撤销<code>C1</code>的修改。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">revert</span> HEAD~</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">error</span>: could <span class="keyword">not</span> <span class="built_in">revert</span> <span class="number">483b537</span>... apple</span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: after resolving the conflicts, mark the corrected paths</span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: with 'git add &lt;paths&gt;' <span class="keyword">or</span> 'git rm &lt;paths&gt;'</span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: <span class="keyword">and</span> commit the result with 'git commit'</span></pre></td></tr></table></figure>

<p>我们看一下文件内容。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line">banana</span></pre></td></tr><tr><td class="code"><pre><span class="line">=======</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; parent of 483b537... apple</span></pre></td></tr></table></figure>

<p>手动解决冲突，执行<code>git add</code>命令然后执行<code>git revert --continue</code>命令完成对冲操作。<br>取消<code>revert</code>操作只需要执行<code>git revert --abort</code>即可。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/revert.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/revert.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（7）：reset</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%887%EF%BC%89%EF%BC%9Areset/</url>
    <content><![CDATA[<p><code>git checkout</code>命令可以在版本之间随意切换，它的本质是移动HEAD指针。<br>那git有没有办法移动分支指针呢？<br>当然有，这就是<code>git reset</code>命令。</p>
<a id="more"></a>

<h2 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h2><p><code>git reset</code>命令与<code>git checkout</code>命令的区别在于，它会把HEAD指针和分支指针一起移动，如果HEAD指针指向的是一个分支指针的话。<br>我们前面说过使用<code>git checkout</code>命令从有分支指向的commit切换到一个没有分支指向的commit上，这个时候的HEAD指针被称为<code>detached HEAD</code>。这是非常危险的。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span>(HEAD -&gt; master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout <span class="built_in">C1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span>(HEAD) -- <span class="built_in">C2</span>(master)</span></pre></td></tr></table></figure>

<p>但是<code>git reset</code>命令没有这个问题，因为它会把当前的分支指针也带过去。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span>(HEAD -&gt; master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git reset <span class="built_in">C1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span>(HEAD -&gt; master) -- <span class="built_in">C2</span></span></pre></td></tr></table></figure>

<p>这就是<code>重置</code>的含义所在。它可以重置分支。<br>看另一种情况。如果是从一个没有分支指向的commit切换到另一个没有分支指向的commit上，那它们就是两个韩国妹子，傻傻分不清楚了。<br>这是<code>git checkout</code>命令的效果。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span>(HEAD) -- <span class="built_in">C3</span>(master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout <span class="built_in">C1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span>(HEAD) -- <span class="built_in">C2</span> -- <span class="built_in">C3</span>(master)</span></pre></td></tr></table></figure>

<p>这是<code>git reset</code>命令的效果。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span>(HEAD) -- <span class="built_in">C3</span>(master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git reset <span class="built_in">C1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span>(HEAD) -- <span class="built_in">C2</span> -- <span class="built_in">C3</span>(master)</span></pre></td></tr></table></figure>

<h2 id="同时重置暂存区和工作区的改动"><a href="#同时重置暂存区和工作区的改动" class="headerlink" title="同时重置暂存区和工作区的改动"></a>同时重置暂存区和工作区的改动</h2><p>当你在 <code>git reset</code> 命令后面加 <code>--hard</code> 参数时，暂存区和工作区的内容都会重置为重置后的commit内容。也就是说暂存区和工作区的改动都会清空，相当于撤销暂存区和工作区的改动。<br>而且是没有确认操作的哟。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--hard HEAD^</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">HEAD</span> <span class="keyword">is</span> <span class="keyword">now</span> <span class="keyword">at</span> <span class="number">58</span>b0040 <span class="keyword">commit</span> <span class="keyword">for</span> <span class="keyword">nothing</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">nothing</span> <span class="keyword">to</span> <span class="keyword">commit</span>, working tree clean</span></pre></td></tr></table></figure>

<h2 id="仅重置暂存区的改动"><a href="#仅重置暂存区的改动" class="headerlink" title="仅重置暂存区的改动"></a>仅重置暂存区的改动</h2><p><code>git reset</code> 命令后面加 <code>--mixed</code> 参数，或者不加参数，因为<code>--mixed</code>参数是默认值，暂存区的内容会重置为重置后的commit内容，工作区的改动不会清空，相当于撤销暂存区的改动。<br>同样也是没有确认操作的哟。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="keyword">HEAD</span>^</span></pre></td></tr><tr><td class="code"><pre><span class="line">Unstaged changes <span class="keyword">after</span> <span class="keyword">reset</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">M	a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span></pre></td></tr></table></figure>

<p>打个趣，如果<code>git reset</code>命令什么都不加会怎样呢？<br>你可以脑补一下，<code>git reset</code>命令不加参数默认就是<code>--mixed</code>，不加操作对象默认就是<code>HEAD</code>，所以单纯的<code>git reset</code>命令相当于<code>git reset --mixed HEAD</code>命令。<br>那这又意味着什么呢？<br>这意味着从当前commit重置到当前commit，没有变化对吧？但是<code>--mixed</code>参数会撤销暂存区的改动对不对，这就是它的效果。</p>
<h2 id="同时保留暂存区和工作区的改动"><a href="#同时保留暂存区和工作区的改动" class="headerlink" title="同时保留暂存区和工作区的改动"></a>同时保留暂存区和工作区的改动</h2><p>如果 <code>git reset</code> 命令后面加 <code>--soft</code> 参数，钢铁直男的温柔，你懂的。仅仅是重置commit而已，暂存区和工作区的改动都会保留下来。<br>更温柔的是，重置前的commit内容与重置后的commit内容的diff也会放入暂存区。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git diff <span class="comment">--staged</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">index</span> <span class="number">4</span>a77268..fde8dcd <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-1</span>,<span class="number">2</span> +<span class="number">1</span>,<span class="number">3</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line"> apple</span></pre></td></tr><tr><td class="code"><pre><span class="line"> banana</span></pre></td></tr><tr><td class="code"><pre><span class="line">+cherry</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--soft HEAD^</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">to</span> be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git diff <span class="comment">--staged</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">index</span> <span class="number">4</span>a77268..fde8dcd <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-1</span> +<span class="number">1</span>,<span class="number">3</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line"> apple</span></pre></td></tr><tr><td class="code"><pre><span class="line">+banana</span></pre></td></tr><tr><td class="code"><pre><span class="line">+cherry</span></pre></td></tr></table></figure>

<p><code>banana</code>就是重置前的commit内容与重置后的commit内容的diff，可以看到，它已经在暂存区了。</p>
<h2 id="文件暂存区内容撤回工作区"><a href="#文件暂存区内容撤回工作区" class="headerlink" title="文件暂存区内容撤回工作区"></a>文件暂存区内容撤回工作区</h2><p><code>git reset</code>命令后面也可以跟文件名，它的作用是将暂存区的内容重置为工作区的内容，是<code>git add --</code>的反向操作。<br><code>git reset --</code>命令是<code>git reset HEAD --mixed --</code>的简写。在操作文件时，参数只有默认的<code>--mixed</code>一种。<br>它并不会撤销工作区原有的改动。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="comment">-- a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Unstaged changes <span class="keyword">after</span> <span class="keyword">reset</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">M	a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span></pre></td></tr></table></figure>

<p><code>git checkout</code>命令后面也可以跟文件名，它的作用是撤销工作区的改动，需要注意区分。</p>
<h2 id="文件若干commit版本撤回工作区"><a href="#文件若干commit版本撤回工作区" class="headerlink" title="文件若干commit版本撤回工作区"></a>文件若干commit版本撤回工作区</h2><p>如果<code>git reset</code>命令后跟一个commit校验和，它会把该commit与所有后代commit的diff重置到工作区。<br>意思就是将该文件重置回你指定的commit版本，但是在你指定的commit之后的改动我也给你留着，就放到工作区里吧。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git diff <span class="comment">--staged</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 空</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="keyword">HEAD</span>~<span class="number">4</span> <span class="comment">-- a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Unstaged changes <span class="keyword">after</span> <span class="keyword">reset</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">M	a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git diff <span class="comment">--staged</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">index</span> <span class="number">6</span>f195b4.<span class="number">.72943</span>a1 <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-1</span>,<span class="number">5</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line"> aaa</span></pre></td></tr><tr><td class="code"><pre><span class="line">-bbb</span></pre></td></tr><tr><td class="code"><pre><span class="line">-ccc</span></pre></td></tr><tr><td class="code"><pre><span class="line">-ddd</span></pre></td></tr><tr><td class="code"><pre><span class="line">-eee</span></pre></td></tr></table></figure>

<p><code>git diff --staged</code>命令比较工作区和暂存区的内容。可以看到初始工作区和暂存区是一致的，重置文件到4个版本之前，发现工作区比暂存区多了很多改动，这些都是指定commit之后的提交被重置到工作区了。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/reset.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/reset.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（6）：rebase</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%886%EF%BC%89%EF%BC%9Arebase/</url>
    <content><![CDATA[<p><code>git merge</code>命令会生成一个新的合并commit。如果你有强迫症，不喜欢这个新的合并commit，git也有更加清爽的方案可以满足你，它就是<code>git rebase</code>命令。<br>git就是哆啦A梦的口袋。<br><code>rebase</code>翻译过来是<code>变基</code>。意思就是将所有要合并进来的commit在新的基础上重新提交一次。</p>
<a id="more"></a>

<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p><code>git rebase</code>会计算当前分支和目标分支的最近共同祖先，然后将最近共同祖先与当前分支之间的所有commit都变基到目标分支上，使得提交历史变成一条直线。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span> -- <span class="built_in">C3</span>(master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">C4</span> -- <span class="built_in">C5</span> -- <span class="built_in">C6</span>(HEAD -&gt; dev)</span></pre></td></tr></table></figure>

<p><code>merge</code>与<code>rebase</code>后跟的分支名是不一样的。合并是合并进来，变基是变基过去，你们感受一下。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git rebase master</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">First</span>, rewinding head to replay your work on top of <span class="keyword">it...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Applying: </span><span class="built_in">C4</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">Applying</span>: <span class="built_in">C5</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">Applying</span>: <span class="built_in">C6</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span> -- <span class="built_in">C3</span>(master) -- <span class="built_in">C4</span><span class="string">' -- C5'</span> -- <span class="built_in">C6</span><span class="string">'(HEAD -&gt; dev)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">       \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">        C4 -- C5 -- C6</span></span></pre></td></tr></table></figure>

<p>现在最近共同祖先与当前分支之间的所有commit都被复制到master分支之后，并且将HEAD指针与当前分支指针切换过去。这招移花接木玩的很溜啊，如果你置身其中根本分不出区别。<br>原来的commit还在吗？还在，如果你记得它的commit校验和，仍然可以切换过去，git会提示你当前处于<code>detached HEAD</code>状态下。只不过没有任何分支指针指向它们，它们已经被抛弃了，剩余的时光就是等待git垃圾回收命令清理它们。<br>好在，还有人记得它们，不是么？<br><code>git rebase</code>完并没有结束，因为我变基的目标分支是master，而当前分支是dev。我需要切换到master分支上，然后再合并一次。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git checkout <span class="literal">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git merge dev</span></pre></td></tr></table></figure>

<p>诶，说来说去，还是要合并啊？<br>别急，这种合并是<code>Fast forward</code>的，并不会生成一个新的合并commit。<br>如果我要变基的本体分支不是当前分支行不行？也是可以的。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git rebase <span class="keyword">master</span> <span class="title">dev</span></span></pre></td></tr></table></figure>

<p>你在任何一个分支上，这种写法都可以将dev分支变基到master分支上，变基完成当前分支会变成dev分支。</p>
<h2 id="裁剪commit变基"><a href="#裁剪commit变基" class="headerlink" title="裁剪commit变基"></a>裁剪commit变基</h2><p>变基有点像基因编辑，git有更精确的工具达到你想要的效果。</p>
<blockquote>
<p>有了精确的基因编辑技术，妈妈再也不用担心你长的<strong>丑</strong>啦。</p>
</blockquote>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span> -- <span class="built_in">C3</span>(master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">C4</span> -- <span class="built_in">C5</span> -- <span class="built_in">C6</span>(dev)</span></pre></td></tr><tr><td class="code"><pre><span class="line">         \</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="built_in">C7</span> -- <span class="built_in">C8</span>(HEAD -&gt; hotfix)</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git rebase --onto master dev hotfix</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">First</span>, rewinding head to replay your work on top of <span class="keyword">it...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Applying: </span><span class="built_in">C7</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">Applying</span>: <span class="built_in">C8</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span> -- <span class="built_in">C3</span>(master) -- <span class="built_in">C7</span><span class="string">' -- C8'</span>(HEAD -&gt; hotfix)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">C4</span> -- <span class="built_in">C5</span> -- <span class="built_in">C6</span>(dev)</span></pre></td></tr><tr><td class="code"><pre><span class="line">         \</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="built_in">C7</span> -- <span class="built_in">C8</span></span></pre></td></tr></table></figure>

<p><code>--onto</code>参数就是那把基因编辑的剪刀。<br>它会把<code>hotfix分支</code>到<code>hotfix分支与dev分支的最近共同祖先</code>之间的commit裁剪下来，复制到目标基础点上。注意，所谓的之间指的都是不包括<code>最近共同祖先commit</code>的范围，比如这里就不会复制<code>C4</code>commit。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ git rebase <span class="comment">--onto master dev</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">First, rewinding head <span class="keyword">to</span> replay your work <span class="keyword">on</span> top <span class="keyword">of</span> <span class="keyword">it</span>...</span></pre></td></tr><tr><td class="code"><pre><span class="line">Applying: C7.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Applying: C8.md</span></pre></td></tr></table></figure>

<p>如果<code>--onto</code>后面只写两个分支(或者commit)名，第三个分支(或者commit)默认就是HEAD指针指向的分支(或者commit)。</p>
<h2 id="变基冲突解决"><a href="#变基冲突解决" class="headerlink" title="变基冲突解决"></a>变基冲突解决</h2><p>变基也会存在冲突的情况，我们看看冲突怎么解决。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">C0 <span class="comment">-- C1 -- C2(HEAD -&gt; master)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        C3 <span class="comment">-- C4(dev)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git rebase master dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">First, rewinding head to replay your work on top of it...</span></pre></td></tr><tr><td class="code"><pre><span class="line">Applying: c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Applying: a.md add banana</span></pre></td></tr><tr><td class="code"><pre><span class="line">Using index info to reconstruct a base tree...</span></pre></td></tr><tr><td class="code"><pre><span class="line">M	a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Falling back to patching base and 3-way merge...</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Auto</span>-merging a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">CONFLICT (<span class="keyword">content</span>): <span class="keyword">Merge</span> conflict <span class="keyword">in</span> a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">error</span>: <span class="keyword">Failed</span> <span class="keyword">to</span> <span class="keyword">merge</span> <span class="keyword">in</span> the changes.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Patch</span> <span class="keyword">failed</span> <span class="keyword">at</span> <span class="number">0002</span> a.md dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">The copy <span class="keyword">of</span> the <span class="keyword">patch</span> that <span class="keyword">failed</span> <span class="keyword">is</span> <span class="keyword">found</span> <span class="keyword">in</span>: .git/rebase-<span class="keyword">apply</span>/<span class="keyword">patch</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Resolve <span class="keyword">all</span> conflicts manually, mark them <span class="keyword">as</span> resolved <span class="keyword">with</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">"git add/rm &lt;conflicted_files&gt;"</span>, <span class="keyword">then</span> run <span class="string">"git rebase --continue"</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">You can instead <span class="keyword">skip</span> this <span class="keyword">commit</span>: run <span class="string">"git rebase --skip"</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">To</span> <span class="keyword">abort</span> <span class="keyword">and</span> <span class="keyword">get</span> back <span class="keyword">to</span> the state <span class="keyword">before</span> <span class="string">"git rebase"</span>, run <span class="string">"git rebase --abort"</span>.</span></pre></td></tr></table></figure>

<p>C2和C4同时修改了<code>a.md</code>的某一行，引发冲突。git已经给我们提示了，大体上和<code>merge</code>的操作一致。<br>我们可以手动解决冲突，然后执行<code>git add</code>和<code>git rebase --continue</code>来完成变基。<br>如果你不想覆盖目标commit的内容，也可以跳过这个commit，执行<code>git rebase --skip</code>。但是注意，这会跳过有冲突的整个commit，而不仅仅是有冲突的部分。<br>后悔药也是有的，执行<code>git rebase --abort</code>，干脆就放弃变基了。</p>
<h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><p><code>git rebase --onto</code>命令可以裁剪分支以变基到另一个分支上。但它依然是挑选连续的一段commit，只是允许你指定头和尾罢了。<br>别急，<code>git cherry-pick</code>命令虽然是一个独立的git命令，它的效果却还是变基，而且是commit级别的变基。<br><code>git cherry-pick</code>命令可以挑选任意commit变基到目标commit上。你负责挑，它负责基。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>只需要在<code>git cherry-pick</code>命令后跟commit校验和，就可以将它应用到目标commit上。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span>(HEAD -&gt; master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">C3</span> -- <span class="built_in">C4</span> -- <span class="built_in">C5</span>(dev)</span></pre></td></tr><tr><td class="code"><pre><span class="line">               \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">C6</span> -- <span class="built_in">C7</span>(hotfix)</span></pre></td></tr></table></figure>

<p>将当前分支切换到master分支。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">git</span> <span class="string">cherry-pick</span> <span class="string">C6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[master</span> <span class="string">dc342e0]</span> <span class="string">c6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="attr">Date:</span> <span class="string">Mon</span> <span class="string">Dec</span> <span class="number">24</span> <span class="number">09</span><span class="string">:13:57</span> <span class="number">2018</span> <span class="string">+0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="string">file</span> <span class="string">changed,</span> <span class="number">0</span> <span class="string">insertions(+),</span> <span class="number">0</span> <span class="string">deletions(-)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="string">create</span> <span class="string">mode</span> <span class="number">100644</span> <span class="string">c6.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">C0</span> <span class="string">--</span> <span class="string">C1</span> <span class="string">--</span> <span class="string">C2</span> <span class="string">--</span> <span class="string">C6'(HEAD</span> <span class="string">-&gt;</span> <span class="string">master)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="string">\</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">C3</span> <span class="string">--</span> <span class="string">C4</span> <span class="string">--</span> <span class="string">C5(dev)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="string">\</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="string">C6</span> <span class="string">--</span> <span class="string">C7(hotfix)</span></span></pre></td></tr></table></figure>

<p><code>C6</code>commit就按原样重新提交到master分支上了。<code>cherry-pick</code>并不会修改原有的commit。<br>同时挑选多个commit也很方便，往后面叠加就行。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick C4 C7</span></pre></td></tr><tr><td class="code"><pre><span class="line">[master ab1e7c7] c4</span></pre></td></tr><tr><td class="code"><pre><span class="line"> Date: Mon Dec <span class="number">24</span> <span class="number">09</span>:<span class="number">12</span>:<span class="number">58</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode <span class="number">100644</span> c4.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">[master <span class="number">161</span>d993] c7</span></pre></td></tr><tr><td class="code"><pre><span class="line"> Date: Mon Dec <span class="number">24</span> <span class="number">09</span>:<span class="number">14</span>:<span class="number">12</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode <span class="number">100644</span> c7.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">C0 -- C1 -- C2 -- C4<span class="string">' -- C7'</span>(HEAD -&gt; master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        C3 -- C4 -- C5(dev)</span></pre></td></tr><tr><td class="code"><pre><span class="line">               \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                C6 -- C7(hotfix)</span></pre></td></tr></table></figure>

<p>如果这多个commit正好是连续的呢？</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">git</span> <span class="string">cherry-pick</span> <span class="string">C3...C7</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[master</span> <span class="string">d16c42e]</span> <span class="string">c4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="attr">Date:</span> <span class="string">Mon</span> <span class="string">Dec</span> <span class="number">24</span> <span class="number">09</span><span class="string">:12:58</span> <span class="number">2018</span> <span class="string">+0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="string">file</span> <span class="string">changed,</span> <span class="number">0</span> <span class="string">insertions(+),</span> <span class="number">0</span> <span class="string">deletions(-)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="string">create</span> <span class="string">mode</span> <span class="number">100644</span> <span class="string">c4.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[master</span> <span class="string">d16c42e]</span> <span class="string">c6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="attr">Date:</span> <span class="string">Mon</span> <span class="string">Dec</span> <span class="number">24</span> <span class="number">09</span><span class="string">:13:57</span> <span class="number">2018</span> <span class="string">+0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="string">file</span> <span class="string">changed,</span> <span class="number">0</span> <span class="string">insertions(+),</span> <span class="number">0</span> <span class="string">deletions(-)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="string">create</span> <span class="string">mode</span> <span class="number">100644</span> <span class="string">c6.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[master</span> <span class="string">a4d5976]</span> <span class="string">c7</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="attr">Date:</span> <span class="string">Mon</span> <span class="string">Dec</span> <span class="number">24</span> <span class="number">09</span><span class="string">:14:12</span> <span class="number">2018</span> <span class="string">+0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="string">file</span> <span class="string">changed,</span> <span class="number">0</span> <span class="string">insertions(+),</span> <span class="number">0</span> <span class="string">deletions(-)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="string">create</span> <span class="string">mode</span> <span class="number">100644</span> <span class="string">c7.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">C0</span> <span class="string">--</span> <span class="string">C1</span> <span class="string">--</span> <span class="string">C2</span> <span class="string">--</span> <span class="string">C4'</span> <span class="string">--</span> <span class="string">C6'</span> <span class="string">--</span> <span class="string">C7'(HEAD</span> <span class="string">-&gt;</span> <span class="string">master)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="string">\</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">C3</span> <span class="string">--</span> <span class="string">C4</span> <span class="string">--</span> <span class="string">C5(dev)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="string">\</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="string">C6</span> <span class="string">--</span> <span class="string">C7(hotfix)</span></span></pre></td></tr></table></figure>

<p>需要注意，git所谓的从某某开始，一般都是不包括某某的，这里也一样。<br>有没有发现操作连续commit的<code>git cherry-pick</code>和<code>git rebase</code>的功能已经非常接近了？所以呀，<code>git cherry-pick</code>也是变基，只不过一边变基一边喂樱桃给你吃。</p>
<h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>git各种命令解决冲突的方法都大同小异。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">C0 <span class="comment">-- C1(HEAD -&gt; master)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  C2(dev)</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git cherry-pick C2</span></pre></td></tr><tr><td class="code"><pre><span class="line">error: could <span class="keyword">not</span> apply <span class="number">051</span>c24c... banana</span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: <span class="keyword">after</span> resolving <span class="keyword">the</span> conflicts, mark <span class="keyword">the</span> corrected paths</span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: <span class="keyword">with</span> <span class="string">'git add &lt;paths&gt;'</span> <span class="keyword">or</span> <span class="string">'git rm &lt;paths&gt;'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: <span class="keyword">and</span> commit <span class="keyword">the</span> <span class="built_in">result</span> <span class="keyword">with</span> <span class="string">'git commit'</span></span></pre></td></tr></table></figure>

<p>手动解决冲突，执行<code>git add</code>命令然后执行<code>git cherry-pick --continue</code>命令。<br>如果被唬住了想还原，执行<code>git cherry-pick --abort</code>即可。</p>
<h2 id="变基还是合并"><a href="#变基还是合并" class="headerlink" title="变基还是合并"></a>变基还是合并</h2><p>这是一个哲学问题。<br>有一种观点认为，仓库的commit历史应该记录<code>实际发生过什么</code>。所以如果你将一个分支合并进另一个分支，commit历史中就应该有这一次合并的痕迹，因为它是实实在在发生过的。<br>另一种观点则认为，仓库的commit历史应该记录<code>项目过程中发生过什么</code>。合并不是项目开发本身带来的，它是一种额外的操作，会使commit历史变的冗长。<br>我是一个极简主义者，所以我支持首选变基。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/rebase.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/rebase.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（5）：merge</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%885%EF%BC%89%EF%BC%9Amerge/</url>
    <content><![CDATA[<p>可以方便的创建分支是git如此受欢迎的重要原因，利用<code>git checkout</code>也让开发者在分支之间穿梭自如。然而百川终入海，其他分支上完成的工作终究是要合并到主分支上去的。<br>所以我们来看看git中的合并操作。</p>
<a id="more"></a>

<p>首先说明，执行<code>git merge</code>命令之前需要一些准备工作。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">merge</span> dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">error: Your <span class="built_in">local</span> changes <span class="built_in">to</span> <span class="keyword">the</span> following <span class="built_in">files</span> would be overwritten <span class="keyword">by</span> <span class="built_in">merge</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Please commit your changes <span class="keyword">or</span> stash them <span class="keyword">before</span> you <span class="built_in">merge</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Aborting</span></pre></td></tr></table></figure>

<p>合并操作之前必须保证暂存区内没有待提交内容，否则git会阻止合并。这是因为合并之后，git会将合并后的版本覆盖暂存区。所以会有丢失工作成果的危险。<br>至于工作区有待添加到暂存区的内容，git倒不会阻止你。可能git觉得它不重要吧。<br>不过最好还是保持一个干净的工作区再执行合并操作。</p>
<h2 id="不同分支的合并"><a href="#不同分支的合并" class="headerlink" title="不同分支的合并"></a>不同分支的合并</h2><p>不同分支指的是要合并的两个commit在某个祖先commit之后开始分叉。</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">C0</span> -- <span class="variable">C1</span> -- <span class="function"><span class="title">C2</span>(<span class="variable">HEAD</span> -&gt; <span class="variable">master</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="title">C3</span>(<span class="variable">dev</span>)</span></span></pre></td></tr></table></figure>

<p><code>git merge</code>后跟合并客体，表示要将它合并进来。</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">merge</span> dev</span></pre></td></tr></table></figure>

<p>进行到这里，如果没有冲突，git会弹出默认或者自定义的编辑器，让你填写commit说明。当然它会给你填写一个默认的commit说明。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Merge</span> branch <span class="string">'dev'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Please enter a commit message to explain why this merge is necessary,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># especially if it merges an updated upstream into a topic branch.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Lines starting with '#' will be ignored, and an empty message aborts</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># the commit.</span></span></pre></td></tr></table></figure>

<p>为什么要你填写commit说明？因为这种情况的<code>git merge</code>实际上会创建一个新的commit对象，记录此次合并的信息，并将当前分支指针移动到它上面来。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span> -- <span class="built_in">C4</span>(HEAD -&gt; master)(merge commit)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       \          /</span></pre></td></tr><tr><td class="code"><pre><span class="line">        \        /</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="built_in">C3</span>(dev)</span></pre></td></tr></table></figure>

<p>大家常说不同分支的<code>git merge</code>操作是一个三方合并，这里的三方指的是<code>合并主体commit</code>、<code>合并客体commit</code>以及<code>合并主客体的共同祖先commit</code>。<br>所谓的三方和并到底是什么意思呢？<br>git会提取出<code>合并主体commit</code>相对于<code>合并主客体的共同祖先commit</code>的diff与<code>合并客体commit</code>相对于<code>合并主客体的共同祖先commit</code>的diff，再去比较这两份diff有没有修改同一个地方，这里同一个地方的单位是文件的行。如果没有，那就将这两份diff合并生成一个新的commit，当前分支指针向右移。如果有那就要求开发者自行解决。<br>所以在三方合并中，<code>合并主客体的共同祖先commit</code>只是一个参照物。</p>
<h2 id="合并主体在合并客体的上游"><a href="#合并主体在合并客体的上游" class="headerlink" title="合并主体在合并客体的上游"></a>合并主体在合并客体的上游</h2><p>它指的是开发者当前在一个commit节点上，要将同一个分支上更新的commit节点合并进来。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">C0 -- C1 -- C2(<span class="name">HEAD</span> -&gt; master) -- C3(<span class="name">dev</span>)</span></pre></td></tr></table></figure>

<p>这时候会发生什么呢？<br>这相当于更新当前分支指针，所以只需要将当前分支指针向下游移动，让合并主体与合并客体指向同一个commit即可。这时并不会产生一个新的commit。<br>用三方合并的概念来理解，<code>合并主体commit</code>与<code>合并主客体的共同祖先commit</code>是同一个commit，<code>合并主体commit</code>相对于<code>合并主客体的共同祖先commit</code>的diff为空，<code>合并客体commit</code>相对于<code>合并主客体的共同祖先commit</code>的diff与空diff合并还是它自己，所以移动过去就行了，并不需要生成一个新的commit。</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">$ git merge dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Updating <span class="number">9242078.</span><span class="number">.631</span>ef3a</span></pre></td></tr><tr><td class="code"><pre><span class="line">Fast-forward</span></pre></td></tr><tr><td class="code"><pre><span class="line"> a.md | <span class="number">2</span> ++</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file <span class="section">changed</span>, <span class="number">2</span> insertions(+)</span></pre></td></tr><tr><td class="code"><pre><span class="line">C0 -- C1 -- C2 -- C3(HEAD -&gt; master, dev)</span></pre></td></tr></table></figure>

<p>这种操作在git中有一个专有名词，叫<code>Fast forward</code>。<br>比如说<code>git pull</code>的时候经常发生这种情况。通常因为远端有更新的commit我们才需要执行<code>git pull</code>命令，这时远端就是合并客体，本地就是合并主体，远端的分支指针在下游，也会触发<code>Fast forward</code>。</p>
<h2 id="合并主体在合并客体的下游"><a href="#合并主体在合并客体的下游" class="headerlink" title="合并主体在合并客体的下游"></a>合并主体在合并客体的下游</h2><p>如果合并主体在合并客体的下游，那合并主体本身就包含合并客体，合并操作并不会产生任何效果。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">C0 -- C1 -- <span class="constructor">C2(<span class="params">dev</span>)</span> -- <span class="constructor">C3(HEAD -&gt; <span class="params">master</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git merge dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Already up <span class="keyword">to</span> date.</span></pre></td></tr><tr><td class="code"><pre><span class="line">C0 -- C1 -- <span class="constructor">C2(<span class="params">dev</span>)</span> -- <span class="constructor">C3(HEAD -&gt; <span class="params">master</span>)</span></span></pre></td></tr></table></figure>

<p>依然用三方合并的概念来理解，这时<code>合并客体commit</code>与<code>合并主客体的共同祖先commit</code>是同一个commit，<code>合并客体commit</code>相对于<code>合并主客体的共同祖先commit</code>的diff为空，<code>合并主体commit</code>相对于<code>合并主客体的共同祖先commit</code>的diff与空diff合并还是它自己。但是这回它都不用移动，因为合并后的diff就是它自己原有的diff。<br>注意，这时候dev分支指针会不会动呢？<br>当然不会，<code>git merge</code>操作对合并客体是没有任何影响的。</p>
<h2 id="同时合并多个客体"><a href="#同时合并多个客体" class="headerlink" title="同时合并多个客体"></a>同时合并多个客体</h2><p>如果你在<code>git merge</code>后面跟不止一个分支，这意味着你想同时将它们合并进当前分支。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ git merge<span class="built_in"> aaa </span>bbb ccc</span></pre></td></tr><tr><td class="code"><pre><span class="line">Fast-forwarding <span class="keyword">to</span>: aaa</span></pre></td></tr><tr><td class="code"><pre><span class="line">Trying<span class="built_in"> simple </span>merge with bbb</span></pre></td></tr><tr><td class="code"><pre><span class="line">Trying<span class="built_in"> simple </span>merge with ccc</span></pre></td></tr><tr><td class="code"><pre><span class="line">Merge made by the <span class="string">'octopus'</span> strategy.</span></pre></td></tr><tr><td class="code"><pre><span class="line"> aaa.md | 0</span></pre></td></tr><tr><td class="code"><pre><span class="line"> bbb.md | 0</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ccc.md | 0</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 3 files changed, 0 insertions(+), 0 deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode 100644 aaa.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode 100644 bbb.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode 100644 ccc.md</span></pre></td></tr></table></figure>

<p>git合并有多种策略，上面使用的是<code>&#39;octopus&#39; strategy</code>章鱼策略，因为同时合并的多个分支最终都会指向新的commit，看起来像章鱼的触手。</p>
<h2 id="合并有冲突"><a href="#合并有冲突" class="headerlink" title="合并有冲突"></a>合并有冲突</h2><p><code>git merge</code>操作并不总是如此顺利的。因为有时候要合并的两个分支不是同一个人的，就会有很大的概率遇到两人同时修改文件某一行的情况。git不知道该用谁的版本，它认为两个分支遇到了冲突。<br>这时就需要开发者手动的解决冲突，才能让git继续合并。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git merge dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Auto-merging a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">CONFLICT</span> (content): Merge <span class="keyword">conflict</span> <span class="keyword">in</span> a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Automatic merge failed; fix conflicts <span class="keyword">and</span> <span class="keyword">then</span> <span class="keyword">commit</span> the result.</span></pre></td></tr></table></figure>

<p>我们来看一下有冲突的文件是什么样的。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line">apple</span></pre></td></tr><tr><td class="code"><pre><span class="line">=======</span></pre></td></tr><tr><td class="code"><pre><span class="line">banana</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</span></pre></td></tr></table></figure>

<p>运行<code>git status</code>命令。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">You have unmerged paths.</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (fix conflicts and run "git <span class="keyword">commit</span><span class="string">")</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">  (use "</span>git <span class="keyword">merge</span> <span class="comment">--abort" to abort the merge)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Unmerged paths:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> mark resolution)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">both</span> modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span></pre></td></tr></table></figure>

<p>解决完冲突之后，你需要再提交，告诉git可以完成合并了。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> -m "fix merge conflict"</span></pre></td></tr><tr><td class="code"><pre><span class="line">U	a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">error: Committing <span class="keyword">is</span> <span class="keyword">not</span> possible because you have unmerged files.</span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: Fix them up <span class="keyword">in</span> the <span class="keyword">work</span> tree, <span class="keyword">and</span> <span class="keyword">then</span> use <span class="string">'git add/rm &lt;file&gt;'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: <span class="keyword">as</span> appropriate <span class="keyword">to</span> mark resolution <span class="keyword">and</span> make a <span class="keyword">commit</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">fatal: Exiting because <span class="keyword">of</span> an unresolved <span class="keyword">conflict</span>.</span></pre></td></tr></table></figure>

<p>诶，被拒绝了。是不是想起了自己的情场故事？<br>当我们解决冲突的时候，工作区已经有改动，所以需要先提交到暂存区。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span> a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> -m "fix merge conflict"</span></pre></td></tr><tr><td class="code"><pre><span class="line">[master <span class="number">9</span>b32d4d] fix merge <span class="keyword">conflict</span></span></pre></td></tr></table></figure>

<p>运行<code>git add</code>命令之后你也可以用<code>git merge --continue</code>来替代<code>git commit</code>命令。它会让后面的行为跟没有冲突时的行为表现的一样。<br>如果你遇到冲突以后不知道如何解决，因为你要去询问你的合作伙伴为什么这样改。这时你肯定想回到合并以前的状态。<br>这对git来说很容易。只需要运行<code>git merge --abort</code>命令即可。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git merge --<span class="keyword">abort</span></span></pre></td></tr></table></figure>

<p>该命令无法保证恢复工作区的修改，所以最好是在合并之前先让工作区保持干净。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/merge.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/merge.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（4）：checkout</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%884%EF%BC%89%EF%BC%9Acheckout/</url>
    <content><![CDATA[<p>在git中，暂存区里有若干备份，版本库里有若干版本。留着这些东西肯定是拿来用的对吧，怎么用呢？当我需要哪一份的时候我就切换到哪一份。<br><code>git checkout</code>命令就是用来干这个的，官方术语叫做<code>签出</code>。<br>怎么理解<code>checkout</code>这个词呢？<code>checkout</code>原本指的是消费结束服务员要与你核对一下账单，结完账之后你就可以走了。在git中核对指的是diff，比较两份版本的差异，如果发现没有冲突那就可以切换过来了。</p>
<a id="more"></a>

<h2 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h2><p>我们知道HEAD指针指向当前版本，而<code>git checkout</code>命令的作用是切换版本，它们肯定有所关联。<br>目前HEAD指针指向master分支。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ cat .git/HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">ref</span>: <span class="built_in">ref</span>s/heads/master</span></pre></td></tr></table></figure>

<p>如果我切换到另一个分支，会发生什么？</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git checkout dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched to branch <span class="string">'dev'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>cat .git/HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">ref:</span> refs/heads/dev</span></pre></td></tr></table></figure>

<p>果然，<code>git checkout</code>命令的原理就是改变了HEAD指针。而一旦HEAD指针改变，git就会取出HEAD指针指向的版本作为当前工作目录的版本。签出到一个没有分支引用的commit也是一样的。</p>
<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>在进入正题之前，我们要先聊聊git中的两个符号<code>~</code>和<code>^</code>。<br>如果我们要从一个分支切换到另一个分支，那还好说，足够语义化。但是如果我们要切换到某个commit，除了兢兢业业的找到它的SHA-1值，还有什么办法快速的引用到它呢？<br>比如说我们可以根据commit之间的谱系关系快速定位。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span> --graph --oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* 4e76510 (HEAD -&gt; master) c4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*   2ec8374 c3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|\</span></pre></td></tr><tr><td class="code"><pre><span class="line">| * <span class="number">7</span>c0a8e3 c2</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* | fb60f51 c1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|/</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* dc96a29 c0</span></span></pre></td></tr></table></figure>

<blockquote>
<p><code>~</code>的作用是在纵向上定位。它可以一直追溯到最早的祖先commit。如果commit历史有分叉，那它就选第一个，也就是主干上的那个。<br><code>^</code>的作用是在横向上定位。它无法向上追溯，但是如果commit历史有分叉，它能定位所有分叉中的任意一支。</p>
</blockquote>
<h3 id="HEAD不加任何符号、加-0-符号或者加-0符号时，定位的都是当前版本"><a href="#HEAD不加任何符号、加-0-符号或者加-0符号时，定位的都是当前版本" class="headerlink" title="HEAD不加任何符号、加~0 符号或者加^0符号时，定位的都是当前版本"></a>HEAD不加任何符号、加<code>~0</code> 符号或者加<code>^0</code>符号时，定位的都是当前版本</h3><p>这个不用说，定位当前commit。</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4e76510</span>fe8bb3c69de12068ab354ef37bba6da9d</span></pre></td></tr></table></figure>

<p>它表示定位第零代父commit，也就是当前commit。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD~<span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4e76510f</span>e8bb3c69de12068ab354ef37bba6da9d</span></pre></td></tr></table></figure>

<p>它表示定位当前commit的第零个父commit，也就是当前commit。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD^<span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4e76510f</span>e8bb3c69de12068ab354ef37bba6da9d</span></pre></td></tr></table></figure>

<h3 id="用-符号数量的堆砌或者-数量的写法定位第几代父commit"><a href="#用-符号数量的堆砌或者-数量的写法定位第几代父commit" class="headerlink" title="用~符号数量的堆砌或者~数量的写法定位第几代父commit"></a>用<code>~</code>符号数量的堆砌或者<code>~数量</code>的写法定位第几代父commit</h3><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD~~</span></pre></td></tr><tr><td class="code"><pre><span class="line">fb60f519a59e9ceeef039f7efd2a8439aa7efd4b</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD~<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">fb60f519a59e9ceeef039f7efd2a8439aa7efd4b</span></pre></td></tr></table></figure>

<h3 id="用-数量的写法定位第几个父commit"><a href="#用-数量的写法定位第几个父commit" class="headerlink" title="用^数量的写法定位第几个父commit"></a>用<code>^数量</code>的写法定位第几个父commit</h3><p>注意，<code>^</code>定位的是当前基础的父commit。</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD^</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span>ec837440051af433677f786e502d1f6cdeb0a4a</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD^<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span>ec837440051af433677f786e502d1f6cdeb0a4a</span></pre></td></tr></table></figure>

<p>因为当前commit只有一个父commit，所以定位第二个父commit会失败。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD^<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HEAD^<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">fata<span class="variable">l:</span> ambiguous <span class="keyword">argument</span> <span class="string">'HEAD^2'</span>: unknown revision <span class="built_in">or</span> path not in the working tree.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Use <span class="string">'--'</span> <span class="keyword">to</span> separate paths from revisions, like thi<span class="variable">s:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]'</span></span></pre></td></tr></table></figure>

<h3 id="用-数量-数量的写法或者-数量-数量的写法定位第几代父commit的第几个父commit"><a href="#用-数量-数量的写法或者-数量-数量的写法定位第几代父commit的第几个父commit" class="headerlink" title="用~数量^数量的写法或者^数量^数量的写法定位第几代父commit的第几个父commit"></a>用<code>~数量^数量</code>的写法或者<code>^数量^数量</code>的写法定位第几代父commit的第几个父commit</h3><p>当前commit的第一代父commit的第零个父commit，意思就是第一代父commit咯。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD~^<span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span>ec837440051af433677f786e502d1f6cdeb0a4a</span></pre></td></tr></table></figure>

<p>比如这里定位的是当前commit的第一代父commit的第一个父commit。再次注意，<code>^</code>定位的是当前基础的父commit。</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD~^<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">fb60f519a59e9ceeef039f7efd2a8439aa7efd4b</span></pre></td></tr></table></figure>

<p>这里定位的是当前commit的第一代父commit的第二个父commit。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD~^<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">7</span><span class="keyword">c</span><span class="number">0</span>a<span class="number">8e3</span>a<span class="number">325</span>ce<span class="number">1</span>b<span class="number">5</span>a<span class="number">1</span>cdeb<span class="number">8</span><span class="keyword">c</span><span class="number">89</span>bef<span class="number">1</span>ecf<span class="number">17</span><span class="keyword">c</span><span class="number">10</span><span class="keyword">c</span><span class="number">9</span></span></pre></td></tr></table></figure>

<p>同样，定位到一个不存在的commit会失败。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD~^<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HEAD~^<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">fata<span class="variable">l:</span> ambiguous <span class="keyword">argument</span> <span class="string">'HEAD~^3'</span>: unknown revision <span class="built_in">or</span> path not in the working tree.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Use <span class="string">'--'</span> <span class="keyword">to</span> separate paths from revisions, like thi<span class="variable">s:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]'</span></span></pre></td></tr></table></figure>

<p>和<code>~</code>不同，<code>^2</code>和<code>^^</code>的效果是不一样的。<code>^2</code>指的是第二个父commit，<code>^^</code>指的是第一个父commit的第一个父commit。</p>
<h2 id="切换到HEAD"><a href="#切换到HEAD" class="headerlink" title="切换到HEAD"></a>切换到HEAD</h2><p><code>git checkout</code>命令如果不带任何参数，默认会加上HEAD参数。而HEAD指针指向的就是当前commit。所以它并不会有任何签出动作。<br>前面没有提到的是，<code>git checkout</code>命令会有一个顺带效果：比较签出后的版本和暂存区之间的差异。<br>所以<code>git checkout</code>命令不带任何参数，意思就是比较当前commit和暂存区之间的差异。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ git checkout</span></pre></td></tr><tr><td class="code"><pre><span class="line">A	<span class="selector-tag">b</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line">A	<span class="selector-tag">b</span>.md</span></pre></td></tr></table></figure>

<h2 id="切换到commit"><a href="#切换到commit" class="headerlink" title="切换到commit"></a>切换到commit</h2><p>开发者用的最多的当然是切换分支。其实<code>checkout</code>后面不仅可以跟分支名，也可以跟commit的校验和，还可以用符号定位commit。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git checkout dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched to branch 'dev'</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout acb71fe</span></pre></td></tr><tr><td class="code"><pre><span class="line">Note: checking out 'acb71fe11f78d230b860692ea6648906153f3d27'.</span></pre></td></tr><tr><td class="code"><pre><span class="line">You are in 'detached HEAD' state. You can look around, make experimental</span></pre></td></tr><tr><td class="code"><pre><span class="line">changes and <span class="keyword">commit</span> them, <span class="keyword">and</span> you can discard <span class="keyword">any</span> commits you make <span class="keyword">in</span> this</span></pre></td></tr><tr><td class="code"><pre><span class="line">state <span class="keyword">without</span> impacting <span class="keyword">any</span> branches <span class="keyword">by</span> performing another checkout.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">If</span> you want <span class="keyword">to</span> <span class="keyword">create</span> a <span class="keyword">new</span> branch <span class="keyword">to</span> retain commits you <span class="keyword">create</span>, you may</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> so (<span class="keyword">now</span> <span class="keyword">or</span> later) <span class="keyword">by</span> <span class="keyword">using</span> -b <span class="keyword">with</span> the checkout command again. Example:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  git checkout -b &lt;<span class="keyword">new</span>-branch-<span class="keyword">name</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">HEAD</span> <span class="keyword">is</span> <span class="keyword">now</span> <span class="keyword">at</span> acb71fe... <span class="literal">null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout <span class="keyword">HEAD</span>~<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Note: checking <span class="keyword">out</span> <span class="string">'acb71fe11f78d230b860692ea6648906153f3d27'</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">You <span class="keyword">are</span> <span class="keyword">in</span> <span class="string">'detached HEAD'</span> state. You can look around, make experimental</span></pre></td></tr><tr><td class="code"><pre><span class="line">changes <span class="keyword">and</span> <span class="keyword">commit</span> them, <span class="keyword">and</span> you can discard <span class="keyword">any</span> commits you make <span class="keyword">in</span> this</span></pre></td></tr><tr><td class="code"><pre><span class="line">state <span class="keyword">without</span> impacting <span class="keyword">any</span> branches <span class="keyword">by</span> performing another checkout.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">If</span> you want <span class="keyword">to</span> <span class="keyword">create</span> a <span class="keyword">new</span> branch <span class="keyword">to</span> retain commits you <span class="keyword">create</span>, you may</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> so (<span class="keyword">now</span> <span class="keyword">or</span> later) <span class="keyword">by</span> <span class="keyword">using</span> -b <span class="keyword">with</span> the checkout command again. Example:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  git checkout -b &lt;<span class="keyword">new</span>-branch-<span class="keyword">name</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">HEAD</span> <span class="keyword">is</span> <span class="keyword">now</span> <span class="keyword">at</span> acb71fe... <span class="literal">null</span></span></pre></td></tr></table></figure>

<h2 id="创建分支并切换"><a href="#创建分支并切换" class="headerlink" title="创建分支并切换"></a>创建分支并切换</h2><p>有时候我们在创建分支时希望同时切换到创建后的分支，仅仅<code>git branch</code>是做不到的。这时<code>git checkout</code>命令可以提供一个快捷操作，创建分支和切换分支一步到位。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched <span class="built_in">to</span> <span class="keyword">a</span> <span class="built_in">new</span> branch <span class="string">'dev'</span></span></pre></td></tr></table></figure>

<h2 id="暂存区文件覆盖工作区文件"><a href="#暂存区文件覆盖工作区文件" class="headerlink" title="暂存区文件覆盖工作区文件"></a>暂存区文件覆盖工作区文件</h2><p><code>git checkout</code>不仅可以执行切换commit这种全量切换，它还能以文件为单位执行微观切换。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">No commits yet</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git rm --cached &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">new</span> <span class="keyword">file</span>:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout <span class="comment">-- a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">No</span> commits yet</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">to</span> be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git rm --cached &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">new</span> <span class="keyword">file</span>:   a.md</span></pre></td></tr></table></figure>

<p>因为暂存区覆盖了工作区，所以工作区的改动就被撤销了，现在只剩下暂存区的改动等待提交。其实相当于撤销文件在工作区的改动，只不过它的语义是覆盖。这个命令没有任何提示，直接撤销工作区改动，要谨慎使用。<br>我们看到git提示语中有一个<code>git checkout --</code>命令，这又是干嘛用的呢？<br>提醒一下，这个参数的写法不是<code>git checkout --</code>，而是<code>git checkout --</code>。<br>其实它和<code>git checkout</code>的效果是一样的。但是别急，我是说这两个命令<strong>想要</strong>达到的效果是一样的，但<strong>实际</strong>效果却有略微的差别。<br>独立的<code>--</code>参数在Linux命令行中指的是：视后面的参数为文件名。当后面跟的是文件名的时候，最好加上独立的<code>--</code>参数，以免有歧义。<br>也就是说，如果该项目正好有一个分支名为<code>a.md</code>(皮一下也不是不行对吧)，那加独立的<code>--</code>参数就不会操作分支，而是操作文件。<br>如果你觉得仅仅撤销一个文件在工作区的改动不过瘾，你不是针对谁，你是觉得工作区的改动都是垃圾。那么还有一个更危险的命令。</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">$ git checkout <span class="comment">-- .</span></span></pre></td></tr></table></figure>

<p><code>.</code>代表当前目录下的所有文件和子目录。这条命令会撤销所有工作区的改动。</p>
<h2 id="当前commit文件覆盖暂存区文件和工作区文件"><a href="#当前commit文件覆盖暂存区文件和工作区文件" class="headerlink" title="当前commit文件覆盖暂存区文件和工作区文件"></a>当前commit文件覆盖暂存区文件和工作区文件</h2><p>如果执行<code>git checkout --</code>的时候加上一个分支名或者commit的校验和，效果就是该文件的当前版本会同时覆盖暂存区和工作区。相当于同时撤销文件在暂存区和工作区的改动。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout <span class="keyword">HEAD</span> <span class="comment">-- a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">nothing</span> <span class="keyword">to</span> <span class="keyword">commit</span>, working tree clean</span></pre></td></tr></table></figure>

<p>最后再提醒一下，运行<code>git checkout</code>命令作用于文件时，即便覆盖内容与被覆盖内容有冲突，也会直接覆盖，所以这真的是闷声打雷式的git命令，一定要抽自己几个耳刮子方可放心食用。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/checkout.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/checkout.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（3）：branch</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%883%EF%BC%89%EF%BC%9Abranch/</url>
    <content><![CDATA[<p>分支是使得git如此灵活的强大武器，正是因为有巧妙的分支设计，众多的git工作流才成为可能。<br>现在我们已经知道commit对象其实就是git中的版本。那我们要在版本之间切换难道只能通过指定commit对象毫无意义的SHA-1值吗？<br>当然不是。<br>在git中，我们可以通过将一些指针指向commit对象来方便操作，这些指针便是分支。</p>
<a id="more"></a>

<blockquote>
<p>分支在git中是一个模棱两可的概念。<br>你可以认为它仅仅是一个指针，指向一个commit对象节点。<br>你也可以认为它是指针指向的commit对象节点追溯到某个交叉节点之间的commit历史。</p>
</blockquote>
<p>严格的来说，一种叫分支指针，一种叫分支历史。不过实际使用中，它们在名字上常常不作区分。<br>所以我们需要意会文字背后的意思，它究竟说的是分支指针还是分支历史。<br>大多数时候，它指的都是分支指针。</p>
<h2 id="master分支"><a href="#master分支" class="headerlink" title="master分支"></a>master分支</h2><p>刚刚初始化的git仓库，会发现<code>.git/refs/heads</code>目录下面是空的。这是因为目前版本库里还没有任何commit对象，而分支一定是指向commit对象的。<br>一旦版本库里有了第一个commit对象，git都会在<code>.git/refs/heads</code>目录下面自动生成一个<code>master</code>文件，它就是git的默认分支。不过它并不特殊，只是它充当的是一个默认角色而已。<br>刚刚初始化的git仓库会显示目前在master分支上，其实这个master分支是假的，<code>.git/refs/heads</code>目录下根本没有这个文件。只有等提交历史不为空时才有会真正的默认分支。<br>我们看一下<code>master</code>文件到底有什么。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ cat .git/refs/heads/<span class="literal">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">6</span>b5a94158cc141286ac98f30bb189b8a83d61347</span></pre></td></tr></table></figure>

<p>40个字符，明显是某个git对象的引用。再识别一下它的类型，发现是一个commit对象。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git cat-<span class="keyword">file</span> -t <span class="number">6</span>b5a941</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit</span></pre></td></tr></table></figure>

<p>就这么简单，所谓的分支(分支指针)就是一个指向某个commit对象的指针。</p>
<h2 id="HEAD指针"><a href="#HEAD指针" class="headerlink" title="HEAD指针"></a>HEAD指针</h2><p>形象的讲，HEAD就是景区地图上标注你当前在哪里的一个图标。<br>你当前在哪里，HEAD就在哪里。它一般指向某个分支，因为一般我们都会在某个分支之上。<br>因为HEAD是用来标注当前位置的，所以一旦HEAD的位置被改变，工作目录就会切换到HEAD指向的分支。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">log</span> <span class="comment">--oneline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">f53aaa7 (HEAD -&gt; master) <span class="keyword">commit</span> <span class="keyword">for</span> <span class="keyword">nothing</span></span></pre></td></tr></table></figure>

<p>但是也有例外，比如我直接签出到某个没有分支引用的commit。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> <span class="comment">--oneline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cb64064 (HEAD -&gt; master) commit <span class="keyword">for</span> nothing again</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">324</span>a3c0 commit <span class="keyword">for</span> nothing</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout <span class="number">324</span>a3c0</span></pre></td></tr><tr><td class="code"><pre><span class="line">Note: checking out <span class="string">'324a3c0'</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">You are <span class="keyword">in</span> <span class="string">'detached HEAD'</span> state. You can look around, make experimental</span></pre></td></tr><tr><td class="code"><pre><span class="line">changes <span class="keyword">and</span> commit them, <span class="keyword">and</span> you can discard <span class="keyword">any</span> commits you make <span class="keyword">in</span> this</span></pre></td></tr><tr><td class="code"><pre><span class="line">state <span class="keyword">without</span> impacting <span class="keyword">any</span> branches <span class="keyword">by</span> performing another checkout.</span></pre></td></tr><tr><td class="code"><pre><span class="line">If you want <span class="built_in">to</span> <span class="built_in">create</span> <span class="keyword">a</span> <span class="built_in">new</span> branch <span class="built_in">to</span> retain commits you <span class="built_in">create</span>, you may</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">do</span> so (now <span class="keyword">or</span> later) <span class="keyword">by</span> <span class="keyword">using</span> -b <span class="keyword">with</span> <span class="keyword">the</span> checkout <span class="keyword">command</span> <span class="title">again</span>. <span class="title">Example</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  git checkout -b &lt;<span class="built_in">new</span>-branch-name&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">HEAD is now <span class="keyword">at</span> <span class="number">324</span>a3c0... commit <span class="keyword">for</span> nothing</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> <span class="comment">--oneline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">324</span>a3c0 commit <span class="keyword">for</span> nothing</span></pre></td></tr></table></figure>

<p>这个时候的HEAD就叫做<code>detached HEAD</code>。<br>要知道，只有在初始提交和某个分支之间的commit才是有效的。当你的HEAD处于<code>detached HEAD</code>状态时，在它之上新建的commit没有被任何分支包裹。一旦你切换到别的分支，这个commit(可能)再也不会被引用到，最终会被垃圾回收机制删除。因此这是很危险的操作。</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="number">324</span><span class="variable">a3c0</span> -- <span class="function"><span class="title">cb64064</span>(<span class="variable">master</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   \</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">3899</span><span class="function"><span class="title">a24</span>(<span class="variable">HEAD</span>)</span></span></pre></td></tr></table></figure>

<p>如果不小心这么做了，要么在原地新建一个分支，要么将已有的分支强行移动过来。确保它不会被遗忘。</p>
<blockquote>
<p>死亡不是终结，遗忘才是。——寻梦环游记</p>
</blockquote>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>除了默认的<code>master</code>分支，我们可以随意创建新的分支。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>dev</span></pre></td></tr></table></figure>

<p>一个dev分支就创建好了。</p>
<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>或许有时我们也想要查看本地仓库有多少个分支，因为在git中新建分支实在是太容易了。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git branch</span></pre></td></tr><tr><td class="code"><pre><span class="line">  dev</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* master</span></span></pre></td></tr></table></figure>

<p>当前分支的前面会有一个<code>*</code>号标注。<br>同时查看本地分支和远端分支引用，添加<code>-a</code>参数。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git branch -a</span></pre></td></tr><tr><td class="code"><pre><span class="line">* <span class="literal">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  remotes/origin/HEAD -&gt; origin/<span class="literal">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  remotes/origin/<span class="literal">master</span></span></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>一般分支合并完之后就不再需要了，这时就要将它删除。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-d dev</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">Deleted</span> <span class="keyword">branch </span>dev (was <span class="number">657142</span>d).</span></pre></td></tr></table></figure>

<p>有时候我们会得到不一样的提示。</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">$ git branch -d dev</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">error: </span>The branch 'dev' is not fully merged.</span></pre></td></tr><tr><td class="code"><pre><span class="line">If you are sure you want to delete it, run 'git branch -D dev'.</span></pre></td></tr></table></figure>

<p>这是git的一种保护措施。<code>is not fully merged</code>是针对当前分支来说的，意思是你要删除的分支还有内容没有合并进<strong>当前分支</strong>，你确定要删除它吗？<br>大多数时候，当然是要的。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-D dev</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">Deleted</span> <span class="keyword">branch </span>dev (was <span class="number">657142</span>d).</span></pre></td></tr></table></figure>

<p><code>-D</code>是<code>--delete --force</code>的缩写，你也可以写成<code>-df</code>。<br>需要注意的是，删除分支仅仅是删除一个指针而已，并不会删除对应的commit对象。不过有可能删除分支以后，这一串commit对象就无法再被引用了，从而被垃圾回收机制删除。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/branch.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/branch.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（2）：commit</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%882%EF%BC%89%EF%BC%9Acommit/</url>
    <content><![CDATA[<p>git是一个版本管理系统。它的终极目的就是将项目特定时间的信息保留成一个版本，以便将来的回退和查阅。<br>我们已经介绍了暂存区，暂存区的下一步就是版本库，而促成这一步操作的是<code>git commit</code>命令。</p>
<a id="more"></a>

<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>暂存区有待提交内容的情况下，如果直接运行<code>git commit</code>命令，git会跳往默认编辑器要求你输入提交说明，你也可以自定义要跳往的编辑器。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Please enter the commit message for your changes. Lines starting</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># with '#' will be ignored, and an empty message aborts the commit.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># On branch master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Initial commit</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Changes to be committed:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#	new file:   a.md</span></span></pre></td></tr></table></figure>

<p>提交之后我们就看到这样的信息。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">[master (root-commit) <span class="number">99558b4</span>] commit <span class="keyword">for</span> nothing</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode <span class="number">100644</span> a.md</span></pre></td></tr></table></figure>

<p>如果我就是不写提交说明呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Aborting <span class="keyword">commit</span> due <span class="keyword">to</span> <span class="keyword">empty</span> <span class="keyword">commit</span> message.</span></pre></td></tr></table></figure>

<p>看到没有，提交信息在git中时必填的。<br>如果提交说明不多，可以加参数<code>-m</code>直接在命令后面填写提交说明。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git commit -m <span class="string">"commit for nothing"</span></span></pre></td></tr></table></figure>

<p>你甚至可以将加入暂存区和提交一并做了。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git commit -am <span class="string">"commit for nothing"</span></span></pre></td></tr></table></figure>

<p>但是要注意，和<code>git add -u</code>命令一样，未跟踪的文件是无法提交上去的。</p>
<h2 id="重写提交"><a href="#重写提交" class="headerlink" title="重写提交"></a>重写提交</h2><p><code>amend</code>翻译成中文是<code>修改</code>的意思。<code>git commit --amend</code>命令允许你修改最近的一次commit。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">log</span> <span class="comment">--oneline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">8274473</span> (HEAD -&gt; master) <span class="keyword">commit</span> <span class="keyword">for</span> <span class="keyword">nothing</span></span></pre></td></tr></table></figure>

<p>目前项目提交历史中只有一个commit。我突然想起来这次提交中有一个笔误，我把<code>高圆圆</code>写成了<code>高晓松</code>(真的是笔误)。但是呢，我又不想为了这个笔误增加一个commit，毕竟它仅仅是一个小小的笔误而已。最重要的是我想悄无声息的改正它，以免被别人笑话。<br>这时我就可以使用<code>git commit --amend</code>命令。<br>首先修改<code>高晓松</code>成<code>高圆圆</code>。<br>然后执行<code>git add a.md</code>命令。<br>最后重写提交。git会跳往默认或者自定义编辑器提示你修改commit说明。当然你也可以不改。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> <span class="comment">--amend</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">commit</span> <span class="keyword">for</span> <span class="keyword">nothing</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Please enter the commit message for your changes. Lines starting</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># with '#' will be ignored, and an empty message aborts the commit.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Date:      Thu Jan 3 09:33:56 2019 +0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># On branch master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Initial commit</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Changes to be committed:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#	new file:   a.md</span></span></pre></td></tr></table></figure>

<p>我们再来看提交历史。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">log</span> <span class="comment">--oneline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">8</span>a71ae1 (HEAD -&gt; master) <span class="keyword">commit</span> <span class="keyword">for</span> <span class="keyword">nothing</span></span></pre></td></tr></table></figure>

<p>提交历史中同样只有一个commit。但是注意哟，commit已经不是之前的那个commit了，它们的校验和是不一样的。这就是所谓的重写。</p>
<h2 id="tree对象和commit对象"><a href="#tree对象和commit对象" class="headerlink" title="tree对象和commit对象"></a>tree对象和commit对象</h2><p>commit操作涉及到两个git对象。<br>第一是tree对象。<br>它存储子目录和子文件的引用。如果只有blob对象，那版本库将是一团散沙。正因为有tree对象将它们的关系登记在册，才能构成一个有结构的版本库。<br>添加到暂存区操作并不会生成tree对象，这时项目的结构信息存储在<code>index</code>文件中，直到提交版本库操作，才会为每一个目录分别生成tree对象。<br>第二是commit对象。<br>它存储每个提交的信息，包括当前提交的根tree对象的引用，父commit对象的引用，作者和提交者，还有提交信息。所谓的版本，其实指的就是这个commit对象。<br>作者和提交者通常是一个人，但也存在不同人的情况。</p>
<h2 id="objects"><a href="#objects" class="headerlink" title="objects"></a>objects</h2><p>初始化一个git项目，新建一些文件和目录。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">src/</span></pre></td></tr><tr><td class="code"><pre><span class="line">src/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">lib</span>/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">lib</span>/<span class="title">b</span>.<span class="title">md</span></span></span></pre></td></tr></table></figure>

<p>首先运行<code>git add</code>命令。我们清楚，这会在<code>.git/objects</code>目录下生成一个blob对象，因为目前两个文件都是空文件，共享一个blob对象。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/info/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/pack/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391</span></span></pre></td></tr></table></figure>

<p>现在我们运行<code>git commit</code>命令，看看有什么变化。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/objects/info/</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/pack/</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/e6/<span class="number">9</span>de29bb2d1d6434b8b29ae775ad8c2e48c5391</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">93</span>/<span class="number">810</span>bbde0f994d41ef550324a2c1ad5f9278e19</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">52</span>/<span class="number">0</span>c9f9f61657ca1e65a288ea77d229a27a8171b</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">0</span>b/<span class="number">785f</span>a11cd93f95b1cab8b9cbab188edc7e04df</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">49</span>/<span class="number">11f</span>f67189d8d5cc2f94904fdd398fc16410d56</span></pre></td></tr></table></figure>

<p>有意思。刚刚只有一个blob对象，怎么突然蹦出来这么多git对象呢？想一想之前说的<code>commit操作涉及到两个git对象</code>这句话，有没有可能多出来的几个，分别是tree对象和commit对象？<br>我们使用git底层命令<code>git cat-file -t</code>查看这些对象的类型发现，其中有一个blob对象，三个tree对象，一个commit对象。<br>这是第一个tree对象。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git cat-<span class="keyword">file</span> -t <span class="number">93810</span>bb</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git cat-<span class="keyword">file</span> -p <span class="number">93810</span>bb</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">100644</span> blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391	b.md</span></pre></td></tr></table></figure>

<p>这是第二个tree对象。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git cat-<span class="keyword">file</span> -t <span class="number">520</span>c9f9</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git cat-<span class="keyword">file</span> -p <span class="number">520</span>c9f9</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">100644</span> blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391	a.md</span></pre></td></tr></table></figure>

<p>这是第三个tree对象。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">$ git cat-file -t <span class="number">0</span>b785fa</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git cat-file -p <span class="number">0</span>b785fa</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0</span>40000 tree <span class="number">93810</span>bbde0f994d41ef550324a2c1ad5f9278e19	<span class="class"><span class="keyword">lib</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0</span>40000 tree <span class="number">520</span>c9f9f61657ca1e65a288ea77d229a27a8171b	src</span></pre></td></tr></table></figure>

<p>可以看到，提交时每个目录都会生成对应的tree对象。<br>然后我们再来看commit对象。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git cat-file -t <span class="number">4911f</span>f6</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git cat-file -p <span class="number">4911f</span>f6</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree <span class="number">0</span>b785fa11cd93f95b1cab8b9cbab188edc7e04df</span></pre></td></tr><tr><td class="code"><pre><span class="line">parent c4731cfab38f036c04de93facf07cae496a124a2</span></pre></td></tr><tr><td class="code"><pre><span class="line">author veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt; <span class="number">1546395770</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">committer veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt; <span class="number">1546395770</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="keyword">for</span> nothing</span></pre></td></tr></table></figure>

<p>可以看到，commit会关联根目录的tree对象，因为关联它就可以关联到所有的项目结构信息，所谓擒贼先擒王嘛。它也要关联父commit，也就是它的上一个commit，这样才能组成版本历史。当然，如果是第一个commit那就没有父commit了。然后就是commit说明和一些参与者信息。<br>我们总结一下，<code>git add</code>命令会为加入暂存区的内容或文件生成blob对象，<code>git commit</code>命令会为加入版本库的内容或文件生成tree对象和commit对象。至此，四种git对象我们见识了三种。<br>为啥不在<code>git add</code>的时候就生成tree对象呢？<br>所谓暂存区，就是不一定会保存为版本的信息，只是一个准备的临时场所。git认为在<code>git add</code>的时候生成tree对象是不够高效的，完全可以等版本定型时再生成。而版本定型之前的结构信息存在<code>index</code>文件中就好了。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/commit.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/commit.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（1）：add</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%881%EF%BC%89%EF%BC%9Aadd/</url>
    <content><![CDATA[<p>git是一个数据库系统，git是一个内容寻址文件系统，git是一个版本管理系统。<br>没错，它都是。<br>不过我们不纠结于git是什么，我们单刀直入，介绍git命令。<br>要将未跟踪的文件和已跟踪文件的改动加入暂存区，我们可以使用<code>git add</code>命令。<br>不过很多人嫌<code>git add</code>命令不够语义化，毕竟这一步操作是加入暂存区呀。所以git又增加了另外一个命令<code>git stage</code>，它们的效果是一模一样的。</p>
<a id="more"></a>

<h2 id="git仓库、工作区和暂存区"><a href="#git仓库、工作区和暂存区" class="headerlink" title="git仓库、工作区和暂存区"></a>git仓库、工作区和暂存区</h2><p>进入主题之前，我们先要介绍一下git仓库、工作区和暂存区的概念。</p>
<h3 id="git仓库"><a href="#git仓库" class="headerlink" title="git仓库"></a>git仓库</h3><p>所谓的git仓库就是一个有<code>.git</code>目录的文件夹。它是和git有关的一切故事开始的地方。<br>可以使用<code>git init</code>命令初始化一个git仓库。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git init</span></pre></td></tr></table></figure>

<p>也可以使用<code>git clone</code>命令从服务器上克隆仓库到本地。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">git</span>@github.com:veedrin/horseshoe.git</span></pre></td></tr></table></figure>

<p>然后你的本地就有了一个和服务器上一模一样的git仓库。<br>这里要说明的是，<code>clone</code>操作并不是将整个仓库下载下来，而是只下载<code>.git</code>目录。因为关于git的一切秘密都在这个目录里面，只要有了它，git就能复原到仓库的任意版本。</p>
<h3 id="工作区-working-directory"><a href="#工作区-working-directory" class="headerlink" title="工作区(working directory)"></a>工作区(working directory)</h3><p>工作区，又叫工作目录，就是不包括<code>.git</code>目录的项目根目录。我们要在这个目录下进行手头的工作，它就是版本管理的素材库。你甚至可以称任何与工作有关的目录为工作区，只不过没有<code>.git</code>目录git是不认的。</p>
<h3 id="暂存区-stage或者index"><a href="#暂存区-stage或者index" class="headerlink" title="暂存区(stage或者index)"></a>暂存区(stage或者index)</h3><p><code>stage</code>在英文中除了有<code>舞台、阶段</code>之意外，还有作为动词的<code>准备、筹划</code>之意，所谓的暂存区就是一个为提交到版本库做准备的地方。<br>那它为什么又被称作<code>index</code>呢？因为暂存区在物理上仅仅是<code>.git</code>目录下的<code>index</code>二进制文件。它就是一个索引文件，将工作区中的文件和暂存区中的备份一一对应起来。<br><code>stage</code>是表意的，<code>index</code>是表形的。<br>你可以把暂存区理解为一个猪猪储钱罐。我们还是孩子的时候，手里有一毛钱就会丢进储钱罐里。等到储钱罐摇晃的声音变的浑厚时，或者我们有一个心愿急需用钱时，我们就砸开储钱罐，一次性花完。<br>类比到软件开发，每当我们写完一个小模块，就可以将它放入暂存区。等到一个完整的功能开发完，我们就可以从暂存区一次性提交到版本库里。<br>这样做的好处是明显的：</p>
<ul>
<li>它可以实现更小颗粒度的撤销。</li>
<li>它可以实现批量提交到版本库。</li>
</ul>
<p>另外，添加到暂存区其实包含两种操作。一种是将还未被git跟踪过的文件放入暂存区；一种是已经被git跟踪的文件，将有改动的内容放入暂存区。</p>
<h2 id="放入暂存区"><a href="#放入暂存区" class="headerlink" title="放入暂存区"></a>放入暂存区</h2><p>git默认是不会把工作区的文件放入暂存区的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">No commits yet</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked files:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">include</span> <span class="keyword">in</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">nothing</span> added <span class="keyword">to</span> <span class="keyword">commit</span> but untracked files <span class="keyword">present</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">to</span> track)</span></pre></td></tr></table></figure>

<p>我们看到文件现在被标注为<code>Untracked files</code>。表示git目前还无法追踪它们的变化，也就是说它们还不在暂存区里。<br>那么我们如何手动将文件或文件夹放入暂存区呢？</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> .</span></span></pre></td></tr></table></figure>

<p>上面的命令表示将工作目录所有未放入暂存区的文件都放入暂存区。这时文件的状态已经变成了<code>Changes to be committed</code>，表示文件已经放入暂存区，等待下一步提交。每一次add操作其实就是为加入的文件或内容生成一份备份。<br>下面的命令也能达到相同的效果。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> -A</span></span></pre></td></tr></table></figure>

<p>假如我只想暂存单个文件呢？后跟相对于当前目录的文件名即可。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> README.md</span></span></pre></td></tr></table></figure>

<p>暂存整个文件夹也是一样的道理。因为git会递归暂存文件夹下的所有文件。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> src</span></span></pre></td></tr></table></figure>

<p>把从来没有被标记过的文件放入暂存区的命令是<code>git add</code>，暂存区中的文件有改动也需要使用<code>git add</code>命令将改动放入暂存区。<br>这时状态变成了<code>Changes not staged for commit</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes not staged for <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span></pre></td></tr></table></figure>

<p>针对已经加入暂存区的文件，要将文件改动加入暂存区，还有一个命令。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> -u</span></span></pre></td></tr></table></figure>

<p>它和<code>git add -A</code>命令的区别在于，它只能将已加入暂存区文件的改动放入暂存区，而<code>git add -A</code>通吃两种情况。</p>
<h2 id="跟踪内容"><a href="#跟踪内容" class="headerlink" title="跟踪内容"></a>跟踪内容</h2><p>假设我们已经将文件加入暂存区，现在我们往文件中添加内容，再次放入暂存区，然后查看状态。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">No commits yet</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git rm --cached &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">new</span> <span class="keyword">file</span>:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr></table></figure>

<p>哎，突然变的有意思了。为什么一个文件会同时存在两种状态，它是薛定谔的猫么？<br>想象一下，我想在一个文件中先修复一个bug然后增加一个feather，我肯定希望分两次放入暂存区，这样可以实现颗粒度更细的撤销和提交。但是如果git是基于文件做版本管理的，它就无法做到。<br>所以git只能是基于内容做版本管理，而不是基于文件。版本管理的最小单位叫做hunk，所谓的hunk就是一段连续的改动。一个文件同时有两种状态也就不稀奇了。</p>
<h2 id="objects"><a href="#objects" class="headerlink" title="objects"></a>objects</h2><p>git项目的<code>.git</code>目录下面有一个目录<code>objects</code>，一开始这个目录下面只有两个空目录：<code>info</code>和<code>pack</code>。<br>一旦我们执行了<code>git add</code>命令，<code>objects</code>目录下面就会多出一些东西。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="title">.git/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/e6/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391</span></span></pre></td></tr></table></figure>

<p>它多出了一个2个字符命名的目录和一个38个字符命名的文件。加起来正好是40个字符。增加一个2个字符的目录是为了提高检索效率。<br>SHA-1是一种哈希加密算法，它的特点是只要加密的内容相同，得到的校验和也相同。当然这种说法是不准确的，但是碰撞的概率极低。<br>git除了用内容来计算校验和之外，还加入了一些其他信息，目的也是为了进一步降低碰撞的概率。<br>重点是，SHA-1算法是根据内容来计算校验和的，跟前面讲的git跟踪内容相呼应。git被称为一个内容寻址文件系统不是没有道理的。<br>我们可以做个实验。初始化本地仓库两次，每次都新建一个markdown文件，里面写<code>## git is awesome</code>，记下完整的40个字符的校验和，看看它们是否一样。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">56</span>/<span class="number">46</span>a656f6331e1b30988472fefd48686a99e10f</span></pre></td></tr></table></figure>

<p>如果你真的做了实验，你会发现即便两个文件的文件名和文件格式都不一样，只要内容一样，它们的校验和就是一样的，并且就是上面列出的校验和。<br>现在大家应该对<code>git跟踪内容</code>这句话有更深的理解了。</p>
<h3 id="相同内容引用一个对象"><a href="#相同内容引用一个对象" class="headerlink" title="相同内容引用一个对象"></a>相同内容引用一个对象</h3><p>虽然开发者要极力避免这种情况，但是如果一个仓库有多个内容相同的文件，git会如何处理呢？<br>我们初始化一个本地仓库，新建两个不同名的文件，但文件内容都是<code>## git is awesome</code>。运行<code>git add .</code>命令之后看看神秘的<code>objects</code>目录下会发生什么？</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">56</span>/<span class="number">46</span>a656f6331e1b30988472fefd48686a99e10f</span></pre></td></tr></table></figure>

<p>只有一个目录，而且校验和跟之前一模一样。<br>其实大家肯定早就想到了，git这么优秀的工具，怎么可能会让浪费磁盘空间的事情发生呢？既然多个文件的内容相同，肯定只保存一个对象，让它们引用到这里来就好了。</p>
<h3 id="文件改动对应新对象"><a href="#文件改动对应新对象" class="headerlink" title="文件改动对应新对象"></a>文件改动对应新对象</h3><p>现在我们猜测工作区的文件和<code>objects</code>目录中的对象是一一对应起来的。但事实真的是这样吗？<br>我们初始化一个本地仓库，新建一个markdown文件，运行<code>git add .</code>命令。现在<code>objects</code>目录中已经有了一个对象。然后往文件中添加内容<code>## git is awesome</code>。再次运行<code>git add .</code>命令。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/objects/e6/<span class="number">9</span>de29bb2d1d6434b8b29ae775ad8c2e48c5391</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">56</span>/<span class="number">46</span>a656f6331e1b30988472fefd48686a99e10f</span></pre></td></tr></table></figure>

<p>哎，<code>objects</code>目录中出现了两个对象。第一个对象肯定对应空文件。第二个对象我们太熟悉了，对应的是添加内容后的文件。<br>再次强调，git是一个版本管理系统，文件在它这里不是主角，版本才是。刚才我们暂存了两次，可以认为暂存区现在已经有了两个版本(暂存区的版本实际上是内容备份，并不是真正的版本)。当然就需要两个对象来保存。</p>
<h3 id="文件改动全量保存"><a href="#文件改动全量保存" class="headerlink" title="文件改动全量保存"></a>文件改动全量保存</h3><p>初始化一个本地仓库，往工作区添加<code>lodash.js</code>未压缩版本，版本号是<code>4.17.11</code>，体积大约是<code>540KB</code>。运行<code>git add .</code>命令后<code>objects</code>目录下面出现一个对象，体积大约是<code>96KB</code>。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/objects/cb/<span class="number">139</span>dd81ebee6f6ed5f5a9198471f5cdc876d70</span></pre></td></tr></table></figure>

<p>我们对<code>lodash.js</code>文件内容作一个小小的改动，将版本号从<code>4.17.11</code>改为<code>4.17.10</code>，再次运行<code>git add .</code>命令。然后大家会惊奇的发现<code>objects</code>目录下有两个对象了。惊奇的不是这个，而是第二个对象的体积也是大约<code>96KB</code>。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/cb/139dd81ebee6f6ed5f5a9198471f5cdc876d70</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/bf/c087eec7e61f106df8f5149091b8790e6f3636</span></span></pre></td></tr></table></figure>

<p>明明只改了一个数字而已，第二个对象却还是这么大。<br>前面刚夸git会精打细算，怎么到这里就不知深浅了？这是因为多个文件内容相同的情况，引用到同一个对象并不会造成查询效率的降低，而暂存区的多个对象之间如果只保存增量的话，版本之间的查询和切换需要花费额外的时间，这样做是不划算的。<br>但是全量保存也不是个办法吧。然而git鱼和熊掌想兼得，它也做到了。后面会讲到。</p>
<h3 id="重命名会拆分成删除和新建两个动作"><a href="#重命名会拆分成删除和新建两个动作" class="headerlink" title="重命名会拆分成删除和新建两个动作"></a>重命名会拆分成删除和新建两个动作</h3><p>初始化一个本地仓库，新建一个文件，运行<code>git add .</code>命令。然后重命名该文件，查看状态信息。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">No commits yet</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git rm --cached &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">new</span> <span class="keyword">file</span>:   <span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes not staged <span class="keyword">for</span> commi<span class="variable">t:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git add/rm &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will <span class="keyword">be</span> committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard <span class="keyword">changes</span> in working directory)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  deleted:    <span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked <span class="keyword">file</span><span class="variable">s:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> include in what will <span class="keyword">be</span> committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">b</span>.md</span></pre></td></tr></table></figure>

<p>这是由于git的内部机制导致的。生成对象的时候，它发现仓库中叫这个名字的文件不见了，于是标记为已删除，又发现有一个新的文件名是之前没有标记过的，于是标记为未跟踪。因为它只是重命名而已，文件内容并没有改变，所以可以共享对象，并不会影响效率。</p>
<h2 id="blob对象"><a href="#blob对象" class="headerlink" title="blob对象"></a>blob对象</h2><p>git的一切秘密都在<code>.git</code>目录里。因为它拥有项目的完整信息，所以git一定是把备份存在了某个地方。git把它们存在了哪里，又是如何存储它们的呢？<br>这些备份信息，git统一称它们为对象。git总共有四种对象类型，都存在<code>.git/objects</code>目录下。<br>这一次我们只介绍blob对象。<br>它存储文件的内容和大小。当开发者把未跟踪的文件或跟踪文件的改动加入暂存区，就会生成若干blob对象。git会对blob对象进行<code>zlib</code>压缩，以减少空间占用。<br>因为它只存储内容和大小，所以两个文件即便文件名和格式完全不一样，只要内容相同，就可以共享一个blob对象。<br>注意blob对象和工作目录的文件并不是一一对应的，因为工作目录的文件几乎会被多次添加到暂存区，这时一个文件会对应多个blob对象。</p>
<h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><p>仓库的<code>.git</code>目录下面有一个文件，它就是大名鼎鼎的暂存区。<br>是的，暂存区并不是一块区域，只是一个文件，确切的说，是一个索引文件。<br>它保存了项目结构、文件名、时间戳以及blob对象的引用。<br>工作区的文件和blob对象之间就是通过这个索引文件关联起来的。</p>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>还记得我们在<code>文件改动全量保存</code>小节里讲到，git鱼和熊掌想兼得么？<br>又想全量保存，不降低检索和切换速度，又想尽可能压榨体积。git是怎么做到的呢？<br>git会定期或者在推送到远端之前对git对象进行打包处理。<br>打包的时候保存文件最新的全量版本，基于该文件的历史版本的改动则只保存diff信息。因为开发者很少会切换到较早的版本中，所以这时候效率就可以部分牺牲。<br>需要注意的是，所有的git对象都会被打包，而不仅仅是blob对象。<br>git也有一个<code>git gc</code>命令可以手动执行打包。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git gc</span></pre></td></tr><tr><td class="code"><pre><span class="line">Counting objects: <span class="number">11</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Delta compression using up to <span class="number">4</span> threads.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">9</span>/<span class="number">9</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">11</span>/<span class="number">11</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="number">11</span> (delta <span class="number">3</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span></pre></td></tr></table></figure>

<p>之前的git对象文件都不见了，<code>pack</code>文件夹多了两个文件。其中 <code>.pack</code> 后缀文件存储的就是打包前git对象文件的实际内容。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/info/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/info/packs</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/pack/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/pack/pack-99b4704a207ea3cc4924c9f0febb6ea45d4cdfd2.idx</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/pack/pack-99b4704a207ea3cc4924c9f0febb6ea45d4cdfd2.pack</span></span></pre></td></tr></table></figure>

<p>只能说，<code>git gc</code>的语义化不够好。它的功能不仅仅是垃圾回收，还有打包。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/add.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/add.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>动态代理（AOP）使用及实现原理分析</title>
    <url>/2019/12/26/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%88AOP%EF%BC%89%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="一、什么是代理？"><a href="#一、什么是代理？" class="headerlink" title="一、什么是代理？"></a>一、什么是代理？</h1><p>代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。</p>
<a id="more"></a>

<p>代理模式UML图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190830132920-220f2.png" alt="img"></p>
<p>简单结构示意图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190830132921-94ede.png" alt="img"></p>
<p>为了保持行为的一致性，代理类和委托类通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。通过代理类这中间一层，能有效控制对委托类对象的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。Java 动态代理机制以巧妙的方式近乎完美地实践了代理模式的设计理念。</p>
<h1 id="二、Java-动态代理类"><a href="#二、Java-动态代理类" class="headerlink" title="二、Java 动态代理类"></a>二、Java 动态代理类</h1><p>Java动态代理类位于java.lang.reflect包下，一般主要涉及到以下两个类：<br>(1)Interface InvocationHandler：该接口中仅定义了一个方法</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> object invoke(Object obj,<span class="function"><span class="keyword">Method</span> <span class="title">method</span>, <span class="title">Object</span>[] <span class="title">args</span>)</span></span></pre></td></tr></table></figure>

<p>在实际使用时，第一个参数obj一般是指代理类，method是被代理的方法，如上例中的request()，args为该方法的参数数组。这个抽象方法在代理类中动态实现。<br>(2)Proxy：该类即为动态代理类，其中主要包含以下内容：<br>protected Proxy(InvocationHandler h)：构造函数，用于给内部的h赋值。<br>static Class getProxyClass(<br>ClassLoader loader,<br>Class[] interfaces)：获得一个代理类，其中loader是类装载器，interfaces是真实类所拥有的全部接口的数组。<br>static Object newProxyInstance(ClassLoaderloader, Class[] interfaces,InvocationHandler h)：返回代理类的一个实例，返回后的代理类可以当作被代理类使用(可使用被代理类的在Subject接口中声明过的方法)<br>所谓DynamicProxy是这样一种class：它是在运行时生成的class，在生成它时你必须提供一组interface给它，然后该class就宣称它实现了这些interface。你当然可以把该class的实例当作这些interface中的任何一个来用。当然，这个DynamicProxy其实就是一个Proxy，它不会替你作实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工作。<br>在使用动态代理类时，我们必须实现InvocationHandler接口<br>通过这种方式，被代理的对象(RealSubject)可以在运行时动态改变，需要控制的接口(Subject接口)可以在运行时改变，控制的方式(DynamicSubject类)也可以动态改变，从而实现了非常灵活的动态代理关系。<br>动态代理步骤：</p>
<ol>
<li>创建一个实现接口InvocationHandler的类，它必须实现invoke方法</li>
<li>创建被代理的类以及接口</li>
<li>通过Proxy的静态方法</li>
</ol>
<p>newProxyInstance(ClassLoaderloader,Class[]interfaces,InvocationHandler h)创建一个代理</p>
<ol>
<li>通过代理调用方法</li>
</ol>
<h1 id="三、JDK的动态代理怎么使用？"><a href="#三、JDK的动态代理怎么使用？" class="headerlink" title="三、JDK的动态代理怎么使用？"></a>三、JDK的动态代理怎么使用？</h1><p>1、需要动态代理的接口：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jiankunking;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 需要动态代理的接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 你好</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * @param name</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * @return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> SayHello(<span class="keyword">String</span> name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 再见</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * @return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> SayGoodBye();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>2、需要代理的实际对象</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">package jiankunking;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>实际对象</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> */</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>你好</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param name</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public <span class="built_in">String</span> SayHello(<span class="built_in">String</span> name) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>再见</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public <span class="built_in">String</span> SayGoodBye() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">" good bye "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>3、调用处理器实现类（有木有感觉这里就是传说中的AOP啊）</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">package jiankunking;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>调用处理器实现类</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>每次生成动态代理类对象时都需要指定一个实现了该接口的调用处理器对象</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> */</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">InvocationHandlerImpl</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>这个就是我们要代理的真实对象</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    private <span class="built_in">Object</span> subject;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>构造方法，给我们要代理的真实对象赋初值</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param subject</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public InvocationHandlerImpl(<span class="built_in">Object</span> subject) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.subject = subject;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>该方法负责集中处理动态代理类上的所有方法调用。</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param proxy  代理类实例</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param method 被调用的方法对象</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param args   调用参数</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@throws Throwable</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public <span class="built_in">Object</span> invoke(<span class="built_in">Object</span> proxy, Method method, <span class="built_in">Object</span>[] args) throws Throwable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//在代理真实对象前我们可以添加一些自己的操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"在调用之前，我要干点啥呢？"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Method:"</span> + method);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">Object</span> returnValue = method.invoke(subject, args);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//在代理真实对象后我们也可以添加一些自己的操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"在调用之后，我要干点啥呢？"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> returnValue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>4、测试</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package jiankunking;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.lang.reflect.Proxy;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 动态代理演示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> DynamicProxyDemonstration &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//代理的真实对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Subject realSubject = <span class="keyword">new</span> <span class="constructor">RealSubject()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 即：要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        InvocationHandler handler = <span class="keyword">new</span> <span class="constructor">InvocationHandlerImpl(<span class="params">realSubject</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ClassLoader loader = handler.get<span class="constructor">Class()</span>.get<span class="constructor">ClassLoader()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Class&lt;?&gt;<span class="literal">[]</span> interfaces = realSubject.get<span class="constructor">Class()</span>.get<span class="constructor">Interfaces()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Subject subject = (Subject) <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(<span class="params">loader</span>, <span class="params">interfaces</span>, <span class="params">handler</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"动态代理对象的类型："</span> + subject.get<span class="constructor">Class()</span>.get<span class="constructor">Name()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String hello = subject.<span class="constructor">SayHello(<span class="string">"jiankunking"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(hello);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//        String goodbye = subject.SayGoodBye();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//        System.out.println(goodbye);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>5、输出结果如下：</p>
<p><img src="http://image.winrains.cn/2019/08/20190830132921-616a4.png" alt="img"></p>
<h1 id="四、动态代理怎么实现的？"><a href="#四、动态代理怎么实现的？" class="headerlink" title="四、动态代理怎么实现的？"></a>四、动态代理怎么实现的？</h1><p>从使用代码中可以看出，关键点在：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Subject subject = (Subject) <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(<span class="params">loader</span>, <span class="params">interfaces</span>, <span class="params">handler</span>)</span>;</span></pre></td></tr></table></figure>

<p>通过跟踪提示代码可以看出：当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用。<br>也就是说，当代码执行到：subject.SayHello(“jiankunking”)这句话时，会自动调用InvocationHandlerImpl的invoke方法。这是为啥呢？</p>
<blockquote>
<p>下面是代码跟分析的过程，不想看的朋友可以直接看结论</p>
</blockquote>
<p>以下代码来自:JDK1.8.0_92<br>既然生成代理对象是用的Proxy类的静态方newProxyInstance，那么我们就去它的源码里看一下它到底都做了些什么？</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Returns </span>an<span class="markdown"> instance of </span>a<span class="markdown"> proxy class for </span>the<span class="markdown"> specified interfaces</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>that dispatches method invocations to </span>the<span class="markdown"> specified invocation</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>handler.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> *</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>&#123;@code Proxy.newProxyInstance&#125; throws</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#123;@code IllegalArgumentException&#125; for </span>the<span class="markdown"> same reasons that</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#123;@code Proxy.getProxyClass&#125; does.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> *</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param   loader </span>the<span class="markdown"> class loader to define </span>the<span class="markdown"> proxy class</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param   interfaces </span>the<span class="markdown"> list of interfaces for </span>the<span class="markdown"> proxy class</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>to implement</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param   h </span>the<span class="markdown"> invocation handler to dispatch method invocations to</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@return  </span>a<span class="markdown"> proxy instance with </span>the<span class="markdown"> specified invocation handler of </span>a</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>proxy class that is defined by </span>the<span class="markdown"> specified class loader</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>and that implements </span>the<span class="markdown"> specified interfaces</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@throws  IllegalArgumentException if any of </span>the<span class="markdown"> restrictions on </span>the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>parameters that may be passed to &#123;@code getProxyClass&#125;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span></span>are<span class="markdown"> violated</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@throws  SecurityException if </span>a<span class="markdown"> security manager, <span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span></span>s<span class="xml"><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span>, is present</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>and any of </span>the<span class="markdown"> following conditions is met:</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span> </span>the<span class="markdown"> given &#123;@code loader&#125; is &#123;@code null&#125; and</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span></span>the<span class="markdown"> caller's class loader is not &#123;@code null&#125; and </span>the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>invocation of &#123;@link SecurityManager#checkPermission</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>s.checkPermission&#125; with</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>&#123;@code RuntimePermission("getClassLoader")&#125; permission</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>denies access;<span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span> for each proxy interface, &#123;@code intf&#125;,</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span></span>the<span class="markdown"> caller's class loader is not </span>the<span class="markdown"> same as or </span>an</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>ancestor of </span>the<span class="markdown"> class loader for &#123;@code intf&#125; and</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>invocation of &#123;@link SecurityManager#checkPackageAccess</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>s.checkPackageAccess()&#125; denies access to &#123;@code intf&#125;;<span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span> any of </span>the<span class="markdown"> given proxy interfaces is non-public and </span>the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>caller class is not in </span>the<span class="markdown"> same &#123;@linkplain Package runtime package&#125;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>as </span>the<span class="markdown"> non-public interface and </span>the<span class="markdown"> invocation of</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>&#123;@link SecurityManager#checkPermission s.checkPermission&#125; with</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>&#123;@code ReflectPermission("newProxyInPackage.&#123;package name&#125;")&#125;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>permission denies access.<span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@throws  NullPointerException if </span>the<span class="markdown"> &#123;@code interfaces&#125; array</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>argument or any of its elements </span>are<span class="markdown"> &#123;@code null&#125;, or</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>if </span>the<span class="markdown"> invocation handler, &#123;@code h&#125;, is</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>&#123;@code null&#125;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> */</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="built_in">Object</span> newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throws IllegalArgumentException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 检查h 不为空，否则抛异常</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Objects.requireNonNull(h);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 获得与指定类装载器和一组接口相关的代理类类型对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 通过反射获取构造函数对象并生成代理类实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 获取代理对象的构造方法（也就是$Proxy0(InvocationHandler h)）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                public Void run() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    cons.setAccessible(<span class="keyword">true</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 生成代理类的实例并把InvocationHandlerImpl的实例传给它的构造方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="built_in">Object</span>[] &#123; h &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Throwable t = e.getCause();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (t instanceof RuntimeException) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们再进去getProxyClass0方法看一下：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Generate a proxy class. Must call the checkProxyAccess method to perform</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * permission checks before calling this.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">Class</span>&lt;?&gt; getProxyClass0(ClassLoader loader, <span class="keyword">Class</span>&lt;?&gt;... interfaces) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// If the proxy class defined by the given loader implementing</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>真相还是没有来到，继续，看一下 proxyClassCache</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * a cache of proxy classes</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, <span class="keyword">Class</span>&lt;?&gt;[], <span class="keyword">Class</span>&lt;?&gt;&gt; proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span></pre></td></tr></table></figure>

<p>奥，原来用了一下缓存啊<br>那么它对应的get方法啥样呢？</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Look-up </span>the<span class="markdown"> value through </span>the<span class="markdown"> cache. This always evaluates </span>the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#123;@code subKeyFactory&#125; function and optionally evaluates</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#123;@code valueFactory&#125; function if there is no entry in </span>the<span class="markdown"> cache for given</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>pair of (key, subKey) or </span>the<span class="markdown"> entry has already been cleared.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> *</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param key</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *            </span>possibly null key</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param parameter</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *            </span>parameter used together with key to create sub-key and value</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *            </span>(</span>should<span class="markdown"> not be null)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@return </span>the<span class="markdown"> cached value (never null)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@throws NullPointerException</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *             </span>if &#123;@code parameter&#125; passed in or &#123;@code sub-key&#125; calculated</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *             </span>by &#123;@code subKeyFactory&#125; or &#123;@code value&#125; calculated by</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *             </span>&#123;@code valueFactory&#125; is null.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> */</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public V <span class="keyword">get</span>(K key, P parameter) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Objects.requireNonNull(parameter);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    expungeStaleEntries();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">Object</span> cacheKey = CacheKey.valueOf(key, refQueue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// lazily install the 2nd level valuesMap for the particular cacheKey</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ConcurrentMap&lt;<span class="built_in">Object</span>, Supplier&lt;V&gt;&gt; valuesMap = map.<span class="keyword">get</span>(cacheKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (valuesMap == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// putIfAbsent这个方法在key不存在的时候加入一个值,如果key存在就不放入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ConcurrentMap&lt;<span class="built_in">Object</span>, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                valuesMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (oldValuesMap != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            valuesMap = oldValuesMap;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// subKey from valuesMap</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">Object</span> subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.<span class="keyword">get</span>(subKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Factory <span class="keyword">factory</span> = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// supplier might be a Factory or a CacheValue&lt;V&gt; instance</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            V value = supplier.<span class="keyword">get</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// else no supplier in cache</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// or a supplier that returned null (could be a cleared CacheValue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// or a Factory that wasn't successful in installing the CacheValue)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// lazily construct a Factory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">factory</span> == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">factory</span> = <span class="keyword">new</span> Factory(key, parameter, subKey, valuesMap);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            supplier = valuesMap.putIfAbsent(subKey, <span class="keyword">factory</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// successfully installed Factory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                supplier = <span class="keyword">factory</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// else retry with winning supplier</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (valuesMap.replace(subKey, supplier, <span class="keyword">factory</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// successfully replaced</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// cleared CacheEntry / unsuccessful Factory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// with our Factory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                supplier = <span class="keyword">factory</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// retry with current supplier</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                supplier = valuesMap.<span class="keyword">get</span>(subKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们可以看到它调用了 supplier.get(); 获取动态代理类，其中supplier是Factory,这个类定义在WeakCach的内部。<br>来瞅瞅，get里面又做了什么？</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> synchronized V <span class="title">get</span>(<span class="params"></span>)</span> &#123; <span class="comment">// serialize access</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// re-check</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.<span class="keyword">get</span>(subKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (supplier != <span class="keyword">this</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// something changed while we were waiting:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// might be that we were replaced by a CacheValue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// or were removed because of failure -&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// return null to signal WeakCache.get() to retry</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// the loop</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// else still us (supplier == this)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// create new value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    V <span class="keyword">value</span> = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">value</span> = Objects.requireNonNull(valueFactory.apply(key, parameter));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="literal">null</span>) &#123; <span class="comment">// remove us on failure</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            valuesMap.<span class="keyword">remove</span>(subKey, <span class="keyword">this</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// the only path to reach here is with non-null value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    assert <span class="keyword">value</span> != <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// wrap value with CacheValue (WeakReference)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    CacheValue&lt;V&gt; cacheValue = <span class="keyword">new</span> CacheValue&lt;&gt;(<span class="keyword">value</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// try replacing us with CacheValue (this should always succeed)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (valuesMap.replace(subKey, <span class="keyword">this</span>, cacheValue)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// put also in reverseMap</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        reverseMap.put(cacheValue, Boolean.TRUE);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Should not reach here"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// successfully replaced us with new CacheValue -&gt; return the value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// wrapped by it</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">value</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>发现重点还是木有出现，但我们可以看到它调用了valueFactory.apply(key, parameter)方法：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * A factory function that generates, defines and returns the proxy class</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * given the ClassLoader and array of interfaces.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> ProxyClassFactory <span class="keyword">implements</span> BiFunction&lt;ClassLoader, <span class="keyword">Class</span>&lt;?&gt;[], <span class="keyword">Class</span>&lt;?&gt;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// prefix for all proxy class names</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// next number to use for generation of unique proxy class names</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">Class</span>&lt;?&gt; apply(ClassLoader loader, <span class="keyword">Class</span>&lt;?&gt;[] interfaces) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Map&lt;<span class="keyword">Class</span>&lt;?&gt;, <span class="keyword">Boolean</span>&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">Class</span>&lt;?&gt; intf : interfaces) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * Verify that the class loader resolves the name of this</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * interface to the same Class object.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">Class</span>&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                interfaceClass = <span class="keyword">Class</span>.forName(intf.getName(), <span class="keyword">false</span>, loader);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (interfaceClass != intf) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(intf + <span class="string">" is not visible from class loader"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * Verify that the Class object actually represents an</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * interface.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * Verify that this interface is not a duplicate.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (interfaceSet.put(interfaceClass, <span class="keyword">Boolean</span>.<span class="keyword">TRUE</span>) != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"repeated interface: "</span> + interfaceClass.getName());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String proxyPkg = <span class="keyword">null</span>; <span class="comment">// package to define proxy class in</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> accessFlags = Modifier.<span class="keyword">PUBLIC</span> | Modifier.<span class="keyword">FINAL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * Record the package of a non-public proxy interface so that the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * proxy class will be defined in the same package. Verify that all</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * non-public proxy interfaces are in the same package.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">Class</span>&lt;?&gt; intf : interfaces) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> flags = intf.getModifiers();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                accessFlags = Modifier.<span class="keyword">FINAL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                String name = intf.getName();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    proxyPkg = pkg;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"non-public interfaces from different packages"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * Choose a name for the proxy class to generate.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String proxyName = proxyPkg + proxyClassNamePrefix + num;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * Generate the specified proxy class.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> defineClass0(loader, proxyName, proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * A ClassFormatError here means that (barring bugs in the proxy</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * class generation code) there was some other invalid aspect of</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * the arguments supplied to the proxy class creation (such as</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * virtual machine limitations exceeded).</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过看代码终于找到了重点：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成字节码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">byte<span class="literal">[]</span> proxyClassFile = <span class="module-access"><span class="module"><span class="identifier">ProxyGenerator</span>.</span></span>generate<span class="constructor">ProxyClass(<span class="params">proxyName</span>, <span class="params">interfaces</span>, <span class="params">accessFlags</span>)</span>;</span></pre></td></tr></table></figure>

<p>那么接下来我们也使用测试一下，使用这个方法生成的字节码是个什么样子：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package jiankunking;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import sun.misc.ProxyGenerator;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.File;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.FileNotFoundException;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.FileOutputStream;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.IOException;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.lang.reflect.Proxy;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 动态代理演示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> DynamicProxyDemonstration &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//代理的真实对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Subject realSubject = <span class="keyword">new</span> <span class="constructor">RealSubject()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 即：要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        InvocationHandler handler = <span class="keyword">new</span> <span class="constructor">InvocationHandlerImpl(<span class="params">realSubject</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ClassLoader loader = handler.get<span class="constructor">Class()</span>.get<span class="constructor">ClassLoader()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Class<span class="literal">[]</span> interfaces = realSubject.get<span class="constructor">Class()</span>.get<span class="constructor">Interfaces()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Subject subject = (Subject) <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(<span class="params">loader</span>, <span class="params">interfaces</span>, <span class="params">handler</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"动态代理对象的类型："</span>+subject.get<span class="constructor">Class()</span>.get<span class="constructor">Name()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String hello = subject.<span class="constructor">SayHello(<span class="string">"jiankunking"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(hello);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 将生成的字节码保存到本地，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        create<span class="constructor">ProxyClassFile()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> static void create<span class="constructor">ProxyClassFile()</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String name = <span class="string">"ProxySubject"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        byte<span class="literal">[]</span> data = <span class="module-access"><span class="module"><span class="identifier">ProxyGenerator</span>.</span></span>generate<span class="constructor">ProxyClass(<span class="params">name</span>,<span class="params">new</span> Class[]&#123;Subject.<span class="params">class</span>&#125;)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        FileOutputStream out =null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            out = <span class="keyword">new</span> <span class="constructor">FileOutputStream(<span class="params">name</span>+<span class="string">".class"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println((<span class="keyword">new</span> <span class="constructor">File(<span class="string">"hello"</span>)</span>).get<span class="constructor">AbsolutePath()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            out.write(data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.print<span class="constructor">StackTrace()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; catch (IOException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.print<span class="constructor">StackTrace()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;finally &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(null!=out) <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                out.close<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; catch (IOException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                e.print<span class="constructor">StackTrace()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看一下这里代理对象的类型：</p>
<p><img src="http://image.winrains.cn/2019/08/20190830132922-3ea54.png" alt="img"></p>
<p>我们用jd-jui 工具将生成的字节码反编译：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jiankunking.Subject;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> final <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">Proxy</span></span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Subject</span></span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> ProxySubject(InvocationHandler paramInvocationHandler) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">super</span>(paramInvocationHandler);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> final boolean equals(Object paramObject) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> ((Boolean) <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="type">Object</span>[] &#123; paramObject &#125;)).booleanValue();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Error | RuntimeException localError) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> localError;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> final <span class="keyword">String</span> SayGoodBye() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> (<span class="keyword">String</span>) <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Error | RuntimeException localError) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> localError;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> final <span class="keyword">String</span> SayHello(<span class="keyword">String</span> paramString) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> (<span class="keyword">String</span>) <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m4, <span class="keyword">new</span> <span class="type">Object</span>[] &#123; paramString &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Error | RuntimeException localError) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> localError;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> final <span class="keyword">String</span> toString() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> (<span class="keyword">String</span>) <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m2, <span class="literal">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Error | RuntimeException localError) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> localError;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> final int hashCode() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> ((Integer) <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m0, <span class="literal">null</span>)).intValue();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Error | RuntimeException localError) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> localError;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">new</span> <span class="type">Class</span>[] &#123; Class.forName(<span class="string">"java.lang.Object"</span>) &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m3 = Class.forName(<span class="string">"jiankunking.Subject"</span>).getMethod(<span class="string">"SayGoodBye"</span>, <span class="keyword">new</span> <span class="type">Class</span>[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m4 = Class.forName(<span class="string">"jiankunking.Subject"</span>).getMethod(<span class="string">"SayHello"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">new</span> <span class="type">Class</span>[] &#123; Class.forName(<span class="string">"java.lang.String"</span>) &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> <span class="type">Class</span>[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> <span class="type">Class</span>[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException localNoSuchMethodException) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchMethodError</span>(localNoSuchMethodException.getMessage());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException localClassNotFoundException) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoClassDefFoundError</span>(localClassNotFoundException.getMessage());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这就是最终真正的代理类，它继承自Proxy并实现了我们定义的Subject接口，也就是说：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Subject subject = (Subject) <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(<span class="params">loader</span>, <span class="params">interfaces</span>, <span class="params">handler</span>)</span>;</span></pre></td></tr></table></figure>

<p>这里的subject实际是这个类的一个实例，那么我们调用它的：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">String</span> SayHello(<span class="keyword">String</span> paramString)</span></pre></td></tr></table></figure>

<p>就是调用我们定义的InvocationHandlerImpl的 invoke方法：</p>
<p><img src="http://image.winrains.cn/2019/08/20190830132923-38112.png" alt="img"></p>
<blockquote>
<p>上面是代码跟分析的过程，不想看的朋友可以直接看结论</p>
</blockquote>
<h1 id="五、结论"><a href="#五、结论" class="headerlink" title="五、结论"></a>五、结论</h1><p>到了这里，终于解答了：<br>subject.SayHello(“jiankunking”)这句话时，为什么会自动调用InvocationHandlerImpl的invoke方法？<br>因为JDK生成的最终真正的代理类，它继承自Proxy并实现了我们定义的Subject接口，在实现Subject接口方法的内部，通过反射调用了InvocationHandlerImpl的invoke方法。<br>通过分析代码可以看出Java 动态代理，具体有如下四步骤：</p>
<ol>
<li>通过实现 InvocationHandler 接口创建自己的调用处理器；</li>
<li>通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；</li>
<li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li>
<li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li>
</ol>
<p>演示代码下载： <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fjiankunking%2FDynamicProxyDemo">github.com/jiankunking…</a></p>
<blockquote>
<p>作者：衣舞晨风</p>
<p>来源：<a href="https://juejin.im/post/5d31c1b7f265da1b9421845d" target="_blank" rel="noopener">https://juejin.im/post/5d31c1b7f265da1b9421845d</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL探索（8）：InnoDB的事务</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%888%EF%BC%89%EF%BC%9AInnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>事务是数据库最为重要的机制之一，凡是使用过数据库的人，都了解数据库的事务机制，也对ACID四个基本特性如数家珍。但是聊起事务或者ACID的底层实现原理，往往言之不详，不明所以。所以，今天我们就一起来分析和探讨InnoDB的事务机制，希望能建立起对事务底层实现原理的具体了解。</p>
<a id="more"></a>

<p><img src="http://image.winrains.cn/2019/10/20191031175432-e26fb.jpeg" alt="img"></p>
<p>事务的四大特性</p>
<p>数据库事务具有ACID四大特性。ACID是以下4个词的缩写：</p>
<ul>
<li>原子性(atomicity) ：事务最小工作单元，要么全成功，要么全失败 。</li>
<li>一致性(consistency)： 事务开始和结束后，数据库的完整性不会被破坏 。</li>
<li>隔离性(isolation) ：不同事务之间互不影响，四种隔离级别为RU（读未提交）、RC（读已提交）、RR（可重复读）、SERIALIZABLE （串行化）。</li>
<li>持久性(durability) ：事务提交后，对数据的修改是永久性的，即使系统故障也不会丢失 。</li>
</ul>
<p>下面，我们就以一个具体实例来介绍数据库事务的原理，并介绍InnoDB是如何实现ACID四大特性的。</p>
<h2 id="示例介绍"><a href="#示例介绍" class="headerlink" title="示例介绍"></a>示例介绍</h2><p>我们首先来看一下具体的示例。大家可以自己亲自试验一下，这样理解和记忆都会更加深刻。<br>首先，使用如下的SQL语句创建两张表，分别是goods和trade，代表货物和交易。并向goods表中插入一条记录，id为1的货物数量为10。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> goods (<span class="keyword">id</span> <span class="built_in">INT</span>, <span class="keyword">num</span> <span class="built_in">INT</span>, PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> trade (<span class="keyword">id</span> <span class="built_in">INT</span>, goods_id <span class="built_in">INT</span>, user_id <span class="built_in">INT</span>, PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> goods <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">10</span>);</span></pre></td></tr></table></figure>

<p>然后打开终端，连接数据库，开启会话一，先用BEGIN显示开启一个事务。会话一先将goods表中id为1的货物的数量减一，然后向trade表中添加一笔交易的记录，最后使用COMMIT显示提交事务。<br>而会话二则先查询goods表中id为1的货物数量，然后向trade表中添加一笔交易记录，接着更新goods表中id为1的货物的数量，最后使用ROLLBACK进行事务的回滚。其中，两个会话中执行的具体语句和先后顺序如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175433-821a1.jpeg" alt="img"></p>
<p>示例具体语句和执行顺序</p>
<p>这个示例可以体现数据库事务的很多特性，我们一一来介绍。首先会话一的操作2更新了id为1的货物的数量，但是会话二的操作5读出来的数量仍然是10，这体现了事务的隔离性，使用InnoDB的<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483698&idx=1&sn=3654042755c7ea0922e5d5b462930946&chksm=fc04c552cb734c443f771eb2075cd4d4ce85df85105805667cc4cf51a67ceed2f9ebdf1a8cde&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">多版本控制机制</a>实现。<br>会话二的操作7也要更新同种货物的数量，此时因为会话一的操作2已经更新了该货物的数量，InnoDB已经锁住了该记录的行锁，所以操作7会被阻塞，直到会话一COMMIT。但是会话一的操作4和会话二的操作7都是向trade表中插入记录，后者却不会因为前者而阻塞，因为二者插入的不是同一行记录。锁机制是一种常见的并发控制机制，它和多版本控制机制一起实现了InnoDB事务的隔离性，关于InnoDB锁相关的具体内容可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483694&idx=1&sn=671ad369f67441c7d1572110066d5695&chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB锁的类型和状态查询</a>和<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483702&idx=1&sn=669fb9f413db0cc744bdb5b9ec8f725e&chksm=fc04c556cb734c40b3c90a55868619b8ca1f3e1f8763be2d6e7f0568d7c992409937c33b7e10&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB行锁算法</a>。</p>
<p>会话一事务最终使用COMMIT提交了事务而会话二事务则使用ROLLBACK回滚了整个事务，这体现了事务的原子性。即事务的一系列操作要么全部执行(COMMIT)，要么就全部不执行(ROLLBACK)，不存在只执行一部分的情况。InnoDB使用事务日志系统来实现事务的原子性。这里有的同学就会问了，如果中途连接断开或者Server Crash会怎么样。能怎么样，直接自动回滚呗。</p>
<p>一旦会话一使用COMMIT操作提交事务成功后，那么数据一定会被写入到数据库中并持久的存储起来，这体现了事务的持久性。InnoDB使用<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483683&idx=1&sn=5225ab3481c38bb57297a36df8e62bce&chksm=fc04c543cb734c556574f9e5331ab70f0c8239d70197f70015f58d4ac3f5c4d0b1260f0478e3&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">redo log机制</a>来实现事务的持久性。</p>
<p>而事务的一致性比较难以理解，简单的讲在事务开始时，此时数据库有一种状态，这个状态是所有的MySQL对象处于一致的状态，例如数据库完整性约束正确，日志状态一致等。当事务提交后，这时数据库又有了一个新的状态，不同的数据，不同的索引，不同的日志等。但此时，约束，数据，索引，日志等MySQL各种状态还是要保持一致性。 也就是说数据库从一个一致性的状态，变到另一个一致性的状态。事务执行后，并没有破坏数据库的完整性约束。</p>
<p>下面我们就来详细讲解一下上述示例涉及的事务的ACID特性的具体实现原理。<strong>总结来说，事务的隔离性由多版本控制机制和锁实现，而原子性、一致性和持久性通过InnoDB的redo log、undo log和Force Log at Commit机制来实现</strong>。</p>
<h2 id="原子性，持久性和一致性"><a href="#原子性，持久性和一致性" class="headerlink" title="原子性，持久性和一致性"></a>原子性，持久性和一致性</h2><p>原子性，持久性和一致性主要是通过redo log、undo log和Force Log at Commit机制机制来完成的。redo log用于在崩溃时恢复数据，undo log用于对事务的影响进行撤销，也可以用于多版本控制。而Force Log at Commit机制保证事务提交后redo log日志都已经持久化。<br>开启一个事务后，用户可以使用COMMIT来提交，也可以用ROLLBACK来回滚。其中COMMIT或者ROLLBACK执行成功之后，数据一定是会被全部保存或者全部回滚到最初状态的，这也体现了事务的原子性。但是也会有很多的异常情况，比如说事务执行中途连接断开，或者是执行COMMIT或者ROLLBACK时发生错误，Server Crash等，此时数据库会自动进行回滚或者重启之后进行恢复。</p>
<p>我们先来看一下redo log的原理，redo log顾名思义，就是重做日志，每次数据库的SQL操作导致的数据变化它都会记录一下，<strong>具体来说，redo log是物理日志，记录的是数据库页的物理修改操作</strong>。如果数据发生了丢失，数据库可以根据redo log进行数据恢复。</p>
<p>InnoDB通过Force Log at Commit机制实现事务的持久性，即当事务COMMIT时，必须先将该事务的所有日志都写入到redo log文件进行持久化之后，COMMIT操作才算完成。<br>当事务的各种SQL操作执行时，即会在缓冲区中修改数据，也会将对应的redo log写入它所属的缓存。当事务执行COMMIT时，与该事务相关的redo log缓冲必须都全部刷新到磁盘中之后COMMIT才算执行成功。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175433-e6413.png" alt="img"></p>
<p>数据库日志和数据落盘机制</p>
<p>redo log写入磁盘时，必须进行一次操作系统的fsync操作，防止redo log只是写入了操作系统的磁盘缓存中。参数innodb_flush_log_at_trx_commit可以控制redo log日志刷新到磁盘的策略，它的具体作用可以查阅<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483683&idx=1&sn=5225ab3481c38bb57297a36df8e62bce&chksm=fc04c543cb734c556574f9e5331ab70f0c8239d70197f70015f58d4ac3f5c4d0b1260f0478e3&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB的磁盘文件及落盘机制</a></p>
<p>redo log全部写入磁盘后事务就算COMMIT成功了，但是此时事务修改的数据还在内存的缓冲区中，称其为脏页，这些数据会依据检查点(CheckPoint)机制择时刷新到磁盘中，然后删除相应的redo log，但是如果在这个过程中数据库Crash了，那么数据库重启时，会依据redo log file将那些还在内存中未更新到磁盘上的数据进行恢复。</p>
<p>数据库为了提高性能，数据页在内存修改后并不是每次都会刷到磁盘上。而是引入checkpoint机制，择时将数据页落盘，checkpoint记录之前的数据页保证一定落盘了，这样相关的redo log就没有用了(由于InnoDB redo log file循环使用，这时这部分日志就可以被覆盖)，checkpoint之后的数据页有可能落盘，也有可能没有落盘，所以checkpoint之后的redo log file在崩溃恢复的时候还是需要被使用的。InnoDB会依据脏页的刷新情况，定期推进checkpoint，从而减少数据库崩溃恢复的时间。检查点的信息在第一个日志文件的头部。</p>
<p>数据库崩溃重启后需要从redo log中把未落盘的脏页数据恢复出来，重新写入磁盘，保证用户的数据不丢失。当然，在崩溃恢复中还需要回滚没有提交的事务。由于回滚操作需要undo日志的支持，undo日志的完整性和可靠性需要redo日志来保证，所以崩溃恢复先做redo恢复数据，然后做undo回滚。</p>
<p>在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175434-53e31.jpeg" alt="img"></p>
<p>数据和回滚日志的逻辑存储结构.jpg</p>
<p>undo log的存储不同于redo log，它存放在数据库内部的一个特殊的段(segment)中，这个段称为回滚段。回滚段位于共享表空间中。undo段中的以undo page为更小的组织单位。undo page和存储数据库数据和索引的页类似。因为redo log是物理日志，记录的是数据库页的物理修改操作。所以undo log的写入也会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。如上图所示，表空间中有回滚段和叶节点段和非叶节点段，而三者都有对应的页结构。</p>
<p>我们再来总结一下数据库事务的整个流程，如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175434-1e1c3.jpeg" alt="img"></p>
<p>事务的相关流程</p>
<p>事务进行过程中，每次sql语句执行，都会记录undo log和redo log，然后更新数据形成脏页，然后redo log按照时间或者空间等条件进行落盘，undo log和脏页按照checkpoint进行落盘，落盘后相应的redo log就可以删除了。此时，事务还未COMMIT，如果发生崩溃，则首先检查checkpoint记录，使用相应的redo log进行数据和undo log的恢复，然后查看undo log的状态发现事务尚未提交，然后就使用undo log进行事务回滚。事务执行COMMIT操作时，会将本事务相关的所有redo log都进行落盘，只有所有redo log落盘成功，才算COMMIT成功。然后内存中的数据脏页继续按照checkpoint进行落盘。如果此时发生了崩溃，则只使用redo log恢复数据。</p>
<h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>InnoDB事务的隔离性主要通过多版本控制机制和锁机制实现，具体可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483698&idx=1&sn=3654042755c7ea0922e5d5b462930946&chksm=fc04c552cb734c443f771eb2075cd4d4ce85df85105805667cc4cf51a67ceed2f9ebdf1a8cde&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">多版本控制</a>，<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483694&idx=1&sn=671ad369f67441c7d1572110066d5695&chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB锁的类型和状态查询</a>和<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483702&idx=1&sn=669fb9f413db0cc744bdb5b9ec8f725e&chksm=fc04c556cb734c40b3c90a55868619b8ca1f3e1f8763be2d6e7f0568d7c992409937c33b7e10&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB行锁算法</a>三篇文章。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本来想一篇文章将MySQL的事务机制讲明白，写完自己读了一遍，还是发现内容有些晦涩难懂，复杂的知识本来就是很难讲明白的，夫夷以近，则游者众；险以远，则至者少，希望读者以本文作为一篇指引性的文章，自己再去更加深入的地方去探秘。不过，能将复杂知识讲解的通俗简单也是一项很大的本领，文字和讲解能力还是需要提示的。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/42d4385c32bb" target="_blank" rel="noopener">https://www.jianshu.com/p/42d4385c32bb</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（7）：InnoDB行锁算法</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%887%EF%BC%89%EF%BC%9AInnoDB%E8%A1%8C%E9%94%81%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>在上一篇<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483698&idx=1&sn=3654042755c7ea0922e5d5b462930946&chksm=fc04c552cb734c443f771eb2075cd4d4ce85df85105805667cc4cf51a67ceed2f9ebdf1a8cde&token=731065842&lang=zh_CN#rd" target="_blank" rel="noopener">《InnoDB一致性非锁定读》</a>中，我们了解到InnoDB使用一致性非锁定读来避免在一般的查询操作(SELECT FOR UPDATE等除外)时使用锁。然而锁这个事情是无法避免的，数据的写入，修改和删除都需要加锁。今天我们就继续学习InnoDB锁相关的知识。</p>
<a id="more"></a>

<p>由于文章涉及的概念比较多，害怕大家看完后会骂人，有一种字我都认识，就不太懂的感觉，文章会给出一些实例和试验，依据具体案例来讲解这些概念。毕竟，实践才能出真知。</p>
<p>InnoDB存储引擎支持表锁和行锁。顾名思义，表锁是锁住整张表，行锁只是锁住某些行。InnoDB通过给索引项加锁来实现行锁，如果没有索引，则通过隐藏的聚簇索引来对记录加锁。如果操作不通过索引条件检索数据，InnoDB 则对表中的所有记录加锁，实际效果就和表锁一样。InnoDB存储引擎有3种行锁的算法，分别是：</p>
<ul>
<li>Record Lock: 单个记录上的锁</li>
<li>Gap Lock: 间隙锁，锁定一个范围，但不包括记录本上</li>
<li>Next-Key Lock: Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身</li>
</ul>
<p>如下图所示，</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175010-58b28.jpeg" alt="img"></p>
<p>三种锁算法</p>
<p>例如一个索引有10,11,13,20这四个值。InnoDB可以根据需要使用Record Lock将10，11，13，20四个索引锁住，也可以使用Gap Lock将(-∞,10)，(10,11)，(11,13)，(13,20)，(20, +∞)五个范围区间锁住。Next-Key Locking类似于上述两种锁的结合，它可以锁住的区间有为(-∞,10]，(10,11]，(11,13]，(13,20]，(20, +∞)，可以看出它即锁定了一个范围，也会锁定记录本身。</p>
<p>InnoDB存储引擎的锁算法的一些规则如下所示，后续章节会给出对应的实验案例和详细讲解。</p>
<ul>
<li>在不通过索引条件查询时，InnoDB 会锁定表中的所有记录。所以，如果考虑性能，WHERE语句中的条件查询的字段都应该加上索引。</li>
<li>InnoDB通过索引来实现行锁，而不是通过锁住记录。因此，当操作的两条不同记录拥有相同的索引时，也会因为行锁被锁而发生等待。</li>
<li>由于InnoDB的索引机制，数据库操作使用了主键索引，InnoDB会锁住主键索引；使用非主键索引时，InnoDB会先锁住非主键索引，再锁定主键索引。</li>
<li>当查询的索引是唯一索引(不存在两个数据行具有完全相同的键值)时，InnoDB存储引擎会将Next-Key Lock降级为Record Lock，即只锁住索引本身，而不是范围。</li>
<li>InnoDB对于辅助索引有特殊的处理，不仅会锁住辅助索引值所在的范围，还会将其下一键值加上Gap LOCK。</li>
<li>InnoDB使用Next-Key Lock机制来避免Phantom Problem（幻读问题）。</li>
</ul>
<h2 id="真的了解本质吗"><a href="#真的了解本质吗" class="headerlink" title="真的了解本质吗?"></a>真的了解本质吗?</h2><p>在不通过索引条件查询时，InnoDB 会锁定表中的所有记录。大家可以登录上自己的MySQL服务器，亲自试验一下。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175011-8d9fc.jpeg" alt="img"></p>
<p>示例一</p>
<p>试验发现，会话二的查询操作真的是会发生等待。那么，这句话真的是对的吗？我们可以使用<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483694&idx=1&sn=671ad369f67441c7d1572110066d5695&chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&token=731065842&lang=zh_CN#rd" target="_blank" rel="noopener">《InnoDB锁的类型和状态查询》</a>中查询数据锁的方法查询一下，<strong>注意必须在会话二操作还在等待时进行查询，否则查询不到</strong>。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175011-a2fad.png" alt="img"></p>
<p>查询锁信息</p>
<p>其中lock_trx_id为1851的事务是会话二的事务，另一个是会话一的事务。我们可以看到两个锁都要对值为1的主键索引加锁。<em>需要注意的是，这里是对主键进行加锁</em>。二者之间的关系是怎么确定的呢?我们可以通过<code>information_schema.INNODB_LOCK_WAITS</code>中的数据确定。</p>
<p>奇怪，不是说好的锁定表中的所有记录嘛？查找了很多资料，发现<code>INNODB_LOCKS</code>的定义如下：</p>
<blockquote>
<p>The INNODB_LOCKS table contains information about each lock that an InnoDB transaction has requested but not yet acquired, and each lock that a transaction holds that is blocking another transaction.</p>
</blockquote>
<p>也就是说，这张表并不会显示所有锁的信息，而是只显示要申请却没有申请到，和已经持有锁并且阻塞其他线程的锁信息。怪不得必须在会话二进行等待时进行查询才能查得到数据。</p>
<p>因为两个会话的操作都要锁住所有的行，所以发现每次在第一行记录上就发生了锁等待。那我们使用插入语句试试。表e1的主键a的值为1-4，我们分别插入主键为1-4(当然会有主键重复问题，但是由于有锁，一直等待)的新记录，分别查询锁信息，就能看到会话一的事务对所有的主键都加了锁，也就是对所有的记录都加了锁。</p>
<h2 id="是索引，而不是记录"><a href="#是索引，而不是记录" class="headerlink" title="是索引，而不是记录"></a>是索引，而不是记录</h2><p>InnoDB存储引擎的行锁是通过锁住索引实现的，而不是记录。这是理解很多数据库锁问题的关键。</p>
<p>由于InnoDB特殊的索引机制，数据库操作使用主键索引时，InnoDB会锁住主键索引；使用非主键索引时，InnoDB会先锁住非主键索引，再锁定主键索引。不了解InnoDB索引机制的可以参考这篇<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483664&idx=1&sn=a4aea45edf13b367ee17539eaff4874b&chksm=fc04c570cb734c66447aec4344288025bfe6ba7d715af31dc6d60d65411cd90a05d9b02e749d&token=731065842&lang=zh_CN#rd" target="_blank" rel="noopener">文章</a></p>
<p>如下图所示，当InnoDB锁定非主键索引b时，它也会锁住其对应的主键索引，所以锁住b值为2和3的非主键索引，那么与其相关的a值为6,5的主键索引也需要被锁住。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175013-450b9.jpeg" alt="img"></p>
<p>非主键索引的加锁</p>
<p>比如说，一种常见的死锁情况一般出现在如下图所示的操作场景中。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175013-1ca41.jpeg" alt="img"></p>
<p>示例2</p>
<p>会话一的语句使用了b上的索引，因为它是非主键索引，所以会先在b索引上添加锁，再去a索引上加锁。而会话二的语句恰恰相反，会先在索引a上加锁，再去索引b加锁。这种情况下，就可能出现死锁。</p>
<h2 id="Next-Key-Lock锁到底有什么用？"><a href="#Next-Key-Lock锁到底有什么用？" class="headerlink" title="Next-Key Lock锁到底有什么用？"></a>Next-Key Lock锁到底有什么用？</h2><p>默认隔离级别REPEATABLE-READ下，InnoDB中行锁默认使用算法Next-Key Lock，只有当查询的索引是唯一索引或主键时，InnoDB会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围。当查询的索引为辅助索引时，InnoDB则会使用Next-Key Lock进行加锁。InnoDB对于辅助索引有特殊的处理，不仅会锁住辅助索引值所在的范围，还会将其下一键值加上Gap LOCK。</p>
<p>废话不多说，我们来看一下相关的实验，先做一下准备。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> e4 (a <span class="built_in">INT</span>, b <span class="built_in">INT</span>, PRIMARY <span class="keyword">KEY</span>(a), <span class="keyword">KEY</span>(b));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">1</span>,<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">3</span>,<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">5</span>,<span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">7</span>,<span class="number">6</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">10</span>,<span class="number">8</span>;</span></pre></td></tr></table></figure>

<p>然后开启一个会话执行下面的语句。</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> e4 <span class="keyword">WHERE</span> b=<span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span></pre></td></tr></table></figure>

<p>因为通过索引b来进行查询，所以InnoDB会使用Next-Key Lock进行加锁，并且索引b是非主键索引，所以还会对主键索引a进行加锁。对于主键索引a，仅仅对值为5的索引加上Record Lock（因为之前的规则）。而对于索引b，需要加上Next-Key Lock索引，锁定的范围是(1,3]。除此之外，还会对其下一个键值加上Gap Lock，即还有一个范围为(3,6)的锁。<br>大家可以再新开一个会话，执行下面的SQL语句，会发现都会被阻塞。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> e4 <span class="keyword">WHERE</span> a = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;  <span class="comment"># 主键a被锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">4</span>,<span class="number">2</span>;   <span class="comment"># 插入行b的值为2，在锁定的(1,3]范围内</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">6</span>,<span class="number">5</span>; <span class="comment"># 插入行b的值为5，在锁定的(3,6)范围内</span></span></pre></td></tr></table></figure>

<p>InnoDB引擎采用Next-Key Lock来解决幻读问题。因为Next-Key Lock是锁住一个范围，所以就不会产生幻读问题。但是需要注意的是，InnoDB只在Repeatable Read隔离级别下使用该机制。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/7d050498d9da" target="_blank" rel="noopener">https://www.jianshu.com/p/7d050498d9da</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（6）：InnoDB一致性非锁定读</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%886%EF%BC%89%EF%BC%9AInnoDB%E4%B8%80%E8%87%B4%E6%80%A7%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB/</url>
    <content><![CDATA[<p>一致性非锁定读(consistent nonlocking read)是指InnoDB存储引擎通过多版本控制(MVVC)读取当前数据库中行数据的方式。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB会去读取行的一个快照。</p>
<a id="more"></a>

<p><img src="http://image.winrains.cn/2019/10/20191031174517-7a2e1.jpeg" alt="img"></p>
<p>一致性非锁定读示意图</p>
<p>上图直观地展现了InnoDB一致性非锁定读的机制。之所以称其为非锁定读，是因为不需要等待行上排他锁的释放。快照数据是指该行的之前版本的数据，每行记录可能有多个版本，一般称这种技术为行多版本技术。由此带来的并发控制，称之为多版本并发控制(Multi Version Concurrency Control, MVVC)。InnoDB是通过undo log来实现MVVC。undo log本身用来在事务中回滚数据，因此快照数据本身是没有额外开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。</p>
<p>一致性非锁定读是InnoDB默认的读取方式，即读取不会占用和等待行上的锁。但是并不是在每个事务隔离级别下都是采用此种方式。此外，即使都是使用一致性非锁定读，但是对于快照数据的定义也各不相同。</p>
<p>在事务隔离级别READ COMMITTED和REPEATABLE READ下，InnoDB使用一致性非锁定读。然而，对于快照数据的定义却不同。在READ COMMITTED事务隔离级别下，一致性非锁定读总是读取被锁定行的最新一份快照数据。而在REPEATABLE READ事务隔离级别下，则读取事务开始时的行数据版本。</p>
<p>我们下面举个例子来详细说明一下上述的情况。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">session</span> A</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">BEGIN</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> id = <span class="number">1</span>;</span></pre></td></tr></table></figure>

<p>我们首先在会话A中显示地开启一个事务，然后读取test表中的id为1的数据，但是事务并没有结束。于此同时，用户在开启另一个会话B，这样可以模拟并发的操作，然后对会话B做出如下的操作：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">session</span> B</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">BEGIN</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">UPDATE</span> test <span class="keyword">SET</span> id = <span class="number">3</span> <span class="keyword">WHERE</span> id = <span class="number">1</span>;</span></pre></td></tr></table></figure>

<p>在会话B的事务中，将test表中id为1的记录修改为id=3，但是事务同样也没有提交，这样id=1的行其实加了一个排他锁。由于InnoDB在READ COMMITTED和REPEATABLE READ事务隔离级别下使用一致性非锁定读，这时如果会话A再次读取id为1的记录，仍然能够读取到相同的数据。此时，READ COMMITTED和REPEATABLE READ事务隔离级别没有任何区别。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174517-65081.jpeg" alt="img"></p>
<p>会话A和会话B示意图</p>
<p>如上图所示，当会话B提交事务后，会话A再次运行<code>SELECT * FROM test WHERE id = 1</code>的SQL语句时，两个事务隔离级别下得到的结果就不一样了。<br>对于READ COMMITTED的事务隔离级别，它总是读取行的最新版本，如果行被锁定了，则读取该行版本的最新一个快照。因为会话B的事务已经提交，所以在该隔离级别下上述SQL语句的结果集是空的。<br>对于REPEATABLE READ的事务隔离级别，总是读取事务开始时的行数据，因此，在该隔离级别下，上述SQL语句仍然会获得相同的数据。</p>
<h2 id="MVVC"><a href="#MVVC" class="headerlink" title="MVVC"></a>MVVC</h2><p>我们首先来看一下wiki上对MVVC的定义：</p>
<blockquote>
<p>Multiversion concurrency control (MCC or MVCC), is a concurrency control method commonly used by database management systems to provide concurrent access to the database and in programming languages to implement transactional memory.</p>
</blockquote>
<p>由定义可知，MVVC是用于数据库提供并发访问控制的并发控制技术。<br>数据库的并发控制机制有很多，最为常见的就是锁机制。锁机制一般会给竞争资源加锁，阻塞读或者写操作来解决事务之间的竞争条件，最终保证事务的可串行化。而MVVC则引入了另外一种并发控制，它让读写操作互不阻塞，每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回，由此解决了事务的竞争条件。<br>考虑一个现实场景。管理者要查询所有用户的存款总额，假设除了用户A和用户B之外，其他用户的存款总额都为0，A、B用户各有存款1000，所以所有用户的存款总额为2000。但是在查询过程中，用户A会向用户B进行转账操作。转账操作和查询总额操作的时序图如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174517-1fed0.jpeg" alt="img"></p>
<p>转账和查询的时序图</p>
<p>如果没有任何的并发控制机制，查询总额事务先读取了用户A的账户存款，然后转账事务改变了用户A和用户B的账户存款，最后查询总额事务继续读取了转账后的用户B的账号存款，导致最终统计的存款总额多了100元，发生错误。</p>
<p>使用锁机制可以解决上述的问题。查询总额事务会对读取的行加锁，等到操作结束后再释放所有行上的锁。因为用户A的存款被锁，导致转账操作被阻塞，直到查询总额事务提交并将所有锁都释放。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174518-4a989.jpeg" alt="img"></p>
<p>使用锁机制</p>
<p>但是这时可能会引入新的问题，当转账操作是从用户B向用户A进行转账时会导致死锁。转账事务会先锁住用户B的数据，等待用户A数据上的锁，但是查询总额的事务却先锁住了用户A数据，等待用户B的数据上的锁。</p>
<p>使用MVVC机制也可以解决这个问题。查询总额事务先读取了用户A的账户存款，然后转账事务会修改用户A和用户B账户存款，查询总额事务读取用户B存款时不会读取转账事务修改后的数据，而是读取本事务开始时的数据副本(在REPEATABLE READ隔离等级下)。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174518-c3ba9.jpeg" alt="img"></p>
<p>使用MVVC机制</p>
<p>MVCC使得数据库读不会对数据加锁，普通的SELECT请求不会加锁，提高了数据库的并发处理能力。借助MVCC，数据库可以实现READ COMMITTED，REPEATABLE READ等隔离级别，用户可以查看当前数据的前一个或者前几个历史版本，保证了ACID中的I特性（隔离性)</p>
<h2 id="InnoDB的MVVC实现"><a href="#InnoDB的MVVC实现" class="headerlink" title="InnoDB的MVVC实现"></a>InnoDB的MVVC实现</h2><p>多版本并发控制仅仅是一种技术概念，并没有统一的实现标准， 其的核心理念就是数据快照，不同的事务访问不同版本的数据快照，从而实现不同的事务隔离级别。虽然字面上是说具有多个版本的数据快照，但这并不意味着数据库必须拷贝数据，保存多份数据文件，这样会浪费大量的存储空间。InnoDB通过事务的undo日志巧妙地实现了多版本的数据快照。<br>数据库的事务有时需要进行回滚操作，这时就需要对之前的操作进行undo。因此，在对数据进行修改时，InnoDB会产生undo log。当事务需要进行回滚时，InnoDB可以利用这些undo log将数据回滚到修改之前的样子。<br>根据行为的不同 undo log 分为两种 insert undo log和update undo log。<br>insert undo log 是在 insert 操作中产生的 undo log。因为 insert 操作的记录只对事务本身可见，对于其它事务此记录是不可见的，所以 insert undo log 可以在事务提交后直接删除而不需要进行 purge 操作。<br>update undo log 是 update 或 delete 操作中产生的 undo log，因为会对已经存在的记录产生影响，为了提供 MVCC机制，因此 update undo log 不能在事务提交时就进行删除，而是将事务提交时放到入 history list 上，等待 purge 线程进行最后的删除操作。<br>为了保证事务并发操作时，在写各自的undo log时不产生冲突，InnoDB采用回滚段的方式来维护undo log的并发写入和持久化。回滚段实际上是一种 Undo 文件组织方式。<br>InnoDB行记录有三个隐藏字段：分别对应该行的rowid、事务号db_trx_id和回滚指针db_roll_ptr，其中db_trx_id表示最近修改的事务的id，db_roll_ptr指向回滚段中的undo log。如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174518-74ed7.jpeg" alt="img"></p>
<p>初始状态</p>
<p>当事务2使用UPDATE语句修改该行数据时，会首先使用排他锁锁定改行，将该行当前的值复制到undo log中，然后再真正地修改当前行的值，最后填写事务ID，使用回滚指针指向undo log中修改前的行。如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174519-e14b3.jpeg" alt="img"></p>
<p>第一次修改</p>
<p>当事务3进行修改与事务2的处理过程类似，如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174519-a9e7e.jpeg" alt="img"></p>
<p>第二次修改</p>
<p>REPEATABLE READ隔离级别下事务开始后使用MVVC机制进行读取时，会将当时活动的事务id记录下来，记录到Read View中。READ COMMITTED隔离级别下则是每次读取时都创建一个新的Read View。<br>Read View是InnoDB中用于判断记录可见性的数据结构，记录了一些用于判断可见性的属性。</p>
<ul>
<li>low_limit_id：某行记录的db_trx_id &lt; 该值，则该行对于当前Read View是一定可见的</li>
<li>up_limit_id：某行记录的db_trx_id &gt;= 该值，则该行对于当前read view是一定不可见的</li>
<li>low_limit_no：用于purge操作的判断</li>
<li>rw_trx_ids：读写事务数组</li>
</ul>
<p>Read View创建后，事务再次进行读操作时比较记录的db_trx_id和Read View中的low_limit_id，up_limit_id和读写事务数组来判断可见性。</p>
<p>如果该行中的db_trx_id等于当前事务id，说明是事务内部发生的更改，直接返回该行数据。否则的话，如果db_trx_id小于up_limit_id，说明是事务开始前的修改，则该记录对当前Read View是可见的，直接返回该行数据。</p>
<p>如果db_trx_id大于或者等于low_limit_id，则该记录对于该Read View一定是不可见的。如果db_trx_id位于[up_limit_id, low_limit_id)范围内，需要在活跃读写事务数组(rw_trx_ids)中查找db_trx_id是否存在，如果存在，记录对于当前Read View是不可见的。<br>如果记录对于Read View不可见，需要通过记录的DB_ROLL_PTR指针遍历undo log，构造对当前Read View可见版本数据。<br>简单来说，Read View记录读开始时及其之后，所有的活动事务，这些事务所做的修改对于Read View是不可见的。除此之外，所有其他的小于创建Read View的事务号的所有记录均可见。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/f6d4d5c37d66" target="_blank" rel="noopener">https://www.jianshu.com/p/f6d4d5c37d66</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（5）：InnoDB锁的类型和状态查询</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%885%EF%BC%89%EF%BC%9AInnoDB%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%8A%B6%E6%80%81%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>锁是数据库系统区分于文件系统的一个关键特性。数据库使用锁来支持对共享资源进行并发访问，提供数据的完整性和一致性。此外，数据库事务的隔离性也是通过锁实现的。InnoDB在此方面一直优于其他数据库引擎。InnoDB会在行级别上对表数据上锁，而MyISAM只能在表级别上锁，二者性能差异可想而知。</p>
<a id="more"></a>

<h2 id="InnoDB存储引擎中的锁"><a href="#InnoDB存储引擎中的锁" class="headerlink" title="InnoDB存储引擎中的锁"></a>InnoDB存储引擎中的锁</h2><p>InnoDB存储引擎实现了如下两种标准的行级锁：</p>
<ul>
<li>共享锁(S Lock)，允许事务读取一行</li>
<li>排他锁(X Lock)，允许事务删除或更新一行数据</li>
</ul>
<p>如果一个事务T1已经获取了行r的共享锁，那么另外一个事务T2可以立刻获得行r的共享锁，因为读取并不会改变数据，可以进行并发的读取操作；但若其他的事务T3想要获取行r的排他锁，则必须等待事务T1和T2释放行r上的共享锁之后才能继续，因为获取排他锁一般是为了改变数据，所以不能同时进行读取或则其他写入操作。</p>
<table>
<thead>
<tr>
<th></th>
<th>X</th>
<th>S</th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>S</td>
<td>不兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p>InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种称为意向锁的锁方式。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。</p>
<p>InnoDB存储引擎的意向锁即为表级别的锁。设计目的主要是为了在一个事务中揭示下一行将被请求的锁类型。其支持两种意向锁：</p>
<ul>
<li>意向共享锁(IS Lock)，事务想要获得一张表中某几行的共享锁</li>
<li>意向排他锁(IX Lock)，事务想要获得一张表中某几行的排他锁</li>
</ul>
<p>需要注意的是意向锁是表级别的锁，它不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。故表级别的意向锁和表级别的锁的兼容性如下表所示。</p>
<table>
<thead>
<tr>
<th></th>
<th>IS</th>
<th>IX</th>
<th>S</th>
<th>X</th>
</tr>
</thead>
<tbody><tr>
<td>IS</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>IX</td>
<td>兼容</td>
<td>兼容</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>S</td>
<td>兼容</td>
<td>不兼容</td>
<td>兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>X</td>
<td>不兼容</td>
<td>不兼容</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
</tbody></table>
<p>向一个表添加表级X锁的时候(执行ALTER TABLE, DROP TABLE, LOCK TABLES等操作)，如果没有意向锁的话，则需要遍历所有整个表判断是否有行锁的存在，以免发生冲突。如果有了意向锁，只需要判断该意向锁与即将添加的表级锁是否兼容即可。因为意向锁的存在代表了，有行级锁的存在或者即将有行级锁的存在，因而无需遍历整个表，即可获取结果。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174021-c0450.jpeg" alt="img"></p>
<p>层次结构.jpg</p>
<p>如果将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。如上图所示，如果需要对表1的记录m行上X锁，那么需要先对表1加意向IX锁，然后对记录m上X锁。如果其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成。</p>
<h2 id="InnoDB锁相关状态查询"><a href="#InnoDB锁相关状态查询" class="headerlink" title="InnoDB锁相关状态查询"></a>InnoDB锁相关状态查询</h2><p>用户可以使用INFOMATION_SCHEMA库下的INNODB_TRX、INNODB_LOCKS和INNODB_LOCK_WAITS表来监控当前事务并分析可能出现的锁问题。INNODB_TRX的定义如下表所示，其由8个字段组成。</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>trx_id</td>
<td>InnoDB存储引擎内部唯一的事务ID</td>
</tr>
<tr>
<td>trx_state</td>
<td>当前事务的状态</td>
</tr>
<tr>
<td>trx_started</td>
<td>事务的开始时间</td>
</tr>
<tr>
<td>trx_request_lock_id</td>
<td>等待事务的锁ID。如果trx_state的状态为LOCK WAIT,那么该字段代表当前事务等待之前事务占用的锁资源ID</td>
</tr>
<tr>
<td>trx_wait_started</td>
<td>事务等待的时间</td>
</tr>
<tr>
<td>trx_weight</td>
<td>事务的权重，反映了一个事务修改和锁住的行数，当发生死锁需要回滚时，会选择该数值最小的进行回滚</td>
</tr>
<tr>
<td>trx_mysql_thread_id</td>
<td>线程ID，SHOW PROCESSLIST 显示的结果</td>
</tr>
<tr>
<td>trx_query</td>
<td>事务运行的SQL语句</td>
</tr>
</tbody></table>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM information_schema.INNODB_TRX\G;</span></pre></td></tr><tr><td class="code"><pre><span class="line">************************************* <span class="number">1.</span>row *********************************************</span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_id:  <span class="number">7311</span>F4</span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_state: LOCK WAIT</span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_started: <span class="number">2010</span><span class="number">-01</span><span class="number">-04</span> <span class="number">10</span>:<span class="number">49</span>:<span class="number">33</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_requested_lock_id: <span class="number">7311</span>F4:<span class="number">96</span>:<span class="number">3</span>:<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_wait_started: <span class="number">2010</span><span class="number">-01</span><span class="number">-04</span> <span class="number">10</span>:<span class="number">49</span>:<span class="number">33</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_weight: <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_mysql_thread_id: <span class="number">471719</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_query: select * <span class="keyword">from</span> parent lock <span class="keyword">in</span> share mode</span></pre></td></tr></table></figure>

<p>INNODB_TRX表只能显示当前运行的InnoDB事务，并不能直接判断锁的一些情况。如果需要查看锁，则还需要访问表INNODB_LOCKS，该表的字段组成如下表所示。</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock_id</td>
<td>锁的ID</td>
</tr>
<tr>
<td>lock_trx_id</td>
<td>事务的ID</td>
</tr>
<tr>
<td>lock_mode</td>
<td>锁的模式</td>
</tr>
<tr>
<td>lock_type</td>
<td>锁的类型，表锁还是行锁</td>
</tr>
<tr>
<td>lock_table</td>
<td>要加锁的表</td>
</tr>
<tr>
<td>lock_index</td>
<td>锁住的索引</td>
</tr>
<tr>
<td>lock_space</td>
<td>锁住的space id</td>
</tr>
<tr>
<td>lock_page</td>
<td>事务锁定页的数量，若是表锁，则该值为NULL</td>
</tr>
<tr>
<td>lock_rec</td>
<td>事务锁定行的数量，如果是表锁，则该值为NULL</td>
</tr>
<tr>
<td>lock_data</td>
<td>事务锁住记录的主键值，如果是表锁，则该值为NULL</td>
</tr>
</tbody></table>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM information<span class="emphasis">_schema.INNODB_</span>LOCKS\G;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">**** 1.row **</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_id: 7311F4:96:3:2</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock<span class="emphasis">_trx_</span>id: 7311F4</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_mode: S</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_type: RECORD</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_type: 'mytest'.'parent'</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_index: 'PRIMARY'</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_space: 96</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_page: 3</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_rec: 2</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_data: 1</span></pre></td></tr></table></figure>

<p>通过表INNODB_LOCKS查看每张表上锁的情况后，用户就可以来判断由此引发的等待情况。当时当事务量非常大，其中锁和等待也时常发生，这个时候就不那么容易判断。但是通过表INNODB_LOCK_WAITS，可以很直观的反应当前事务的等待。表INNODB_LOCK_WAITS由四个字段组成，如下表所示。</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>requesting_trx_id</td>
<td>申请锁资源的事务ID</td>
</tr>
<tr>
<td>requesting_lock_id</td>
<td>申请的锁的ID</td>
</tr>
<tr>
<td>blocking_trx_id</td>
<td>阻塞的事务ID</td>
</tr>
<tr>
<td>blocking_lock_id</td>
<td>阻塞的锁的ID</td>
</tr>
</tbody></table>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM information<span class="emphasis">_schema.INNODB_</span>LOCK_WAITS\G;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">***1.row**</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span>*</span></pre></td></tr><tr><td class="code"><pre><span class="line">requesting<span class="emphasis">_trx_</span>id: 7311F4</span></pre></td></tr><tr><td class="code"><pre><span class="line">requesting<span class="emphasis">_lock_</span>id: 7311F4:96:3:2</span></pre></td></tr><tr><td class="code"><pre><span class="line">blocking<span class="emphasis">_trx_</span>id: 730FEE</span></pre></td></tr><tr><td class="code"><pre><span class="line">blocking<span class="emphasis">_lock_</span>id: 730FEE:96:3:2</span></pre></td></tr></table></figure>

<p>通过上述的SQL语句，用户可以清楚直观地看到哪个事务阻塞了另一个事务，然后使用上述的事务ID和锁ID，去INNODB_TRX和INNDOB_LOCKS表中查看更加详细的信息。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/160371211b10" target="_blank" rel="noopener">https://www.jianshu.com/p/160371211b10</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（4）：InnoDB的磁盘文件及落盘机制</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%884%EF%BC%89%EF%BC%9AInnoDB%E7%9A%84%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E5%8F%8A%E8%90%BD%E7%9B%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>任何一个技术都有其底层的关键基础技术，这些关键技术很有可能也是其他技术的关键技术，学习这些底层技术，就可以一通百通，让你很快的掌握其他技术。如何在磁盘上存储数据，如何使用日志文件保证数据不丢失以及如何落盘，不仅是MySQL等数据库的关键技术，也是MQ消息队列或者其他中间件的关键技术之一。</p>
<a id="more"></a>

<p><img src="http://image.winrains.cn/2019/10/20191031173512-1a975.png" alt="img"></p>
<p>InnoDB整体架构</p>
<p>上图详细显示了InnoDB存储引擎的体系架构，从图中可见，InnoDB存储引擎由内存池，后台线程和磁盘文件三大部分组成。接下来我们就来简单了解一下磁盘文件相关的概念和原理。</p>
<p>InnoDB的主要的磁盘文件主要分为三大块：一是系统表空间，二是用户表空间，三是redo日志文件和归档文件。二进制文件(binlog)等文件是MySQL Server层维护的文件，所以未列入InnoDB的磁盘文件中。</p>
<h2 id="系统表空间和用户表空间"><a href="#系统表空间和用户表空间" class="headerlink" title="系统表空间和用户表空间"></a>系统表空间和用户表空间</h2><p>InnoDB系统表空间包含InnoDB数据字典(元数据以及相关对象)并且doublewrite buffer,change buffer,undo logs的存储区域。系统表空间也默认包含任何用户在系统表空间创建的表数据和索引数据。系统表空间是一个共享的表空间因为它是被多个表共享的</p>
<p>系统表空间是由一个或者多个数据文件组成。默认情况下,1个初始大小为10MB，名为ibdata1的系统数据文件在MySQL的data目录下被创建。用户可以使用innodb_data_file_path对数据文件的大小和数量进行配置。</p>
<p>innodb_data_file_path的格式如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">innodb_data_file_path</span>=datafile1[,datafile2]<span class="built_in">..</span>.</span></pre></td></tr></table></figure>

<p>用户可以通过多个文件组成一个表空间，同时制定文件的属性：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">innodb_data_file_path = <span class="regexp">/db/</span><span class="string">ibdata1:</span><span class="number">1000</span>M;<span class="regexp">/dr2/</span>db/<span class="string">ibdata2:</span><span class="number">1000</span><span class="string">M:</span>autoextend</span></pre></td></tr></table></figure>

<p>这里讲/db/ibdata1和/dr2/db/ibdata2两个文件组成系统表空间。如果这两个文件位于不同的磁盘上，磁盘的负载可能被平均，因此可以提高数据库的整体性能。两个文件的文件名之后都跟了属性，表示文件ibdata1的大小为1000MB，文件ibdata2的大小为1000MB，而且用完空间之后可以自动增长(autoextend)。</p>
<p>设置innodb_data_file_path参数之后，所以基于InnoDB存储引擎的表的数据都会记录到该系统表空间中，如果设置了参数innodb_file_per_table，则用户可以将每个基于InnoDB存储引擎的表产生一个独立的用户表空间。用户表空间的命名规则为：表名.ibd。<br>通过这种方式，用户不用将所有数据都存放于默认的系统表空间中，但是用户表空只存储该表的数据、索引和插入缓冲BITMAP等信息，其余信息还是存放在默认的表空间中。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031173513-39774.png" alt="img"></p>
<p>InnoDB表存储引擎文件</p>
<p>上图显示InnoDB存储引擎对于文件的存储方式，其中frm文件是表结构定义文件，记录每个表的表结构定义。</p>
<h2 id="重做日志文件和归档文件"><a href="#重做日志文件和归档文件" class="headerlink" title="重做日志文件和归档文件"></a>重做日志文件和归档文件</h2><p>默认情况下，在InnoDB存储引擎的数据目录下会有两个名为ib_logfile0和ib_logfile1的文件，这就是InnoDB的重做日志文件(redo log fiel)，它记录了对于InnoDB存储引擎的事务日志。<br>当InnoDB的数据存储文件发生错误时，重做日志文件就能派上用场。InnoDB存储引擎可以使用重做日志文件将数据恢复为正确状态，以此来保证数据的正确性和完整性。</p>
<p>每个InnoDB存储引擎至少有1个重做日志文件组(group)，每个文件组下至少有2个重做日志文件，如默认的ib_logfile0和ib_logfile1。<br>为了得到更高的可靠性，用户可以设置多个镜像日志组，将不同的文件组放在不同的磁盘上，以此来提高重做日志的高可用性。</p>
<p>在日志组中每个重做日志文件的大小一致，并以循环写入的方式运行。InnoDB存储引擎先写入重做日志文件1，当文件被写满时，会切换到重做日志文件2，再当重做日志文件2也被写满时，再切换到重做日志文件1。</p>
<p>用户可以使用innodb_log_file_size来设置重做日志文件的大小，这对InnoDB存储引擎的性能有着非常大的影响。</p>
<p>如果重做日志文件设置的太大，数据丢失时，恢复时可能需要很长的时间；另一方面，如果设置的太小，重做日志文件太小会导致依据checkpoint的检查需要频繁刷新脏页到磁盘中，导致性能的抖动。<br>重做日志相关和Checkpoint的机制可以阅读我之前文章的相应章节。<a href="https://mp.weixin.qq.com/s/JCXdP59OUvQEB3q1V9YrCA" target="_blank" rel="noopener">MySQL探秘(三):InnoDB的内存结构和特性
</a></p>
<h2 id="重做日志的落盘机制"><a href="#重做日志的落盘机制" class="headerlink" title="重做日志的落盘机制"></a>重做日志的落盘机制</h2><p>InnoDB对于数据文件和日志文件的刷盘遵守WAL(Write ahead redo log) 和Force-log-at-commit两种规则，二者保证了事务的持久性。WAL要求数据的变更写入到磁盘前，首先必须将内存中的日志写入到磁盘；Force-log-at-commit要求当一个事务提交时，所有产生的日志都必须刷新到磁盘上，如果日志刷新成功后，缓冲池中的数据刷新到磁盘前数据库发生了宕机，那么重启时，数据库可以从日志中恢复数据。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031173514-36d2a.jpeg" alt="img"></p>
<h3 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h3><p>如上图所示，InnoDB在缓冲池中变更数据时，会首先将相关变更写入重做日志缓冲中，然后再按时或者当事务提交时写入磁盘，这符合Force-log-at-commit原则；当重做日志写入磁盘后，缓冲池中的变更数据才会依据checkpoint机制择时写入到磁盘中，这符合WAL原则。<br>在checkpoint择时机制中，就有重做日志文件写满的判断，所以，如前文所述，如果重做日志文件太小，经常被写满，就会频繁导致checkpoint将更改的数据写入磁盘，导致性能抖动。</p>
<p>操作系统的文件系统是带有缓存的，当InnoDB向磁盘写入数据时，有可能只是写入到了文件系统的缓存中，没有真正的“落袋为安”。<br>InnoDB的innodb_flush_log_at_trx_commit属性可以控制每次事务提交时InnoDB的行为。当属性值为0时，事务提交时，不会对重做日志进行写入操作，而是等待主线程按时写入；当属性值为1时，事务提交时，会将重做日志写入文件系统缓存，并且调用文件系统的fsync，将文件系统缓冲中的数据真正写入磁盘存储，确保不会出现数据丢失；当属性值为2时，事务提交时，也会将日志文件写入文件系统缓存，但是不会调用fsync，而是让文件系统自己去判断何时将缓存写入磁盘。日志的刷盘机制如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031173514-227a0.png" alt="img"></p>
<h3 id="log刷盘机制"><a href="#log刷盘机制" class="headerlink" title="log刷盘机制"></a>log刷盘机制</h3><p>innodb_flush_log_at_commit是InnoDB性能调优的一个基础参数，涉及InnoDB的写入效率和数据安全。当参数值为0时，写入效率最高，但是数据安全最低；参数值为1时，写入效率最低，但是数据安全最高；参数值为2时，二者都是中等水平。一般建议将该属性值设置为1，以获得较高的数据安全性，而且也只有设置为1，才能保证事务的持久性。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/e546ea1fc067" target="_blank" rel="noopener">https://www.jianshu.com/p/e546ea1fc067</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（3）：InnoDB的内存结构和特性</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%883%EF%BC%89%EF%BC%9AInnoDB%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%92%8C%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>常言说得好，每个成功男人背后都有一个为他默默付出的女人，而对于MySQL来说，这个“人”就是InnoDB存储引擎。<br>MySQL区别于其他数据库的最为重要的特点就是其插件式的表存储引擎。而在众多存储引擎中，InnoDB是最为常用的存储引擎。从MySQL5.5.8版本开始，InnoDB存储引擎是默认的存储引擎。<br>InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理(OLTP)的应用。其特点是行锁设计、支持外键，并支持非锁定读，即默认读操作不会产生锁。</p>
<a id="more"></a>

<p>InnoDB通过使用多版本并发控制(MVCC)来获取高并发性，并且实现了SQL标准的4中隔离级别，默认为REPEATABLE级别。同时，使用一种被称为next-key-locking的策略来避免幻读现象的产生。除此之外，InnoDB存储引擎还提供了插入缓冲(insert buffer)、二次写(double write)、自适应哈希索引(adaptive hash index)、预读(read ahead)等高性能和高可用的功能。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031172740-361a4.png" alt="img"></p>
<p>InnoDB整体架构.png</p>
<p>上图详细显示了InnoDB存储引擎的体系架构，从图中可见，InnoDB存储引擎由内存池，后台线程和磁盘文件三大部分组成。接下来我们就来简单了解一下内存相关的概念和原理。</p>
<h2 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h2><p>InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。但是由于CPU速度和磁盘速度之间的鸿沟，基于磁盘的数据库系统通常使用缓冲池记录来提高数据库的的整体性能。</p>
<p>在数据库中进行读取操作，首先将从磁盘中读到的页放在缓冲池中，下次再读相同的页中时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取该页。否则，读取磁盘上的页。</p>
<p>对于数据库中页的修改操作，则首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是通过一种称为CheckPoint的机制刷新回磁盘。</p>
<p>所以，缓冲池的大小直接影响着数据库的整体性能，可以通过配置参数innodb_buffer_pool_size来设置。</p>
<p>具体来看，缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲(insert buffer)、自适应哈希索引(adaptive hash index)、InnoDB存储的锁信息(lock info)和数据字典信息(data dictionary)。</p>
<p>在架构图上可以看到，InnoDB存储引擎的内存区域除了有缓冲池之外，还有重做日志缓冲和额外内存池。InnoDB存储引擎首先将重做日志信息先放到这个缓冲区中，然后按照一定频率将其刷新到重做日志文件中。重做日志缓冲一般不需要设置的很大，该值可由配置参数innodb_log_buffer_size控制。</p>
<h2 id="数据页和索引页"><a href="#数据页和索引页" class="headerlink" title="数据页和索引页"></a>数据页和索引页</h2><p>Page是Innodb存储的最基本结构，也是Innodb磁盘管理的最小单位，与数据库相关的所有内容都存储在Page结构里。Page分为几种类型，数据页和索引页就是其中最为重要的两种类型。</p>
<h2 id="插入缓冲-Insert-Buffer"><a href="#插入缓冲-Insert-Buffer" class="headerlink" title="插入缓冲(Insert Buffer)"></a>插入缓冲(Insert Buffer)</h2><p>我们都知道，在InnoDB引擎上进行插入操作时，一般需要按照主键顺序进行插入，这样才能获得较高的插入性能。当一张表中存在非聚簇的且不唯一的索引时，在插入时，数据页的存放还是按照主键进行顺序存放，但是对于非聚簇索引叶节点的插入不再是顺序的了，这时就需要离散的访问非聚簇索引页，由于随机读取的存在导致插入操作性能下降。</p>
<p>InnoDB为此设计了Insert Buffer来进行插入优化。对于非聚簇索引的插入或者更新操作，不是每一次都直接插入到索引页中，而是先判断插入的非聚集索引是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer中。看似数据库这个非聚集的索引已经查到叶节点，而实际没有，这时存放在另外一个位置。然后再以一定的频率和情况进行Insert Buffer和非聚簇索引页子节点的合并操作。这时通常能够将多个插入合并到一个操作中，这样就大大提高了对于非聚簇索引的插入性能。</p>
<h2 id="两次写-Double-Write"><a href="#两次写-Double-Write" class="headerlink" title="两次写(Double Write)"></a>两次写(Double Write)</h2><p>如果说Insert Buffer给InnoDB存储引擎带来了性能上的提升，那么Double Write带给InnoDB存储引擎的是数据页的可靠性。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031172743-bdca7.jpeg" alt="img"></p>
<p>doublewrite示意图</p>
<p>如上图所示，Double Write由两部分组成，一部分是内存中的double write buffer，大小为2MB，另一部分是物理磁盘上共享表空间连续的128个页，大小也为2MB。在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是通过memcpy函数将脏页先复制到内存中的该区域，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免操作系统缓冲写带来的问题。在完成doublewrite页的写入后，再讲doublewirite buffer中的页写入各个表空间文件中。</p>
<p>如果操作系统在将页写入磁盘的过程中发生了崩溃，在恢复过程中，InnoDB存储引擎可以从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件中，再应用重做日志。</p>
<h2 id="重做日志-Redo-Log-Buffer"><a href="#重做日志-Redo-Log-Buffer" class="headerlink" title="重做日志(Redo Log Buffer)"></a>重做日志(Redo Log Buffer)</h2><p>当缓冲池中的页的版本比磁盘要新时，数据库需要将新版本的页从缓冲池刷新到磁盘。但是如果每次一个页发送变化，就进行刷新，那么性能开发是非常大的，于是InnoDB采用了Write Ahead Log策略，即当事务提交时，先写重做日志，然后再择时将脏页写入磁盘。如果发生宕机导致数据丢失，就通过重做日志进行数据恢复。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031172743-45863.jpeg" alt="img"></p>
<p>InnoDB数据写入示意图</p>
<p>InnoDB存储引擎会首先将重做日志信息先放入重做日志缓冲中，然后再按照一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置得很大，因为一般情况每一秒钟都会讲重做日志缓冲刷新到日志文件中。可通过配置参数innodb_log_buffer_size控制，默认为8MB。</p>
<p>除了每秒刷新机制之外，每次事务提交时重做日志缓冲也会刷新到日志中。InnoDB是事务的存储引擎，其通过Force Log at Commit机制实现事务的持久性，即当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，然后事务的提交操作完成才算完成。InnoDB的写入机制大致入下图所示。</p>
<p>为了确保每次日志都写入到重做日志文件，在每次讲重做日志缓冲写入重做日志后，必须调用一次fsync操作，将缓冲文件从文件系统缓存中真正写入磁盘。</p>
<p>可以通过innodb_flush_log_at_trx_commit来控制重做日志刷新到磁盘的策略。该参数默认值为1，表示事务提交必须进行一次fsync操作，还可以设置为0和2。0表示事务提交时不进行写入重做日志操作，该操作只在主线程中完成，2表示提交时写入重做日志，但是只写入文件系统缓存，不进行fsync操作。由此可见，设置为0时，性能最高，但是丧失了事务的一致性。</p>
<h2 id="自适应哈希索引-Adaptive-Hash-Index"><a href="#自适应哈希索引-Adaptive-Hash-Index" class="headerlink" title="自适应哈希索引(Adaptive Hash Index)"></a>自适应哈希索引(Adaptive Hash Index)</h2><p>InnoDB会根据访问的频率和模式，为热点页建立哈希索引，来提高查询效率。InnoDB存储引擎会监控对表上各个索引页的查询，如果观察到建立哈希索引可以带来速度上的提升，则建立哈希索引，所以叫做自适应哈希索引。</p>
<p>自适应哈希索引是通过缓冲池的B+树页构建而来，因此建立速度很快，而且不需要对整张数据表建立哈希索引。其有一个要求，即对这个页的连续访问模式必须是一样的，也就是说其查询的条件(WHERE)必须完全一样，而且必须是连续的。</p>
<h2 id="锁信息-lock-info"><a href="#锁信息-lock-info" class="headerlink" title="锁信息(lock info)"></a>锁信息(lock info)</h2><p>我们都知道，InnoDB存储引擎会在行级别上对表数据进行上锁。不过InnoDB也会在数据库内部其他很多地方使用锁，从而允许对多种不同资源提供并发访问。数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。关于锁的具体知识我们之后再进行详细学习。</p>
<h2 id="数据字典信息-Data-Dictionary"><a href="#数据字典信息-Data-Dictionary" class="headerlink" title="数据字典信息(Data Dictionary)"></a>数据字典信息(Data Dictionary)</h2><p>InnoDB有自己的表缓存，可以称为表定义缓存或者数据字典。当InnoDB打开一张表，就增加一个对应的对象到数据字典。</p>
<p>数据字典是对数据库中的数据、库对象、表对象等的元信息的集合。在MySQL中，数据字典信息内容就包括表结构、数据库名或表名、字段的数据类型、视图、索引、表字段信息、存储过程、触发器等内容。MySQL INFORMATION_SCHEMA库提供了对数据局元数据、统计信息、以及有关MySQL server的访问信息（例如：数据库名或表名，字段的数据类型和访问权限等）。该库中保存的信息也可以称为MySQL的数据字典。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/1c1f83d0bb72" target="_blank" rel="noopener">https://www.jianshu.com/p/1c1f83d0bb72</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（2）：SQL语句执行过程详解</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%882%EF%BC%89%EF%BC%9ASQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>昔日庖丁解牛，未见全牛，所赖者是其对牛内部骨架结构的了解，对于MySQL亦是如此，只有更加全面地了解SQL语句执行的每个过程，才能更好的进行SQL的设计和优化。<br>当希望MySQL能够以更高的性能运行查询时，最好的办法就是弄清楚MySQL是如何优化和执行查询的。一旦理解了这一点，很多查询优化工作实际上就是遵循一些原则能够按照预想的合理的方式运行。</p>
<a id="more"></a>

<p>如下图所示，当向MySQL发送一个请求的时候，MySQL到底做了什么：</p>
<ol>
<li>客户端发送一条查询给服务器。</li>
<li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</li>
<li>服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。</li>
<li>MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询。</li>
<li>将结果返回给客户端。</li>
</ol>
<p><img src="http://image.winrains.cn/2019/10/20191031172218-253a8.png" alt="img"></p>
<p>SQL语句执行过程</p>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>MySQL查询缓存保存查询返回的完整结构。当查询命中该缓存时，MySQL会立刻返回结果，跳过了解析、优化和执行阶段。<br>查询缓存系统会跟踪查询中涉及的每个表，如果这些表发生了变化，那么和这个表相关的所有缓存数据都将失效。<br>MySQL将缓存存放在一个引用表中，通过一个哈希值引用，这个哈希值包括了以下因素，即查询本身、当前要查询的数据库、客户端协议的版本等一些其他可能影响返回结果的信息。<br>当判断缓存是否命中时，MySQL不会进行解析查询语句，而是直接使用SQL语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。<br>当查询语句中有一些不确定的数据时，则不会被缓存。例如包含函数NOW()或者CURRENT_DATE()的查询不会缓存。包含任何用户自定义函数，存储函数，用户变量，临时表，mysql数据库中的系统表或者包含任何列级别权限的表，都不会被缓存。<br>有一点需要注意，MySQL并不是会因为查询中包含一个不确定的函数而不检查查询缓存，因为检查查询缓存之前，MySQL不会解析查询语句，所以也无法知道语句中是否有不确定的函数。<br>事实则是，如果查询语句中包含任何的不确定的函数，那么其查询结果不会被缓存，因为查询缓存中也无法找到对应的缓存结果。<br>有关查询缓存的配置如下所示。</p>
<ul>
<li>query_cache_type:是否打开查询缓存。可以设置为OFF、ON和DEMAND。DEMAND表示只有在查询语句中明确写明SQL_CACHE的语句才会放入查询缓存。</li>
<li>query_cache_size:查询缓存使用的总内存空间。</li>
<li>query_cache_min_res_unit:在查询缓存中分配内存块时的最小单元。较小的该值可以减少碎片导致的内存空间浪费，但是会导致更频繁的内存块操作。</li>
<li>query_cache_limit:MySQL能够查询的最大查询结果。如果查询结果大于这个值，则不会被缓存。因为查询缓存在数据生成的时候就开始尝试缓存数据，所以当结果全部返回后，MySQL才知道查询结果是否超出限制。超出之后，才会将结果从查询缓存中删除。</li>
</ul>
<p>对查询缓存的优化是数据库性能优化的重要一环。判断流程大致如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031172218-253a8.png" alt="img"></p>
<p>查询缓存判断流程图</p>
<p>缓存命中率可以通过如下公式计算：Qcache_hits/(Qcache_hits + Com_select)来计算。</p>
<h2 id="解析和预处理"><a href="#解析和预处理" class="headerlink" title="解析和预处理"></a>解析和预处理</h2><p>解析器通过关键字将SQL语句进行解析，并生成对应的解析树。MySQL解析器将使用MySQL语法规则验证和解析查询。<br>预处理器则根据一些MySQL规则进行进一步检查解析书是否合法，例如检查数据表和数据列是否存在，还会解析名字和别名，看看它们是否有歧义。</p>
<h2 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h2><p>查询优化器会将解析树转化成执行计划。一条查询可以有多种执行方法，最后都是返回相同结果。优化器的作用就是找到这其中最好的执行计划。<br>生成执行计划的过程会消耗较多的时间，特别是存在许多可选的执行计划时。如果在一条SQL语句执行的过程中将该语句对应的最终执行计划进行缓存，当相似的语句再次被输入服务器时，就可以直接使用已缓存的执行计划，从而跳过SQL语句生成执行计划的整个过程，进而可以提高语句的执行速度。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031172220-78b8b.png" alt="img"></p>
<p>执行计划缓存</p>
<p>MySQL使用基于成本的查询优化器(Cost-Based Optimizer，CBO)。它会尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最少的一个。<br>优化器会根据优化规则对关系表达式进行转换，这里的转换是说一个关系表达式经过优化规则后会生成另外一个关系表达式，同时原有表达式也会保留，经过一系列转换后会生成多个执行计划，然后CBO会根据统计信息和代价模型(Cost Model)计算每个执行计划的Cost，从中挑选Cost最小的执行计划。由上可知，CBO中有两个依赖：统计信息和代价模型。统计信息的准确与否、代价模型的合理与否都会影响CBO选择最优计划。<br>有关优化器的原理十分复杂，这里就不进行详细讲解了，大家可以自行学习。</p>
<h2 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h2><p>在解析和优化阶段，MySQL将生成查询对应的执行计划，MySQL的查询执行引擎根据这个执行计划来完成整个查询。这里执行计划是一个数据结构，而不是和其他的关系型数据库那样生成对应的字节码。</p>
<h2 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h2><p>如果查询可以被缓存，那么MySQL在这个阶段页会将结果存放到查询缓存中。<br>MySQL将结果集返回给客户端是一个增量、逐步返回的过程。在查询生成第一条结果时，MySQL就可以开始向客户端逐步返回结果集了。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/56fe9bf91448" target="_blank" rel="noopener">https://www.jianshu.com/p/56fe9bf91448</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（1）：B-Tree索引</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%881%EF%BC%89%EF%BC%9AB-Tree%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>MySQL是目前业界最为流行的关系型数据库之一，而索引的优化也是数据库性能优化的关键之一。所以，充分地了解MySQL索引有助于提升开发人员对MySQL数据库的使用优化能力。<br>MySQL的索引有很多种类型，可以为不同的场景提供更好的性能。而B-Tree索引是最为常见的MySQL索引类型，一般谈论MySQL索引时，如果没有特别说明，就是指B-Tree索引。本文就详细讲解一下B-Tree索引的的底层结构，使用原则和特性。</p>
<a id="more"></a>

<p>为了节约你的时间，本文的主要内容如下：</p>
<ul>
<li>B-Tree索引的底层结构</li>
<li>B-Tree索引的使用规则</li>
<li>聚簇索引</li>
<li>InnoDB和MyISAM引擎索引的差异</li>
<li>松散索引</li>
<li>覆盖索引</li>
</ul>
<h2 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h2><p>B-Tree索引使用B-Tree来存储数据，当然不同存储引擎的实现方式不同。B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同，图1展示了B-Tree索引的抽象表示，由此可以看出MySQL的B-Tree索引的大致工作机制。<br>B-Tree索引的底层数据结构一般是B+树，其具体数据结构和优势这里就不作详细描述，图1展示了B-树索引的抽象表示，大致反应了MyISAM索引是如何工作的，而InnoDB使用的结构有所不同。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031171835-cd3fe.png" alt="img"></p>
<p>图1 B-Tree索引的底层结构示意图</p>
<p>MySQL可以在单独一列上添加B-Tree索引，也可以在多列数据上添加B-Tree索引，多列的数据按照添加索引声明的顺序组合起来，存储在B-Tree的页中。假设有如下数据表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People (</span></pre></td></tr><tr><td class="code"><pre><span class="line">      last_name    <span class="built_in">varchar</span>(<span class="number">50</span>)    <span class="keyword">not</span> <span class="literal">null</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      first_name   <span class="built_in">varchar</span>(<span class="number">50</span>)    <span class="keyword">not</span> <span class="literal">null</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      birthday     <span class="built_in">date</span>           <span class="keyword">not</span> <span class="literal">null</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      gender       enum(<span class="string">'m'</span>,<span class="string">'f'</span>)  <span class="keyword">not</span> <span class="literal">null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">key</span>(last_name, first_name, birthday)</span></pre></td></tr><tr><td class="code"><pre><span class="line">);</span></pre></td></tr></table></figure>

<p>对于表中的每一行数据，索引中包含了last_name，first_name和birthday列的值，图2展示了该索引是如何组织数据的存储的。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031171836-50d95.png" alt="img"></p>
<p>图2 多列索引</p>
<p>B-Tree索引使用B-Tree作为其存储数据的数据结构，其使用的查询规则也由此决定。一般来说，B-Tree索引适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于根据最左前缀查找。B-Tree索引支持的查询原则如下所示：</p>
<ul>
<li>全值匹配：全值匹配指的是和索引中的所有列进行匹配，</li>
<li>匹配最左前缀：前边提到的索引可以用于查找所有姓Allen的人，即只使用索引中的第一列。</li>
<li>匹配列前缀：也可以只匹配某一列的值的开头部分。例如前面提到的索引可用于查找所有以J开头的姓的人。这里也只用到了索引的第一列。</li>
<li>匹配范围值：例如前边提到的索引可用于查找姓在Allen和Barrymore之间的人。这里也只使用了索引的第一列。</li>
<li>精确匹配某一列并范围匹配另外一列：前边提到的索引也可用于查找所有姓为Allen，并且名字是字母K开头(比如Kim,Karl等)的人。即第一列last_name全匹配，第二列first_name范围匹配。</li>
</ul>
<p>因为索引树的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的ORDER BY操作(按顺序查找)，如果ORDER BY子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。<br>下面是一些关于B-Tree索引的限制：</p>
<ul>
<li>如果不是按照索引的最左列开始查找，则无法使用索引。例如上面例子中的索引无法查找名字为Bill的人，也无法查找某个特定生日的日，因为这两列都不是最左数据列。</li>
<li>如果查询中有某个列的范围查询，则其右侧所有列都无法使用索引优化查找。</li>
</ul>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于其实现方式，但是InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。<br>当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中，这也就是说数据行和相邻的键值紧凑地存储在一起。<br>图3展示了聚簇索引中的记录是如何存放的。注意到，叶子页包含了行的全部数据行，但是节点页只包含了索引列。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031171836-2a3fb.png" alt="img"></p>
<p>图3 聚簇索引</p>
<p>聚簇索引可能对性能有帮助，但也可能导致严重的性能问题。聚簇的数据是有一些重要的优点：</p>
<ul>
<li>数据访问更快，聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li>
</ul>
<p>如果在设计表和查询时能充分利用上面的优点，那么就能极大地提升性能。同时，聚簇索引也有一些缺点：</p>
<ul>
<li>插入顺序严重依赖插入顺序。按照主键的顺序插入是向InnoDB表中插入数据速度最快的方式，需要避免主键键值随机的(不连续且值得分布范围非常大)聚簇索引，比如使用UUID作为主键，而应该使用类似AUTO_INCREMENT的自增列。</li>
<li>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动位置到新的位置。</li>
<li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行时，可能面临“页分裂”的问题。当行的主键值要求必须将这行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间</li>
<li>二级索引可能比想象的更大，因为在二级索引中的叶节点包含了引用行的主键列</li>
<li>二级索引访问需要两次索引查找，而不是一次。</li>
</ul>
<h2 id="InnoDB和MyISAM的索引区别"><a href="#InnoDB和MyISAM的索引区别" class="headerlink" title="InnoDB和MyISAM的索引区别"></a>InnoDB和MyISAM的索引区别</h2><p>聚簇索引和非聚簇索引的数据分布有区别，以及对应的主键索引和二级索引的数据分布也有区别，通常会让人感到困惑和意外。图4展示了MyISAM和InnoDB的不同索引和数据存储方式。<br>MyISAM的数据分布非常简单，按照数据插入的顺序存储在磁盘上，主键索引和二级索引的叶节点存储着指针，指向对应的数据行。<br>InnoDB中，聚簇索引“就是”表，所以不会像MyISAM那样需要独立的行存储。聚簇索引的每个叶节点都包含了主键值和所有的剩余列(在此例中是col2)。<br>InnoDB的二级索引和聚簇索引很不同。InnoDB二级索引的叶节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031171837-1e9a0.png" alt="img"></p>
<p>图4 InnoDB和MyISAM的区别</p>
<h2 id="松散索引扫描"><a href="#松散索引扫描" class="headerlink" title="松散索引扫描"></a>松散索引扫描</h2><p>MySQL并不支持松散索引扫描，也就是无法按照不连续的方式扫描一个索引。通常，MySQL的索引扫描需要先定义一个起点和终点，即使需要的数据只是这段索引中很少数的几个，MySQL仍然需要扫描这段索引中的每个条目。<br>下面，我们通过一个示例说明这点，假设我们有如下索引(a,b)，有下面的查询：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">mysql&gt;<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb1 <span class="keyword">WHERE</span> b <span class="keyword">BETWEEN</span> <span class="number">2</span> <span class="keyword">AND</span> <span class="number">3</span>;</span></pre></td></tr></table></figure>

<p>因为索引的前导字段是列a，但是在查询中只指定了字段b，MySQL无法使用这个索引，从而只能通过全表扫描找到匹配的行，如图5所示。<br><img src="http://image.winrains.cn/2019/10/20191031171837-a11d6.png" alt="img"></p>
<p>图5 全表扫描</p>
<p>了解索引的物理结构的话，不难发现还可以有一个更快的办法执行上面的查询。索引的物理结构(不是存储引擎的API)是的可以先扫描a列第一个值对应的b列的范围，然后再跳到a列第二个不不同值扫描对应的b列的范围。图6展示了如果由MySQL来实现这个过程会怎样。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031171838-b59f9.png" alt="img"></p>
<p>图6 松散索引</p>
<p>注意到，这时就无须再使用WHERE子句过滤，因为松散索引扫描已经跳过了所有不需要的记录。<br>MySQL 5.0之后的版本，在某些特殊的场景下是可以使用松散索引扫描的，例如，在一个分组查询中需要找到分组的最大值和最小值：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT actor_id, MAX(film_id)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        -&gt; <span class="keyword">FROM</span> sakila.film.film_actor</span></pre></td></tr><tr><td class="code"><pre><span class="line">        -&gt;<span class="built_in"> GROUP </span>BY actor_id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">********************************************* 1. row ***********************************</span></pre></td></tr><tr><td class="code"><pre><span class="line">id: 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">select_type: SIMPLE</span></pre></td></tr><tr><td class="code"><pre><span class="line">table: film_actor</span></pre></td></tr><tr><td class="code"><pre><span class="line">type: range</span></pre></td></tr><tr><td class="code"><pre><span class="line">possible_keys: <span class="literal">NULL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">key: PRIMARY</span></pre></td></tr><tr><td class="code"><pre><span class="line">key_len: 2</span></pre></td></tr><tr><td class="code"><pre><span class="line">ref: <span class="literal">NULL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">rows: 396</span></pre></td></tr><tr><td class="code"><pre><span class="line">Extra: Using index <span class="keyword">for</span> group-by</span></pre></td></tr></table></figure>

<p>在EXPLAIN中的Extra字段显示”Using index for group-by”，表示这里将使用松散索引扫描。</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>索引除了是一种查找数据的高效方式之外，也是一种列数据的直接获取方式。MySQL可以使用索引来直接获取列的数据，这样就不需要读取数据行。如果一个索引包含所有需要查询的字段的值，我们就称之为“覆盖索引”。<br>覆盖索引是非常有用的工具，能够极大地提高性能。SQL查询只需要扫描索引而无需回表，会带来很多好处：</p>
<ul>
<li>索引条目数量和大小通常远小于数据行的条目和大小，所以如果只需要读取索引，那么MySQL就会极大地减少数据访问量。</li>
<li>因为索引是按照列顺序存储的，所以对于I/O密集型的范围查找会比随机从磁盘读取每一行数据的I/O要少的多。</li>
<li>由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键，索引如果二级主键能够覆盖查询，则避免对主键索引的第二次查询。</li>
</ul>
<p>当发起一个被覆盖索引的查询(也叫索引覆盖查询)时，在EXPLAIN的Extra列可以看到”Using Index”的信息。例如，表sakila.inventory有一个多列索引(store_id, film_id)。MySQL如果只需要访问这两列，就可以使用这个索引做覆盖索引，如下所示：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT store<span class="emphasis">_id, film_</span>id FROM sakila.inventory</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">***1.row**</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**</span></pre></td></tr><tr><td class="code"><pre><span class="line">id:1</span></pre></td></tr><tr><td class="code"><pre><span class="line">select_type:SIMPLE</span></pre></td></tr><tr><td class="code"><pre><span class="line">table:inventory</span></pre></td></tr><tr><td class="code"><pre><span class="line">type:index</span></pre></td></tr><tr><td class="code"><pre><span class="line">possible_keys:NULL</span></pre></td></tr><tr><td class="code"><pre><span class="line">key:idx<span class="emphasis">_store_</span>id<span class="emphasis">_film_</span>id</span></pre></td></tr><tr><td class="code"><pre><span class="line">key_len:3</span></pre></td></tr><tr><td class="code"><pre><span class="line">ref:NULL</span></pre></td></tr><tr><td class="code"><pre><span class="line">rows:4673</span></pre></td></tr><tr><td class="code"><pre><span class="line">Extra:Using Index</span></pre></td></tr></table></figure>

<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/9e00633958e6" target="_blank" rel="noopener">https://www.jianshu.com/p/9e00633958e6</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Redis使用方法</title>
    <url>/2019/12/26/Redis%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本文将从Redis的基本特性入手，通过讲述Redis的数据结构和主要命令对Redis的基本能力进行直观介绍。</p>
<p>然后概览Redis提供的高级能力，并在部署、维护、性能调优等多个方面进行更深入的介绍和指导。</p>
<p>本文适合使用Redis的普通开发人员，以及对Redis进行选型、架构设计和性能调优的架构设计人员。</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h1><p>Redis是一个开源的，基于内存的结构化数据存储媒介，可以作为数据库、缓存服务或消息服务使用。<br>Redis支持多种数据结构，包括字符串、哈希表、链表、集合、有序集合、位图、Hyperloglogs等。<br>Redis具备LRU淘汰、事务实现、以及不同级别的硬盘持久化等能力，并且支持副本集和通过Redis Sentinel实现的高可用方案，同时还支持通过Redis Cluster实现的数据自动分片能力。<br>Redis的主要功能都基于单线程模型实现，也就是说Redis使用一个线程来服务所有的客户端请求<br>同时Redis采用了非阻塞式IO，并精细地优化各种命令的算法时间复杂度，这些信息意味着：</p>
<ul>
<li>Redis是线程安全的（因为只有一个线程），其所有操作都是原子的，不会因并发产生数据异常</li>
<li>Redis的速度非常快（因为使用非阻塞式IO，且大部分命令的算法时间复杂度都是O(1))</li>
<li>使用高耗时的Redis命令是很危险的，会占用唯一的一个线程的大量处理时间，导致所有的请求都被拖慢。（例如时间复杂度为O(N)的KEYS命令，严格禁止在生产环境中使用）</li>
</ul>
<h1 id="Redis的数据结构和相关常用命令"><a href="#Redis的数据结构和相关常用命令" class="headerlink" title="Redis的数据结构和相关常用命令"></a><strong>Redis的数据结构和相关常用命令</strong></h1><p>本节将介绍Redis支持的主要数据结构，以及相关的常用Redis命令</p>
<h2 id="Key"><a href="#Key" class="headerlink" title="Key"></a><strong>Key</strong></h2><p>Redis采用Key-Value型的基本数据结构，任何二进制序列都可以作为Redis的Key使用（例如普通的字符串或一张JPEG图片）<br>关于Key的一些注意事项：</p>
<ul>
<li><strong>不要使用过长的Key</strong>。例如使用一个1024字节的key就不是一个好主意，不仅会消耗更多的内存，还会导致查找的效率降低</li>
<li><strong>Key短到缺失了可读性也是不好的</strong>，例如”u1000flw”比起”user:1000:followers”来说，节省了寥寥的存储空间，却引发了可读性和可维护性上的麻烦</li>
<li><strong>最好使用统一的规范来设计Key</strong>，比如”object-type:id:attr”，以这一规范设计出的Key可能是”user:1000”或”comment:1234:reply-to”</li>
<li><strong>Redis允许的最大Key长度是512MB</strong>（对Value的长度限制也是512MB）</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a><strong>String</strong></h2><p>String是Redis的基础数据类型，Redis没有Int、Float、Boolean等数据类型的概念，所有的基本类型在Redis中都以String体现。<br>与String相关的常用命令：</p>
<ul>
<li><strong>SET</strong>：为一个key设置value，可以配合EX/PX参数指定key的有效期，通过NX/XX参数针对key是否存在的情况进行区别操作，时间复杂度O(1)</li>
<li><strong>GET</strong>：获取某个key对应的value，时间复杂度O(1)</li>
<li><strong>GETSET</strong>：为一个key设置value，并返回该key的原value，时间复杂度O(1)</li>
<li><strong>MSET</strong>：为多个key设置value，时间复杂度O(N)</li>
<li><strong>MSETNX</strong>：同MSET，如果指定的key中有任意一个已存在，则不进行任何操作，时间复杂度O(N)</li>
<li><strong>MGET</strong>：获取多个key对应的value，时间复杂度O(N)</li>
</ul>
<p>上文提到过，Redis的基本数据类型只有String，但Redis可以把String作为整型或浮点型数字来使用，主要体现在INCR、DECR类的命令上：</p>
<ul>
<li><strong>INCR</strong>：将key对应的value值自增1，并返回自增后的值。只对可以转换为整型的String数据起作用。时间复杂度O(1)</li>
<li><strong>INCRBY</strong>：将key对应的value值自增指定的整型数值，并返回自增后的值。只对可以转换为整型的String数据起作用。时间复杂度O(1)</li>
<li><strong>DECR/DECRBY</strong>：同INCR/INCRBY，自增改为自减。</li>
</ul>
<p>INCR/DECR系列命令要求操作的value类型为String，并可以转换为64位带符号的整型数字，否则会返回错误。<br>也就是说，进行INCR/DECR系列命令的value，必须在[-2^63 ~ 2^63 - 1]范围内。<br>前文提到过，Redis采用单线程模型，天然是线程安全的，这使得INCR/DECR命令可以非常便利的实现高并发场景下的精确控制。</p>
<h3 id="例1：库存控制"><a href="#例1：库存控制" class="headerlink" title="例1：库存控制"></a><strong>例1：库存控制</strong></h3><p>在高并发场景下实现库存余量的精准校验，确保不出现超卖的情况。<br>设置库存总量：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> inv:remain <span class="comment">"100"</span></span></pre></td></tr></table></figure>

<p>库存扣减+余量校验：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">DECR</span> <span class="selector-tag">inv</span><span class="selector-pseudo">:remain</span></span></pre></td></tr></table></figure>

<p>当DECR命令返回值大于等于0时，说明库存余量校验通过，如果返回小于0的值，则说明库存已耗尽。<br>假设同时有300个并发请求进行库存扣减，Redis能够确保这300个请求分别得到99到-200的返回值，每个请求得到的返回值都是唯一的，绝对不会找出现两个请求得到一样的返回值的情况。</p>
<h3 id="例2：自增序列生成"><a href="#例2：自增序列生成" class="headerlink" title="例2：自增序列生成"></a><strong>例2：自增序列生成</strong></h3><p>实现类似于RDBMS的Sequence功能，生成一系列唯一的序列号<br>设置序列起始值：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> sequence <span class="comment">"10000"</span></span></pre></td></tr></table></figure>

<p>获取一个序列值：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">INCR sequence</span></span></pre></td></tr></table></figure>

<p>直接将返回值作为序列使用即可。<br>获取一批（如100个）序列值：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">INCRBY sequence <span class="number">100</span></span></pre></td></tr></table></figure>

<p>假设返回值为N，那么[N - 99 ~ N]的数值都是可用的序列值。<br>当多个客户端同时向Redis申请自增序列时，Redis能够确保每个客户端得到的序列值或序列范围都是全局唯一的，绝对不会出现不同客户端得到了重复的序列值的情况。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a><strong>List</strong></h2><p>Redis的List是链表型的数据结构，可以使用LPUSH/RPUSH/LPOP/RPOP等命令在List的两端执行插入元素和弹出元素的操作。<br>虽然List也支持在特定index上插入和读取元素的功能，但其时间复杂度较高（O(N)），应小心使用。<br>与List相关的常用命令：</p>
<ul>
<li><strong>LPUSH</strong>：向指定List的左侧（即头部）插入1个或多个元素，返回插入后的List长度。时间复杂度O(N)，N为插入元素的数量</li>
<li><strong>RPUSH</strong>：同LPUSH，向指定List的右侧（即尾部）插入1或多个元素</li>
<li><strong>LPOP</strong>：从指定List的左侧（即头部）移除一个元素并返回，时间复杂度O(1)</li>
<li><strong>RPOP</strong>：同LPOP，从指定List的右侧（即尾部）移除1个元素并返回</li>
<li><strong>LPUSHX/RPUSHX</strong>：与LPUSH/RPUSH类似，区别在于，LPUSHX/RPUSHX操作的key如果不存在，则不会进行任何操作</li>
<li><strong>LLEN</strong>：返回指定List的长度，时间复杂度O(1)</li>
<li><strong>LRANGE</strong>：返回指定List中指定范围的元素（双端包含，即LRANGE key 0 10会返回11个元素），时间复杂度O(N)。</li>
</ul>
<p>注意：应尽可能控制一次获取的元素数量，一次获取过大范围的List元素会导致延迟，同时对长度不可预知的List，避免使用LRANGE key 0 -1这样的完整遍历操作。</p>
<p>应谨慎使用的List相关命令：</p>
<ul>
<li><strong>LINDEX</strong>：返回指定List指定index上的元素，如果index越界，返回nil。index数值是回环的，即-1代表List最后一个位置，-2代表List倒数第二个位置。时间复杂度O(N)</li>
<li><strong>LSET</strong>：将指定List指定index上的元素设置为value，如果index越界则返回错误，时间复杂度O(N)，如果操作的是头/尾部的元素，则时间复杂度为O(1)</li>
<li><strong>LINSERT</strong>：向指定List中指定元素之前/之后插入一个新元素，并返回操作后的List长度。如果指定的元素不存在，返回-1。如果指定key不存在，不会进行任何操作，时间复杂度O(N)</li>
</ul>
<p>由于Redis的List是链表结构的，上述的三个命令的算法效率较低，需要对List进行遍历，命令的耗时无法预估，在List长度大的情况下耗时会明显增加，应谨慎使用。<br>换句话说，Redis的List实际是设计来用于实现队列，而不是用于实现类似ArrayList这样的列表的。<br>如果你不是想要实现一个双端出入的队列，那么请尽量不要使用Redis的List数据结构。<br>为了更好支持队列的特性，Redis还提供了一系列阻塞式的操作命令，如BLPOP/BRPOP等，能够实现类似于BlockingQueue的能力，即在List为空时，阻塞该连接，直到List中有对象可以出队时再返回。</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a><strong>Hash</strong></h2><p>Hash即哈希表，Redis的Hash和传统的哈希表一样，是一种field-value型的数据结构，可以理解成将HashMap搬入Redis。<br>Hash非常适合用于表现对象类型的数据，用Hash中的field对应对象的field即可。<br>Hash的优点包括：</p>
<ul>
<li>可以实现二元查找，如”查找ID为1000的用户的年龄”</li>
<li>比起将整个对象序列化后作为String存储的方法，Hash能够有效地减少网络传输的消耗</li>
<li>当使用Hash维护一个集合时，提供了比List效率高得多的随机访问命令</li>
</ul>
<p>与Hash相关的常用命令：</p>
<ul>
<li><p><strong>HSET</strong>：将key对应的Hash中的field设置为value。如果该Hash不存在，会自动创建一个。时间复杂度O(1)</p>
</li>
<li><p><strong>HGET</strong>：返回指定Hash中field字段的值，时间复杂度O(1)</p>
</li>
<li><p><strong>HMSET/HMGET</strong>：同HSET和HGET，可以批量操作同一个key下的多个field，时间复杂度：O(N)，N为一次操作的field数量</p>
</li>
<li><p><strong>HSETNX</strong>：同HSET，但如field已经存在，HSETNX不会进行任何操作，时间复杂度O(1)</p>
</li>
<li><p><strong>HEXISTS</strong>：判断指定Hash中field是否存在，存在返回1，不存在返回0，时间复杂度O(1)</p>
</li>
<li><p><strong>HDEL</strong>：删除指定Hash中的field（1个或多个），时间复杂度：O(N)，N为操作的field数量</p>
</li>
<li><p><strong>HINCRBY</strong>：同INCRBY命令，对指定Hash中的一个field进行INCRBY，时间复杂度O(1)</p>
</li>
</ul>
<p>应谨慎使用的Hash相关命令：</p>
<ul>
<li><strong>HGETALL</strong>：返回指定Hash中所有的field-value对。返回结果为数组，数组中field和value交替出现。时间复杂度O(N)</li>
<li><strong>HKEYS/HVALS</strong>：返回指定Hash中所有的field/value，时间复杂度O(N)</li>
</ul>
<p>上述三个命令都会对Hash进行完整遍历，Hash中的field数量与命令的耗时线性相关<br>对于尺寸不可预知的Hash，应严格避免使用上面三个命令，而改为使用HSCAN命令进行游标式的遍历</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a><strong>Set</strong></h2><p>Redis Set是无序的，不可重复的String集合。<br>与Set相关的常用命令：</p>
<ul>
<li><strong>SADD</strong>：向指定Set中添加1个或多个member，如果指定Set不存在，会自动创建一个。时间复杂度O(N)，N为添加的member个数</li>
<li><strong>SREM</strong>：从指定Set中移除1个或多个member，时间复杂度O(N)，N为移除的member个数</li>
<li><strong>SRANDMEMBER</strong>：从指定Set中随机返回1个或多个member，时间复杂度O(N)，N为返回的member个数</li>
<li><strong>SPOP</strong>：从指定Set中随机移除并返回count个member，时间复杂度O(N)，N为移除的member个数</li>
<li><strong>SCARD</strong>：返回指定Set中的member个数，时间复杂度O(1)</li>
<li><strong>SISMEMBER</strong>：判断指定的value是否存在于指定Set中，时间复杂度O(1)</li>
<li><strong>SMOVE</strong>：将指定member从一个Set移至另一个Set</li>
</ul>
<p>慎用的Set相关命令：</p>
<ul>
<li><strong>SMEMBERS</strong>：返回指定Hash中所有的member，时间复杂度O(N)</li>
<li><strong>SUNION/SUNIONSTORE</strong>：计算多个Set的并集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数</li>
<li><strong>SINTER/SINTERSTORE</strong>：计算多个Set的交集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数</li>
<li><strong>SDIFF/SDIFFSTORE</strong>：计算1个Set与1或多个Set的差集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数</li>
</ul>
<p>上述几个命令涉及的计算量大，应谨慎使用，特别是在参与计算的Set尺寸不可知的情况下，应严格避免使用。</p>
<h2 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a><strong>Sorted Set</strong></h2><p>Redis Sorted Set是有序的、不可重复的String集合。<br>Sorted Set中的每个元素都需要指派一个分数(score)，Sorted Set会根据score对元素进行升序排序。<br>如果多个member拥有相同的score，则以字典序进行升序排序。Sorted Set非常适合用于实现排名。<br>Sorted Set的主要命令：</p>
<ul>
<li><strong>ZADD</strong>：向指定Sorted Set中添加1个或多个member，时间复杂度O(Mlog(N))，M为添加的member数量，N为Sorted Set中的member数量</li>
<li><strong>ZREM</strong>：从指定Sorted Set中删除1个或多个member，时间复杂度O(Mlog(N))，M为删除的member数量，N为Sorted Set中的member数量</li>
<li><strong>ZCOUNT</strong>：返回指定Sorted Set中指定score范围内的member数量，时间复杂度：O(log(N))</li>
<li><strong>ZCARD</strong>：返回指定Sorted Set中的member数量，时间复杂度O(1)</li>
<li><strong>ZSCORE</strong>：返回指定Sorted Set中指定member的score，时间复杂度O(1)</li>
<li><strong>ZRANK/ZREVRANK</strong>：返回指定member在Sorted Set中的排名，ZRANK返回按升序排序的排名，ZREVRANK则返回按降序排序的排名。时间复杂度O(log(N))</li>
<li><strong>ZINCRBY</strong>：同INCRBY，对指定Sorted Set中的指定member的score进行自增，时间复杂度O(log(N))</li>
</ul>
<p>慎用的Sorted Set相关命令：</p>
<ul>
<li><strong>ZRANGE/ZREVRANGE</strong>：返回指定Sorted Set中指定排名范围内的所有member，ZRANGE为按score升序排序，ZREVRANGE为按score降序排序，时间复杂度O(log(N)+M)，M为本次返回的member数</li>
<li><strong>ZRANGEBYSCORE/ZREVRANGEBYSCORE</strong>：返回指定Sorted Set中指定score范围内的所有member，返回结果以升序/降序排序，min和max可以指定为-inf和+inf，代表返回所有的member。时间复杂度O(log(N)+M)</li>
<li><strong>ZREMRANGEBYRANK/ZREMRANGEBYSCORE</strong>：移除Sorted Set中指定排名范围/指定score范围内的所有member。时间复杂度O(log(N)+M)</li>
</ul>
<p>上述几个命令，应尽量避免传递[0 -1]或[-inf +inf]这样的参数，来对Sorted Set做一次性的完整遍历，特别是在Sorted Set的尺寸不可预知的情况下。</p>
<h2 id="Bitmap和HyperLogLog"><a href="#Bitmap和HyperLogLog" class="headerlink" title="Bitmap和HyperLogLog"></a><strong>Bitmap和HyperLogLog</strong></h2><p>Redis的这两种数据结构相较之前的并不常用，在本文中只做简要介绍<br>Bitmap在Redis中不是一种实际的数据类型，而是一种将String作为Bitmap使用的方法。<br>可以理解为将String转换为bit数组。使用Bitmap来存储true/false类型的简单数据极为节省空间。<br>HyperLogLogs是一种主要用于数量统计的数据结构，它和Set类似，维护一个不可重复的String集合<br>但是HyperLogLogs并不维护具体的member内容，只维护member的个数。<br>也就是说，HyperLogLogs只能用于计算一个集合中不重复的元素数量，所以它比Set要节省很多内存空间。</p>
<h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a><strong>其他常用命令</strong></h2><ul>
<li><strong>EXISTS</strong>：判断指定的key是否存在，返回1代表存在，0代表不存在，时间复杂度O(1)</li>
<li><strong>DEL</strong>：删除指定的key及其对应的value，时间复杂度O(N)，N为删除的key数量</li>
<li><strong>EXPIRE/PEXPIRE</strong>：为一个key设置有效期，单位为秒或毫秒，时间复杂度O(1)</li>
<li><strong>TTL/PTTL</strong>：返回一个key剩余的有效时间，单位为秒或毫秒，时间复杂度O(1)</li>
<li><strong>RENAME/RENAMENX</strong>：将key重命名为newkey。使用RENAME时，如果newkey已经存在，其值会被覆盖；使用RENAMENX时，如果newkey已经存在，则不会进行任何操作，时间复杂度O(1)</li>
<li><strong>TYPE</strong>：返回指定key的类型，string, list, set, zset, hash。时间复杂度O(1)</li>
<li><strong>CONFIG GET</strong>：获得Redis某配置项的当前值，可以使用*通配符，时间复杂度O(1)</li>
<li><strong>CONFIG SET</strong>：为Redis某个配置项设置新值，时间复杂度O(1)</li>
<li><strong>CONFIG REWRITE</strong>：让Redis重新加载redis.conf中的配置</li>
</ul>
<h1 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a><strong>数据持久化</strong></h1><p>Redis提供了将数据定期自动持久化至硬盘的能力，包括RDB和AOF两种方案。<br>两种方案分别有其长处和短板，可以配合起来同时运行，确保数据的稳定性。</p>
<h2 id="必须使用数据持久化吗？"><a href="#必须使用数据持久化吗？" class="headerlink" title="必须使用数据持久化吗？"></a><strong>必须使用数据持久化吗？</strong></h2><p>Redis的数据持久化机制是可以关闭的，如果你只把Redis作为缓存服务使用，Redis中存储的所有数据都不是该数据的主体而仅仅是同步过来的备份，那么可以关闭Redis的数据持久化机制。<br>但通常来说，仍然建议至少开启RDB方式的数据持久化，因为：</p>
<ul>
<li>RDB方式的持久化几乎不损耗Redis本身的性能，在进行RDB持久化时，Redis主进程唯一需要做的事情就是fork出一个子进程，所有持久化工作都由子进程完成</li>
<li>Redis无论因为什么原因crash掉之后，重启时能够自动恢复到上一次RDB快照中记录的数据。这省去了手工从其他数据源（如DB）同步数据的过程，而且要比其他任何的数据恢复方式都要快</li>
<li>现在硬盘那么大，真的不缺那一点地方</li>
</ul>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a><strong>RDB</strong></h2><p>采用RDB持久方式，Redis会定期保存数据快照至一个rbd文件中，并在启动时自动加载rdb文件，恢复之前保存的数据。<br>可以在配置文件中配置Redis进行快照保存的时机：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">save</span> <span class="selector-attr">[seconds]</span> <span class="selector-attr">[changes]</span></span></pre></td></tr></table></figure>

<p>意为在[seconds]秒内如果发生了[changes]次数据修改，则进行一次RDB快照保存，例如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">save <span class="number">60</span> <span class="number">100</span></span></pre></td></tr></table></figure>

<p>会让Redis每60秒检查一次数据变更情况，如果发生了100次或以上的数据变更，则进行RDB快照保存。<br>可以配置多条save指令，让Redis执行多级的快照保存策略。<br>Redis默认开启RDB快照，默认的RDB策略如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span>s</span></pre></td></tr><tr><td class="code"><pre><span class="line">save <span class="number">300</span> <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">save <span class="number">60</span> <span class="number">10000</span></span></pre></td></tr></table></figure>

<p>也可以通过<strong>BGSAVE</strong>命令手工触发RDB快照保存。<br><strong>RDB的优点：</strong></p>
<ul>
<li>对性能影响最小。如前文所述，Redis在保存RDB快照时会fork出子进程进行，几乎不影响Redis处理客户端请求的效率。</li>
<li>每次快照会生成一个完整的数据快照文件，所以可以辅以其他手段保存多个时间点的快照（例如把每天0点的快照备份至其他存储媒介中），作为非常可靠的灾难恢复手段。</li>
<li>使用RDB文件进行数据恢复比使用AOF要快很多。</li>
</ul>
<p><strong>RDB的缺点：</strong></p>
<ul>
<li>快照是定期生成的，所以在Redis crash时或多或少会丢失一部分数据。</li>
<li>如果数据集非常大且CPU不够强（比如单核CPU），Redis在fork子进程时可能会消耗相对较长的时间（长至1秒），影响这期间的客户端请求。</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a><strong>AOF</strong></h2><p>采用AOF持久方式时，Redis会把每一个写请求都记录在一个日志文件里。<br>在Redis重启时，会把AOF文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。<br>AOF默认是关闭的，如要开启，进行如下配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">appendonly</span> <span class="literal">yes</span></span></pre></td></tr></table></figure>

<p>AOF提供了三种fsync配置，always/everysec/no，通过配置项[appendfsync]指定：</p>
<ul>
<li><strong>appendfsync no</strong>：不进行fsync，将flush文件的时机交给OS决定，速度最快</li>
<li><strong>appendfsync always</strong>：每写入一条日志就进行一次fsync操作，数据安全性最高，但速度最慢</li>
<li><strong>appendfsync everysec</strong>：折中的做法，交由后台线程每秒fsync一次</li>
</ul>
<p>随着AOF不断地记录写操作日志，必定会出现一些无用的日志<br>例如某个时间点执行了命令<strong>SET key1 “abc”</strong>，在之后某个时间点又执行了<strong>SET key1 “bcd”</strong>，那么第一条命令很显然是没有用的。<br>大量的无用日志会让AOF文件过大，也会让数据恢复的时间过长。<br>所以Redis提供了AOF rewrite功能，可以重写AOF文件，只保留能够把数据恢复到最新状态的最小写操作集。<br>AOF rewrite可以通过<strong>BGREWRITEAOF</strong>命令触发，也可以配置Redis定期自动进行：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">auto</span>-aof-rewrite-percentage <span class="number">100</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">auto</span>-aof-rewrite-min-size <span class="number">64</span>mb</span></pre></td></tr></table></figure>

<p>上面两行配置的含义是，Redis在每次AOF rewrite时，会记录完成rewrite后的AOF日志大小，当AOF日志大小在该基础上增长了100%后，自动进行AOF rewrite。同时如果增长的大小没有达到64mb，则不会进行rewrite。<br><strong>AOF的优点：</strong></p>
<ul>
<li>最安全，在启用appendfsync always时，任何已写入的数据都不会丢失，使用在启用appendfsync everysec也至多只会丢失1秒的数据。</li>
<li>AOF文件在发生断电等问题时也不会损坏，即使出现了某条日志只写入了一半的情况，也可以使用redis-check-aof工具轻松修复。</li>
<li>AOF文件易读，可修改，在进行了某些错误的数据清除操作后，只要AOF文件没有rewrite，就可以把AOF文件备份出来，把错误的命令删除，然后恢复数据。</li>
</ul>
<p><strong>AOF的缺点：</strong></p>
<ul>
<li>AOF文件通常比RDB文件更大</li>
<li>性能消耗比RDB高</li>
<li>数据恢复速度比RDB慢</li>
</ul>
<h1 id="内存管理与数据淘汰机制"><a href="#内存管理与数据淘汰机制" class="headerlink" title="内存管理与数据淘汰机制"></a><strong>内存管理与数据淘汰机制</strong></h1><h2 id="最大内存设置"><a href="#最大内存设置" class="headerlink" title="最大内存设置"></a><strong>最大内存设置</strong></h2><p>默认情况下，在32位OS中，Redis最大使用3GB的内存，在64位OS中则没有限制。<br>在使用Redis时，应该对数据占用的最大空间有一个基本准确的预估，并为Redis设定最大使用的内存。<br>否则在64位OS中Redis会无限制地占用内存（当物理内存被占满后会使用swap空间），容易引发各种各样的问题。<br>通过如下配置控制Redis使用的最大内存：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">maxmemory <span class="number">100</span>mb</span></pre></td></tr></table></figure>

<p>在内存占用达到了maxmemory后，再向Redis写入数据时，Redis会：</p>
<ul>
<li>根据配置的数据淘汰策略尝试淘汰数据，释放空间</li>
<li>如果没有数据可以淘汰，或者没有配置数据淘汰策略，那么Redis会对所有写请求返回错误，但读请求仍然可以正常执行</li>
</ul>
<p>在为Redis设置maxmemory时，需要注意：</p>
<p>如果采用了Redis的主从同步，主节点向从节点同步数据时，会占用掉一部分内存空间</p>
<p>如果maxmemory过于接近主机的可用内存，会导致数据同步时内存不足。</p>
<p>所以设置的maxmemory不要过于接近主机可用的内存，留出一部分预留用作主从同步。</p>
<h2 id="数据淘汰机制"><a href="#数据淘汰机制" class="headerlink" title="数据淘汰机制"></a><strong>数据淘汰机制</strong></h2><p>Redis提供了5种数据淘汰策略：</p>
<ul>
<li><strong>volatile-lru</strong>：使用LRU算法进行数据淘汰（淘汰上次使用时间最早的，且使用次数最少的key），只淘汰设定了有效期的key</li>
<li><strong>allkeys-lru</strong>：使用LRU算法进行数据淘汰，所有的key都可以被淘汰</li>
<li><strong>volatile-random</strong>：随机淘汰数据，只淘汰设定了有效期的key</li>
<li><strong>allkeys-random</strong>：随机淘汰数据，所有的key都可以被淘汰</li>
<li><strong>volatile-ttl</strong>：淘汰剩余有效期最短的key</li>
</ul>
<p>最好为Redis指定一种有效的数据淘汰策略以配合maxmemory设置，避免在内存使用满后发生写入失败的情况。<br>一般来说，推荐使用的策略是volatile-lru，并辨识Redis中保存的数据的重要性。<br>对于那些重要的，绝对不能丢弃的数据（如配置类数据等），应不设置有效期，这样Redis就永远不会淘汰这些数据。<br>对于那些相对不是那么重要的，并且能够热加载的数据（比如缓存最近登录的用户信息，当在Redis中找不到时，程序会去DB中读取），可以设置上有效期，这样在内存不够时Redis就会淘汰这部分数据。<br>配置方法：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">maxmemory-policy <span class="keyword">volatile</span>-lru <span class="meta">#默认是noeviction，即不进行数据淘汰</span></span></pre></td></tr></table></figure>

<h2 id="Pipelining"><a href="#Pipelining" class="headerlink" title="Pipelining"></a><strong>Pipelining</strong></h2><p>Redis提供许多批量操作的命令，如MSET/MGET/HMSET/HMGET等等，这些命令存在的意义是减少维护网络连接和传输数据所消耗的资源和时间。<br>例如连续使用5次SET命令设置5个不同的key，比起使用一次MSET命令设置5个不同的key，效果是一样的<br>但前者会消耗更多的RTT(Round Trip Time)时长，永远应优先使用后者。<br>然而，如果客户端要连续执行的多次操作无法通过Redis命令组合在一起，例如：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> a <span class="comment">"abc"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">INCR <span class="comment">b</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HSET <span class="comment">c name</span> <span class="comment">"hi"</span></span></pre></td></tr></table></figure>

<p>此时便可以使用Redis提供的pipelining功能来实现在一次交互中执行多条命令。<br>使用pipelining时，只需要从客户端一次向Redis发送多条命令（以\r\n）分隔，Redis就会依次执行这些命令，并且把每个命令的返回按顺序组装在一起一次返回，比如：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">$ (printf <span class="string">"PING\r<span class="subst">\n</span>PING\r<span class="subst">\n</span>PING\r<span class="subst">\n</span>"</span>; sleep <span class="number">1</span>) | nc localhost <span class="number">6379</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+PONG</span></pre></td></tr><tr><td class="code"><pre><span class="line">+PONG</span></pre></td></tr><tr><td class="code"><pre><span class="line">+PONG</span></pre></td></tr></table></figure>

<p>大部分的Redis客户端都对Pipelining提供支持，所以开发者通常并不需要自己手工拼装命令列表。</p>
<h3 id="Pipelining的局限性"><a href="#Pipelining的局限性" class="headerlink" title="Pipelining的局限性"></a><strong>Pipelining的局限性</strong></h3><p>Pipelining只能用于执行<strong>连续且无相关性</strong>的命令，当某个命令的生成需要依赖于前一个命令的返回时，就无法使用Pipelining了。<br>通过Scripting功能，可以规避这一局限性</p>
<h2 id="事务与Scripting"><a href="#事务与Scripting" class="headerlink" title="事务与Scripting"></a><strong>事务与Scripting</strong></h2><p>Pipelining能够让Redis在一次交互中处理多条命令，然而在一些场景下，我们可能需要在此基础上确保这一组命令是连续执行的。<br>比如获取当前累计的PV数并将其清0</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt; <span class="builtin-name">GET</span> vCount</span></pre></td></tr><tr><td class="code"><pre><span class="line">12384</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; <span class="builtin-name">SET</span> vCount 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">OK</span></pre></td></tr></table></figure>

<p>如果在GET和SET命令之间插进来一个INCR vCount，就会使客户端拿到的vCount不准确。<br>Redis的事务可以确保复数命令执行时的原子性。<br>也就是说Redis能够保证：一个事务中的一组命令是绝对连续执行的，在这些命令执行完成之前，绝对不会有来自于其他连接的其他命令插进去执行。<br>通过MULTI和EXEC命令来把这两个命令加入一个事务中：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt; MULTI</span></pre></td></tr><tr><td class="code"><pre><span class="line">OK</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; GET vCount</span></pre></td></tr><tr><td class="code"><pre><span class="line">QUEUED</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; SET vCount <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">QUEUED</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; EXEC</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="number">12384</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span>) OK</span></pre></td></tr></table></figure>

<p>Redis在接收到MULTI命令后便会开启一个事务，这之后的所有读写命令都会保存在队列中但并不执行<br>直到接收到EXEC命令后，Redis会把队列中的所有命令连续顺序执行，并以数组形式返回每个命令的返回结果。<br>可以使用DISCARD命令放弃当前的事务，将保存的命令队列清空。<br>需要注意的是，<strong>Redis事务不支持回滚</strong>：如果一个事务中的命令出现了语法错误，大部分客户端驱动会返回错误<br>2.6.5版本以上的Redis也会在执行EXEC时检查队列中的命令是否存在语法错误，如果存在，则会自动放弃事务并返回错误。<br>但如果一个事务中的命令有非语法类的错误（比如对String执行HSET操作），无论客户端驱动还是Redis都无法在真正执行这条命令之前发现，所以事务中的所有命令仍然会被依次执行。<br>在这种情况下，会出现一个事务中部分命令成功部分命令失败的情况，然而与RDBMS不同，Redis不提供事务回滚的功能，所以只能通过其他方法进行数据的回滚。</p>
<h2 id="通过事务实现CAS"><a href="#通过事务实现CAS" class="headerlink" title="通过事务实现CAS"></a><strong>通过事务实现CAS</strong></h2><p>Redis提供了WATCH命令与事务搭配使用，实现CAS乐观锁的机制。<br>假设要实现将某个商品的状态改为已售：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">if(exec(HGET stock:<span class="number">1001</span> <span class="keyword">state</span>) == <span class="string">"in stock"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    exec(HSET stock:<span class="number">1001</span> <span class="keyword">state</span> <span class="string">"sold"</span>);</span></pre></td></tr></table></figure>

<p>这一伪代码执行时，无法确保并发安全性，有可能多个客户端都获取到了”in stock”的状态，导致一个库存被售卖多次。<br>使用WATCH命令和事务可以解决这一问题：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">exec(WATCH stock:<span class="number">1001</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">if(exec(HGET stock:<span class="number">1001</span> <span class="keyword">state</span>) == <span class="string">"in stock"</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    exec(MULTI);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    exec(HSET stock:<span class="number">1001</span> <span class="keyword">state</span> <span class="string">"sold"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    exec(EXEC);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>WATCH的机制是</strong>：在事务EXEC命令执行时，Redis会检查被WATCH的key，只有被WATCH的key从WATCH起始时至今没有发生过变更，EXEC才会被执行。<br>如果WATCH的key在WATCH命令到EXEC命令之间发生过变化，则EXEC命令会返回失败。</p>
<h2 id="Scripting"><a href="#Scripting" class="headerlink" title="Scripting"></a><strong>Scripting</strong></h2><p>通过EVAL与EVALSHA命令，可以让Redis执行LUA脚本。这就类似于RDBMS的存储过程一样，可以把客户端与Redis之间密集的读/写交互放在服务端进行，避免过多的数据交互，提升性能。<br>Scripting功能是作为事务功能的替代者诞生的，事务提供的所有能力Scripting都可以做到。Redis官方推荐使用LUA Script来代替事务，前者的效率和便利性都超过了事务。<br>关于Scripting的具体使用，本文不做详细介绍，请参考官方文档 <a href="https://redis.io/commands/eval" target="_blank" rel="noopener">https://redis.io/commands/eval</a></p>
<h1 id="Redis性能调优"><a href="#Redis性能调优" class="headerlink" title="Redis性能调优"></a><strong>Redis性能调优</strong></h1><p>尽管Redis是一个非常快速的内存数据存储媒介，也并不代表Redis不会产生性能问题。<br>前文中提到过，Redis采用单线程模型，所有的命令都是由一个线程串行执行的<br>所以当某个命令执行耗时较长时，会拖慢其后的所有命令，这使得Redis对每个任务的执行效率更加敏感。<br>针对Redis的性能优化，主要从下面几个层面入手：</p>
<ul>
<li>最初的也是最重要的，确保没有让Redis执行耗时长的命令</li>
<li>使用pipelining将连续执行的命令组合执行</li>
<li>操作系统的Transparent huge pages功能必须关闭：</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">echo never &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/mm/</span>transparent_hugepage<span class="regexp">/enabled</span></span></pre></td></tr></table></figure>

<ul>
<li>如果在虚拟机中运行Redis，可能天然就有虚拟机环境带来的固有延迟。</li>
<li>可以通过./redis-cli –intrinsic-latency 100命令查看固有延迟。同时如果对Redis的性能有较高要求的话，应尽可能在物理机上直接部署Redis。</li>
<li>检查数据持久化策略</li>
<li>考虑引入读写分离机制</li>
</ul>
<h2 id="长耗时命令"><a href="#长耗时命令" class="headerlink" title="长耗时命令"></a><strong>长耗时命令</strong></h2><p>Redis绝大多数读写命令的时间复杂度都在O(1)到O(N)之间，在本文和官方文档中均对每个命令的时间复杂度有说明。<br>通常来说，O(1)的命令是安全的，O(N)命令在使用时需要注意，如果N的数量级不可预知，则应避免使用。<br>例如对一个field数未知的Hash数据执行HGETALL/HKEYS/HVALS命令，通常来说这些命令执行的很快，但如果这个Hash中的field数量极多，耗时就会成倍增长。<br>又如使用SUNION对两个Set执行Union操作，或使用SORT对List/Set执行排序操作等时，都应该严加注意。<br>避免在使用这些O(N)命令时发生问题主要有几个办法：</p>
<ul>
<li>不要把List当做列表使用，仅当做队列来使用</li>
<li>通过机制严格控制Hash、Set、Sorted Set的大小</li>
<li>可能的话，将排序、并集、交集等操作放在客户端执行</li>
<li>绝对禁止使用KEYS命令</li>
<li>避免一次性遍历集合类型的所有成员，而应使用SCAN类的命令进行分批的，游标式的遍历</li>
</ul>
<p>Redis提供了SCAN命令，可以对Redis中存储的所有key进行游标式的遍历，避免使用KEYS命令带来的性能问题。<br>同时还有SSCAN/HSCAN/ZSCAN等命令，分别用于对Set/Hash/Sorted Set中的元素进行游标式遍历。<br>SCAN类命令的使用请参考官方文档：<br><a href="https://redis.io/commands/scan" target="_blank" rel="noopener">https://redis.io/commands/scan</a><br>Redis提供了Slow Log功能，可以自动记录耗时较长的命令。相关的配置参数有两个：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">slowlog-<span class="built_in">log</span>-slower-than xxxms #执行时间慢于xxx毫秒的命令计入Slow <span class="built_in">Log</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">slowlog-<span class="built_in">max</span>-<span class="built_in">len</span> xxx #Slow <span class="built_in">Log</span>的长度，即最大纪录多少条Slow <span class="built_in">Log</span></span></pre></td></tr></table></figure>

<p>使用<strong>SLOWLOG GET [number]</strong>命令，可以输出最近进入Slow Log的number条命令。<br>使用<strong>SLOWLOG RESET</strong>命令，可以重置Slow Log</p>
<h2 id="网络引发的延迟"><a href="#网络引发的延迟" class="headerlink" title="网络引发的延迟"></a><strong>网络引发的延迟</strong></h2><ul>
<li>尽可能使用长连接或连接池，避免频繁创建销毁连接</li>
<li>客户端进行的批量数据操作，应使用Pipeline特性在一次交互中完成。具体请参照本文的Pipelining章节</li>
</ul>
<h2 id="数据持久化引发的延迟"><a href="#数据持久化引发的延迟" class="headerlink" title="数据持久化引发的延迟"></a><strong>数据持久化引发的延迟</strong></h2><p>Redis的数据持久化工作本身就会带来延迟，需要根据数据的安全级别和性能要求制定合理的持久化策略：</p>
<ul>
<li>AOF + fsync always的设置虽然能够绝对确保数据安全，但每个操作都会触发一次fsync，会对Redis的性能有比较明显的影响。</li>
<li>AOF + fsync every second是比较好的折中方案，每秒fsync一次</li>
<li>AOF + fsync never会提供AOF持久化方案下的最优性能</li>
<li>使用RDB持久化通常会提供比使用AOF更高的性能，但需要注意RDB的策略配置</li>
<li>每一次RDB快照和AOF Rewrite都需要Redis主进程进行fork操作。fork操作本身可能会产生较高的耗时，与CPU和Redis占用的内存大小有关。根据具体的情况合理配置RDB快照和AOF Rewrite时机，避免过于频繁的fork带来的延迟</li>
</ul>
<blockquote>
<p>Redis在fork子进程时需要将内存分页表拷贝至子进程以占用了24GB内存的Redis实例为例，共需要拷贝24GB / 4kB * 8 = 48MB的数据。在使用单Xeon 2.27Ghz的物理机上，这一fork操作耗时216ms。可以通过<strong>INFO</strong>命令返回的latest_fork_usec字段查看上一次fork操作的耗时（微秒）</p>
</blockquote>
<h2 id="Swap引发的延迟"><a href="#Swap引发的延迟" class="headerlink" title="Swap引发的延迟"></a><strong>Swap引发的延迟</strong></h2><p>当Linux将Redis所用的内存分页移至swap空间时，将会阻塞Redis进程，导致Redis出现不正常的延迟。<br>Swap通常在物理内存不足或一些进程在进行大量I/O操作时发生，应尽可能避免上述两种情况的出现。<br>/proc//smaps文件中会保存进程的swap记录，通过查看这个文件，能够判断Redis的延迟是否由Swap产生。<br>如果这个文件中记录了较大的Swap size，则说明延迟很有可能是Swap造成的。</p>
<h2 id="数据淘汰引发的延迟"><a href="#数据淘汰引发的延迟" class="headerlink" title="数据淘汰引发的延迟"></a><strong>数据淘汰引发的延迟</strong></h2><p>当同一秒内有大量key过期时，也会引发Redis的延迟。在使用时应尽量将key的失效时间错开。</p>
<h2 id="引入读写分离机制"><a href="#引入读写分离机制" class="headerlink" title="引入读写分离机制"></a><strong>引入读写分离机制</strong></h2><p>Redis的主从复制能力可以实现一主多从的多节点架构，在这一架构下，主节点接收所有写请求，并将数据同步给多个从节点。<br>在这一基础上，我们可以让从节点提供对实时性要求不高的读请求服务，以减小主节点的压力。<br>尤其是针对一些使用了长耗时命令的统计类任务，完全可以指定在一个或多个从节点上执行，避免这些长耗时命令影响其他请求的响应。</p>
<h1 id="主从复制与集群分片"><a href="#主从复制与集群分片" class="headerlink" title="主从复制与集群分片"></a><strong>主从复制与集群分片</strong></h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a><strong>主从复制</strong></h2><p>Redis支持一主多从的主从复制架构。一个Master实例负责处理所有的写请求，Master将写操作同步至所有Slave。<br>借助Redis的主从复制，可以实现读写分离和高可用：</p>
<ul>
<li>实时性要求不是特别高的读请求，可以在Slave上完成，提升效率。特别是一些周期性执行的统计任务，这些任务可能需要执行一些长耗时的Redis命令，可以专门规划出1个或几个Slave用于服务这些统计任务</li>
<li>借助Redis Sentinel可以实现高可用，当Master crash后，Redis Sentinel能够自动将一个Slave晋升为Master，继续提供服务</li>
</ul>
<p>启用主从复制非常简单，只需要配置多个Redis实例，在作为Slave的Redis实例中配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">slaveof</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> <span class="number">6379</span> <span class="comment">#指定Master的IP和端口</span></span></pre></td></tr></table></figure>

<p>当Slave启动后，会从Master进行一次冷启动数据同步<br>由Master触发BGSAVE生成RDB文件推送给Slave进行导入，导入完成后Master再将增量数据通过Redis Protocol同步给Slave<br>之后主从之间的数据便一直以Redis Protocol进行同步</p>
<h2 id="使用Sentinel做自动failover"><a href="#使用Sentinel做自动failover" class="headerlink" title="使用Sentinel做自动failover"></a><strong>使用Sentinel做自动failover</strong></h2><p>Redis的主从复制功能本身只是做数据同步，并不提供监控和自动failover能力<br>要通过主从复制功能来实现Redis的高可用，还需要引入一个组件：Redis Sentinel<br>Redis Sentinel是Redis官方开发的监控组件，可以监控Redis实例的状态，通过Master节点自动发现Slave节点，并在监测到Master节点失效时选举出一个新的Master，并向所有Redis实例推送新的主从配置。<br>Redis Sentinel需要至少部署3个实例才能形成选举关系。<br>关键配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">sentinel</span> <span class="string">monitor</span> <span class="string">mymaster</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> <span class="number">2</span> <span class="comment">#Master实例的IP、端口，以及选举需要的赞成票数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">sentinel</span> <span class="string">down-after-milliseconds</span> <span class="string">mymaster</span> <span class="number">60000</span> <span class="comment">#多长时间没有响应视为Master失效</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">sentinel</span> <span class="string">failover-timeout</span> <span class="string">mymaster</span> <span class="number">180000</span> <span class="comment">#两次failover尝试间的间隔时长</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">sentinel</span> <span class="string">parallel-syncs</span> <span class="string">mymaster</span> <span class="number">1</span> <span class="comment">#如果有多个Slave，可以通过此配置指定同时从新Master进行数据同步的Slave数，避免所有Slave同时进行数据同步导致查询服务也不可用</span></span></pre></td></tr></table></figure>

<p>另外需要注意的是，Redis Sentinel实现的自动failover不是在同一个IP和端口上完成的<br>也就是说自动failover产生的新Master提供服务的IP和端口与之前的Master是不一样的，所以要实现HA，还要求客户端必须支持Sentinel，能够与Sentinel交互获得新Master的信息才行。</p>
<h2 id="集群分片"><a href="#集群分片" class="headerlink" title="集群分片"></a><strong>集群分片</strong></h2><p>为何要做集群分片：</p>
<ul>
<li>Redis中存储的数据量大，一台主机的物理内存已经无法容纳</li>
<li>Redis的写请求并发量大，一个Redis实例以无法承载</li>
</ul>
<p>当上述两个问题出现时，就必须要对Redis进行分片了。<br>Redis的分片方案有很多种，例如很多Redis的客户端都自行实现了分片功能，也有像Twemproxy这样的以代理方式实现的Redis分片方案。<br>然而首选的方案还应该是Redis官方在3.0版本中推出的Redis Cluster分片方案。<br>本文不会对Redis Cluster的具体安装和部署细节进行介绍，重点介绍Redis Cluster带来的好处与弊端。</p>
<h3 id="Redis-Cluster的能力"><a href="#Redis-Cluster的能力" class="headerlink" title="Redis Cluster的能力"></a><strong>Redis Cluster的能力</strong></h3><ul>
<li>能够自动将数据分散在多个节点上</li>
<li>当访问的key不在当前分片上时，能够自动将请求转发至正确的分片</li>
<li>当集群中部分节点失效时仍能提供服务</li>
</ul>
<p>其中第三点是基于主从复制来实现的，Redis Cluster的每个数据分片都采用了主从复制的结构，原理和前文所述的主从复制完全一致<br>唯一的区别是省去了Redis Sentinel这一额外的组件，由Redis Cluster负责进行一个分片内部的节点监控和自动failover。</p>
<h3 id="Redis-Cluster分片原理"><a href="#Redis-Cluster分片原理" class="headerlink" title="Redis Cluster分片原理"></a><strong>Redis Cluster分片原理</strong></h3><p>Redis Cluster中共有16384个hash slot，Redis会计算每个key的CRC16，将结果与16384取模，来决定该key存储在哪一个hash slot中，<br>同时需要指定Redis Cluster中每个数据分片负责的Slot数，Slot的分配在任何时间点都可以进行重新分配。<br>客户端在对key进行读写操作时，可以连接Cluster中的任意一个分片，如果操作的key不在此分片负责的Slot范围内，Redis Cluster会自动将请求重定向到正确的分片上。</p>
<h3 id="hash-tags"><a href="#hash-tags" class="headerlink" title="hash tags"></a><strong>hash tags</strong></h3><p>在基础的分片原则上，Redis还支持hash tags功能，以hash tags要求的格式明明的key，将会确保进入同一个Slot中。<br>例如：{uiv}user:1000和{uiv}user:1001拥有同样的hash tag {uiv}，会保存在同一个Slot中。<br>使用Redis Cluster时，pipelining、事务和LUA Script功能涉及的key必须在同一个数据分片上，否则将会返回错误。<br>如要在Redis Cluster中使用上述功能，就必须通过hash tags来确保一个pipeline或一个事务中操作的所有key都位于同一个Slot中。</p>
<blockquote>
<p>有一些客户端（如Redisson）实现了集群化的pipelining操作，可以自动将一个pipeline里的命令按key所在的分片进行分组，分别发到不同的分片上执行。但是Redis不支持跨分片的事务，事务和LUA Script还是必须遵循所有key在一个分片上的规则要求。</p>
</blockquote>
<h2 id="主从复制-vs-集群分片"><a href="#主从复制-vs-集群分片" class="headerlink" title="主从复制 vs 集群分片"></a><strong>主从复制 vs 集群分片</strong></h2><p>在设计软件架构时，要如何在主从复制和集群分片两种部署方案中取舍呢？<br>从各个方面看，Redis Cluster都是优于主从复制的方案</p>
<ul>
<li>Redis Cluster能够解决单节点上数据量过大的问题</li>
<li>Redis Cluster能够解决单节点访问压力过大的问题</li>
<li>Redis Cluster包含了主从复制的能力</li>
</ul>
<p>那是不是代表Redis Cluster永远是优于主从复制的选择呢？<br>并不是！！！<br>软件架构永远不是越复杂越好，复杂的架构在带来显著好处的同时，一定也会带来相应的弊端。采用Redis Cluster的弊端包括：</p>
<p><strong>1、维护难度增加</strong>。</p>
<p>在使用Redis Cluster时，需要维护的Redis实例数倍增，需要监控的主机数量也相应增加，数据备份/持久化的复杂度也会增加。</p>
<p>同时在进行分片的增减操作时，还需要进行reshard操作，远比主从模式下增加一个Slave的复杂度要高。</p>
<p><strong>2、客户端资源消耗增加</strong></p>
<p>当客户端使用连接池时，需要为每一个数据分片维护一个连接池，客户端同时需要保持的连接数成倍增多，加大了客户端本身和操作系统资源的消耗。</p>
<p><strong>3、性能优化难度增加</strong></p>
<p>你可能需要在多个分片上查看Slow Log和Swap日志才能定位性能问题。</p>
<p><strong>4、事务和LUA Script的使用成本增加</strong></p>
<p>在Redis Cluster中使用事务和LUA Script特性有严格的限制条件</p>
<p>事务和Script中操作的key必须位于同一个分片上，这就使得在开发时必须对相应场景下涉及的key进行额外的规划和规范要求。</p>
<p>如果应用的场景中大量涉及事务和Script的使用，如何在保证这两个功能的正常运作前提下把数据平均分到多个数据分片中就会成为难点。</p>
<p>所以，在主从复制和集群分片两个方案中做出选择时，应该从应用软件的功能特性、数据和访问量级、未来发展规划等方面综合考虑，只在<strong>确实有必要</strong>引入数据分片时再使用Redis Cluster。<br><strong>下面是一些建议：</strong></p>
<ul>
<li>需要在Redis中存储的数据有多大？未来2年内可能发展为多大？这些数据是否都需要长期保存？是否可以使用LRU算法进行非热点数据的淘汰？综合考虑前面几个因素，评估出Redis需要使用的物理内存。</li>
<li>用于部署Redis的主机物理内存有多大？有多少可以分配给Redis使用？对比(1)中的内存需求评估，是否足够用？</li>
<li>Redis面临的并发写压力会有多大？在不使用pipelining时，Redis的写性能可以超过10万次/秒（更多的benchmark可以参考 <a href="https://redis.io/topics/benchmarks" target="_blank" rel="noopener">https://redis.io/topics/benchmarks</a> ）</li>
<li>在使用Redis时，是否会使用到pipelining和事务功能？使用的场景多不多？</li>
</ul>
<p>综合上面几点考虑，如果单台主机的可用物理内存完全足以支撑对Redis的容量需求，且Redis面临的并发写压力距离Benchmark值还尚有距离，建议采用主从复制的架构，可以省去很多不必要的麻烦。<br>同时，如果应用中大量使用pipelining和事务，也建议尽可能选择主从复制架构，可以减少设计和开发时的复杂度。</p>
<h1 id="Redis-Java客户端的选择"><a href="#Redis-Java客户端的选择" class="headerlink" title="Redis Java客户端的选择"></a><strong>Redis Java客户端的选择</strong></h1><p>Redis的Java客户端很多，官方推荐的有三种：Jedis、Redisson和lettuce。<br>在这里对Jedis和Redisson进行对比介绍<br>Jedis：</p>
<ul>
<li>轻量，简洁，便于集成和改造</li>
<li>支持连接池</li>
<li>支持pipelining、事务、LUA Scripting、Redis Sentinel、Redis Cluster</li>
<li>不支持读写分离，需要自己实现</li>
<li>文档差（真的很差，几乎没有……）</li>
</ul>
<p>Redisson：</p>
<ul>
<li>基于Netty实现，采用非阻塞IO，性能高</li>
<li>支持异步请求</li>
<li>支持连接池</li>
<li>支持pipelining、LUA Scripting、Redis Sentinel、Redis Cluster</li>
<li>不支持事务，官方建议以LUA Scripting代替事务</li>
<li>支持在Redis Cluster架构下使用pipelining</li>
<li>支持读写分离，支持读负载均衡，在主从复制和Redis Cluster架构下都可以使用</li>
<li>内建Tomcat Session Manager，为Tomcat 6/7/8提供了会话共享功能</li>
<li>可以与Spring Session集成，实现基于Redis的会话共享</li>
<li>文档较丰富，有中文文档</li>
</ul>
<p>对于Jedis和Redisson的选择，同样应遵循前述的原理，尽管Jedis比起Redisson有各种各样的不足，但也应该在需要使用Redisson的高级特性时再选用Redisson，避免造成不必要的程序复杂度提升。</p>
]]></content>
      <categories>
        <category>Java技术</category>
        <category>Redis</category>
      </categories>
  </entry>
</search>
