<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>StringBuilder为什么线程不安全</title>
    <url>/2019/12/26/StringBuilder%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>周五去面试又被面试的一个问题问哑巴了</p>
<blockquote>
<p>面试官：StringBuilder和StringBuffer的区别在哪？<br>我：StringBuilder不是线程安全的，StringBuffer是线程安全的<br>面试官：那StringBuilder不安全的点在哪儿？<br>我：。。。（哑巴了）</p>
</blockquote>
<p>在这之前我只记住了StringBuilder不是线程安全的，StringBuffer是线程安全的这个结论，至于StringBuilder为什么不安全从来没有去想过。</p>
<a id="more"></a>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote>
<p>在分析设个问题之前我们要知道StringBuilder和StringBuffer的内部实现跟String类一样，都是通过一个char数组存储字符串的，不同的是String类里面的char数组是final修饰的，是不可变的，而StringBuilder和StringBuffer的char数组是可变的。</p>
</blockquote>
<p>首先通过一段代码去看一下多线程操作StringBuilder对象会出现什么问题</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">StringBuilderDemo</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) throws InterruptedException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        StringBuilder <span class="built_in">string</span>Builder = new StringBuilder();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            new Thread(new Runnable() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">public</span> <span class="built_in">void</span> run() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="built_in">string</span>Builder.append(<span class="string">"a"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Thread.sleep(<span class="number">100</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(<span class="built_in">string</span>Builder.length());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们能看到这段代码创建了10个线程，每个线程循环1000次往StringBuilder对象里面append字符。正常情况下代码应该输出10000，但是实际运行会输出什么呢？</p>
<p><img src="http://image.winrains.cn/2019/08/20190829104615-6ff18.png" alt="img"></p>
<p>我们看到输出了“9326”，小于预期的10000，并且还抛出了一个ArrayIndexOutOfBoundsException异常（异常不是必现）。</p>
<h4 id="1、为什么输出值跟预期值不一样"><a href="#1、为什么输出值跟预期值不一样" class="headerlink" title="1、为什么输出值跟预期值不一样"></a>1、为什么输出值跟预期值不一样</h4><p>我们先看一下StringBuilder的两个成员变量（这两个成员变量实际上是定义在AbstractStringBuilder里面的，StringBuilder和StringBuffer都继承了AbstractStringBuilder）</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储字符串的具体内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//已经使用的字符数组的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">count</span>;</span></pre></td></tr></table></figure>

<p>再看StringBuilder的append()方法：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">@Override</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> StringBuilder <span class="built_in">append</span>(<span class="keyword">String</span> <span class="built_in">str</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">super</span>.<span class="built_in">append</span>(<span class="built_in">str</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>StringBuilder的append()方法调用的父类AbstractStringBuilder的append()方法</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder append(String <span class="keyword">str</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">str</span> == <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> appendNull();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> len = <span class="keyword">str</span>.length();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ensureCapacityInternal(<span class="keyword">count</span> + len);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">str</span>.getChars(<span class="number">0</span>, len, value, <span class="keyword">count</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">count</span> += len;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们先不管代码的第五行和第六行干了什么，直接看第七行，count += len不是一个原子操作。假设这个时候count值为10，len值为1，两个线程同时执行到了第七行，拿到的count值都是10，执行完加法运算后将结果赋值给count，所以两个线程执行完后count值为11，而不是12。这就是为什么测试代码输出的值要比10000小的原因。</p>
<h4 id="2、为什么会抛出ArrayIndexOutOfBoundsException异常"><a href="#2、为什么会抛出ArrayIndexOutOfBoundsException异常" class="headerlink" title="2、为什么会抛出ArrayIndexOutOfBoundsException异常"></a>2、为什么会抛出ArrayIndexOutOfBoundsException异常</h4><p>我们看回AbstractStringBuilder的append()方法源码的第五行，ensureCapacityInternal()方法是检查StringBuilder对象的原char数组的容量能不能盛下新的字符串，如果盛不下就调用expandCapacity()方法对char数组进行扩容。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void ensure<span class="constructor">CapacityInternal(<span class="params">int</span> <span class="params">minimumCapacity</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// overflow-conscious code</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        expand<span class="constructor">Capacity(<span class="params">minimumCapacity</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>扩容的逻辑就是new一个新的char数组，新的char数组的容量是原来char数组的两倍再加2，再通过System.arryCopy()函数将原数组的内容复制到新数组，最后将指针指向新的char数组。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void expand<span class="constructor">Capacity(<span class="params">int</span> <span class="params">minimumCapacity</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//计算新的容量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">int</span> newCapacity = value.length<span class="operator"> * </span><span class="number">2</span> + <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//中间省略了一些检查逻辑</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    value = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>copy<span class="constructor">Of(<span class="params">value</span>, <span class="params">newCapacity</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Arrys.copyOf()方法</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">char</span>[] copyOf(<span class="built_in">char</span>[] original, <span class="built_in">int</span> newLength) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">char</span>[] <span class="built_in">copy</span> = <span class="keyword">new</span> <span class="built_in">char</span>[newLength];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//拷贝数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.arraycopy(original, <span class="number">0</span>, <span class="built_in">copy</span>, <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                         Math.<span class="built_in">min</span>(original.length, newLength));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">copy</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>AbstractStringBuilder的append()方法源码的第六行，是将String对象里面char数组里面的内容拷贝到StringBuilder对象的char数组里面，代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">str.get<span class="constructor">Chars(0, <span class="params">len</span>, <span class="params">value</span>, <span class="params">count</span>)</span>;</span></pre></td></tr></table></figure>

<p>getChars()方法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void get<span class="constructor">Chars(<span class="params">int</span> <span class="params">srcBegin</span>, <span class="params">int</span> <span class="params">srcEnd</span>, <span class="params">char</span> <span class="params">dst</span>[], <span class="params">int</span> <span class="params">dstBegin</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//中间省略了一些检查</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>拷贝流程见下图</p>
<p><img src="http://image.winrains.cn/2019/08/20190829104616-1d8a7.png" alt="img"></p>
<p>假设现在有两个线程同时执行了StringBuilder的append()方法，两个线程都执行完了第五行的ensureCapacityInternal()方法，此刻count=5。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829104616-ea5e7.png" alt="img"></p>
<p>这个时候线程1的cpu时间片用完了，线程2继续执行。线程2执行完整个append()方法后count变成6了</p>
<p><img src="http://image.winrains.cn/2019/08/20190829104617-849b5.png" alt="img"></p>
<p>线程1继续执行第六行的str.getChars()方法的时候拿到的count值就是6了，执行char数组拷贝的时候就会抛出ArrayIndexOutOfBoundsException异常。<br>至此，StringBuilder为什么不安全已经分析完了。如果我们将测试代码的StringBuilder对象换成StringBuffer对象会输出什么呢？</p>
<p><img src="http://image.winrains.cn/2019/08/20190829104618-6d57d.png" alt="img"></p>
<p>当然是输出10000啦！那么StringBuffer用什么手段保证线程安全的？这个问题你点进StringBuffer的append()方法里面就知道了。</p>
<blockquote>
<p>作者：千山qianshan</p>
<p>来源：<a href="https://juejin.im/post/5d6228046fb9a06add4e37fe" target="_blank" rel="noopener">https://juejin.im/post/5d6228046fb9a06add4e37fe</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解多线程（五）：Java虚拟机的锁优化技术</title>
    <url>/2019/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E9%94%81%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>本文是《<a href="http://www.hollischuang.com/archives/tag/深入理解多线程" target="_blank" rel="noopener">深入理解多线程</a>》的第五篇文章，前面几篇文章中我们从synchronized的实现原理开始，一直介绍到了Monitor的实现原理。</p>
<a id="more"></a>

<h3 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h3><p>通过前面几篇文章，我们已经知道：<br>1、同步方法通过<code>ACC_SYNCHRONIZED</code>关键字隐式的对方法进行加锁。当线程要执行的方法被标注上<code>ACC_SYNCHRONIZED</code>时，需要先获得锁才能执行该方法。《<a href="http://www.hollischuang.com/archives/1883" target="_blank" rel="noopener">深入理解多线程（一）——Synchronized的实现原理</a>》<br>2、同步代码块通过<code>monitorenter</code>和<code>monitorexit</code>执行来进行加锁。当线程执行到<code>monitorenter</code>的时候要先获得所锁，才能执行后面的方法。当线程执行到<code>monitorexit</code>的时候则要释放锁。《<a href="http://www.hollischuang.com/archives/2030" target="_blank" rel="noopener">深入理解多线程（四）—— Moniter的实现原理</a>》<br>3、在HotSpot虚拟机中，使用<strong>oop-klass模型</strong>来表示对象。每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个<code>instanceKlass</code>，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个<code>instanceOopDesc</code>对象，这个对象中包含了对象头以及实例数据。《<a href="http://www.hollischuang.com/archives/1910" target="_blank" rel="noopener">深入理解多线程（二）—— Java的对象模型</a>》<br>4、对象头中主要包含了GC分代年龄、锁状态标记、哈希码、epoch等信息。对象的状态一共有五种，分别是无锁态、轻量级锁、重量级锁、GC标记和偏向锁。《<a href="http://www.hollischuang.com/archives/1953" target="_blank" rel="noopener">深入理解多线程（三）—— Java的对象头</a>》<br><strong>在上一篇文章的最后，我们说过，事实上，只有在JDK1.6之前，<code>synchronized</code>的实现才会直接调用<code>ObjectMonitor</code>的<code>enter</code>和<code>exit</code>，这种锁被称之为重量级锁。</strong><br><strong>高效并发是从JDK 1.5 到 JDK 1.6的一个重要改进，HotSpot虚拟机开发团队在这个版本中花费了很大的精力去对Java中的锁进行优化，如适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等。这些技术都是为了在线程之间更高效的共享数据，以及解决竞争问题。</strong><br>本文，主要先来介绍一下自旋、锁消除以及锁粗化等技术。<br>这里简单说明一下，本文要介绍的这几个概念，以及后面要介绍的轻量级锁和偏向锁，其实对于使用他的开发者来说是屏蔽掉了的，也就是说，<strong>作为一个Java开发，你只需要知道你想在加锁的时候使用synchronized就可以了，具体的锁的优化是虚拟机根据竞争情况自行决定的。</strong><br>也就是说，在JDK 1.5 以后，我们即将介绍的这些概念，都被封装在synchronized中了。</p>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>要想把锁说清楚，一个重要的概念不得不提，那就是线程和线程的状态。锁和线程的关系是怎样的呢，举个简单的例子你就明白了。<br>比如，你今天要去银行办业务，你到了银行之后，要先取一个号，然后你坐在休息区等待叫号，过段时间，广播叫到你的号码之后，会告诉你去哪个柜台办理业务，这时，你拿着你手里的号码，去到对应的柜台，找相应的柜员开始办理业务。当你办理业务的时候，这个柜台和柜台后面的柜员只能为你自己服务。当你办完业务离开之后，广播再喊其他的顾客前来办理业务。<br><a href="http://image.winrains.cn/2019/08/f092d-Pic1.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/f092d-Pic1.png" alt="Pic1"></a></p>
<blockquote>
<p>这个例子中，每个顾客是一个<strong>线程</strong>。 柜台前面的那把椅子，就是<strong>锁</strong>。 柜台后面的柜员，就是<strong>共享资源</strong>。 你发现无法直接办理业务，要取号等待的过程叫做<strong>阻塞</strong>。 当你听到叫你的号码的时候，你起身去办业务，这就是<strong>唤醒</strong>。 当你坐在椅子上开始办理业务的时候，你就<strong>获得锁</strong>。 当你办完业务离开的时候，你就<strong>释放锁</strong>。</p>
</blockquote>
<p>对于线程来说，一共有五种状态，分别为：初始状态(New) 、就绪状态(Runnable) 、运行状态(Running) 、阻塞状态(Blocked) 和死亡状态(Dead) 。<br><a href="http://image.winrains.cn/2019/08/6d157-thread.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/6d157-thread.png" alt="thread"></a></p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>在<a href="http://www.hollischuang.com/archives/2030" target="_blank" rel="noopener">前一篇</a>文章中，我们介绍的<code>synchronized</code>的实现方式中使用<code>Monitor</code>进行加锁，这是一种互斥锁，为了表示他对性能的影响我们称之为重量级锁。<br>这种互斥锁在互斥同步上对性能的影响很大，Java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统的帮忙，这就要从用户态转换到内核态，因此状态转换需要花费很多的处理器时间。<br>就像去银行办业务的例子，当你来到银行，发现柜台前面都有人的时候，你需要取一个号，然后再去等待区等待，一直等待被叫号。这个过程是比较浪费时间的，那么有没有什么办法改进呢？<br>有一种比较好的设计，那就是银行提供自动取款机，当你去银行取款的时候，你不需要取号，不需要去休息区等待叫号，你只需要找到一台取款机，排在其他人后面等待取款就行了。<br><a href="http://image.winrains.cn/2019/08/1e69c-Pic2.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/1e69c-Pic2.png" alt="Pic2"></a><br>之所以能这样做，是因为取款的这个过程相比较之下是比较节省时间的。如果所有人去银行都只取款，或者办理业务的时间都很短的话，那也就可以不需要取号，不需要去单独的休息区，不需要听叫号，也不需要再跑到对应的柜台了。<br>而，在程序中，Java虚拟机的开发工程师们在分析过大量数据后发现：共享数据的锁定状态一般只会持续很短的一段时间，为了这段时间去挂起和恢复线程其实并不值得。<br>如果物理机上有多个处理器，可以让多个线程同时执行的话。我们就可以让后面来的线程“稍微等一下”，但是并不放弃处理器的执行时间，看看持有锁的线程会不会很快释放锁。这个“稍微等一下”的过程就是自旋。<br>自旋锁在JDK 1.4中已经引入，在JDK 1.6中默认开启。<br>很多人在对于自旋锁的概念不清楚的时候可能会有以下疑问：这么听上去，自旋锁好像和阻塞锁没啥区别，反正都是等着嘛。</p>
<ul>
<li>对于去银行取钱的你来说，站在取款机面前等待和去休息区等待叫号有一个很大的区别：<ul>
<li>那就是如果你在休息区等待，这段时间你什么都不需要管，随意做自己的事情，等着被唤醒就行了。</li>
<li>如果你在取款机面前等待，那么你需要时刻关注自己前面还有没有人，因为没人会唤醒你。</li>
<li>很明显，这种直接去取款机前面排队取款的效率是比较高。</li>
</ul>
</li>
</ul>
<p><strong>所以呢，自旋锁和阻塞锁最大的区别就是，到底要不要放弃处理器的执行时间。对于阻塞锁和自旋锁来说，都是要等待获得共享资源。但是阻塞锁是放弃了CPU时间，进入了等待区，等待被唤醒。而自旋锁是一直“自旋”在那里，时刻的检查共享资源是否可以被访问。</strong><br>由于自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。如果线程竞争不激烈，并且保持锁的时间段。适合使用自旋锁。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>除了自旋锁之后，JDK中还有一种锁的优化被称之为锁消除。还拿去银行取钱的例子说。<br>你去银行取钱，所有情况下都需要取号，并且等待吗？其实是不用的，当银行办理业务的人不多的时候，可能根本不需要取号，直接走到柜台前面办理业务就好了。<br><a href="http://image.winrains.cn/2019/08/21271-Pic3.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/21271-Pic3.png" alt="Pic3"></a><br>能这么做的前提是，没有人和你抢着办业务。<br>上面的这种例子，在锁优化中被称作“锁消除”，是JIT编译器对内部锁的具体实现所做的一种优化。<br>在动态编译同步块的时候，JIT编译器可以借助一种被称为逃逸分析（Escape Analysis）的技术来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。<br>如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。<br>如以下代码：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> f() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">Object</span> hollis = <span class="built_in">new</span> <span class="keyword">Object</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    synchronized(hollis) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(hollis);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>代码中对<code>hollis</code>这个对象进行加锁，但是<code>hollis</code>对象的生命周期只在<code>f()</code>方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。优化成：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> f() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">Object</span> hollis = <span class="built_in">new</span> <span class="keyword">Object</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(hollis);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>这里，可能有读者会质疑了，代码是程序员自己写的，程序员难道没有能力判断要不要加锁吗？就像以上代码，完全没必要加锁，有经验的开发者一眼就能看的出来的。其实道理是这样，但是还是有可能有疏忽，比如我们经常在代码中使用<code>StringBuffer</code>作为局部变量，而<code>StringBuffer</code>中的<code>append</code>是线程安全的，有<code>synchronized</code>修饰的，这种情况开发者可能会忽略。这时候，JIT就可以帮忙优化，进行锁消除。</p>
</blockquote>
<p>了解我的朋友都知道，一般到这个时候，我就会开始反编译，然后拿出反编译之后的代码来证明锁优化确实存在。<br>但是，之前很多例子之所以可以用反编译工具，是因为那些“优化”，如语法糖等，是在<code>javac编译</code>阶段发生的，并不是在<code>JIT编译</code>阶段发生的。而锁优化，是JIT编译器的功能，所以，无法使用现有的反编译工具查看具体的优化结果。（关于javac编译和JIT编译的关系和区别，我在我的知识星球中单独发了一篇文章介绍。）</p>
<blockquote>
<p>但是，如果读者感兴趣，还是可以看的，只是会复杂一点，首先你要自己build一个fasttest版本的jdk，然后在使用java命令对<code>.class</code>文件进行执行的时候加上<code>-XX:+PrintEliminateLocks</code>参数。而且jdk的模式还必须是server模式。</p>
</blockquote>
<p>总之，读者只需要知道，在使用<code>synchronized</code>的时候，如果JIT经过逃逸分析之后发现并无线程安全问题的话，就会做锁消除。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>很多人都知道，在代码中，需要加锁的时候，我们提倡尽量减小锁的粒度，这样可以避免不必要的阻塞。<br>这也是很多人原因是用同步代码块来代替同步方法的原因，因为往往他的粒度会更小一些，这其实是很有道理的。<br>还是我们去银行柜台办业务，最高效的方式是你坐在柜台前面的时候，只办和银行相关的事情。如果这个时候，你拿出手机，接打几个电话，问朋友要往哪个账户里面打钱，这就很浪费时间了。最好的做法肯定是提前准备好相关资料，在办理业务时直接办理就好了。<br><a href="http://image.winrains.cn/2019/08/de86f-Pic4.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/de86f-Pic4.png" alt="Pic4"></a><br>加锁也一样，把无关的准备工作放到锁外面，锁内部只处理和并发相关的内容。这样有助于提高效率。<br>那么，这和锁粗化有什么关系呢？可以说，大部分情况下，减小锁的粒度是很正确的做法，只有一种特殊的情况下，会发生一种叫做锁粗化的优化。<br>就像你去银行办业务，你为了减少每次办理业务的时间，你把要办的五个业务分成五次去办理，这反而适得其反了。因为这平白的增加了很多你重新取号、排队、被唤醒的时间。<br>如果在一段代码中连续的对同一个对象反复加锁解锁，其实是相对耗费资源的，这种情况可以适当放宽加锁的范围，减少性能消耗。<br>当JIT发现一系列连续的操作都对同一个对象反复加锁和解锁，甚至加锁操作出现在循环体中的时候，会将加锁同步的范围扩散（粗化）到整个操作序列的外部。<br>如以下代码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    synchronized(<span class="keyword">this</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">do</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>会被粗化成：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">synchronized(<span class="keyword">this</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">do</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>这其实和我们要求的减小锁粒度并不冲突。减小锁粒度强调的是不要在银行柜台前做准备工作以及和办理业务无关的事情。而锁粗化建议的是，同一个人，要办理多个业务的时候，可以在同一个窗口一次性办完，而不是多次取号多次办理。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>自Java 6/Java 7开始，Java虚拟机对内部锁的实现进行了一些优化。这些优化主要包括锁消除（Lock Elision）、锁粗化（Lock Coarsening）、偏向锁（Biased Locking）以及适应性自旋锁（Adaptive Locking）。这些优化仅在Java虚拟机server模式下起作用（即运行Java程序时我们可能需要在命令行中指定Java虚拟机参数“-server”以开启这些优化）。<br>本文主要介绍了自旋锁、锁粗化和锁消除的概念。在JIT编译过程中，虚拟机会根据情况使用这三种技术对锁进行优化，目的是减少锁的竞争，提升性能。</p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/2344" target="_blank" rel="noopener">https://www.hollischuang.com/archives/2344</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解多线程（四）：Monitor的实现原理</title>
    <url>/2019/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AMonitor%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>在<a href="http://www.hollischuang.com/archives/1883" target="_blank" rel="noopener">深入理解多线程（一）——Synchronized的实现原理</a>中介绍过关于<code>Synchronize</code>的实现原理，无论是同步方法还是同步代码块，无论是<code>ACC_SYNCHRONIZED</code>还是<code>monitorenter</code>、<code>monitorexit</code>都是基于<code>Monitor</code>实现的，那么这篇来介绍下什么是<strong>Monitor</strong>。</p>
<a id="more"></a>

<h3 id="操作系统中的管程"><a href="#操作系统中的管程" class="headerlink" title="操作系统中的管程"></a>操作系统中的管程</h3><p>如果你在大学学习过操作系统，你可能还记得管程（monitors）在操作系统中是很重要的概念。同样Monitor在java同步机制中也有使用。</p>
<blockquote>
<p>管程 (英语：Monitors，也称为监视器) 是一种程序结构，结构内的多个子程序（对象或模块）形成的多个工作线程互斥访问共享资源。这些共享资源一般是硬件设备或一群变量。管程实现了在一个时间点，最多只有一个线程在执行管程的某个子程序。与那些通过修改数据结构实现互斥访问的并发程序设计相比，管程实现很大程度上简化了程序设计。 管程提供了一种机制，线程可以临时放弃互斥访问，等待某些条件得到满足后，重新获得执行权恢复它的互斥访问。</p>
</blockquote>
<h3 id="Java线程同步相关的Monitor"><a href="#Java线程同步相关的Monitor" class="headerlink" title="Java线程同步相关的Monitor"></a>Java线程同步相关的Monitor</h3><p>在多线程访问共享资源的时候，经常会带来可见性和原子性的安全问题。为了解决这类线程安全的问题，Java提供了同步机制、互斥锁机制，这个机制保证了在同一时刻只有一个线程能访问共享资源。这个机制的保障来源于监视锁Monitor，每个对象都拥有自己的监视锁Monitor。<br>先来举个例子，然后我们在上源码。我们可以把监视器理解为包含一个特殊的房间的建筑物，这个特殊房间同一时刻只能有一个客人（线程）。这个房间中包含了一些数据和代码。<br><a href="http://image.winrains.cn/2019/08/df48a-Java-Monitor.jpg" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/df48a-Java-Monitor.jpg" alt="Java-Monitor"></a><br>如果一个顾客想要进入这个特殊的房间，他首先需要在走廊（Entry Set）排队等待。调度器将基于某个标准（比如 FIFO）来选择排队的客户进入房间。如果，因为某些原因，该客户客户暂时因为其他事情无法脱身（线程被挂起），那么他将被送到另外一间专门用来等待的房间（Wait Set），这个房间的可以可以在稍后再次进入那件特殊的房间。如上面所说，这个建筑屋中一共有三个场所。<br><a href="http://image.winrains.cn/2019/08/64de8-java-monitor-associate-with-object.jpg" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/64de8-java-monitor-associate-with-object.jpg" alt="java-monitor-associate-with-object"></a><br>总之，监视器是一个用来监视这些线程进入特殊的房间的。他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。<br>Monitor其实是一种同步工具，也可以说是一种同步机制，它通常被描述为一个对象，主要特点是：</p>
<blockquote>
<p>对象的所有方法都被“互斥”的执行。好比一个Monitor只有一个运行“许可”，任一个线程进入任何一个方法都需要获得这个“许可”，离开时把许可归还。<br>通常提供singal机制：允许正持有“许可”的线程暂时放弃“许可”，等待某个谓词成真（条件变量），而条件成立后，当前进程可以“通知”正在等待这个条件变量的线程，让他可以重新去获得运行许可。</p>
</blockquote>
<h3 id="监视器的实现"><a href="#监视器的实现" class="headerlink" title="监视器的实现"></a>监视器的实现</h3><p>在Java虚拟机(HotSpot)中，Monitor是基于C++实现的，由<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp" target="_blank" rel="noopener">ObjectMonitor</a>实现的，其主要数据结构如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">ObjectMonitor()</span> <span class="string">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_header</span>       <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_count</span>        <span class="string">=</span> <span class="number">0</span><span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_waiters</span>      <span class="string">=</span> <span class="number">0</span><span class="string">,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_recursions</span>   <span class="string">=</span> <span class="number">0</span><span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_object</span>       <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_owner</span>        <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_WaitSet</span>      <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_WaitSetLock</span>  <span class="string">=</span> <span class="number">0</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_Responsible</span>  <span class="string">=</span> <span class="literal">NULL</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_succ</span>         <span class="string">=</span> <span class="literal">NULL</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_cxq</span>          <span class="string">=</span> <span class="literal">NULL</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">FreeNext</span>      <span class="string">=</span> <span class="literal">NULL</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_EntryList</span>    <span class="string">=</span> <span class="literal">NULL</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_SpinFreq</span>     <span class="string">=</span> <span class="number">0</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_SpinClock</span>    <span class="string">=</span> <span class="number">0</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">OwnerIsThread</span> <span class="string">=</span> <span class="number">0</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">&#125;</span></span></pre></td></tr></table></figure>

<p>源码地址：<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.hpp#L193" target="_blank" rel="noopener">objectMonitor.hpp</a><br>ObjectMonitor中有几个关键属性：</p>
<blockquote>
<p>_owner：指向持有ObjectMonitor对象的线程<br>_WaitSet：存放处于wait状态的线程队列<br>_EntryList：存放处于等待锁block状态的线程队列<br>_recursions：锁的重入次数<br>_count：用来记录该线程获取锁的次数</p>
</blockquote>
<p>当多个线程同时访问一段同步代码时，首先会进入<code>_EntryList</code>队列中，当某个线程获取到对象的monitor后进入<code>_Owner</code>区域并把monitor中的<code>_owner</code>变量设置为当前线程，同时monitor中的计数器<code>_count</code>加1。即获得对象锁。<br>若持有monitor的线程调用<code>wait()</code>方法，将释放当前持有的monitor，<code>_owner</code>变量恢复为<code>null</code>，<code>_count</code>自减1，同时该线程进入<code>_WaitSet</code>集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示<br><a href="http://image.winrains.cn/2019/08/bd30d-monitor.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/bd30d-monitor.png" alt="monitor"></a><br>ObjectMonitor类中提供了几个方法：<br><strong>获得锁</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">void ATTR ObjectMonitor::enter(TRAPS) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Thread * <span class="keyword">const</span> <span class="keyword">Self</span> = THREAD ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void * cur ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//通过CAS尝试把monitor的`_owner`字段设置为当前线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cur = Atomic::cmpxchg_ptr (<span class="keyword">Self</span>, &amp;_owner, <span class="keyword">NULL</span>) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//获取锁失败</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (cur == <span class="keyword">NULL</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        assert (_recursions == <span class="number">0</span>   , <span class="string">"invariant"</span>) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        assert (_owner      == <span class="keyword">Self</span>, <span class="string">"invariant"</span>) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// CONSIDER: set or assert OwnerIsThread == 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果旧值和当前线程一样，说明当前线程已经持有锁，此次为重入，_recursions自增，并获得锁。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (cur == <span class="keyword">Self</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// TODO-<span class="doctag">FIXME:</span> check for integer overflow!  BUGID 6557169.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        _recursions ++ ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果当前线程是第一次进入该monitor，设置_recursions为1，_owner为当前线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">Self</span>-&gt;is_lock_owned ((address)cur)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        assert (_recursions == <span class="number">0</span>, <span class="string">"internal state error"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _recursions = <span class="number">1</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Commute owner from a thread-specific on-stack BasicLockObject address to</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// a full-fledged "Thread *".</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        _owner = <span class="keyword">Self</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        OwnerIsThread = <span class="number">1</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 省略部分代码。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 通过自旋执行ObjectMonitor::EnterI方法等待锁的释放</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (;;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        jt-&gt;set_suspend_equivalent();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// cleared by handle_special_suspend_equivalent_condition()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// or java_suspend_self()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        EnterI (THREAD) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!ExitSuspendEquivalent(jt)) <span class="keyword">break</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// We have acquired the contended monitor, but while we were</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// waiting another thread suspended us. We don't want to enter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// the monitor while suspended because that would surprise the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// thread that suspended us.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        _recursions = <span class="number">0</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _succ = <span class="keyword">NULL</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">exit</span> (<span class="keyword">Self</span>) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        jt-&gt;java_suspend_self();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><a href="http://image.winrains.cn/2019/08/b370f-lockenter.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/b370f-lockenter.png" alt="lockenter"></a><br>释放锁</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">void ATTR ObjectMonitor::<span class="keyword">exit</span>(TRAPS) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   Thread * Self = THREAD ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">//如果当前线程不是Monitor的所有者</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (THREAD != <span class="variable">_owner</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">if</span> (THREAD-&gt;is_lock_owned((address) <span class="variable">_owner</span>)) &#123; <span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// Transmute _owner from a BasicLock pointer to a Thread address.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// We don't need to hold _mutex for this transition.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// Non-null to Non-null is safe as long as all readers can</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// tolerate either flavor.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="built_in">assert</span> (<span class="variable">_recursions</span> == <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="variable">_owner</span> = THREAD ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="variable">_recursions</span> = <span class="number">0</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       OwnerIsThread = <span class="number">1</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// <span class="doctag">NOTE:</span> we need to handle unbalanced monitor enter/exit</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// in native code by throwing an exception.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// <span class="doctag">TODO:</span> Throw an IllegalMonitorStateException ?</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       TEVENT (<span class="keyword">Exit</span> - <span class="keyword">Throw</span> IMSX) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="built_in">assert</span>(<span class="literal">false</span>, <span class="string">"Non-balanced monitor enter/exit!"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">THROW</span>(vmSymbols::java_lang_IllegalMonitorStateException());</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       return;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果_recursions次数不为0.自减</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (<span class="variable">_recursions</span> != <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="variable">_recursions</span>--;        <span class="comment">// this is simple recursive enter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     TEVENT (Inflated <span class="keyword">exit</span> - recursive) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     return ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">//省略部分代码，根据不同的策略（由QMode指定），从cxq或EntryList中获取头节点，通过ObjectMonitor::ExitEpilog方法唤醒该节点封装的线程，唤醒操作最终由unpark完成。</span></span></pre></td></tr></table></figure>

<p><a href="http://image.winrains.cn/2019/08/ce586-lockexit.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/ce586-lockexit.png" alt="lockexit"></a><br>除了enter和exit方法以外，<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp" target="_blank" rel="noopener">objectMonitor.cpp</a>中还有</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>      <span class="title">wait</span><span class="params">(jlong <span class="built_in">millis</span>, <span class="keyword">bool</span> interruptable, TRAPS)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>      <span class="title">notify</span><span class="params">(TRAPS)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>      <span class="title">notifyAll</span><span class="params">(TRAPS)</span></span>;</span></pre></td></tr></table></figure>

<p>等方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面介绍的就是HotSpot虚拟机中Monitor的的加锁以及解锁的原理。<br>通过这篇文章我们知道了<code>sychronized</code>加锁的时候，会调用objectMonitor的<code>enter</code>方法，解锁的时候会调用<code>exit</code>方法。事实上，只有在JDK1.6之前，<code>synchronized</code>的实现才会直接调用ObjectMonitor的<code>enter</code>和<code>exit</code>，这种锁被称之为重量级锁。为什么说这种方式操作锁很重呢？</p>
<ul>
<li>Java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统的帮忙，这就要从用户态转换到核心态，因此状态转换需要花费很多的处理器时间，对于代码简单的同步块（如被<code>synchronized</code>修饰的<code>get</code> 或<code>set</code>方法）状态转换消耗的时间有可能比用户代码执行的时间还要长，所以说<code>synchronized</code>是java语言中一个重量级的操纵。</li>
</ul>
<p>所以，在JDK1.6中出现对锁进行了很多的优化，进而出现轻量级锁，偏向锁，锁消除，适应性自旋锁，锁粗化(自旋锁在1.4就有 只不过默认的是关闭的，jdk1.6是默认开启的)，这些操作都是为了在线程之间更高效的共享数据 ，解决竞争问题。后面的文章会继续介绍这几种锁以及他们之间的关系。<br><a href="http://bigdatadecode.club/JavaSynchronizedTheory.html" target="_blank" rel="noopener">Java Synchronized实现原理</a><br><a href="http://www.jianshu.com/p/f4454164c017" target="_blank" rel="noopener">JVM源码分析之Object.wait/notify实现</a><br><a href="http://blog.csdn.net/penngrove/article/details/44175387" target="_blank" rel="noopener">Linux Kernel CMPXCHG函数分析</a><br><a href="https://www.cnblogs.com/kundeg/p/8422557.html" target="_blank" rel="noopener">从jvm源码看synchronized</a></p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/2030" target="_blank" rel="noopener">https://www.hollischuang.com/archives/2030</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解多线程（三）：Java的对象头</title>
    <url>/2019/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AJava%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%A4%B4/</url>
    <content><![CDATA[<p><a href="http://www.hollischuang.com/archives/1910" target="_blank" rel="noopener">上一篇</a>文章中我们从HotSpot的源码入手，介绍了Java的对象模型。这一篇文章在上一篇文章的基础上再来介绍一下Java的对象头。主要介绍一下对象头的作用，结构以及他和锁的关系。</p>
<a id="more"></a>

<h3 id="Java对象模型回顾与勘误"><a href="#Java对象模型回顾与勘误" class="headerlink" title="Java对象模型回顾与勘误"></a>Java对象模型回顾与勘误</h3><p>在上一篇文章中，关于对象头的部分描述有误，我已经在我博客的文章中就行修正 。这里再重新表述一下。<br>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个<code>instanceKlass</code>，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个<code>instanceOopDesc</code>对象，这个对象中包含了对象头以及实例数据。<br>这里提到的对象头到底是什么呢？</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">oopDesc</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  friend <span class="class"><span class="keyword">class</span> <span class="title">VMStructs</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="symbol">private:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  volatile markOop  _mark;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">_metadata</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    wideKlassOop    _klass;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    narrowOop       _compressed_klass;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125; _metadata;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面代码中的<code>_mark</code>和<code>_metadata</code>其实就是对象头的定义。关于<code>_metadata</code>之前就介绍过，这里不再赘述。由于这个专题主要想介绍和JAVA并发相关的知识，所以本文展开介绍一下<code>_mark</code> ，即mark word。<br>对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。<br>对markword的设计方式上，非常像网络协议报文头：将mark word划分为多个比特位区间，并在不同的对象状态下赋予比特位不同的含义。下图描述了在32位虚拟机上，在对象不同状态时 mark word各个比特位区间的含义。<br><img src="http://image.winrains.cn/2019/08/acec7-ObjectHead-1024x329.png" alt="ObjectHead"><br>同样，在HotSpot的源码中我们可以找到关于对象头对象的定义，会一一印证上图的描述。对应与<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/markOop.hpp" target="_blank" rel="noopener">markOop.hpp</a>类。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; age_bits                 = <span class="number">4</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      lock_bits                = <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      biased_lock_bits         = <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      max_hash_bits            = BitsPerWord - age_bits - lock_bits - biased_lock_bits,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      hash_bits                = max_hash_bits &gt; <span class="number">31</span> ? <span class="number">31</span> : max_hash_bits,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      cms_bits                 = LP64_ONLY(<span class="number">1</span>) NOT_LP64(<span class="number">0</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      epoch_bits               = <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>从上面的枚举定义中可以看出，对象头中主要包含了GC分代年龄、锁状态标记、哈希码、epoch等信息。<br>从上图中可以看出，对象的状态一共有五种，分别是无锁态、轻量级锁、重量级锁、GC标记和偏向锁。在32位的虚拟机中有两个Bits是用来存储锁的标记为的，但是我们都知道，两个bits最多只能表示四种状态：00、01、10、11，那么第五种状态如何表示呢 ，就要额外依赖1Bit的空间，使用0和1来区分。</p>
<blockquote>
<p>在32位的HotSpot虚拟机 中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码(HashCode)，4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，表示非偏向锁。</p>
</blockquote>
<p><a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/markOop.hpp" target="_blank" rel="noopener">markOop.hpp</a>类中有关于对象状态的定义：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; locked_value             = <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       unlocked_value           = <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       monitor_value            = <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       marked_value             = <span class="number">3</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       biased_lock_pattern      = <span class="number">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>简单翻译一下：</p>
<blockquote>
<p>locked_value(00) = 0<br>unlocked_value(01) = 1<br>monitor_value(10) = 2<br>marked_value(11) = 3<br>biased_lock_pattern(101) = 5</p>
</blockquote>
<p>关于为什么要定义这么多状态，上面提到的轻量级锁、重量级锁、偏向锁以及他们之前的关系，会在下一篇文章中重点阐述，敬请期待。</p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/1953" target="_blank" rel="noopener">https://www.hollischuang.com/archives/1953</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解多线程（二）：Java的对象模型</title>
    <url>/2019/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AJava%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p><a href="http://www.hollischuang.com/archives/1883" target="_blank" rel="noopener">上一篇</a>文章中简单介绍过<code>synchronized</code>关键字的方式，其中，同步代码块使用<code>monitorenter</code>和<code>monitorexit</code>两个指令实现，同步方法使用<code>ACC_SYNCHRONIZED</code>标记符实现。后面几篇文章会从JVM源码的角度更加深入，层层剥开<code>synchronized</code>的面纱。在进入正题之前，肯定有些基础知识需要铺垫，那么先来看一下一个容易被忽略的但是又很重要的知识点 —— Java对象模型 。<br>大家都知道的是，Java对象保存在堆内存中。在内存中，一个Java对象包含三部分：对象头、实例数据和对齐填充。其中对象头是一个很关键的部分，因为<strong>对象头中包含锁状态标志、线程持有的锁等标志</strong>。这篇文章就主要从Java对象模型入手，找一找我们关系的对象头以及对象头中和锁相关的运行时数据在JVM中是如何表示的。</p>
<a id="more"></a>

<h3 id="Java的对象模型"><a href="#Java的对象模型" class="headerlink" title="Java的对象模型"></a>Java的对象模型</h3><p>任何一个接触过Java的人都知道，Java是一种面向对象语言。在学习Java的过程中你一定对下面两句话不陌生：</p>
<ul>
<li>1、在面向对象的软件中，对象（Object）是某一个类（Class）的实例。 <a href="https://zh.wikipedia.org/wiki/对象_(计算机科学)" target="_blank" rel="noopener">维基百科</a></li>
<li>2、一切皆对象 <a href="https://book.douban.com/subject/1474824/" target="_blank" rel="noopener">Thinking In Java</a></li>
</ul>
<p>我们还知道，在JVM的内存结构中，对象保存在堆内存中，而我们在对对象进行操作时，其实操作的是对象的引用。那么对象本身在JVM中的结构是什么样的呢？本文的所有分析均基于<a href="https://github.com/openjdk-mirror/jdk7u-hotspot" target="_blank" rel="noopener">HotSpot</a>虚拟机。</p>
<h3 id="oop-klass-model"><a href="#oop-klass-model" class="headerlink" title="oop-klass model"></a>oop-klass model</h3><p>HotSpot是基于c++实现，而c++是一门面向对象的语言，本身是具备面向对象基本特征的，所以Java中的对象表示，最简单的做法是为每个Java类生成一个c++类与之对应。但HotSpot JVM并没有这么做，而是设计了一个<code>OOP-Klass Model</code>。OOP（<code>Ordinary Object Pointer</code>）指的是普通对象指针，而<code>Klass</code>用来描述对象实例的具体类型。<br>为什么HotSpot要设计一套<code>oop-klass model</code>呢？答案是：HotSopt JVM的设计者不想让每个对象中都含有一个<code>vtable</code>（虚函数表）<br>这个解释似乎可以说得通。众所周知，C++和Java都是面向对象的语言，面向对象语言有一个很重要的特性就是多态。关于多态的实现，C++和Java有着本质的区别。</p>
<blockquote>
<p>多态是面向对象的最主要的特性之一，是一种方法的动态绑定，实现运行时的类型决定对象的行为。多态的表现形式是父类指针或引用指向子类对象，在这个指针上调用的方法使用子类的实现版本。多态是IOC、模板模式实现的关键。</p>
<blockquote>
<p>在C++中通过虚函数表的方式实现多态，每个包含虚函数的类都具有一个虚函数表（virtual table），在这个类对象的地址空间的最靠前的位置存有指向虚函数表的指针。在虚函数表中，按照声明顺序依次排列所有的虚函数。由于C++在运行时并不维护类型信息，所以在编译时直接在子类的虚函数表中将被子类重写的方法替换掉。<br>在Java中，在运行时会维持类型信息以及类的继承体系。每一个类会在方法区中对应一个数据结构用于存放类的信息，可以通过Class对象访问这个数据结构。其中，类型信息具有superclass属性指示了其超类，以及这个类对应的方法表（其中只包含这个类定义的方法，不包括从超类继承来的）。而每一个在堆上创建的对象，都具有一个指向方法区类型信息数据结构的指针，通过这个指针可以确定对象的类型。</p>
</blockquote>
</blockquote>
<p>上面这段是我从网上摘取过来的，说的有一定道理，但是也不全对。至于为啥，我会在后文介绍到Klass的时候细说。<br>关于opp-klass模型的整体定义，在HotSpot的<a href="https://github.com/openjdk-mirror/jdk7u-hotspot" target="_blank" rel="noopener">源码</a>中可以找到。<br>oops模块可以分成两个相对独立的部分：OOP框架和Klass框架。<br>在<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/oopsHierarchy.hpp" target="_blank" rel="noopener">oopsHierarchy.hpp</a>里定义了oop和klass各自的体系。</p>
<h3 id="oop-klass结构"><a href="#oop-klass结构" class="headerlink" title="oop-klass结构"></a>oop-klass结构</h3><p><a href="http://image.winrains.cn/2019/08/d99a2-oops.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/d99a2-oops.png" alt="oops"></a><br>oop体系：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义了oops共同基类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">oopDesc</span>*                            <span class="title">oop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示一个Java类型实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">instanceOopDesc</span>*            <span class="title">instanceOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示一个Java方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">methodOopDesc</span>*                    <span class="title">methodOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示一个Java方法中的不变信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">constMethodOopDesc</span>*            <span class="title">constMethodOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//记录性能信息的数据结构</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">methodDataOopDesc</span>*            <span class="title">methodDataOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//定义了数组OOPS的抽象基类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">arrayOopDesc</span>*                    <span class="title">arrayOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示持有一个OOPS数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">objArrayOopDesc</span>*            <span class="title">objArrayOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示容纳基本类型的数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">typeArrayOopDesc</span>*            <span class="title">typeArrayOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示在Class文件中描述的常量池</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">constantPoolOopDesc</span>*            <span class="title">constantPoolOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//常量池告诉缓存</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">constantPoolCacheOopDesc</span>*   <span class="title">constantPoolCacheOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//描述一个与Java类对等的C++类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">klassOopDesc</span>*                    <span class="title">klassOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示对象头</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">markOopDesc</span>*                    <span class="title">markOop</span>;</span></span></pre></td></tr></table></figure>

<p><strong>上面列出的是整个Oops模块的组成结构，其中包含多个子模块。每一个子模块对应一个类型，每一个类型的OOP都代表一个在JVM内部使用的特定对象的类型。</strong><br>从上面的代码中可以看到，有一个变量opp的类型是<code>oppDesc</code> ，OOPS类的共同基类型为<code>oopDesc</code>。<br><strong>在Java程序运行过程中，每创建一个新的对象，在JVM内部就会相应地创建一个对应类型的OOP对象。</strong>在HotSpot中，根据JVM内部使用的对象业务类型，具有多种<code>oopDesc</code>的子类。除了<code>oppDesc</code>类型外，opp体系中还有很多<code>instanceOopDesc</code>、<code>arrayOopDesc</code> 等类型的实例，他们都是<code>oopDesc</code>的子类。<br><a href="http://image.winrains.cn/2019/08/c4110-OOP结构.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/c4110-OOP%E7%BB%93%E6%9E%84.png" alt="OOP结构"></a><br>这些OOPS在JVM内部有着不同的用途，例如<strong>，<code>instanceOopDesc</code>表示类实例，<code>arrayOopDesc</code>表示数组。</strong>也就是说，<strong>当我们使用<code>new</code>创建一个Java对象实例的时候，JVM会创建一个<code>instanceOopDesc</code>对象来表示这个Java对象。同理，当我们使用<code>new</code>创建一个Java数组实例的时候，JVM会创建一个<code>arrayOopDesc</code>对象来表示这个数组对象。</strong><br>在HotSpot中，oopDesc类定义在<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/oop.hpp" target="_blank" rel="noopener">oop.hpp</a>中，instanceOopDesc定义在<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/instanceOop.hpp" target="_blank" rel="noopener">instanceOop.hpp</a>中，arrayOopDesc定义在<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/arrayOop.hpp" target="_blank" rel="noopener">arrayOop.hpp</a>中。<br>简单看一下相关定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">oopDesc</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VMStructs</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">volatile</span> markOop  _mark;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">union</span> _metadata &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wideKlassOop    _klass;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        narrowOop       _compressed_klass;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; _metadata;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// field addresses in oop</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">void</span>*     <span class="title">field_base</span><span class="params">(<span class="keyword">int</span> offset)</span>        <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jbyte*    <span class="title">byte_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span>   <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jchar*    <span class="title">char_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span>   <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jboolean* <span class="title">bool_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span>   <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jint*     <span class="title">int_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span>    <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jshort*   <span class="title">short_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span>  <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jlong*    <span class="title">long_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span>   <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jfloat*   <span class="title">float_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span>  <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jdouble*  <span class="title">double_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">address*  <span class="title">address_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">instanceOopDesc</span> :</span> <span class="keyword">public</span> oopDesc &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arrayOopDesc</span> :</span> <span class="keyword">public</span> oopDesc &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过上面的源码可以看到，<code>instanceOopDesc</code>实际上就是继承了<code>oopDesc</code>，并没有增加其他的数据结构，也就是说<code>instanceOopDesc</code>中主要包含以下几部分数据：<code>markOop  _mark</code>和<code>union _metadata</code> 以及一些不同类型的 <code>field</code>。<br>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头、实例数据和对齐填充。在虚拟机内部，一个Java对象对应一个<code>instanceOopDesc</code>的对象。其中对象头包含了两部分内容：<code>_mark</code>和<code>_metadata</code>，而实例数据则保存在oopDesc中定义的各种field中。</p>
<h4 id="mark"><a href="#mark" class="headerlink" title="_mark"></a>_mark</h4><p>文章开头我们就说过，之所以我们要写这篇文章，是因为对象头中有和锁相关的运行时数据，这些运行时数据是<code>synchronized</code>以及其他类型的锁实现的重要基础，而关于锁标记、GC分代等信息均保存在<code>_mark</code>中。因为本文主要介绍的<code>oop-klass</code>模型，在这里暂时不对对象头做展开，下一篇文章介绍。</p>
<h4 id="metadata"><a href="#metadata" class="headerlink" title="_metadata"></a>_metadata</h4><p>前面介绍到的<code>_metadata</code>是一个共用体，其中<code>_klass</code>是普通指针，<code>_compressed_klass</code>是压缩类指针。在深入介绍之前，就要来到<code>oop-Klass</code>中的另外一个主角<code>klass</code>了。</p>
<h3 id="klass"><a href="#klass" class="headerlink" title="klass"></a>klass</h3><p>klass体系</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//klassOop的一部分，用来描述语言层的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Klass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//在虚拟机层面描述一个Java类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">instanceKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//专有instantKlass，表示java.lang.Class的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>     <span class="title">instanceMirrorKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//专有instantKlass，表示java.lang.ref.Reference的子类的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>     <span class="title">instanceRefKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示methodOop的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">methodKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示constMethodOop的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">constMethodKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示methodDataOop的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">methodDataKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//最为klass链的端点，klassKlass的Klass就是它自身</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">klassKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示instanceKlass的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>     <span class="title">instanceKlassKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示arrayKlass的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>     <span class="title">arrayKlassKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示objArrayKlass的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>       <span class="title">objArrayKlassKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示typeArrayKlass的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>       <span class="title">typeArrayKlassKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示array类型的抽象基类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">arrayKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示objArrayOop的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>     <span class="title">objArrayKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示typeArrayOop的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>     <span class="title">typeArrayKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示constantPoolOop的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">constantPoolKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示constantPoolCacheOop的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">constantPoolCacheKlass</span>;</span></span></pre></td></tr></table></figure>

<p>和<code>oopDesc</code>是其他oop类型的父类一样，Klass类是其他klass类型的父类。<br><a href="http://image.winrains.cn/2019/08/527b3-klass.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/527b3-klass.png" alt="klass"></a><br>Klass向JVM提供两个功能：</p>
<ul>
<li>实现语言层面的Java类（在Klass基类中已经实现）</li>
<li>实现Java对象的分发功能（由Klass的子类提供虚函数实现）</li>
</ul>
<p>文章开头的时候说过：之所以设计<code>oop-klass</code>模型，是因为HotSopt JVM的设计者不想让每个对象中都含有一个虚函数表。<br>HotSopt JVM的设计者把对象一拆为二，分为<code>klass</code>和<code>oop</code>，其中<code>oop</code>的职能主要在于表示对象的实例数据，所以其中不含有任何虚函数。而klass为了实现虚函数多态，所以提供了虚函数表。所以，关于Java的多态，其实也有虚函数的影子在。<br><code>_metadata</code>是一个共用体，其中<code>_klass</code>是普通指针，<code>_compressed_klass</code>是压缩类指针。这两个指针都指向<code>instanceKlass</code>对象，它用来描述对象的具体类型。</p>
<h3 id="instanceKlass"><a href="#instanceKlass" class="headerlink" title="instanceKlass"></a>instanceKlass</h3><p>JVM在运行时，需要一种用来标识Java内部类型的机制。在HotSpot中的解决方案是：为每一个已加载的Java类创建一个<code>instanceKlass</code>对象，用来在JVM层表示Java类。<br>来看下<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/instanceKlass.hpp" target="_blank" rel="noopener">instanceKlass</a>的内部结构：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类拥有的方法列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">objArrayOop     <span class="variable">_methods</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//描述方法顺序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">typeArrayOop    <span class="variable">_method_ordering</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//实现的接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">objArrayOop     <span class="variable">_local_interfaces</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//继承的接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">objArrayOop     <span class="variable">_transitive_interfaces</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//域</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">typeArrayOop    <span class="variable">_fields</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//常量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">constantPoolOop <span class="variable">_constants</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//类加载器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">oop             <span class="variable">_class_loader</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//protected域</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">oop             <span class="variable">_protection_domain</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ....</span></pre></td></tr></table></figure>

<p>可以看到，一个类该具有的东西，这里面基本都包含了。<br>这里还有个点需要简单介绍一下。<br>在JVM中，对象在内存中的基本存在形式就是oop。那么，对象所属的类，在JVM中也是一种对象，因此它们实际上也会被组织成一种oop，即klassOop。同样的，对于klassOop，也有对应的一个klass来描述，它就是klassKlass，也是klass的一个子类。klassKlass作为oop的klass链的端点。关于对象和数组的klass链大致如下图：<br><a href="http://image.winrains.cn/2019/08/e6430-400_ac3_932.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/e6430-400_ac3_932.png" alt="400_ac3_932"></a><br>在这种设计下，JVM对内存的分配和回收，都可以采用统一的方式来管理。oop-klass-klassKlass关系如图：<br><a href="http://image.winrains.cn/2019/08/ce592-2579123-5b117a7c06e83d84.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/ce592-2579123-5b117a7c06e83d84.png" alt="2579123-5b117a7c06e83d84"></a></p>
<h3 id="内存存储"><a href="#内存存储" class="headerlink" title="内存存储"></a>内存存储</h3><p>关于一个Java对象，他的存储是怎样的，一般很多人会回答：对象存储在堆上。稍微好一点的人会回答：对象存储在堆上，对象的引用存储在栈上。今天，再给你一个更加显得牛逼的回答：</p>
<blockquote>
<p>对象的实例（instantOopDesc)保存在堆上，对象的元数据（instantKlass）保存在方法区，对象的引用保存在栈上。</p>
</blockquote>
<p>其实如果细追究的话，上面这句话有点故意卖弄的意思。因为我们都知道。<strong>方法区用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong> 所谓加载的类信息，其实不就是给每一个被加载的类都创建了一个 instantKlass对象么。<br>talk is cheap ,show me the code ：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Model</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.b = b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> c = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Model modelA = <span class="keyword">new</span> Model(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Model modelB = <span class="keyword">new</span> Model(<span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>存储结构如下：<br><a href="http://image.winrains.cn/2019/08/e3b37-20170615230126453.jpeg" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/e3b37-20170615230126453.jpeg" alt="20170615230126453"></a><br>从上图中可以看到，在方法区的instantKlass中有一个<code>int a=1</code>的数据存储。在堆内存中的两个对象的oop中，分别维护着<code>int b=3</code>,<code>int b=2</code>的实例数据。和oopDesc一样，instantKlass也维护着一些<code>fields</code>，用来保存类中定义的类数据，比如<code>int a=1</code>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个<code>instanceKlass</code>，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个<code>instanceOopDesc</code>对象，这个对象中包含了两部分信息，对象头以及元数据。对象头中有一些运行时数据，其中就包括和多线程相关的锁的信息。元数据其实维护的是指针，指向的是对象所属的类的<code>instanceKlass</code>。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://blog.csdn.net/linxdcn/article/details/73287490" target="_blank" rel="noopener">【理解HotSpot虚拟机】对象在jvm中的表示：OOP-Klass模型</a><br><a href="http://www.jianshu.com/p/b6cb4c694951" target="_blank" rel="noopener">Java反射: 从JDK到JVM全链路详解</a><br><a href="http://www.voidcn.com/article/p-pzznrtkc-ez.html" target="_blank" rel="noopener">HotSpotVM 对象机制实现浅析#1</a><br><a href="https://book.douban.com/subject/25847620/" target="_blank" rel="noopener">HotSpot实战</a></p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/1910" target="_blank" rel="noopener">https://www.hollischuang.com/archives/1910</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解多线程（一）：Synchronized的实现原理</title>
    <url>/2019/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ASynchronized%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><code>synchronized</code>，是Java中用于解决并发情况下数据同步访问的一个很重要的关键字。当我们想要保证一个共享资源在同一时间只会被一个线程访问到时，我们可以在代码中使用<code>synchronized</code>关键字对类或者对象加锁。那么，本文来介绍一下<code>synchronized</code>关键字的实现原理是什么。在阅读本文之间，建议先看下<a href="http://www.hollischuang.com/archives/1876" target="_blank" rel="noopener">Java虚拟机是如何执行线程同步的</a> 。</p>
<a id="more"></a>

<h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><p>众所周知，在Java中，<code>synchronized</code>有两种使用形式，同步方法和同步代码块。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hollis 17/11/9.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth1</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">synchronized</span> (SynchronizedTest<span class="class">.<span class="keyword">class</span>)</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.println(<span class="string">"Hello World"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们先来使用<a href="http://www.hollischuang.com/archives/1107" target="_blank" rel="noopener">Javap</a>来反编译以上代码，结果如下（部分无用信息过滤掉了）：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> synchronized <span class="built_in">void</span> doSth();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  descriptor: ()V</span></pre></td></tr><tr><td class="code"><pre><span class="line">  flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Code:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String Hello World</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> doSth1();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  descriptor: ()V</span></pre></td></tr><tr><td class="code"><pre><span class="line">  flags: ACC_PUBLIC</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Code:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">0</span>: ldc           #<span class="number">5</span>                  <span class="comment">// class com/hollis/SynchronizedTest</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">2</span>: dup</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">3</span>: astore_1</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">4</span>: monitorenter</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">5</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">8</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String Hello World</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">10</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">13</span>: aload_1</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">14</span>: monitorexit</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">15</span>: goto          <span class="number">23</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">18</span>: astore_2</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">19</span>: aload_1</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">20</span>: monitorexit</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">21</span>: aload_2</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">22</span>: athrow</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">23</span>: <span class="keyword">return</span></span></pre></td></tr></table></figure>

<p><a href="http://www.hollischuang.com/archives/58" target="_blank" rel="noopener">反编译</a>后，我们可以看到Java编译器为我们生成的字节码。在对于<code>doSth</code>和<code>doSth1</code>的处理上稍有不同。也就是说。JVM对于同步方法和同步代码块的处理方式不同。<br>对于同步方法，JVM采用<code>ACC_SYNCHRONIZED</code>标记符来实现同步。 对于同步代码块。JVM采用<code>monitorenter</code>、<code>monitorexit</code>两个指令来实现同步。<br>关于这部分内容，在<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.14" target="_blank" rel="noopener">JVM规范</a>中也可以找到相关的描述。</p>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10" target="_blank" rel="noopener">The Java® Virtual Machine Specification</a>中有关于方法级同步的介绍：</p>
<blockquote>
<p>Method-level synchronization is performed implicitly, as part of method invocation and return. A synchronized method is distinguished in the run-time constant pool’s method_info structure by the ACC_SYNCHRONIZED flag, which is checked by the method invocation instructions. When invoking a method for which ACC_SYNCHRONIZED is set, the executing thread enters a monitor, invokes the method itself, and exits the monitor whether the method invocation completes normally or abruptly. During the time the executing thread owns the monitor, no other thread may enter it. If an exception is thrown during invocation of the synchronized method and the synchronized method does not handle the exception, the monitor for the method is automatically exited before the exception is rethrown out of the synchronized method.</p>
</blockquote>
<p>主要说的是： 方法级的同步是隐式的。同步方法的常量池中会有一个<code>ACC_SYNCHRONIZED</code>标志。当某个线程要访问某个方法的时候，会检查是否有<code>ACC_SYNCHRONIZED</code>，如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁。这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。</p>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>同步代码块使用<code>monitorenter</code>和<code>monitorexit</code>两个指令实现。 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html" target="_blank" rel="noopener">The Java® Virtual Machine Specification</a> 中有关于这两个指令的介绍：</p>
<h4 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h4><blockquote>
<p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:</p>
<blockquote>
<p>If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.<br>If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.<br>If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.</p>
</blockquote>
</blockquote>
<h4 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h4><blockquote>
<p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.<br>The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p>
</blockquote>
<p>大致内容如下： 可以把执行<code>monitorenter</code>指令理解为加锁，执行<code>monitorexit</code>理解为释放锁。 每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁（执行<code>monitorenter</code>）后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁（执行<code>monitorexit</code>指令）的时候，计数器再自减。当计数器为0的时候。锁将被释放，其他线程便可以获得锁。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>同步方法通过<code>ACC_SYNCHRONIZED</code>关键字隐式的对方法进行加锁。当线程要执行的方法被标注上<code>ACC_SYNCHRONIZED</code>时，需要先获得锁才能执行该方法。<br>同步代码块通过<code>monitorenter</code>和<code>monitorexit</code>执行来进行加锁。当线程执行到<code>monitorenter</code>的时候要先获得所锁，才能执行后面的方法。当线程执行到<code>monitorexit</code>的时候则要释放锁。<br>每个对象自身维护这一个被加锁次数的计数器，当计数器数字为0时表示可以被任意线程获得锁。当计数器不为0时，只有获得锁的线程才能再次获得锁。即可重入锁。</p>
</blockquote>
<p>至此，我们大致了解了Synchronized的原理。但是还有几个问题并没有介绍清楚，比如，Monitor到底是什么？对象的锁的状态保存在哪里？ 别急，后面会再介绍。</p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/1883" target="_blank" rel="noopener">https://www.hollischuang.com/archives/1883</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>Synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>同步容器Vector并不是所有操作都线程安全</title>
    <url>/2019/12/26/%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8Vector%E5%B9%B6%E4%B8%8D%E6%98%AF%E6%89%80%E6%9C%89%E6%93%8D%E4%BD%9C%E9%83%BD%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h3 id="问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？"><a href="#问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？" class="headerlink" title="问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？"></a><strong>问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？</strong></h3><p><strong>答：同步容器中的所有自带方法都是线程安全的，因为方法都使用<code>synchronized</code>关键字标注。但是，对这些集合类的复合操作无法保证其线程安全性。需要客户端通过主动加锁来保证</strong><br>如果你看过JDK的源码，那么你会发现，像Vector这样的同步容器的所有共有方法全都是<code>synchronized</code>的。也就是说，我们可以在多线程场景中放心的使用<strong>单独</strong>这些方法，因为这些方法本身的确是线程安全的。那么为什么又说复合操作无法保证线程安全呢？这里举个栗子，我们定义如下删除Vector中最后一个元素方法：</p>
<a id="more"></a>

<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">deleteLast</span><span class="params">(Vector v)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> lastIndex  = v.<span class="built_in">size</span>()<span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    v.<span class="built_in">remove</span>(lastIndex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面这个方法是一个复合方法，包括<code>size(）</code>和<code>remove()</code>，乍一看上去好像并没有什么问题，无论是<code>size()</code>方法还是<code>remove()</code>方法都是线程安全的，那么整个<code>deleteLast</code>方法应该也是线程安全的。但是时，如果多线程调用该方法的过程中有，<code>remove</code>方法有可能抛出<code>ArrayIndexOutOfBoundsException</code>。我们看一下<code>remove</code>方法具体实现，什么情况下会抛出这个异常呢。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> synchronized E remove(<span class="keyword">int</span> <span class="keyword">index</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    modCount++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">index</span> &gt;= elementCount)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="keyword">index</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    E oldValue = elementData(<span class="keyword">index</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> numMoved = elementCount - <span class="keyword">index</span> - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.arraycopy(elementData, <span class="keyword">index</span>+<span class="number">1</span>, elementData, <span class="keyword">index</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                         numMoved);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> oldValue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>从上面代码中可以看出，当<code>index &gt;= elementCount</code>时，会抛出<code>ArrayIndexOutOfBoundsException</code>，也就是说，当当前索引值不再有效的时候，将会抛出这个异常。因为<code>removeLast</code>方法，有可能被多个线程同时执行，当线程一通过<code>index()</code>获得索引值为10，在尝试通过<code>remove()</code>删除该索引位置的元素之前，线程2把该索引位置的值删除掉了，这时线程一在执行时便会抛出异常。<br>为了避免出现类似问题，可以尝试加锁：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    synchronized (v) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> index = v.<span class="built_in">size</span>() - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        v.<span class="built_in">remove</span>(index);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如上，我们在<code>deleteLast</code>中，对v进行加锁，即可保证同一时刻，不会有其他线程删除掉v中的元素。<br>至此，我们已经解释清楚了我们的问题。</p>
<h3 id="问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？-1"><a href="#问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？-1" class="headerlink" title="问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？"></a><strong>问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？</strong></h3><p><strong>答：同步容器中的所有自带方法都是线程安全的，因为方法都使用<code>synchronized</code>关键字标注。但是，对这些集合类的复合操作无法保证其线程安全性。需要客户端通过主动加锁来保证。</strong><br>由于我们自己已知<code>Vector</code>等同步容器是线程安全的，所以我们通常在多线程场景中会直接拿来使用，并不会考虑太多，从而可能导致问题。<br>所以，我们在使用同步容器的时候，如果只使用其中的自带方法，那么可以放心使用，因为他们是线程安全的，但是如果我们想做复合操作，尤其是涉及到删除容器中的元素时，一定要注意是否需要客户端主动加锁。<br>下面，我们考虑以下代码，如果在多线程场景中使用会不会出现线程安全问题：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &lt; v.size(); i++) &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="name">v</span>.get(<span class="name">i</span>))<span class="comment">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>显然，以上代码在迭代的过程中，并不会出现线程安全问题。但是，如果在程序中还有以下代码有可能被同时调用呢？</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; v.<span class="built_in">size</span>(); <span class="built_in">i</span>++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    v.remove(<span class="built_in">i</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>由于，不同线程在同一时间操作同一个Vector，其中包括删除操作，那么就同样有可能发生线程安全问题。所以，在使用同步容器的时候，如果涉及到多个线程同时执行删除操作，就要考虑下是否需要加锁。</p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/1786" target="_blank" rel="noopener">https://www.hollischuang.com/archives/1786</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>Vector</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中String类型是否有长度限制</title>
    <url>/2019/12/26/Java%E4%B8%ADString%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E6%9C%89%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/</url>
    <content><![CDATA[<p>String是Java中很重要的一个数据类型，除了基本数据类型以外，String是被使用的最广泛的了，但是，关于String，其实还是有很多东西容易被忽略的。就如本文我们要讨论的问题：Java中的String有没有长度限制？这个问题要分两个阶段看，分别是编译期和运行期。不同的时期限制不一样。</p>
<a id="more"></a>

<h3 id="编译期"><a href="#编译期" class="headerlink" title="编译期"></a>编译期</h3><p>首先，我们先来合理的推断一下，当我们在代码中使用String s = “”;的形式来定义String对象的时候，””中字符的个数有没有限制呢？<br>既然是合理的推断，那就要要足够的依据，所以我们可以从String的源码入手，根据public String(char value[], int offset, int count)的定义，count是int类型的，所以，char value[]中最多可以保存Integer.MAX_VALUE个,即2147483647字符。(jdk1.8.0_73)<br>但是，实验证明，String s = “”;中，最多可以有65534个字符。如果超过这个个数。就会在编译期报错。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">String</span> s = <span class="string">"a...a"</span>;<span class="comment">// 共65534个a</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.<span class="built_in">println</span>(s.length());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">String</span> s1 = <span class="string">"a...a"</span>;<span class="comment">// 共65535个a</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.<span class="built_in">println</span>(s1.length());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>以上代码，会在String s1 = “a…a”;// 共65535个a处编译失败：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">✗ javac <span class="module-access"><span class="module"><span class="identifier">StringLenghDemo</span>.</span></span>java</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">StringLenghDemo</span>.</span></span>java:<span class="number">11</span>: 错误: 常量字符串过长</span></pre></td></tr></table></figure>

<p><strong>明明说好的长度限制是2147483647，为什么65535个字符就无法编译了呢？</strong><br>当我们使用字符串字面量直接定义String的时候，是会把字符串在常量池中存储一份的。那么上面提到的65534其实是常量池的限制。<br>常量池中的每一种数据项也有自己的类型。Java中的UTF-8编码的Unicode字符串在常量池中以CONSTANT_Utf8类型表示。<br>CONSTANTUtf8info是一个CONSTANTUtf8类型的常量池数据项，它存储的是一个常量字符串。常量池中的所有字面量几乎都是通过CONSTANTUtf8info描述的。CONSTANTUtf8_info的定义如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">CONSTANT_Utf8_info</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">u1</span> tag;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">u2</span> length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">u1</span> bytes[length];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>由于本文的重点并不是CONSTANTUtf8info的介绍，这里就不详细展开了，我们只需要我们使用字面量定义的字符串在class文件中，是使用CONSTANTUtf8info存储的，而CONSTANTUtf8info中有u2 length;表明了该类型存储数据的长度。<br>u2是无符号的16位整数，因此理论上允许的的最大长度是2^16=65536。而 java class 文件是使用一种变体UTF-8格式来存放字符的，null 值使用两个 字节来表示，因此只剩下 65536－ 2 ＝ 65534个字节。<br>关于这一点，在the class file format spec中也有明确说明：</p>
<blockquote>
<p>The length of field and method names, field and method descriptors, and other constant string values is limited to 65535 characters by the 16-bit unsigned length item of the CONSTANTUtf8info structure (§4.4.7). Note that the limit is on the number of bytes in the encoding and not on the number of encoded characters. UTF-8 encodes some characters using two or three bytes. Thus, strings incorporating multibyte characters are further constrained.</p>
</blockquote>
<p><strong>也就是说，在Java中，所有需要保存在常量池中的数据，长度最大不能超过65535，这当然也包括字符串的定义咯。</strong></p>
<h3 id="运行期"><a href="#运行期" class="headerlink" title="运行期"></a>运行期</h3><p>上面提到的这种String长度的限制是编译期的限制，也就是使用String s= “”;这种字面值方式定义的时候才会有的限制。<br>那么。String在运行期有没有限制呢，答案是有的，就是我们前文提到的那个Integer.MAX_VALUE ，这个值约等于4G，在运行期，如果String的长度超过这个范围，就可能会抛出异常。(在jdk 1.9之前）<br>int 是一个 32 位变量类型，取正数部分来算的话，他们最长可以有</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>^<span class="number">31</span>-<span class="number">1</span> =<span class="number">2147483647</span> 个 <span class="number">16</span>-bit Unicodecharacter</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">2147483647 </span>* <span class="number">16</span> = <span class="number">34359738352</span> 位</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">34359738352 </span>/ <span class="number">8</span> = <span class="number">4294967294</span> (Byte)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">4294967294 </span>/ <span class="number">1024</span> = <span class="number">4194303.998046875</span> (KB)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4194303.998046875</span> / <span class="number">1024</span> = <span class="number">4095.9999980926513671875</span> (MB)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4095.9999980926513671875</span> / <span class="number">1024</span> = <span class="number">3.99999999813735485076904296875</span> (GB)</span></pre></td></tr></table></figure>

<p>有近 4G 的容量。</p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/3916" target="_blank" rel="noopener">https://www.hollischuang.com/archives/3916</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>工厂模式介绍</title>
    <url>/2019/12/26/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>很多人认为工厂模式很简单，只是有一个建造工厂，帮我们进行对象构造而已。那么请尝试回答下以下问题：</p>
<blockquote>
<p>1、工厂模式分为几类？<br>2、GOF 23种设计模式中，工厂方法模式和抽象工厂模式有什么区别？<br>3、不在GOF 23种设计模式中的简单工厂模式是什么？<br>4、简单工厂模式、工厂方法模式和抽象工厂模式各自解决什么问题？有什么不同？</p>
</blockquote>
<p>如果以上四个问题，你都可以很好的回答的话，那么这篇文章就没有继续读下去的必要了，否则，建议你好好学习下本文。</p>
<a id="more"></a>

<h3 id="三种工厂模式"><a href="#三种工厂模式" class="headerlink" title="三种工厂模式"></a>三种工厂模式</h3><p>工厂模式可以分为三类：</p>
<ul>
<li>1）简单工厂模式（Simple Factory）</li>
<li>2）工厂方法模式（Factory Method）</li>
<li>3）抽象工厂模式（Abstract Factory）</li>
</ul>
<p>这三种模式从上到下逐步抽象，并且更具一般性。<br>GOF在《设计模式》一书中将工厂模式分为两类：工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）。<br>将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。<br>这三种工厂模式在设计模式的分类中都属于<strong>创建型模式</strong>。<br>创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。<br>创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。<br>创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。<br>工厂模式是创建型模式中比较重要的。工厂模式的主要功能就是帮助我们实例化对象的。<strong>之所以名字中包含工厂模式四个字，是因为对象的实例化过程是通过工厂实现的，是用工厂代替new操作的。</strong><br>这样做的好处是封装了对象的实例化细节，尤其是对于实例化较复杂或者对象的生命周期应该集中管理的情况。会给你系统带来更大的可扩展性和尽量少的修改量。<br>接下来我们分别介绍下这三种工厂模式。</p>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。<br>在介绍简单工厂模式之前，我们尝试解决以下问题：<br>现在我们要使用面向对象的形式定义计算器，为了实现各算法之间的解耦。主要的用到的类如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算类的基类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> double value1 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> double value2 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public double getValue1() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> value1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void setValue1(double value1) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.value1 = value1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public double getValue2() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> value2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void setValue2(double value2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.value2 = value2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> double getResule();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//加法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> double getResule() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> getValue1() + getValue2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//减法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OperationSub</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> double getResule() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> getValue1() - getValue2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//乘法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OperationMul</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> double getResule() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> getValue1() * getValue2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//除法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OperationDiv</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> double getResule() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (getValue2() != <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> getValue1() / getValue2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"除数不能为零"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>当我想要执行加法运算时，可以使用如下代码：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        OperationAdd operationAdd = <span class="keyword">new</span> OperationAdd();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        operationAdd.setValue1(<span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        operationAdd.setValue2(<span class="number">5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(operationAdd.getResule());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>当我需要执行减法运算时，我就要创建一个OperationSub类。也就是说，我想要使用不同的运算的时候就要创建不同的类，并且要明确知道该类的名字。<br>那么这种重复的创建类的工作其实可以放到一个统一的工厂类中。简单工厂模式有以下优点：</p>
<blockquote>
<p>1、一个调用者想创建一个对象，只要知道其名称就可以了。<br>2、屏蔽产品的具体实现，调用者只关心产品的接口。</p>
</blockquote>
<h4 id="简单工厂模式实现方式"><a href="#简单工厂模式实现方式" class="headerlink" title="简单工厂模式实现方式"></a><strong>简单工厂模式实现方式</strong></h4><p>简单工厂模式其实和他的名字一样，很简单。先来看看它的组成:</p>
<blockquote>
<p>Factory:这是本模式的核心,含有一定的商业逻辑和判断逻辑。在java中它往往由 一个具体类实现。（OperationFactory）<br>Product:它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。（Operation）<br>ConcreteProduct:工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。 来用类图来清晰的表示下的它们之间的关系（OperationAdd\OperationSub等）</p>
</blockquote>
<p><img src="http://image.winrains.cn/2019/08/c5e3c-15588649289622.jpg" alt="img"><br>在原有类的基础上，定义工厂类：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工厂类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Operation createOperation(<span class="keyword">String</span> operation) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Operation oper = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">"+"</span>:<span class="type"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="type">                oper </span>= <span class="keyword">new</span> <span class="type">OperationAdd</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">"-"</span>:<span class="type"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="type">                oper </span>= <span class="keyword">new</span> <span class="type">OperationSub</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">"*"</span>:<span class="type"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="type">                oper </span>= <span class="keyword">new</span> <span class="type">OperationMul</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">"/"</span>:<span class="type"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="type">                oper </span>= <span class="keyword">new</span> <span class="type">OperationDiv</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">default</span>:<span class="type"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="type">                throw new UnsupportedOperationException</span>(<span class="string">"不支持该操作"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> oper;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>有了工厂类之后，可以使用工厂创建对象：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Operation operationAdd = <span class="module-access"><span class="module"><span class="identifier">OperationFactory</span>.</span></span>create<span class="constructor">Operation(<span class="string">"+"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">operationAdd.set<span class="constructor">Value1(10)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">operationAdd.set<span class="constructor">Value2(5)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(operationAdd.get<span class="constructor">Resule()</span>);</span></pre></td></tr></table></figure>

<p>通过简单工厂模式，该计算器的使用者不需要关系实现加法逻辑的那个类的具体名字，他只要知道该类对应的参数”+”就可以了。</p>
<h4 id="简单工厂模式存在的问题"><a href="#简单工厂模式存在的问题" class="headerlink" title="简单工厂模式存在的问题"></a><strong>简单工厂模式存在的问题</strong></h4><p>当我们需要增加一种计算时，例如开平方。这个时候我们需要先定义一个类继承<code>Operation</code>类，其中实现平方的代码。除此之外我们还要修改<code>OperationFactory</code>类的代码，增加一个case。这显然是违背开闭原则的。可想而知对于新产品的加入，工厂类是很被动的。<br>我们举的例子是最简单的情况。而在实际应用中，很可能产品是一个多层次的树状结构。 简单工厂可能就不太适用了。</p>
<h4 id="简单工厂模式总结"><a href="#简单工厂模式总结" class="headerlink" title="简单工厂模式总结"></a><strong>简单工厂模式总结</strong></h4><p>工厂类是整个简单工厂模式的关键。包含了必要的逻辑判断，根据外界给定的信息，决定究竟应该创建哪个具体类的对象。通过使用工厂类，外界可以从直接创建具体产品对象的尴尬局面摆脱出来，仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的。明确了各自的职责和权利，有利于整个软件体系结构的优化。<br>但是由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。<br>当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；<br>这些缺点在工厂方法模式中得到了一定的解决。</p>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。<br>工厂方法模式是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。</p>
<blockquote>
<p>工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。”</p>
</blockquote>
<h4 id="工厂方法模式用途"><a href="#工厂方法模式用途" class="headerlink" title="工厂方法模式用途"></a><strong>工厂方法模式用途</strong></h4><p>工厂方法模式和简单工厂模式虽然都是通过工厂来创建对象，他们之间最大的不同是——<strong>工厂方法模式在设计上完全完全符合“开闭原则”。</strong><br>在以下情况下可以使用工厂方法模式：</p>
<blockquote>
<p>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。<br>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。<br>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</p>
</blockquote>
<h4 id="工厂方法模式实现方式"><a href="#工厂方法模式实现方式" class="headerlink" title="工厂方法模式实现方式"></a><strong>工厂方法模式实现方式</strong></h4><p>工厂方法模式包含如下角色：</p>
<blockquote>
<p>Product：抽象产品（<code>Operation</code>）<br>ConcreteProduct：具体产品(<code>OperationAdd</code>)<br>Factory：抽象工厂(<code>IFactory</code>)<br>ConcreteFactory：具体工厂(<code>AddFactory</code>)</p>
</blockquote>
<p><img src="http://image.winrains.cn/2019/08/7fbba-15588647240804.jpg" alt="img"><br>这里还用计算器的例子。在保持<code>Operation</code>，<code>OperationAdd</code>，<code>OperationDiv</code>，<code>OperationSub</code>，<code>OperationMul</code>等几个方法不变的情况下，修改简单工厂模式中的工厂类（<code>OperationFactory</code>）。替代原有的那个”万能”的大工厂类，这里使用工厂方法来代替：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工厂接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">Operation <span class="title">CreateOption</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//加法类工厂</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOption</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationAdd();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//除法类工厂</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOption</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationDiv();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//除法类工厂</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOption</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationMul();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//减法类工厂</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOption</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationSub();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这样，在客户端中想要执行加法运算时，需要以下方式：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        IFactory factory = <span class="keyword">new</span> AddFactory();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Operation operationAdd =  factory.CreateOption();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        operationAdd.setValue1(<span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        operationAdd.setValue2(<span class="number">5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(operationAdd.<span class="built_in">getResult</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>到这里，一个工厂方法模式就已经写好了。<br>从代码量上看，这种工厂方法模式比简单工厂方法模式更加复杂。针对不同的操作（Operation）类都有对应的工厂。很多人会有以下疑问：</p>
<blockquote>
<p>貌似工厂方法模式比简单工厂模式要复杂的多？<br>工厂方法模式和我自己创建对象没什么区别？为什么要多搞出一些工厂来？</p>
</blockquote>
<p>下面就针对以上两个问题来深入理解一下工厂方法模式。</p>
<h4 id="为什么要使用工厂来创建对象？"><a href="#为什么要使用工厂来创建对象？" class="headerlink" title="为什么要使用工厂来创建对象？"></a><strong>为什么要使用工厂来创建对象？</strong></h4><blockquote>
<p>封装对象的创建过程</p>
</blockquote>
<p>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户<strong>隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</strong><br>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。<strong>它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。</strong>工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</p>
<h4 id="为什么每种对象要单独有一个工厂？"><a href="#为什么每种对象要单独有一个工厂？" class="headerlink" title="为什么每种对象要单独有一个工厂？"></a><strong>为什么每种对象要单独有一个工厂？</strong></h4><blockquote>
<p>符合『开放-封闭原则』</p>
</blockquote>
<p>主要目的是为了解耦。在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则。<br>以上就是工厂方法模式的优点。但是，工厂模式也有一些不尽如人意的地方：</p>
<blockquote>
<p>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。<br>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</p>
</blockquote>
<h4 id="工厂方法模式总结"><a href="#工厂方法模式总结" class="headerlink" title="工厂方法模式总结"></a><strong>工厂方法模式总结</strong></h4><p>工厂方法模式是简单工厂模式的进一步抽象和推广。<br>由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。<br>在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。<br>工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。<br>抽象工厂模式提供了一种方式，可以将同一产品族的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。</p>
<h4 id="产品族"><a href="#产品族" class="headerlink" title="产品族"></a><strong>产品族</strong></h4><p>来认识下什么是产品族: 位于不同产品等级结构中,功能相关的产品组成的家族。如下面的例子，就有两个产品族：跑车族和商务车族。<br><img src="http://image.winrains.cn/2019/08/5a461-15588644956826.jpg" alt="img"></p>
<h4 id="抽象工厂模式用途"><a href="#抽象工厂模式用途" class="headerlink" title="抽象工厂模式用途"></a><strong>抽象工厂模式用途</strong></h4><p>抽象工厂模式和工厂方法模式一样，都符合开放-封闭原则。但是不同的是，工厂方法模式在增加一个具体产品的时候，都要增加对应的工厂。但是抽象工厂模式只有在新增一个类型的具体产品时才需要新增工厂。也就是说，工厂方法模式的一个工厂只能创建一个具体产品。而抽象工厂模式的一个工厂可以创建属于一类类型的多种具体产品。工厂创建产品的个数介于简单工厂模式和工厂方法模式之间。<br>在以下情况下可以使用抽象工厂模式：</p>
<blockquote>
<p>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。<br>系统中有多于一个的产品族，而每次只使用其中某一产品族。<br>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。<br>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</p>
</blockquote>
<h4 id="抽象工厂模式实现方式"><a href="#抽象工厂模式实现方式" class="headerlink" title="抽象工厂模式实现方式"></a><strong>抽象工厂模式实现方式</strong></h4><p>抽象工厂模式包含如下角色：</p>
<blockquote>
<p>AbstractFactory(抽象工厂)：用于声明生成抽象产品的方法<br>ConcreteFactory(具体工厂)：实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中；<br>AbstractProduct(抽象产品)：为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法；<br>Product(具体产品)：定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。</p>
</blockquote>
<p>本文的例子采用一个汽车代工厂造汽车的例子。假设我们是一家汽车代工厂商，我们负责给奔驰和特斯拉两家公司制造车子。我们简单的把奔驰车理解为需要加油的车，特斯拉为需要充电的车。其中奔驰车中包含跑车和商务车两种，特斯拉同样也包含奔驰车和商务车。<br><img src="http://image.winrains.cn/2019/08/c1a96-15588645213493.jpg" alt="img"><br>以上场景，我们就可以把跑车和商务车分别对待，对于跑车有单独的工厂创建，商务车也有单独的工厂。这样，以后无论是再帮任何其他厂商造车，只要是跑车或者商务车我们都不需要再引入工厂。同样，如果我们要增加一种其他类型的车，比如越野车，我们也不需要对跑车或者商务车的任何东西做修改。<br>下面是抽象产品，奔驰车和特斯拉车：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">BenzCar</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//加汽油</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> gasUp();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">TeslaCar</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//充电</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> charge();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>下面是具体产品，奔驰跑车、奔驰商务车、特斯拉跑车、特斯拉商务车：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">BenzSportCar</span> <span class="symbol">implements</span> <span class="symbol">BenzCar</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> gasUp() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"给我的奔驰跑车加最好的汽油"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">BenzBusinessCar</span> <span class="symbol">implements</span> <span class="symbol">BenzCar</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> gasUp() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"给我的奔驰商务车加一般的汽油"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">TeslaSportCar</span> <span class="symbol">implements</span> <span class="symbol">TeslaCar</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> charge() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"给我特斯拉跑车冲满电"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">TeslaBusinessCar</span> <span class="symbol">implements</span> <span class="symbol">TeslaCar</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> charge() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"不用给我特斯拉商务车冲满电"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>下面是抽象工厂：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>CarFactory &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public BenzCar getBenzCar();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public TeslaCar getTeslaCar();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>下面是具体工厂：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SportCarFactory</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">CarFactory</span></span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> BenzCar getBenzCar() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">BenzSportCar</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> TeslaCar getTeslaCar() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">TeslaSportCar</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessCarFactory</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">CarFactory</span></span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> BenzCar getBenzCar() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">BenzBusinessCar</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> TeslaCar getTeslaCar() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">TeslaBusinessCar</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="“开闭原则”的倾斜性"><a href="#“开闭原则”的倾斜性" class="headerlink" title="“开闭原则”的倾斜性"></a><strong>“开闭原则”的倾斜性</strong></h4><p>“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的。对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：</p>
<blockquote>
<p>增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。<br>增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持“开闭原则”。</p>
</blockquote>
<p>抽象工厂模式的这种性质称为“开闭原则”的倾斜性，抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，但不能为新的产品等级结构的增加提供这样的方便。</p>
<h4 id="抽象工厂模式总结"><a href="#抽象工厂模式总结" class="headerlink" title="抽象工厂模式总结"></a><strong>抽象工厂模式总结</strong></h4><p>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。<br>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。<br>抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。</p>
<h3 id="三种工厂模式对比"><a href="#三种工厂模式对比" class="headerlink" title="三种工厂模式对比"></a>三种工厂模式对比</h3><h4 id="简单工厂模式的优缺点"><a href="#简单工厂模式的优缺点" class="headerlink" title="简单工厂模式的优缺点"></a><strong>简单工厂模式的优缺点</strong></h4><ul>
<li>优点：<ul>
<li>1、屏蔽产品的具体实现，调用者只关心产品的接口。</li>
<li>2、实现简单</li>
</ul>
</li>
<li>缺点：<ul>
<li>1、增加产品，需要修改工厂类，不符合开放-封闭原则</li>
<li>2、工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则</li>
</ul>
</li>
</ul>
<h4 id="工厂方法模式的优缺点"><a href="#工厂方法模式的优缺点" class="headerlink" title="工厂方法模式的优缺点"></a><strong>工厂方法模式的优缺点</strong></h4><ul>
<li>优点：<ul>
<li>1、继承了简单工厂模式的优点</li>
<li>2、符合开放-封闭原则</li>
</ul>
</li>
<li>缺点：<ul>
<li>1、增加产品，需要增加新的工厂类，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</li>
</ul>
</li>
</ul>
<h4 id="抽象工厂模式的优缺点"><a href="#抽象工厂模式的优缺点" class="headerlink" title="抽象工厂模式的优缺点"></a><strong>抽象工厂模式的优缺点</strong></h4><ul>
<li>优点：<ul>
<li>1、隔离了具体类的生成，使得客户并不需要知道什么被创建</li>
<li>2、每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；</li>
</ul>
</li>
<li>缺点<ul>
<li>增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。</li>
</ul>
</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/eb056-15588638543500.jpg" alt="img"><br>简单工厂 ： 用来生产同一等级结构中的任意产品。（对于增加新的产品，主要是新增产品，就要修改工厂类。符合单一职责原则。不符合开放-封闭原则）<br>工厂方法 ：用来生产同一等级结构中的固定产品。（支持增加任意产品，新增产品时不需要更改已有的工厂，需要增加该产品对应的工厂。符合单一职责原则、符合开放-封闭原则。但是引入了复杂性）<br>抽象工厂 ：用来生产不同产品族的全部产品。（增加新产品时，需要修改工厂，增加产品族时，需要增加工厂。符合单一职责原则，部分符合开放-封闭原则，降低了复杂性）<br>最后，三种工厂模式各有优缺点，没有最好的，只有最合适的！</p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/3709" target="_blank" rel="noopener">https://www.hollischuang.com/archives/3709</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>工厂模式</category>
      </categories>
  </entry>
  <entry>
    <title>IntelliJ IDEA必装插件</title>
    <url>/2019/12/26/IntelliJ-IDEA%E5%BF%85%E8%A3%85%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>本文，给大家推荐几款我私藏已久的，自己经常使用的，可以提升代码效率的插件。</p>
<a id="more"></a>

<h2 id="IDEA插件简介"><a href="#IDEA插件简介" class="headerlink" title="IDEA插件简介"></a>IDEA插件简介</h2><p>常见的IDEA插件主要有如下几类：</p>
<h3 id="常用工具支持"><a href="#常用工具支持" class="headerlink" title="常用工具支持"></a>常用工具支持</h3><p>Java日常开发需要接触到很多常用的工具，为了便于使用，很多工具也有IDEA插件供开发使用，其中大部分已经在IDEA中默认集成了。例如maven、git、svn、tomcat、jetty、jrebel、Gradle等。</p>
<h3 id="功能增强"><a href="#功能增强" class="headerlink" title="功能增强"></a>功能增强</h3><p>还有些插件提供了一些IDE中不具有的功能，比如静态代码扫描、代码自动生成等。</p>
<h3 id="框架集成"><a href="#框架集成" class="headerlink" title="框架集成"></a>框架集成</h3><p>集成框架主要是为了提供框架定制的代码和配置的生成，以及快速的访问框架提供的功能。例如集成Spring框架，Mybatis框架等。</p>
<h3 id="UI定制化及优化"><a href="#UI定制化及优化" class="headerlink" title="UI定制化及优化"></a>UI定制化及优化</h3><p>UI定制化相关的插件主要提供一下个性化需求定制，例如修改编辑区的背景图片插件、修改代码颜色等。</p>
<h3 id="其他编程语言支持"><a href="#其他编程语言支持" class="headerlink" title="其他编程语言支持"></a>其他编程语言支持</h3><p>IDEA主要支持Java，为了使用其他语言，可以使用一些支持其他语言的插件，通过这些插件可以实现语法分析，配色主题，代码格式化和提示等功能。例如Go语言的支持的插件。</p>
<h3 id="个人或者公司特殊需求"><a href="#个人或者公司特殊需求" class="headerlink" title="个人或者公司特殊需求"></a>个人或者公司特殊需求</h3><p>公司内部插件</p>
<h2 id="我的插件一览"><a href="#我的插件一览" class="headerlink" title="我的插件一览"></a>我的插件一览</h2><p>这里简单介绍一些笔者日常开发中使用到的插件。 以下是我的IDEA中自己安装的插件列表。这些插件都是我经过很长时间的使用之后最终保留下来的，都是值得安装的一些插件。其中被我打码的就是公司内部插件。<br><img src="http://image.winrains.cn/2019/08/40c4f-15479665089765.jpg" alt="img"></p>
<h2 id="IDEA插件安装"><a href="#IDEA插件安装" class="headerlink" title="IDEA插件安装"></a>IDEA插件安装</h2><p>IDEA的插件安装非常简单，对于很多插件来说，只要你知道插件的名字就可以在IDEA里面直接安装。<br>Preferences—&gt;Plugins—&gt;查找所需插件—&gt;Install<br>或者<br>Preferences—&gt;Plugins—&gt;Install plug from disk —&gt;选择下载好的插件安装<br>安装之后重启IDEA即可生效</p>
<h3 id="IDEA插件仓库"><a href="#IDEA插件仓库" class="headerlink" title="IDEA插件仓库"></a>IDEA插件仓库</h3><p>IntelliJ IDEA激发了许多Java开发人员编写插件， IntelliJ IDEA Plugins（<a href="https://plugins.jetbrains.com/?idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/?idea</a> ）中目前包含3000+个插件并且还在不断增长。<br><img src="http://image.winrains.cn/2019/08/58b19-15479620248612.jpg" alt="img"></p>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><p>作者目前使用的IntelliJ IDEA版本是专业版2018.2.4（Ultimate Edition）<br><img src="http://image.winrains.cn/2019/08/4483c-15479603329394.jpg" alt="img"><br>很多插件中提供的功能在这个版本中都已经集成进来了，这里简单说几个可能比较常用的，这几种功能就无需加装插件了。</p>
<h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><p>目前，IDEA支持设置背景图片。这对于广大程序员来说无疑是个好功能。整日对着枯燥的代码实在是会让人疲乏。要是可以设置一张美女图片的话。。。<br><strong>设置方法</strong><br>Ctrl+Shift+A(或者help -&gt; find action)调用弹窗后输入Set Background Image<br><img src="http://image.winrains.cn/2019/08/28b10-15479606563989.jpg" alt="img"><br>在里面设定要设置为Image的图片,透明度调到15左右，保存即可。<br><img src="http://image.winrains.cn/2019/08/1ac63-15479609892646.jpg" alt="img"><br><strong>效果如下</strong><br><img src="http://image.winrains.cn/2019/08/a4dfc-15479609485695.jpg" alt="img"></p>
<h3 id="内置terminal"><a href="#内置terminal" class="headerlink" title="内置terminal"></a>内置terminal</h3><p>目前IntelliJ IDEA已经有一个内置的terminal工具，可以方便的使用shell命令。<br><img src="http://image.winrains.cn/2019/08/75127-15479610703144.jpg" alt="img"></p>
<h3 id="内置support"><a href="#内置support" class="headerlink" title="内置support"></a>内置support</h3><p>目前很多新版本的IntelliJ IDEA中，已经内置了很多support插件，比如我们常用的markdown support 、UML support 以及 android support等。<br><img src="http://image.winrains.cn/2019/08/f2924-15479615077554.jpg" alt="img"><br>PS：由于作者使用的是专业版，不知道社区版是否也会内置这些插件，如果没有内置的话，读者可以根据需要自行下载相关插件并安装。<br>有了markdowm support插件以后，就可以直接预览md语法的内容了。<br><img src="http://image.winrains.cn/2019/08/761da-15479618675094.jpg" alt="img"></p>
<h2 id="必备插件"><a href="#必备插件" class="headerlink" title="必备插件"></a>必备插件</h2><h3 id="Maven-Helper"><a href="#Maven-Helper" class="headerlink" title="Maven Helper"></a>Maven Helper</h3><p>目前，Java开发很多都在使用maven进行项目管理和自动构建。<br>日常开发中，可能经常会遇到jar包冲突等问题，就需要通过查看maven依赖树来查查看依赖情况。这种方式不是很高效，这里推荐一个插件，安装之后，直接打开pom文件，即可查看依赖数，还能自动分析是否存在jar包冲突。<br>一旦安装了Maven Helper插件，只要打开pom文件，就可以打开该pom文件的Dependency Analyzer视图（在文件打开之后，文件下面会多出这样一个tab）。<br><img src="http://image.winrains.cn/2019/08/3d81a-15479624935730.jpg" alt="img"><br>进入Dependency Analyzer视图之后有三个查看选项，分别是Conflicts(冲突)、All Dependencies as List(列表形式查看所有依赖)、All Dependencies as Tree(树结构查看所有依赖)。并且这个页面还支持搜索。</p>
<h3 id="FindBugs-IDEA"><a href="#FindBugs-IDEA" class="headerlink" title="FindBugs-IDEA"></a>FindBugs-IDEA</h3><p>FindBugs很多人都并不陌生，Eclipse中有插件可以帮助查找代码中隐藏的bug，IDEA中也有这款插件。<br>使用方法很简单，就是可以对多种级别的内容进行finbugs<br><img src="http://image.winrains.cn/2019/08/a365c-15479625706835.png" alt="img"><br>分析完之后会有一个视图进行提示，详细的说明是哪种问题。<br><img src="http://image.winrains.cn/2019/08/c79aa-15479625758685.png" alt="img"><br>按照提示解决完问题之后再执行findbug查看情况即可。</p>
<h3 id="阿里巴巴代码规约检测"><a href="#阿里巴巴代码规约检测" class="headerlink" title="阿里巴巴代码规约检测"></a>阿里巴巴代码规约检测</h3><p>2017年10月14日杭州云栖大会，Java代码规约扫描插件全球首发仪式正式启动，规范正式以插件形式公开走向业界，引领Java语言的规范之路。<br>Java代码规约扫描插件以今年年初发布的《阿里巴巴Java开发规约》为标准，作为Eclipse、IDEA的插件形式存在，检测JAVA代码中存在不规范得位置然后给予提示。规约插件是采用kotlin语言开发的，感兴趣的同学可以去开看插件源码。<br>阿里巴巴规约插件包含三个子菜单：编码规约扫描、关闭试试检测功能。<br><img src="http://image.winrains.cn/2019/08/63d65-15479626591284.jpg" alt="img"><br>并且，该插件支持在编写代码的同时进行提示，<br><img src="http://image.winrains.cn/2019/08/74649-15479627335217.jpg" alt="img"><br>这款插件，真的可以很大程度上提升代码质量，一定要安装。</p>
<h3 id="GsonFormat"><a href="#GsonFormat" class="headerlink" title="GsonFormat"></a>GsonFormat</h3><p>Java开发中，经常有把json格式的内容转成Object的需求，比如项目开始时，合作方给你提供了一个json格式request/response，这时候你就需要将其定义成一个Java类，GsonFormat这款插件可以实现该功能。<br><img src="http://image.winrains.cn/2019/08/abd2e-15479627865604.gif" alt="img"></p>
<h3 id="Lombok-plugin"><a href="#Lombok-plugin" class="headerlink" title="Lombok plugin"></a>Lombok plugin</h3><p>在Java中，我们经常会定义很多JavaBean，这些Bean需要有getter、setter、toString、equals和hashCode等方法。<br>通常情况下，我们可以使用IDEA的快捷键生成这些代码，但是自动生成的代码后，如果bean中的属性一旦有修改，需要重新生成，给代码维护增加了一定的负担。<br>有一款很好的插件，可以帮助开发者节省这部分工作。那就是Lombok。<br>只要在IDEA中安装了该插件，只需要在JavaBean中添加一行注解代码，插件就会自动帮我们生成getter、setter、toString、equals和hashCode等方法。<br>当然，这些方法不止在IDE中的代码调用中需要用到，在真正线上部署的时候也需要有，所以，还需要使用maven引入一个lombok的包。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;groupId&gt;org.projectlombok&lt;<span class="regexp">/groupId&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">      &lt;artifactId&gt;lombok&lt;/</span>artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;version&gt;<span class="number">1.16</span><span class="number">.10</span>&lt;<span class="regexp">/version&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">&lt;/</span>dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * @author Hollis</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HollisLab</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Wechat wechat = <span class="keyword">new</span> Wechat();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wechat.setId(<span class="string">"Hollis"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wechat.setDesc(<span class="string">"每日更新Java技术文章"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(wechat);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Data</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wechat</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private <span class="built_in">String</span> id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private <span class="built_in">String</span> desc;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Wechat(<span class="attribute">id</span>=Hollis, <span class="attribute">desc</span>=每日更新Java技术文章)</span></pre></td></tr></table></figure>

<p>我们在Wechat类上面添加了@Data注解，插件就自动帮我们添加了getter/setter和toString方法。</p>
<h3 id="String-Manipulation"><a href="#String-Manipulation" class="headerlink" title="String Manipulation"></a>String Manipulation</h3><p>字符串日常开发中经常用到的，但是不同的字符串类型在不同的地方可能有一些不同的规则，比如类名要用驼峰形式、常量需要全部大写等，有时候还需要进行编码解码等。这里推荐一款强大的字符串转换工具——String Manipulation。<br>它强大到什么程度，看下他的功能列表你就知道了：<br><img src="http://image.winrains.cn/2019/08/59068-15479639987089.jpg" alt="img"></p>
<ul>
<li>文本转换操作<ul>
<li>切换样式（camelCase, hyphen-lowercase, HYPHEN-UPPERCASE, snake_case, SCREAMING_SNAKE_CASE, dot.case, words lowercase, Words Capitalized, PascalCase）</li>
<li>转换为SCREAMING_SNAKE_CASE (或转换为camelCase)</li>
<li>转换为 snake_case (或转换为camelCase)</li>
<li>转换为dot.case (或转换为camelCase)</li>
<li>转换为hyphen-case (或转换为camelCase)</li>
<li>转换为hyphen-case (或转换为snake_case)</li>
<li>转换为camelCase (或转换为Words)</li>
<li>转换为camelCase (或转换为lowercase words)</li>
<li>转换为PascalCase (或转换为camelCase)</li>
<li>选定文本大写</li>
<li>样式反转</li>
</ul>
</li>
<li>Un/Escape<ul>
<li>Un/Escape 选中的 java 文本</li>
<li>Un/Escape 选中的 javascript 文本</li>
<li>Un/Escape 选中的 HTML 文本</li>
<li>Un/Escape 选中的 XML 文本</li>
<li>Un/Escape 选中的 SQL 文本</li>
<li>Un/Escape 选中的 PHP 文本</li>
<li>将 diacritics(accents) 转换为 ASCII</li>
<li>将非ASCII 转换为转义的Unicode</li>
<li>将转义的Unicode转换为字符串</li>
</ul>
</li>
<li>Encode/Decode<ul>
<li>Encode 选中的文本为 MD5 Hex16</li>
<li>De/Encode 选中的文本为 URL</li>
<li>De/Encode 选中的文本为 Base64</li>
</ul>
</li>
<li>递增/递减<ul>
<li>递增/递减所有找到的数字</li>
<li>复制行并且递增/递减所有找到的数字</li>
<li>创建序列：保持第一个数字，递增替换所有其他数字</li>
<li>递增重复的数字</li>
</ul>
</li>
<li>按自然顺序排序<ul>
<li>按行倒序</li>
<li>按行随机排序</li>
<li>区分大小写A-z排序</li>
<li>区分大小写z-A排序</li>
<li>不区分大小写A-Z排序</li>
<li>不区分大小写Z-A排序</li>
<li>按行长度排序</li>
<li>通过子选择行排序：每行仅处理一个选择/插入符号</li>
</ul>
</li>
<li>对齐<ul>
<li>通过选定的分隔将选定的文本格式化为列/表格</li>
<li>将文本对齐为左/中/右</li>
</ul>
</li>
<li>过滤/删除/移除<ul>
<li>grep选定的文本，所有行不匹配输入文字将被删除。 （不能在列模式下工作）</li>
<li>移除选定的文本</li>
<li>移除选定文本中的所有空格</li>
<li>删除选定文本中的所有空格</li>
<li>删除重复的行</li>
<li>只保留重复的行</li>
<li>删除空行</li>
<li>删除所有换行符</li>
</ul>
</li>
<li>其他<ul>
<li>交换字符/选择/线/标记</li>
<li>切换文件路径分隔符：Windows &lt; – &gt; UNIX</li>
</ul>
</li>
</ul>
<p>安装好插件后，选中需要处理的内容后，按快捷键Alt+m，即可弹出工具功能列表。<br>很好很强大的一款字符串处理工具。</p>
<h3 id="ignore"><a href="#ignore" class="headerlink" title=".ignore"></a>.ignore</h3><p>目前很多开发都在使用git做版本控制工具，但是有些时候有些代码我们是不想提到到我们的代码仓库中的，比如ide自动生成的一些配置文件，或者是我们打包生成的一些jar文件等，这时候就需要编写一个.ignore文件，来排除那些不想被版本管理的文件。<br>这里推荐一个好用的插件.ignore，他可以帮我们方便的生成各种ignore文件。<br>安装插件后，选中项目，右键新建的时候，会多出一个.ignore文件的选项，可以通过这个选项创建ignore文件。<br><img src="http://image.winrains.cn/2019/08/9ab64-15479645941037.jpg" alt="img"><br>在弹出的对话框中，可以自动帮我们生成一份.ignore文件，这里我们让其帮忙自动排除所有和idea有关的文件。 <img src="http://image.winrains.cn/2019/08/68614-15479646877699.jpg" alt="img"></p>
<h3 id="Mybatis-plugin"><a href="#Mybatis-plugin" class="headerlink" title="Mybatis plugin"></a>Mybatis plugin</h3><p>目前ORM框架中，Mybatis非常受欢迎。但是，同时给很多开发带来困扰的就是Mybatis需要很多xml的配置文件，有的时候很难去进行修改。<br>这里推荐一款神器，可以让你像编辑java代码一样编辑mybatis的文件。<br>Intellij Idea Mybatis插件主要功能：</p>
<ul>
<li>提供Mapper接口与配置文件中对应SQL的导航</li>
<li>编辑XML文件时自动补全</li>
<li>根据Mapper接口, 使用快捷键生成xml文件及SQL标签</li>
<li>ResultMap中的property支持自动补全，支持级联(属性A.属性B.属性C)</li>
<li>快捷键生成@Param注解</li>
<li>XML中编辑SQL时, 括号自动补全</li>
<li>XML中编辑SQL时, 支持参数自动补全(基于@Param注解识别参数)</li>
<li>自动检查Mapper XML文件中ID冲突</li>
<li>自动检查Mapper XML文件中错误的属性值</li>
<li>支持Find Usage</li>
<li>支持重构从命名</li>
<li>支持别名</li>
<li>自动生成ResultMap属性</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/c18c4-15479651996039.jpg" alt="img"><br><img src="http://image.winrains.cn/2019/08/dd63b-15479652100916.jpg" alt="img"><br>（图源：<a href="https://www.oschina.net/p/intellij-mybatis-plugin）" target="_blank" rel="noopener">https://www.oschina.net/p/intellij-mybatis-plugin）</a><br>但是这款插件是收费的，但是不影响他确实是一个很实用，可以很大程度上提升开发效率的插件。读者可以考虑使用Free Mybatis plugin（这款插件我没用过，具体是否好用有待考证）。</p>
<h3 id="Key-promoter-X"><a href="#Key-promoter-X" class="headerlink" title="Key promoter X"></a>Key promoter X</h3><p>对于很多刚刚开始使用IDEA的开发者来说，最苦恼的就是不知道快捷键操作是什么。<br>使用IDEA，如果所有操作都使用鼠标，那么说明你还不是一个合格的程序员。<br>这里推荐一款可以进行快捷键提示的插件Key promoter X。<br>Key Promoter X 是一个提示插件，当你在IDEA里面使用鼠标的时候，如果这个鼠标操作是能够用快捷键替代的，那么Key Promoter X会弹出一个提示框，告知你这个鼠标操作可以用什么快捷键替代。<br>当我使用鼠标查看一个方法都被哪些类使用的时候，就会提示：<br><img src="http://image.winrains.cn/2019/08/78545-15479654859661.jpg" alt="img"><br>记住这个快捷键以后，就可以使用快捷键代替鼠标啦。</p>
<h3 id="AceJump"><a href="#AceJump" class="headerlink" title="AceJump"></a>AceJump</h3><p>前面介绍了一款可以通过使用快捷键来代替鼠标操作的插件，这里再介绍一款可以彻底摆脱鼠标的插件，即AceJump<br>AceJump允许您快速将光标导航到编辑器中可见的任何位置，只需点击“ctrl +;”，然后输入一个你想要跳转到的字符，之后键入匹配的字符就跳转到你想要挑战的地方了。<br><img src="http://image.winrains.cn/2019/08/2fc37-15479658623827.jpg" alt="img"><br>如以上代码，我想在这个类中，跳转到println那个位置，只需要按下快捷键：“ctrl +;”，然后输入println，即可定位到目标位置。<br>上图中，我输入了pri三个字母后，页面提示三个可选项，分别用字母G、H、D标注，这时候只需要按下对应字母，即可快速定位到指定位置，是不是很方便。</p>
<h3 id="activate-power-mode"><a href="#activate-power-mode" class="headerlink" title="activate-power-mode"></a>activate-power-mode</h3><p>最后，介绍一款程序员很好的在妹子面前装X的插件——activate-power-mode 。<br>安装了这款插件之后，你写代码的时候，就会附加一些狂拽炫酷屌炸天的效果：<br><img src="http://image.winrains.cn/2019/08/a45d6-15479661234183.gif" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文一共介绍了11款可以提升程序员开发效率、提升代码质量、提升编码心情的软件。欢迎大家安装尝试一下。</p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/3220" target="_blank" rel="noopener">https://www.hollischuang.com/archives/3220</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>IntelliJ IDEA</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构</title>
    <url>/2019/12/26/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>redis 是 key-value 类型的数据库，key 一般是一个字符串，但他的value可以储存5种数据类型</p>
<h2 id="key-的定义注意事项"><a href="#key-的定义注意事项" class="headerlink" title="key 的定义注意事项"></a>key 的定义注意事项</h2><p>它的 key 在定义时，需要注意以下事项</p>
<ul>
<li>不要超过 1024 个字节，过长除了会消耗内存，还会降低查找效率</li>
<li>有统一的命名规范</li>
</ul>
<a id="more"></a>

<h3 id="key-常用的命令"><a href="#key-常用的命令" class="headerlink" title="key 常用的命令"></a>key 常用的命令</h3><ul>
<li><strong>查询所有的键</strong>：<code>keys *</code></li>
<li><strong>查询所有以某个字符串开头的的键</strong>：<code>keys 字符串?</code></li>
<li><strong>删除键</strong>：<code>del 键1 键2</code></li>
<li><strong>查看键是否存在</strong>：<code>exists 键</code> 存在返回1 不存在返回0</li>
<li><strong>对键重命名</strong>： <code>rename 键 新键名</code></li>
<li><strong>设置过期时间</strong>：<code>expire 键 秒</code></li>
<li><strong>查看键的剩余过期时间</strong>：<code>ttl 键</code> 返回剩余的秒 如果键没有设置超时时间返回-1</li>
<li><strong>查看键对应的值的类型</strong>：<code>type 键</code> <strong>sorted-set</strong> 类型的值会返回 zset</li>
</ul>
<h2 id="五种数据类型"><a href="#五种数据类型" class="headerlink" title="五种数据类型"></a>五种数据类型</h2><p>redis 的值有五种数据类型</p>
<ul>
<li><strong>String</strong>：存储字符串、整数、浮点数</li>
<li><strong>list</strong>: 存储字符串、整数、浮点数列表</li>
<li><strong>set</strong>：存储字符串、整数、浮点数集合</li>
<li><strong>sort set</strong>：存储有序字符串、整数、浮点数集合</li>
<li><strong>hash</strong>：存储键值对</li>
</ul>
<p>比较常用的是 <strong>String</strong>、<strong>hash</strong></p>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>string 类型的数据在redis中是以二进制的方式存储的，这就避免了编码格式的问题，存入的是什么编码格式的字符串，读取的就是什么编码格式的字符串</p>
<ul>
<li>以二进制形式存储，存入和获取的数据一致</li>
<li>value 最多可以容纳的数据长度是 512M</li>
</ul>
<h3 id="string-常用命令"><a href="#string-常用命令" class="headerlink" title="string 常用命令"></a>string 常用命令</h3><ul>
<li><strong>赋值</strong>：<code>set 键 值</code></li>
<li><strong>不存在才赋值</strong>:<code>setnx 键 值</code> 存在不赋值，返回0， 不存在才赋值，返回1</li>
<li><strong>取值</strong>：<code>get 键</code> 获取键的值</li>
<li><strong>修改</strong>：<code>getset 键 新值</code> 将键的值改为新值</li>
<li><strong>删除</strong>：<code>del 键</code> 删除键的值</li>
<li><strong>数值加1</strong>：<code>inc 键</code> 如果 键 不存在，则创建 键 并设置值为0再加1，如果存在就直接加1，如果存在但值不能转成整型，就会报错</li>
<li><strong>数值减1</strong>：<code>decr 键</code>，decr 正好 与 inc 命令相反，它是减1</li>
<li><strong>数值加</strong>：：<code>incby 键 数值</code>，与 <code>inc 键</code> 相同，不同的地方在于他指定了要加的数值</li>
<li><strong>数值减</strong>：<code>decrby 键 数值</code>，与 <code>inc 键</code> 相同，不同的地方在于他指定了要减的数值</li>
<li><strong>拼接</strong>：<code>append 键 值</code> 在指定键后面拼接值，如果键不存在，创建 键 并初始化化为 值</li>
<li><strong>判断键是否存在</strong>：<code>exists 键</code>， 存在返回1，不存在返回0</li>
</ul>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>hash 类型可以看做是 string key 和 string value 的 map 容器<br>一个hesh可以存储 4294967295 个键值对</p>
<h3 id="hash-常用命令"><a href="#hash-常用命令" class="headerlink" title="hash 常用命令"></a>hash 常用命令</h3><ul>
<li><strong>赋值</strong>：<code>hset 键 hash的键 hash的值</code> 存入一对 hash ，同一个 键 可以存入多对hash</li>
<li><strong>批量赋值</strong>：<code>hmset 键 hash的键1 hash的值1 hash的键2 hash的值2</code> 在一个键中同时存入多对hash</li>
<li><strong>取值</strong>：<code>hget 键 hash的键</code> 取出 hash键对应的值</li>
<li><strong>批量取值</strong>：<code>hmget 键 hash的键1 hash的键2</code> 取出 hash键1、hash键2对应的值</li>
<li><strong>获取全部的值</strong>：<code>hgetall 键</code> 获取 键 中所有 hash键对应的值</li>
<li><strong>删除</strong>：<code>hdel 键 hash的键1 hash的键2</code> 删除hash的键1、hash的键2对应的键值对</li>
<li><strong>数值加</strong>：：<code>hincby 键 hash的键 数值</code>，给 hash的键对应的值 加上指定的数值</li>
<li><strong>判断某个 hash键 是否存在</strong>：<code>hexists 键 hash的键</code>， 存在返回1，不存在返回0</li>
<li><strong>获取 hash对 的数量</strong>：<code>hlen 键</code> 获取该键中 hash 对的数量</li>
<li><strong>获取所有的 hash键</strong>： <code>hkeys</code> 获取该键中 hash键的列表</li>
<li><strong>获取所有的 hash值</strong>： <code>hvals</code> 获取该键中 hash值的列表</li>
</ul>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）<br>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。<br>如果列表中的所以元素被删除，那么列表本身也会被删除</p>
<h3 id="list-常用命令"><a href="#list-常用命令" class="headerlink" title="list 常用命令"></a>list 常用命令</h3><ul>
<li><strong>左端添加</strong>：<code>lpush 键 值1 值2 值3</code> 在list左边添加值 如果键不存在则创建 插入后的顺序为值3 值2 值1</li>
<li><strong>右端添加</strong>：<code>rpush 键 值1 值2 值3</code> 在list右边添加值 如果键不存在则创建 插入后的顺序为值1 值2 值3</li>
<li><strong>查看</strong>：<code>lrange 键 开始下标 结束下标</code> 包括开始不包括结束 下标可以从0开始 也可以从-1开始，-1就表示倒数第一个</li>
<li><strong>左端弹出</strong>：<code>lpop 键</code> 删除掉list左边第一个元素</li>
<li><strong>右端弹出</strong>：<code>rpop 键</code> 删除掉list右边第一个元素</li>
<li><strong>获取列表中元素的个数</strong>： <code>llen 键</code> 如果键不存在，返回0</li>
<li><strong>list存在时，左端添加</strong>：<code>lpushx 键 值</code> 键存在则添加，键不存在不添加</li>
<li><strong>list存在时，右端添加</strong>：<code>rpushx 键 值</code> 键存在则添加，键不存在不添加</li>
<li><strong>批量删除某个元素</strong>：<code>lrem 键 个数 元素</code> 个数为正数则从左往右删除 个数为负数则从右往左删除 个数为0则删除所有 举例 lrem nameList 2 tom 表示从左往右删除 nameList 中2个 tom 元素。lrem nameList -3 joy 表示从右往左删除 nameList 中3个 joy 元素。lrem nameList 0 ros 删除nameList中所以的 ros</li>
<li><strong>修改某一下标的值</strong>：<code>lset 键 下标的值</code> 下标可以从0开始 也可以从-1开始，-1就表示倒数第一个 如果下标存在则覆盖原有值 如果下标不存在则报错</li>
<li><strong>在某个元素之前插入元素</strong> ：<code>linsert 键 before 元素 要插入的元素</code> 从左往右匹配第一个找到的元素 插入之后，插入点后面的元素下标+1</li>
<li><strong>在某个元素之后插入元素</strong> ：<code>linsert 键 after 元素 要插入的元素</code> 从左往右匹配第一个找到的元素 插入之后，插入点后面的元素下标+1</li>
<li><strong>将链表a的尾部元素弹出插入到链表b的头部</strong>：<code>rpoplpush 键a 键b</code> 完成之后 链表a会少一个元素 链表b会多一个元素</li>
</ul>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set 可以看成是没有排序的字符集合，和list不同的是 set 中不允许出现重复元素<br>一个set 最多可以包含 232 - 1 个元素</p>
<h3 id="set-常用命令"><a href="#set-常用命令" class="headerlink" title="set 常用命令"></a>set 常用命令</h3><ul>
<li><strong>添加元素</strong>：<code>sadd 键 元素1 元素2 元素3</code> 重复的元素只会保留一份</li>
<li><strong>删除元素</strong>：<code>srem 键 元素1 元素2</code></li>
<li><strong>查看元素</strong>：<code>smembers 键</code> 它会列出所有的元素</li>
<li><strong>查看set中是否包含某元素</strong>：<code>sismember 键 元素</code> 返回1表示存在 0表示不存在</li>
<li><strong>获取set中元素的数量</strong>： <code>scard 键</code></li>
<li><strong>随机获取一个元素</strong>： <code>srandmember 键</code></li>
</ul>
<h4 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h4><p>假设 set1 中有 a、b、c， set2 中有 1、2、c</p>
<ul>
<li><strong>差集(补集)运算</strong>： <code>sdiff 键a 键b</code> 谁在前面，求谁的差集(补集)</li>
</ul>
<p>set1的差集(补集)为红色部分中的 1、2，命令写作 <code>sdiff set1 set2</code></p>
<p><img src="http://image.winrains.cn/2019/08/20190829134305-4eff6.png" alt="img"></p>
<p>set2的差集(补集)为红色部分中的 a、b，命令写作 <code>sdiff set2 set1</code></p>
<p><img src="http://image.winrains.cn/2019/08/20190829134305-cd37f.png" alt="img"></p>
<ul>
<li><p><strong>存储差集(补集)到新set</strong>：<code>sdiffstore 新集合 集合1 集合2</code> 将集合1的差集(补集) 存入新集合</p>
</li>
<li><p>交集运算</p>
<p>：</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">sinter</span> <span class="comment">键a</span> <span class="comment">键b</span></span></pre></td></tr></table></figure>

<p> 结果是两个set 中都有的元素</p>
<p><img src="http://image.winrains.cn/2019/08/20190829134306-4b266.png" alt="img"></p>
</li>
<li><p><strong>存储交集到新set</strong>：<code>sinterstore 新集合 集合1 集合2</code> 将集合1 和集合2的交集存入新集合</p>
</li>
<li><p>并集运算</p>
<p>：</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">sunion</span> <span class="comment">键a</span> <span class="comment">键b</span></span></pre></td></tr></table></figure>

<p> 会将两个 set 中的元素合并在一起，重复的元素只会保留一份</p>
<p><img src="http://image.winrains.cn/2019/08/20190829134306-3b37d.png" alt="img"></p>
</li>
<li><p><strong>存储并集到新set</strong>：<code>sunionstore 新集合 集合1 集合2</code> 将集合1 和集合2的并集存入新集合</p>
</li>
</ul>
<h2 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted-set"></a>sorted-set</h2><p>有序的set集合，除了顺序其他都和set一致，比如不允许出现重复元素<br>sorted-set 中的每一个成员都有一个对应的分数，sorted-set 通过分数确定成员的顺序<br>如果两个元素的分数一样，那么按照元素的字典顺序排序</p>
<h3 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h3><ul>
<li><strong>添加元素</strong>：<code>zadd 键 分数1 值1 分数2 值2</code> 例如 zadd sortName 90 张三 93 王五</li>
<li><strong>更新分数</strong>：<code>zadd 键 新分数 值1</code> 例如 zadd sortName 100 张三</li>
<li><strong>获取元素的分数</strong>：<code>zscore 键 值</code></li>
<li><strong>获取元素数量</strong>：<code>zcard 键</code></li>
<li><strong>删除某个元素</strong>：<code>zrem 键 值1 值2</code></li>
<li><strong>查看元素</strong>：<code>zrange 键 序号1 序号2</code> 序号可以从0开始 也可以从-1开始，-1就表示倒数第一个 比如 zrange sortName 0 -1 表示查看 sortName 的第一个元素到最后一个元素</li>
<li><strong>查看元素和对应的分数</strong>：<code>zrange 键 序号1 序号2 withscorse</code> 按分数从小到大排序</li>
<li><strong>查看元素和对应的分数</strong>：<code>zrevrange 键 序号1 序号2 withscorse</code> 按分数从大到小排序</li>
<li><strong>按照排名的范围删除元素</strong>：<code>zremrangebyrank 键 序号1 序号2</code> 包含开始不包含结束</li>
<li><strong>按照分数的范围删除元素</strong>：<code>zremrangebyscore 键 分数1 分数2</code> 包含开始分数不包含结束分数</li>
<li><strong>获取某段分数内的元素</strong>：<code>zrangebyscore 键 分数1 分数2 withscorse limit 数字1 数字2</code> 包含开始分数不包含结束分数， 结果按分数从小到大排序， withscorse是可选参数，加上之后会显示分数 limit也是可选参数，例如 limit 0 2 表示只取结果集的前两位</li>
<li><strong>给元素加分数</strong>：<code>zincrby 键 要加的分数 值</code></li>
<li><strong>获取某段分数中元素的个数</strong>：<code>zcount 键 分数1 分数2</code></li>
</ul>
<blockquote>
<p>作者：我妻礼弥</p>
<p>来源：<a href="https://juejin.im/post/5d64806151882528307e7e79" target="_blank" rel="noopener">https://juejin.im/post/5d64806151882528307e7e79</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>最全的select加锁分析</title>
    <url>/2019/12/26/%E6%9C%80%E5%85%A8%E7%9A%84select%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>大家在面试中有没遇到面试官问你下面六句Sql的区别呢</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ?</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> &lt; ?</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> &lt; ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ? <span class="keyword">for</span> <span class="keyword">update</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> &lt; ? <span class="keyword">for</span> <span class="keyword">update</span></span></pre></td></tr></table></figure>

<a id="more"></a>

<p>如果你能清楚的说出，这六句sql在不同的事务隔离级别下，是否加锁，加的是共享锁还是排他锁，是否存在间隙锁，那这篇文章就没有看的意义了。 之所以写这篇文章是因为目前为止网上这方面的文章太片面，都只说了一半，且大多没指明隔离级别，以及<code>where</code>后跟的是否为索引条件列。在此，我就不一一列举那些有误的文章了，大家可以自行百度一下，大多都是讲不清楚。 OK，要回答这个问题，先问自己三个问题</p>
<ul>
<li>当前事务隔离级别是什么</li>
<li>id列是否存在索引</li>
<li>如果存在索引是聚簇索引还是非聚簇索引呢？</li>
</ul>
<p>OK，开始回答</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ul>
<li>innodb一定存在聚簇索引，默认以主键作为聚簇索引</li>
<li>有几个索引，就有几棵B+树(不考虑hash索引的情形)</li>
<li>聚簇索引的叶子节点为磁盘上的真实数据。非聚簇索引的叶子节点还是索引，指向聚簇索引B+树。</li>
</ul>
<p>下面啰嗦点基础知识</p>
<h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><p><strong>共享锁</strong>(S锁):假设事务T1对数据A加上共享锁，那么事务T2<strong>可以</strong>读数据A，<strong>不能</strong>修改数据A。<br><strong>排他锁</strong>(X锁):假设事务T1对数据A加上共享锁，那么事务T2<strong>不能</strong>读数据A，<strong>不能</strong>修改数据A。 我们通过<code>update</code>、<code>delete</code>等语句加上的锁都是行级别的锁。只有<code>LOCK TABLE … READ</code>和<code>LOCK TABLE … WRITE</code>才能申请表级别的锁。<br><strong>意向共享锁</strong>(IS锁):一个事务在获取（任何一行/或者全表）S锁之前，一定会先在所在的表上加IS锁。<br><strong>意向排他锁</strong>(IX锁):一个事务在获取（任何一行/或者全表）X锁之前，一定会先在所在的表上加IX锁。</p>
<blockquote>
<p><strong>意向锁存在的目的?</strong></p>
</blockquote>
<p>OK，这里说一下意向锁存在的目的。假设事务T1，用X锁来锁住了表上的几条记录，那么此时表上存在IX锁，即意向排他锁。那么此时事务T2要进行<code>LOCK TABLE … WRITE</code>的表级别锁的请求，可以直接根据意向锁是否存在而判断是否有锁冲突。</p>
<h3 id="加锁算法"><a href="#加锁算法" class="headerlink" title="加锁算法"></a>加锁算法</h3><p>我的说法是来自官方文档: <code>https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html</code> 加上自己矫揉造作的见解得出。<br>ok，记得如下三种，本文就够用了<br><code>Record Locks</code>：简单翻译为行锁吧。注意了，该锁是对索引记录进行加锁！锁是在加索引上而不是行上的。注意了，innodb一定存在聚簇索引，因此行锁最终都会落到聚簇索引上！<br><code>Gap Locks</code>：简单翻译为间隙锁，是对索引的间隙加锁，其目的只有一个，防止其他事物插入数据。在<code>Read Committed</code>隔离级别下，不会使用间隙锁。这里我对官网补充一下，隔离级别比<code>Read Committed</code>低的情况下，也不会使用间隙锁，如隔离级别为<code>Read Uncommited</code>时，也不存在间隙锁。当隔离级别为<code>Repeatable Read</code>和<code>Serializable</code>时，就会存在间隙锁。<br><code>Next-Key Locks</code>：这个理解为<code>Record Lock</code>+索引前面的<code>Gap Lock</code>。记住了，锁住的是索引前面的间隙！比如一个索引包含值，10，11，13和20。那么，间隙锁的范围如下</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(negative infinity, <span class="number">10</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">(<span class="number">10</span>, <span class="number">11</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">(<span class="number">11</span>, <span class="number">13</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">(<span class="number">13</span>, <span class="number">20</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">(<span class="number">20</span>, positive infinity)</span></pre></td></tr></table></figure>

<h3 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h3><p>最后一点基础知识了，大家坚持看完，这些是后面分析的基础！ 在mysql中select分为快照读和当前读，执行下面的语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ?;</span></pre></td></tr></table></figure>

<p>执行的是快照读，读的是数据库记录的快照版本，是不加锁的。（这种说法在隔离级别为<code>Serializable</code>中不成立，后面我会补充。） 那么，执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span></pre></td></tr></table></figure>

<p>会对读取记录加S锁 (共享锁)，执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ? <span class="keyword">for</span> <span class="keyword">update</span></span></pre></td></tr></table></figure>

<p>会对读取记录加X锁 (排他锁)，那么</p>
<blockquote>
<p><strong>加的是表锁还是行锁呢？</strong></p>
</blockquote>
<p>针对这点，我们先回忆一下事务的四个隔离级别，他们由弱到强如下所示:</p>
<ul>
<li><code>Read Uncommited(RU)</code>：读未提交，一个事务可以读到另一个事务未提交的数据！</li>
<li><code>Read Committed (RC)</code>：读已提交，一个事务可以读到另一个事务已提交的数据!</li>
<li><code>Repeatable Read (RR)</code>:可重复读，加入间隙锁，一定程度上避免了幻读的产生！注意了，只是一定程度上，并没有完全避免!我会在下一篇文章说明!另外就是记住从该级别才开始加入间隙锁(这句话记下来，后面有用到)!</li>
<li><code>Serializable</code>：串行化，该级别下读写串行化，且所有的<code>select</code>语句后都自动加上<code>lock in share mode</code>，即使用了共享锁。因此在该隔离级别下，使用的是当前读，而不是快照读。</li>
</ul>
<p>那么关于是表锁还是行锁，大家可以看到网上最流传的一个说法是这样的，</p>
<blockquote>
<p><strong>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。 InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong></p>
</blockquote>
<p>这句话大家可以搜一下，都是你抄我的，我抄你的。那么，这句话本身有两处错误！ <strong>错误一</strong>:并不是用表锁来实现锁表的操作，而是利用了<code>Next-Key Locks</code>，也可以理解为是用了行锁+间隙锁来实现锁表的操作! 为了便于说明，我来个例子，假设有表数据如下，pId为主键索引</p>
<table>
<thead>
<tr>
<th>pId(int)</th>
<th>name(varchar)</th>
<th>num(int)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>aaa</td>
<td>100</td>
</tr>
<tr>
<td>2</td>
<td>bbb</td>
<td>200</td>
</tr>
<tr>
<td>7</td>
<td>ccc</td>
<td>200</td>
</tr>
</tbody></table>
<p>执行语句(name列无索引)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">`aaa`</span> <span class="keyword">for</span> <span class="keyword">update</span></span></pre></td></tr></table></figure>

<p>那么此时在pId=1,2,7这三条记录上存在行锁(把行锁住了)。另外，在(-∞,1)(1,2)(2,7)(7,+∞)上存在间隙锁(把间隙锁住了)。因此，给人一种整个表锁住的错觉！<br><code>ps:</code>对该结论有疑问的，可自行执行<code>show engine innodb status;</code>语句进行分析。<br><strong>错误二</strong>:所有文章都不提隔离级别！<br>注意我上面说的，之所以能够锁表，是通过行锁+间隙锁来实现的。那么，<code>RU</code>和<code>RC</code>都不存在间隙锁，这种说法在<code>RU</code>和<code>RC</code>中还能成立么？ 因此，该说法只在<code>RR</code>和<code>Serializable</code>中是成立的。如果隔离级别为<code>RU</code>和<code>RC</code>，无论条件列上是否有索引，都不会锁表，只锁行！</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>下面来对开始的问题作出解答，假设有表如下，pId为主键索引</p>
<table>
<thead>
<tr>
<th>pId(int)</th>
<th>name(varchar)</th>
<th>num(int)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>aaa</td>
<td>100</td>
</tr>
<tr>
<td>2</td>
<td>bbb</td>
<td>200</td>
</tr>
<tr>
<td>3</td>
<td>bbb</td>
<td>300</td>
</tr>
<tr>
<td>7</td>
<td>ccc</td>
<td>200</td>
</tr>
</tbody></table>
<h4 id="RC-RU-条件列非索引"><a href="#RC-RU-条件列非索引" class="headerlink" title="RC/RU+条件列非索引"></a>RC/RU+条件列非索引</h4><p>(1)<code>select * from table where num = 200</code><br>不加任何锁，是快照读。<br>(2)<code>select * from table where num &gt; 200</code><br>不加任何锁，是快照读。<br>(3)<code>select * from table where num = 200 lock in share mode</code><br>当num = 200，有两条记录。这两条记录对应的pId=2，7，因此在pId=2，7的聚簇索引上加行级S锁，采用当前读。<br>(4)<code>select * from table where num &gt; 200 lock in share mode</code><br>当num &gt; 200，有一条记录。这条记录对应的pId=3，因此在pId=3的聚簇索引上加上行级S锁，采用当前读。<br>(5)<code>select * from table where num = 200 for update</code><br>当num = 200，有两条记录。这两条记录对应的pId=2，7，因此在pId=2，7的聚簇索引上加行级X锁，采用当前读。<br>(6)<code>select * from table where num &gt; 200 for update</code><br>当num &gt; 200，有一条记录。这条记录对应的pId=3，因此在pId=3的聚簇索引上加上行级X锁，采用当前读。</p>
<h4 id="RC-RU-条件列是聚簇索引"><a href="#RC-RU-条件列是聚簇索引" class="headerlink" title="RC/RU+条件列是聚簇索引"></a>RC/RU+条件列是聚簇索引</h4><p>恩，大家应该知道pId是主键列，因此pId用的就是聚簇索引。此情况其实和<strong>RC/RU+条件列非索引</strong>情况是类似的。<br>(1)<code>select * from table where pId = 2</code><br>不加任何锁，是快照读。<br>(2)<code>select * from table where pId &gt; 2</code><br>不加任何锁，是快照读。<br>(3)<code>select * from table where pId = 2 lock in share mode</code><br>在pId=2的聚簇索引上，加S锁，为当前读。<br>(4)<code>select * from table where pId &gt; 2 lock in share mode</code><br>在pId=3，7的聚簇索引上，加S锁，为当前读。<br>(5)<code>select * from table where pId = 2 for update</code><br>在pId=2的聚簇索引上，加X锁，为当前读。<br>(6)<code>select * from table where pId &gt; 2 for update</code><br>在pId=3，7的聚簇索引上，加X锁，为当前读。<br>这里，大家可能有疑问</p>
<blockquote>
<p><strong>为什么条件列加不加索引，加锁情况是一样的？</strong></p>
</blockquote>
<p>ok,其实是不一样的。在RC/RU隔离级别中，MySQL Server做了优化。在条件列没有索引的情况下，尽管通过聚簇索引来扫描全表，进行全表加锁。但是，MySQL Server层会进行过滤并把不符合条件的锁当即释放掉，因此你看起来最终结果是一样的。但是<strong>RC/RU+条件列非索引</strong>比本例多了一个释放不符合条件的锁的过程！</p>
<h4 id="RC-RU-条件列是非聚簇索引"><a href="#RC-RU-条件列是非聚簇索引" class="headerlink" title="RC/RU+条件列是非聚簇索引"></a>RC/RU+条件列是非聚簇索引</h4><p>我们在num列上建上非唯一索引。此时有一棵聚簇索引(主键索引，pId)形成的B+索引树，其叶子节点为硬盘上的真实数据。以及另一棵非聚簇索引(非唯一索引，num)形成的B+索引树，其叶子节点依然为索引节点，保存了num列的字段值，和对应的聚簇索引。<br>接下来分析开始<br>(1)<code>select * from table where num = 200</code><br>不加任何锁，是快照读。<br>(2)<code>select * from table where num &gt; 200</code><br>不加任何锁，是快照读。<br>(3)<code>select * from table where num = 200 lock in share mode</code><br>当num = 200，由于num列上有索引，因此先在 num = 200的两条索引记录上加行级S锁。接着，去聚簇索引树上查询，这两条记录对应的pId=2，7，因此在pId=2，7的聚簇索引上加行级S锁，采用当前读。<br>(4)<code>select * from table where num &gt; 200 lock in share mode</code><br>当num &gt; 200，由于num列上有索引，因此先在符合条件的 num = 300的一条索引记录上加行级S锁。接着，去聚簇索引树上查询，这条记录对应的pId=3，因此在pId=3的聚簇索引上加行级S锁，采用当前读。<br>(5)<code>select * from table where num = 200 for update</code><br>当num = 200，由于num列上有索引，因此先在 num = 200的两条索引记录上加行级X锁。接着，去聚簇索引树上查询，这两条记录对应的pId=2，7，因此在pId=2，7的聚簇索引上加行级X锁，采用当前读。<br>(6)<code>select * from table where num &gt; 200 for update</code><br>当num &gt; 200，由于num列上有索引，因此先在符合条件的 num = 300的一条索引记录上加行级X锁。接着，去聚簇索引树上查询，这条记录对应的pId=3，因此在pId=3的聚簇索引上加行级X锁，采用当前读。</p>
<h4 id="RR-Serializable-条件列非索引"><a href="#RR-Serializable-条件列非索引" class="headerlink" title="RR/Serializable+条件列非索引"></a>RR/Serializable+条件列非索引</h4><p>RR级别需要多考虑的就是gap lock，他的加锁特征在于，无论你怎么查都是锁全表。如下所示 接下来分析开始<br>(1)<code>select * from table where num = 200</code><br>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，在pId = 1,2,3,7（全表所有记录）的聚簇索引上加S锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock<br>(2)<code>select * from table where num &gt; 200</code><br>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，在pId = 1,2,3,7（全表所有记录）的聚簇索引上加S锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock<br>(3)<code>select * from table where num = 200 lock in share mode</code><br>在pId = 1,2,3,7（全表所有记录）的聚簇索引上加S锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock<br>(4)<code>select * from table where num &gt; 200 lock in share mode</code><br>在pId = 1,2,3,7（全表所有记录）的聚簇索引上加S锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock<br>(5)<code>select * from table where num = 200 for update</code><br>在pId = 1,2,3,7（全表所有记录）的聚簇索引上加X锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock<br>(6)<code>select * from table where num &gt; 200 for update</code><br>在pId = 1,2,3,7（全表所有记录）的聚簇索引上加X锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock</p>
<h4 id="RR-Serializable-条件列是聚簇索引"><a href="#RR-Serializable-条件列是聚簇索引" class="headerlink" title="RR/Serializable+条件列是聚簇索引"></a>RR/Serializable+条件列是聚簇索引</h4><p>恩，大家应该知道pId是主键列，因此pId用的就是聚簇索引。该情况的加锁特征在于，如果<code>where</code>后的条件为精确查询(<code>=</code>的情况)，那么只存在record lock。如果<code>where</code>后的条件为范围查询(<code>&gt;</code>或<code>&lt;</code>的情况)，那么存在的是record lock+gap lock。<br>(1)<code>select * from table where pId = 2</code><br>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，是当前读，在pId=2的聚簇索引上加S锁，不存在gap lock。<br>(2)<code>select * from table where pId &gt; 2</code><br>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，是当前读，在pId=3,7的聚簇索引上加S锁。在(2,3)(3,7)(7,+∞)加上gap lock<br>(3)<code>select * from table where pId = 2 lock in share mode</code><br>是当前读，在pId=2的聚簇索引上加S锁，不存在gap lock。<br>(4)<code>select * from table where pId &gt; 2 lock in share mode</code><br>是当前读，在pId=3,7的聚簇索引上加S锁。在(2,3)(3,7)(7,+∞)加上gap lock<br>(5)<code>select * from table where pId = 2 for update</code><br>是当前读，在pId=2的聚簇索引上加X锁。<br>(6)<code>select * from table where pId &gt; 2 for update</code><br>在pId=3,7的聚簇索引上加X锁。在(2,3)(3,7)(7,+∞)加上gap lock<br>(7)<code>select * from table where pId = 6 [lock in share mode|for update]</code><br>注意了，pId=6是不存在的列，这种情况会在(3,7)上加gap lock。<br>(8)<code>select * from table where pId &gt; 18 [lock in share mode|for update]</code><br>注意了，pId&gt;18，查询结果是空的。在这种情况下，是在(7,+∞)上加gap lock。</p>
<h4 id="RR-Serializable-条件列是非聚簇索引"><a href="#RR-Serializable-条件列是非聚簇索引" class="headerlink" title="RR/Serializable+条件列是非聚簇索引"></a>RR/Serializable+条件列是非聚簇索引</h4><p>这里非聚簇索引，需要区分是否为唯一索引。因为如果是非唯一索引，间隙锁的加锁方式是有区别的。<br>先说一下，唯一索引的情况。如果是唯一索引，情况和<strong>RR/Serializable+条件列是聚簇索引</strong>类似，唯一有区别的是:这个时候有两棵索引树，加锁是加在对应的非聚簇索引树和聚簇索引树上！大家可以自行推敲!<br>下面说一下，非聚簇索引是非唯一索引的情况，他和唯一索引的区别就是通过索引进行精确查询以后，不仅存在record lock，还存在gap lock。而通过唯一索引进行精确查询后，只存在record lock，不存在gap lock。老规矩在num列建立非唯一索引<br>(1)<code>select * from table where num = 200</code><br>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，是当前读，在pId=2，7的聚簇索引上加S锁，在num=200的非聚集索引上加S锁，在(100,200)(200,300)加上gap lock。<br>(2)<code>select * from table where num &gt; 200</code><br>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，是当前读，在pId=3的聚簇索引上加S锁，在num=300的非聚集索引上加S锁。在(200,300)(300,+∞)加上gap lock<br>(3)<code>select * from table where num = 200 lock in share mode</code><br>是当前读，在pId=2，7的聚簇索引上加S锁，在num=200的非聚集索引上加S锁，在(100,200)(200,300)加上gap lock。<br>(4)<code>select * from table where num &gt; 200 lock in share mode</code><br>是当前读，在pId=3的聚簇索引上加S锁，在num=300的非聚集索引上加S锁。在(200,300)(300,+∞)加上gap lock。<br>(5)<code>select * from table where num = 200 for update</code><br>是当前读，在pId=2，7的聚簇索引上加S锁，在num=200的非聚集索引上加X锁，在(100,200)(200,300)加上gap lock。<br>(6)<code>select * from table where num &gt; 200 for update</code><br>是当前读，在pId=3的聚簇索引上加S锁，在num=300的非聚集索引上加X锁。在(200,300)(300,+∞)加上gap lock<br>(7)<code>select * from table where num = 250 [lock in share mode|for update]</code><br>注意了，num=250是不存在的列，这种情况会在(200,300)上加gap lock。<br>(8)<code>select * from table where num &gt; 400 [lock in share mode|for update]</code><br>注意了，pId&gt;400，查询结果是空的。在这种情况下，是在(400,+∞)上加gap lock。</p>
<blockquote>
<p>作者：RDJ</p>
<p>来源：<a href="https://juejin.im/post/5d5671a2e51d45620821cea7" target="_blank" rel="noopener">https://juejin.im/post/5d5671a2e51d45620821cea7</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型中的通配符</title>
    <url>/2019/12/26/Java%E6%B3%9B%E5%9E%8B%E4%B8%AD%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许开发者在编译时检测到非法的类型。<br>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<a id="more"></a>

<h2 id="泛型带来的好处"><a href="#泛型带来的好处" class="headerlink" title="泛型带来的好处"></a>泛型带来的好处</h2><p>在没有泛型的情况的下，通过对类型 Object 的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是本身就是一个安全隐患。<br>那么泛型的好处就是在编译的时候能够检查类型安全，并且所有的强制转换都是自动和隐式的。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperGeneric</span>&lt;T&gt; &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> T t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">this</span>.t = t; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// do nothing</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    * 不指定类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noSpecifyType</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        GlmapperGeneric glmapperGeneric = <span class="keyword">new</span> GlmapperGeneric();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        glmapperGeneric.<span class="built_in">set</span>(<span class="string">"test"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 需要强制类型转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">String</span> test = (<span class="keyword">String</span>) glmapperGeneric.<span class="built_in">get</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(test);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 指定类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specifyType</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        GlmapperGeneric&lt;<span class="keyword">String</span>&gt; glmapperGeneric = <span class="keyword">new</span> GlmapperGeneric();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        glmapperGeneric.<span class="built_in">set</span>(<span class="string">"test"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 不需要强制类型转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">String</span> test = glmapperGeneric.<span class="built_in">get</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(test);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面这段代码中的 specifyType 方法中 省去了强制转换，可以在编译时候检查类型安全，可以用在类，方法，接口上。</p>
<h2 id="泛型中通配符"><a href="#泛型中通配符" class="headerlink" title="泛型中通配符"></a>泛型中通配符</h2><p>我们在定义泛型类，泛型方法，泛型接口的时候经常会碰见很多不同的通配符，比如 T，E，K，V 等等，这些通配符又都是什么意思呢？</p>
<h3 id="常用的-T，E，K，V，？"><a href="#常用的-T，E，K，V，？" class="headerlink" title="常用的 T，E，K，V，？"></a>常用的 T，E，K，V，？</h3><p>本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。<strong>通常情况下，T，E，K，V，？ 是这样约定的：</strong></p>
<ul>
<li>？ 表示不确定的 java 类型</li>
<li>T (type) 表示具体的一个java类型</li>
<li>K V (key value) 分别代表java键值中的Key Value</li>
<li>E (element) 代表Element</li>
</ul>
<h3 id="？-无界通配符"><a href="#？-无界通配符" class="headerlink" title="？ 无界通配符"></a>？ <strong>无界通配符</strong></h3><p>先从一个小例子看起，原文在 <a href="https://link.juejin.im?target=https%3A%2F%2Fcodeday.me%2Fbug%2F20180113%2F116421.html">这里</a> 。<br>我有一个父类 Animal 和几个子类，如狗、猫等，现在我需要一个动物的列表，我的第一个想法是像这样的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">List<span class="tag">&lt;<span class="name">Animal</span>&gt;</span> listAnimals</span></pre></td></tr></table></figure>

<p>但是老板的想法确实这样的：</p>
<figure class="highlight capnproto"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;? <span class="keyword">extends</span> Animal&gt; listAnimals</span></pre></td></tr></table></figure>

<p>为什么要使用通配符而不是简单的泛型呢？通配符其实在声明局部变量时是没有什么意义的，但是当你为一个方法声明一个参数时，它是非常重要的。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countLegs</span> <span class="params">(List&lt;? extends Animal &gt; animals )</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> ( Animal animal : animals )</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        retVal += animal.countLegs();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> retVal;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countLegs1</span> <span class="params">(List&lt; Animal &gt; animals )</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> ( Animal animal : animals )</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        retVal += animal.countLegs();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> retVal;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;Dog&gt; dogs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 不会报错</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    countLegs( dogs );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 报错</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    countLegs1(dogs);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>当调用 countLegs1 时，就会飘红，提示的错误信息如下：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829135619-25fc4.png" alt="img"></p>
<p>所以，对于不确定或者不关心实际要操作的类型，可以使用无限制通配符（尖括号里一个问号，即 &lt;?&gt; ），表示可以持有任何类型。像 countLegs 方法中，限定了上届，但是不关心具体类型是什么，所以对于传入的 Animal 的所有子类都可以支持，并且不会报错。而 countLegs1 就不行。</p>
<h3 id="上界通配符-lt-extends-E-gt"><a href="#上界通配符-lt-extends-E-gt" class="headerlink" title="上界通配符 &lt; ? extends E&gt;"></a>上界通配符 &lt; ? extends E&gt;</h3><blockquote>
<p>上届：用 extends 关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。</p>
</blockquote>
<p>在类型参数中使用 extends 表示这个泛型中的参数必须是 E 或者 E 的子类，这样有两个好处：</p>
<ul>
<li>如果传入的类型不是 E 或者 E 的子类，编译不成功</li>
<li>泛型中可以使用 E 的方法，要不然还得强转成 E 才能使用</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;K <span class="keyword">extends</span> A, E <span class="keyword">extends</span> B&gt; <span class="function">E <span class="title">test</span><span class="params">(K arg1, E arg2)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    E result = arg2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    arg2.compareTo(arg1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//.....</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> result;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>类型参数列表中如果有多个类型参数上限，用逗号分开</p>
</blockquote>
<h3 id="下界通配符-lt-super-E-gt"><a href="#下界通配符-lt-super-E-gt" class="headerlink" title="下界通配符 &lt; ? super E&gt;"></a>下界通配符 &lt; ? super E&gt;</h3><blockquote>
<p>下界: 用 super 进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object</p>
</blockquote>
<p>在类型参数中使用 super 表示这个泛型中的参数必须是 E 或者 E 的父类。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;<span class="type">T</span>&gt; void test(<span class="type">List</span>&lt;? <span class="keyword">super</span> <span class="type">T</span>&gt; dst, <span class="type">List</span>&lt;<span class="type">T</span>&gt; src)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="type">T</span> t : src) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dst.add(t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public static void main(<span class="type">String</span>[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="type">List</span>&lt;<span class="type">Dog</span>&gt; dogs = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="type">List</span>&lt;<span class="type">Animal</span>&gt; animals = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">new</span> <span class="type">Test3</span>().test(animals,dogs);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Dog 是 Animal 的子类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>dst 类型 “大于等于” src 的类型，这里的“大于等于”是指 dst 表示的范围比 src 要大，因此装得下 dst 的容器也就能装 src 。</p>
<h3 id="？-和-T-的区别"><a href="#？-和-T-的区别" class="headerlink" title="？ 和 T 的区别"></a>？ 和 T 的区别</h3><p><img src="http://image.winrains.cn/2019/08/20190829135619-75ae8.png" alt="img"></p>
<p>？和 T 都表示不确定的类型，区别在于我们可以对 T 进行操作，但是对 ？ 不行，比如如下这种 ：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">T t = operate<span class="comment">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 不可以</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">？ car = operate<span class="comment">()</span>;</span></pre></td></tr></table></figure>

<p>简单总结下：<br>T 是一个 确定的 类型，通常用于泛型类和泛型方法的定义，？是一个 不确定 的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。</p>
<h4 id="区别1：通过-T-来-确保-泛型参数的一致性"><a href="#区别1：通过-T-来-确保-泛型参数的一致性" class="headerlink" title="区别1：通过 T 来 确保 泛型参数的一致性"></a>区别1：通过 T 来 确保 泛型参数的一致性</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 T 来 确保 泛型参数的一致性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="built_in">Number</span>&gt; <span class="built_in">void</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">test(List&lt;T&gt; dest, List&lt;T&gt; src)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">test(List&lt;? <span class="keyword">extends</span> <span class="built_in">Number</span>&gt; dest, List&lt;? <span class="keyword">extends</span> <span class="built_in">Number</span>&gt; src)</span></pre></td></tr></table></figure>

<p>像下面的代码中，约定的 T 是 Number 的子类才可以，但是申明时是用的 String ，所以就会飘红报错。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829135620-2b52e.png" alt="img"></p>
<p>不能保证两个 List 具有相同的元素类型的情况</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">GlmapperGeneric&lt;<span class="keyword">String</span>&gt; glmapperGeneric = <span class="keyword">new</span> <span class="type">GlmapperGeneric</span>&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;<span class="keyword">String</span>&gt; dest = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;Number&gt; src = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">glmapperGeneric.testNon(dest,src);</span></pre></td></tr></table></figure>

<p>上面的代码在编译器并不会报错，但是当进入到 testNon 方法内部操作时（比如赋值），对于 dest 和 src 而言，就还是需要进行类型转换。</p>
<h4 id="区别2：类型参数可以多重限定而通配符不行"><a href="#区别2：类型参数可以多重限定而通配符不行" class="headerlink" title="区别2：类型参数可以多重限定而通配符不行"></a>区别2：类型参数可以多重限定而通配符不行</h4><p><img src="http://image.winrains.cn/2019/08/20190829135620-be4a2.png" alt="img"></p>
<p>使用 &amp; 符号设定多重边界（Multi Bounds)，指定泛型类型 T 必须是 MultiLimitInterfaceA 和 MultiLimitInterfaceB 的共有子类型，此时变量 t 就具有了所有限定的方法和属性。对于通配符来说，因为它不是一个确定的类型，所以不能进行多重限定。</p>
<h4 id="区别3：通配符可以使用超类限定而类型参数不行"><a href="#区别3：通配符可以使用超类限定而类型参数不行" class="headerlink" title="区别3：通配符可以使用超类限定而类型参数不行"></a>区别3：通配符可以使用超类限定而类型参数不行</h4><p>类型参数 T 只具有 一种 类型限定方式：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">T <span class="keyword">extends</span> A</span></pre></td></tr></table></figure>

<p>但是通配符 ? 可以进行 两种限定：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">? <span class="keyword">extends</span> A</span></pre></td></tr><tr><td class="code"><pre><span class="line">? <span class="keyword">super</span> A</span></pre></td></tr></table></figure>

<h2 id="Class-和-Class-区别"><a href="#Class-和-Class-区别" class="headerlink" title="Class 和 Class 区别"></a><code>Class</code> 和 <code>Class</code> 区别</h2><p>前面介绍了 ？ 和 T 的区别，那么对于，<code>Class</code> 和 `` 又有什么区别呢？<br><code>Class</code> 和 <code>Class</code><br>最常见的是在反射场景下的使用，这里以用一段发射的代码来说明下。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过反射的方式生成  multiLimit</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 对象，这里比较明显的是，我们需要使用强制类型转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">MultiLimit multiLimit = (MultiLimit)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name(<span class="string">"com.glmapper.bridge.boot.generic.MultiLimit"</span>)</span>.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span></pre></td></tr></table></figure>

<p>对于上述代码，在运行期，如果反射的类型不是 MultiLimit 类，那么一定会报 java.lang.ClassCastException 错误。<br>对于这种情况，则可以使用下面的代码来代替，使得在在编译期就能直接 检查到类型的问题：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829135621-e19b0.png" alt="img"></p>
<p><code>Class</code> 在实例化的时候，T 要替换成具体类。<code>Class</code> 它是个通配泛型，? 可以代表任何类型，所以主要用于声明时的限制情况。比如，我们可以这样做申明：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Class</span>&lt;?&gt; clazz;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 不可以，因为 T 需要指定类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Class</span>&lt;T&gt; clazzT;</span></pre></td></tr></table></figure>

<p>所以当不知道定声明什么类型的 Class 的时候可以定义一 个Class&lt;?&gt;。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829135622-b7ad1.png" alt="img"></p>
<p>那如果也想 <code>public Class clazzT;</code> 这样的话，就必须让当前的类也指定 T ，</p>
<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span>&lt;<span class="title">T</span>&gt; &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">Class</span>&lt;?&gt; <span class="title">clazz</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    // 不会报错</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">Class</span>&lt;<span class="title">T</span>&gt; <span class="title">clazzT</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文零碎整理了下 JAVA 泛型中的一些点，不是很全，仅供参考。如果文中有不当的地方，欢迎指正。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.toutiao.com%2Fa6694132392728199683">JAVA泛型通配符T，E，K，V区别，网友回复：一文秒懂</a></li>
</ul>
<blockquote>
<p>作者：glmapper</p>
<p>来源：<a href="https://juejin.im/post/5d5789d26fb9a06ad0056bd9" target="_blank" rel="noopener">https://juejin.im/post/5d5789d26fb9a06ad0056bd9</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring AOP介绍</title>
    <url>/2019/12/26/Spring-AOP%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="为什么要有aop"><a href="#为什么要有aop" class="headerlink" title="为什么要有aop"></a>为什么要有aop</h3><p>我们都知道Java是一种面向对象编程【也就是OOP】的语言，不得不说面向对象编程是一种及其优秀的设计，但是任何语言都无法十全十美，对于OOP语言来说，当需要为部分对象引入公共部分的时候，OOP就会引入大量的重复代码【这些代码我们可以称之为横切代码】。而这也是Aop出现的原因，没错，<strong>Aop就是被设计出来弥补OOP短板的</strong>。Aop便是将这些横切代码封装到一个可重用模块中，继而降低模块间的耦合度，这样也有利于后面维护。</p>
<a id="more"></a>

<h3 id="Aop是什么东西"><a href="#Aop是什么东西" class="headerlink" title="Aop是什么东西"></a>Aop是什么东西</h3><p>学过Spring的都知道，Spring内比较核心的功能便是Ioc和Aop，Ioc的主要作用是应用对象之间的解耦，而Aop则可以实现横切代码【如权限、日志等】与他们绑定的对象之间的解耦，举个浅显易懂的小栗子，在用户调用很多接口的地方，我们都需要做权限认证，判断用户是否有调用该接口的权限，如果每个接口都要自己去做类似的处理，未免有点sb了，也不够装x，因此Aop就可以派上用场了，将这些处理的代码放到切片中，定义一下切片、连接点和通知，刷刷刷跑起来就ojbk了。<br>想要了解Aop，就要先理解以下几个术语，如PointCut、Advice、JoinPoint。接下来尽量用白话文描述下。<br><strong>PointCut【切点】</strong> 其实切点的概念很好理解，你想要去切某个东西之前总得先知道要在哪里切入是吧，切点格式如下：execution(* com.nuofankj.springdemo.aop.<em>Service.</em>(..)) 可以看出来，格式使用了正常表达式来定义那个范围内的类、那些接口会被当成切点，简单明了。<br><strong>Advice</strong> Advice行内很多人都定义成了通知，但是我总觉得有点勉强。所谓的Advice其实就是定义了Aop何时被调用，确实有种通知的感觉，何时调用其实也不过以下几种：</p>
<ul>
<li>Before 在方法被调用之前调用</li>
<li>After 在方法完成之后调用</li>
<li>After-returning 在方法成功执行之后调用</li>
<li>After-throwing 在方法抛出异常之后调用</li>
<li>Around 在被通知的方法调用之前和调用之后调用</li>
</ul>
<p><strong>JoinPoint【连接点】</strong> JoinPoint连接点，其实很好理解，上面又有通知、又有切点，那和具体业务的连接点又是什么呢？没错，其实就是对应业务的方法对象，因为我们在横切代码中是有可能需要用到具体方法中的具体数据的，而连接点便可以做到这一点。</p>
<h3 id="给出一个Aop在实际中的应用场景"><a href="#给出一个Aop在实际中的应用场景" class="headerlink" title="给出一个Aop在实际中的应用场景"></a>给出一个Aop在实际中的应用场景</h3><p>先给出两个业务内的接口，一个是聊天，一个是购买东西</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140729-c2c96.png" alt="图片描述"></p>
<p><img src="http://image.winrains.cn/2019/08/20190829140730-705db.png" alt="图片描述"></p>
<p>接下来该给出说了那么久的切片了</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140730-b536d.png" alt="图片描述"></p>
<p>可以从中看到PointCut【切点】是</p>
<blockquote>
<p>execution(* com.nuofankj.springdemo.aop.<em>Service.</em>(..))</p>
</blockquote>
<p>Advice是</p>
<blockquote>
<p>Before</p>
</blockquote>
<p>JoinPoint【连接点】是</p>
<blockquote>
<p>MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod();</p>
</blockquote>
<p>代码浅显易懂，其实就是将ChatService和BuyService里边给userId做权限校验的逻辑抽出来做成切片。<br>那么如何拿到具体业务方法内的具体参数呢？ 这里是定义了一个新的注解</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140731-c3324.png" alt="图片描述"></p>
<p>作用可以直接看注释，使用地方如下</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140732-e1517.png" alt="图片描述"></p>
<p>可以看到对应接口使用了AuthPermission的注解，而取出的地方在于</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140732-ad2a0.png" alt="图片描述"></p>
<p>是的，这样便可以取出来对应的接口传递的userId具体是什么了，而校验逻辑可以自己处理。送佛送到西，不对，撸码撸整套，接下来给出运行的主类</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140733-a9a1f.png" alt="图片描述"></p>
<p>可以看到，上面有一个接口传递的userId是1，另一个是123，而上面权限认证只有1才说通过，否则会抛出异常。运行结果如下</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140734-55ef4.png" alt="图片描述"></p>
<p>运行结果可想而知，1的通过验证，123的失败。</p>
<h3 id="Spring-Aop做了什么【开始源码跟踪阅读】"><a href="#Spring-Aop做了什么【开始源码跟踪阅读】" class="headerlink" title="Spring Aop做了什么【开始源码跟踪阅读】"></a>Spring Aop做了什么【开始源码跟踪阅读】</h3><p>首先给出Main类</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140734-e3249.png" alt="2"></p>
<p>可以看到我这里用的是AnnotationConfigApplicationContext，解释下</p>
<blockquote>
<p>AnnotationConfigApplicationContext是一个用来管理注解bean的容器，所以我可以用该容器取得我定义了@Service注解的类的实例。</p>
</blockquote>
<p>打断点后，启动程序，我们可以看到TestDemo的实例在idea的表现是这样的</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140735-31fda.png" alt="3"></p>
<p>而BuyService的实例却不同</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140736-d6fe1.png" alt="4"></p>
<p>我们可以从看到BuyService是SpringCGLIB强化过的一个实例，那么问题来了</p>
<ul>
<li>为什么BuyService被强化过而TestDemo没有？</li>
<li>SpringCGLIB又是什么？</li>
<li>Spring是在什么时候生成一个强化后的实例的？</li>
</ul>
<p>带着这些疑问，让我们一步步从Spring源码中找到答案。<br><strong>为什么BuyService被强化过而TestDemo没有？</strong><br>这个问题比较简单，我们可以看回上面我对切片的定义</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140737-98698.png" alt="5"></p>
<p>可以从代码中看出，我定义的切点是<em>Service命名的类，而TestDemo很明显不符合这个设定，因此TestDemo逃过被强化的命运。<br>*</em>SpringCGLIB又是什么？**<br>CGLIB其实就是一种实现动态代理的技术，利用了ASM开源包，先将代理对象类的class文件加载进来，之后通过修改其字节码并且生成子类。结合demo来解读便是SpringCGLIB会先将BuyService加载到内存中，之后通过修改字节码生成BuyService的子类，该子类便是强化后的BuyService，上文看到的强化后的实例便是该子类的实例。<br><strong>Spring是在什么时候生成一个强化后的实例的？</strong><br>这个便厉害了，首先，我们要先从Spring如何加载切片入手。</p>
<blockquote>
<p><strong>【思考Time】</strong> 为什么我会选择从切片入手呢？原因很简单，Spring就是因为发现了切片，并且对切片进行解析后才知道了要强化哪些类。</p>
</blockquote>
<p><img src="http://image.winrains.cn/2019/08/20190829140737-9f030.png" alt="6"></p>
<p>切片的处理第一步便是要加上@Aspect注解，学过注解的都知道，注解的作用更多的是标志识别，也就是告诉Spring这个类要做相关特殊处理，因此我们可以基于该认识，反调该注解使用的地方</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140738-1885b.png" alt="7"></p>
<p>可以从截图看出，我反调了@Aspect后定位到了AbstractAspectJAdvisorFactory类中的hasAspectAnnotation函数，并且携带参数clazz，因此我猜测该接口就是用来识别clazz是否使用了注解@Aspect的地方，于是我打上了断点，并且加了条件 clazz == AuthAspect.class ，重新启动后</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140740-97aaf.png" alt="8"></p>
<p>我们看到确实被断点到了，可以得出我的猜测是对的。 我们先看下断点后做了什么事情，之后再看下具体是哪里进行了扫描。在断点处按F8继续往下走，最后发现</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140740-1f21b.png" alt="13"></p>
<p>没错，可以看到最终是构建成了一个Advisor对象 ，并且放入了BeanFactoryAspectJAdvisorsBuilder中的advisorsCache中，<strong>这样意味着Spring最终会将使用了@Aspect注解的类构建成Advisor对象后保存进BeanFactoryAspectJAdvisorsBuilder.advisorsCache中。</strong><br>接下来我们看看具体是哪里进行了使用@Aspect注解的相关类的扫描，这次我断点的地方在BeanFactoryAspectJAdvisorsBuilder中的advisorsCache调用了put的地方。</p>
<blockquote>
<p><strong>【思考Time】</strong> 为什么我会选择在advisorsCache调用了put的地方打断点呢？原因很简单，因为我们上面已经分析出@Aspect注解的类构建成Advisor对象后保存进BeanFactoryAspectJAdvisorsBuilder.advisorsCache中，而我通过反调知道put的地方只有一个，因此我可以断定在此处打断点可以知道到底哪里进行了扫描的操作。</p>
</blockquote>
<p><img src="http://image.winrains.cn/2019/08/20190829140741-95484.png" alt="14"></p>
<p>通过打断点后我从idea的Frames面板中看到</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140742-20566.png" alt="19"></p>
<p>没错，做了扫描@Aspect注解的扫描器是AbstractAutoProxyCreator类</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140743-80ddb.png" alt="11"></p>
<p><img src="http://image.winrains.cn/2019/08/20190829140743-99987.png" alt="12"></p>
<p>我们可以从中看到AbstractAutoProxyCreator最终实现了InstantiationAwareBeanPostProcessor接口。</p>
<blockquote>
<p><strong>【思考Time】</strong> 这个接口有什么作用呢？具体可以看我前阵子写的一篇文章：<a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fr2OEqsap6NgaEnNveO1mVg">mp.weixin.qq.com/s/r2OEqsap6…</a></p>
</blockquote>
<p>现在已经找到了扫描注解的地方，并且我们也看到了最终是生成了Advisor对象 ，并且放入了BeanFactoryAspectJAdvisorsBuilder中的advisorsCache中，那么Spring是在什么时候生成强化后的实例的呢？ 接下来我的切入点是AbstractAutoProxyCreator中的postProcessAfterInitialization接口。</p>
<blockquote>
<p><strong>【思考Time】</strong> 之所以会选择AbstractAutoProxyCreator为切入点，是因为通过命名可以看出这是SpringAop用来构建代理[强化]对象的地方，并且由于SpringCGLIB是先将目标类加载到内存中，之后通过修改字节码生成目标类的子类，因此我猜测强化是在目标类实例化后触发postProcessAfterInitialization的时候进行的。</p>
</blockquote>
<p>因此我在postProcessAfterInitialization接口中做了断点，并且加了调试条件。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140744-e739c.png" alt="14"></p>
<p>可以看到我这里断点到了ChatService这个类。</p>
<blockquote>
<p><strong>【思考Time】</strong> 为什么专门断点ChatService这个类？之所以会专门定位这个类，因为我的切面的目标类就包含了ChatService，通过定位到该类，我们可以一步步捕捉Spring的强化操作。</p>
</blockquote>
<p>我们可以看到，生成强化后的对象就藏在wrapIfNecessary中。</p>
<blockquote>
<p><strong>【思考Time】</strong> 为什么我会知道是生成强化后的对象就藏在wrapIfNecessary中呢？因为我通过调试发现，在调用了wrapIfNecessary接口后，返回的对象是强化后的对象。</p>
</blockquote>
<p>那么问题来了，为什么Spring会知道ChatService类需要进行进行强化呢？我们可以从wrapIfNecessary中走入更深一层，通过调试，可以看到</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140744-61c41.png" alt="16"></p>
<p>在此处会从advisorsCache中根据aspectName取出对应的Advisor。拿到Advisor后，便是进行过滤的地方了，通过F8往后走，可以看到过滤的地方在AopUtils.canApply接口中。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140745-70bb8.png" alt="17"></p>
<p>可以看到此处传进来的targetClass符合切面的要求，因此可以进行构建强化对象。 接下来让我们看下真正产生强化对象的地方了</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140746-c6df7.png" alt="18"></p>
<p>我们可以看到在AbstractAutoProxyCreator的createProxy函数中看到，最后会构造出一个强化后的chatService。 那么createProxy又做了什么呢？通过断点一层层深入后，发现最后会到达</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140747-61a37.png" alt="18"></p>
<p>通过源码分析，我们发现在AbstractAutoProxyCreator构建强化对象的时候是调用了createAopProxy函数，重点来了，我们可以看到针对targetClass，也就是ChatService做了判断，如果targetClass有实现接口或者targetClass是Proxy的子类，那么使用的是JDK的动态代理实现AOP，如果不是才会使用CGLIB实现动态代理。<br><strong>那么JDK实现的动态代理和CGLIB实现的动态代理有什么区别吗？</strong> 首先动态代理可以分为两种：JDK动态代理和CGLIB动态代理。从文中我们也可以看出，当目标类有接口的时候才会使用JDK动态代理，其实是因为JDK动态代理无法代理一个没有接口的类。JDK动态代理是利用反射机制生成一个实现代理接口的匿名类，而CGLIB是针对类实现代理，主要是对指定的类生成一个子类，并且覆盖其中的方法。</p>
<h3 id="Aop实现机制之代理模式"><a href="#Aop实现机制之代理模式" class="headerlink" title="Aop实现机制之代理模式"></a>Aop实现机制之代理模式</h3><p>本来想一篇文章说完源码跟踪分析Aop和Aop的实现机制代理模式，发现源码跟踪分析已经很占篇幅了，因此没办法只能再开一篇文章专门阐述Aop的实现机制代理模式，期待下篇文章。<br>大家都知道，我有个习惯，在动手写一篇文章之前会先将该文章相关的资料仔细琢磨一遍，然后再结合源码再调试一遍，结果，说好的</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140748-b1917.png" alt="img"></p>
<p>看源码也确实是</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140748-23b5b.png" alt="img"></p>
<p>源码确实有进行了是否是接口的判断，但是问题来了，我调试的时候发现无论代理类是否有接口，最终都会被强制使用CGLIB代理，没办法，只能翻看SpringBoot的相关文档，最终发现原来SpringBoot从2.0开始就默认使用Cglib代理了，好家伙，怪不得我调试半天找不到原因。<br>那么如何解决呢？肯定是通过配置啦，按照如下配置即可</p>
<blockquote>
<p>在application.properties文件中配置 spring.aop.proxy-target-class=false</p>
</blockquote>
<p>即可。</p>
<blockquote>
<p><strong>【划重点】</strong> 曾经遇见过面试官问，SpringBoot默认代理类型是什么？看完该篇文章，我们就可以果断的回答是Cglib代理了。通过调试代码发现的规则，我想我这辈子都不会忘记这个默认规则。</p>
</blockquote>
<h3 id="动态代理原理剖析"><a href="#动态代理原理剖析" class="headerlink" title="动态代理原理剖析"></a>动态代理原理剖析</h3><h4 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h4><p>简单来说，就是在运行的时候为目标类动态生成代理类，而在操作的时候都是操作代理类，代理模式有个显而易见的好处，那便是可以在不改变对象方法的情况下对方法进行增强。试想下，我们在<a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FtQLO-lF_HiG6YK1kGQeD9w">你必须要懂的Spring-Aop之应用篇</a>有提到使用Aop来做权限认证，如果不用Aop，那么我们就必须要为所有需要权限认证的方法都加上权限认证代码，听起来就觉得<strong>蛋疼</strong>，你觉得对不对？</p>
<h4 id="为什么不用静态代理"><a href="#为什么不用静态代理" class="headerlink" title="为什么不用静态代理"></a>为什么不用静态代理</h4><p>静态代理类不是说不可以用，如果只有一个类需要被代理，那么自然可以用，如 这是在<a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FtQLO-lF_HiG6YK1kGQeD9w">你必须要懂的Spring-Aop之应用篇</a>使用的一个例子类，该类的作用只是打印出我要买东西。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140748-979ec.png" alt="3"></p>
<p>代理类如下</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140749-8c4a0.png" alt="4"></p>
<p>可以看到这个BuyProxy代理类只是塞了一个IBuyServcie接口进行，而且自身也实现了接口IBuyService，而在buyItem方法被调用的时候会先做自己的操作，再调用塞进去的接口的buyItem方法。 测试类很简单，如下</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140750-74a87.png" alt="5"></p>
<p>运行后很自然而然的打印出</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140751-89b3c.png" alt="6"></p>
<p>静态代理就是简单，但是<strong>弊端</strong>也很明显，如果有多个类都需要同样的代理，都实现了同样的接口，那么如果使用静态代理的话，我们就要构造多个Proxy类，就会造成<strong>类爆炸</strong>。 而使用了Aop后，也就是动态代理后，便可以一次性解决该问题了，具体可以看<a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FtQLO-lF_HiG6YK1kGQeD9w">你必须要懂的Spring-Aop之应用篇</a>中的操作方法。</p>
<h4 id="JDK动态代理原理"><a href="#JDK动态代理原理" class="headerlink" title="JDK动态代理原理"></a>JDK动态代理原理</h4><p>这里给出一个JDK动态代理的demo 首先给出一个简单的业务类，Hello类和接口</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140751-69aba.png" alt="7"></p>
<p><img src="http://image.winrains.cn/2019/08/20190829140751-de9d6.png" alt="8"></p>
<p>真正实现了类的代理功能的其实就是这个实现了接口InvocationHandler的JdkProxy类</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140752-d5d78.png" alt="9"></p>
<p>我们可以看到其中必须实现的方法是invoke，可以看到invoke方法的参数带有Method对象，这个就是我们的目标Method，现在我们的目的就是要在这个Method在被调用前后实现我们的业务，可以看到在method.invoke反调前后实现了before和after业务。<br>这里再给出一个Main测试类，作用是取得Hello的代理类，然后调用其中的say方法。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140753-a95d2.png" alt="10"></p>
<p>运行结果如下</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140754-ab525.png" alt="11"></p>
<p><strong>原理很简单</strong> 在JdkProxyMain中hello调用say的时候，由于Hello已经被“代理”了，所以在调用say函数的时候其实是调用JdkProxy类中的invoke函数，而在invoke函数中先是实现了before函数才实现Object result = method.invoke(target, args)，这一句其实是调用say函数，而后才实现after函数，于是这样就可以不必在改动目标类的前提下实现代理了，并且不会像静态代理那样导致类爆炸。</p>
<h4 id="CGLIB动态代理原理"><a href="#CGLIB动态代理原理" class="headerlink" title="CGLIB动态代理原理"></a>CGLIB动态代理原理</h4><p>先给出一个Cglib动态代理的demo</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140754-4e272.png" alt="13"></p>
<p>核心类是实现了MethodInterceptor的CGlibProxy类</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140754-3e363.png" alt="14"></p>
<p>可以看到其中实现了方法intercept，先是在目标函数被调用前实现自己的业务，比如before()和after()，之后再通过 proxy.invokeSuper(obj, args) 触发目标函数。<br>最后给出入口类</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140755-ec283.png" alt="15"></p>
<p>最后给出运行类，运行类如下</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140756-563b0.png" alt="15"></p>
<p>可以看到运行结果</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140756-eeee5.png" alt="16"></p>
<p><strong>原理很简单</strong> 在CglibProxyMain中hello调用say的时候，由于Hello已经被“代理”了，所以在调用say函数的时候其实是调用CGlibProxy类中的intercept函数。</p>
<blockquote>
<p>作者：饭谈编程</p>
<p>来源：<a href="https://juejin.im/post/5d558819e51d45620b21c3a7" target="_blank" rel="noopener">https://juejin.im/post/5d558819e51d45620b21c3a7</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring7大知识点</title>
    <url>/2019/12/26/Spring7%E5%A4%A7%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>Spring框架自诞生以来一直备受开发者青睐，有人亲切的称之为：Spring 全家桶。它包括SpringMVC、SpringBoot、Spring Cloud、Spring Cloud Dataflow等解决方案。<br>很多研发人员把spring看作心目中最好的java项目，没有之一。<br>所以这是重点也是难点，工作中必须会，面试时肯定考。<br><strong>那么，今天花费10分钟，梳理Spring框架相关知识</strong>。</p>
<a id="more"></a>

<h1 id="一、Spring知识点-汇总"><a href="#一、Spring知识点-汇总" class="headerlink" title="一、Spring知识点-汇总"></a>一、Spring知识点-汇总</h1><hr>
<p>spring系列包含非常多的项目，可以满足java开发中的方方面面。<br>先来看常用框架的知识点汇总，如图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829141013-a68f8.png" alt="img"></p>
<h2 id="Ⅰ、5个常用的spring框架"><a href="#Ⅰ、5个常用的spring框架" class="headerlink" title="Ⅰ、5个常用的spring框架"></a>Ⅰ、5个常用的spring框架</h2><hr>
<h3 id="1-spring-framework"><a href="#1-spring-framework" class="headerlink" title="1.spring framework"></a>1.spring framework</h3><p>也就是我们经常说的spring框架，包括了ioc依赖注入，Context上下文、bean管理、springmvc等众多功能模块，其它spring项目比如spring boot也会依赖spring框架。</p>
<h3 id="2-spring-boot"><a href="#2-spring-boot" class="headerlink" title="2.spring boot"></a>2.spring boot</h3><p>它的目标是简化Spring应用和服务的创建、开发与部署，简化了配置文件，使用嵌入式web服务器，含有诸多开箱即用的微服务功能，可以和spring cloud联合部署。<br>Spring Boot的核心思想是约定大于配置，应用只需要很少的配置即可，简化了应用开发模式。</p>
<h3 id="3-Spring-Data"><a href="#3-Spring-Data" class="headerlink" title="3.Spring Data"></a>3.Spring Data</h3><p>是一个数据访问及操作的工具集，封装了多种数据源的操作能力，包括：jdbc、Redis、MongoDB等。</p>
<h3 id="4-Spring-Cloud"><a href="#4-Spring-Cloud" class="headerlink" title="4.Spring Cloud"></a>4.Spring Cloud</h3><p>是一套完整的微服务解决方案，是一系列不同功能的微服务框架的集合。Spring Cloud基于Spring Boot，简化了分布式系统的开发，集成了服务发现、配置管理、消息总线、负载均衡、断路器、数据监控等各种服务治理能力。比如sleuth提供了全链路追踪能力，Netflix套件提供了hystrix熔断器、zuul网关等众多的治理组件。config组件提供了动态配置能力，bus组件支持使用RabbitMQ、kafka、Activemq等消息队列，实现分布式服务之间的事件通信。</p>
<h3 id="5-Spring-Security"><a href="#5-Spring-Security" class="headerlink" title="5. Spring Security"></a>5. Spring Security</h3><p>主要用于快速构建安全的应用程序和服务，在Spring Boot和Spring Security OAuth2的基础上，可以快速实现常见安全模型，如单点登录，令牌中继和令牌交换。你可以了解一下oauth2授权机制和jwt认证方式。oauth2是一种授权机制，规定了完备的授权、认证流程。JWT全称是JSON Web Token，是一种把认证信息包含在token中的认证实现，oauth2授权机制中就可以应用jwt来作为认证的具体实现方法。</p>
<h2 id="Ⅱ、Struts的具体作用"><a href="#Ⅱ、Struts的具体作用" class="headerlink" title="Ⅱ、Struts的具体作用"></a>Ⅱ、Struts的具体作用</h2><hr>
<p>struts是曾经非常火爆的web组合ssh中的控制层。我们知道web服务一般都采用MVC分层模型构建，就是model层负责内部数据模型，controller负责请求的分发控制，view层负责返回给用户展示的视图。struts实现的就是其中控制层的角色。<br>Struts采用Filter实现，针对类进行拦截，每次请求就会创建一个Action。使用struts的SSH组合已经逐渐被使用springMVC的SSM组合代替，也就是Spring-MVC+Spring+MyBatis的组合，一方面原因是由于struts对几次安全漏洞的处理，让大家对struts的信心受到影响；另一方面，springmvc更加的灵活，不需要额外配置，不存在和spring整合等问题，使用更加方便，所以建议以SSM框架的学习为主。</p>
<h2 id="Ⅲ、常用的ORM框架"><a href="#Ⅲ、常用的ORM框架" class="headerlink" title="Ⅲ、常用的ORM框架"></a>Ⅲ、常用的ORM框架</h2><hr>
<p>ORM就是对象关系匹配，是为了解决面向对象与关系数据库存在的互不匹配的问题。简单来说，就是把关系数据库中的数据转换成面向对象程序中的对象。<br>常用的ORM框架有Hibernate和MyBatis，也就是ssh组合和ssm组合中的h与m。<br><strong>它们的特点和区别如下</strong>：<br>Hibernate对数据库结构提供了完整的封装，实现了POJO对象与数据库表之间的映射，能够自动生成并执行SQL语句。只要定义了POJO 到数据库表的映射关系，就可以通过Hibernate提供的方法完成数据库操作。Hibernate符合JPA规范，就是Java持久层API。<br>mybatis通过映射配置文件，将SQL所需的参数和返回的结果字段映射到指定对象，mybatis不会自动生成sql，需要自己定义sql语句，不过更方便对sql语句进行优化。<br><strong>总结起来</strong>：</p>
<ol>
<li>hibernate配置要比mybatis复杂的多，学习成本也比mybatis高。mybatis，简单、高效、灵活，但是需要自己维护sql；</li>
<li>hibernate功能强大、全自动、适配不同数据库，但是非常复杂，灵活性稍差。</li>
</ol>
<h2 id="Ⅳ、Netty简介"><a href="#Ⅳ、Netty简介" class="headerlink" title="Ⅳ、Netty简介"></a>Ⅳ、Netty简介</h2><hr>
<p>Netty是一个高性能的异步事件驱动的网络通信框架，Netty对JDK原生NIO进行封装，简化了网络服务的开发。下文会详细讲解<br>另外，同类型的框架还有mina、grizzly，不过目前使用的相对较少，一般不会在面试中出现，可以作为兴趣简单了解。</p>
<h2 id="Ⅴ、RPC服务"><a href="#Ⅴ、RPC服务" class="headerlink" title="Ⅴ、RPC服务"></a>Ⅴ、RPC服务</h2><hr>
<p>Motan、Dubbo、gRPC都是比较常用的高性能rpc框架，可以提供完善的服务治理能力，java版本的通信层都是基于前面提到的Netty实现。它们的特点稍后介绍。</p>
<h2 id="Ⅵ、其他常用框架"><a href="#Ⅵ、其他常用框架" class="headerlink" title="Ⅵ、其他常用框架"></a>Ⅵ、其他常用框架</h2><hr>
<p>jersy和restEasy都是可以快速开发restful服务的框架。<br>和springmvc相比，这两个框架都是基于jax-rs标准，而springmvcs基于servlet，使用自己构建的API，是两个不同的标准。<br>shiro框架是一个与spring security类似的开源的权限管理框架，用于访问授权、认证、加密及会话管理。能够支持单机与分布式session管理。<br>相比security，shiro更加简单易用。</p>
<h1 id="二、Spring知识点-详解"><a href="#二、Spring知识点-详解" class="headerlink" title="二、Spring知识点-详解"></a>二、Spring知识点-详解</h1><hr>
<h2 id="Ⅰ、spring基本概念"><a href="#Ⅰ、spring基本概念" class="headerlink" title="Ⅰ、spring基本概念"></a>Ⅰ、spring基本概念</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141014-5112a.png" alt="Sping中的基本概念"></p>
<p>本文涉及的流程与实现默认都是基于最新的5.x版本。<br>spring中的几个重要概念如下：</p>
<h3 id="1-IOC"><a href="#1-IOC" class="headerlink" title="1.IOC"></a>1.IOC</h3><p>IOC，就是控制反转，如最左边，拿公司招聘岗位来举例：<br>假设一个公司有产品、研发、测试等岗位。如果是公司根据岗位要求，逐个安排人选，如图中向下的箭头，这是正向流程。如果反过来，不用公司来安排候选人，而是由第三方猎头来匹配岗位和候选人，然后进行推荐，如图中向上的箭头，这就是控制反转。<br>在spring中，对象的属性是由对象自己创建的，就是正向流程；如果属性不是对象创建，而是由spring来自动进行装配，就是控制反转。这里的DI也就是依赖注入，就是实现控制反转的方式。正向流程导致了对象于对象之间的高耦合，IOC可以解决对象耦合的问题，有利于功能的复用，能够使程序的结构变得非常灵活。</p>
<h3 id="2-context上下文和bean"><a href="#2-context上下文和bean" class="headerlink" title="2.context上下文和bean"></a>2.context上下文和bean</h3><p>spring进行IOC实现时使用的有两个概念：context上下文和bean。<br>如中间图所示，所有被spring管理的、由spring创建的、用于依赖注入的对象，就叫做一个bean。Spring创建并完成依赖注入后，所有bean统一放在一个叫做context的上下文中进行管理。</p>
<h3 id="3-AOP"><a href="#3-AOP" class="headerlink" title="3.AOP"></a>3.AOP</h3><p>AOP就是面向切面编程。如右面的图，一般程序执行流程是从controller层调用service层、然后service层调用DAO层访问数据，最后在逐层返回结果。<br>这个是图中向下箭头所示的按程序执行顺序的纵向处理。但是，一个系统中会有多个不同的服务，例如用户服务、商品信息服务等等，每个服务的controller层都需要验证参数，都需要处理异常，如果按照图中红色的部分，对不同服务的纵向处理流程进行横切，在每个切面上完成通用的功能，例如身份认证、验证参数、处理异常等等、这样就不用在每个服务中都写相同的逻辑了，这就是AOP思想解决的问题。<br>AOP以功能进行划分，对服务顺序执行流程中的不同位置进行横切，完成各服务共同需要实现的功能。</p>
<h2 id="Ⅱ、spring框架"><a href="#Ⅱ、spring框架" class="headerlink" title="Ⅱ、spring框架"></a>Ⅱ、spring框架</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141015-b9e55.png" alt="Spring框架组件"></p>
<p>上图列出了spring框架主要包含的组件。这张图来自spring4.x的文档。目前最新的5.x版本中右面的portlet组件已经被废弃掉，同时增加了用于异步响应式处理的WebFlux组件。<br>并不需要对所有的组件都详细了解，只需重点了解最常用的几个组件实现，以及知道每个组件用来实现哪一类功能。<br>图中红框是比较重要的组件，core组件是spring所有组件的核心；bean组件和context组件我刚才提到了，是实现IOC和依赖注入的基础；AOP组件用来实现面向切面编程；web组件包括springmvc是web服务的控制层实现。</p>
<h2 id="Ⅲ、spring中机制和实现"><a href="#Ⅲ、spring中机制和实现" class="headerlink" title="Ⅲ、spring中机制和实现"></a>Ⅲ、spring中机制和实现</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141015-66563.png" alt="img"></p>
<h3 id="1-AOP"><a href="#1-AOP" class="headerlink" title="1.AOP"></a>1.AOP</h3><p>AOP的实现是通过代理模式，在调用对象的某个方法时，执行插入的切面逻辑。实现的方式有动态代理也叫运行时增强，比如jdk代理、CGLIB；静态代理是在编译时进行织入或类加载时进行织入，比如AspectJ。<br>关于AOP还需要了解一下对应的Aspect、pointcut、advice等注解和具体使用方式。</p>
<h3 id="2-placeHolder动态替换"><a href="#2-placeHolder动态替换" class="headerlink" title="2.placeHolder动态替换"></a>2.placeHolder动态替换</h3><p>主要需要了解替换发生的时间，是在bean definition创建完成后，bean初始化之前，是通过实现<code>BeanFactoryPostProcessor</code>接口实现的。主要实现方式有<code>PropertyPlaceholderConfigurer</code>和<code>PropertySourcesPlaceholderConfigurer</code>。这两个类实现逻辑不一样，spring boot使用<code>PropertySourcesPlaceholderConfigurer</code>实现。</p>
<h3 id="3-事务"><a href="#3-事务" class="headerlink" title="3.事务"></a>3.事务</h3><p>需要了解spring 中对事务规定的隔离类型和事务传播类型。要知道事务的隔离级别是由具体的数据库来实现的，在数据库部分我会详细介绍。<br>事务的传播类型，可以重点了解最常用的REQUIRED和SUPPORTS类型。</p>
<h3 id="4-核心接口类"><a href="#4-核心接口类" class="headerlink" title="4.核心接口类"></a>4.核心接口类</h3><ul>
<li>ApplicationContext保存了ioc的整个应用上下文，可以通过其中的beanfactory获取到任意到bean；</li>
<li>BeanFactory主要的作用是根据bean definition来创建具体的bean；</li>
<li>BeanWrapper是对Bean的包装，一般情况下是在spring ioc内部使用，提供了访问bean的属性值、属性编辑器注册、类型转换等功能，方便ioc容器用统一的方式来访问bean的属性；</li>
<li>FactoryBean通过getObject方法返回实际的bean对象，例如motan框架中referer对service的动态代理就是通过FactoryBean来实现的。</li>
</ul>
<h3 id="5-Scope"><a href="#5-Scope" class="headerlink" title="5.Scope"></a>5.Scope</h3><p>bean的scope是指bean的作用域，默认情况下是单例模式，这也是使用最多的一种方式；多例模式，即每次从beanFactory中获取bean都会创建一个新的bean。<br>request、session、global-session是在web服务中使用的scope，request每次请求都创建一个实例，session是在一个会话周期内保证只有一个实例。<br>global-session在5.x版本中已经不在使用，同时增加了Application和Websocket两种scope，分别保证在一个ServletContext与一个WebSocket中只创建一个实例。</p>
<h3 id="6-事件机制"><a href="#6-事件机制" class="headerlink" title="6.事件机制"></a>6.事件机制</h3><p>spring的事件机制需要知道spring定义的五种标准事件，具体事件可见上图，了解如何自定义事件和实现对应的applicationListener来处理自定义事件。</p>
<h2 id="Ⅳ、spring应用相关"><a href="#Ⅳ、spring应用相关" class="headerlink" title="Ⅳ、spring应用相关"></a>Ⅳ、spring应用相关</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141016-e1017.png" alt="img"></p>
<h3 id="1-常用注释"><a href="#1-常用注释" class="headerlink" title="1.常用注释"></a>1.常用注释</h3><h4 id="a-类型类注释："><a href="#a-类型类注释：" class="headerlink" title="a.类型类注释："></a><strong>a.类型类注释</strong>：</h4><p>类型类注释包括<code>controller</code>、<code>service</code>等，需要重点了解<br>其中<code>component</code>和<code>bean</code>注解的区别如下：</p>
<ul>
<li><code>@Component</code>注解在类上使用表明这个类是个组件类，需要Spring为这个类创建bean。</li>
<li><code>@Bean</code>注解使用在方法上，告诉Spring这个方法将会返回一个Bean对象，需要把返回的对象注册到Spring的应用上下文中。</li>
</ul>
<h4 id="b-设置类注解"><a href="#b-设置类注解" class="headerlink" title="b.设置类注解"></a><strong>b.设置类注解</strong></h4><p>重点了解<code>@Autowire</code>和<code>@Qualifier</code>以及bytype、byname等不同的自动装配机制。</p>
<h4 id="c-web类注解"><a href="#c-web类注解" class="headerlink" title="c.web类注解"></a><strong>c.web类注解</strong></h4><p>主要以了解为主，关注<code>@RequestMapping</code>、<code>@GetMapping</code>、<code>@PostMapping</code>等路径匹配注解，以及<code>@PathVariable</code>、<code>@RequestParam</code> 等参数获取注解。</p>
<h4 id="d-功能类注解"><a href="#d-功能类注解" class="headerlink" title="d.功能类注解"></a><strong>d.功能类注解</strong></h4><p>包括<code>@ImportResource</code>引用配置、<code>@ComponentScan</code>注解自动扫描、<code>@Transactional</code>事务注解等等，这里不一一介绍了。</p>
<h3 id="2-配置方式"><a href="#2-配置方式" class="headerlink" title="2.配置方式"></a>2.配置方式</h3><p>需要了解配置spring的几种方式，xml文件配置、注解配置和使用api进行配置。<br>自动装配机制需要了解按类型匹配进行自动装配，按bean名称进行自动装配，构造器中的自动装配和自动检测等主要的四种方式。<br>还需要了解一下list、set、map等集合类属性的配置方式以及内部bean的使用。</p>
<h2 id="Ⅴ、Spring的Context的初始化流程"><a href="#Ⅴ、Spring的Context的初始化流程" class="headerlink" title="Ⅴ、Spring的Context的初始化流程"></a>Ⅴ、Spring的Context的初始化流程</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141016-37f83.png" alt="Spring Context初始化流程"></p>
<p>图中左上角是三种类型的context，xml配置方式的context、springboot的context和web服务的context。不论哪种context，创建后都会调用到AbstractApplicationContext类的refresh方法，这个方法是我们要重点分析的。<br><strong>refresh方法中，操作共分13步</strong>：<br><strong>第1步</strong>：对刷新进行准备，包括设置开始时间、设置激活状态、初始化context环境中的占位符，这个动作根据子类的需求由子类来执行，然后验证是否缺失必要的properties；<br><strong>第2步</strong>：刷新并获得内部的bean factory；<br><strong>第3步</strong>：对bean factory进行准备工作，比如设置类加载器和后置处理器、配置不进行自动装配的类型、注册默认的环境bean；<br><strong>第4步</strong>：为context的子类提供后置处理bean factory的扩展能力。如果子类想在bean定义加载完成后，开始初始化上下文之前做一些特殊逻辑，可以复写这个方法；<br><strong>第5步</strong>，执行context中注册的bean factory后缀处理器；</p>
<blockquote>
<p>注：这里有两种后置处理器，一种是可以注册bean的后缀处理器，另一种是针对bean factory进行处理的后置处理器。执行的顺序是，先按优先级执行可注册bean的处理器，在按优先级执行针对beanfactory的处理器。</p>
</blockquote>
<blockquote>
<p>对springboot来说，这一步会进行注解bean definition的解析。流程如右面小框中所示，由ConfigurationClassPostProcessor触发、由ClassPathBeanDefinitionScanner解析并注册到bean factory。</p>
</blockquote>
<p><strong>第6步</strong>：按优先级顺序在beanfactory中注册bean的后缀处理器，bean后置处理器可以在bean初始化前、后执行处理；<br><strong>第7步</strong>：初始化消息源，消息源用来支持消息的国际化；<br><strong>第8步</strong>：初始化应用事件广播器。事件广播器用来向applicationListener通知各种应用产生的事件，是一个标准的观察者模式；<br><strong>第9步</strong>：是留给子类的扩展步骤，用来让特定的context子类初始化其他的bean；<br><strong>第10步</strong>：把实现了ApplicationListener的bean注册到事件广播器，并对广播器中的早期未广播事件进行通知；<br><strong>第11步</strong>：冻结所有bean描述信息的修改，实例化非延迟加载的单例bean；<br><strong>第12步</strong>：完成上下文的刷新工作，调用LifecycleProcessor的onFresh()方法以及发布ContextRefreshedEvent事件；<br><strong>第13步</strong>：在finally中，执行第十三步，重置公共的缓存，比如ReflectionUtils中的缓存、AnnotationUtils中的缓存等等；<br>至此，spring的context初始化完成。这里仅介绍了最主要的主流程，建议课后阅读源码来复习这个知识点，补全细节。</p>
<h2 id="Ⅵ、Spring中bean的生命周期"><a href="#Ⅵ、Spring中bean的生命周期" class="headerlink" title="Ⅵ、Spring中bean的生命周期"></a>Ⅵ、Spring中bean的生命周期</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141016-8d203.png" alt="Spring中bean的生命周期"></p>
<p><strong>面试中经常问到的bean的生命周期，先看绿色的部分，bean的创建过程</strong>：<br><strong>第1步</strong>：调用bean的构造方法创建bean；<br><strong>第2步</strong>：通过反射调用setter方法进行属性的依赖注入；<br><strong>第3步</strong>：如果实现BeanNameAware接口的话，会设置bean的name；<br><strong>第4步</strong>：如果实现了BeanFactoryAware，会把bean factory设置给bean；<br><strong>第5步</strong>：如果实现了ApplicationContextAware，会给bean设置ApplictionContext；<br><strong>第6步</strong>：如果实现了BeanPostProcessor接口，则执行前置处理方法；<br><strong>第7步</strong>：实现了InitializingBean接口的话，执行afterPropertiesSet方法；<br><strong>第8步</strong>：执行自定义的init方法；<br><strong>第9步</strong>：执行BeanPostProcessor接口的后置处理方法。<br>这时，就完成了bean的创建过程。<br>在使用完bean需要销毁时，会先执行DisposableBean接口的destroy方法，然后在执行自定义的destroy方法。<br>这部分也建议阅读源码加深理解。</p>
<h2 id="Ⅶ、Spring扩展接口"><a href="#Ⅶ、Spring扩展接口" class="headerlink" title="Ⅶ、Spring扩展接口"></a>Ⅶ、Spring扩展接口</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141018-3633a.png" alt="Spring扩展接口"></p>
<p>对spring进行定制化功能扩展时，可以选择如下一些扩展点：</p>
<h3 id="1-BeanFactoryPostProcessor"><a href="#1-BeanFactoryPostProcessor" class="headerlink" title="1.BeanFactoryPostProcessor"></a>1.BeanFactoryPostProcessor</h3><p>是beanFactory后置处理器，支持在bean factory标准初始化完成后，对bean factory进行一些额外处理。在讲context初始化流程时介绍过，这时所有的bean的描述信息已经加载完毕，但是还没有进行bean初始化。例如前面提到的PropertyPlaceholderConfigurer，就是在这个扩展点上对bean属性中的占位符进行替换。</p>
<h3 id="2-BeanDefinitionRegistryPostProcessor"><a href="#2-BeanDefinitionRegistryPostProcessor" class="headerlink" title="2.BeanDefinitionRegistryPostProcessor"></a>2.BeanDefinitionRegistryPostProcessor</h3><p>它扩展自BeanFactoryPostProcessor，在执行BeanFactoryPostProcessor的功能前，提供了可以添加bean definition的能力，允许在初始化一般bean前，注册额外的bean。例如可以在这里根据bean的scope创建一个新的代理bean。</p>
<h3 id="3-BeanPostProcessor"><a href="#3-BeanPostProcessor" class="headerlink" title="3.BeanPostProcessor"></a>3.BeanPostProcessor</h3><p>提供了在bean初始化之前和之后插入自定义逻辑的能力。与BeanFactoryPostProcessor的区别是处理的对象不同，BeanFactoryPostProcessor是对beanfactory进行处理，BeanPostProcessor是对bean进行处理。</p>
<blockquote>
<p>注：上面这三个扩展点，可以通过实现Ordered和PriorityOrdered接口来指定执行顺序。实现PriorityOrdered接口的processor会先于实现Ordered接口的执行。</p>
</blockquote>
<h3 id="4-ApplicationContextAware"><a href="#4-ApplicationContextAware" class="headerlink" title="4.ApplicationContextAware"></a>4.ApplicationContextAware</h3><p>可以获得ApplicationContext及其中的bean，当需要在代码中动态获取bean时，可以通过实现这个接口来实现。</p>
<h3 id="5-InitializingBean"><a href="#5-InitializingBean" class="headerlink" title="5.InitializingBean"></a>5.InitializingBean</h3><p>可以在bean初始化完成，所有属性设置完成后执行特定逻辑，例如对自动装配对属性进行验证等等。</p>
<h3 id="6-DisposableBean"><a href="#6-DisposableBean" class="headerlink" title="6.DisposableBean"></a>6.DisposableBean</h3><p>用于在bean被销毁前执行特定的逻辑，例如做一些回收工作等。</p>
<h3 id="7-ApplicationListener"><a href="#7-ApplicationListener" class="headerlink" title="7.ApplicationListener"></a>7.ApplicationListener</h3><p>用来监听spring的标准应用事件或者自定义事件。</p>
<h2 id="Ⅷ、springboot相关的知识点"><a href="#Ⅷ、springboot相关的知识点" class="headerlink" title="Ⅷ、springboot相关的知识点"></a>Ⅷ、springboot相关的知识点</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141019-666c3.png" alt="img"></p>
<h3 id="1-启动流程"><a href="#1-启动流程" class="headerlink" title="1.启动流程"></a>1.启动流程</h3><p>主要步骤首先要配置environment，然后准备context上下文，包括执行applicationContext的后置处理、初始化initializer、通知listener处理contextPrepared和contextLoaded事件。最后执行refreshContext，也就是前面介绍过的AbstractApplicationContext类的refresh方法。</p>
<h3 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2.配置文件"></a>2.配置文件</h3><p>然后要知道在Spring Boot中有两种上下文，一种是bootstrap, 另外一种是application。<br>bootstrap是应用程序的父上下文，也就是说bootstrap会先于applicaton加载。bootstrap主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。bootstrap里面的属性会优先加载，默认也不能被本地相同配置覆盖。</p>
<h3 id="3-注解"><a href="#3-注解" class="headerlink" title="3.注解"></a>3.注解</h3><p><code>@SpringBootApplication</code>包含了<code>@ComponentScan</code>、<code>@EnableAutoConfiguration</code>、<code>@SpringBootConfiguration</code>三个注解<br>而<code>@SpringBootConfiguration</code>注解包含了<code>@Configuration</code>注解。也就是springboot的自动配置功能。<br><code>@Conditional</code>注解就是控制自动配置的生效条件的注解，例如bean或class存在、不存在时进行配置，当满足条件时进行配置等等。</p>
<h3 id="4-特色模块"><a href="#4-特色模块" class="headerlink" title="4.特色模块"></a>4.特色模块</h3><ul>
<li>starter是springboot提供的无缝集成功能的一种方式，使用某个功能时开发者不需要关注各种依赖库的处理，不需要具体的配置信息，由Spring Boot自动配置进行bean的创建。例如需要使用web功能时，只需要在依赖中引入spring-boot-starter-web即可。</li>
<li>actuator是用来对应用程序进行监视和管理，通过restful api请求来监管、审计、收集应用的运行情况。</li>
<li>devtools提供了一系列开发工具的支持，来提高开发效率。例如热部署能力等。</li>
<li>CLI就是命令行接口，是一个命令行工具，支持使用Groovy脚本，可以快速搭建spring原型项目。</li>
</ul>
<p>以上为Spring框架需要掌握的内容，前面提到的核心机制、核心流程，建议阅读源码加深理解。</p>
<blockquote>
<p>作者：Java_苏先生</p>
<p>来源：<a href="https://juejin.im/post/5cc175e2e51d456e2e656d7b" target="_blank" rel="noopener">https://juejin.im/post/5cc175e2e51d456e2e656d7b</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>BeanFactory和ApplicationContext的区别</title>
    <url>/2019/12/26/BeanFactory%E5%92%8CApplicationContext%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>接口 BeanFactory 和 ApplicationContext 都是用来从容器中获取 Spring beans 的，但是，他们二者有很大不同</p>
</blockquote>
<p>我看到过很多问 BeanFactory 和 ApplicationContext 不同点的问题，考虑到这，我应该使用前者还是后者从 Spring 容器中获取 beans 呢？请向下看</p>
<a id="more"></a>

<h2 id="什么是-Spring-Bean"><a href="#什么是-Spring-Bean" class="headerlink" title="什么是 Spring Bean"></a>什么是 Spring Bean</h2><p>这是一个非常简单而又很复杂的问题，通常来说，Spring beans 就是被 Spring 容器所管理的 Java 对象，来看一个简单的例子</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package com.zoltanraffai;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">String</span> message;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(<span class="keyword">String</span> message)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">this</span>.message  = message;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMessage</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      System.out.<span class="built_in">println</span>(<span class="string">"My Message : "</span> + message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在基于 XML 的配置中， beans.xml 为 Spring 容器管理 bean 提供元数据</p>
<h2 id="什么是-Spring-容器"><a href="#什么是-Spring-容器" class="headerlink" title="什么是 Spring 容器"></a>什么是 Spring 容器</h2><p>Spring 容器负责实例化，配置和装配 Spring beans，下面来看如何为 IoC 容器配置我们的 HelloWorld POJO</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version = "1.0" encoding = "UTF-8"?&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span> = <span class="string">"http://www.springframework.org/schema/beans"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span> = <span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span> = <span class="string">"http://www.springframework.org/schema/beans</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"helloWorld"</span> <span class="attr">class</span> = <span class="string">"com.zoltanraffai.HelloWorld"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"message"</span> <span class="attr">value</span> = <span class="string">"Hello World!"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<p>现在，它已经被 Spring 容器管理了，接下来的问题是：我们怎样获取它？</p>
<h2 id="BeanFactory-和-ApplicationContext-的不同点"><a href="#BeanFactory-和-ApplicationContext-的不同点" class="headerlink" title="BeanFactory 和 ApplicationContext 的不同点"></a>BeanFactory 和 ApplicationContext 的不同点</h2><h3 id="BeanFactory-接口"><a href="#BeanFactory-接口" class="headerlink" title="BeanFactory 接口"></a>BeanFactory 接口</h3><p>这是一个用来访问 Spring 容器的 root 接口，要访问 Spring 容器，我们将使用 Spring 依赖注入功能，使用 BeanFactory 接口和它的子接口 <strong>特性：</strong></p>
<ul>
<li>Bean 的实例化/串联 通常情况，BeanFactory 的实现是使用懒加载的方式，这意味着 beans 只有在我们通过 getBean() 方法直接调用它们时才进行实例化 实现 BeanFactory 最常用的 API 是 XMLBeanFactory 这里是如何通过 BeanFactory 获取一个 bean 的例子：</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">package com.zoltanraffai;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.<span class="keyword">factory</span>.InitializingBean;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.<span class="keyword">factory</span>.xml.XmlBeanFactory;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldApp</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      XmlBeanFactory <span class="keyword">factory</span> = <span class="keyword">new</span> XmlBeanFactory (<span class="keyword">new</span> ClassPathResource(<span class="string">"beans.xml"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">      HelloWorld obj = (HelloWorld) <span class="keyword">factory</span>.getBean(<span class="string">"helloWorld"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      obj.getMessage();</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="ApplicationContext-接口"><a href="#ApplicationContext-接口" class="headerlink" title="ApplicationContext 接口"></a>ApplicationContext 接口</h3><p>ApplicationContext 是 Spring 应用程序中的中央接口，用于向应用程序提供配置信息 它继承了 BeanFactory 接口，所以 ApplicationContext 包含 BeanFactory 的所有功能以及更多功能！它的主要功能是支持大型的业务应用的创建 <strong>特性：</strong></p>
<ul>
<li>Bean instantiation/wiring</li>
<li>Bean 的实例化/串联</li>
<li>自动的 BeanPostProcessor 注册</li>
<li>自动的 BeanFactoryPostProcessor 注册</li>
<li>方便的 MessageSource 访问（i18n）</li>
<li>ApplicationEvent 的发布 与 BeanFactory 懒加载的方式不同，它是预加载，所以，每一个 bean 都在 ApplicationContext 启动之后实例化 这里是 ApplicationContext 的使用例子：</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package com.zoltanraffai;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.xml.XmlBeanFactory;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldApp</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ApplicationContext context=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      HelloWorld obj = (HelloWorld) context.getBean(<span class="string">"helloWorld"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      obj.getMessage();</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>ApplicationContext 包含 BeanFactory 的所有特性，通常推荐使用前者。但是也有一些限制情形，比如移动应用内存消耗比较严苛，在那些情景中，使用更轻量级的 BeanFactory 是更合理的。然而，在大多数企业级的应用中，ApplicationContext 是你的首选。</p>
</blockquote>
<blockquote>
<p>作者：日拱一兵</p>
<p>来源：<a href="https://juejin.im/post/5d195530f265da1bb80c4560" target="_blank" rel="noopener">https://juejin.im/post/5d195530f265da1bb80c4560</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>面试中常问的Spring方面问题</title>
    <url>/2019/12/26/%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%B8%B8%E9%97%AE%E7%9A%84Spring%E6%96%B9%E9%9D%A2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>Spring Framework 现在几乎已成为 Java Web 开发的标配框架。那么，作为 Java 程序员，你对 Spring 的主要技术点又掌握了多少呢？不妨用本文的问题来检测一下。</p>
<a id="more"></a>

<h2 id="1、一般问题"><a href="#1、一般问题" class="headerlink" title="1、一般问题"></a>1、一般问题</h2><h3 id="1-1-不同版本的-Spring-Framework-有哪些主要功能？"><a href="#1-1-不同版本的-Spring-Framework-有哪些主要功能？" class="headerlink" title="1.1. 不同版本的 Spring Framework 有哪些主要功能？"></a>1.1. 不同版本的 Spring Framework 有哪些主要功能？</h3><p>VersionFeatureSpring 2.5发布于 2007 年。这是第一个支持注解的版本。Spring 3.0发布于 2009 年。它完全利用了 Java5 中的改进，并为 JEE6 提供了支持。Spring 4.0发布于 2013 年。这是第一个完全支持 JAVA8 的版本。</p>
<h3 id="1-2-什么是-Spring-Framework？"><a href="#1-2-什么是-Spring-Framework？" class="headerlink" title="1.2. 什么是 Spring Framework？"></a>1.2. 什么是 Spring Framework？</h3><ul>
<li>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</li>
<li>它是轻量级、松散耦合的。</li>
<li>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</li>
<li>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。</li>
</ul>
<h3 id="1-3-列举-Spring-Framework-的优点。"><a href="#1-3-列举-Spring-Framework-的优点。" class="headerlink" title="1.3. 列举 Spring Framework 的优点。"></a>1.3. 列举 Spring Framework 的优点。</h3><ul>
<li>由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。</li>
<li>Spring Framework 支持 POJO(Plain Old Java Object) 编程，从而具备持续集成和可测试性。</li>
<li>由于依赖注入和控制反转，JDBC 得以简化。</li>
<li>它是开源免费的。</li>
</ul>
<h3 id="1-4-Spring-Framework-有哪些不同的功能？"><a href="#1-4-Spring-Framework-有哪些不同的功能？" class="headerlink" title="1.4. Spring Framework 有哪些不同的功能？"></a>1.4. Spring Framework 有哪些不同的功能？</h3><ul>
<li><strong>轻量级</strong> - Spring 在代码量和透明度方面都很轻便。</li>
<li><strong>IOC</strong> - 控制反转</li>
<li><strong>AOP</strong> - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。</li>
<li><strong>容器</strong> - Spring 负责创建和管理对象（Bean）的生命周期和配置。</li>
<li><strong>MVC</strong> - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</li>
<li><strong>事务管理</strong> - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。</li>
<li><strong>JDBC 异常</strong> - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</li>
</ul>
<h3 id="1-5-Spring-Framework-中有多少个模块，它们分别是什么？"><a href="#1-5-Spring-Framework-中有多少个模块，它们分别是什么？" class="headerlink" title="1.5. Spring Framework 中有多少个模块，它们分别是什么？"></a>1.5. Spring Framework 中有多少个模块，它们分别是什么？</h3><p><img src="http://image.winrains.cn/2019/08/641e0-2c9c6daadf8154be46afbfd87d3e5824.jpeg-wh_651x-s_919540347.jpeg" alt="http://image.winrains.cn/2019/08/641e0-2c9c6daadf8154be46afbfd87d3e5824.jpeg-wh_651x-s_919540347.jpeg"></p>
<ul>
<li><p>Spring 核心容器</p>
<p> – 该层基本上是 Spring Framework 的核心。它包含以下模块：</p>
<ul>
<li>Spring Core</li>
<li>Spring Bean</li>
<li>SpEL (Spring Expression Language)</li>
<li>Spring Context</li>
</ul>
</li>
<li><p>数据访问/集成</p>
<p> – 该层提供与数据库交互的支持。它包含以下模块：</p>
<ul>
<li>JDBC (Java DataBase Connectivity)</li>
<li>ORM (Object Relational Mapping)</li>
<li>OXM (Object XML Mappers)</li>
<li>JMS (Java Messaging Service)</li>
<li>Transaction</li>
</ul>
</li>
<li><p>Web</p>
<p> – 该层提供了创建 Web 应用程序的支持。它包含以下模块：</p>
<ul>
<li>Web</li>
<li>Web – Servlet</li>
<li>Web – Socket</li>
<li>Web – Portlet</li>
</ul>
</li>
<li><p><strong>AOP</strong> – 该层支持面向切面编程</p>
</li>
<li><p><strong>Instrumentation</strong> – 该层为类检测和类加载器实现提供支持。</p>
</li>
<li><p><strong>Test</strong> – 该层为使用 JUnit 和 TestNG 进行测试提供支持。</p>
</li>
<li><p>几个杂项模块:</p>
<ul>
<li>Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。</li>
<li>Aspects – 该模块为与 AspectJ 的集成提供支持。</li>
</ul>
</li>
</ul>
<h3 id="1-6-什么是-Spring-配置文件？"><a href="#1-6-什么是-Spring-配置文件？" class="headerlink" title="1.6. 什么是 Spring 配置文件？"></a>1.6. 什么是 Spring 配置文件？</h3><p>Spring 配置文件是 XML 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。但是，XML 配置文件冗长且更加干净。如果没有正确规划和编写，那么在大项目中管理变得非常困难。</p>
<h3 id="1-7-Spring-应用程序有哪些不同组件？"><a href="#1-7-Spring-应用程序有哪些不同组件？" class="headerlink" title="1.7. Spring 应用程序有哪些不同组件？"></a>1.7. Spring 应用程序有哪些不同组件？</h3><p>Spring 应用一般有以下组件：</p>
<ul>
<li><strong>接口</strong> - 定义功能。</li>
<li><strong>Bean 类</strong> - 它包含属性，setter 和 getter 方法，函数等。</li>
<li><strong>Spring 面向切面编程（AOP）</strong> - 提供面向切面编程的功能。</li>
<li><strong>Bean 配置文件</strong> - 包含类的信息以及如何配置它们。</li>
<li><strong>用户程序</strong> - 它使用接口。</li>
</ul>
<h3 id="1-8-使用-Spring-有哪些方式？"><a href="#1-8-使用-Spring-有哪些方式？" class="headerlink" title="1.8. 使用 Spring 有哪些方式？"></a>1.8. 使用 Spring 有哪些方式？</h3><p>使用 Spring 有以下方式：</p>
<ul>
<li>作为一个成熟的 Spring Web 应用程序。</li>
<li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li>
<li>用于远程使用。</li>
<li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li>
</ul>
<h2 id="2、依赖注入（Ioc）"><a href="#2、依赖注入（Ioc）" class="headerlink" title="2、依赖注入（Ioc）"></a>2、依赖注入（Ioc）</h2><h3 id="2-1-什么是-Spring-IOC-容器？"><a href="#2-1-什么是-Spring-IOC-容器？" class="headerlink" title="2.1. 什么是 Spring IOC 容器？"></a>2.1. 什么是 Spring IOC 容器？</h3><p>Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过 XML，Java 注解或 Java 代码提供。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829143756-2ecdd.jpeg" alt="img"></p>
<h3 id="2-2-什么是依赖注入？"><a href="#2-2-什么是依赖注入？" class="headerlink" title="2.2. 什么是依赖注入？"></a>2.2. 什么是依赖注入？</h3><p>在依赖注入中，您不必创建对象，但必须描述如何创建它们。您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。由 IoC 容器将它们装配在一起。</p>
<h3 id="2-3-可以通过多少种方式完成依赖注入？"><a href="#2-3-可以通过多少种方式完成依赖注入？" class="headerlink" title="2.3. 可以通过多少种方式完成依赖注入？"></a>2.3. 可以通过多少种方式完成依赖注入？</h3><p>通常，依赖注入可以通过三种方式完成，即：</p>
<ul>
<li>构造函数注入</li>
<li>setter 注入</li>
<li>接口注入</li>
</ul>
<p>在 Spring Framework 中，仅使用构造函数和 setter 注入。</p>
<h3 id="2-4-区分构造函数注入和-setter-注入。"><a href="#2-4-区分构造函数注入和-setter-注入。" class="headerlink" title="2.4. 区分构造函数注入和 setter 注入。"></a>2.4. 区分构造函数注入和 setter 注入。</h3><p>构造函数注入setter 注入没有部分注入有部分注入不会覆盖 setter 属性会覆盖 setter 属性任意修改都会创建一个新实例任意修改不会创建一个新实例适用于设置很多属性适用于设置少量属性</p>
<h3 id="2-5-spring-中有多少种-IOC-容器？"><a href="#2-5-spring-中有多少种-IOC-容器？" class="headerlink" title="2.5. spring 中有多少种 IOC 容器？"></a>2.5. spring 中有多少种 IOC 容器？</h3><ul>
<li>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。</li>
<li>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。</li>
</ul>
<h3 id="2-6-区分-BeanFactory-和-ApplicationContext。"><a href="#2-6-区分-BeanFactory-和-ApplicationContext。" class="headerlink" title="2.6. 区分 BeanFactory 和 ApplicationContext。"></a>2.6. 区分 BeanFactory 和 ApplicationContext。</h3><p>BeanFactoryApplicationContext它使用懒加载它使用即时加载它使用语法显式提供资源对象它自己创建和管理资源对象不支持国际化支持国际化不支持基于依赖的注解支持基于依赖的注解</p>
<h3 id="2-7-列举-IoC-的一些好处。"><a href="#2-7-列举-IoC-的一些好处。" class="headerlink" title="2.7. 列举 IoC 的一些好处。"></a>2.7. 列举 IoC 的一些好处。</h3><p>IoC 的一些好处是：</p>
<ul>
<li>它将最小化应用程序中的代码量。</li>
<li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li>
<li>它以最小的影响和最少的侵入机制促进松耦合。</li>
<li>它支持即时的实例化和延迟加载服务。</li>
</ul>
<h3 id="2-8-Spring-IoC-的实现机制。"><a href="#2-8-Spring-IoC-的实现机制。" class="headerlink" title="2.8. Spring IoC 的实现机制。"></a>2.8. Spring IoC 的实现机制。</h3><p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。<br>示例：</p>
<p><img src="http://image.winrains.cn/2019/08/a4f36-223b876d39a7bd0d001271c445d56aa7.jpeg" alt="http://image.winrains.cn/2019/08/a4f36-223b876d39a7bd0d001271c445d56aa7.jpeg"></p>
<h2 id="3-Beans"><a href="#3-Beans" class="headerlink" title="3. Beans"></a>3. Beans</h2><h3 id="3-1-什么是-spring-bean？"><a href="#3-1-什么是-spring-bean？" class="headerlink" title="3.1. 什么是 spring bean？"></a>3.1. 什么是 spring bean？</h3><ul>
<li>它们是构成用户应用程序主干的对象。</li>
<li>Bean 由 Spring IoC 容器管理。</li>
<li>它们由 Spring IoC 容器实例化，配置，装配和管理。</li>
<li>Bean 是基于用户提供给容器的配置元数据创建。</li>
</ul>
<h3 id="3-2-spring-提供了哪些配置方式？"><a href="#3-2-spring-提供了哪些配置方式？" class="headerlink" title="3.2. spring 提供了哪些配置方式？"></a>3.2. spring 提供了哪些配置方式？</h3><ul>
<li><ul>
<li>基于 xml 配置</li>
</ul>
</li>
</ul>
<p>bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">"studentbean"</span> <span class="built_in">class</span>=<span class="string">"org.edureka.firstSpring.StudentBean"</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"name"</span> value=<span class="string">"Edureka"</span>&gt;&lt;/<span class="keyword">property</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;/bean&gt;</span></pre></td></tr></table></figure>

<ul>
<li>基于注解配置</li>
</ul>
<p>您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bean definitions go here --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<ul>
<li>基于 Java API 配置</li>
</ul>
<p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>
<ol>
<li>@Bean 注解扮演与 <bean /> 元素相同的角色。</li>
<li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="3-3-spring-支持集中-bean-scope？"><a href="#3-3-spring-支持集中-bean-scope？" class="headerlink" title="3.3. spring 支持集中 bean scope？"></a>3.3. spring 支持集中 bean scope？</h3><p>Spring bean 支持 5 种 scope：</p>
<ul>
<li><strong>Singleton</strong> - 每个 Spring IoC 容器仅有一个单实例。</li>
<li><strong>Prototype</strong> - 每次请求都会产生一个新的实例。</li>
<li><strong>Request</strong> - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。</li>
<li><strong>Session</strong> - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。</li>
<li><strong>Global-session</strong> - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。</li>
</ul>
<p>仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。</p>
<h3 id="3-4-spring-bean-容器的生命周期是什么样的？"><a href="#3-4-spring-bean-容器的生命周期是什么样的？" class="headerlink" title="3.4. spring bean 容器的生命周期是什么样的？"></a>3.4. spring bean 容器的生命周期是什么样的？</h3><p>spring bean 容器的生命周期流程如下：</p>
<ol>
<li>Spring 容器根据配置中的 bean 定义中实例化 bean。</li>
<li>Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。</li>
<li>如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。</li>
<li>如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。</li>
<li>如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。</li>
<li>如果为 bean 指定了 init 方法（<bean> 的 init-method 属性），那么将调用它。</li>
<li>最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。</li>
<li>如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。</li>
<li>如果为 bean 指定了 destroy 方法（<bean> 的 destroy-method 属性），那么将调用它。<img src="http://image.winrains.cn/2019/08/af3ef-41bc3485d75dc4aabe3d843ac2048790.jpeg" alt="http://image.winrains.cn/2019/08/af3ef-41bc3485d75dc4aabe3d843ac2048790.jpeg"></li>
</ol>
<h3 id="3-5-什么是-spring-的内部-bean？"><a href="#3-5-什么是-spring-的内部-bean？" class="headerlink" title="3.5. 什么是 spring 的内部 bean？"></a>3.5. 什么是 spring 的内部 bean？</h3><p>只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean。为了定义 bean，Spring 的基于 XML 的配置元数据在 <property> 或 <constructor-arg>中提供了 <bean> 元素的使用。内部 bean 总是匿名的，它们总是作为原型。<br>例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。<br>Student.java</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Student</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Person person;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//Setters and Getters</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Person</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> String name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> String address;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//Setters and Getters</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>bean.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“StudentBean</span>" <span class="attr">class</span>=<span class="string">"com.edureka.Student"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"person"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!--This is inner bean --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.edureka.Person"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">“Scott</span>"&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">value</span>=<span class="string">“Bangalore</span>"&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>

<h3 id="3-6-什么是-spring-装配？"><a href="#3-6-什么是-spring-装配？" class="headerlink" title="3.6. 什么是 spring 装配？"></a>3.6. 什么是 spring 装配？</h3><p>当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。 Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。</p>
<h3 id="3-7-自动装配有哪些方式？"><a href="#3-7-自动装配有哪些方式？" class="headerlink" title="3.7. 自动装配有哪些方式？"></a>3.7. 自动装配有哪些方式？</h3><p>Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。<br>自动装配的不同模式：</p>
<ul>
<li><strong>no</strong> - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li>
<li><strong>byName</strong> - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</li>
<li><strong>byType</strong> - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</li>
<li><strong>构造函数</strong> - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li>
<li><strong>autodetect</strong> - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li>
</ul>
<h3 id="3-8-自动装配有什么局限？"><a href="#3-8-自动装配有什么局限？" class="headerlink" title="3.8. 自动装配有什么局限？"></a>3.8. 自动装配有什么局限？</h3><ul>
<li>覆盖的可能性 - 您始终可以使用 <constructor-arg> 和 <property> 设置指定依赖项，这将覆盖自动装配。</li>
<li>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</li>
<li>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</li>
</ul>
<h2 id="4、注解"><a href="#4、注解" class="headerlink" title="4、注解"></a>4、注解</h2><h3 id="4-1-什么是基于注解的容器配置？"><a href="#4-1-什么是基于注解的容器配置？" class="headerlink" title="4.1. 什么是基于注解的容器配置？"></a>4.1. 什么是基于注解的容器配置？</h3><p>不使用 XML 来描述 bean 装配，开发人员通过在相关的类，方法或字段声明上使用注解将配置移动到组件类本身。它可以作为 XML 设置的替代方案。例如：<br>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>
<ul>
<li>@Bean 注解扮演与</li>
<li>元素相同的角色。</li>
<li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="4-2-如何在-spring-中启动注解装配？"><a href="#4-2-如何在-spring-中启动注解装配？" class="headerlink" title="4.2. 如何在 spring 中启动注解装配？"></a>4.2. 如何在 spring 中启动注解装配？</h3><p>默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置&lt;context：annotation-config /&gt; 元素在 Spring 配置文件中启用它。</p>
<h3 id="4-3-Component-Controller-Repository-Service-有何区别？"><a href="#4-3-Component-Controller-Repository-Service-有何区别？" class="headerlink" title="4.3. @Component, @Controller, @Repository, @Service 有何区别？"></a>4.3. @Component, @Controller, @Repository, @Service 有何区别？</h3><ul>
<li>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li>
<li>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</li>
<li>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</li>
<li>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li>
</ul>
<h3 id="4-4-Required-注解有什么用？"><a href="#4-4-Required-注解有什么用？" class="headerlink" title="4.4. @Required 注解有什么用？"></a>4.4. @Required 注解有什么用？</h3><p>@Required 应用于 bean 属性 setter 方法。此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性。如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。<br>示例：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Required</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name=name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">return</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="4-5-Autowired-注解有什么用？"><a href="#4-5-Autowired-注解有什么用？" class="headerlink" title="4.5. @Autowired 注解有什么用？"></a>4.5. @Autowired 注解有什么用？</h3><p>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是类型驱动的注入。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name=name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="4-6-Qualifier-注解有什么用？"><a href="#4-6-Qualifier-注解有什么用？" class="headerlink" title="4.6. @Qualifier 注解有什么用？"></a>4.6. @Qualifier 注解有什么用？</h3><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。<br>例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount 中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。<br>Employee.java</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>EmpAccount.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpAccount</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Employee emp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Qualifier</span>(emp1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showName</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Employee name : "</span> + emp.getName);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="4-7-RequestMapping-注解有什么用？"><a href="#4-7-RequestMapping-注解有什么用？" class="headerlink" title="4.7. @RequestMapping 注解有什么用？"></a>4.7. @RequestMapping 注解有什么用？</h3><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：</p>
<ul>
<li>类级别：映射请求的 URL</li>
<li>方法级别：映射 URL 以及 HTTP 请求方法</li>
</ul>
<h2 id="5、数据访问"><a href="#5、数据访问" class="headerlink" title="5、数据访问"></a>5、数据访问</h2><h3 id="5-1-spring-DAO-有什么用？"><a href="#5-1-spring-DAO-有什么用？" class="headerlink" title="5.1. spring DAO 有什么用？"></a>5.1. spring DAO 有什么用？</h3><p>Spring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p>
<h3 id="5-2-列举-Spring-DAO-抛出的异常。"><a href="#5-2-列举-Spring-DAO-抛出的异常。" class="headerlink" title="5.2. 列举 Spring DAO 抛出的异常。"></a>5.2. 列举 Spring DAO 抛出的异常。</h3><p><img src="http://image.winrains.cn/2019/08/caa7f-d6ebd1c162702b14bf48320d0ce48921.jpeg" alt="http://image.winrains.cn/2019/08/caa7f-d6ebd1c162702b14bf48320d0ce48921.jpeg"></p>
<h3 id="5-3-spring-JDBC-API-中存在哪些类？"><a href="#5-3-spring-JDBC-API-中存在哪些类？" class="headerlink" title="5.3. spring JDBC API 中存在哪些类？"></a>5.3. spring JDBC API 中存在哪些类？</h3><ul>
<li>JdbcTemplate</li>
<li>SimpleJdbcTemplate</li>
<li>NamedParameterJdbcTemplate</li>
<li>SimpleJdbcInsert</li>
<li>SimpleJdbcCall</li>
</ul>
<h3 id="5-4-使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#5-4-使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="5.4. 使用 Spring 访问 Hibernate 的方法有哪些？"></a>5.4. 使用 Spring 访问 Hibernate 的方法有哪些？</h3><p>我们可以通过两种方式使用 Spring 访问 Hibernate：</p>
<ol>
<li>使用 Hibernate 模板和回调进行控制反转</li>
<li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li>
</ol>
<h3 id="5-5-列举-spring-支持的事务管理类型"><a href="#5-5-列举-spring-支持的事务管理类型" class="headerlink" title="5.5. 列举 spring 支持的事务管理类型"></a>5.5. 列举 spring 支持的事务管理类型</h3><p>Spring 支持两种类型的事务管理：</p>
<ol>
<li>程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。</li>
<li>声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。</li>
</ol>
<h3 id="5-6-spring-支持哪些-ORM-框架？"><a href="#5-6-spring-支持哪些-ORM-框架？" class="headerlink" title="5.6. spring 支持哪些 ORM 框架？"></a>5.6. spring 支持哪些 ORM 框架？</h3><ul>
<li>Hibernate</li>
<li>iBatis</li>
<li>JPA</li>
<li>JDO</li>
<li>OJB</li>
</ul>
<h2 id="6、AOP"><a href="#6、AOP" class="headerlink" title="6、AOP"></a>6、AOP</h2><h3 id="6-1-什么是-AOP？"><a href="#6-1-什么是-AOP？" class="headerlink" title="6.1. 什么是 AOP？"></a>6.1. 什么是 AOP？</h3><p>AOP(Aspect-Oriented Programming), 即 <strong>面向切面编程</strong>, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角.<br>在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 <strong>Aspect(切面)</strong></p>
<h3 id="6-2-什么是-Aspect？"><a href="#6-2-什么是-Aspect？" class="headerlink" title="6.2. 什么是 Aspect？"></a>6.2. 什么是 Aspect？</h3><p>aspect 由 pointcount 和 advice 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.<br>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p>
<ol>
<li>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上</li>
<li>如何在 advice 中编写切面代码.</li>
</ol>
<p><strong>可以简单地认为, 使用 @Aspect 注解的类就是切面.</strong><br><img src="http://image.winrains.cn/2019/08/2a040-bc1af77af5b09fb02a8920292ff4f8e1.jpeg" alt="http://image.winrains.cn/2019/08/2a040-bc1af77af5b09fb02a8920292ff4f8e1.jpeg"></p>
<h3 id="6-3-什么是切点（JoinPoint）"><a href="#6-3-什么是切点（JoinPoint）" class="headerlink" title="6.3. 什么是切点（JoinPoint）"></a>6.3. 什么是切点（JoinPoint）</h3><p>程序运行中的一些时间点, 例如一个方法的执行, 或者是一个异常的处理.<br>在 Spring AOP 中, join point 总是方法的执行点。</p>
<h3 id="6-4-什么是通知（Advice）？"><a href="#6-4-什么是通知（Advice）？" class="headerlink" title="6.4. 什么是通知（Advice）？"></a>6.4. 什么是通知（Advice）？</h3><p>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice。Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的拦截器。</p>
<h3 id="6-5-有哪些类型的通知（Advice）？"><a href="#6-5-有哪些类型的通知（Advice）？" class="headerlink" title="6.5. 有哪些类型的通知（Advice）？"></a>6.5. 有哪些类型的通知（Advice）？</h3><ul>
<li><strong>Before</strong> - 这些类型的 Advice 在 joinpoint 方法之前执行，并使用 @Before 注解标记进行配置。</li>
<li><strong>After Returning</strong> - 这些类型的 Advice 在连接点方法正常执行后执行，并使用@AfterReturning 注解标记进行配置。</li>
<li><strong>After Throwing</strong> - 这些类型的 Advice 仅在 joinpoint 方法通过抛出异常退出并使用 @AfterThrowing 注解标记配置时执行。</li>
<li><strong>After (finally)</strong> - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @After 注解标记进行配置。</li>
<li><strong>Around</strong> - 这些类型的 Advice 在连接点之前和之后执行，并使用 @Around 注解标记进行配置。</li>
</ul>
<h3 id="6-6-指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处"><a href="#6-6-指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处" class="headerlink" title="6.6. 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处"></a>6.6. 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处</h3><p>concern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。<br>cross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。</p>
<h3 id="6-7-AOP-有哪些实现方式"><a href="#6-7-AOP-有哪些实现方式" class="headerlink" title="6.7. AOP 有哪些实现方式"></a>6.7. AOP 有哪些实现方式</h3><p>实现 AOP 的技术，主要分为两大类：</p>
<ul>
<li>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；</li>
<li>编译时编织（特殊编译器实现）</li>
<li>类加载时编织（特殊的类加载器实现）。</li>
<li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</li>
<li>JDK 动态代理</li>
<li>CGLIB</li>
</ul>
<h3 id="6-8-Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#6-8-Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="6.8. Spring AOP and AspectJ AOP 有什么区别？"></a>6.8. Spring AOP and AspectJ AOP 有什么区别？</h3><p>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。<br>Spring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。</p>
<h3 id="6-9-如何理解-Spring-中的代理？"><a href="#6-9-如何理解-Spring-中的代理？" class="headerlink" title="6.9. 如何理解 Spring 中的代理？"></a>6.9. 如何理解 Spring 中的代理？</h3><p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。<br>Advice + Target Object = Proxy</p>
<h3 id="6-10-什么是编织（Weaving）？"><a href="#6-10-什么是编织（Weaving）？" class="headerlink" title="6.10. 什么是编织（Weaving）？"></a>6.10. 什么是编织（Weaving）？</h3><p>为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）。在 Spring AOP 中，编织在运行时执行。请参考下图：<br><img src="http://image.winrains.cn/2019/08/dfa9f-801b410c598b76a9ac602373008c90e1.jpeg" alt="http://image.winrains.cn/2019/08/dfa9f-801b410c598b76a9ac602373008c90e1.jpeg"></p>
<h2 id="7、MVC"><a href="#7、MVC" class="headerlink" title="7、MVC"></a>7、MVC</h2><h3 id="7-1-Spring-MVC-框架有什么用？"><a href="#7-1-Spring-MVC-框架有什么用？" class="headerlink" title="7.1. Spring MVC 框架有什么用？"></a>7.1. Spring MVC 框架有什么用？</h3><p>Spring Web MVC 框架提供 <strong>模型-视图-控制器</strong> 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。 MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。</p>
<h3 id="7-2-描述一下-DispatcherServlet-的工作流程"><a href="#7-2-描述一下-DispatcherServlet-的工作流程" class="headerlink" title="7.2. 描述一下 DispatcherServlet 的工作流程"></a><strong>7.2. 描述一下 DispatcherServlet 的工作流程</strong></h3><p>DispatcherServlet 的工作流程可以用一幅图来说明：<br><img src="http://image.winrains.cn/2019/08/62864-0a2ce874e9e8b25d524d2fe7b4da8770.jpeg" alt="http://image.winrains.cn/2019/08/62864-0a2ce874e9e8b25d524d2fe7b4da8770.jpeg"></p>
<ol>
<li>向服务器发送 HTTP 请求，请求被前端控制器 DispatcherServlet 捕获。</li>
<li>DispatcherServlet 根据 <strong>-servlet.xml</strong> 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以HandlerExecutionChain 对象的形式返回。</li>
<li>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的 preHandler(…)方法）。</li>
<li>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：</li>
</ol>
<ul>
<li>HttpMessageConveter： 将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。</li>
<li>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等。</li>
<li>数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。</li>
<li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中。</li>
</ul>
<ol>
<li>Handler(Controller)执行完成后，向 DispatcherServlet 返回一个ModelAndView 对象；</li>
<li>根据返回的ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的ViewResolver)返回给DispatcherServlet。</li>
<li>ViewResolver 结合Model和View，来渲染视图。</li>
<li>视图负责将渲染结果返回给客户端。</li>
</ol>
<h3 id="7-3-介绍一下-WebApplicationContext"><a href="#7-3-介绍一下-WebApplicationContext" class="headerlink" title="7.3. 介绍一下 WebApplicationContext"></a><strong>7.3. 介绍一下 WebApplicationContext</strong></h3><p>WebApplicationContext 是 ApplicationContext 的扩展。它具有 Web 应用程序所需的一些额外功能。它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。</p>
<blockquote>
<p>作者：51CTO</p>
<p>来源：<a href="http://developer.51cto.com/art/201808/580655.htm" target="_blank" rel="noopener">http://developer.51cto.com/art/201808/580655.htm</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring使用注解式声明与使用切面</title>
    <url>/2019/12/26/Spring%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%A3%B0%E6%98%8E%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%88%87%E9%9D%A2/</url>
    <content><![CDATA[<h3 id="1-什么是面向切面"><a href="#1-什么是面向切面" class="headerlink" title="1 什么是面向切面"></a>1 什么是面向切面</h3><p>这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。<br>AOP是Spring提供的关键特性之一。AOP即面向切面编程，是OOP编程的有效补充。使用AOP技术，可以将一些系统性相关的编程工作，独立提取出来，独立实现，然后通过切面切入进系统。从而避免了在业务逻辑的代码中混入很多的系统相关的逻辑——比如权限管理，事物管理，日志记录等等。这些系统性的编程工作都可以独立编码实现，然后通过AOP技术切入进系统即可。从而达到了 将不同的关注点分离出来的效果。</p>
<a id="more"></a>

<h3 id="2-AOP术语"><a href="#2-AOP术语" class="headerlink" title="2 AOP术语"></a>2 AOP术语</h3><h4 id="2-1-通知（Advice）"><a href="#2-1-通知（Advice）" class="headerlink" title="2.1 通知（Advice）"></a>2.1 通知（Advice）</h4><p>切面必须要完成的工作即称为通知。通知定义了切面是什么以及什么时候实用。<br>spring切面可以实用的5种类型通知：</p>
<ul>
<li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li>
<li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li>
<li>返回通知（After-returning）：在目标方法成功执行之后调用通知；</li>
<li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li>
<li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li>
</ul>
<h4 id="2-2-连接点（Join-point）"><a href="#2-2-连接点（Join-point）" class="headerlink" title="2.2 连接点（Join point）"></a>2.2 连接点（Join point）</h4><p>我们的应用可能有数以千计的时机应用通知。这些时机被称 为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p>
<h4 id="2-3-切点（Poincut）"><a href="#2-3-切点（Poincut）" class="headerlink" title="2.3 切点（Poincut）"></a>2.3 切点（Poincut）</h4><p>切点定义了从何处切入。切点的定义会匹配通知所要织入的一个或多个连接点。通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p>
<h4 id="2-4-切面（Aspect）"><a href="#2-4-切面（Aspect）" class="headerlink" title="2.4 切面（Aspect）"></a>2.4 切面（Aspect）</h4><p>切面是通知和切点的结合。通知和切点共同定义了切面的全部内容—-它是什么，在何时和何处完成其功能。</p>
<h4 id="2-5-引入（Introduction）"><a href="#2-5-引入（Introduction）" class="headerlink" title="2.5 引入（Introduction）"></a>2.5 引入（Introduction）</h4><p>引入允许我们向现有的类添加新方法或属性。</p>
<h4 id="2-6-织入（Weaving）"><a href="#2-6-织入（Weaving）" class="headerlink" title="2.6 织入（Weaving）"></a>2.6 织入（Weaving）</h4><p>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。</p>
<ul>
<li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li>
<li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ 5的加载时织入（load-timeweaving，LTW）就支持以这种方式织入切面。</li>
<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。</li>
</ul>
<h3 id="3-Spring对切面的支持"><a href="#3-Spring对切面的支持" class="headerlink" title="3 Spring对切面的支持"></a>3 Spring对切面的支持</h3><p>Spring提供了4种类型的AOP支持：</p>
<ul>
<li>基于代理的经典Spring AOP；</li>
<li>纯POJO切面；</li>
<li>@AspectJ注解驱动的切面；</li>
<li>注入式AspectJ切面（适用于Spring各版本）。</li>
</ul>
<p>前三种都是Spring AOP实现的变体，Spring AOP构建在动态代理基础之上，因此，Spring对AOP的支持局限于方法拦截。</p>
<h3 id="4-认识切点"><a href="#4-认识切点" class="headerlink" title="4 认识切点"></a>4 认识切点</h3><p>在Spring AOP中，要使用AspectJ的切点表达式语言来定义切点。<br>首先定义一个接口来作为切点：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> interface Performance &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="type">void</span> <span class="keyword">perform</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>假设我们想编写Performance的perform()方法触发的通 知。下面的表达式能够设置当perform()方法执行时触发通知的调用。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">execution(* com.wtj.springlearn.aop.Performance.<span class="keyword">perform</span>(..))</span></pre></td></tr></table></figure>

<p>execution()指示器选择Performance的perform()方法。方法表达式以“*”号开始，表明了不关心方法返回值的类型。然后指定了全限定类名和方法名。对于方法参数列表，使用两个点号（..）表明切点要选择任意的perform()方法，无论该方法的入参是什么。<br>如果我们需要设置切点匹配com.wtj.springlearn.aop包，可以使用within()来限定匹配。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">execution(* com.wtj.springlearn.aop.Performance.<span class="keyword">perform</span>(..)） &amp;&amp; <span class="keyword">within</span>(com.wtj.springlearn.aop.*)</span></pre></td></tr></table></figure>

<p>表示com.wtj.springlearn.aop包下任意类的方法被调用时。<br>使用“&amp;&amp;”操作符把execution()和within()指示器连接在一起形成与（and）关系（切点必须匹配所有的指示器）。类似地，我们可以使用“||”操作符来标识或（or）关系，而使用“!”操作符来标识非（not）操作。<br>因为“&amp;”在XML中有特殊含义，所以在Spring的XML配置里面描述切点时，我们可以使用and来代替“&amp;&amp;”。同样，or和not可以分别用来代替“||”和“!”。<br>还可以使用bean的ID来标识bean。bean()使用bean ID或bean名称作为参数来限制切点只匹配特定的bean。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">execution(* com.wtj.springlearn.aop.Performance.<span class="keyword">perform</span>(..)) &amp;&amp; bean(<span class="string">'book'</span>)</span></pre></td></tr></table></figure>

<p>这里表示执行perform方法时通知，但是只限于bean的ID为book。</p>
<h3 id="5-通过注解创建切面"><a href="#5-通过注解创建切面" class="headerlink" title="5 通过注解创建切面"></a>5 通过注解创建切面</h3><blockquote>
<p>本篇主要介绍注解方式的切面定义方式</p>
</blockquote>
<p>通过@Aspect进行标注，表示该Audience不仅是一个POJO还是一个切面。类中的方法表示了切面的具体行为。<br>Spring提供了五种注解来定义通知时间：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829144905-e7439.png" alt="img"></p>
<p>首先创建一个切面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//表演前 手机静音</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.wtj.springlearn.aop.Performance.perform(..))"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhone</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"silence Cell Phone"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//表演成功-clap</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"execution(** com.wtj.springlearn.aop.Performance.perform(..))"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clap</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"clap clap clap"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//表演失败-退款</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"execution(** com.wtj.springlearn.aop.Performance.perform(..))"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refund</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"refund refund refund"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Performance的实现类：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@Component</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> PerformanceImpl implements Performance &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">public</span> <span class="type">void</span> <span class="keyword">perform</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("the perform is good");</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>最后还需要开启自动代理功能</strong>，通过JavaConfig进行配置，使用<code>@EnableAspectJAutoProxy</code>标签开启。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@EnableAspectJAutoProxy</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@ComponentScan</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class AudienceConfig &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Audience audience()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">Audience</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>最后通过一个简单的测试用例就可以来验证了。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.<span class="keyword">class</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">@ContextConfiguration(classes = AudienceConfig.<span class="keyword">class</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> PerformanceTest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Performance performance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Test</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">public</span> <span class="type">void</span> perTest()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        performance.<span class="keyword">perform</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">silence Cell Phone</span></pre></td></tr><tr><td class="code"><pre><span class="line">the <span class="keyword">perform</span> <span class="keyword">is</span> good</span></pre></td></tr><tr><td class="code"><pre><span class="line">clap clap clap</span></pre></td></tr></table></figure>

<h4 id="5-1-PointCut声明切点"><a href="#5-1-PointCut声明切点" class="headerlink" title="5.1 @PointCut声明切点"></a>5.1 @PointCut声明切点</h4><p>你会发现上面切面的方法中，切点的声明都是一样的，这种情况下可以使用<code>@Pointcut</code>注解来定义切点。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.wtj.springlearn.aop.Performance.perform(..))"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">per</span><span class="params">()</span></span>&#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表演前 手机静音</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"per()"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">silenceCellPhone</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"silence Cell Phone"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>per()方法本身并不重要，该方法只是一个标识，供@PointCut注解依附。</p>
<h4 id="5-2-环绕通知"><a href="#5-2-环绕通知" class="headerlink" title="5.2 环绕通知"></a>5.2 环绕通知</h4><p>环绕通知是最为强大的通知类型。它能够让你所编写的逻辑将被通知的目标方法完全包装起来。实际上就像在一个通知方法中同时编写前置通知和后置通知。<br>重写Audience切面，使用环绕通知替代之前多个不同的前置通知和后置通知。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@Around("per()")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> watch(ProceedingJoinPoint <span class="type">point</span>) throws Throwable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    try&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("silence Cell Phone");</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="type">point</span>.proceed();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("clap clap clap");</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;catch (<span class="keyword">Exception</span> e)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("refund refund refund");</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>首先注意到的可能是它接受ProceedingJoinPoint作为参数。这个对象是必须要有的，因为你要在通知中通过它来调用被通知的方法。通知方法中可以做任何的事情，当要将控制权交给被通知的方法时，它需要调用ProceedingJoinPoint的proceed()方法。<br>如果不调proceed()这个方法的话，那么你的通知实际上会阻塞对被通知方法的调用。同样的，你也可以调用多次。</p>
<h4 id="5-3-向通知中传入参数"><a href="#5-3-向通知中传入参数" class="headerlink" title="5.3 向通知中传入参数"></a>5.3 向通知中传入参数</h4><p>上面我们创建的切面都很简单，没有任何参数。那么切面能访问和使用传递给被通知方法的参数么？<br>Performance中新增方法：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="keyword">perform</span>(String <span class="type">name</span>);</span></pre></td></tr></table></figure>

<p>实现类：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> <span class="keyword">perform</span>(String <span class="type">name</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("下面请 "+<span class="type">name</span>+" 开始他的表演");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>修改Audience中的切点和切面</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@Pointcut("execution(* com.wtj.springlearn.aop.Performance.perform(String)) &amp;&amp; args(name)")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> per(String <span class="type">name</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Around("per(name)")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> toWatch(ProceedingJoinPoint <span class="type">point</span>, String <span class="type">name</span>) throws Throwable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    try &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="type">point</span>.proceed();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span> + " 上场啦");</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span> + " 演出结束");</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; catch (<span class="keyword">Exception</span> e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("refund refund refund");</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>表达式<code>args(name)</code>限定符，它表示传递给perform(String name)方法的String类型参数也会传到通知中去，参数名与切点中的参数名相同。<code>perform(String)</code>指明了传入参数的类型。<br>然后在<code>@Around</code>注解中指明切点与参数名，这样就完成了参数转移。<br>最后修改一下测试用例就完成了</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@Test</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> perTest()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    performance.<span class="keyword">perform</span>("渣渣辉");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>打印输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下面请 渣渣辉 开始他的表演</span></pre></td></tr><tr><td class="code"><pre><span class="line">渣渣辉 上场啦</span></pre></td></tr><tr><td class="code"><pre><span class="line">渣渣辉 演出结束</span></pre></td></tr></table></figure>

<h4 id="5-4-通过注解-DeclareParents引入新方法"><a href="#5-4-通过注解-DeclareParents引入新方法" class="headerlink" title="5.4 通过注解@DeclareParents引入新方法"></a>5.4 通过注解@DeclareParents引入新方法</h4><p>如果我们想在一个类上新增方法，通常情况下我们会怎么做呢？最简单的办法就是在此目标类上增加此方法，但是如果原目标类非常复杂，动一发而牵全身。并且有些时候我们是没有目标类的源码的，哪这个时候怎么办呢？<br>我们可以为需要添加的方法建立一个类，然后建一个代理类，同时代理该类和目标类。用一个图来表示</p>
<p><img src="http://image.winrains.cn/2019/08/20190829144906-93ff8.png" alt="img"></p>
<p>当引入接口的方法被调用时，代理会把此调用委托给实现了新接口的某个其他对象。<br>还是上面的例子，假设我们需要让表演者跳起来。<br>新建Jump接口以及实现类：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">Jump</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">void</span> duJump();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">JumpImpl</span> <span class="symbol">implements</span> <span class="symbol">Jump</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> duJump() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"do Jump"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后我们代理两个类：</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@Aspect</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> JumpIntroducer &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">@DeclareParents</span>(value = <span class="string">"com.wtj.springlearn.aop.Performance+"</span>,defaultImpl = JumpImpl.<span class="keyword">class</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jump jump;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>@DeclareParents注解由三部分组成：</p>
<ul>
<li>value属性指定了哪种类型的bean要引入该接口。在本例中，也就是所有实现Performance的类型。（标记符后面的加号表示是Performance的所有子类型，而不是Performance本 身。）</li>
<li>defaultImpl属性指定了为引入功能提供实现的类。</li>
<li>@DeclareParents注解所标注的静态属性指明了要引入了接 口。</li>
</ul>
<p><strong>通过配置将JumpIntroducer声明</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@ComponentScan</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@EnableAspectJAutoProxy</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class JumpConfig &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public JumpIntroducer jumpIntroducer()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">JumpIntroducer</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>或者你也可以在JumpIntroducer类上加入<code>@Component</code>注解，就可以不用声明bean了。<br>最后通过测试用例进行测试：</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@RunWith</span>(SpringJUnit4ClassRunner.<span class="keyword">class</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@ContextConfiguration</span>(classes = JumpConfig.<span class="keyword">class</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> PerformanceTest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Performance performance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">@Test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> perTest()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//类型转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Jump jump = (Jump) performance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        jump.duJump();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> Jump</span></pre></td></tr></table></figure>

<blockquote>
<p>作者：爱西考的王同学</p>
<p>来源：<a href="https://juejin.im/post/5d394d4ce51d4550a629b35a" target="_blank" rel="noopener">https://juejin.im/post/5d394d4ce51d4550a629b35a</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud介绍</title>
    <url>/2019/12/26/Spring-Cloud%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><blockquote>
<p>只有光头才能变强</p>
</blockquote>
<p>认识我的朋友可能都知道我这阵子去实习啦，去的公司说是用SpringCloud(但我觉得使用的力度并不大啊<del>)…<br>所以，这篇主要来讲讲SpringCloud的一些基础的知识。(我就是现学现卖了，主要当做我学习SpringCloud的笔记吧！)当然了，我的水平是有限的，可能会有一些理解错的的概念/知识点，还请大家不吝在评论区指正啊</del></p>
<a id="more"></a>

<p>SpringCloud GitHub Demo(看完文章的同学可以自己练手玩玩)：</p>
<ul>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FZhongFuCheng3y%2Fmsc-Demo">github.com/ZhongFuChen…</a></li>
</ul>
<p>项目结构图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151036-c9caa.png" alt="img"></p>
<h1 id="二、集群-分布式-微服务-SOA是什么？"><a href="#二、集群-分布式-微服务-SOA是什么？" class="headerlink" title="二、集群/分布式/微服务/SOA是什么？"></a>二、集群/分布式/微服务/SOA是什么？</h1><p>像我这种技术小白，看到这些词(<code>集群/分布式/微服务/SOA</code>)的时候，感觉就是遥不可及的(高大尚的技术！！)。就好像刚学Java面向对象的时候，在论坛上翻阅资料的时候，无意看到”面向切面编程”，也认为这是遥不可及的(高大尚的技术！！)。<br>但真正接触到”面向切面编程”的时候，发现原来就是如此啊，也没什么大不了的。只不过当时被它的名字给唬住了…<br>不知道各位在刚接触这些名字<code>集群/分布式/微服务/SOA</code>的时候，有没有被唬住了呢？？</p>
<ul>
<li>下面我就<strong>简单</strong>说说这些名词的意思</li>
</ul>
<h2 id="2-1什么是集群"><a href="#2-1什么是集群" class="headerlink" title="2.1什么是集群"></a>2.1什么是集群</h2><p>以下内容来源维基百科：</p>
<blockquote>
<p>计算机集群简称集群是一种计算机系统，它通过一组松散集成的计算机软件和/或硬件连接起来高度紧密地协作完成计算工作。在某种意义上，他们可以被看作是一台计算机。集群系统中的单个计算机通常称为节点，通常通过局域网连接，但也有其它的可能连接方式。集群计算机通常用来改进单个计算机的计算速度和/或可靠性。一般情况下集群计算机比单个计算机，比如工作站或超级计算机性能价格比要高得多</p>
</blockquote>
<p>集群技术特点：</p>
<ul>
<li>通过<strong>多台计算机完成同一个工作</strong>，达到更高的效率。</li>
<li><strong>两机或多机内容、工作过程等完全一样</strong>。如果一台死机，另一台可以起作用。</li>
</ul>
<p>在维基百科上说得也挺明白的了，我来举个<strong>例子</strong>吧。</p>
<ul>
<li><p>小周在公司写Java程序，但公司业务在发展，一个Java开发者可能</p>
<p>忙不过来</p>
<p>，小周有的时候也得</p>
<p>请个假呀</p>
<p>。于是请了3y过去</p>
<p>一起做Java开发</p>
<p>。平时小周和3y就写Java程序，但3y可能</p>
<p>有事</p>
<p>要回学校一趟。没事，公司还有小周做Java开发呢，公司开发还能继续运作。</p>
<ul>
<li>3y跟小周<strong>都是做Java开发</strong>。</li>
<li>3y来了，小周的工作可以<strong>分担</strong>一些。</li>
<li>3y请假了，还有小周在呢。</li>
</ul>
</li>
</ul>
<p>我写了一个910便利网发布到服务器去了，现在越来越多的人访问了，访问有点慢，怎么办？？？很简单，(只有充钱才能变强)，加配置吧(加cpu，加内存)。升级完配置之后，访问人数越来越多，于是发现又不禁用啦，在这台机器上加配置已经解决不了了，怎么办？？？很简单，(只有充钱才能变强)，我<strong>再买一台服务器，将910便利网也发布到新买的这台服务器上去</strong>。<br>特点：</p>
<ul>
<li>这两台服务器都是运行<strong>同一个系统</strong>—&gt;910便利网</li>
</ul>
<p>好处：</p>
<ul>
<li>本来只有一台机器处理访问，现在有两台机器处理访问了，<strong>分担了压力</strong>。</li>
<li>如果其中一台忘记缴费了，暂时用不了了。没关系，还有另一台可以用呢。</li>
</ul>
<p><strong>集群</strong>：同一个业务，部署在多个服务器上(不同的服务器运行同样的代码，干同一件事)</p>
<h2 id="2-2什么是分布式"><a href="#2-2什么是分布式" class="headerlink" title="2.2什么是分布式"></a>2.2什么是分布式</h2><p>以下内容来源维基百科：</p>
<blockquote>
<p>分布式系统是一组计算机，通过网络相互连接传递消息与通信后并协调它们的行为而形成的系统。<strong>组件之间彼此进行交互以实现一个共同的目标</strong>。</p>
</blockquote>
<p>我也来举个例子来说明一下吧：</p>
<ul>
<li><p>现在公司有小周和3y一起做Java开发，做Java开发一般jQuery，AJAX都能写一点，所以这些活都由我们来干。可是呢，3y对前端不是很熟，有的时候调试半天都调不出来。老板认为3y是真的菜！于是让小周</p>
<p>专门来处理前端</p>
<p>的事情。这样3y就高兴了，可以</p>
<p>专心写自己的Java</p>
<p>，前端就</p>
<p>专门</p>
<p>交由小周负责了。于是，小周和3y就变成了</p>
<p>协作开发</p>
<p>。</p>
<ul>
<li>3y对前端不熟(能写出来)，但在调试的时候可能会花费很多时间</li>
<li>小周来<strong>专门做前端</strong>的事，3y可以<strong>专心写自己的Java程序</strong>了。</li>
<li>都是为了项目正常运行以及迭代。</li>
</ul>
</li>
</ul>
<p>我的910便利网已经部署到两台服务器去了，但是越来越多的人去访问。现在也逐渐承受不住啦。那现在怎么办啊？？那继续充钱变强？？作为一个理智的我，肯定得想想是哪里有问题。现在910便利网的模块有好几个，全都丢在同一个Tomcat里边。<br>其实有些模块的访问是很低的(比如后台管理)，那我可不可以这样做：将每个模块<strong>抽取独立</strong>出来，访问量大的模块用好的服务器装着，没啥人访问的模块用差的服务器装着。这样的好处是：一、<strong>资源合理利用了</strong>(没人访问的模块用性能差的服务器，访问量大的模块<strong>单独提升性能</strong>就好了)。二、<strong>耦合度降低了</strong>：每个模块独立出来，各干各的事(专业的人做专业的事)，便于扩展<br>特点：</p>
<ul>
<li>将910便利网的<strong>功能拆分，模块之间独立</strong>，在使用的时候再将这些<strong>独立的模块组合起来</strong>就是一个系统了。</li>
</ul>
<p>好处：</p>
<ul>
<li>模块之间独立，各做各的事，<strong>便于扩展，复用性高</strong></li>
<li><strong>高吞吐量</strong>。某个任务需要一个机器运行10个小时，将该任务用10台机器的分布式跑(将这个任务拆分成10个小任务)，可能2个小时就跑完了</li>
</ul>
<p><strong>分布式</strong>：一个业务分拆多个子业务，部署在不同的服务器上(不同的服务器，运行不同的代码，为了同一个目的)</p>
<h2 id="2-3集群-分布式"><a href="#2-3集群-分布式" class="headerlink" title="2.3集群/分布式"></a>2.3集群/分布式</h2><p>集群和分布式并不冲突，可以有<strong>分布式集群</strong><br>现在3y的公司规模变大了，有5个小伙子写Java，4个小伙子写前端，2个小伙子做测试，1个小伙子做DBA。</p>
<ul>
<li>Java，前端，测试，DBA的关系看作是分布式的</li>
<li>5个Java看作是集群的(前端，测试同理)…</li>
</ul>
<h2 id="2-4分布式-微服务-SOA"><a href="#2-4分布式-微服务-SOA" class="headerlink" title="2.4分布式/微服务/SOA"></a>2.4分布式/微服务/SOA</h2><p>其实我认为分布式/微服务/SOA这三个概念是差不多的，了解了其中的一个，然后将自己的理解往上面套就好了。<strong>没必要细分每个的具体概念</strong>~~(当然了，我很期待有大佬可以在评论区留言说下自己的看法哈)<br>参考资料：</p>
<ul>
<li>分布式与集群的区别是什么？<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F20004877">www.zhihu.com/question/20…</a></li>
<li>分布式、集群、微服务、SOA 之间的区别<a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fheatdeath%2Farticle%2Fdetails%2F79038795">blog.csdn.net/heatdeath/a…</a></li>
</ul>
<h1 id="三、CAP理论"><a href="#三、CAP理论" class="headerlink" title="三、CAP理论"></a>三、CAP理论</h1><p>从上面所讲的分布式概念我们已经知道，分布式简单理解就是：<strong>一个业务分拆多个子业务，部署在不同的服务器上</strong></p>
<ul>
<li>一般来说，一个子业务我们称为<strong>节点</strong>。</li>
</ul>
<p>如果你接触过一些分布式的基础概念，那肯定会听过CAP这个理论。就比如说：你学了MySQL的InnoDB存储引擎相关知识，你肯定听过ACID！<br>首先，我们来看一下CAP分别代表的是什么意思：</p>
<ul>
<li>C：数据一致性(consistency)<ul>
<li><strong>所有</strong>节点拥有数据的最新版本</li>
</ul>
</li>
<li>A：可用性(availability)<ul>
<li>数据具备高可用性</li>
</ul>
</li>
<li>P：分区容错性(partition-tolerance)<ul>
<li><strong>容忍网络出现分区</strong>，分区之间网络不可达。</li>
</ul>
</li>
</ul>
<p>下面有三个节点(它们是集群的)，此时三个节点都能够相互通信：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151037-626c9.png" alt="img"></p>
<p>由于我们的系统是分布式的，节点之间的通信是通过网络来进行的。<strong>只要是分布式系统</strong>，那很有可能会出现一种情况：因为一些<strong>故障</strong>，使得有些<strong>节点之间不连通</strong>了，整个网络就分成了<strong>几块区域</strong>。</p>
<ul>
<li>数据就散布在了这些不连通的区域中，这就叫<strong>分区</strong></li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829151038-3bfa5.png" alt="img"></p>
<p>现在出现了网络分区后，此时有一个请求过来了，想要注册一个账户。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151038-1e806.png" alt="img"></p>
<p>此时我们<strong>节点一和节点三是不可通信的</strong>，这就有了抉择：</p>
<ul>
<li><p>如果</p>
<p>允许</p>
<p>当前用户注册一个账户，此时注册的记录数据只会在节点一和节点二或者节点二和节点三</p>
<p>同步</p>
<p>，因为节点一和节点三的记录不能同步的。</p>
<ul>
<li>这种情况其实就是选择了可用性(availability)，抛弃了数据一致性(consistency)</li>
</ul>
</li>
<li><p>如果</p>
<p>不允许</p>
<p>当前用户注册一个账户(就是要</p>
<p>等到</p>
<p>节点一和节点三恢复通信)。节点一和节点三一旦恢复通信，我们就可以</p>
<p>保证节点拥有的数据是最新版本</p>
<p>。</p>
<ul>
<li>这种情况其实就是抛弃了可用性(availability)，选择了数据一致性(consistency)</li>
</ul>
</li>
</ul>
<h2 id="3-1再次梳理一下CAP理论"><a href="#3-1再次梳理一下CAP理论" class="headerlink" title="3.1再次梳理一下CAP理论"></a>3.1再次梳理一下CAP理论</h2><p>一般我们说的分布式系统，P：分区容错性(partition-tolerance)这个是<strong>必需</strong>的，这是客观存在的。<br>CAP是无法完全兼顾的，从上面的例子也可以看出，我们可以选AP，也可以选CP。但是，要<strong>注意的是</strong>：不是说选了AP，C就完全抛弃了。不是说选了CP，A就完全抛弃了！<br>在CAP理论中，<strong>C所表示的一致性是强一致性</strong>(每个节点的数据都是最新版本)，其实一致性还有其他级别的：</p>
<ul>
<li>弱一致性：弱一致性是相对于强一致性而言，它不保证总能得到最新的值；</li>
<li>最终一致性(eventual consistency)：放宽对时间的要求，在被调完成操作响应后的某个时间点，被调多个节点的数据最终达成一致</li>
</ul>
<p>可用性的值域可以定义成<strong>0到100%的连续区间</strong>。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151039-cf259.png" alt="img"></p>
<p>所以，<strong>CAP理论定义的其实是在容忍网络分区的条件下，“强一致性”和“极致可用性”无法同时达到</strong>。<br>参考资料：</p>
<ul>
<li>CAP理论中的P到底是个什么意思？<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F54105974">www.zhihu.com/question/54…</a></li>
<li>浅谈分布式系统的基本问题：可用性与一致性：<a href="https://link.juejin.im?target=https%3A%2F%2Fm.aliyun.com%2Fyunqi%2Farticles%2F2709">m.aliyun.com/yunqi/artic…</a></li>
<li>分布式系统的CAP理论：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F666">www.hollischuang.com/archives/66…</a></li>
<li>为什么CAP理论在舍弃P的情况下，可以有完美的CA？<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F285878189">www.zhihu.com/question/28…</a></li>
<li>不懂点CAP理论，你好意思说你是做分布式的吗？<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.yunweipai.com%2Farchives%2F8432.html">www.yunweipai.com/archives/84…</a></li>
</ul>
<p>扩展阅读：</p>
<ul>
<li>浅谈分布式事务：<a href="https://link.juejin.im?target=https%3A%2F%2Fm.aliyun.com%2Fyunqi%2Farticles%2F230242">m.aliyun.com/yunqi/artic…</a></li>
</ul>
<h1 id="四、SpringCloud就是这么简单"><a href="#四、SpringCloud就是这么简单" class="headerlink" title="四、SpringCloud就是这么简单"></a>四、SpringCloud就是这么简单</h1><p>相信大家读到这里，对分布式/微服务已经有一定的了解了，其实单从概念来说，是非常容易理解的。只是很可能被它的名字给唬住了。<br>下面我就来讲讲SpringCloud<strong>最基础</strong>的知识~</p>
<h2 id="4-1为什么需要SpringCloud？"><a href="#4-1为什么需要SpringCloud？" class="headerlink" title="4.1为什么需要SpringCloud？"></a>4.1为什么需要SpringCloud？</h2><p>前面也讲了，从分布式/微服务的角度而言：就是把我们一<strong>大</strong>的项目，<strong>分解</strong>成多个<strong>小</strong>的模块。这些小的模块组合起来，完成功能。<br>举个可能不太恰当的例子(现实可能不会这么拆分，但意思到位就好了)：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151040-e70c0.png" alt="img"></p>
<p>拆分出多个模块以后，就会出现<strong>各种各样</strong>的问题，而SpringCloud提供了<strong>一整套</strong>的解决方案！</p>
<ul>
<li>注：这些模块是<strong>独立</strong>成一个子系统的(不同主机)。</li>
</ul>
<p>SpringCloud的<strong>基础功能</strong>：</p>
<ul>
<li>服务治理： Spring Cloud Eureka</li>
<li>客户端负载均衡： Spring Cloud Ribbon</li>
<li>服务容错保护： Spring Cloud Hystrix</li>
<li>声明式服务调用： Spring Cloud Feign</li>
<li>API网关服务：Spring Cloud Zuul</li>
<li>分布式配置中心： Spring Cloud Config</li>
</ul>
<p>SpringCloud的高级功能(本文不讲)：</p>
<ul>
<li>消息总线： Spring Cloud Bus</li>
<li>消息驱动的微服务： Spring Cloud Stream</li>
<li>分布式服务跟踪： Spring Cloud Sleuth</li>
</ul>
<h1 id="五、引出Eureka"><a href="#五、引出Eureka" class="headerlink" title="五、引出Eureka"></a>五、引出Eureka</h1><p>那会出现什么问题呢？？首当其冲的就是子系统之间的<strong>通讯</strong>问题。子系统与子系统之间不是在同一个环境下，那就需要<strong>远程调用</strong>。远程调用可能就会想到httpClient，WebService等等这些技术来实现。<br>既然是远程调用，就必须知道ip地址，我们可能有以下的场景。</p>
<ul>
<li>功能实现一：A服务需要调用B服务<ul>
<li>在A服务的代码里面调用B服务，<strong>显式通过IP地址调用</strong>：<code>http://123.123.123.123:8888/java3y/3</code></li>
</ul>
</li>
<li>功能实现二：A服务调用B服务，B服务调用C服务，C服务调用D服务<ul>
<li>在A服务的代码里面调用B服务，显式通过IP地址调用：<code>http://123.123.123.123:8888/java3y/3</code>，(同样地)B-&gt;C，C-&gt;D</li>
</ul>
</li>
<li>功能实现三：D服务调用B服务，B服务调用C服务<ul>
<li>在D服务的代码里面调用B服务，显式通过IP地址调用：<code>http://123.123.123.123:8888/java3y/3</code>，(同样地)B-&gt;C</li>
</ul>
</li>
<li>…..等等等等</li>
</ul>
<p>万一，我们<strong>B服务的IP地址变了</strong>，想想会出现什么问题：A服务,D服务(等等)需要<strong>手动更新</strong>B服务的地址</p>
<ul>
<li>在服务多的情况下，手动来维护这些静态配置就是噩梦！</li>
</ul>
<blockquote>
<p>为了解决微服务架构中的<strong>服务实例维护问题(ip地址)</strong>， 产生了大量的<strong>服务治理</strong>框架和产品。 这些框架和产品的实现都围绕着服务注册与服务发现机制来完成对微服务应用实例的<strong>自动化管理</strong>。</p>
</blockquote>
<p>在SpringCloud中我们的服务治理框架一般使用的就是Eureka。<br>我们的问题：</p>
<ul>
<li>现在有A、B、C、D四个服务，它们之间会互相调用(而且IP地址很可能会发生变化)，一旦某个服务的IP地址变了，那服务中的代码要跟着变，手动维护这些静态配置(IP)非常麻烦！</li>
</ul>
<p>Eureka是这样解决上面所说的情况的：</p>
<ul>
<li>创建一个E服务，将A、B、C、D四个服务的信息都<strong>注册</strong>到E服务上，E服务维护这些已经注册进来的信息</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829151040-c277f.png" alt="img"></p>
<p>A、B、C、D四个服务都可以<strong>拿到</strong>Eureka(服务E)那份<strong>注册清单</strong>。A、B、C、D四个服务互相调用不再通过具体的IP地址，而是<strong>通过服务名来调用</strong>！</p>
<ul>
<li>拿到注册清单—&gt;注册清单上有服务名—&gt;自然就能够拿到服务具体的位置了(IP)。</li>
<li>其实简单来说就是：代码中通过<strong>服务名找到对应的IP地址</strong>(IP地址会变，但服务名一般不会变)</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829151042-3b61f.png" alt="img"></p>
<h2 id="5-1Eureka细节"><a href="#5-1Eureka细节" class="headerlink" title="5.1Eureka细节"></a>5.1Eureka细节</h2><p>Eureka专门用于给其他服务注册的称为Eureka Server(服务注册中心)，其余注册到Eureka Server的服务称为Eureka Client。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151042-81de6.png" alt="img"></p>
<p>在Eureka Server一般我们会这样配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">register-with-eureka:</span> <span class="literal">false</span>     <span class="comment">#false表示不向注册中心注册自己。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">fetch-registry:</span> <span class="literal">false</span>     <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span></pre></td></tr></table></figure>

<p>Eureka Client<strong>分为服务提供者和服务消费者</strong>。</p>
<ul>
<li>但很可能，某服务<strong>既是服务提供者又是服务消费者</strong>。</li>
</ul>
<p>如果在网上看到SpringCloud的<strong>某个服务配置没有”注册”到Eureka-Server也不用过于惊讶</strong>(但是它是可以获取Eureka服务清单的)</p>
<ul>
<li>很可能只是作者把该服务认作为<strong>单纯的服务消费者</strong>，单纯的服务消费者无需对外提供服务，也就无须注册到Eureka中了</li>
</ul>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="symbol">eureka:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="symbol">client:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    register-<span class="keyword">with</span>-<span class="symbol">eureka:</span> <span class="literal">false</span>  <span class="comment"># 当前微服务不注册到eureka中(消费端)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    service-<span class="symbol">url:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="symbol">defaultZone:</span> <span class="symbol">http:</span>/<span class="regexp">/eureka7001.com:7001/eureka</span><span class="regexp">/,http:/</span><span class="regexp">/eureka7002.com:7002/eureka</span><span class="regexp">/,http:/</span><span class="regexp">/eureka7003.com:7003/eureka</span><span class="regexp">/</span></span></pre></td></tr></table></figure>

<p>下面是Eureka的治理机制：</p>
<ul>
<li>服务提供者<ul>
<li><strong>服务注册：启动的时候会通过发送REST请求的方式将自己注册到Eureka Server上</strong>，同时带上了自身服务的一些元数据信息。</li>
<li><strong>服务续约：</strong>在注册完服务之后，<strong>服务提供者会维护一个心跳</strong>用来持续告诉Eureka Server: “我还活着 ” 、</li>
<li><strong>服务下线：当服务实例进行正常的关闭操作时，它会触发一个服务下线的REST请求</strong>给Eureka Server, 告诉服务注册中心：“我要下线了 ”。</li>
</ul>
</li>
<li>服务消费者<ul>
<li><strong>获取服务：当我们启动服务消费者</strong>的时候，它会发送一个REST请求给服务注册中心，来获取上面注册的服务清单</li>
<li><strong>服务调用：服务消费者在获取服务清单后，通过服务名</strong>可以获得具体提供服务的实例名和该实例的元数据信息。在进行服务调用的时候，<strong>优先访问同处一个Zone中的服务提供方</strong>。</li>
</ul>
</li>
<li>Eureka Server(服务注册中心)：<ul>
<li><strong>失效剔除：</strong>默认每隔一段时间（默认为60秒） 将当前清单中超时（默认为90秒）<strong>没有续约的服务剔除出去</strong>。</li>
<li><strong>自我保护：</strong>。EurekaServer 在运行期间，会统计心跳失败的比例在15分钟之内是否低于85%(通常由于网络不稳定导致)。 Eureka Server会将当前的<strong>实例注册信息保护起来</strong>， 让这些实例不会过期，尽可能<strong>保护这些注册信息</strong>。</li>
</ul>
</li>
</ul>
<p>最后，我们就有了这张图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151043-cdb68.png" alt="img"></p>
<p>举个例子：</p>
<ul>
<li>3y跟女朋友去东站的东方宝泰逛街，但不知道东方宝泰有什么好玩的。于是就去<strong>物业</strong>搜了一下<strong>东方宝泰商户清单</strong>，发现一楼有优衣库，二楼有星巴克，三楼有麦当劳。</li>
<li>在优衣库旁边，有新开张的KFC，在墙壁打上了很大的标识“欢迎KFC<strong>入驻</strong>东方宝泰”。</li>
<li>商家们需要定时<strong>交物业费</strong>给物业。</li>
<li><strong>物业维持</strong>东方宝泰的稳定性。如果某个商家不想在东方宝泰运营了，告诉了物业。物业自然就会将其在东方宝泰商户清单去除。</li>
</ul>
<p>优秀博文：</p>
<ul>
<li>Spring Cloud Eureka详解：<a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fsunhuiliang85%2Farticle%2Fdetails%2F76222517">blog.csdn.net/sunhuiliang…</a></li>
<li>《Spring Cloud Netflix》 – 服务注册和服务发现-Eureka 的使用：<a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F26472547">zhuanlan.zhihu.com/p/26472547</a></li>
<li>微服务架构：Eureka参数配置项详解：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Ffangfuhai%2Fp%2F7070325.html">www.cnblogs.com/fangfuhai/p…</a></li>
</ul>
<h1 id="六、引出RestTemplate和Ribbon"><a href="#六、引出RestTemplate和Ribbon" class="headerlink" title="六、引出RestTemplate和Ribbon"></a>六、引出RestTemplate和Ribbon</h1><p>通过Eureka服务治理框架，我们可以通过服务名来获取具体的服务实例的位置了(IP)。一般在使用SpringCloud的时候<strong>不需要自己手动创建</strong>HttpClient来进行远程调用。<br>可以使用Spring封装好的<strong>RestTemplate</strong>工具类，使用起来很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统的方式，直接显示写死IP是不好的！</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// private static final String REST_URL_PREFIX = "http://localhost:8001";</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 服务实例名</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REST_URL_PREFIX = <span class="string">"http://MICROSERVICECLOUD-DEPT"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 使用 使用restTemplate访问restful接口非常的简单粗暴无脑。 (url, requestMap,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * ResponseBean.class)这三个参数分别代表 REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/consumer/dept/add"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Dept dept)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> restTemplate.postForObject(REST_URL_PREFIX + <span class="string">"/dept/add"</span>, dept, Boolean<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>为了实现服务的<strong>高可用</strong>，我们可以将<strong>服务提供者集群</strong>。比如说，现在一个秒杀系统设计出来了，准备上线了。在11月11号时为了能够支持高并发，我们开多台机器来支持并发量。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151044-6ca5a.png" alt="img"></p>
<p>现在想要这三个秒杀系统<strong>合理摊分</strong>用户的请求(专业来说就是负载均衡)，可能你会想到nginx。<br>其实SpringCloud也支持的负载均衡功能，只不过它是<strong>客户端的负载均衡</strong>，这个功能实现就是Ribbon！<br>负载均衡又区分了两种类型：</p>
<ul>
<li>客户端负载均衡(Ribbon)<ul>
<li>服务实例的<strong>清单在客户端</strong>，客户端进行负载均衡算法分配。</li>
<li>(从上面的知识我们已经知道了：客户端可以从Eureka Server中得到一份服务清单，在发送请求时通过负载均衡算法，<strong>在多个服务器之间选择一个进行访问</strong>)</li>
</ul>
</li>
<li>服务端负载均衡(Nginx)<ul>
<li>服务实例的<strong>清单在服务端</strong>，服务器进行负载均衡算法分配</li>
</ul>
</li>
</ul>
<p>所以，我们的图可以画成这样：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151045-bac78.png" alt="img"></p>
<h2 id="6-1Ribbon细节"><a href="#6-1Ribbon细节" class="headerlink" title="6.1Ribbon细节"></a>6.1Ribbon细节</h2><p>Ribbon是支持负载均衡，默认的负载均衡策略是轮询，我们也是可以根据自己实际的需求自定义负载均衡策略的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelfRule</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">myRule</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// return new RandomRule();// Ribbon默认是轮询，我自定义为随机</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// return new RoundRobinRule();// Ribbon默认是轮询，我自定义为随机</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule_ZY();<span class="comment">// 我自定义为每台机器5次</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>实现起来也很简单：继承AbstractLoadBalancerRule类，重写<code>public Server choose(ILoadBalancer lb, Object key)</code>即可。<br>SpringCloud 在CAP理论是选择了AP的，在Ribbon中还可以配置<strong>重试机制</strong>的(有兴趣的同学可以去搜搜)~<br>举个例子：</p>
<ul>
<li>3y跟女朋友过了几个月，又去东方宝泰了。由于记性不好，又去物业那弄了一份东方宝泰商户清单。</li>
<li>这次看到东方宝泰又开了一间麦当劳，一间在二楼，一间在三楼。原来生意太好了，为了能提高用户体验，在二楼<strong>多开了一间麦当劳</strong>。</li>
<li>这时，3y问女朋友：“去哪间麦当劳比较好？要不我们抛硬币决定？”3y女朋友说：”你是不是傻，肯定哪间近去哪间啊“</li>
</ul>
<p>优秀博文：</p>
<ul>
<li>撸一撸Spring Cloud Ribbon的原理-负载均衡策略：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fkongxianghai%2Fp%2F8477781.html">www.cnblogs.com/kongxiangha…</a></li>
</ul>
<h1 id="七、引出Hystrix"><a href="#七、引出Hystrix" class="headerlink" title="七、引出Hystrix"></a>七、引出Hystrix</h1><p>到目前为止，我们的服务看起来好像挺好的了：能够根据服务名来远程调用其他的服务，可以实现客户端的负载均衡。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151046-2109a.png" alt="img"></p>
<p>但是，如果我们在<strong>调用多个远程服务时，某个服务出现延迟</strong>，会怎么样？？</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151047-90a16.jpeg" alt="img"></p>
<p>在<strong>高并发</strong>的情况下，由于单个服务的延迟，可能导致<strong>所有的请求都处于延迟状态</strong>，甚至在几秒钟就使服务处于负载饱和的状态，资源耗尽，直到不可用，最终导致这个分布式系统都不可用，这就是“雪崩”。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151047-1ef55.jpeg" alt="img"></p>
<p>针对上述问题， Spring Cloud Hystrix实现了<strong>断路器、线程隔离</strong>等一系列服务保护功能。</p>
<ul>
<li>Fallback(失败快速返回)：当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝）， <strong>向调用方返回一个错误响应， 而不是长时间的等待</strong>。这样就不会使得线程因调用故障服务被长时间占用不释放，<strong>避免</strong>了故障在分布式系统中的<strong>蔓延</strong>。</li>
<li>资源/依赖隔离(线程池隔离)：它会为<strong>每一个依赖服务创建一个独立的线程池</strong>，这样就算某个依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响， 而<strong>不会拖慢其他的依赖服务</strong>。</li>
</ul>
<p>Hystrix提供几个熔断关键参数：<code>滑动窗口大小（20）、 熔断器开关间隔（5s）、错误率（50%）</code></p>
<ul>
<li>每当20个请求中，有50%失败时，熔断器就会打开，此时再调用此服务，将会<strong>直接返回失败</strong>，不再调远程服务。</li>
<li>直到5s钟之后，重新检测该触发条件，<strong>判断是否把熔断器关闭，或者继续打开</strong>。</li>
</ul>
<p>Hystrix还有请求合并、请求缓存这样强大的功能，在此我就不具体说明了，有兴趣的同学可继续深入学习~</p>
<h2 id="7-1Hystrix仪表盘"><a href="#7-1Hystrix仪表盘" class="headerlink" title="7.1Hystrix仪表盘"></a>7.1Hystrix仪表盘</h2><p>Hystrix仪表盘：它主要用来<strong>实时监控Hystrix的各项指标信息</strong>。通过Hystrix Dashboard反馈的实时信息，可以帮助我们快速发现系统中存在的问题，从而及时地采取应对措施。<br>启动时的页面：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151048-d634c.png" alt="img"></p>
<p><strong>监控单服务</strong>的页面：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151049-6494b.png" alt="img"></p>
<p>我们现在的服务是这样的：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151050-b2592.png" alt="img"></p>
<p>除了可以开启单个实例的监控页面之外，还有一个监控端点 <code>/turbine.stream</code>是对<strong>集群</strong>使用的。 从端点的命名中，可以引入Turbine, 通过它来<strong>汇集监控信息</strong>，并将聚合后的信息提供给 HystrixDashboard 来<strong>集中展示和监控</strong>。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151051-75606.png" alt="img"></p>
<p>举个例子：</p>
<ul>
<li>3y和女朋友决定去万达玩，去到万达的停车场发现在负一层已经大大写上“负一层已停满，请下负二层，负二层空余停车位还有100个！”</li>
<li>这时，3y就跟女朋友说：“万达停车场是做得挺好的，如果它没有<strong>直接</strong>告知我负一层已满，可能我就去负一层找位置了，要是一堆人跑去负一层但都找不到车位的话，恐怕就塞死了”。3y接着说：“看停车位的状态也做得不错，在停车位上头有一个<strong>感应(监控)</strong>，如果是红色就代表已被停了，如果是绿色就说明停车位是空的”。</li>
<li>3y女朋友不屑的说：“你话是真的多”</li>
</ul>
<p>参考资料：</p>
<ul>
<li>Hystrix ，为什么说它是每个系统不可或缺的开源框架？<a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F34304136">zhuanlan.zhihu.com/p/34304136</a></li>
<li>深入理解Hystrix之文档翻译：<a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F28523060">zhuanlan.zhihu.com/p/28523060</a></li>
<li>谈谈我对服务熔断、服务降级的理解：<a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fguwei9111986%2Farticle%2Fdetails%2F51649240">blog.csdn.net/guwei911198…</a></li>
<li>Hystrix几篇文章《青芒》：<a href="https://link.juejin.im?target=https%3A%2F%2Fsegmentfault.com%2Fu%2Fyedge%2Farticles">segmentfault.com/u/yedge/art…</a></li>
</ul>
<h1 id="八、引出Feign"><a href="#八、引出Feign" class="headerlink" title="八、引出Feign"></a>八、引出Feign</h1><p>上面已经介绍了Ribbon和Hystrix了，可以发现的是：他俩作为基础工具类框架<strong>广泛地应用</strong>在各个微服务的实现中。我们会发现对这两个框架的<strong>使用几乎是同时出现</strong>的。<br>为了<strong>简化</strong>我们的开发，Spring Cloud Feign出现了！它基于 Netflix Feign 实现，<strong>整合</strong>了 Spring Cloud Ribbon 与 Spring Cloud Hystrix, 除了整合这两者的强大功能之外，它还提 供了<strong>声明式的服务调用</strong>(不再通过RestTemplate)。</p>
<blockquote>
<p>Feign是一种声明式、模板化的HTTP客户端。在Spring Cloud中使用Feign, 我们可以做到使用HTTP请求远程服务时能与调用本地方法一样的编码体验，开发者完全感知不到这是远程方法，更感知不到这是个HTTP请求。</p>
</blockquote>
<p>下面就简单看看Feign是怎么优雅地实现远程调用的：<br>服务绑定：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// value ---&gt;指定调用哪个服务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// fallbackFactory---&gt;熔断器的降级提示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@FeignClient</span>(value = <span class="string">"MICROSERVICECLOUD-DEPT"</span>, fallbackFactory = DeptClientServiceFallbackFactory.class)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public interface DeptClientService &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 采用Feign我们可以使用SpringMVC的注解来对服务进行绑定！</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@RequestMapping</span>(value = <span class="string">"/dept/get/&#123;id&#125;"</span>, method = RequestMethod.GET)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Dept get(<span class="variable">@PathVariable</span>(<span class="string">"id"</span>) long id);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@RequestMapping</span>(value = <span class="string">"/dept/list"</span>, method = RequestMethod.GET)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public List&lt;Dept&gt; list();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@RequestMapping</span>(value = <span class="string">"/dept/add"</span>, method = RequestMethod.POST)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public boolean add(Dept dept);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Feign中使用熔断器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Feign中使用断路器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 这里主要是处理异常出错的情况(降级/熔断时服务不可用，fallback就会找到这里来)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 不要忘记添加，不要忘记添加</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptClientServiceFallbackFactory</span> <span class="keyword">implements</span> <span class="title">FallbackFactory</span>&lt;<span class="title">DeptClientService</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> DeptClientService <span class="title">create</span><span class="params">(Throwable throwable)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DeptClientService() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">public</span> Dept <span class="title">get</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Dept().setDeptno(id).setDname(<span class="string">"该ID："</span> + id + <span class="string">"没有没有对应的信息,Consumer客户端提供的降级信息,此刻服务Provider已经关闭"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        .setDb_source(<span class="string">"no this database in MySQL"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">public</span> List&lt;Dept&gt; <span class="title">list</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Dept dept)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>调用：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151052-9a6e4.png" alt="img"></p>
<h1 id="九、引出Zuul"><a href="#九、引出Zuul" class="headerlink" title="九、引出Zuul"></a>九、引出Zuul</h1><p>基于上面的学习，我们现在的架构很可能会设计成这样：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151052-a2fbe.png" alt="img"></p>
<p>这样的架构会有两个比较麻烦的问题：</p>
<ol>
<li><strong>路由规则与服务实例的维护间题</strong>：外层的负载均衡(nginx)需要<strong>维护</strong>所有的服务实例清单(图上的OpenService)</li>
<li><strong>签名校验、 登录校验冗余问题</strong>：为了保证对外服务的安全性， 我们在服务端实现的微服务接口，往往都会有一定的<strong>权限校验机制</strong>，但我们的服务是独立的，我们<strong>不得不在这些应用中都实现这样一套校验逻辑</strong>，这就会造成校验逻辑的冗余。</li>
</ol>
<p>还是画个图来理解一下吧：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151053-1d37f.png" alt="img"></p>
<p>每个服务都有自己的IP地址，Nginx想要正确请求转发到服务上，就必须<strong>维护着每个服务实例的地址</strong>！</p>
<ul>
<li>更是灾难的是：这些服务实例的IP地址还有可能会变，服务之间的划分也很可能会变。</li>
</ul>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//123.123.123.123</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//123.123.123.124</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//123.123.123.125</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//123.123.123.126</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//123.123.123.127</span></span></pre></td></tr></table></figure>

<p>购物车和订单模块都需要用户登录了才可以正常访问，基于现在的架构，只能在<strong>购物车和订单模块都编写校验逻辑</strong>，这无疑是冗余的代码。<br>为了解决上面这些常见的架构问题，<strong>API网关</strong>的概念应运而生。在SpringCloud中了提供了基于Netfl ix Zuul实现的API网关组件<strong>Spring Cloud Zuul</strong>。<br>Spring Cloud Zuul是这样解决上述两个问题的：</p>
<ul>
<li>SpringCloud Zuul通过与SpringCloud Eureka进行整合，将自身注册为Eureka服务治理下的应用，同时从Eureka中获得了所有其他微服务的实例信息。<strong>外层调用都必须通过API网关</strong>，使得<strong>将维护服务实例的工作交给了服务治理框架自动完成</strong>。</li>
<li>在API网关服务上进行统一调用来<strong>对微服务接口做前置过滤</strong>，以实现对微服务接口的<strong>拦截和校验</strong>。</li>
</ul>
<p>Zuul天生就拥有线程隔离和断路器的自我保护功能，以及对服务调用的客户端负载均衡功能。也就是说：<strong>Zuul也是支持Hystrix和Ribbon</strong>。<br>关于Zuul还有很多知识点(由于篇幅问题，这里我就不细说了)：</p>
<ul>
<li>路由匹配(动态路由)</li>
<li>过滤器实现(动态过滤器)</li>
<li>默认会过滤掉Cookie与敏感的HTTP头信息(额外配置)</li>
</ul>
<h2 id="9-1可能对Zuul的疑问"><a href="#9-1可能对Zuul的疑问" class="headerlink" title="9.1可能对Zuul的疑问"></a>9.1可能对Zuul的疑问</h2><p>Zuul支持Ribbon和Hystrix，也能够实现客户端的负载均衡。我们的Feign不也是实现客户端的负载均衡和Hystrix的吗？既然Zuul已经能够实现了，那我们的Feign还有必要吗？</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151054-d6685.png" alt="img"></p>
<p>或者可以这样理解：</p>
<ul>
<li>zuul是对外暴露的唯一接口相当于路由的是controller的请求，而Ribbonhe和Fegin路由了service的请求</li>
<li>zuul做最外层请求的负载均衡 ，而Ribbon和Fegin做的是系统内部各个微服务的service的调用的负载均衡</li>
</ul>
<p>有了Zuul，还需要Nginx吗？他俩可以一起使用吗？</p>
<ul>
<li>我的理解：Zuul和Nginx是可以一起使用的(毕竟我们的Zuul也是可以搭成集群来实现高可用的)，要不要一起使用得看架构的复杂度了(业务)<del>~</del></li>
</ul>
<p>参考资料：</p>
<ul>
<li>微服务与API网关（上）: 为什么需要API网关？：<a href="https://link.juejin.im?target=http%3A%2F%2Fblog.didispace.com%2Fhzf-ms-apigateway-1%2F">blog.didispace.com/hzf-ms-apig…</a></li>
<li>谈谈 API 网关：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fb52a2773e75f">www.jianshu.com/p/b52a2773e…</a></li>
<li>谈谈微服务中的 API 网关（API Gateway）：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fsavorboard%2Fp%2Fapi-gateway.html">www.cnblogs.com/savorboard/…</a></li>
<li>API网关性能比较：NGINX vs. ZUUL vs. Spring Cloud Gateway ：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.360doc.com%2Fcontent%2F18%2F0208%2F05%2F46368139_728502763.shtml">www.360doc.com/content/18/…</a></li>
<li>谈API网关的背景、架构以及落地方案：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.infoq.com%2Fcn%2Fnews%2F2016%2F07%2FAPI-background-architecture-floo">www.infoq.com/cn/news/201…</a></li>
<li>zuul和nginx：<a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F37385481">zhuanlan.zhihu.com/p/37385481</a></li>
</ul>
<h1 id="十、引出SpringCloud-Config"><a href="#十、引出SpringCloud-Config" class="headerlink" title="十、引出SpringCloud Config"></a>十、引出SpringCloud Config</h1><p>随着业务的扩展，我们的服务会越来越多，越来越多。每个服务都有自己的配置文件。<br>既然是配置文件，给我们配置的东西，那<strong>难免会有些改动</strong>的。<br>比如我们的Demo中，每个服务都写上<strong>相同</strong>的配置文件。万一我们有一天，配置文件中的密码需要更换了，那就得<strong>三个都要重新更改</strong>。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151055-7a0e8.png" alt="img"></p>
<blockquote>
<p>在分布式系统中，某一个基础服务信息变更，都<strong>很可能</strong>会引起一系列的更新和重启</p>
</blockquote>
<p>Spring Cloud Config项目是一个解决分布式系统的配置管理方案。它包含了Client和Server两个部分，<strong>server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，client通过接口获取数据、并依据此数据初始化自己的应用</strong>。</p>
<ul>
<li>简单来说，使用Spring Cloud Config就是将配置文件放到<strong>统一的位置管理</strong>(比如GitHub)，客户端通过接口去获取这些配置文件。</li>
<li>在GitHub上修改了某个配置文件，应用加载的就是修改后的配置文件。</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829151056-71b18.png" alt="img"></p>
<p>SpringCloud Config其他的知识：</p>
<ul>
<li>在SpringCloud Config的服务端， 对于配置仓库的默认<strong>实现采用了Git</strong>，我们也可以配置SVN。</li>
<li>配置文件内的信息<strong>加密和解密</strong></li>
<li>修改了配置文件，希望不用重启来<strong>动态刷新配置</strong>，配合Spring Cloud Bus 使用~</li>
</ul>
<p>使用SpringCloud Config可能的疑问：application.yml和 bootstrap.yml区别</p>
<ul>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2FBlogNetSpace%2Fp%2F8469033.html">www.cnblogs.com/BlogNetSpac…</a></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要写了SpringCloud的基础知识，希望大家看完能有所帮助~<br>SpringCloud的资料也很多，我整理一些我认为比较好，想要深入的同学不妨看看下边的资源<del>~</del><br>SpringCloud系列文章参考资料：</p>
<ul>
<li>史上最简单的 SpringCloud 教程 | 终章<a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fforezp%2Farticle%2Fdetails%2F70148833">blog.csdn.net/forezp/arti…</a></li>
<li>Spring Cloud基础教程《程序员DD》<a href="https://link.juejin.im?target=http%3A%2F%2Fblog.didispace.com%2FSpring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%2F">blog.didispace.com/Spring-Clou…</a></li>
<li>Spring Cloud 系列文章《纯洁的微笑》：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.ityouknow.com%2Fspring-cloud.html">www.ityouknow.com/spring-clou…</a></li>
<li>SpringCloud系列文章：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fwoshimrf%2Ftag%2FSpringCloud%2F">www.cnblogs.com/woshimrf/ta…</a></li>
<li>SpringCloud系列文章《狂小白》：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fhuangjuncong%2Ftag%2FSpringCloud%2F">www.cnblogs.com/huangjuncon…</a></li>
<li>SpringCloud官方文档：<a href="https://link.juejin.im?target=http%3A%2F%2Fprojects.spring.io%2Fspring-cloud%2F">projects.spring.io/spring-clou…</a></li>
<li>Spring Cloud 中文文档：<a href="https://link.juejin.im?target=https%3A%2F%2Fspringcloud.cc%2Fspring-cloud-dalston.html%23_appendix_compendium_of_configuration_properties">springcloud.cc/spring-clou…</a></li>
</ul>
<p>参考书籍：</p>
<ul>
<li>《SpringCloud 微服务实战》</li>
</ul>
<p>SpringCloud GitHub Demo(看完文章的同学可以自己练手玩玩，写好了ReadMe了)：</p>
<ul>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FZhongFuCheng3y%2Fmsc-Demo">github.com/ZhongFuChen…</a></li>
</ul>
<blockquote>
<p>作者：Java3y</p>
<p>来源：<a href="https://juejin.im/post/5b83466b6fb9a019b421cecc" target="_blank" rel="noopener">https://juejin.im/post/5b83466b6fb9a019b421cecc</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring Cloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringMVC 源码解析</title>
    <url>/2019/12/26/SpringMVC-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>年初面试时接触到一道面试题，在聊到SpringMVC时提到了SpringMVC的开发者为何要设计父子容器呢，又或者说是父子容器的设计有什么更实际的作用呢？ 首先要理解对于一个web应用，当期部署在web容器上时，容器会为其提供一个全局上下文环境ServletContext，这个上下文环境将为后续的Spring提供宿主环境。</p>
<a id="more"></a>

<h2 id="SpringMVC工作流程"><a href="#SpringMVC工作流程" class="headerlink" title="SpringMVC工作流程"></a>SpringMVC工作流程</h2><p><img src="http://image.winrains.cn/2019/08/20190829153349-d1b15.png" alt="20180708224853769.png"></p>
<h2 id="DispatcherServlet上下文继承关系"><a href="#DispatcherServlet上下文继承关系" class="headerlink" title="DispatcherServlet上下文继承关系"></a>DispatcherServlet上下文继承关系</h2><p><img src="http://image.winrains.cn/2019/08/20190829153350-5d564.png" alt="mvc-context-hierarchy.png"></p>
<h2 id="SpringMVC设计的父子容器"><a href="#SpringMVC设计的父子容器" class="headerlink" title="SpringMVC设计的父子容器"></a>SpringMVC设计的父子容器</h2><h3 id="父子容器配置文件"><a href="#父子容器配置文件" class="headerlink" title="父子容器配置文件"></a>父子容器配置文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在web.xml中配置，两个重要的xml:applicationContext.xml和SpringMVC-conf.xml--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:applictionContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher-servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:springMVC-conf.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher-servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span></pre></td></tr></table></figure>

<h3 id="父子容器的设计目的"><a href="#父子容器的设计目的" class="headerlink" title="父子容器的设计目的"></a>父子容器的设计目的</h3><p>根据SpringMVC的官方解释，父（根）容器主要包括一些基础脚手架的bean，比如Pool、DataSource、Dao、Service。目的是在不同的Servlet实例之间共享。这些不同的bean可以在子容器中重写。 而子容器主要包括一些Controller、View等一些web相关的bean。</p>
<h2 id="DispatcherServlet源码分析"><a href="#DispatcherServlet源码分析" class="headerlink" title="DispatcherServlet源码分析"></a>DispatcherServlet源码分析</h2><p>既然SpringMVC中同时包含Spring容器和SpringMVC容器，那么这两个容器都是在什么时候初始化呢？</p>
<h3 id="根容器初始化"><a href="#根容器初始化" class="headerlink" title="根容器初始化"></a>根容器初始化</h3><p>首先，根容器是通过ServletContext监听器进行创建，默认的监听器为ContextLoaderListener，当web应用启动时，会调用监听器的<strong>contextInitialized</strong>方法。 那么根容器的初始化就从<strong>ContextLoaderListener</strong>类说起吧，，Spring官方对该类的描述是启动监听器去启动和关闭Spring的root WebApplicationContext（翻译的实在有点蹩脚）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">(WebApplicationContext context)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">super</span>(context);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// ===初始化root WebApplicationContext===</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        initWebApplicationContext(event.getServletContext());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        closeWebApplicationContext(event.getServletContext());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ContextCleanupListener.cleanupAttributes(event.getServletContext());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// ContextLoader.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 初始化Spring容器时如果发现servlet</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 容器中已存在根Spring容根器则抛出异常，证明rootWebApplicationContext只能有一个。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="string">"Cannot initialize context because there is already a root application context present - "</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                        + <span class="string">"check whether you have multiple ContextLoader* definitions in your web.xml!"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 创建webApplicationContext实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.context == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.context = createWebApplicationContext(servletContext);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class="keyword">this</span>.context;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    ApplicationContext parent = loadParentContext(servletContext);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    cwac.setParent(parent);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// 配置WebApplicationContext</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                configureAndRefreshWebApplicationContext(cwac, servletContext);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 把生成的webApplicationContext设置成root</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * WebApplicationContext。保存在ServletContext上下文中。 下一步初始化MVC</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * ApplicationContext时需要从ServletContext取出根上下文作为其父上下文。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         **/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.context);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (ccl == ContextLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()) </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            currentContext = <span class="keyword">this</span>.context;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ccl != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            currentContextPerThread.put(ccl, <span class="keyword">this</span>.context);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.context;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> ex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>以上代码主要完成两个功能：创建实例WebApplicationContext实例、把所创建的WebApplicationContext设置为根上下文，也就是设置成为ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE的值。</p>
<h3 id="MVC容器初始化"><a href="#MVC容器初始化" class="headerlink" title="MVC容器初始化"></a>MVC容器初始化</h3><p>大家知道Servlet生命周期都是从init方法开始，desctory方法结束，由jvm负责垃圾回收。而DispatcherServlet也是一个普通的Servlet，先看一下DispatcherServlet的继承关系图，对整个继承关系有个了解。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829153351-f1d00.jpeg" alt="1946613-f6892f5c658de75c.jpg"></p>
<p>既然说起Servlet，那就从Servlet的初始化（init）方法入手</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HttpServletBean.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            bw.registerCustomEditor(Resource<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">ResourceEditor</span>(<span class="title">resourceLoader</span>, <span class="title">getEnvironment</span>()))</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            initBeanWrapper(bw);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> ex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 交给子类重写</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    initServletBean();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//FrameworkServlet.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        initFrameworkServlet();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">catch</span> (ServletException | RuntimeException ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> ex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//FrameworkServlet.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化MVC容器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 从ServletContext取出根上下文</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    WebApplicationContext wac = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wac = <span class="keyword">this</span>.webApplicationContext;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    cwac.setParent(rootContext);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                configureAndRefreshWebApplicationContext(cwac);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wac = findWebApplicationContext();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果还没有webApplicatioinContext，创建webApplicationContext</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wac = createWebApplicationContext(rootContext);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 子类自定义对servlet子上下文后续操作，在DispatcherServlet中实现</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.onRefreshMonitor) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 执行子类扩展方法onRefresh，在DispatcherServlet内初始化所有web相关组件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            onRefresh(wac);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 发布servlet子上下文到ServletContext</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String attrName = getServletContextAttributeName();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 将servlet子上下文以org.springframework.web.servlet.FrameworkServlet.CONTEXT.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// + servletName的属性名称注册到ServletContext中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        getServletContext().setAttribute(attrName, wac);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> wac;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(@Nullable WebApplicationContext parent)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> createWebApplicationContext((ApplicationContext) parent);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(@Nullable ApplicationContext parent)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 获取WebApplicationContext实现类，此处其实就是XmlWebApplicationContext</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Class&lt;?&gt; contextClass = getContextClass();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!ConfigurableWebApplicationContext<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">contextClass</span>)) </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Fatal initialization error in servlet with name '"</span> + getServletName()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                + <span class="string">"': custom WebApplicationContext class ["</span> + contextClass.getName()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                + <span class="string">"] is not of type ConfigurableWebApplicationContext"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 生成XmlWebApplicationContext实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ConfigurableWebApplicationContext wac = (ConfigurableWebApplicationContext) BeanUtils</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .instantiateClass(contextClass);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    wac.setEnvironment(getEnvironment());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 设置根容器为父容器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    wac.setParent(parent);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    String configLocation = getContextConfigLocation();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (configLocation != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 设置配置文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        wac.setConfigLocation(configLocation);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 配置webApplicationContext</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    configureAndRefreshWebApplicationContext(wac);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> wac;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureAndRefreshWebApplicationContext</span><span class="params">(ConfigurableWebApplicationContext wac)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.contextId != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            wac.setId(<span class="keyword">this</span>.contextId);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    + ObjectUtils.getDisplayString(getServletContext().getContextPath()) + <span class="string">'/'</span> + getServletName());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    wac.setServletContext(getServletContext());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    wac.setServletConfig(getServletConfig());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    wac.setNamespace(getNamespace());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    wac.addApplicationListener(<span class="keyword">new</span> SourceFilteringListener(wac, <span class="keyword">new</span> ContextRefreshListener()));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ConfigurableEnvironment env = wac.getEnvironment();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (env <span class="keyword">instanceof</span> ConfigurableWebEnvironment) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    postProcessWebApplicationContext(wac);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    applyInitializers(wac);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 开始处理bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    wac.refresh();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面的关键代码都在FrameworkServlet类中，有几个关键点：取除根上下文，创建子上下文并设置父上下文，完成刷新，把子上下文发布到ServletContext中。 到这里可以说子容器（子上下文）已经创建完成。 并把其他初始化web组件的相关工作交给onRefresh方法完成，由DispatcherServlet来重写onRefresh方法，这就又回到了我们熟悉的initStrategies方法。</p>
<h3 id="web组件初始化"><a href="#web组件初始化" class="headerlink" title="web组件初始化"></a>web组件初始化</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">protected void on<span class="constructor">Refresh(ApplicationContext <span class="params">context</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">Strategies(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">protected void init<span class="constructor">Strategies(ApplicationContext <span class="params">context</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//文件上传解析器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">MultipartResolver(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//本地化解析器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">LocaleResolver(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//主题解析器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">ThemeResolver(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//处理器映射器(url和Controller方法的映射)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">HandlerMappings(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//处理器适配器(实际执行Controller方法)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">HandlerAdapters(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//处理器异常解析器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">HandlerExceptionResolvers(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//RequestToViewName解析器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">RequestToViewNameTranslator(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//视图解析器(视图的匹配和渲染)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">ViewResolvers(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//FlashMap管理者</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">FlashMapManager(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里我们主要关注一下三个重要组件：HandlerMapping、HandlerAdapter、ViewResolver。分析这3个组件之前，我们先看一下我们的springMVC-conf.xml配置文件，mvc的配置文件中，我们配置了两行代码：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">&lt;<span class="symbol">context:</span>component-scan base-package=<span class="string">"com.zhangfei"</span>/&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;<span class="symbol">mvc:</span><span class="keyword">annotation</span>-<span class="title">driven</span>&gt;</span></pre></td></tr></table></figure>

<p>第二行代码主要是添加了默认的HandleMapping,ViewResolver,HandleAdapter。我们看看annotation-driven的源码定义，根据spring自定义schema定义，我们找到如下代码，如图所示：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829153351-eab5e.jpeg" alt="QQ截图20190822131726.jpg"></p>
<p>该文件就一行代码：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">http:<span class="type"></span>//www.springframework.org/schema/mvc=org.springframework.web.servlet.config.MvcNamespaceHandler</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//MVC所有的标签解析器都定义在此</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcNamespaceHandler</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">NamespaceHandlerSupport</span></span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> void init() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"annotation-driven"</span>, <span class="keyword">new</span> <span class="type">AnnotationDrivenBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"default-servlet-handler"</span>, <span class="keyword">new</span> <span class="type">DefaultServletHandlerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"interceptors"</span>, <span class="keyword">new</span> <span class="type">InterceptorsBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"resources"</span>, <span class="keyword">new</span> <span class="type">ResourcesBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"view-controller"</span>, <span class="keyword">new</span> <span class="type">ViewControllerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"redirect-view-controller"</span>, <span class="keyword">new</span> <span class="type">ViewControllerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"status-controller"</span>, <span class="keyword">new</span> <span class="type">ViewControllerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"view-resolvers"</span>, <span class="keyword">new</span> <span class="type">ViewResolversBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"tiles-configurer"</span>, <span class="keyword">new</span> <span class="type">TilesConfigurerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"freemarker-configurer"</span>, <span class="keyword">new</span> <span class="type">FreeMarkerConfigurerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"groovy-configurer"</span>, <span class="keyword">new</span> <span class="type">GroovyMarkupConfigurerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"script-template-configurer"</span>, <span class="keyword">new</span> <span class="type">ScriptTemplateConfigurerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"cors"</span>, <span class="keyword">new</span> <span class="type">CorsBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>那么通过分析AnnotationDrivenBeanDefinitionParser类，主要完成以下三大组件的装配工作：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829153351-7caf6.jpeg" alt="QQ截图20190822132044.jpg"></p>
<h4 id="初始化处理器映射器"><a href="#初始化处理器映射器" class="headerlink" title="初始化处理器映射器"></a>初始化处理器映射器</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void initHandlerMappings(ApplicationContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">this</span>.handlerMappings = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 这里detectAllHandlerMappings默认值为true，可以通过配置文件设置为false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerMappings) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 从上下文(包含父上下文)中查找所有HandlerMapping实现类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Map&lt;String, HandlerMapping&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                HandlerMapping<span class="class">.<span class="keyword">class</span>, <span class="type">true</span>, <span class="type">false);</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.handlerMappings = new ArrayList&lt;&gt;(matchingBeans.values());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerMappings);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 这里只取固定的bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping<span class="class">.<span class="keyword">class</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.handlerMappings = Collections.singletonList(hm);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/***</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 确保至少有一个HandlerMapping，如果没能找到，注册一个默认的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 默认规则在DispatcherServlet.properties中，这里也就是取BeanNameUrlHandlerMapping、</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * RequestMappingHandlerMapping</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     ***/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="literal">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping<span class="class">.<span class="keyword">class</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="初始化处理器适配器"><a href="#初始化处理器适配器" class="headerlink" title="初始化处理器适配器"></a>初始化处理器适配器</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void initHandlerAdapters(ApplicationContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">this</span>.handlerAdapters = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerAdapters) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 从上下文（包括父上下文）中查找所有HandlerAdapter实现类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Map&lt;String, HandlerAdapter&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                HandlerAdapter<span class="class">.<span class="keyword">class</span>, <span class="type">true</span>, <span class="type">false);</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.handlerAdapters = new ArrayList&lt;&gt;(matchingBeans.values());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerAdapters);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 这里取bean名字为handlerAdapter，类型为HandlerAdapter的处理器适配器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            HandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter<span class="class">.<span class="keyword">class</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.handlerAdapters = Collections.singletonList(ha);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 如果没找到，则从默认规则里取出指定的三个实现类：HttpRequestHandlerAdapter、</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * SimpleControllerHandlerAdapter、RequestMappingHandlerAdapter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     **/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerAdapters == <span class="literal">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.handlerAdapters = getDefaultStrategies(context, HandlerAdapter<span class="class">.<span class="keyword">class</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="初始化试图解析器"><a href="#初始化试图解析器" class="headerlink" title="初始化试图解析器"></a>初始化试图解析器</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void initViewResolvers(ApplicationContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">this</span>.viewResolvers = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.detectAllViewResolvers) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 从上下文（包括父上下文）中查找所有ViewResolver实现类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Map&lt;String, ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ViewResolver<span class="class">.<span class="keyword">class</span>, <span class="type">true</span>, <span class="type">false);</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.viewResolvers = new ArrayList&lt;&gt;(matchingBeans.values());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.viewResolvers);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ViewResolver vr = context.getBean(VIEW_RESOLVER_BEAN_NAME, ViewResolver<span class="class">.<span class="keyword">class</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.viewResolvers = Collections.singletonList(vr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 如果没找到，则从默认规则里取出指定的实现类：InternalResourceViewResolver</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     **/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.viewResolvers == <span class="literal">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.viewResolvers = getDefaultStrategies(context, ViewResolver<span class="class">.<span class="keyword">class</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>三大组件的初始化最后判断为NULL时都会调用getDefaultStrategies方法，也就是从DispatcherServlet.properties中取出指定默认值。</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; List&lt;T&gt; getDefaultStrategies(ApplicationContext context, Class&lt;T&gt; strategyInterface) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">String</span> <span class="built_in">key</span> = strategyInterface.getName();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">String</span> value = defaultStrategies.getProperty(<span class="built_in">key</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">String</span>[] classNames = StringUtils.commaDelimitedListToStringArray(value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;T&gt; strategies = <span class="keyword">new</span> ArrayList&lt;&gt;(classNames.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">String</span> className : classNames) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Class&lt;?&gt; clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">Object</span> strategy = createDefaultStrategy(context, clazz);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                strategies.<span class="built_in">add</span>((T) strategy);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">"Could not find DispatcherServlet's default strategy class ["</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                        + className + <span class="string">"] for interface ["</span> + <span class="built_in">key</span> + <span class="string">"]"</span>, ex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">catch</span> (LinkageError err) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="string">"Unresolvable class definition for DispatcherServlet's default strategy class ["</span> + className</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                + <span class="string">"] for interface ["</span> + <span class="built_in">key</span> + <span class="string">"]"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        err);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> strategies;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="DispatcherServlet请求处理过程"><a href="#DispatcherServlet请求处理过程" class="headerlink" title="DispatcherServlet请求处理过程"></a>DispatcherServlet请求处理过程</h2><p>提到请求处理过程，我们再来回顾一下Servlet生命周期，处理请求都放在service方法中处理，那么也从DispatcherServlet的service方法入手。DispatcherServlet继承FrameworkServlet，在FrameworkServlet中重写了service、doGet、doPost、doPut、doDelete方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FrameworkServlet.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (httpMethod == HttpMethod.PATCH || httpMethod == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        processRequest(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">super</span>.service(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    processRequest(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    processRequest(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPut</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    processRequest(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    processRequest(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Throwable failureCause = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LocaleContext localeContext = buildLocaleContext(request);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    asyncManager.registerCallableInterceptor(FrameworkServlet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">new</span> <span class="title">RequestBindingInterceptor</span>())</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 把新构造的LocaleContext对象和ServletRequestAttributes对象和当前请求线程绑定（后面要解除绑定）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    initContextHolders(request, localeContext, requestAttributes);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 抽象方法，交给DispatcherServlet方法实现</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        doService(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (ServletException | IOException ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        failureCause = ex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> ex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        failureCause = ex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NestedServletException(<span class="string">"Request processing failed"</span>, ex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 重置LocaleContext和RequestAttributes对象，也就是解除LocaleContext对象和ServletRequestAttributes对象和当前请求线程的绑定</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        resetContextHolders(request, previousLocaleContext, previousAttributes);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (requestAttributes != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            requestAttributes.requestCompleted();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 发布ServletRequestHandledEvent事件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        publishRequestHandledEvent(request, response, startTime, failureCause);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// DispatcherServlet.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        attributesSnapshot = <span class="keyword">new</span> HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            String attrName = (String) attrNames.nextElement();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                attributesSnapshot.put(attrName, request.getAttribute(attrName));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 在当前request对象中填充4个属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.flashMapManager != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 主要处理分发请求</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        doDispatch(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (attributesSnapshot != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                restoreAttributesAfterInclude(request, attributesSnapshot);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    HttpServletRequest processedRequest = request;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            processedRequest = checkMultipart(request);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            multipartRequestParsed = (processedRequest != request);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 调用handlerMapping获取handlerChain</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            mappedHandler = getHandler(processedRequest);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                noHandlerFound(processedRequest, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 获取支持该handler解析的HandlerAdapter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            String method = request.getMethod();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 使用HandlerAdapter完成handler处理</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 视图处理(页面渲染)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            applyDefaultViewName(processedRequest, mv);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            dispatchException = ex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable err) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Throwable err) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                cleanupMultipart(processedRequest);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>DispatcherServlet的doDispatch方法概括起来大致就是以下几点：首先根据当前请求路径找到对应的HandlerMethod，一个HandlerMethod和若干个拦截器构造一个<strong>HandlerExecutionChain.通过HandlerExecutionChain</strong>得到<strong>HandlerAdapter</strong>对象<strong>，</strong>通过执行<strong>HandlerAdapter</strong>的handle方法得到<strong>ModelAndView</strong>对象，调用ModelAndView解析视图，渲染视图，Response结束。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5cb89dae6fb9a0686b47306d" target="_blank" rel="noopener">juejin.im/post/5cb89d…</a> <a href="https://juejin.im/post/5cbc10b46fb9a0689f4c2c22" target="_blank" rel="noopener">juejin.im/post/5cbc10…</a> <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Ffangjian0423%2Fp%2FspringMVC-dispatcherServlet.html">www.cnblogs.com/fangjian042…</a></p>
<blockquote>
<p>作者：garfieldzf8</p>
<p>来源：<a href="https://juejin.im/post/5d5e3e70e51d453b5d4d8d75" target="_blank" rel="noopener">https://juejin.im/post/5d5e3e70e51d453b5d4d8d75</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring MVC</category>
      </categories>
  </entry>
  <entry>
    <title>Spring AOP使用讲解</title>
    <url>/2019/12/26/Spring%20AOP%E4%BD%BF%E7%94%A8%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="1-什么是AOP"><a href="#1-什么是AOP" class="headerlink" title="1. 什么是AOP?"></a>1. 什么是AOP?</h2><p>AOP是Aspect Oriented Programming的缩写，意思是：面向切面编程，它是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。<br>可以认为AOP是对OOP(Object Oriented Programming 面向对象编程)的补充，主要使用在日志记录，性能统计，安全控制等场景，使用AOP可以使得业务逻辑各部分之间的耦合度降低，只专注于各自的业务逻辑实现，从而提高程序的可读性及维护性。<br>比如，我们需要记录项目中所有对外接口的入参和出参，以便出现问题时定位原因，在每一个对外接口的代码中添加代码记录入参和出参当然也可以达到目的，但是这种硬编码的方式非常不友好，也不够灵活，而且记录日志本身和接口要实现的核心功能没有任何关系。</p>
<a id="more"></a>

<p>此时，我们可以将记录日志的功能定义到1个切面中，然后通过声明的方式定义要在何时何地使用这个切面，而不用修改任何1个外部接口。<br>在讲解具体的实现方式之前，我们先了解几个AOP中的术语。</p>
<h3 id="1-1-通知-Advice"><a href="#1-1-通知-Advice" class="headerlink" title="1.1 通知(Advice)"></a>1.1 通知(Advice)</h3><p>在AOP术语中，切面要完成的工作被称为通知，通知定义了切面是什么以及何时使用。<br>Spring切面有5种类型的通知，分别是：</p>
<ul>
<li>前置通知(Before)：在目标方法被调用之前调用通知功能</li>
<li>后置通知(After)：在目标方法完成之后调用通知，此时不关心方法的输出结果是什么</li>
<li>返回通知(After-returning)：在目标方法成功执行之后调用通知</li>
<li>异常通知(After-throwing)：在目标方法抛出异常后调用通知</li>
<li>环绕通知(Around)：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为</li>
</ul>
<h3 id="1-2-连接点-Join-point"><a href="#1-2-连接点-Join-point" class="headerlink" title="1.2 连接点(Join point)"></a>1.2 连接点(Join point)</h3><p>连接点是在应用执行过程中能够插入切面的一个点，这个点可以是调用方法时、抛出异常时、修改某个字段时。</p>
<h3 id="1-3-切点-Pointcut"><a href="#1-3-切点-Pointcut" class="headerlink" title="1.3 切点(Pointcut)"></a>1.3 切点(Pointcut)</h3><p>切点是为了缩小切面所通知的连接点的范围，即切面在何处执行。我们通常使用明确的类和方法名称，或者利用正则表达式定义所匹配的类和方法名称来指定切点。</p>
<h3 id="1-4-切面-Aspect"><a href="#1-4-切面-Aspect" class="headerlink" title="1.4 切面(Aspect)"></a>1.4 切面(Aspect)</h3><p>切面是通知和切点的结合。通知和切点共同定义了切面的全部内容：它是什么，在何时和何处完成其功能。</p>
<h3 id="1-5-引入-Introduction"><a href="#1-5-引入-Introduction" class="headerlink" title="1.5 引入(Introduction)"></a>1.5 引入(Introduction)</h3><p>引入允许我们在不修改现有类的基础上，向现有类添加新方法或属性。</p>
<h3 id="1-6-织入-Weaving"><a href="#1-6-织入-Weaving" class="headerlink" title="1.6 织入(Weaving)"></a>1.6 织入(Weaving)</h3><p>织入是把切面应用到目标对象并创建新的代理对象的过程。<br>切面在指定的连接点被织入到目标对象中，在目标对象的生命周期里，有以下几个点可以进行织入：</p>
<ul>
<li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li>
<li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器(ClassLoader)，它可以在目标类被引入应用之前增强该目标类的字节码。</li>
<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。</li>
</ul>
<h2 id="2-Spring-对AOP的支持"><a href="#2-Spring-对AOP的支持" class="headerlink" title="2. Spring 对AOP的支持"></a>2. Spring 对AOP的支持</h2><h3 id="2-1-动态代理"><a href="#2-1-动态代理" class="headerlink" title="2.1 动态代理"></a>2.1 动态代理</h3><p><strong>Spring AOP构建在动态代理之上</strong>，也就是说，Spring运行时会为目标对象动态创建代理对象。<br>代理类封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。<br>当代理类拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829154615-53d0a.png" alt="img"></p>
<h3 id="2-2-织入切面时机"><a href="#2-2-织入切面时机" class="headerlink" title="2.2 织入切面时机"></a>2.2 织入切面时机</h3><p>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring 管理的bean中，也就是说，直到应用需要被代理的bean时，Spring才会创建代理对象。<br>因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入Spring AOP切面。</p>
<h3 id="2-3-连接点限制"><a href="#2-3-连接点限制" class="headerlink" title="2.3 连接点限制"></a>2.3 连接点限制</h3><p>Spring只支持方法级别的连接点，如果需要字段级别或者构造器级别的连接点，可以利用AspectJ来补充Spring AOP的功能。</p>
<h2 id="3-Spring-AOP使用"><a href="#3-Spring-AOP使用" class="headerlink" title="3. Spring AOP使用"></a>3. Spring AOP使用</h2><p>假设我们有个现场表演的接口Performance和它的实现类SleepNoMore：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package chapter04.concert;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 现场表演,如舞台剧,电影,音乐会</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> interface Performance &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="type">void</span> <span class="keyword">perform</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">package chapter04.concert;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 戏剧:《不眠之夜Sleep No More》</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Component</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> SleepNoMore implements Performance &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">public</span> <span class="type">void</span> <span class="keyword">perform</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("戏剧《不眠之夜Sleep No More》");</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>既然是演出，就需要观众，假设我们的需求是：在看演出之前，观众先入座并将手机调整至静音，在观看演出之后观众鼓掌，如果演出失败观众退票，我们当然可以把这些逻辑写在上面的perform()方法中，但不推荐这么做，因为这些逻辑理论上和演出的核心无关，就算观众不将手机调整至静音或者看完演出不鼓掌，都不影响演出的进行。<br>针对这个需求，我们可以使用AOP来实现。</p>
<h3 id="3-1-定义切面"><a href="#3-1-定义切面" class="headerlink" title="3.1 定义切面"></a>3.1 定义切面</h3><p>首先，在pom.xml文件中添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring aop支持--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--aspectj支持--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure>

<p>然后，定义一个观众的切面如下：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">package chapter04.concert;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.aspectj.lang.<span class="keyword">annotation</span>.<span class="title">Aspect</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">/**</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * 观众</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * 使用@Aspect注解定义为切面</span></pre></td></tr><tr><td class="code"><pre><span class="line"> *<span class="regexp">/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">@Aspect</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">public class Audience &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">&#125;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：<code>@Aspect</code>注解表明Audience类是一个切面。</p>
</blockquote>
<h3 id="3-2-定义前置通知"><a href="#3-2-定义前置通知" class="headerlink" title="3.2 定义前置通知"></a>3.2 定义前置通知</h3><p>在Audience切面中定义前置通知如下所示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演之前,观众就座</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="keyword">Before</span>("execution(* chapter04.concert.Performance.perform(..))")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> takeSeats() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("Taking seats");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演之前,将手机调至静音</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="keyword">Before</span>("execution(* chapter04.concert.Performance.perform(..))")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> silenceCellPhones() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("Silencing cell phones");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里的重点代码是<code>@Before(&quot;execution(* chapter04.concert.Performance.perform(..))&quot;)</code>，它定义了1个前置通知，其中<code>execution(* chapter04.concert.Performance.perform(..))</code>被称为AspectJ切点表达式，每一部分的讲解如下：</p>
<ul>
<li>@Before：该注解用来定义前置通知，通知方法会在目标方法调用之前执行</li>
<li>execution：在方法执行时触发</li>
<li>*：表明我们不关心方法返回值的类型，即可以是任意类型</li>
<li>chapter04.concert.Performance.perform：使用全限定类名和方法名指定要添加前置通知的方法</li>
<li>(..)：方法的参数列表使用(..)，表明我们不关心方法的入参是什么，即可以是任意类型</li>
</ul>
<h3 id="3-3-定义后置通知"><a href="#3-3-定义后置通知" class="headerlink" title="3.3 定义后置通知"></a>3.3 定义后置通知</h3><p>在Audience切面中定义后置通知如下所示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演结束,不管表演成功或者失败</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="keyword">After</span>("execution(* chapter04.concert.Performance.perform(..))")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> finish() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("perform finish");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：@After注解用来定义后置通知，通知方法会在目标方法返回或者抛出异常后调用</p>
</blockquote>
<h3 id="3-4-定义返回通知"><a href="#3-4-定义返回通知" class="headerlink" title="3.4 定义返回通知"></a>3.4 定义返回通知</h3><p>在Audience切面中定义返回通知如下所示：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演之后,鼓掌</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@AfterReturning(<span class="string">"execution(* chapter04.concert.Performance.perform(..))"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"CLAP CLAP CLAP!!!"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：@AfterReturning注解用来定义返回通知，通知方法会在目标方法返回后调用</p>
</blockquote>
<h3 id="3-5-定义异常通知"><a href="#3-5-定义异常通知" class="headerlink" title="3.5 定义异常通知"></a>3.5 定义异常通知</h3><p>在Audience切面中定义异常通知如下所示：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演失败之后,观众要求退款</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@AfterThrowing(<span class="string">"execution(* chapter04.concert.Performance.perform(..))"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demandRefund</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Demanding a refund"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：@AfterThrowing注解用来定义异常通知，通知方法会在目标方法抛出异常后调用</p>
</blockquote>
<h3 id="3-6-定义可复用的切点表达式"><a href="#3-6-定义可复用的切点表达式" class="headerlink" title="3.6 定义可复用的切点表达式"></a>3.6 定义可复用的切点表达式</h3><p>细心的你可能会发现，我们上面定义的5个切点中，切点表达式都是一样的，这显然是不好的，好在我们可以使用<code>@Pointcut</code>注解来定义可重复使用的切点表达式：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 可复用的切点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Pointcut("execution(* chapter04.concert.Performance.perform(..))")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> <span class="keyword">perform</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后之前定义的5个切点都可以引用这个切点表达式：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演之前,观众就座</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="keyword">Before</span>("perform()")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> takeSeats() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("Taking seats");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演之前,将手机调至静音</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="keyword">Before</span>("perform()")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> silenceCellPhones() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("Silencing cell phones");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演结束,不管表演成功或者失败</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="keyword">After</span>("perform()")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> finish() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("perform finish");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演之后,鼓掌</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@AfterReturning("perform()")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> applause() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("CLAP CLAP CLAP!!!");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演失败之后,观众要求退款</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@AfterThrowing("perform()")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> demandRefund() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("Demanding a refund");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="3-7-单元测试"><a href="#3-7-单元测试" class="headerlink" title="3.7 单元测试"></a>3.7 单元测试</h3><p>新建配置类ConcertConfig如下所示：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">package chapter04.concert;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">Bean</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">ComponentScan</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">Configuration</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">EnableAspectJAutoProxy</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableAspectJAutoProxy</span></pre></td></tr><tr><td class="code"><pre><span class="line">@ComponentScan</span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcertConfig</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Audience audience() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> new Audience();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：和以往不同的是，我们使用了<code>@EnableAspectJAutoProxy</code>注解，该注解用来启用自动代理功能。</p>
</blockquote>
<p>新建Main类，在其main()方法中添加如下测试代码：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package chapter04.concert;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Main &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        AnnotationConfigApplicationContext context = <span class="built_in">new</span> AnnotationConfigApplicationContext(ConcertConfig.<span class="keyword">class</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Performance performance = context.getBean(Performance.<span class="keyword">class</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        performance.<span class="keyword">perform</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        context.<span class="keyword">close</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>运行代码，输出结果如下所示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Silencing cell phones</span></pre></td></tr><tr><td class="code"><pre><span class="line">Taking seats</span></pre></td></tr><tr><td class="code"><pre><span class="line">戏剧《不眠之夜Sleep <span class="keyword">No</span> More》</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">perform</span> finish</span></pre></td></tr><tr><td class="code"><pre><span class="line">CLAP CLAP CLAP!!!</span></pre></td></tr></table></figure>

<p>稍微修改下SleepNoMore类的perform()方法，让它抛出一个异常：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@Override</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> <span class="keyword">perform</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="type">int</span> number = <span class="number">3</span> / <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("戏剧《不眠之夜Sleep No More》");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>再次运行代码，输出结果如下所示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Silencing cell phones</span></pre></td></tr><tr><td class="code"><pre><span class="line">Taking seats</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">perform</span> finish</span></pre></td></tr><tr><td class="code"><pre><span class="line">Demanding a refund</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Exception</span> <span class="keyword">in</span> thread "main" java.lang.ArithmeticException: / <span class="keyword">by</span> zero</span></pre></td></tr></table></figure>

<p><img src="http://image.winrains.cn/2019/08/20190829154615-ecdb8.png" alt="img"></p>
<p>由此也可以说明，不管目标方法是否执行成功，@After注解都会执行，但@AfterReturning注解只会在目标方法执行成功时执行。<br>值得注意的是，使用<code>@Aspect</code>注解的切面类必须是一个bean(不管以何种方式声明)，否则切面不会生效，因为AspectJ自动代理只会为使用<code>@Aspect</code>注解的bean创建代理类。<br>也就是说，如果我们将ConcertConfig配置类中的以下代码删除或者注释掉：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">Audience <span class="title">audience</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Audience();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>运行结果将变为：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">戏剧《不眠之夜<span class="keyword">Sleep</span> <span class="keyword">No</span> <span class="keyword">More</span>》</span></pre></td></tr></table></figure>

<h3 id="3-8-创建环绕通知"><a href="#3-8-创建环绕通知" class="headerlink" title="3.8 创建环绕通知"></a>3.8 创建环绕通知</h3><p>我们可以使用<code>@Around</code>注解创建环绕通知，该注解能够让你在调用目标方法前后，自定义自己的逻辑。<br>因此，我们之前定义的5个切点，现在可以定义在一个切点中，为不影响之前的切面，我们新建切面AroundAudience，如下所示：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">package chapter04.concert;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.aspectj.lang.<span class="keyword">annotation</span>.<span class="title">Around</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.aspectj.lang.<span class="keyword">annotation</span>.<span class="title">Aspect</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.aspectj.lang.<span class="keyword">annotation</span>.<span class="title">Pointcut</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Aspect</span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AroundAudience</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    /**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 可重用的切点</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *<span class="regexp">/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    @Pointcut("execution(* chapter04.concert.Performance.perform(..))")</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    public void perform() &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    @Around("perform()")</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    public void watchPerform(ProceedingJoinPoint joinPoint) &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">        try &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">            System.out.println("Taking seats");</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">            System.out.println("Silencing cell phones");</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">            joinPoint.proceed();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">            System.out.println("CLAP CLAP CLAP!!!");</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">        &#125; catch (Throwable throwable) &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">            System.out.println("Demanding a refund");</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">        &#125; finally &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">            System.out.println("perform finish");</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">        &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">&#125;</span></span></pre></td></tr></table></figure>

<p>这里要注意的是，该方法有个ProceedingJoinPoint类型的参数，在方法中可以通过调用它的proceed()方法来调用目标方法。<br>然后修改下ConcertConfig类的代码：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">package chapter04.concert;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">Bean</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">ComponentScan</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">Configuration</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">EnableAspectJAutoProxy</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableAspectJAutoProxy</span></pre></td></tr><tr><td class="code"><pre><span class="line">@ComponentScan</span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcertConfig</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    /*@Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Audience audience() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> new Audience();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;*<span class="regexp">/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    @Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    public AroundAudience aroundAudience() &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">        return new AroundAudience();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">&#125;</span></span></pre></td></tr></table></figure>

<p>运行结果如下所示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Taking seats</span></pre></td></tr><tr><td class="code"><pre><span class="line">Silencing cell phones</span></pre></td></tr><tr><td class="code"><pre><span class="line">戏剧《不眠之夜Sleep <span class="keyword">No</span> More》</span></pre></td></tr><tr><td class="code"><pre><span class="line">CLAP CLAP CLAP!!!</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">perform</span> finish</span></pre></td></tr></table></figure>

<h2 id="4-源码及参考"><a href="#4-源码及参考" class="headerlink" title="4. 源码及参考"></a>4. 源码及参考</h2><p>源码地址：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fzwwhnly%2Fspring-action.git">github.com/zwwhnly/spr…</a>，欢迎下载。<br>Craig Walls 《Spring实战（第4版）》<br><a href="https://link.juejin.im?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2FAOP%2F1332219">AOP（面向切面编程）_百度百科</a></p>
<blockquote>
<p>作者：申城异乡人</p>
<p>来源：<a href="https://juejin.im/post/5d648403f265da03f564f291" target="_blank" rel="noopener">https://juejin.im/post/5d648403f265da03f564f291</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引数据结构详解与索引优化</title>
    <url>/2019/12/26/MySQL%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>本篇文章主要学习了MySQL的索引的数据结构的认识，做一个大概的了解即可。</p>
<h2 id="一、索引"><a href="#一、索引" class="headerlink" title="一、索引"></a>一、索引</h2><p>在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行<strong>排序</strong>的一种存储<strong>数据结构</strong>，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑<a href="https://link.juejin.im?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E6%8C%87%E9%92%88%2F2878304">指针</a>清单。索引的作用相当于图书的目录，可以根据目录中的页码快速查找到所需的内容。<br>在MySQL中，存储引擎用类似的方法使用索引，先在索引中找到对应值，然后根据匹配的索引记录找到对应的行。<br>首先说明下MySQL的索引主要是基于Hash表或者B+树。</p>
<a id="more"></a>

<h2 id="二、索引数据结构"><a href="#二、索引数据结构" class="headerlink" title="二、索引数据结构"></a>二、索引数据结构</h2><p>了解索引就需要从索引常见的数据结构开始了解学习，这里有集中常见的的索引数据结构。</p>
<h3 id="二叉树（Binary-Trees）"><a href="#二叉树（Binary-Trees）" class="headerlink" title="二叉树（Binary Trees）"></a>二叉树（Binary Trees）</h3><p>二叉树是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常被称之为“左子树”和“右子树”</p>
<p><img src="http://image.winrains.cn/2019/08/20190829160230-5df25.jpeg" alt="http://image.winrains.cn/2019/08/20190829160230-5df25.jpeg"></p>
<p><strong>左子树&lt;父节点&lt;=右子树</strong><br>二叉树的第i层至多有有2^(i-1)个节点，<br>深度为K的二叉树至多总共有个2^k-1节点（定义根节点所在深度 k0=0），而总计拥有节点数符合的，称为“满二叉树”；<br>二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现<a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9">二叉搜索树</a>和<a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E4%BA%8C%E5%85%83%E5%A0%86%E7%A9%8D">二叉堆</a>，并应用于高效率的搜索和排序。<br>同时学习数据结构，这里还推荐<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cs.usfca.edu%2F~galles%2Fvisualization%2FAlgorithms.html">Data Structure Visualizations</a>进行学习，可以非常直观的看到数据结构允许的过程，一步一步的怎么走的都可以很清晰看得到。<br>找到其中的<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cs.usfca.edu%2F~galles%2Fvisualization%2FBST.html">Binary Search Trees</a>二叉树</p>
<p><img src="http://image.winrains.cn/2019/08/20190829160230-b696d.png" alt="http://image.winrains.cn/2019/08/20190829160230-b696d.png"></p>
<p>可以直观的看到二叉树的数据插入过程，如下：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829160232-1b122.gif" alt="http://image.winrains.cn/2019/08/20190829160232-1b122.gif"></p>
<p>可以看到二叉树不适合用作当作索引的，数据量庞大的话，二叉树的层数会很大，查找效率固然也很慢了。<br>推荐阅读：<a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E4%BA%8C%E5%8F%89%E6%A0%91">维基百科-二叉树</a></p>
<h3 id="红黑树（Red-Black-Trees）"><a href="#红黑树（Red-Black-Trees）" class="headerlink" title="红黑树（Red-Black Trees）"></a>红黑树（Red-Black Trees）</h3><p>是一种自平衡二叉查找树，典型用途是实现关联数组。<br>红黑树的结构复杂，但它的操作有着良好的最坏情况<a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90">运行时间</a>，并且在实践中高效：它可以在O(log n)时间内完成查找，插入和删除，这里的n是树中元素的数目。<br>红黑树遵行以下原则：</p>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有<a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E9%81%93%E8%B7%AF_(%E5%9B%BE%E8%AE%BA)">简单路径</a>都包含相同数目的黑色节点。</li>
</ol>
<p>下面是一个具体的红黑树的图例：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829160233-a9fa9.png" alt="http://image.winrains.cn/2019/08/20190829160233-a9fa9.png"></p>
<p>这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的<a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">二叉查找树</a>。<br>要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。<br>同样在<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cs.usfca.edu%2F~galles%2Fvisualization%2FAlgorithms.html">Data Structure Visualizations</a>中选择<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cs.usfca.edu%2F~galles%2Fvisualization%2FRedBlack.html">Red-Black Trees</a>红黑树进行插入操作可以直观的看到红黑树的插入过程</p>
<p><img src="http://image.winrains.cn/2019/08/20190829160233-7ea03.gif" alt="http://image.winrains.cn/2019/08/20190829160233-7ea03.gif"></p>
<p>同样红黑树也不适用于MySQL的索引，数据量庞大之后，数层也会变大。<br>推荐阅读：<br><a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E7%BA%A2%E9%BB%91%E6%A0%91">维基百科-红黑树</a><br><a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fjz1ajDUygZ7sXLQFHyfjWA">程序员小灰-红黑树</a></p>
<h3 id="其他结构的问题"><a href="#其他结构的问题" class="headerlink" title="其他结构的问题"></a>其他结构的问题</h3><p>由于无法装入内存，则必然依赖磁盘（或SSD）存储。而内存的读写速度是磁盘的成千上万倍（与具体实现有关），因此，核心问题是“如何减少磁盘读写次数”。<br>首先不考虑页表机制，假设每次读、写都直接穿透到磁盘，那么：</p>
<ul>
<li>线性结构：读/写平均O(n)次</li>
<li>二叉搜索树（<code>BST</code>）：读/写平均O(log2(n))次；如果树不平衡，则最差读/写O(n)次</li>
<li>自平衡二叉搜索树（<code>AVL</code>）：在BST的基础上加入了自平衡算法，读/写最大O(log2(n))次</li>
<li>红黑树（<code>RBT</code>）：另一种自平衡的查找树，读/写最大O(log2(n))次</li>
</ul>
<p><code>BST</code>、<code>AVL</code>、<code>RBT</code>很好的将读写次数从O(n)优化到O(log2(n))；其中，<code>AVL</code>和<code>RBT</code>都比<code>BST</code>多了自平衡的功能，将读写次数降到最大O(log2(n))。<br>假设使用自增主键，则主键本身是有序的，树结构的读写次数能够优化到树高，树高越低读写次数越少；自平衡保证了树结构的稳定。如果想进一步优化，可以引入<code>B树</code>和<code>B+树</code>。</p>
<h3 id="B树（B-Trees）"><a href="#B树（B-Trees）" class="headerlink" title="B树（B-Trees）"></a>B树（B-Trees）</h3><p>又称：多路平衡查找树。大多数存储引擎都支持B树索引。b树通常意味着所有的值都是按顺序存储的，并且每一个叶子节点到根的距离相同。B树索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取数据。下图就是一颗简单的B树。<br>在B树中，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）。当数据被插入或从一个节点中移除，它的子节点数量发生变化。为了维持在预先设定的数量范围内，内部节点可能会被合并或者分离。<br>如下图所示：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829160234-35182.png" alt="http://image.winrains.cn/2019/08/20190829160234-35182.png"></p>
<ul>
<li>叶节点具有相同的深度，叶节点的指针为空</li>
<li>所有索引元素不重复</li>
<li>节点中的数据索引从左到右递增排列</li>
<li>无论中间节点还是叶子节点都带有卫星数据data（索引元素所指向的数据记录）</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829160235-9e2bd.gif" alt="http://image.winrains.cn/2019/08/20190829160235-9e2bd.gif"></p>
<p>只演示了插入的过程，其中可以通过delete、find执行删除和查找操作。直观的感受到B树的执行过程。<br>每个节点存储了多个Key和子树，子树与Key按顺序排列。</p>
<blockquote>
<p>同二叉搜索树类似，每个节点存储了多个key和子树，子树与key按顺序排列。<br>页表的目录是扩展外存+加速磁盘读写，一个页（Page）通常4K（等于磁盘数据块block的大小，见inode与block的分析），操作系统每次以页为单位将内容从磁盘加载到内存（以摊分寻道成本），修改页后，再择期将该页写回磁盘。考虑到页表的良好性质，可以使每个节点的大小约等于一个页（使m非常大），这每次加载的一个页就能完整覆盖一个节点，以便选择下一层子树；对子树同理。对于页表来说，AVL（或RBT）相当于1个key+2个子树的B树，由于逻辑上相邻的节点，物理上通常不相邻，因此，读入一个4k页，页面内绝大部分空间都将是无效数据。</p>
</blockquote>
<p>假设key、子树节点指针均占用4B，则B树节点最大<code>m * (4 + 4) = 8m B</code>；页面大小4KB。则<code>m = 4 * 1024 / 8m = 512</code>，一个512叉的B树，1000w的数据，深度最大 <code>log(512/2)(10^7) = 3.02 ~= 4</code>。对比二叉树如AVL的深度为<code>log(2)(10^7) = 23.25 ~= 24</code>，相差了5倍以上。震惊！B树索引深度竟然如此！<br>那为什么B数这么厉害了，还有B+树的出现呢，必然是解决B树存在的问题<br>1、为定位行数<br>2、无法处理范围查询<br><strong>问题1：为定位行数</strong><br>数据表的记录有多个字段，仅仅定位到主键是不够的，还需要定位到数据行。有3个方案解决：</p>
<ol>
<li>直接将key对应的数据行（可能对应多行）存储子节点中。</li>
<li>数据行单独存储；节点中增加一个字段，定位key对应数据行的位置。</li>
<li>修改key与子树的判断逻辑，使子树大于等于上一key小于下一key，最终所有访问都将落于叶子节点；叶子节点中直接存储数据行或数据行的位置。</li>
</ol>
<p>方案1直接pass，存储数据行将减少页面中的子树个数，m减小树高增大。<br>方案2的节点中增加了一个字段，假设是4B的指针，则新的<code>m = 4 * 1024 / 12m = 341.33 ~= 341</code>，深度最大 <code>log(341/2)(10^7) = 3.14 ~= 4</code>。<br>方案3的节点m与深度不变，但时间复杂度变为稳定的O(logm(n))。<br>方案3可以考虑。<br><strong>问题2：无法处理范围查询</strong><br>实际业务中，范围查询的频率非常高，B树只能定位到一个索引位置（可能对应多行），很难处理范围查询。改动较小的是2个方案：</p>
<ol>
<li>不改动；查询的时候先查到左界，再查到右界，然后DFS（或BFS）遍历左界、右界之间的节点。</li>
<li>在“问题1-方案3”的基础上，由于所有数据行都存储在叶子节点，B树的叶子节点本身也是有序的，可以增加一个指针，指向当前叶子节点按主键顺序的下一叶子节点；查询时先查到左界，再查到右界，然后从左界到有界线性遍历。</li>
</ol>
<p>乍一看感觉方案1比方案2好——时间复杂度和常数项都一样，方案1还不需要改动。但是别忘了局部性原理，不管节点中存储的是数据行还是数据行位置，方案2的好处在于，依然可以利用页表和缓存预读下一节点的信息。而方案1则面临节点逻辑相邻、物理分离的缺点。 推荐阅读：<br><a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FB%E6%A0%91">维基百科-B树</a><br><a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FrDCEFzoKHIjyHfI_bsz5Rw">程序员小灰-B树</a></p>
<h3 id="B-树（B-Trees）"><a href="#B-树（B-Trees）" class="headerlink" title="B+树（B+Trees）"></a>B+树（B+Trees）</h3><p>主要变动如上所述：</p>
<ul>
<li>修改key与子树的组织逻辑，将索引访问都落到叶子节点</li>
<li>按顺序将叶子节点串起来（方便范围查询）</li>
</ul>
<p>回顾上一个B树，<strong>一个m阶的B树具有如下几个特征：</strong><br>1.根结点至少有两个子女。<br>2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m<br>3.每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m<br>4.所有的叶子结点都位于同一层。<br>5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。<br><strong>一个m阶的B+树具有如下几个特征：</strong><br>1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。<br>2.所有的叶子结点包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。<br>3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。<br><strong>B+树特性总结</strong><br><strong>B+树是B树的升级版</strong>，其有如下特性</p>
<ul>
<li>非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引</li>
<li>叶子节点包含所有索引字段</li>
<li>叶子节点用指针连接，提高区间访问的性能</li>
<li>只有叶子节点带有卫星数据data（索引元素所指向的数据记录）</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829160236-e80c3.png" alt="http://image.winrains.cn/2019/08/20190829160236-e80c3.png"></p>
<p>同样在<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cs.usfca.edu%2F~galles%2Fvisualization%2FAlgorithms.html">Data Structure Visualizations</a>中选择<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cs.usfca.edu%2F~galles%2Fvisualization%2FBPlusTree.html">B+ Trees</a>B+树进行插入操作可以直观的看到插入过程</p>
<p><img src="http://image.winrains.cn/2019/08/20190829160237-38799.gif" alt="http://image.winrains.cn/2019/08/20190829160237-38799.gif"></p>
<p>在动图中可以看出，B+树的每一个叶子节点都有一个指针指向下一个节点，把所有的叶子节点串在一起。索引数据都存储在叶子节点中。<br>B+树相比于B树，有什么优势呢：<br>1.单一节点存储更多的元素，使得查询的IO次数更少。<br>2.所有查询都要查找到叶子节点，查询性能稳定。<br>3.所有叶子节点形成有序链表，便于范围查询。<br>总结，B+树相比B树的优势有三：1.IO次数更少；2.查询性能稳定；3.范围查询简便。<br>推荐阅读：<br><a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FB%2B%E6%A0%91">维基百科-B+树</a><br><a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FjRZMMONW3QP43dsDKIV9VQ">程序员小灰-B+树</a></p>
<h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p>hash索引基于hash表实现，<strong>Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中</strong>。只有精准匹配索引所有列的查询才有效。索引的检索可以一次定位，不像B-Tree索引需要从根节点出发到目标节点。虽然Hash索引很快，远高于B-tree索引，但是也有其弊端。</p>
<ol>
<li>Hash索引仅仅能满足’=’,’IN’,’&lt;=&gt;’查询，也就是等值查询，不能使用范围查询。很受限<ol>
<li>由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。</li>
</ol>
</li>
<li>由于Hash索引是通过hash表实现，其本身是没有排序的。<ol>
<li>由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；</li>
</ol>
</li>
<li>Hash索引不能利用部分索引键查询<ol>
<li>对于组合索引，Hash索引在计算hash值的时候是组合索引键合并后再一起计算hash值，而不是单独计算hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。</li>
</ol>
</li>
<li>Hash 索引在任何时候都不能避免表扫描<ol>
<li>前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。</li>
</ol>
</li>
<li>Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。<ol>
<li>对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。</li>
</ol>
</li>
</ol>
<h2 id="三、MySQL数据库引擎"><a href="#三、MySQL数据库引擎" class="headerlink" title="三、MySQL数据库引擎"></a>三、MySQL数据库引擎</h2><p>通过navicat工具查看表设计选项中，从引擎中可以看到MySQL又这么多引擎。具体细分到每个表，不同的表引擎可以不一样。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155930-985f7.png" alt="MySQL数据库引擎"></p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>新建一张表t_test_myisam，引擎使用MyISAM，查看原文件可以看到有3个文件</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155931-943cb.png" alt="MyISAM索引结构原文件"></p>
<p>可以看到索引和数据是分开的，其中索引文件仅仅保存数据记录的地址，故属于<strong>非聚簇索引</strong>。</p>
<h4 id="主键索引（Primary-Index）"><a href="#主键索引（Primary-Index）" class="headerlink" title="主键索引（Primary Index）"></a>主键索引（Primary Index）</h4><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data存放的是数据记录的地址。如下图是MyISAM主键索引的原理图。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155931-a8365.png" alt="MyISAM主键索引"></p>
<p>其中Col1为主键，可以看出看出MyISAM的索引文件仅保存数据记录的地址。</p>
<h4 id="辅助索引（Secondary-Index）"><a href="#辅助索引（Secondary-Index）" class="headerlink" title="辅助索引（Secondary Index）"></a>辅助索引（Secondary Index）</h4><p>在Col2上建立一个辅助索引，如下图辅助索引原理图。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155932-6e0c5.png" alt="MyISAM辅助索引"></p>
<p>可以看到与主键索引没有任何区别，只不过主键索引的key是唯一的，而辅助索引的key可以重复。<br><strong>MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</strong></p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>新建一张表t_test_innodb，引擎使用InnoDB，查看原文件可以看到有2个文件</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155932-cea23.png" alt="InnoDB索引结构原文件"></p>
<h4 id="主键索引（Primary-Index）-1"><a href="#主键索引（Primary-Index）-1" class="headerlink" title="主键索引（Primary Index）"></a>主键索引（Primary Index）</h4><p>InnoDB的索引和数据在一个文件当中。<br>按照B+Tree组织的一个索引结构。<br>叶节点保存了完整的数据记录和索引。这种索引就叫做<strong>聚簇索引</strong>。<br>索引的Key是数据的主键，因此InnoDB表数据文件本身就是主索引。<br>如下图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155932-35591.png" alt="InnoDB主键索引"></p>
<p>可以看到叶节点包含了完整的数据记录。<br>因为InnoDB的数据文件本身要按照主键聚集，所以InnoDB要求<strong>必须有主键</strong>。如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段rowid作为主键，这个字段长度为6个字节，类型为长整形。</p>
<h4 id="辅助索引（Secondary-Index）-1"><a href="#辅助索引（Secondary-Index）-1" class="headerlink" title="辅助索引（Secondary Index）"></a>辅助索引（Secondary Index）</h4><p>辅助索引，将途中的第二行name，作为索引如图</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155932-4d106.png" alt="InnoDB辅助索引"></p>
<p>聚簇索引这种实现方式使得按照主键的搜索十分高效，但是<strong>首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录</strong>。<br>由于InnoDB索引的实现特性，推荐使用整形的自增主键。<br>有三点好处：</p>
<ol>
<li>自增key一般为int等整数型，key比较紧凑，这样m可以非常大，而且索引占用空间小。最极端的例子，如果使用50B的varchar（包括长度），那么<code>m = 4 * 1024 / 54m = 75.85 ~= 76</code>，深度最大<code>log(76/2)(10^7) = 4.43 ~= 5</code>，再加上cache缺失、字符串比较的成本，时间成本增加较大。同时，key由4B增长到50B，整棵索引树的空间占用增长也是极为恐怖的（如果二级索引使用主键定位数据行，则空间增长更加严重）。</li>
<li>MySQL索引底层的数据比较都是整数型比较，如果主键时字符串类型的，里面还有英文，还得转换ASCII码进行比较。所以不建议使用uuid作为主键。</li>
<li>自增的主键使得数据行的插入比如落到索引数的最右侧，发生节点分裂的频率较低。<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cs.usfca.edu%2F~galles%2Fvisualization%2FBPlusTree.html">B+Tree</a>实际操作插入过程。如果不是非单调主键，插入过程很大程度会发生节点重排，不利于索引优化的初衷。</li>
</ol>
<h3 id="InnoDB索引和MyISAM索引的区别"><a href="#InnoDB索引和MyISAM索引的区别" class="headerlink" title="InnoDB索引和MyISAM索引的区别"></a>InnoDB索引和MyISAM索引的区别</h3><p>一是主索引的区别：InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。<br>二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。</p>
<h2 id="四、覆盖索引"><a href="#四、覆盖索引" class="headerlink" title="四、覆盖索引"></a>四、覆盖索引</h2><p>InnoDB存储引擎支持覆盖索引，即从辅助索引中就可以得到查询的记录，不需要查询聚簇索引中的记录了。可以减少大量的IO操作。<br>如果要查询辅助索引中不含有的字段，得先遍历辅助索引，再遍历聚集索引，而如果要查询的字段值在辅助索引上就有，就不用再查聚集索引了，这显然会减少IO操作。</p>
<h2 id="五、联合索引"><a href="#五、联合索引" class="headerlink" title="五、联合索引"></a>五、联合索引</h2><p>两个或以上的列上的索引。如下图联合索引的原理图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155933-ebb18.png" alt="联合索引原理图"></p>
<p>上图中的联合索引有三个，从上到下，严格按照排序。</p>
<h2 id="六、优化建议"><a href="#六、优化建议" class="headerlink" title="六、优化建议"></a>六、优化建议</h2><h3 id="最左前缀匹配"><a href="#最左前缀匹配" class="headerlink" title="最左前缀匹配"></a>最左前缀匹配</h3><p>索引可以简单如一个列(a)，也可以复杂如多个列(a, b, c, d)，即<code>联合索引</code>。如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否存在（相等），遇到范围查询(&gt;、&lt;、between、like左匹配)等就不能进一步匹配了，后续退化为线性查找。因此，列的排列顺序决定了可命中索引的列数。<br>如有索引(a, b, c, d)，查询条件<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>，则会在每个节点依次命中a、b、c，无法命中d。也就是最左前缀匹配原则。</p>
<h3 id="、in自动优化顺序"><a href="#、in自动优化顺序" class="headerlink" title="=、in自动优化顺序"></a>=、in自动优化顺序</h3><p>不需要考虑=、in等的顺序，mysql会自动优化这些条件的顺序，以匹配尽可能多的索引列。<br>如有索引(a, b, c, d)，查询条件<code>c &gt; 3 and b = 2 and a = 1 and d &lt; 4</code>与<code>a = 1 and c &gt; 3 and b = 2 and d &lt; 4</code>等顺序都是可以的，MySQL会自动优化为<code>a = 1 and b = 2 and c &gt; 3 and d &lt; 4</code>，依次命中a、b、c。</p>
<h3 id="索引列不能参与计算"><a href="#索引列不能参与计算" class="headerlink" title="索引列不能参与计算"></a>索引列不能参与计算</h3><p>有索引列参与计算的查询条件对索引不友好（甚至无法使用索引），如<code>from_unixtime(create_time) = &#39;2014-05-29&#39;</code>。<br>原因很简单，如何在节点中查找到对应key？如果线性扫描，则每次都需要重新计算，成本太高；如果二分查找，则需要针对from_unixtime方法确定大小关系。<br>因此，索引列不能参与计算。上述<code>from_unixtime(create_time) = &#39;2014-05-29&#39;</code>语句应该写成<code>create_time = unix_timestamp(&#39;2014-05-29&#39;)</code>。</p>
<h3 id="能扩展就不要新建索引"><a href="#能扩展就不要新建索引" class="headerlink" title="能扩展就不要新建索引"></a>能扩展就不要新建索引</h3><p>如果已有索引(a)，想建立索引(a, b)，尽量选择修改索引(a)为索引(a, b)。<br>新建索引的成本很容易理解。而基于索引(a)修改为索引(a, b)的话，MySQL可以直接在索引a的B+树上，经过分裂、合并等修改为索引(a, b)。</p>
<h3 id="不需要建立前缀有包含关系的索引"><a href="#不需要建立前缀有包含关系的索引" class="headerlink" title="不需要建立前缀有包含关系的索引"></a>不需要建立前缀有包含关系的索引</h3><p>如果已有索引(a, b)，则不需要再建立索引(a)，但是如果有必要，则仍然需考虑建立索引(b)。</p>
<blockquote>
<p>作者：鸟不拉屎</p>
<p>来源：<a href="https://juejin.im/post/5d63348ae51d453b1e478ae3" target="_blank" rel="noopener">https://juejin.im/post/5d63348ae51d453b1e478ae3</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>理解JVM虚拟机</title>
    <url>/2019/12/26/%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="一-JVM内存区域的划分"><a href="#一-JVM内存区域的划分" class="headerlink" title="一. JVM内存区域的划分"></a>一. JVM内存区域的划分</h2><h3 id="1-1-java虚拟机运行时数据区"><a href="#1-1-java虚拟机运行时数据区" class="headerlink" title="1.1 java虚拟机运行时数据区"></a>1.1 java虚拟机运行时数据区</h3><p><strong>java虚拟机运行时数据区分布图：</strong></p>
<p><img src="http://image.winrains.cn/2019/08/20190829183219-8c64b.png" alt="img"></p>
<a id="more"></a>

<ul>
<li><strong>JVM栈（Java Virtual Machine Stacks）：</strong> Java中一个线程就会相应有一个线程栈与之对应，因为不同的线程执行逻辑有所不同，因此需要一个独立的线程栈，因此栈存储的信息都是跟当前线程（或程序）相关信息的，包括<strong>局部变量</strong>、<strong>程序运行状态</strong>、<strong>方法返回值</strong>、<strong>方法出口</strong>等等。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
<li><strong>堆（Heap）：</strong> 堆是所有线程共享的，主要是存放对象实例和数组。处于<strong>物理上不连续</strong>的内存空间，只要<strong>逻辑连续</strong>即可</li>
<li><strong>方法区（Method Area）：</strong> 属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</li>
<li><strong>常量池（Runtime Constant Pool）：</strong> 它是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。</li>
<li><strong>本地方法栈（Native Method Stacks）：</strong></li>
</ul>
<p>其中，<strong>堆(Heap)和JVM栈</strong>是<strong>程序运行的关键</strong>,因为：</p>
<ol>
<li>栈是运行时的单位（解决程序的运行问题，即程序如何执行，或者说如何处理数据），而堆是存储的单位（解决的是数据存储的问题，即数据怎么放、放在哪儿）。</li>
<li>堆存储的是对象。栈存储的是基本数据类型和堆中对象的引用；（参数传递的值传递和引用传递）</li>
</ol>
<p><strong>那为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？</strong></p>
<ol>
<li>从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据，分工明确，处理逻辑更为清晰体现了“分而治之”以及“隔离”的思想。</li>
<li>堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这样共享的方式有很多收益：提供了一种有效的数据交互方式(如：共享内存)；堆中的共享常量和缓存可以被所有栈访问，节省了空间。</li>
<li>栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。</li>
<li>堆和栈的结合完美体现了面向对象的设计。当我们将对象拆开，你会发现，对象的属性即是数据，存放在堆中；而对象的行为（方法）即是运行逻辑，放在栈中。因此编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。</li>
</ol>
<h3 id="1-2-堆-Heap-和JVM栈："><a href="#1-2-堆-Heap-和JVM栈：" class="headerlink" title="1.2 堆(Heap)和JVM栈："></a>1.2 堆(Heap)和JVM栈：</h3><h4 id="1-2-1-堆-Heap"><a href="#1-2-1-堆-Heap" class="headerlink" title="1.2.1 堆(Heap)"></a>1.2.1 堆(Heap)</h4><p><strong>Java堆</strong>是java虚拟机所管理内存中<strong>最大的一块内存空间</strong>，处于<strong>物理上不连续</strong>的内存空间，只要<strong>逻辑连续</strong>即可，主要用于存放各种类的实例对象。该区域被所有线程共享，在虚拟机启动时创建，用来存放对象的实例，几乎所有的对象以及数组都在这里分配内存（栈上分配、标量替换优化技术的例外）。<br>在 Java 中，堆被划分成两个不同的区域：<strong>新生代 ( Young )</strong>、<strong>老年代 ( Old )</strong>。<strong>新生代 ( Young )</strong> 又被划分为三个区域：<strong>Eden</strong>、<strong>From Survivor(S0)</strong>、<strong>To Survivor(S1)</strong>。如图所示：<br><strong>堆的内存布局:</strong></p>
<p><img src="http://image.winrains.cn/2019/08/20190829183221-9ca8c.png" alt="img"></p>
<p>这样划分的目的是为了使jvm能够更好的管理内存中的对象，包括内存的分配以及回收。 而新生代按eden和两个survivor的分法，是为了</p>
<ul>
<li>有效空间增大，eden+1个survivor；</li>
<li>有利于对象代的计算，当一个对象在S0/S1中达到设置的XX:MaxTenuringThreshold值后，会将其挪到老年代中，即只需扫描其中一个survivor。如果没有S0/S1,直接分成两个区，该如何计算对象经过了多少次GC还没被释放。</li>
<li>两个Survivor区可解决内存碎片化</li>
</ul>
<h4 id="1-2-2-堆栈相关的参数"><a href="#1-2-2-堆栈相关的参数" class="headerlink" title="1.2.2 堆栈相关的参数"></a>1.2.2 堆栈相关的参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms</td>
<td>堆内存初始大小，单位m、g</td>
</tr>
<tr>
<td>-Xmx</td>
<td>堆内存最大允许大小，一般不要大于物理内存的80%</td>
</tr>
<tr>
<td>-Xmn</td>
<td>年轻代内存初始大小</td>
</tr>
<tr>
<td>-Xss</td>
<td>每个线程的堆栈大小，即JVM栈的大小</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>年轻代(包括Eden和两个Survivor区)与年老代的比值</td>
</tr>
<tr>
<td>-XX:NewSzie(-Xns)</td>
<td>年轻代内存初始大小,可以缩写-Xns</td>
</tr>
<tr>
<td>-XX:MaxNewSize(-Xmx)</td>
<td>年轻代内存最大允许大小，可以缩写-Xmx</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>年轻代中Eden区与Survivor区的容量比例值，默认为8，即8:1</td>
</tr>
<tr>
<td>-XX:MinHeapFreeRatio</td>
<td>GC后，如果发现空闲堆内存占到整个预估堆内存的40%，则放大堆内存的预估最大值，但不超过固定最大值。</td>
</tr>
<tr>
<td>-XX:MaxHeapFreeRatio</td>
<td>预估堆内存是堆大小动态调控的重要选项之一。堆内存预估最大值一定小于或等于固定最大值(-Xmx指定的数值)。前者会根据使用情况动态调大或缩小，以提高GC回收的效率，默认70%</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>垃圾最大年龄，设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代。对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率</td>
</tr>
<tr>
<td>-XX:InitialTenuringThreshold</td>
<td>可以设定老年代阀值的初始值</td>
</tr>
<tr>
<td>-XX:+PrintTenuringDistribution</td>
<td>查看每次minor GC后新的存活周期的阈值</td>
</tr>
</tbody></table>
<p><strong>Note：</strong> 每次GC 后会调整堆的大小，为了<strong>防止动态调整带来的性能损耗</strong>，一般设置-<strong>Xms、-Xmx 相等</strong>。<br>新生代的三个设置参数：-Xmn，-XX:NewSize，-XX:NewRatio的优先级：<br>（1）.最高优先级： -XX:NewSize=1024m和-XX:MaxNewSize=1024m<br>（2）.次高优先级： -Xmn1024m （默认等效效果是：-XX:NewSize==-XX:MaxNewSize==1024m）<br>（3）.最低优先级：-XX:NewRatio=2<br>推荐使用的是-Xmn参数，原因是这个参数很简洁，相当于一次性设定NewSize和MaxNewSIze，而且两者相等。</p>
<h3 id="1-3-jvm对象"><a href="#1-3-jvm对象" class="headerlink" title="1.3 jvm对象"></a>1.3 jvm对象</h3><h4 id="1-3-1-创建对象的方式"><a href="#1-3-1-创建对象的方式" class="headerlink" title="1.3.1 创建对象的方式"></a>1.3.1 创建对象的方式</h4><p><img src="http://image.winrains.cn/2019/08/20190829183222-b1608.png" alt="img"></p>
<p>各个方式的实质操作如下：</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>实质</th>
</tr>
</thead>
<tbody><tr>
<td>使用new关键</td>
<td>调用无参或有参构造器函数创建</td>
</tr>
<tr>
<td>使用Class的newInstance方法</td>
<td>调用无参或有参构造器函数创建，且需要是public的构造函数</td>
</tr>
<tr>
<td>使用Constructor类的newInstance方法</td>
<td>调用有参和私有private构造器函数创建，实用性更广</td>
</tr>
<tr>
<td>使用Clone方法</td>
<td>不调用任何参构造器函数，且对象需要实现Cloneable接口并实现其定义的clone方法，且默认为浅复制</td>
</tr>
<tr>
<td>第三方库Objenesis</td>
<td>利用了asm字节码技术，动态生成Constructor对象</td>
</tr>
</tbody></table>
<h4 id="1-3-2-jvm对象分配"><a href="#1-3-2-jvm对象分配" class="headerlink" title="1.3.2 jvm对象分配"></a>1.3.2 jvm对象分配</h4><p>在虚拟机层面上创建对象的步骤：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829183222-54375.png" alt="img"></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>解析</th>
</tr>
</thead>
<tbody><tr>
<td>1、判断对象对应的类是否加载、链接、初始化</td>
<td>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。如果没有，那么必须先执行类的加载、解释、初始化（类的clinit方法）。</td>
</tr>
<tr>
<td>2、为对象分配内存</td>
<td>类加载检查通过后，虚拟机为新生对象分配内存。对象所需内存大小在类加载完成后便可以完全确定，为对象分配空间无非就是从Java堆中划分出一块确定大小的内存而已。</td>
</tr>
<tr>
<td>3、处理并发安全问题</td>
<td>另外一个问题及时保证new对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发问题。 虚拟机采用了两种方式解决并发问题: （1）CAS配上失败重试的方式保证指针更新操作的原子性; （2）TLAB 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区，（TLAB ，Thread Local Allocation Buffer）虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。</td>
</tr>
<tr>
<td>4、初始化分配到的空间</td>
<td>内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值</td>
</tr>
<tr>
<td>5、设置对象的对象头</td>
<td>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC分代年龄等数据存储在对象的对象头中</td>
</tr>
<tr>
<td>6、执行init方法进行初始化</td>
<td>在Java程序的视角看来，初始化才正式开始，开始调用方法完成初始赋值和构造函数，所有的字段都为零值。因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执 行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。</td>
</tr>
</tbody></table>
<h4 id="1-3-3-对象分配内存方式"><a href="#1-3-3-对象分配内存方式" class="headerlink" title="1.3.3 对象分配内存方式"></a>1.3.3 对象分配内存方式</h4><p><strong>分配对象内存</strong>，<strong>有两种分配方式</strong>，<strong>指针碰撞</strong>和<strong>空闲列表</strong>：<br>（1）如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Pointer）来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。 如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。 一般使用带有compact（整理）过程的收集器时，使用指针碰撞。<br>（2）如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为“空闲列表（Free List）”。<br><strong>Note：</strong> 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<h4 id="1-3-4-那什么样的对象能够进入老年代-Old"><a href="#1-3-4-那什么样的对象能够进入老年代-Old" class="headerlink" title="1.3.4 那什么样的对象能够进入老年代(Old)"></a>1.3.4 那什么样的对象能够进入老年代(Old)</h4><p><strong>那什么样的对象能够进入老年代(Old)？</strong></p>
<p><img src="http://image.winrains.cn/2019/08/20190829183223-9dcb9.png" alt="img"></p>
<h3 id="1-4-内存分配与回收策略"><a href="#1-4-内存分配与回收策略" class="headerlink" title="1.4 内存分配与回收策略"></a>1.4 内存分配与回收策略</h3><table>
<thead>
<tr>
<th>情况</th>
<th>解析</th>
</tr>
</thead>
<tbody><tr>
<td>1.对象优先在Eden分配</td>
<td>大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC；虚拟机提供了-XX:PrintGCDetails参数，发生垃圾回收时打印内存回收日志，并且在进程退出时输出当前内存各区域的分配情况。</td>
</tr>
<tr>
<td>2.大对象直接进入老年代</td>
<td>所谓的大对象就是指，需要大量连续内存空间的java对象，最典型的大对象就是那种很长的字符串及数组。虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值得对象直接在老年代中分配（这样做的目的是避免在Eden区及两个Survivor之间发生大量的内存拷贝）</td>
</tr>
<tr>
<td>3.长期存活的对象将直接进入老年代</td>
<td>对象年龄计数器。-XX:MaxTenuringThreshold</td>
</tr>
<tr>
<td>4、动态对象年龄判定</td>
<td>虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。</td>
</tr>
<tr>
<td>5、空间分配担保</td>
<td>在发生Minor GC时（前），虚拟机会检测之前每次晋升到老年代的平均大小（因为当次会有多少对象会存活是无法确定的，所以取之前的平均值/经验值）是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于，则查看HandlePromotionFailure设置是否允许担保失败；如果允许，那只会进行Minor GC；如果不允许，则也要改为进行一次Full GC。取平均值进行比较其实仍然是一种动态概率手段，也就是说如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure），这样会触发Full GC。</td>
</tr>
</tbody></table>
<h2 id="二-垃圾回收算法分类"><a href="#二-垃圾回收算法分类" class="headerlink" title="二 垃圾回收算法分类"></a>二 垃圾回收算法分类</h2><h3 id="2-1-引用"><a href="#2-1-引用" class="headerlink" title="2.1 引用"></a>2.1 引用</h3><p><img src="http://image.winrains.cn/2019/08/20190829183224-a964f.png" alt="img"></p>
<h3 id="2-2-GC-Root的对象"><a href="#2-2-GC-Root的对象" class="headerlink" title="2.2 GC Root的对象"></a>2.2 GC Root的对象</h3><p><img src="http://image.winrains.cn/2019/08/20190829183225-a0343.png" alt="img"></p>
<h3 id="2-3-标记-清除（Mark—Sweep）"><a href="#2-3-标记-清除（Mark—Sweep）" class="headerlink" title="2.3 标记-清除（Mark—Sweep）"></a>2.3 标记-清除（Mark—Sweep）</h3><p>被誉为现代垃圾回收算法的思想基础。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829183225-8ae9d.png" alt="img"></p>
<p><strong>标记-清除算法</strong>采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。</p>
<h3 id="2-4-复制算法（Copying）"><a href="#2-4-复制算法（Copying）" class="headerlink" title="2.4 复制算法（Copying）"></a>2.4 复制算法（Copying）</h3><p>该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。建立在存活对象少，垃圾对象多的前提下。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去后还能进行相应的内存整理，不会出现碎片问题。但缺点也是很明显，就是需要两倍内存空间。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829183226-687ca.png" alt="img"></p>
<p>它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象面和空闲区域面，在对象面与空闲区域面的切换过程中，程序暂停执行。</p>
<h3 id="2-5-标记-整理（或标记-压缩算法，Mark-Compact，又或者叫标记清除压缩MarkSweepCompact）"><a href="#2-5-标记-整理（或标记-压缩算法，Mark-Compact，又或者叫标记清除压缩MarkSweepCompact）" class="headerlink" title="2.5 标记-整理（或标记-压缩算法，Mark-Compact，又或者叫标记清除压缩MarkSweepCompact）"></a>2.5 标记-整理（或标记-压缩算法，Mark-Compact，又或者叫标记清除压缩MarkSweepCompact）</h3><p>此算法是结合了“标记-清除”和“复制算法”两个算法的优点。避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829183226-4c3a5.png" alt="img"></p>
<p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。</p>
<h3 id="2-6-分代回收策略（Generational-Collecting）"><a href="#2-6-分代回收策略（Generational-Collecting）" class="headerlink" title="2.6 分代回收策略（Generational Collecting）"></a>2.6 分代回收策略（Generational Collecting）</h3><p>基于这样的事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。<br>新生代由于其对象存活时间短，且需要经常gc，因此采用效率较高的复制算法，其将内存区分为一个eden区和两个suvivor区，默认eden区和survivor区的比例是8:1，分配内存时先分配eden区，当eden区满时，使用复制算法进行gc，将存活对象复制到一个survivor区，当一个survivor区满时，将其存活对象复制到另一个区中，当对象存活时间大于某一阈值时，将其放入老年代。老年代和永久代因为其存活对象时间长，因此使用标记清除或标记整理算法<br><strong>总结：</strong></p>
<ul>
<li>新生代：复制算法（新生代回收的频率很高，每次回收的耗时很短，为了支持高频率的新生代回收，虚拟机可能使用一种叫做卡表（Card Table）的数据结构，卡表为一个比特位集合，每个比特位可以用来表示老年代的某一区域中的所有对象是否持有新生代对,</li>
</ul>
<h3 id="2-7-垃圾回收器"><a href="#2-7-垃圾回收器" class="headerlink" title="2.7 垃圾回收器"></a>2.7 垃圾回收器</h3><p><img src="http://image.winrains.cn/2019/08/20190829183227-3e6e1.png" alt="img"></p>
<p><strong>垃圾回收器</strong>的任务是识别和回收垃圾对象进行内存清理，不同代可使用不同的收集器：</p>
<ul>
<li><strong>新生代收集器</strong>使用的收集器：<strong>Serial、ParNew、Parallel Scavenge</strong>；</li>
<li><strong>老年代收集器</strong>使用的收集器：<strong>Serial Old（MSC）、Parallel Old、CMS。</strong></li>
</ul>
<p><strong>总结：</strong></p>
<ol>
<li><strong>Serial old和新生代的所有回收器都能搭配；也可以作为CMS回收器的备用回收器；</strong></li>
<li><strong>CMS只能和新生代的Serial和ParNew搭配，而且ParNew是CMS默认的新生代回收器；</strong></li>
<li><strong>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态</strong></li>
<li><strong>并发（Concurrent）：指用户线程和垃圾收集线程同时执行（但不一定是并行的，可能是交替执行），用户程序继续运行，而垃圾收集程序运行在另外的CPU上。</strong></li>
</ol>
<h2 id="三-GC的执行机制"><a href="#三-GC的执行机制" class="headerlink" title="三. GC的执行机制"></a>三. GC的执行机制</h2><p>Java 中的<strong>堆(deap)</strong> 也是 GC 收集垃圾的主要区域。 由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：<strong>Scavenge GC（Minor GC）和Full GC（Major GC）</strong>。</p>
<ul>
<li><strong>Scavenge GC(Minor GC):</strong> 一般情况下，当新对象生成（age=0），并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区（age+1）。然后整理（其实是复制过去就顺便整理了）Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法（即复制-清理算法），使Eden去能尽快空闲出来。Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。</li>
<li><strong>Full GC:</strong> 对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。</li>
</ul>
<h3 id="3-1-触发Full-GC执行的场景"><a href="#3-1-触发Full-GC执行的场景" class="headerlink" title="3.1 触发Full GC执行的场景"></a>3.1 触发Full GC执行的场景</h3><p><img src="http://image.winrains.cn/2019/08/20190829183228-85964.png" alt="img"></p>
<h3 id="3-2-Young-GC触发条件"><a href="#3-2-Young-GC触发条件" class="headerlink" title="3.2 Young GC触发条件"></a>3.2 Young GC触发条件</h3><p><img src="http://image.winrains.cn/2019/08/20190829183229-c67c1.png" alt="img"></p>
<h3 id="3-3-新生对象GC收回流程"><a href="#3-3-新生对象GC收回流程" class="headerlink" title="3.3 新生对象GC收回流程"></a>3.3 新生对象GC收回流程</h3><p>基于大多数新生对象都会在GC中被收回的假设。新生代的GC 使用复制算法，（将年轻代分为3部分，主要是为了生命周期短的对象尽量留在年轻代。老年代主要存放生命周期比较长的对象，比如缓存）。可能经历过程：</p>
<ol>
<li><strong>对象创建时，一般在Eden区完成内存分配（有特殊）；</strong></li>
<li><strong>当Eden区满了，再创建对象，会因为申请不到空间，触发minorGC，进行young(eden+1survivor)区的垃圾回收；</strong></li>
<li><strong>minorGC时，Eden和survivor A不能被GC回收且年龄没有达到阈值（tenuring threshold）的对象，会被放入survivor B，始终保证一个survivor是空的；</strong></li>
<li><strong>当做第3步的时候，如果发现survivor满了，将这些对象copy到old区（分配担保机制）；或者survivor并没有满，但是有些对象已经足够Old，也被放入Old区 XX:MaxTenuringThreshold；（回顾下对象进入老年代的情况）</strong></li>
<li><strong>直接清空eden和survivor A；</strong></li>
<li><strong>当Old区被放满的之后，进行fullGC。</strong></li>
</ol>
<h3 id="3-4-GC日志"><a href="#3-4-GC日志" class="headerlink" title="3.4 GC日志"></a>3.4 GC日志</h3><p><strong>GC日志相关参数:</strong></p>
<ul>
<li>-XX:+PrintGC：输出GC日志</li>
<li>-XX:+PrintGCDetails：输出GC的详细日志</li>
<li>-XX:+PrintGCTimeStamps：输出GC的时间戳（以基准时间的形式）</li>
<li>-XX:+PrintGCApplicationStoppedTime：打印垃圾回收期间程序暂停的时间</li>
<li>-XX:+PrintGCApplicationConcurrentTime：打印每次垃圾回收前，程序未中断的执行时间</li>
<li>-XX:+PrintHeapAtGC：在进行GC的前后打印出堆的信息</li>
<li>-XX:+PrintTLAB：查看TLAB空间的使用情况</li>
<li>-XX:PrintTenuingDistribution：查看每次minor GC后新的存活周期的阈值</li>
<li>-XX:PrintReferenceFC：用来跟踪系统内的(softReference)软引用，(weadReference)弱引用,(phantomReference)虚引用，显示引用过程</li>
</ul>
<p>案例分析：-XX:+PrintGCApplicationStoppedTime -XX:+PrintGCApplicationConcurrentTime一起使用</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Application <span class="built_in">time</span>: <span class="number">0.3440086</span> <span class="built_in">seconds</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which application threads were stopped: <span class="number">0.0620105</span> <span class="built_in">seconds</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Application <span class="built_in">time</span>: <span class="number">0.2100691</span> <span class="built_in">seconds</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which application threads were stopped: <span class="number">0.0890223</span> <span class="built_in">seconds</span></span></pre></td></tr></table></figure>

<p>得知应用程序在前344毫秒中是在处理实际工作的，然后将所有线程暂停了62毫秒，紧接着又工作了210ms，然后又暂停了89ms。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2796146</span>K-&gt;<span class="number">2049</span>K(<span class="number">1784832</span>K)] <span class="number">4171400</span>K-&gt;<span class="number">2049</span>K(<span class="number">3171840</span>K), [Metaspace: <span class="number">3134</span>K-&gt;<span class="number">3134</span>K(<span class="number">1056768</span>K)], <span class="number">0.0571841</span> secs] [Times: user=<span class="number">0.02</span> sys=<span class="number">0.04</span>, real=<span class="number">0.06</span> secs]</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total time <span class="keyword">for</span> which application threads were stopped: <span class="number">0.0572646</span> seconds, Stopping threads took: <span class="number">0.0000088</span> seconds</span></pre></td></tr></table></figure>

<p>应用线程被强制暂停了57ms来进行垃圾回收。其中又有8ms是用来等待所有的应用线程都到达安全点。<br>只要设置-XX:+PrintGCDetails 就会自动带上-verbose:gc和-XX:+PrintGC</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">33.125</span>: [GC [DefNew: <span class="number">3324</span>K-&gt;<span class="number">152</span>K(<span class="number">3712</span>K), <span class="number">0.0025925</span> secs] <span class="number">3324</span>K-&gt;<span class="number">152</span>K(<span class="number">11904</span>K), <span class="number">0.0031680</span> secs]</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">100.667</span>: [Full GC [Tenured: <span class="number">0</span>K-&gt;<span class="number">210</span>K(<span class="number">10240</span>K), <span class="number">0.0149142</span> secs] <span class="number">4603</span>K-&gt;<span class="number">210</span>K(<span class="number">19456</span>K), [Perm : <span class="number">2999</span>K-&gt;<span class="number">2999</span>K(<span class="number">21248</span>K)], <span class="number">0.0150007</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs]</span></pre></td></tr></table></figure>

<ol>
<li>最前面的数字“33.125：”和“100.667：”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。</li>
<li>GC日志开头的“［GC”和“［Full GC”说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有“Full”，说明这次GC是发生了Stop-The-World的。</li>
<li>接下来的“［DefNew”、“［Tenured”、“［Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的，例如上面样例所使用的Serial收集器中的新生代名为“Default New Generation”，所以显示的是“［DefNew”。如果是ParNew收集器，新生代名称就会变为“［ParNew”，意为“Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代称为“PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。</li>
<li>后面方括号内部的“3324K-&gt;152K(3712K)”含义是“GC前该内存区域已使用容量-&gt; GC后该内存区域已使用容量 (该内存区域总容量)”。而在方括号之外的“3324K-&gt;152K(11904K)”表示“GC前Java堆已使用容量 -&gt; GC后Java堆已使用容量 (Java堆总容量)”。</li>
<li>再往后，“0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据</li>
<li>[Full GC 283.736: [ParNew: 261599K-&gt;261599K(261952K), 0.0000288 secs] 新生代收集器ParNew的日志也会出现“［Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc()方法所触发的收集，那么在这里将显示“［Full GC (System)”。</li>
</ol>
<h3 id="3-5-减少GC开销的措施"><a href="#3-5-减少GC开销的措施" class="headerlink" title="3.5 减少GC开销的措施"></a>3.5 减少GC开销的措施</h3><p>从代码上：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829183230-18b22.png" alt="img"></p>
<p>从JVM参数上调优上：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829183231-7f999.png" alt="img"></p>
<h3 id="3-6-内存溢出分类"><a href="#3-6-内存溢出分类" class="headerlink" title="3.6 内存溢出分类"></a>3.6 内存溢出分类</h3><p><img src="http://image.winrains.cn/2019/08/20190829183232-a9393.png" alt="img"></p>
<h2 id="四-总结-JVM调优相关"><a href="#四-总结-JVM调优相关" class="headerlink" title="四. 总结-JVM调优相关"></a>四. 总结-JVM调优相关</h2><h3 id="4-1-调优目的"><a href="#4-1-调优目的" class="headerlink" title="4.1 调优目的"></a>4.1 调优目的</h3><p><img src="http://image.winrains.cn/2019/08/20190829183233-1dbfb.png" alt="img"></p>
<h3 id="4-2-JVM性能调优所处的层次"><a href="#4-2-JVM性能调优所处的层次" class="headerlink" title="4.2 JVM性能调优所处的层次"></a>4.2 JVM性能调优所处的层次</h3><p><img src="http://image.winrains.cn/2019/08/20190829183233-87064.png" alt="img"></p>
<h3 id="4-3-JVM调优流程"><a href="#4-3-JVM调优流程" class="headerlink" title="4.3 JVM调优流程"></a>4.3 JVM调优流程</h3><p><img src="http://image.winrains.cn/2019/08/20190829183234-4caaa.png" alt="img"></p>
<h3 id="4-4-性能监控工具"><a href="#4-4-性能监控工具" class="headerlink" title="4.4 性能监控工具"></a>4.4 性能监控工具</h3><p><img src="http://image.winrains.cn/2019/08/20190829183234-b5031.png" alt="img"></p>
<p>调优的最终目的都是为了令应用程序使用最小的硬件消耗来承载更大的吞吐。jvm的调优也不例外，jvm调优主要是针对垃圾收集器的收集性能优化，令运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量。</p>
<blockquote>
<p>作者：Ccww</p>
<p>来源：<a href="https://juejin.im/post/5d200b54f265da1bac40384a" target="_blank" rel="noopener">https://juejin.im/post/5d200b54f265da1bac40384a</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>小而美的Shiro安全框架</title>
    <url>/2019/12/26/%E5%B0%8F%E8%80%8C%E7%BE%8E%E7%9A%84Shiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在一款应用的整个生命周期，我们都会谈及该应用的数据安全问题。用户的合法性与数据的可见性是数据安全中非常重要的一部分。但是，一方面，不同的应用对于数据的合法性和可见性要求的维度与粒度都有所区别；另一方面，以当前微服务、多服务的架构方式，如何共享Session，如何缓存认证和授权数据应对高并发访问都迫切需要我们解决。Shiro的出现让我们可以快速和简单的应对我们应用的数据安全问题。</p>
<a id="more"></a>

<h2 id="Shiro介绍"><a href="#Shiro介绍" class="headerlink" title="Shiro介绍"></a>Shiro介绍</h2><h3 id="Shiro简介"><a href="#Shiro简介" class="headerlink" title="Shiro简介"></a>Shiro简介</h3><p>这个官网解释不抽象，所以直接用官网解释：Apache Shiro™是一个强大且易用的 Java 安全框架，可以执行身份验证、授权、加密和会话管理等。基于 Shiro 的易于理解的API，您可以快速、轻松地使任何应用程序变得安全（从最小的移动应用到最大的网络和企业应用）。<br>谈及安全，多数 Java 开发人员都离不开 Spring 框架的支持，自然也就会先想到 Spring Security，那我们先来看二者的差别</p>
<table>
<thead>
<tr>
<th>Shiro</th>
<th>Spring Security</th>
</tr>
</thead>
<tbody><tr>
<td>简单、灵活</td>
<td>复杂、笨重</td>
</tr>
<tr>
<td>可脱离Spring</td>
<td>不可脱离Spring</td>
</tr>
<tr>
<td>粒度较粗</td>
<td>粒度较细</td>
</tr>
</tbody></table>
<p>虽然 Spring Security 属于名震中外 Spring 家族的一部分，但是了解 Shiro 之后，你不会想 “嫁入豪门”，而是选择追求「诗和远方」冲动。<br>横看成岭侧成峰，远近高低各不同 (依旧是先了解概念就好)</p>
<h3 id="远看-Shiro-看轮廓"><a href="#远看-Shiro-看轮廓" class="headerlink" title="远看 Shiro 看轮廓"></a>远看 Shiro 看轮廓</h3><p><img src="http://image.winrains.cn/2019/08/20190829192223-d2934.png" alt="img"></p>
<h4 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h4><p>它是一个主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者</p>
<h4 id="SecurityManager"><a href="#SecurityManager" class="headerlink" title="SecurityManager"></a>SecurityManager</h4><p>安全管理器；即所有与安全有关的操作都会与 SecurityManager 交互；且它管理着所有 Subject；可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet前端控制器</p>
<h4 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h4><p>域，Shiro 从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。</p>
<h3 id="近看-Shiro-看细节"><a href="#近看-Shiro-看细节" class="headerlink" title="近看 Shiro 看细节"></a>近看 Shiro 看细节</h3><p>看图瞬间懵逼？别慌，会为你拆解来看，结合着图看下面的解释，这不是啥大问题，且看:</p>
<p><img src="http://image.winrains.cn/2019/08/20190829192224-bcb0d.png" alt="img"></p>
<h4 id="Subject-1"><a href="#Subject-1" class="headerlink" title="Subject"></a>Subject</h4><p>主体，可以看到主体可以是任何可以与应用交互的 “用户”</p>
<h4 id="SecurityManager-1"><a href="#SecurityManager-1" class="headerlink" title="SecurityManager"></a>SecurityManager</h4><p>相当于 SpringMVC 中的 DispatcherServlet；是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理</p>
<h4 id="Authenticator"><a href="#Authenticator" class="headerlink" title="Authenticator"></a>Authenticator</h4><p>认证器，负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；需要自定义认证策略（Authentication Strategy），即什么情况下算用户认证通过了</p>
<h4 id="Authrizer"><a href="#Authrizer" class="headerlink" title="Authrizer"></a>Authrizer</h4><p>授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能</p>
<h4 id="Realm-1"><a href="#Realm-1" class="headerlink" title="Realm"></a>Realm</h4><p>可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC实现，也可以是LDAP实现，或者内存实现等等；由用户提供；注意：Shiro 不知道你的用户/权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的Realm</p>
<h4 id="SessionManager"><a href="#SessionManager" class="headerlink" title="SessionManager"></a>SessionManager</h4><p>如果写过 Servlet 就应该知道 Session 的概念，Session 需要有人去管理它的生命周期，这个组件就是 SessionManager；而Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境、EJB等环境；所以，Shiro 就抽象了一个自己的Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台Web服务器；接着又上了台EJB 服务器；这时又想把两台服务器的会话数据放到一个地方，我们就可以实现自己的分布式会话（如把数据放到Memcached 服务器）</p>
<h4 id="SessionDAO"><a href="#SessionDAO" class="headerlink" title="SessionDAO"></a>SessionDAO</h4><p>DAO大家都用过，数据访问对象，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的SessionDAO，通过如JDBC写到数据库；比如想把 Session 放到 Memcached 中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能；</p>
<h4 id="CacheManager"><a href="#CacheManager" class="headerlink" title="CacheManager"></a>CacheManager</h4><p>缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能</p>
<h4 id="Cryptography"><a href="#Cryptography" class="headerlink" title="Cryptography"></a>Cryptography</h4><p>密码模块，Shiro提高了一些常见的加密组件用于如密码「加密/解密」的<br><strong>注意上图的结构，我们会根据这张图来逐步拆分讲解，记住这张图也更有助于我们理解 Shiro 的工作原理</strong>，所以依旧是打开两个网页一起看就好喽</p>
<h2 id="搭建概览"><a href="#搭建概览" class="headerlink" title="搭建概览"></a>搭建概览</h2><p>多数小伙伴都在使用 Spring Boot， Shiro 也很应景的定义了 starter，做了更好的封装，对于我们来说使用起来也就更加方便，来看选型概览</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Springboot</td>
<td>2.0.4</td>
</tr>
<tr>
<td>2</td>
<td>JPA</td>
<td>2.0.4</td>
</tr>
<tr>
<td>3</td>
<td>Mysql</td>
<td>8.0.12</td>
</tr>
<tr>
<td>4</td>
<td>Redis</td>
<td>2.0.4</td>
</tr>
<tr>
<td>5</td>
<td>Lombok</td>
<td>1.16.22</td>
</tr>
<tr>
<td>6</td>
<td>Guava</td>
<td>26.0-jre</td>
</tr>
<tr>
<td>7</td>
<td>Shiro</td>
<td>1.4.0</td>
</tr>
</tbody></table>
<p>使用 Spring Boot，大多都是通过添加 starter 依赖，会自动解决依赖包版本，所以自己尝试的时候用最新版本不会有什么问题，比如 Shiro 现在的版本是 1.5.0 了，整体问题不大，大家自行尝试就好</p>
<h3 id="添加-Gradle-依赖管理"><a href="#添加-Gradle-依赖管理" class="headerlink" title="添加 Gradle 依赖管理"></a>添加 Gradle 依赖管理</h3><p><img src="http://image.winrains.cn/2019/10/20191025224019-68039.png" alt="img"></p>
<h3 id="大体目录结构"><a href="#大体目录结构" class="headerlink" title="大体目录结构"></a>大体目录结构</h3><p><img src="http://image.winrains.cn/2019/10/20191025224022-423fe.png" alt="img"></p>
<h3 id="application-yml-配置"><a href="#application-yml-配置" class="headerlink" title="application.yml 配置"></a>application.yml 配置</h3><p><img src="http://image.winrains.cn/2019/10/20191025224023-262fc.png" alt="img"></p>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p><img src="http://image.winrains.cn/2019/10/20191025224025-d9011.png" alt="img"></p>
<p>你就让我看这？这只是一个概览，先做到心中有数，我们来看具体配置，逐步完成搭建<br>其中 shiroFilter bean 部分指定了拦截路径和相应的过滤器，”/user/login”, ”/user”, ”/user/loginout” 可以匿名访问，其他路径都需要授权访问，shiro 提供和多个默认的过滤器，我们可以用这些过滤器来配置控制指定url的权限(先了解个大概即可)：</p>
<table>
<thead>
<tr>
<th>配置缩写</th>
<th>对应的过滤器</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>anon</td>
<td>AnonymousFilter</td>
<td>指定url可以匿名访问</td>
</tr>
<tr>
<td>authc</td>
<td>FormAuthenticationFilter</td>
<td>指定url需要form表单登录，默认会从请求中获取username、password,rememberMe等参数并尝试登录，如果登录不了就会跳转到loginUrl配置的路径。我们也可以用这个过滤器做默认的登录逻辑，但是一般都是我们自己在控制器写登录逻辑的，自己写的话出错返回的信息都可以定制嘛。</td>
</tr>
<tr>
<td>authcBasic</td>
<td>BasicHttpAuthenticationFilter</td>
<td>指定url需要basic登录</td>
</tr>
<tr>
<td>Logout</td>
<td>LogoutFilter</td>
<td>登出过滤器，配置指定url就可以实现退出功能，非常方便</td>
</tr>
<tr>
<td>noSessionCreation</td>
<td>NoSessionCreationFilter</td>
<td>禁止创建会话</td>
</tr>
<tr>
<td>perms</td>
<td>PermissionsAuthorizationFilter</td>
<td>需要指定权限才能访问</td>
</tr>
<tr>
<td>port</td>
<td>PortFilter</td>
<td>需要指定端口才能访问</td>
</tr>
<tr>
<td>rest</td>
<td>HttpMethodPermissionFilter</td>
<td>将http请求方法转化成相应的动词来构造一个权限字符串，这个感觉意义不大，有兴趣自己看源码的注释</td>
</tr>
<tr>
<td>roles</td>
<td>RolesAuthorizationFilter</td>
<td>需要指定角色才能访问</td>
</tr>
<tr>
<td>ssl</td>
<td>SslFilter</td>
<td>需要https请求才能访问</td>
</tr>
<tr>
<td>user</td>
<td>UserFilter</td>
<td>需要已登录或“记住我”的用户才能访问</td>
</tr>
</tbody></table>
<h3 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h3><p>数据库表设计请参考 entity package下的 bean，通过@Entity 注解与 JPA 的设置自动生成表结构 (你需要简单的了解一下 JPA 的功能)。<br>我们要说重点啦～～～</p>
<h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><p>身份认证是一个证明 “李雷是李雷，韩梅梅是韩梅梅” 的过程，回看上图，Realm 模块就是用来做这件事的，Shiro 提供了 IniRealm，JdbcReaml，LDAPReam等认证方式，但自定义的 Realm 通常是最适合我们业务需要的，认证通常是校验登录用户是否合法。</p>
<h3 id="新建用户-User"><a href="#新建用户-User" class="headerlink" title="新建用户 User"></a>新建用户 User</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Id</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@GeneratedValue</span>(strategy=GenerationType.AUTO)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Long id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(unique =true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String username;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">String</span> <span class="selector-tag">password</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">String</span> <span class="selector-tag">salt</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="定义-Repository"><a href="#定义-Repository" class="headerlink" title="定义 Repository"></a>定义 Repository</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">@Repository</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">UserRepository</span> <span class="symbol">extends</span> <span class="symbol">JpaRepository</span>&lt;<span class="symbol">User</span>, <span class="symbol">Long</span>&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> User findUserByUsername(String username);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="编写UserController："><a href="#编写UserController：" class="headerlink" title="编写UserController："></a>编写UserController：</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@<span class="constructor">GetMapping(<span class="string">"/login"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public void login(String username, String password) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UsernamePasswordToken token = <span class="keyword">new</span> <span class="constructor">UsernamePasswordToken(<span class="params">username</span>, <span class="params">password</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    token.set<span class="constructor">RememberMe(<span class="params">true</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Subject currentUser = <span class="module-access"><span class="module"><span class="identifier">SecurityUtils</span>.</span></span>get<span class="constructor">Subject()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    currentUser.login(token);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="自定义-Realm"><a href="#自定义-Realm" class="headerlink" title="自定义 Realm"></a>自定义 Realm</h3><p>自定义 Realm，主要是为了重写 doGetAuthenticationInfo(…)方法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">protected AuthenticationInfo <span class="keyword">do</span><span class="constructor">GetAuthenticationInfo(AuthenticationToken <span class="params">authenticationToken</span>)</span> throws AuthenticationException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    String username = token.get<span class="constructor">Username()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    User user = userRepository.find<span class="constructor">UserByUsername(<span class="params">username</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    SimpleAuthenticationInfo simpleAuthenticationInfo = <span class="keyword">new</span> <span class="constructor">SimpleAuthenticationInfo(<span class="params">user</span>, <span class="params">user</span>.<span class="params">getPassword</span>()</span>, get<span class="constructor">Name()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    simpleAuthenticationInfo.set<span class="constructor">CredentialsSalt(ByteSource.Util.<span class="params">bytes</span>(<span class="params">user</span>.<span class="params">getSalt</span>()</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return simpleAuthenticationInfo;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这些代码我需要做一个说明，你可能也满肚子疑惑:</p>
<ol>
<li>这段代码怎么应用了 shiro？</li>
<li>controller 是怎么调用到 custom realm 的？</li>
<li>重写的 doGetAuthenticationInfo(…) 方法目的是什么？</li>
</ol>
<h3 id="认证流程说明"><a href="#认证流程说明" class="headerlink" title="认证流程说明"></a>认证流程说明</h3><p>用户访问<code>/user/login</code> 路径，生成 UsernamePasswordToken, 通过SecurityUtils.getSubject()获取Subject（currentUser），调用 login 方法进行验证，让我们跟踪一下代码，瞧一瞧就知道自定义的CustomRealm怎样起作用的，一起来看源码：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829192228-5bb11.png" alt="img"></p>
<p>到这里我们要停一停了，请回看 Shiro 近景图，将源码追踪路径与其对比，是完全一致的</p>
<h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>身份认证是验证你是谁的问题，而授权是你能干什么的问题，</p>
<blockquote>
<p>产品经理：申购模块只能科室看 程序员：好的 产品经理：科长权限大一些，他也能看申购模块 程序员：好的(黑脸) 产品经理：科长不但能看，还能修改数据 程序员：关公提大刀，拿命来 …</p>
</blockquote>
<p>作为程序员，我们的宗旨是：「能动手就不吵吵」; 硝烟怒火拔地起，耳边响起驼铃声（Shiro）：「放下屠刀，立地成佛」授权没有那么麻烦，大家好商量…<br>整个过程和身份认证基本是一毛一样，你对比看看</p>
<h3 id="角色实体创建"><a href="#角色实体创建" class="headerlink" title="角色实体创建"></a>角色实体创建</h3><p>涉及到授权，自然要和角色相关，所以我们创建 Role 实体:</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class Role &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Id</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@GeneratedValue</span>(strategy=GenerationType.AUTO)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Long id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(unique =true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String roleCode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">String</span> <span class="selector-tag">roleName</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="新建-Role-Repository"><a href="#新建-Role-Repository" class="headerlink" title="新建 Role Repository"></a>新建 Role Repository</h3><figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">@Repository</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RoleRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Role</span>, <span class="title">Long</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Query(value = <span class="string">"select roleId from UserRoleRel ur where ur.userId = ?1"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">List</span>&lt;<span class="keyword">Long</span>&gt; findUserRole(<span class="keyword">Long</span> userId);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">List</span>&lt;Role&gt; findByIdIn(<span class="keyword">List</span>&lt;<span class="keyword">Long</span>&gt; ids);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="定义权限实体-Permission"><a href="#定义权限实体-Permission" class="headerlink" title="定义权限实体 Permission"></a>定义权限实体 Permission</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class Permission &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Id</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@GeneratedValue</span>(strategy=GenerationType.AUTO)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Long id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(unique =true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String permCode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">String</span> <span class="selector-tag">permName</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="定义-Permission-Repository"><a href="#定义-Permission-Repository" class="headerlink" title="定义 Permission Repository"></a>定义 Permission Repository</h3><figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">@Repository</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PermissionRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Permission</span>, <span class="title">Long</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Query(value = <span class="string">"select permId from RolePermRel pr where pr.roleId in ?1"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">List</span>&lt;<span class="keyword">Long</span>&gt; findRolePerm(<span class="keyword">List</span>&lt;<span class="keyword">Long</span>&gt; roleIds);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">List</span>&lt;Permission&gt; findByIdIn(<span class="keyword">List</span>&lt;<span class="keyword">Long</span>&gt; ids);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="建立用户与角色关系"><a href="#建立用户与角色关系" class="headerlink" title="建立用户与角色关系"></a>建立用户与角色关系</h3><p>其实可以通过 JPA 注解来制定关系的，这里为了说明问题，以单独外键形式说明</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class UserRoleRel &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Id</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@GeneratedValue</span>(strategy=GenerationType.AUTO)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Long id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">Long</span> <span class="selector-tag">userId</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">Long</span> <span class="selector-tag">roleId</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="建立角色与权限关系"><a href="#建立角色与权限关系" class="headerlink" title="建立角色与权限关系"></a>建立角色与权限关系</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class RolePermRel &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Id</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@GeneratedValue</span>(strategy=GenerationType.AUTO)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Long id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">Long</span> <span class="selector-tag">permId</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">Long</span> <span class="selector-tag">roleId</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="编写-UserController"><a href="#编写-UserController" class="headerlink" title="编写 UserController"></a>编写 UserController</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequiresPermissions</span>(<span class="string">"user:list:view"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">getAllUsers</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;User&gt; users = userRepository.findAll();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>@RequiresPermissions(&quot;user:list:view&quot;)</code> 注解说明具有用户：列表：查看权限的才可以访问），官网明确给出权限定义格式，包括通配符等，我希望你自行去查看<br>自定义 CustomRealm (主要重写 doGetAuthorizationInfo) 方法:</p>
<p><img src="http://image.winrains.cn/2019/10/20191025224030-8db56.png" alt="img"></p>
<p>与认证流程如出一辙，只不过多了用户，角色，权限的关系罢了</p>
<h3 id="授权流程说明"><a href="#授权流程说明" class="headerlink" title="授权流程说明"></a>授权流程说明</h3><p>这里通过过滤器（见Shiro配置）和注解二者结合的方式来进行授权，和认证流程一样，最终会走到我们自定义的 CustomRealm 中，同样 Shiro 默认提供了许多注解用来处理不同的授权情况</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>@RequiresGuest</td>
<td>只有游客可以访问</td>
</tr>
<tr>
<td>@RequiresAuthentication</td>
<td>需要登录才能访问</td>
</tr>
<tr>
<td>@RequiresUser</td>
<td>已登录的用户或“记住我”的用户能访问</td>
</tr>
<tr>
<td>@RequiresRoles</td>
<td>已登录的用户需具有指定的角色才能访问</td>
</tr>
<tr>
<td>@RequiresPermissions</td>
<td>已登录的用户需具有指定的权限才能访问（如果不想和产品经理华山论剑，推荐用这个注解）</td>
</tr>
</tbody></table>
<p>授权官网给出明确的授权策略与案例，请查看：<a href="https://link.juejin.im?target=http%3A%2F%2Fshiro.apache.org%2Fpermissions.html">shiro.apache.org/permissions…</a><br>上面的例子我们通过一直在通过访问 Mysql 获取用户认证和授权信息，这中方式明显不符合生产环境的需求</p>
<h2 id="Session会话管理"><a href="#Session会话管理" class="headerlink" title="Session会话管理"></a>Session会话管理</h2><p>做过 Web 开发的同学都知道 Session 的概念，最常用的是 Session 过期时间，数据在 Session 的 CRUD，同样看上图，我们需要关注 SessionManager 和 SessionDAO 模块，Shiro starter 已经提供了基本的 Session配置信息，我们按需在YAML中配置就好（官网<a href="https://shiro.apache.org/spring-boot.html" target="_blank" rel="noopener">https://shiro.apache.org/spring-boot.html</a> 已经明确给出Session的配置信息）</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Default Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>shiro.enabled</td>
<td>true</td>
<td>Enables Shiro’s Spring module</td>
</tr>
<tr>
<td>shiro.web.enabled</td>
<td>true</td>
<td>Enables Shiro’s Spring web module</td>
</tr>
<tr>
<td>shiro.annotations.enabled</td>
<td>true</td>
<td>Enables Spring support for Shiro’s annotations</td>
</tr>
<tr>
<td>shiro.sessionManager.deleteInvalidSessions</td>
<td>true</td>
<td>Remove invalid session from session storage</td>
</tr>
<tr>
<td>shiro.sessionManager.sessionIdCookieEnabled</td>
<td>true</td>
<td>Enable session ID to cookie, for session tracking</td>
</tr>
<tr>
<td>shiro.sessionManager.sessionIdUrlRewritingEnabled</td>
<td>true</td>
<td>Enable session URL rewriting support</td>
</tr>
<tr>
<td>shiro.userNativeSessionManager</td>
<td>false</td>
<td>If enabled Shiro will manage the HTTP sessions instead of the container</td>
</tr>
<tr>
<td>shiro.sessionManager.cookie.name</td>
<td>JSESSIONID</td>
<td>Session cookie name</td>
</tr>
<tr>
<td>shiro.sessionManager.cookie.maxAge</td>
<td>-1</td>
<td>Session cookie max age</td>
</tr>
<tr>
<td>shiro.sessionManager.cookie.domain</td>
<td>null</td>
<td>Session cookie domain</td>
</tr>
<tr>
<td>shiro.sessionManager.cookie.path</td>
<td>null</td>
<td>Session cookie path</td>
</tr>
<tr>
<td>shiro.sessionManager.cookie.secure</td>
<td>false</td>
<td>Session cookie secure flag</td>
</tr>
<tr>
<td>shiro.rememberMeManager.cookie.name</td>
<td>rememberMe</td>
<td>RememberMe cookie name</td>
</tr>
<tr>
<td>shiro.rememberMeManager.cookie.maxAge</td>
<td>one year</td>
<td>RememberMe cookie max age</td>
</tr>
<tr>
<td>shiro.rememberMeManager.cookie.domain</td>
<td>null</td>
<td>RememberMe cookie domain</td>
</tr>
<tr>
<td>shiro.rememberMeManager.cookie.path</td>
<td>null</td>
<td>RememberMe cookie path</td>
</tr>
<tr>
<td>shiro.rememberMeManager.cookie.secure</td>
<td>false</td>
<td>RememberMe cookie secure flag</td>
</tr>
<tr>
<td>shiro.loginUrl</td>
<td>/login.jsp</td>
<td>Login URL used when unauthenticated users are redirected to login page</td>
</tr>
<tr>
<td>shiro.successUrl</td>
<td>/</td>
<td>Default landing page after a user logs in (if alternative cannot be found in the current session)</td>
</tr>
<tr>
<td>shiro.unauthorizedUrl</td>
<td>null</td>
<td>Page to redirect user to if they are unauthorized (403 page)</td>
</tr>
</tbody></table>
<p>分布式服务中，我们通常需要将Session信息放入Redis中来管理，来应对高并发的访问需求，这时只需重写SessionDAO即可完成自定义的Session管理</p>
<h3 id="整合Redis"><a href="#整合Redis" class="headerlink" title="整合Redis"></a>整合Redis</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> RedisConnectionFactory redisConnectionFactory;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;<span class="keyword">String</span>, Object&gt; stringObjectRedisTemplate() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        RedisTemplate&lt;<span class="keyword">String</span>, Object&gt; <span class="keyword">template</span> = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span>.setConnectionFactory(redisConnectionFactory);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span>.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span>.setValueSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">template</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="重写SessionDao"><a href="#重写SessionDao" class="headerlink" title="重写SessionDao"></a>重写SessionDao</h3><p><img src="http://image.winrains.cn/2019/10/20191025224031-5691e.png" alt="img"></p>
<p>查看源码，可以看到调用默认SessionManager的retriveSession方法，我们重写该方法，将Session放入HttpRequest中，进一步提高session访问效率</p>
<p><img src="http://image.winrains.cn/2019/10/20191025224035-220fc.png" alt="img"></p>
<h3 id="向ShiroConfig中添加配置"><a href="#向ShiroConfig中添加配置" class="headerlink" title="向ShiroConfig中添加配置"></a>向ShiroConfig中添加配置</h3><p>其实在概览模块已经给出代码展示，这里单独列出来做说明:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 自定义RedisSessionDao用来管理Session在Redis中的CRUD</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * @return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">Bean(<span class="params">name</span> = <span class="string">"redisSessionDao"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public RedisSessionDao redis<span class="constructor">SessionDao()</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return <span class="keyword">new</span> <span class="constructor">RedisSessionDao()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 自定义SessionManager,应用自定义SessionDao</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * @return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">Bean(<span class="params">name</span> = <span class="string">"customerSessionManager"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public CustomerWebSessionManager customer<span class="constructor">WebSessionManager()</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    CustomerWebSessionManager customerWebSessionManager = <span class="keyword">new</span> <span class="constructor">CustomerWebSessionManager()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    customerWebSessionManager.set<span class="constructor">SessionDAO(<span class="params">redisSessionDao</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return customerWebSessionManager;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 定义Security manager</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * @param customRealm</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * @return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">Bean(<span class="params">name</span> = <span class="string">"securityManager"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public DefaultWebSecurityManager default<span class="constructor">WebSecurityManager(CustomRealm <span class="params">customRealm</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    DefaultWebSecurityManager  securityManager = <span class="keyword">new</span> DefaultWebSecurityManager <span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    securityManager.set<span class="constructor">Realm(<span class="params">customRealm</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    securityManager.set<span class="constructor">SessionManager(<span class="params">customerWebSessionManager</span>()</span>); <span class="comment">// 可不指定，Shiro会用默认Session manager</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    securityManager.set<span class="constructor">CacheManager(<span class="params">redisCacheManagers</span>()</span>);  <span class="comment">//可不指定，Shiro会用默认CacheManager</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//        securityManager.setSessionManager(defaultWebSessionManager());</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    return securityManager;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 定义session管理器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * @return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">Bean(<span class="params">name</span> = <span class="string">"sessionManager"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public DefaultWebSessionManager default<span class="constructor">WebSessionManager()</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    DefaultWebSessionManager defaultWebSessionManager = <span class="keyword">new</span> <span class="constructor">DefaultWebSessionManager()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    defaultWebSessionManager.set<span class="constructor">SessionDAO(<span class="params">redisSessionDao</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return defaultWebSessionManager;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>至此，将 session 信息由 redis 管理功能就这样完成了</p>
<h2 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h2><p>应对分布式服务，对于高并发访问数据库权限内容是非常低效的方式，同样我们可以利用Redis来解决这一问题，将授权数据缓存到Redis中</p>
<h3 id="新建-RedisCache"><a href="#新建-RedisCache" class="headerlink" title="新建 RedisCache"></a>新建 RedisCache</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Cache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SHIRO_PREFIX = <span class="string">"shiro-cache:"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Resource</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; stringObjectRedisTemplate;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getKey</span><span class="params">(K key)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (key <span class="keyword">instanceof</span> String)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> (SHIRO_PREFIX + key);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> key.toString();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        log.info(<span class="string">"read from redis..."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        V v = (V) stringObjectRedisTemplate.opsForValue().get(getKey(k));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K k, V v)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        stringObjectRedisTemplate.opsForValue().set(getKey(k), v);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        stringObjectRedisTemplate.expire(getKey(k), <span class="number">100</span>, TimeUnit.SECONDS);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K k)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        V v = (V) stringObjectRedisTemplate.opsForValue().get(getKey(k));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        stringObjectRedisTemplate.delete((String) get(k));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> <span class="keyword">throws</span> CacheException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//不要重写，如果只保存shiro数据无所谓</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="新建-RedisCacheManager"><a href="#新建-RedisCacheManager" class="headerlink" title="新建 RedisCacheManager"></a>新建 RedisCacheManager</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheManager</span> <span class="keyword">implements</span> <span class="title">CacheManager</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Resource</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> &lt;K, V&gt; <span class="function">Cache&lt;K, V&gt; <span class="title">getCache</span><span class="params">(String s)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> redisCache;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>至此，我们不用每次访问 Mysql DB 来获取认证和授权信息，而是通过 Redis 来缓存这些信息，大大提升了效率，也满足分布式系统的设计需求</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回复公众号 「demo」获取 demo 代码。这里只是梳理了Springboot整合Shiro的流程，以及应用Redis最大化利用Shiro，Shiro的使用细节还很多，官网说的也很明确，带着上面的架构图来理解Shiro会事半功倍，感觉这里面的代码挺多挺头大的？那是你没有自己动手去尝试，结合官网与 demo 相信你会对 Shiro 有更好的理解，另外你可以理解 Shiro 是 mini 版本的 Spring Security，我希望以小见大，当需要更细粒度的认证授权时，也会对理解 Spring Security 有很大帮助，点击文末「阅读原文」，效果更好<br>落霞与孤鹜齐飞 秋水共长天一色，产品经理和程序员一片祥和…</p>
<h2 id="灵魂追问"><a href="#灵魂追问" class="headerlink" title="灵魂追问"></a>灵魂追问</h2><ol>
<li>都说 Redis 是单线程，但是很快，你知道为什么吗？</li>
<li>你们项目中是怎样控制认证授权的呢？当授权有变化，对于程序员来说，这个修改是灾难吗？</li>
</ol>
<blockquote>
<p>作者：日拱一兵</p>
<p>来源：<a href="https://juejin.im/post/5d4b7425e51d4561bb33fafd" target="_blank" rel="noopener">https://juejin.im/post/5d4b7425e51d4561bb33fafd</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
        <category>Shiro</category>
      </categories>
  </entry>
  <entry>
    <title>如何设计好的RESTful API</title>
    <url>/2019/12/26/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%A5%BD%E7%9A%84RESTful-API/</url>
    <content><![CDATA[<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>现阶段的开发模式多以前后端分离形式存在，前后端开发人员需要通过大量 API 来进行数据交互，如果在交互过程中前后端人员经常遭遇如下问题：</p>
<ul>
<li>前端人员不能快速理解接口字段含义及接口字段变化</li>
<li>后端人员想复用某些接口，但是不能快速从接口 URL 的定义中明确该接口的含义，需要进一步读代码确认</li>
<li>URL中的英文单词使用五花八门，搜索某个接口不知道具体的关键字</li>
<li>请求方法动词如 POST GET 随意使用</li>
<li>完成当前业务接口对接，前端人员经常会询问下一步业务流程的接口定义在哪里，对接形式是什么样的</li>
</ul>
<a id="more"></a>

<p>以上只是前后端人员通过接口交互的一小部分问题，这些问题就好比”牙痛”，不致命，但是在整个软件开发的生命周期内，天天”牙痛”是很要命的, 需要解决上述的问题，需要前后端人员都能认识与了解接口设计规范的重要性。</p>
<h2 id="什么是REST"><a href="#什么是REST" class="headerlink" title="什么是REST"></a>什么是REST</h2><p>在 2000 年，Roy Fielding 提出 Representational State Transfer (REST) 的概念，中文翻译过来”表述性状态传递”，感兴趣的朋友可以去维基百科看看原始概念，乍一看是一个挺抽象的概念，但其实，这个概念就像交通灯规则一样简单，就看如何看待相关规范. 当我们谈及 RESTful 设计规范，多数人能了解设计的大原则，但是不了解小细节，而对这些细节的了解与否，是能否治好”牙痛病”的关键</p>
<h2 id="REST术语介绍"><a href="#REST术语介绍" class="headerlink" title="REST术语介绍"></a>REST术语介绍</h2><p>现实世界交通灯有红绿黄，REST相关的概念也是三个：资源，集合，URL</p>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>资源是某种东西的对象或表示，它具有一些与之相关的数据，并且可以有一组方法对其进行操作。 例如, 动物，学校和员工是资源; 删除，添加，更新是对这些资源执行的相关操作</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合是资源集合，例如，公司是公司资源的集合</p>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>URL（统一资源定位符）是可以通过其定位资源的路径，并且可以对其执行某些操作<br>了解到以上内容， 那REST 世界的”交通灯”规则是什么样的？我们来了解一下</p>
<h2 id="如何设计和开发一个高可用的-REST-APIs"><a href="#如何设计和开发一个高可用的-REST-APIs" class="headerlink" title="如何设计和开发一个高可用的 REST APIs"></a>如何设计和开发一个高可用的 REST APIs</h2><blockquote>
<p>网上一直有关于”最好的Restful API的设计”争论，何为最好，至今没有一个官方的指导。本文总结 RESTful 的设计细节，介绍如何设计出易于理解和使用的 API。在 Restful API 设计标准之上，我们可以为我们的设计增加一些弹性（团队都认可的方式），每个项目的情况不同，最重要的是项目组成员达成一致的Restful API 设计规则，达到高可用即可</p>
</blockquote>
<h3 id="URL-设计"><a href="#URL-设计" class="headerlink" title="URL 设计"></a>URL 设计</h3><p>学英语，名词（car/animal/teacher）都很好记忆，但是如何用动词和这些名词组合来准确的表达特定的含义却很困难，庆幸的是在 REST 的世界，动词寥寥无几，并且含义单一 ，RESTful 的核心思想也是通过这些<strong>动词 + 名词</strong>完成对资源的操作与访问，但我们经常看到这样的动词与名词的 URL 组合：</p>
<ul>
<li>/getAllUsers</li>
<li>/createNewCompany</li>
<li>/updateUserInfo</li>
<li>/deleteUser?name=zhangsan</li>
</ul>
<p>这些 URL 的设计会导致文章开头所说的很多问题，我们进一步来了解如何应用所谓的<strong>动词 + 名词</strong></p>
<h4 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h4><p>动词通常就是 5 种 HTTP 方法，对应我们常见的 CRUD 操作：</p>
<ul>
<li>POST：新建（Create）</li>
<li>GET：读取（Read）</li>
<li>PUT：更新（Update）</li>
<li>PATCH：更新（Update），通常不分更新，也很少用到</li>
<li>DELETE：删除（Delete）</li>
</ul>
<p>根据 HTTP 规范，动词一律大写，另外根据RESTful 幂等性（多次调用是否会对资源产生影响）原则，我们不能乱用动词，GET/PUT/DELETE 是幂等的，POST/PATCH 不是幂等的<br>有些客户端只能使用 <code>GET</code>和 <code>POST</code>这两种方法。服务器必须接受 <code>POST</code>模拟其他三个方法（ <code>PUT</code>、 <code>PATCH</code>、 <code>DELETE</code>）。<br>这时，客户端发出的 HTTP 请求，要加上 <code>X-HTTP-Method-Override</code>属性，告诉服务器应该使用哪一个动词，覆盖 <code>POST</code>方法。</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">POST /users/<span class="number">12</span> HTTP/<span class="number">1.1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">X-HTTP-<span class="function"><span class="keyword">Method</span>-<span class="title">Override</span>:</span> PUT</span></pre></td></tr></table></figure>

<p>上面代码中， <code>X-HTTP-Method-Override</code>指定本次请求的方法是 <code>PUT</code>，而不是 <code>POST</code></p>
<h4 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h4><p>名词就是表示一个资源或者服务，如 /users，/teachers，这里看到我用名词复数的形式描述某一资源，至于用单数还是复数每个人都有自己的见解，我在这里推荐使用复数，因为在现实世界中，资源多数是以集合的形式存在的</p>
<h4 id="动词-名词"><a href="#动词-名词" class="headerlink" title="动词 + 名词"></a>动词 + 名词</h4><p><img src="http://image.winrains.cn/2019/08/20190829193552-61f08.jpeg" alt="http://image.winrains.cn/2019/08/20190829193552-61f08.jpeg"></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">POST /users</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /users</span></pre></td></tr><tr><td class="code"><pre><span class="line">PUT /users</span></pre></td></tr><tr><td class="code"><pre><span class="line">DELETE /users</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /users/12</span></pre></td></tr><tr><td class="code"><pre><span class="line">PUT /users/12</span></pre></td></tr><tr><td class="code"><pre><span class="line">DELETE /users/12</span></pre></td></tr></table></figure>

<p>上述<strong>动词 + 名词</strong>的组合是不是清晰多了，没有杂乱的动词在 URL 中，大家的理解含义相同</p>
<h4 id="URL-层级"><a href="#URL-层级" class="headerlink" title="URL 层级"></a>URL 层级</h4><p>现实中哪有这么简单的 CRUD，资源的相互关联与嵌套很常见，查找 id 是 12 的用户的所有帖子， 如何设计这个 URL，下面两种设计也会有争论：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /users/12/posts</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /posts?<span class="attribute">userId</span>=12</span></pre></td></tr></table></figure>

<p>第一种出现两个名词主题（users/posts），会让人有几秒钟的猜想，这到底请求的是用户资源还是帖子资源，当存在更深浅套的时候也不容易扩展，所以我推荐第二种方式，主体名词 posts 资源明显，其他过滤条件也更容易扩展，比如 /posts?userName=zhangsan，我们可以复用同样的接口</p>
<h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>我们看到过很多如下 URL 设计，用来区分 API 版本：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">POST /v2/users</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /V1/users/12</span></pre></td></tr></table></figure>

<p>我们都指向同样的资源 users，URL 中为什么要加版本号呢？ 针对这个问题，答案依旧没有统一标准，如果多个版本的API版本返回数据结果结构一样，那没必要区分版本，如果结构已经发生变化，而且要向下兼容，那版本号是很好的区分方式，而且通过 URL 加版本的方式可以更好的发现资源</p>
<h4 id="过滤-分页-排序"><a href="#过滤-分页-排序" class="headerlink" title="过滤/分页/排序"></a>过滤/分页/排序</h4><p>实际的业务场景中会经常对请求资源做条件筛选，分页显示，以及排序，我们不要为这些业务要求创建不同步的 API，我们应该尽量保持 URL 的信息简单，只需添加查询条件参数来实现上述功能，同时符合”望 URL 知意”的原则</p>
<h5 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h5><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /users/12/posts?<span class="attribute">state</span>=published</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /users/12/posts?<span class="attribute">published</span>=<span class="literal">true</span></span></pre></td></tr></table></figure>

<p>上述两种方式都可以实现资源的过滤</p>
<h5 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h5><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /users?<span class="attribute">pageNo</span>=1&amp;pageSize=20</span></pre></td></tr></table></figure>

<p>以分页方式查询用户列表，显示第 2 页内容，每页显示 20 条信息</p>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /users?<span class="attribute">sort</span>=score_desc</span></pre></td></tr></table></figure>

<p>按照学生分数降序进行排序<br>上述所有的方式我们都可以做到”望 URL 知意”，这就是好的设计</p>
<h3 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h3><p>RESTful API 的返回结果也是设计环节中重要的一环</p>
<h4 id="响应数据格式"><a href="#响应数据格式" class="headerlink" title="响应数据格式"></a>响应数据格式</h4><p>API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的 <code>Content-Type</code>属性要设为 <code>application/json</code>。同时客户端也应作出相应的配合，客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的 <code>ACCEPT</code>属性也要设成 <code>application/json</code>，多渠道调用可能会存在相同资源需要有不同的 producer 类型的情况存在</p>
<h4 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h4><p>很多后端开发人员可能受开发框架所限，或者返回数据封装形式不够好，经常会给前端人员不是很友好的 HTTP 状态码，比如 response 有 error，却给出 <code>200HTTP.OK</code> 的状态码 (明明吃了三碗粉，却给两碗粉的钱)</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span></pre></td></tr><tr><td class="code"><pre><span class="line">Content-<span class="keyword">Type</span>: application/<span class="type">json</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    "status": "-1",</span></pre></td></tr><tr><td class="code"><pre><span class="line">    "result": &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        "error": "分数应小于150"</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>有人说，我已经标记返回内容 status 是 -1（表示failure）, 用 200 作为状态码也无妨吧？这是一个很错误的观念，RESTful 的设计理念之一是简单直观，试想一下，前端开发人员打开开发者工具，所有请求都是200的状态码，但是页面数据就是没有显示出来，难道前端开发人员还要每个接口调用点开看一看，是哪个 status 是 -1 导致的吗？ 很显然我们不希望这样的情况发生，正确的做法应该类似这样的：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">400</span> Bad Request</span></pre></td></tr><tr><td class="code"><pre><span class="line">Content-<span class="keyword">Type</span>: application/<span class="type">json</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    "status": "-1",</span></pre></td></tr><tr><td class="code"><pre><span class="line">    "result": &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        "error": "分数应小于150"</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>下面页列举出来常用的状态码以及表示的含义：</p>
<h5 id="2xx-状态码"><a href="#2xx-状态码" class="headerlink" title="2xx 状态码"></a>2xx 状态码</h5><p>200表示成功，同时我们可以表示的更加精确</p>
<blockquote>
<ul>
<li><code>GET:200OK</code> 请求成功</li>
<li><code>POST:201Created</code> 创建成功</li>
<li><code>PUT:200OK</code> 更新成功</li>
<li><code>DELETE:204NoContent</code> 找不到要删除的内容</li>
</ul>
</blockquote>
<p>使用状态码 202 有时候会比 使用状态啊吗 201 是更好的选择，状态码 202 的意思是：服务端已接收到了请求，但是还没有创建任何资源，但结果一切正常。 比如：</p>
<blockquote>
<ul>
<li>异步操作：服务器已接收到请求，但是还未处理，但是会在未来处理</li>
<li>资源已经存在，没有创建新的资源 （有些业务可能会返回错误信息”您创建的数据已存在”，所以这种情景没有明确的规定，符合自己的业务需求即可）</li>
</ul>
</blockquote>
<h5 id="4xx-状态码"><a href="#4xx-状态码" class="headerlink" title="4xx 状态码"></a>4xx 状态码</h5><p>4xx 状态码表示客户端的错误，主要有以下几种：</p>
<blockquote>
<ul>
<li><code>400BadRequest</code>：服务器不理解客户端的请求，未做任何处理</li>
<li><code>401Unauthorized</code>：用户未提供身份验证凭据，或者没有通过身份验证</li>
<li><code>403Forbidden</code>：用户通过了身份验证，但是不具有访问资源所需的权限</li>
<li><code>404NotFound</code>：所请求的资源不存在，或不可用</li>
<li><code>415UnsupportedMediaType</code>：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式</li>
</ul>
</blockquote>
<p>这里要注意状态码 401 和 403 的区别</p>
<h5 id="5xx-状态码"><a href="#5xx-状态码" class="headerlink" title="5xx 状态码"></a>5xx 状态码</h5><p>5xx 状态码表示服务端错误，通常只会用到两个：</p>
<blockquote>
<ul>
<li><code>500InternalServerError</code>：客户端请求有效，服务器处理时发生了意外</li>
<li><code>503ServiceUnavailable</code>：服务器无法处理请求，一般用于网站维护状态</li>
</ul>
</blockquote>
<h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>过去开发人员通常会将活动的用户信息存储在服务端的 session 中， 这种形式很显然不适用于现在分布式微服务架构的模式，我们可以使用 JWT (JSON Web Token) 如 OAuth2 来实现，这样每次在 Httpheader 中添加 token 来做验证即可</p>
<h4 id="API-文档"><a href="#API-文档" class="headerlink" title="API 文档"></a>API 文档</h4><p>Swagger是一种广泛使用的工具来用来记录与呈现 REST API，它提供了一种探索特定 API 使用的方法，因此允许开发人员理解底层的语义行为。 这是一种使用注释添加文档的声明性方法，它进一步生成描述 API 及其用法的 JSON，可以实时应对 API 的更新，具体请参考 Swagger 官网 , 同时使用 Spring Boot 的小伙伴也可以很轻松的集成 Swagger，只需引入Swagger Starter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spring4all<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure>

<h4 id="HATEOAS"><a href="#HATEOAS" class="headerlink" title="HATEOAS"></a>HATEOAS</h4><p>HATEOAS (Hypermedia As Transfer Engine Of Application State), API 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做 HATEOAS , 举个例子，列表页数据通常会有查看操作，这样我们在返回列表页的数据的时候同样返回如何操作查看具体数据详情的 API 接口：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">"status"</span>: <span class="string">"-1"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">"result"</span>: [&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">"id"</span>: <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">"name"</span>: <span class="string">"zhangsan"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">"links"</span>:[</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="attr">"href"</span>: <span class="string">"http://localhost:8080/user/&#123;id&#125;"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用 Spring 框架的小伙伴可以快速的体验一下这种方式，Spring 官网项目 Spring HATEOAS , 会快速的将参数都做替换, 将查看 API URL 中的 id 直接替换成 1。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">"status"</span>: <span class="string">"-1"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">"result"</span>: [&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">"id"</span>: <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">"name"</span>: <span class="string">"zhangsan"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">"links"</span>:[</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="attr">"href"</span>: <span class="string">"http://localhost:8080/user/1"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="提升效率工具"><a href="#提升效率工具" class="headerlink" title="提升效率工具"></a>提升效率工具</h2><h3 id="RestfulToolkit"><a href="#RestfulToolkit" class="headerlink" title="RestfulToolkit"></a>RestfulToolkit</h3><p>后端开发人员可以安装 IntellJ idea 插件 RestfulToolkit, Mac 环境使用快捷键 <code>CMD+\</code> 输入关键字快速定位到 API 位置<br><img src="http://image.winrains.cn/2019/08/20190829193553-5ae2b.jpeg" alt="http://image.winrains.cn/2019/08/20190829193553-5ae2b.jpeg"><br>同时在右侧工具栏打开 API，会自动生成 demoData 请求参数，实现快速调用测试：<br><img src="http://image.winrains.cn/2019/08/20190829193553-64b76.png" alt="http://image.winrains.cn/2019/08/20190829193553-64b76.png"><br>JSON-Viewer<br>JSON-Viewer 是 Chrome 浏览器的插件，用于快速解析及格式化 json 内容，在 Chrome omnibox（多功能输入框）输入 <code>json-viewer+TAB</code> ，将 json 内容拷贝进去，然后输入回车键，将看到结构清晰的 json 数据，同时可以自定义主题<br><img src="http://image.winrains.cn/2019/08/20190829193553-d6f5d.jpeg" alt="http://image.winrains.cn/2019/08/20190829193553-d6f5d.jpeg"><br>另外，前端人员打开开发者工具，双击请求链接，会自动将 response 中的 json 数据解析出来，非常方便</p>
<h3 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h3><p>Postman 功能十分强大， 搜索 <code>Postman自定义环境变量</code>，会打开新世界的大门</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>如何设计出最好的 RESTful API 永远不会有结论，设计出高可用，团队认可，简单清晰明了的 RESTful API 就是好的。</p>
<blockquote>
<p>作者：日拱一兵</p>
<p>来源：<a href="https://mp.weixin.qq.com/s/hR1TqkVzwZ_T8fuMnsM4hQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/hR1TqkVzwZ_T8fuMnsM4hQ</a></p>
</blockquote>
]]></content>
      <categories>
        <category>其它技术</category>
        <category>Restful</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL锁机制</title>
    <url>/2019/12/26/MySQL%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="一、锁的类型"><a href="#一、锁的类型" class="headerlink" title="一、锁的类型"></a>一、锁的类型</h2><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><ul>
<li>共享锁（S Lock）允许事务读一行数据</li>
<li>排它锁 （X Lock） 允许事务读一行数据</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829194616-b39aa.jpeg" alt="img"></p>
<a id="more"></a>

<h3 id="表锁-意向锁"><a href="#表锁-意向锁" class="headerlink" title="表锁(意向锁)"></a>表锁(意向锁)</h3><p>锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式</p>
<ul>
<li>意向共享锁（IS Lock）事务想要获得一张表中某几行的共享锁</li>
<li>意向排他锁（IX Lock）事务想要获得一张表中某几行的排他锁</li>
</ul>
<p>由于InnoDB存储引擎支持的是行级别的锁，因此意向锁其实不会阻塞除全表扫以外的任何请求。故表级意向锁与行级锁的兼容性如下所示</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194616-95e79.jpeg" alt="img"></p>
<p><img src="http://image.winrains.cn/2019/08/20190829194616-bdd47.jpeg" alt="img"></p>
<p>若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。例上图，如果需要对页上的记录r进行上X锁，那么分别需要对数据库A、表、页上意向锁IX，最后对记录r上X锁。若其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成。举例来说，在对记录r加X锁之前，已经有事务对表1进行了S表锁，那么表1上已存在S锁，之后事务需要对记录r在表1上加上IX，由于不兼容，所以该事务需要等待表锁操作的完成。</p>
<h3 id="意向锁到底有什么作用？"><a href="#意向锁到底有什么作用？" class="headerlink" title="意向锁到底有什么作用？"></a>意向锁到底有什么作用？</h3><p>innodb的意向锁主要用户多粒度的锁并存的情况。比如事务A要在一个表上加S锁，如果表中的一行已被事务B加了X锁，那么该锁的申请也应被阻塞。如果表中的数据很多，逐行检查锁标志的开销将很大，系统的性能将会受到影响。为了解决这个问题，可以在表级上引入新的锁类型来表示其所属行的加锁情况，这就引出了“意向锁”的概念。<br>举个例子，如果表中记录1亿，事务A把其中有几条记录上了行锁了，这时事务B需要给这个表加表级锁，如果没有意向锁的话，那就要去表中查找这一亿条记录是否上锁了。如果存在意向锁，那么假如事务Ａ在更新一条记录之前，先加意向锁，再加Ｘ锁，事务B先检查该表上是否存在意向锁，存在的意向锁是否与自己准备加的锁冲突，如果有冲突，则等待直到事务Ａ释放，而无须逐条记录去检测。事务Ｂ更新表时，其实无须知道到底哪一行被锁了，它只要知道反正有一行被锁了就行了。<br><strong>主要作用是处理行锁和表锁之间的矛盾，能够显示“某个事务正在某一行上持有了锁，或者准备去持有锁”</strong></p>
<h2 id="二、锁的算法"><a href="#二、锁的算法" class="headerlink" title="二、锁的算法"></a>二、锁的算法</h2><ul>
<li>Record Lock：单个行记录上的锁</li>
<li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身</li>
<li>Next-Key Lock∶Gap Lock+Record Lock，锁定一个范围、索引之间的间隙，并且锁定记录本身；目的是为了防止幻读</li>
</ul>
<h2 id="三、mysql如何做到读写并行（多版本控制）？"><a href="#三、mysql如何做到读写并行（多版本控制）？" class="headerlink" title="三、mysql如何做到读写并行（多版本控制）？"></a>三、mysql如何做到读写并行（多版本控制）？</h2><p>多版本并发控制 MVCC，是行级锁的一个变种，通过保存数据在某个时间节点的快照(snapshot)，类似实现了行级锁。由此不同事务对同一表，同一时刻看到的数据可能是不一样的。 实现上通过在不同的数据行后增加创建日期版本号和删除日期版本号，且版本号不断递增，进而实现了数据快照</p>
<h3 id="读的类型"><a href="#读的类型" class="headerlink" title="读的类型"></a>读的类型</h3><ul>
<li>一致性非锁定读（快照读）<ul>
<li>在事务隔离级别提交读（RC）和可重复读（RR）下，InnoDB存储引擎使用非锁定的一致性读<ul>
<li>RC模式下，读取最新的快照</li>
<li>RR模式下，读取事务开始时的快照</li>
</ul>
</li>
</ul>
</li>
<li>一致性锁定读 （当前读）<ul>
<li>隔离级别为未提交读(RN）时读取都是当前读</li>
<li>SELECT…FOR UPDATE （加写锁）</li>
<li>SELECT…LOCK IN SHARE MODE （加读锁）</li>
</ul>
</li>
</ul>
<h2 id="四、加锁处理分析"><a href="#四、加锁处理分析" class="headerlink" title="四、加锁处理分析"></a>四、加锁处理分析</h2><p>下面两条简单的SQL，他们加什么锁？<br><strong>select * from t1 where id = 10</strong><br><strong>delete from t1 where id = 10</strong><br>如果要分析加锁情况，必须还要知道以下的一些前提，前提不同，加锁处理的方式也不同</p>
<ul>
<li><strong>前提一</strong>:id列是不是主键？</li>
<li><strong>前提二</strong>:当前系统的隔离级别是什么？</li>
<li><strong>前提三</strong>:id列如果不是主键，那么id列上有索引吗？</li>
<li><strong>前提四</strong>:id列上如果有二级索引，那么这个索引是唯一索引吗？</li>
<li><strong>前提五</strong>:两个SQL的执行计划是什么？索引扫描？全表扫描？</li>
</ul>
<p>根据上述情况，有以下几种组合</p>
<ul>
<li><strong>组合一</strong>:id列是主键，RC隔离级别</li>
<li><strong>组合二</strong>:id列是二级唯一索引，RC隔离级别</li>
<li><strong>组合三</strong>:id列是二级非唯一索引，RC隔离级别</li>
<li><strong>组合四</strong>:id列上没有索引，RC隔离级别</li>
<li><strong>组合五</strong>:id列是主键，RR隔离级别</li>
<li><strong>组合六</strong>:id列是二级唯一索引，RR隔离级别</li>
<li><strong>组合七</strong>:id列是二级非唯一索引，RR隔离级别</li>
<li><strong>组合八</strong>:id列上没有索引，RR隔离级别</li>
<li><strong>组合九</strong>:Serializable隔离级别</li>
</ul>
<p>排列组合还没有列举完全，但是看起来，已经很多了。真的有必要这么复杂吗？事实上，要分析加锁，就是需要这么复杂。但是从另一个角度来说，只要你选定了一种组合，SQL需要加哪些锁，其实也就确定了。接下来挑几个比较经典的组合</p>
<h3 id="组合一：id主键-RC"><a href="#组合一：id主键-RC" class="headerlink" title="组合一：id主键+RC"></a>组合一：id主键+RC</h3><p>这个组合，是最简单，最容易分析的组合。id是主键，Read Committed隔离级别，给定SQL：delete from t1 where id = 10; 只需要将主键上，id = 10的记录加上X锁即可。如下图所示：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194616-d6aa4.jpeg" alt="img"></p>
<p><strong>结论：id是主键时，此SQL只需要在id=10这条记录上加X锁即可。</strong></p>
<h3 id="组合二：id唯一索引-RC"><a href="#组合二：id唯一索引-RC" class="headerlink" title="组合二：id唯一索引+RC"></a>组合二：id唯一索引+RC</h3><p>这个组合，id不是主键，而是一个Unique的二级索引键值。那么在RC隔离级别下，delete from t1 where id = 10; 需要加什么锁呢？见下图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194617-c3318.jpeg" alt="img"></p>
<p>此组合中，id是unique索引，而主键是name列。此时，加锁的情况由于组合一有所不同。由于id是unique索引，因此delete语句会选择走id列的索引进行where条件的过滤，在找到id=10的记录后，首先会将unique索引上的id=10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name = ‘d’ 对应的主键索引项加X锁。为什么聚簇索引上的记录也要加锁？试想一下，如果并发的一个SQL，是通过主键索引来更新：update t1 set id = 100 where name = ‘d’; 此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新/删除需要串行执行的约束。<br><strong>结论：若id列是unique列，其上有unique索引。那么SQL需要加两个X锁，一个对应于id unique索引上的id = 10的记录，另一把锁对应于聚簇索引上的[name=’d’,id=10]的记录。</strong></p>
<h3 id="组合三：id非唯一索引-RC"><a href="#组合三：id非唯一索引-RC" class="headerlink" title="组合三：id非唯一索引+RC"></a>组合三：id非唯一索引+RC</h3><p><strong>相对于组合一、二，组合三又发生了变化，隔离级别仍旧是RC不变，但是id列上的约束又降低了，id列不再唯一，只有一个普通的索引。假设delete from t1 where id = 10; 语句，仍旧选择id列上的索引进行过滤where条件，那么此时会持有哪些锁？同样见下图：</strong></p>
<p><img src="http://image.winrains.cn/2019/08/20190829194617-bf55f.jpeg" alt="img"></p>
<p>根据此图，可以看到，首先，id列索引上，满足id = 10查询条件的记录，均已加锁。同时，这些记录对应的主键索引上的记录也都加上了锁。与组合二唯一的区别在于，组合二最多只有一个满足等值查询的记录，而组合三会将所有满足查询条件的记录都加锁。<br><strong>结论：若id列上有非唯一索引，那么对应的所有满足SQL查询条件的记录，都会被加锁。同时，这些记录在主键索引上的记录，也会被加锁。</strong></p>
<h3 id="组合四：id无索引-RC"><a href="#组合四：id无索引-RC" class="headerlink" title="组合四：id无索引+RC"></a>组合四：id无索引+RC</h3><p><strong>相对于前面三个组合，这是一个比较特殊的情况。id列上没有索引，where id = 10;这个过滤条件，没法通过索引进行过滤，那么只能走全表扫描做过滤。对应于这个组合，SQL会加什么锁？或者是换句话说，全表扫描时，会加什么锁？这个答案也有很多：有人说会在表上加X锁；有人说会将聚簇索引上，选择出来的id = 10;的记录加上X锁。那么实际情况呢？请看下图：</strong></p>
<p><img src="http://image.winrains.cn/2019/08/20190829194617-e2541.jpeg" alt="img"></p>
<p>由于id列上没有索引，因此只能走聚簇索引，进行全部扫描。从图中可以看到，满足删除条件的记录有两条，但是，聚簇索引上所有的记录，都被加上了X锁。无论记录是否满足条件，全部被加上X锁。既不是加表锁，也不是在满足条件的记录上加行锁。<br>有人可能会问？为什么不是只在满足条件的记录上加锁呢？这是由于MySQL的实现决定的。如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由MySQL Server层进行过滤。因此也就把所有的记录，都锁上了。<br>注：在实际的实现中，MySQL有一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁 (违背了2PL的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。<br><strong>结论：若id列上没有索引，SQL会走聚簇索引的全扫描进行过滤，由于过滤是由MySQL Server层面进行的。因此每条记录，无论是否满足条件，都会被加上X锁。但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁/放锁动作不会省略。同时，优化也违背了2PL的约束。</strong></p>
<h3 id="组合五：id主键-RR"><a href="#组合五：id主键-RR" class="headerlink" title="组合五：id主键+RR"></a>组合五：id主键+RR</h3><p>上面的四个组合，都是在Read Committed隔离级别下的加锁行为，接下来的四个组合，是在Repeatable Read隔离级别下的加锁行为。<br>组合五，id列是主键列，Repeatable Read隔离级别，针对delete from t1 where id = 10; 这条SQL，加锁与组合一：[<a href="https://link.juejin.im?target=http%3A%2F%2Fhedengcheng.com%2F%3Fp%3D771%23_%E7%BB%84%E5%90%88%E4%B8%80%EF%BC%9Aid%E4%B8%BB%E9%94%AE%2BRC">id主键，Read Committed</a>]一致。</p>
<h3 id="组合六：id唯一索引-RR"><a href="#组合六：id唯一索引-RR" class="headerlink" title="组合六：id唯一索引+RR"></a>组合六：id唯一索引+RR</h3><p><strong>与组合五类似，组合六的加锁，与组合二：[id唯一索引，Read Committed]一致。两个X锁，id唯一索引满足条件的记录上一个，对应的聚簇索引上的记录一个。</strong></p>
<h3 id="组合七：id非唯一索引-RR"><a href="#组合七：id非唯一索引-RR" class="headerlink" title="组合七：id非唯一索引+RR"></a>组合七：id非唯一索引+RR</h3><p>还记得前面提到的MySQL的四种隔离级别的区别吗？RC隔离级别允许幻读，而RR隔离级别，不允许存在幻读。但是在组合五、组合六中，加锁行为又是与RC下的加锁行为完全一致。那么RR隔离级别下，<br>组合七，Repeatable Read隔离级别，id上有一个非唯一索引，执行delete from t1 where id = 10; 假设选择id列上的索引进行条件过滤，最后的加锁行为，是怎么样的呢？同样看下面这幅图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194617-a6c84.jpeg" alt="img"></p>
<p>此图，相对于组合三：[<a href="https://link.juejin.im?target=http%3A%2F%2Fhedengcheng.com%2F%3Fp%3D771%23_%E7%BB%84%E5%90%88%E4%B8%89%EF%BC%9Aid%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%2BRC">id列上非唯一锁，Read Committed</a>]看似相同，其实却有很大的区别。最大的区别在于，这幅图中多了一个GAP锁，而且GAP锁看起来也不是加在记录上的，倒像是加载两条记录之间的位置，GAP锁有何用？<br>其实这个多出来的GAP锁，就是RR隔离级别，相对于RC隔离级别，不会出现幻读的关键。确实，GAP锁锁住的位置，也不是记录本身，而是两条记录之间的GAP。<br>如何保证两次当前读返回一致的记录，那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交。为了实现这个功能，GAP锁应运而生。<br>如图中所示，有哪些位置可以插入新的满足条件的项 (id = 10)，考虑到B+树索引的有序性，满足条件的项一定是连续存放的。记录[6,c]之前，不会插入id=10的记录；[6,c]与[10,b]间可以插入[10, aa]；[10,b]与[10,d]间，可以插入新的[10,bb],[10,c]等；[10,d]与[11,f]间可以插入满足条件的[10,e],[10,z]等；而[11,f]之后也不会插入满足条件的记录。因此，为了保证[6,c]与[10,b]间，[10,b]与[10,d]间，[10,d]与[11,f]不会插入新的满足条件的记录，MySQL选择了用GAP锁，将这三个GAP给锁起来。<br>Insert操作，如insert [10,aa]，首先会定位到[6,c]与[10,b]间，然后在插入前，会检查这个GAP是否已经被锁上，如果被锁上，则Insert不能插入记录。因此，通过第一遍的当前读，不仅将满足条件的记录锁上 (X锁)，与组合三类似。同时还是增加3把GAP锁，将可能插入满足条件记录的3个GAP给锁上，保证后续的Insert不能插入新的id=10的记录，也就杜绝了同一事务的第二次当前读，出现幻象的情况。<br>有心的朋友看到这儿，可以会问：既然防止幻读，需要靠GAP锁的保护，为什么组合五、组合六，也是RR隔离级别，却不需要加GAP锁呢？<br>首先，这是一个好问题。其次，回答这个问题，也很简单。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。而组合五，id是主键；组合六，id是unique键，都能够保证唯一性。一个等值查询，最多只能返回一条记录，而且新的相同取值的记录，一定不会在新插入进来，因此也就避免了GAP锁的使用。其实，针对此问题，还有一个更深入的问题：如果组合五、组合六下，针对SQL：select * from t1 where id = 10 for update; 第一次查询，没有找到满足查询条件的记录，那么GAP锁是否还能够省略？此问题留给大家思考。<br><strong>结论：Repeatable Read隔离级别下，id列上有一个非唯一索引，对应SQL：delete from t1 where id = 10; 首先，通过id索引定位到第一条满足查询条件的记录，加记录上的X锁，加GAP上的GAP锁，然后加主键聚簇索引上的记录X锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录X锁，但是仍旧需要加GAP锁，最后返回结束。</strong><br><strong>什么时候会取得gap lock或nextkey lock 这和隔离级别有关,只在REPEATABLE READ或以上的隔离级别下的特定操作才会取得gap lock或nextkey lock。</strong></p>
<h3 id="组合八：id无索引-RR"><a href="#组合八：id无索引-RR" class="headerlink" title="组合八：id无索引+RR"></a>组合八：id无索引+RR</h3><p>组合八，Repeatable Read隔离级别下的最后一种情况，id列上没有索引。此时SQL：delete from t1 where id = 10; 没有其他的路径可以选择，只能进行全表扫描。最终的加锁情况，如下图所示：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194618-de6cf.jpeg" alt="img"></p>
<p>如图，这是一个很恐怖的现象。首先，聚簇索引上的所有记录，都被加上了X锁。其次，聚簇索引每条记录间的间隙(GAP)，也同时被加上了GAP锁。这个示例表，只有6条记录，一共需要6个记录锁，7个GAP锁。试想，如果表上有1000万条记录呢？<br>在这种情况下，这个表上，除了不加锁的快照度，其他任何加锁的并发SQL，均不能执行，不能更新，不能删除，不能插入，全表被锁死。<br>当然，跟组合四：[<a href="https://link.juejin.im?target=http%3A%2F%2Fhedengcheng.com%2F%3Fp%3D771%23_%E7%BB%84%E5%90%88%E5%9B%9B%EF%BC%9Aid%E6%97%A0%E7%B4%A2%E5%BC%95%2BRC">id无索引, Read Committed</a>]类似，这个情况下，MySQL也做了一些优化，就是所谓的semi-consistent read。semi-consistent read开启的情况下，对于不满足查询条件的记录，MySQL会提前放锁。针对上面的这个用例，就是除了记录[d,10]，[g,10]之外，所有的记录锁都会被释放，同时不加GAP锁。semi-consistent read如何触发：要么是read committed隔离级别；要么是Repeatable Read隔离级别，同时设置了<a href="https://link.juejin.im?target=http%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.5%2Fen%2Finnodb-parameters.html">innodb_locks_unsafe_for_binlog</a> 参数。更详细的关于semi-consistent read的介绍，可参考我之前的一篇博客：<a href="https://link.juejin.im?target=http%3A%2F%2Fhedengcheng.com%2F%3Fp%3D220">MySQL+InnoDB semi-consitent read原理及实现分析</a> 。<br><strong>结论：在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新/删除/插入 操作。当然，也可以通过触发semi-consistent read，来缓解加锁开销与并发影响，但是semi-consistent read本身也会带来其他问题，不建议使用。</strong></p>
<h3 id="组合九：Serializable"><a href="#组合九：Serializable" class="headerlink" title="组合九：Serializable"></a>组合九：Serializable</h3><p>针对前面提到的简单的SQL，最后一个情况：Serializable隔离级别。对于SQL2：delete from t1 where id = 10; 来说，Serializable隔离级别与Repeatable Read隔离级别完全一致，因此不做介绍。<br>Serializable隔离级别，影响的是SQL1：select * from t1 where id = 10; 这条SQL，在RC，RR隔离级别下，都是快照读，不加锁。但是在Serializable隔离级别，SQL1会加读锁，也就是说快照读不复存在，MVCC并发控制降级为Lock-Based CC。<br><strong>结论：在MySQL/InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读。</strong></p>
<h2 id="五、死锁案例"><a href="#五、死锁案例" class="headerlink" title="五、死锁案例"></a>五、死锁案例</h2><h3 id="1-不同表相同记录行锁冲突"><a href="#1-不同表相同记录行锁冲突" class="headerlink" title="1. 不同表相同记录行锁冲突"></a>1. 不同表相同记录行锁冲突</h3><p>这种情况很好理解，事务A和事务B操作两张表，但出现循环等待锁情况。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194618-5c095.png" alt="img"></p>
<h3 id="2-相同表记录行锁冲突"><a href="#2-相同表记录行锁冲突" class="headerlink" title="2. 相同表记录行锁冲突"></a>2. 相同表记录行锁冲突</h3><p>这种情况比较常见，之前遇到两个job在执行数据批量更新时，jobA处理的的id列表为[1,2,3,4]，而job处理的id列表为[8,9,10,4,2]，这样就造成了死锁。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194618-a8e69.png" alt="img"></p>
<h3 id="3-不同索引锁冲突"><a href="#3-不同索引锁冲突" class="headerlink" title="3. 不同索引锁冲突"></a>3. 不同索引锁冲突</h3><p>这种情况比较隐晦，事务A在执行时，除了在二级索引加锁外，还会在聚簇索引上加锁，在聚簇索引上加锁的顺序是[1,4,2,3,5]，而事务B执行时，只在聚簇索引上加锁，加锁顺序是[1,2,3,4,5]，这样就造成了死锁的可能性。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194619-b0144.png" alt="img"></p>
<h3 id="4-gap锁冲突"><a href="#4-gap锁冲突" class="headerlink" title="4. gap锁冲突"></a>4. gap锁冲突</h3><p>innodb在RR级别下，如下的情况也会产生死锁，比较隐晦。不清楚的同学可以自行根据上节的gap锁原理分析下。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194619-5e115.png" alt="img"></p>
<h2 id="六、如何尽可能避免死锁"><a href="#六、如何尽可能避免死锁" class="headerlink" title="六、如何尽可能避免死锁"></a>六、如何尽可能避免死锁</h2><ol>
<li>以固定的顺序访问表和行。比如对第2节两个job批量更新的情形，简单方法是对id列表先排序，后执行，这样就避免了交叉等待锁的情形；又比如对于3.1节的情形，将两个事务的sql顺序调整为一致，也能避免死锁。</li>
<li>大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。</li>
<li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。</li>
<li>降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。</li>
<li>为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。=</li>
</ol>
<h2 id="七、如何查看锁"><a href="#七、如何查看锁" class="headerlink" title="七、如何查看锁"></a>七、如何查看锁</h2><p>从InnoDB1.0开始，在INFORMATION_SCHEMA架构下添加了表INNODB_TRX、INNODB_LOCKS、INNODB_LOCK_WAITS。（详情见附录）通过这三张表，用户可以更简单地监控当前事务并分析可能存在的锁问题。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#全局分析系统上中行锁的争夺情况</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'innodb_row_lock%'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#查看事务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.INNODB_TRX;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#查看锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.INNODB_LOCKS;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#查看锁等待情况</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.INNODB_LOCK_WAITS;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#通过联合查询可以比较直观的查看哪个事务阻塞了哪个事务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> r.trx_id              <span class="string">'等待事务ID'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       r.trx_mysql_thread_id <span class="string">'等待线程ID'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       r.trx_query           <span class="string">'等待事务运行语句'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       b.trx_id              <span class="string">'阻塞事务ID'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       b.trx_mysql_thread_id <span class="string">'阻塞线程ID'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       b.trx_query           <span class="string">'阻塞事务运行语句'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> information_schema.innodb_lock_waits w</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">INNER</span> <span class="keyword">JOIN</span> information_schema.innodb_trx b</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">ON</span> b.trx_id = w.blocking_trx_id</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">INNER</span> <span class="keyword">JOIN</span> information_schema.innodb_trx r</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">ON</span> r.trx_id = w.requesting_trx_id;</span></pre></td></tr></table></figure>

<h2 id="八、mysql是如何预防死锁的？"><a href="#八、mysql是如何预防死锁的？" class="headerlink" title="八、mysql是如何预防死锁的？"></a>八、mysql是如何预防死锁的？</h2><h3 id="innodb-lock-wait-timeout-等待锁超时回滚事务"><a href="#innodb-lock-wait-timeout-等待锁超时回滚事务" class="headerlink" title="innodb_lock_wait_timeout 等待锁超时回滚事务"></a>innodb_lock_wait_timeout 等待锁超时回滚事务</h3><p>直观方法是在两个事务相互等待时，当一个等待时间超过设置的某一阀值时，对其中一个事务进行回滚，另一个事务就能继续执行。</p>
<h3 id="wait-for-graph算法来主动进行死锁检测"><a href="#wait-for-graph算法来主动进行死锁检测" class="headerlink" title="wait-for graph算法来主动进行死锁检测"></a>wait-for graph算法来主动进行死锁检测</h3><p>每当加锁请求无法立即满足需要并进入等待时，wait-for graph算法都会被触发。<br>wait-for graph要求数据库保存以下两种信息：</p>
<ul>
<li>锁的信息链表</li>
<li>事务等待链表</li>
</ul>
<p>通过上述链表可以构造出一张图，而在这个图中若存在回路，就代表存在死锁，因此资源间相互发生等待。在wait-for graph中，事务为图中的节点。而在图中，事务T1指向T2边的定义为：</p>
<ul>
<li>事务T1等待事务T2所占用的资源</li>
<li>事务T1最终等待T2所占用的资源，也就是事务之间在等待相同的资源，而事务T1发生在事务T2的后面</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829194619-3a057.jpeg" alt="img"></p>
<p>示例事务状态和锁的信息<br>在Transaction Wait Lists中可以看到共有4个事务t1、t2、t3、t4，故在wait-for graph中应有4个节点。而事务t2对row1占用x锁，事务t1对row2占用s锁。事务t1需要等待事务t2中row1的资源，因此在wait-for graph中有条边从节点t1指向节点t2。事务t2需要等待事务t1、t4所占用的row2对象，故而存在节点t2到节点t1、t4的边。同样，存在节点t3到节点t1、t2、t4的边，因此最终的wait-for graph如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194619-bc75d.jpeg" alt="img"></p>
<p>ps:若存在则有死锁，通常来说InnoDB存储引擎选择回滚undo量最小的事务并从新开始</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="INNODB-ROW-LOCK"><a href="#INNODB-ROW-LOCK" class="headerlink" title="INNODB_ROW_LOCK"></a>INNODB_ROW_LOCK</h3><table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>innodb_row_lock_current_waits</td>
<td>当前正在等待锁定的数量</td>
</tr>
<tr>
<td><strong>innodb_row_lock_time</strong></td>
<td>从系统启动到现在锁定总时间长度</td>
</tr>
<tr>
<td><strong>innodb_row_lock_time_avg</strong></td>
<td>每次等待所花平均时间</td>
</tr>
<tr>
<td>innodb_row_lock_time_max</td>
<td>从系统启动到现在等待最常的一次所花的时间</td>
</tr>
<tr>
<td><strong>innodb_row_lock_waits</strong></td>
<td>系统启动后到现在总共等待的次数；直接决定优化的方向和策略</td>
</tr>
</tbody></table>
<h3 id="INNODB-TRX"><a href="#INNODB-TRX" class="headerlink" title="INNODB_TRX"></a>INNODB_TRX</h3><p>提供有关当前正在内部执行的每个事务的信息 InnoDB，包括事务是否在等待锁定，事务何时启动以及事务正在执行的SQL语句（如果有）。详见<a href="https://link.juejin.im?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Finnodb-trx-table.html">dev.mysql.com/doc/refman/…</a></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>TRX_ID</strong></td>
<td><a href="https://link.juejin.im?target=http%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Finnodb-performance-ro-txn.html">事务Id</a></td>
</tr>
<tr>
<td><strong>TRX_WEIGHT</strong></td>
<td>事务的权重，反映（但不一定是确切的计数）更改的行数和事务锁定的行数。要解决死锁，请 InnoDB``选择权重最小的事务作为回滚的“ 受害者 ”。无论更改和锁定行的数量如何，已更改非事务表的事务都被认为比其他事务更重。</td>
</tr>
<tr>
<td><strong>TRX_STATE</strong></td>
<td>事务执行状态。允许值是 RUNNING<code>，LOCK WAIT</code>， ROLLING BACK<code>，和 COMMITTING</code>。</td>
</tr>
<tr>
<td>TRX_STARTED</td>
<td>交易开始时间。</td>
</tr>
<tr>
<td><strong>TRX_REQUESTED_LOCK_ID</strong></td>
<td>事务当前正在等待的锁的ID，如果TRX_STATE<code>是LOCK WAIT</code>; 否则NULL``。</td>
</tr>
<tr>
<td><strong>TRX_WAIT_STARTED</strong></td>
<td>交易开始等待锁定的时间，如果 TRX_STATE<code>是LOCK WAIT</code>; 否则NULL``。</td>
</tr>
<tr>
<td><strong>TRX_MYSQL_THREAD_ID</strong></td>
<td>MySQL线程ID，与show processlist中的ID值相对应</td>
</tr>
<tr>
<td><strong>TRX_QUERY</strong></td>
<td>事务正在执行的SQL语句</td>
</tr>
<tr>
<td>TRX_OPERATION_STATE</td>
<td>交易的当前操作，如果有的话; 否则 NULL``。</td>
</tr>
<tr>
<td>TRX_TABLES_IN_USE</td>
<td>InnoDB``处理此事务的当前SQL语句时使用 的表数。</td>
</tr>
<tr>
<td>TRX_TABLES_LOCKED</td>
<td>InnoDB``当前SQL语句具有行锁定 的表的数量。（因为这些是行锁，而不是表锁，所以通常仍可以通过多个事务读取和写入表，尽管某些行被锁定。）</td>
</tr>
<tr>
<td>TRX_LOCK_STRUCTS</td>
<td>事务保留的锁数。</td>
</tr>
<tr>
<td>TRX_LOCK_MEMORY_BYTES</td>
<td>内存中此事务的锁结构占用的总大小</td>
</tr>
<tr>
<td>TRX_ROWS_LOCKED</td>
<td>此交易锁定的大致数字或行数。该值可能包括实际存在但对事务不可见的删除标记行</td>
</tr>
<tr>
<td>TRX_ROWS_MODIFIED</td>
<td>此事务中已修改和插入的行数。</td>
</tr>
<tr>
<td>TRX_CONCURRENCY_TICKETS</td>
<td>一个值，指示当前事务在被换出之前可以执行多少工作</td>
</tr>
<tr>
<td>TRX_ISOLATION_LEVEL</td>
<td>当前事务的隔离级别。</td>
</tr>
<tr>
<td>TRX_UNIQUE_CHECKS</td>
<td>是否为当前事务打开或关闭唯一检查。例如，在批量数据加载期间可能会关闭它们</td>
</tr>
<tr>
<td>TRX_FOREIGN_KEY_CHECKS</td>
<td>是否为当前事务打开或关闭外键检查。例如，在批量数据加载期间可能会关闭它们</td>
</tr>
<tr>
<td>TRX_LAST_FOREIGN_KEY_ERROR</td>
<td>最后一个外键错误的详细错误消息（如果有）; 否则NULL``</td>
</tr>
<tr>
<td>TRX_ADAPTIVE_HASH_LATCHED</td>
<td>自适应哈希索引是否被当前事务锁定。当自适应哈希索引搜索系统被分区时，单个事务不会锁定整个自适应哈希索引。自适应哈希索引分区由<a href="https://link.juejin.im?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Finnodb-parameters.html%23sysvar_innodb_adaptive_hash_index_parts">innodb_adaptive_hash_index_parts``</a>，默认设置为8。</td>
</tr>
<tr>
<td>TRX_ADAPTIVE_HASH_TIMEOUT</td>
<td>是否立即为自适应哈希索引放弃搜索锁存器，或者在MySQL的调用之间保留它。当没有自适应哈希索引争用时，该值保持为零，语句保留锁存器直到它们完成。在争用期间，它倒计时到零，并且语句在每次行查找后立即释放锁存器。当自适应散列索引搜索系统被分区（受控制 <a href="https://link.juejin.im?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Finnodb-parameters.html%23sysvar_innodb_adaptive_hash_index_parts">innodb_adaptive_hash_index_parts``</a>）时，该值保持为0。</td>
</tr>
<tr>
<td>TRX_IS_READ_ONLY</td>
<td>值为1表示事务是只读的。</td>
</tr>
<tr>
<td>TRX_AUTOCOMMIT_NON_LOCKING</td>
<td>值为1表示事务是 <a href="https://link.juejin.im?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Fserver-system-variables.html%23sysvar_autocommit">SELECT<code>](https://dev.mysql.com/doc/refman/5.7/en/select.html)不使用FOR UPDATE</code>or或 LOCK IN SHARED MODE<code>子句的语句，并且正在执行， [autocommit</code></a>因此事务将仅包含此一个语句。当此列和TRX_IS_READ_ONLY<code>都为1时，InnoDB</code>优化事务以减少与更改表数据的事务关联的开销</td>
</tr>
</tbody></table>
<h3 id="INNODB-LOCKS"><a href="#INNODB-LOCKS" class="headerlink" title="INNODB_LOCKS"></a>INNODB_LOCKS</h3><p>提供有关InnoDB 事务已请求但尚未获取的每个锁的信息，以及事务持有的阻止另一个事务的每个锁。详见<a href="https://link.juejin.im?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Finnodb-locks-table.html">dev.mysql.com/doc/refman/…</a></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>LOCK_ID</td>
<td>一个唯一的锁ID号，内部为 InnoDB``。</td>
</tr>
<tr>
<td>LOCK_TRX_ID</td>
<td>持有锁的交易的ID</td>
</tr>
<tr>
<td>LOCK_MODE</td>
<td>如何请求锁定。允许锁定模式描述符 S<code>，X</code>， IS<code>，IX</code>， GAP<code>，AUTO_INC</code>，和 UNKNOWN``。锁定模式描述符可以组合使用以识别特定的锁定模式。</td>
</tr>
<tr>
<td>LOCK_TYPE</td>
<td>锁的类型</td>
</tr>
<tr>
<td>LOCK_TABLE</td>
<td>已锁定或包含锁定记录的表的名称</td>
</tr>
<tr>
<td>LOCK_INDEX</td>
<td>索引的名称，如果LOCK_TYPE是 RECORD; 否则NULL</td>
</tr>
<tr>
<td>LOCK_SPACE</td>
<td>锁定记录的表空间ID，如果 LOCK_TYPE<code>是RECORD</code>; 否则NULL``</td>
</tr>
<tr>
<td>LOCK_PAGE</td>
<td>锁定记录的页码，如果 LOCK_TYPE<code>是RECORD</code>; 否则NULL``。</td>
</tr>
<tr>
<td>LOCK_REC</td>
<td>页面内锁定记录的堆号，如果 LOCK_TYPE<code>是RECORD</code>; 否则NULL``。</td>
</tr>
<tr>
<td>LOCK_DATA</td>
<td>与锁相关的数据（如果有）。如果 LOCK_TYPE<code>是RECORD</code>，是锁定的记录的主键值，否则NULL<code>。此列包含锁定行中主键列的值，格式为有效的SQL字符串。如果没有主键，LOCK_DATA</code>则是唯一的InnoDB<code>内部行ID号。如果对键值或范围高于索引中的最大值的间隙锁定，则LOCK_DATA</code> 报告<em>supremum</em> <em>pseudo-record</em>。当包含锁定记录的页面不在缓冲池中时（如果在保持锁定时将其分页到磁盘），InnoDB<code>不从磁盘获取页面，以避免不必要的磁盘操作。相反， LOCK_DATA</code>设置为 NULL``。</td>
</tr>
</tbody></table>
<h3 id="INNODB-LOCK-WAITS"><a href="#INNODB-LOCK-WAITS" class="headerlink" title="INNODB_LOCK_WAITS"></a>INNODB_LOCK_WAITS</h3><p>包含每个被阻止InnoDB 事务的一个或多个行，指示它已请求的锁以及阻止该请求的任何锁。详见<a href="https://link.juejin.im?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Finnodb-lock-waits-table.html">dev.mysql.com/doc/refman/…</a></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>REQUESTING_TRX_ID</td>
<td>请求（阻止）事务的ID。</td>
</tr>
<tr>
<td>REQUESTED_LOCK_ID</td>
<td>事务正在等待的锁的ID。</td>
</tr>
<tr>
<td>BLOCKING_TRX_ID</td>
<td>阻止事务的ID。</td>
</tr>
<tr>
<td>BLOCKING_LOCK_ID</td>
<td>由阻止另一个事务继续进行的事务所持有的锁的ID</td>
</tr>
</tbody></table>
<h2 id="引用文献"><a href="#引用文献" class="headerlink" title="引用文献"></a>引用文献</h2><p>《MySQL技术内幕：InnoDB存储引擎》<br><a href="https://link.juejin.im?target=http%3A%2F%2Fhedengcheng.com%2F%3Fp%3D771">何登成MySQL 加锁处理分析</a><br><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fcrazylqy%2Fp%2F7611069.html">Mysql加锁过程详解</a><br><a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fyuyinghua0302%2Farticle%2Fdetails%2F82318408">数据库事务和锁（三）</a><br><a href="https://juejin.im/post/5d04b33e6fb9a07ee1692653#heading-7" target="_blank" rel="noopener">针对MySQL死锁问题的思路分析</a></p>
<blockquote>
<p>作者：白山丶</p>
<p>来源：<a href="https://juejin.im/post/5d3e8b63f265da1bce3e1988" target="_blank" rel="noopener">https://juejin.im/post/5d3e8b63f265da1bce3e1988</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>git操作（13）：remote</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%8813%EF%BC%89%EF%BC%9Aremote/</url>
    <content><![CDATA[<p>git是分布式版本管理工具，它没有中央仓库。但多人协作时，我们依然需要一个集散地，让协作成员之间统一往集散地推送和拉取更新。否则，点对点的沟通，效率会很低。<br>所以就引出了git中远端仓库的概念。</p>
<a id="more"></a>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>我们之前所有的操作都是在本地仓库完成的，和本地仓库对应的是远端仓库。那么本地有若干分支，远端仓库是不是也有对应的若干分支呢？<br>当然。<br>我们探讨一个问题，在离线状态下，git是不是无从知道远端仓库的任何状态？<br>我让网络下线，查询从github克隆下来的本地仓库的状态，结果它告诉我本地仓库的master分支是<code>up to date with &#39;origin/master&#39;</code>。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Your branch <span class="keyword">is</span> up <span class="keyword">to</span> <span class="type">date</span> <span class="keyword">with</span> <span class="string">'origin/master'</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">nothing</span> <span class="keyword">to</span> <span class="keyword">commit</span>, working tree clean</span></pre></td></tr></table></figure>

<p>实际上，git的分支有三种：</p>
<ul>
<li>本地分支，我们可以通过``写法访问它。</li>
<li>远端分支，我们可以通过``写法访问它。</li>
<li>远端分支引用，我们可以通过``写法访问它。实际上它也是本地分支，只不过我们无法操作它，只有git的网络操作才可以更新它。离线状态下，git给的状态就是本地分支和远端分支引用的比较结果。</li>
</ul>
<blockquote>
<p>git官方把我所说的<code>远端分支引用</code>称为<code>远端分支</code>。知道谁是谁就行了，名字不重要🤔<br>我是马蹄疾</p>
</blockquote>
<p>我们看一下本地的远端分支引用。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">.git/</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git<span class="meta-keyword">/refs/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">.git<span class="meta-keyword">/refs/</span>remotes/</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git<span class="meta-keyword">/refs/</span>remotes<span class="meta-keyword">/origin/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">.git<span class="meta-keyword">/refs/</span>remotes<span class="meta-keyword">/origin/</span>HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git<span class="meta-keyword">/refs/</span>remotes<span class="meta-keyword">/origin/</span>master</span></pre></td></tr></table></figure>

<p>默认的远端仓库名就叫<code>origin</code>。它也有master分支指针，也有HEAD指针。</p>
<h2 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h2><p>如果远端仓库有新的提交或者新的分支，我们需要运行<code>git fetch</code>命令来拉取更新。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git fetch</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Enumerating objects: <span class="number">5</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Counting objects: <span class="number">100</span>% (<span class="number">5</span>/<span class="number">5</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>), pack-reused <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Unpacking objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">From github.com:veedrin/git</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">3893459.</span><span class="number">.0f</span>80eeb  master     -&gt; origin/master</span></pre></td></tr></table></figure>

<p>这个命令是<code>git fetch origin</code>的缩写。因为<code>origin</code>是远端仓库的默认名称，所以可以省略。如果有手动添加的远端仓库，那就必须指定远端仓库的名称了。<br>这个命令做了什么呢？<br>它会把新的提交和新的分支拉取到本地，然后更新本地的远端分支引用到最新的提交。<br><code>git fetch</code>仅仅是将远端的更新拉取下来，同步本地的远端分支引用，不会对本地分支有任何影响。我们需要手动执行合并操作才能更新本地分支。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">merge</span> origin/<span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Your branch <span class="keyword">is</span> up <span class="keyword">to</span> <span class="built_in">date</span> <span class="keyword">with</span> <span class="string">'origin/master'</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">nothing</span> <span class="keyword">to</span> <span class="keyword">commit</span>, working tree clean</span></pre></td></tr></table></figure>

<p>当然，有一个更简单的操作。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git pull</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Enumerating objects: <span class="number">5</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Counting objects: <span class="number">100</span>% (<span class="number">5</span>/<span class="number">5</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Unpacking objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>), pack-reused <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">From github.com:veedrin/git</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">4f</span>bd1d4..d9785d7  master     -&gt; origin/master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Updating <span class="number">4f</span>bd1d4..d9785d7</span></pre></td></tr><tr><td class="code"><pre><span class="line">Fast-forward</span></pre></td></tr><tr><td class="code"><pre><span class="line"> README.md | <span class="number">2</span> ++</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">2</span> insertions(+)</span></pre></td></tr></table></figure>

<p><code>git pull</code>就是<code>git fetch</code>和<code>git merge</code>的一键操作。</p>
<h2 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h2><p>推送到远端的命令是<code>git push</code>。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Counting objects: <span class="number">3</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="number">261</span> bytes | <span class="number">261.00</span> KiB/s, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">To github.com:veedrin/git.git</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">3</span>eaa1ae.<span class="number">.2</span>bd3c9d  master -&gt; master</span></pre></td></tr></table></figure>

<p>如果当前分支对远端分支设置了追踪的话，也可以省略分支名。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git push</span></pre></td></tr><tr><td class="code"><pre><span class="line">Counting objects: <span class="number">3</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="number">261</span> bytes | <span class="number">261.00</span> KiB/s, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">To github.com:veedrin/git.git</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">3</span>eaa1ae.<span class="number">.2</span>bd3c9d  master -&gt; master</span></pre></td></tr></table></figure>

<p>有时候本地分支和远端分支同时有新的提交，直接<code>push</code>是不行的。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git push</span></pre></td></tr><tr><td class="code"><pre><span class="line">To github.<span class="keyword">com</span>:veedrin/git.git</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ! [rejected]        master -&gt; master (fetch <span class="keyword">first</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">error: failed <span class="keyword">to</span> push some refs <span class="keyword">to</span> <span class="string">'git@github.com:veedrin/git.git'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">hin<span class="variable">t:</span> Updates were rejected because the remote contains work that you <span class="keyword">do</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">hin<span class="variable">t:</span> not have locally. This <span class="keyword">is</span> usually caused by another repository pushing</span></pre></td></tr><tr><td class="code"><pre><span class="line">hin<span class="variable">t:</span> <span class="keyword">to</span> the same ref. You may want <span class="keyword">to</span> <span class="keyword">first</span> integrate the remote <span class="keyword">changes</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">hin<span class="variable">t:</span> (<span class="keyword">e</span>.g., <span class="string">'git pull ...'</span>) before pushing again.</span></pre></td></tr><tr><td class="code"><pre><span class="line">hin<span class="variable">t:</span> See the <span class="string">'Note about fast-forwards'</span> in <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span></pre></td></tr></table></figure>

<p>有两种方式解决。<br>第一是先把远端的更新拉下来，有冲突则解决冲突，没冲突则再推送。<br>第二是强推。有时候我们就是想覆盖远端对吧，也不是不行，但是必须十分谨慎。而且不要在公共分支上强制推送。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git push -f</span></pre></td></tr><tr><td class="code"><pre><span class="line">Counting objects: <span class="number">24</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Delta compression using up to <span class="number">4</span> threads.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">8</span>/<span class="number">8</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">24</span>/<span class="number">24</span>), <span class="number">3.72</span> KiB | <span class="number">1.24</span> MiB/s, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="number">24</span> (delta <span class="number">0</span>), reused <span class="number">3</span> (delta <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">To github.com:veedrin/git.git</span></pre></td></tr><tr><td class="code"><pre><span class="line"> + <span class="number">54</span>d741b..<span class="number">.2</span>db10e0 master -&gt; master (forced update)</span></pre></td></tr></table></figure>

<p>实际开发时我们会建很多特性分支，推送到远端，通过测试后再合入主分支。使用<code>git push</code>每次都要指定远端分支名，如果会有多次推送，我们可以在推送时设置本地分支追踪远端分支，这样下次就可以直接推送了。<br>也可以简写成<code>git push -u</code>。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git push --<span class="keyword">set</span>-upstream origin dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Counting object<span class="variable">s:</span> <span class="number">3</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Delta compression using <span class="keyword">up</span> <span class="keyword">to</span> <span class="number">4</span> threads.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Compressing object<span class="variable">s:</span> <span class="number">100</span>% (<span class="number">2</span>/<span class="number">2</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Writing object<span class="variable">s:</span> <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="number">255</span> bytes | <span class="number">255.00</span> KiB/s, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote:</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Create <span class="keyword">a</span> pull request <span class="keyword">for</span> <span class="string">'dev'</span> <span class="keyword">on</span> GitHub by visitin<span class="variable">g:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">remote:      http<span class="variable">s:</span>//github.<span class="keyword">com</span>/veedrin/git/pull/<span class="keyword">new</span>/dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote:</span></pre></td></tr><tr><td class="code"><pre><span class="line">To github.<span class="keyword">com</span>:veedrin/git.git</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * [<span class="keyword">new</span> branch]      dev -&gt; dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Branch <span class="string">'dev'</span> <span class="keyword">set</span> <span class="keyword">up</span> <span class="keyword">to</span> track remote branch <span class="string">'dev'</span> from <span class="string">'origin'</span>.</span></pre></td></tr></table></figure>

<p>然后我们在<code>.git/config</code>文件中能看到多了一条配置。</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">[branch <span class="string">"dev"</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">remote</span> = origin</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">merge</span> = refs/heads/dev</span></pre></td></tr></table></figure>

<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>查看远端仓库的命令是<code>git remote</code>。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote</span></pre></td></tr><tr><td class="code"><pre><span class="line">origin</span></pre></td></tr></table></figure>

<p>加<code>-v</code>参数可以查看更为详细的信息，<code>-v</code>是<code>--verbose</code>的缩写。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span></pre></td></tr><tr><td class="code"><pre><span class="line">origin	git<span class="meta">@github</span>.<span class="string">com:</span>veedrin/git.git (fetch)</span></pre></td></tr><tr><td class="code"><pre><span class="line">origin	git<span class="meta">@github</span>.<span class="string">com:</span>veedrin/git.git (push)</span></pre></td></tr></table></figure>

<p>查看某个远端仓库的信息，可以使用命令<code>git remote show</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git remote <span class="keyword">show</span> origin</span></pre></td></tr><tr><td class="code"><pre><span class="line">* remote origin</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">Fetch</span> <span class="keyword">URL</span>: git@github.com:veedrin/git<span class="number">-1.</span>git</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Push  <span class="keyword">URL</span>: git@github.com:veedrin/git<span class="number">-1.</span>git</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">HEAD</span> branch: <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Remote branches:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dev    tracked</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">master</span> tracked</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">Local</span> branches configured <span class="keyword">for</span> <span class="string">'git pull'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dev    merges <span class="keyword">with</span> remote dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">master</span> merges <span class="keyword">with</span> remote <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">Local</span> refs configured <span class="keyword">for</span> <span class="string">'git push'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">master</span> pushes <span class="keyword">to</span> <span class="keyword">master</span> (up <span class="keyword">to</span> <span class="built_in">date</span>)</span></pre></td></tr></table></figure>

<h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><p>添加新的远端仓库，使用<code>git remote add</code>命令。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git remote <span class="built_in">add</span> horseshoe http<span class="variable">s:</span>//github.<span class="keyword">com</span>/veedrin/horseshoe</span></pre></td></tr></table></figure>

<p>然后本地就多了一个远端仓库。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote</span></pre></td></tr><tr><td class="code"><pre><span class="line">horseshoe</span></pre></td></tr><tr><td class="code"><pre><span class="line">origin</span></pre></td></tr></table></figure>

<p>除了添加远端仓库，我们还可以添加本地分支对远端分支的追踪。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Branch <span class="string">'dev'</span> <span class="built_in">set</span> up <span class="built_in">to</span> track remote branch <span class="string">'dev'</span> <span class="built_in">from</span> <span class="string">'origin'</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched <span class="built_in">to</span> <span class="keyword">a</span> <span class="built_in">new</span> branch <span class="string">'dev'</span></span></pre></td></tr></table></figure>

<p>创建dev分支的同时，也设置了对远端分支dev的追踪，这样下次推送的时候就不需要指定了。<br>当然，远端分支引用必须得存在才行。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">fatal: <span class="string">'origin/dev'</span> is <span class="keyword">not</span> <span class="keyword">a</span> commit <span class="keyword">and</span> <span class="keyword">a</span> branch <span class="string">'dev'</span> cannot be created <span class="built_in">from</span> <span class="keyword">it</span></span></pre></td></tr></table></figure>

<p>git也提供了快捷方式。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git checkout <span class="comment">--track origin/dev</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Branch <span class="string">'dev'</span> <span class="built_in">set</span> up <span class="built_in">to</span> track remote branch <span class="string">'dev'</span> <span class="built_in">from</span> <span class="string">'origin'</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched <span class="built_in">to</span> <span class="keyword">a</span> <span class="built_in">new</span> branch <span class="string">'dev'</span></span></pre></td></tr></table></figure>

<h2 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h2><p>有时候你想修改远端仓库的简写名。比如你将女朋友的名字命名为远端仓库的简写名，然后你们分手了。这真是一个令人悲伤(欣喜)的故事。</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">$ git remote <span class="built_in">rename</span> nvpengyou gaoyuanyuan</span></pre></td></tr></table></figure>

<p>查看远端仓库列表。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote</span></pre></td></tr><tr><td class="code"><pre><span class="line">gaoyuanyuan</span></pre></td></tr><tr><td class="code"><pre><span class="line">origin</span></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>一般来说，一个git项目有一个远端仓库就行了，其余的大多是临时性的。所以总有一天要删除它。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote rm horseshoe</span></pre></td></tr></table></figure>

<p>查看远端仓库列表。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote</span></pre></td></tr><tr><td class="code"><pre><span class="line">origin</span></pre></td></tr></table></figure>

<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/remote.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/remote.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（12）：tag</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%8812%EF%BC%89%EF%BC%9Atag/</url>
    <content><![CDATA[<p>git是一个版本管理工具，但在众多版本中，肯定有一些版本是比较重要的，这时候我们希望给这些特定的版本打上标签。比如发布一年以后，程序的各项功能都趋于稳定，可以在圣诞节发布<code>v1.0</code>版本。这个<code>v1.0</code>在git中就可以通过标签实现。<br>而git标签又分为两种，轻量级标签和含附注标签。</p>
<a id="more"></a>

<p>轻量级标签和分支的表现形式是一样的，仅仅是一个指向commit的指针而已。只不过它不能切换，一旦贴上就无法再挪动了。<br>含附注标签才是我们理解的那种标签，它是一个独立的git对象。包含标签的名字，电子邮件地址和日期，以及标签说明。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>创建轻量级标签的命令很简单，运行<code>git tag</code>。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">v0</span>.<span class="number">3</span></span></pre></td></tr></table></figure>

<p>在<code>.git</code>目录中就多了一个指针文件。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/<span class="built_in">ref</span>s/tags/v0<span class="number">.3</span></span></pre></td></tr></table></figure>

<p>创建含附注标签要加一个参数<code>-a</code>，它是<code>--annotated</code>的缩写。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> v1.<span class="number">0</span></span></pre></td></tr></table></figure>

<p>和<code>git commit</code>一样，如果不加<code>-m</code>参数，则会弹出默认或者自定义的编辑器，要求你写标签说明。<br>不写呢？</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">fatal: no <span class="keyword">tag</span> <span class="title">message</span>?</span></pre></td></tr></table></figure>

<p>创建完含附注标签后，<code>.git</code>目录会多出两个文件。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/<span class="built_in">ref</span>s/tags/v0<span class="number">.3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">80</span>/e79e91ce192e22a9fd860182da6649c4614ba1</span></pre></td></tr></table></figure>

<p>含附注标签不仅会创建一个指针，还会创建一个tag对象。<br>我们了解过git有四种对象类型，tag类型是我们认识的最后一种。<br>我们看看该对象的类型。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">cat</span>-<span class="keyword">file</span> -t <span class="number">80</span>e79e9</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">tag</span></span></pre></td></tr></table></figure>

<p>再来看看该对象的内容。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ git cat-file -p 80e79e9</span></pre></td></tr><tr><td class="code"><pre><span class="line">object 359fd95229532cd352aec43aada8e6cea68d87a9</span></pre></td></tr><tr><td class="code"><pre><span class="line">type commit</span></pre></td></tr><tr><td class="code"><pre><span class="line">tag v1.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">tagger veedrin &lt;veedrin@qq.com&gt; 1545878480 +0800</span></pre></td></tr><tr><td class="code"><pre><span class="line">版本 v1.0</span></pre></td></tr></table></figure>

<p>它关联的是一个commit对象，包含标签的名称，打标签的人，打标签的时间以及标签说明。<br>我可不可以给历史commit打标签呢？当然可以。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> v1.<span class="number">0</span> <span class="number">36</span>ff0f5</span></pre></td></tr></table></figure>

<p>只需在后面加上commit的校验和。</p>
<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>查看当前git项目的标签列表，运行<code>git tag</code>命令不带任何参数即可。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">v0.<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">v1.<span class="number">0</span></span></pre></td></tr></table></figure>

<p>注意git标签是按字母顺序排列的，而不是按时间顺序排列。<br>而且我并没有找到分别查看轻量级标签和含附注标签的方法。<br>查看标签详情可以使用<code>git show</code>。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git show v0<span class="number">.3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">36f</span>f0f58c8e6b6a441733e909dc95a6136a4f91b (tag: v0<span class="number">.3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Thu Dec <span class="number">27</span> <span class="number">11</span>:<span class="number">08</span>:<span class="number">09</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    add a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/a.md b/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">new file mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">0000000.</span>.e69de29</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git show v1<span class="number">.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">tag v1<span class="number">.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Tagger: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Thu Dec <span class="number">27</span> <span class="number">11</span>:<span class="number">08</span>:<span class="number">39</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">版本 v1<span class="number">.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">6</span>dfdb65ce65b782a6cb57566bcc1141923059d2b (HEAD -&gt; master, tag: v1<span class="number">.0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Thu Dec <span class="number">27</span> <span class="number">11</span>:<span class="number">08</span>:<span class="number">33</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    add b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/b.md b/b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">new file mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">0000000.</span>.e69de29</span></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>虽然git标签不能移动对吧，但我们可以删除它呀。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-d</span> v0.<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Deleted <span class="keyword">tag</span> <span class="title">'v0</span>.<span class="number">3</span>' (was <span class="number">36</span>ff0f5)</span></pre></td></tr><tr><td class="code"><pre><span class="line">如果标签已经推送到了远端，也是可以删除的。$ git push origin -d v0.<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">To github.com:veedrin/git.git</span></pre></td></tr><tr><td class="code"><pre><span class="line"> - [deleted]         v0.<span class="number">3</span></span></pre></td></tr></table></figure>

<h2 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h2><p>默认情况下，<code>git push</code>推送到远端仓库并不会将标签也推送上去。如果想将标签推送到远端与别人共享，我们得显式的运行命令<code>git push origin</code>。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git push origin v1<span class="number">.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Counting objects: <span class="number">1</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">1</span>/<span class="number">1</span>), <span class="number">160</span> bytes | <span class="number">160.00</span> KiB/s, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="number">1</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">To github.com:veedrin/git.git</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * [new tag]         v1<span class="number">.0</span> -&gt; v1<span class="number">.0</span></span></pre></td></tr></table></figure>

<p>这里并不区分轻量级标签和含附注标签。<br>一次性将本地标签推送到远端仓库也是可以的。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> --tags</span></pre></td></tr></table></figure>

<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/tag.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/tag.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（11）：position</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%8811%EF%BC%89%EF%BC%9Aposition/</url>
    <content><![CDATA[<p>程序遇到bug的时候，我们需要快速定位。<br>定位有两种，第一种是定位bug在哪个提交上，第二种是定位特定文件的某一行是谁最近提交的。</p>
<a id="more"></a>

<h2 id="bisect"><a href="#bisect" class="headerlink" title="bisect"></a>bisect</h2><p>有时候我们发现程序有bug，但是回退几个版本都不解决问题。说明这个bug是一次很老的提交导致的，也不知道当时怎么就没察觉。<br>那怎么办呢？继续一个一个版本的回退？<br>估计<code>Linus Torvalds</code>会鄙视你吧。<br>为了专注于工作，不分心来鄙视你，<code>Linus Torvalds</code>在git中内置了一套定位bug的命令。<br>大家都玩过猜数字游戏吧。主持人悄悄写下一个数，给大家一个数字区间，然后大家轮流开始切割，谁切到主持人写的那个数就要自罚三杯了。<br>对，这就是二分法。git利用二分法定位bug的命令是<code>git bisect</code>。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>假设目前的git项目历史是这样的。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span> -- <span class="built_in">C3</span> -- <span class="built_in">C4</span> -- <span class="built_in">C5</span> -- <span class="built_in">C6</span> -- <span class="built_in">C7</span> -- <span class="built_in">C8</span> -- <span class="built_in">C9</span>(HEAD -&gt; master)</span></pre></td></tr></table></figure>

<p>这里面有一次commit藏了一个bug，但幸运的是，你不知道是哪一次。<br>运行<code>git bisect start</code>命令，后跟你要定位的区间中最新的commit和最老的commit。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git bisect <span class="keyword">start</span> <span class="keyword">HEAD</span> C0</span></pre></td></tr><tr><td class="code"><pre><span class="line">Bisecting: <span class="number">4</span> revisions <span class="keyword">left</span> <span class="keyword">to</span> <span class="keyword">test</span> <span class="keyword">after</span> this (roughly <span class="number">2</span> steps)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[ee27077fdfc6c0c9281c1b7f6957ea2b59a461dd] C4</span></pre></td></tr></table></figure>

<p>然后你就发现HEAD指针自动的指向了<code>C4</code>commit。如果范围是奇数位，那取中间就行了，如果范围是偶数位，则取中间更偏老的那个commit，就比如这里的<code>C4</code>commit。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git bisect good</span></pre></td></tr><tr><td class="code"><pre><span class="line">Bisecting: <span class="number">2</span> revisions left to test after <span class="keyword">this</span> (roughly <span class="number">1</span> step)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">97</span>cc0e879dc09796bd56cfd7c3a54deb41e447f6] C6</span></pre></td></tr></table></figure>

<p>HEAD指针指向<code>C4</code>commit后，你应该运行一下程序，如果没问题，那说明有bug的提交在它之后。我们只需要告诉git当前commit以及更老的commit都是好的。<br>然后HEAD指针就自动指向<code>C6</code>commit。<br>继续在<code>C6</code>commit运行程序，结果复现了bug。说明问题就出在<code>C6</code>commit和<code>C4</code>commit之间。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">bisect </span><span class="keyword">bad</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Bisecting: </span><span class="number">0</span> <span class="keyword">revisions </span>left to test after this (roughly <span class="number">0</span> steps)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[a7e09bd3eab7d1e824c0338233f358cafa682af0] <span class="built_in">C5</span></span></pre></td></tr></table></figure>

<p>将<code>C6</code>commit标记为<code>bad</code>之后，HEAD指针自动指向<code>C5</code>commit。再次运行程序，依然能复现bug。话不多说，标记<code>C5</code>commit为<code>bad</code>。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git bisect <span class="keyword">bad</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">a7e09bd3eab7d1e824c0338233f358cafa682af0 <span class="keyword">is</span> the <span class="keyword">first</span> <span class="keyword">bad</span> commit</span></pre></td></tr></table></figure>

<p>因为<code>C4</code>commit和<code>C5</code>commit之间已经不需要二分了，git会告诉你，<code>C5</code>commit是你标记为<code>bad</code>的最早的commit。问题就应该出在<code>C5</code>commit上。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git bisect <span class="keyword">reset</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Previous <span class="keyword">HEAD</span> <span class="keyword">position</span> was a7e09bd... C5</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched <span class="keyword">to</span> branch <span class="string">'master'</span></span></pre></td></tr></table></figure>

<p>既然找到问题了，那就可以退出<code>git bisect</code>工具了。<br>另外，<code>git bisect old</code>和<code>git bisect good</code>的效果相同，<code>git bisect new</code>和<code>git bisect bad</code>的效果相同，这是因为git考虑到，有时候开发者并不是想定位bug，只是想定位某个commit，这时候用<code>good bad</code>就会有点别扭。</p>
<h3 id="后悔"><a href="#后悔" class="headerlink" title="后悔"></a>后悔</h3><p><code>git bisect</code>确实很强大，但如果我已经<code>bisect</code>若干次，结果不小心把一个<code>good</code>commit标记为<code>bad</code>，或者相反，难道我要<code>reset</code>重来么？<br><code>git bisect</code>还有一个<code>log</code>命令，我们只需要保存<code>bisect</code>日志到一个文件，然后擦除文件中标记错误的日志，然后按新的日志重新开始<code>bisect</code>就好了。</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">git bisect <span class="built_in">log</span> &gt; <span class="built_in">log</span>.txt</span></pre></td></tr></table></figure>

<p>该命令的作用是将日志保存到<code>log.txt</code>文件中。<br>看看<code>log.txt</code>文件中的内容。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"># bad: [<span class="number">4</span>d<span class="number">5e75</span><span class="keyword">c</span><span class="number">7</span>a<span class="number">9e6</span>e<span class="number">65</span>a<span class="number">168</span>d<span class="number">6</span>a<span class="number">2663e95</span>b<span class="number">19</span>da<span class="number">1e2</span>b<span class="number">21</span>] C<span class="number">9</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"># good: [<span class="keyword">c</span><span class="number">2</span>fa<span class="number">7</span>ca<span class="number">426</span>cac<span class="number">9990</span>ba<span class="number">27466520677</span>bf<span class="number">1780</span>af<span class="number">97</span>] <span class="keyword">add</span> a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">git bisect start 'HEAD' '<span class="keyword">c</span><span class="number">2</span>fa<span class="number">7</span>ca<span class="number">426</span>cac<span class="number">9990</span>ba<span class="number">27466520677</span>bf<span class="number">1780</span>af<span class="number">97</span>'</span></pre></td></tr><tr><td class="code"><pre><span class="line"># good: [ee<span class="number">27077</span>fdfc<span class="number">6</span><span class="keyword">c</span><span class="number">0</span><span class="keyword">c</span><span class="number">9281</span><span class="keyword">c</span><span class="number">1</span>b<span class="number">7</span>f<span class="number">6957</span>ea<span class="number">2</span>b<span class="number">59</span>a<span class="number">461</span>dd] C<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">git bisect good ee<span class="number">27077</span>fdfc<span class="number">6</span><span class="keyword">c</span><span class="number">0</span><span class="keyword">c</span><span class="number">9281</span><span class="keyword">c</span><span class="number">1</span>b<span class="number">7</span>f<span class="number">6957</span>ea<span class="number">2</span>b<span class="number">59</span>a<span class="number">461</span>dd</span></pre></td></tr><tr><td class="code"><pre><span class="line"># good: [<span class="number">97</span><span class="keyword">cc</span><span class="number">0e879</span>dc<span class="number">09796</span>bd<span class="number">56</span>cfd<span class="number">7</span><span class="keyword">c</span><span class="number">3</span>a<span class="number">54</span>deb<span class="number">41e447</span>f<span class="number">6</span>] C<span class="number">6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">git bisect good <span class="number">97</span><span class="keyword">cc</span><span class="number">0e879</span>dc<span class="number">09796</span>bd<span class="number">56</span>cfd<span class="number">7</span><span class="keyword">c</span><span class="number">3</span>a<span class="number">54</span>deb<span class="number">41e447</span>f<span class="number">6</span></span></pre></td></tr></table></figure>

<p>将标记错误的内容去掉。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"># bad: [<span class="number">4</span>d<span class="number">5e75</span><span class="keyword">c</span><span class="number">7</span>a<span class="number">9e6</span>e<span class="number">65</span>a<span class="number">168</span>d<span class="number">6</span>a<span class="number">2663e95</span>b<span class="number">19</span>da<span class="number">1e2</span>b<span class="number">21</span>] C<span class="number">9</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"># good: [<span class="keyword">c</span><span class="number">2</span>fa<span class="number">7</span>ca<span class="number">426</span>cac<span class="number">9990</span>ba<span class="number">27466520677</span>bf<span class="number">1780</span>af<span class="number">97</span>] <span class="keyword">add</span> a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">git bisect start 'HEAD' '<span class="keyword">c</span><span class="number">2</span>fa<span class="number">7</span>ca<span class="number">426</span>cac<span class="number">9990</span>ba<span class="number">27466520677</span>bf<span class="number">1780</span>af<span class="number">97</span>'</span></pre></td></tr><tr><td class="code"><pre><span class="line"># good: [ee<span class="number">27077</span>fdfc<span class="number">6</span><span class="keyword">c</span><span class="number">0</span><span class="keyword">c</span><span class="number">9281</span><span class="keyword">c</span><span class="number">1</span>b<span class="number">7</span>f<span class="number">6957</span>ea<span class="number">2</span>b<span class="number">59</span>a<span class="number">461</span>dd] C<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">git bisect good ee<span class="number">27077</span>fdfc<span class="number">6</span><span class="keyword">c</span><span class="number">0</span><span class="keyword">c</span><span class="number">9281</span><span class="keyword">c</span><span class="number">1</span>b<span class="number">7</span>f<span class="number">6957</span>ea<span class="number">2</span>b<span class="number">59</span>a<span class="number">461</span>dd</span></pre></td></tr></table></figure>

<p>然后运行<code>git bisect replay log.txt</code>命令。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">bisect </span>replay log.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">Previous</span> HEAD position was ad95ae3... <span class="built_in">C8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Switched </span>to <span class="keyword">branch </span><span class="string">'master'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Bisecting: </span><span class="number">4</span> <span class="keyword">revisions </span>left to test after this (roughly <span class="number">2</span> steps)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[ee27077fdfc6c0c9281c1b7f6957ea2b59a461dd] <span class="built_in">C4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Bisecting: </span><span class="number">2</span> <span class="keyword">revisions </span>left to test after this (roughly <span class="number">1</span> step)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">97</span>cc0e879dc09796bd56cfd7c3a54deb41e447f6] <span class="built_in">C6</span></span></pre></td></tr></table></figure>

<p>git会根据log从头开始重新<code>bisect</code>，错误的标记就被擦除了。<br>然后就是重新做人啦。</p>
<h2 id="blame"><a href="#blame" class="headerlink" title="blame"></a>blame</h2><p>一个充分协作的项目，每个文件可能都被多个人改动过。当出现问题的时候，大家希望快速的知道，某个文件的某一行是谁最后改动的，以便厘清责任。<br><code>git blame</code>就是这样一个命令。<code>blame</code>翻译成中文是<code>归咎于</code>，这个命令就是用来甩锅的。<br><code>git blame</code>只能作用于单个文件。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git blame a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">705</span>d9622 (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">09</span>:<span class="number">04</span> +<span class="number">0800</span> <span class="number">1</span>) 第一行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">74</span>eff2ee (abby <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">44</span> +<span class="number">0800</span> <span class="number">2</span>) 第二行</span></pre></td></tr><tr><td class="code"><pre><span class="line">a65b29bd (bob <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">17</span>:<span class="number">02</span> +<span class="number">0800</span> <span class="number">3</span>) 第三行</span></pre></td></tr><tr><td class="code"><pre><span class="line">ee27077f (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">05</span> +<span class="number">0800</span> <span class="number">4</span>) 第四行</span></pre></td></tr><tr><td class="code"><pre><span class="line">a7e09bd3 (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">19</span> +<span class="number">0800</span> <span class="number">5</span>) 第五行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">97</span>cc0e87 (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">21</span>:<span class="number">55</span> +<span class="number">0800</span> <span class="number">6</span>) 第六行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">67029</span>a81 (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">22</span>:<span class="number">15</span> +<span class="number">0800</span> <span class="number">7</span>) 第七行</span></pre></td></tr><tr><td class="code"><pre><span class="line">ad95ae3f (zhangsan <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">23</span>:<span class="number">20</span> +<span class="number">0800</span> <span class="number">8</span>) 第八行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span>d5e75c7 (lisi <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">23</span>:<span class="number">37</span> +<span class="number">0800</span> <span class="number">9</span>) 第九行</span></pre></td></tr></table></figure>

<p>它会把每一行的修改者信息都列出来。<br>第一部分是commit哈希值，表示这一行的最近一次修改属于该次提交。<br>第二部分是作者以及修改时间。<br>第三部分是行的内容。<br>如果文件太长，我们可以截取部分行。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git blame -L <span class="number">1</span>,<span class="number">5</span> a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">705</span>d9622 (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">09</span>:<span class="number">04</span> +<span class="number">0800</span> <span class="number">1</span>) 第一行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">74</span>eff2ee (abby <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">44</span> +<span class="number">0800</span> <span class="number">2</span>) 第二行</span></pre></td></tr><tr><td class="code"><pre><span class="line">a65b29bd (bob <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">17</span>:<span class="number">02</span> +<span class="number">0800</span> <span class="number">3</span>) 第三行</span></pre></td></tr><tr><td class="code"><pre><span class="line">ee27077f (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">05</span> +<span class="number">0800</span> <span class="number">4</span>) 第四行</span></pre></td></tr><tr><td class="code"><pre><span class="line">a7e09bd3 (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">19</span> +<span class="number">0800</span> <span class="number">5</span>) 第五行</span></pre></td></tr></table></figure>

<p>或者这样写。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git blame -L <span class="number">1</span>,+<span class="number">4</span> a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">705</span>d9622 (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">09</span>:<span class="number">04</span> +<span class="number">0800</span> <span class="number">1</span>) 第一行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">74</span>eff2ee (abby <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">44</span> +<span class="number">0800</span> <span class="number">2</span>) 第二行</span></pre></td></tr><tr><td class="code"><pre><span class="line">a65b29bd (bob <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">17</span>:<span class="number">02</span> +<span class="number">0800</span> <span class="number">3</span>) 第三行</span></pre></td></tr><tr><td class="code"><pre><span class="line">ee27077f (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">05</span> +<span class="number">0800</span> <span class="number">4</span>) 第四行</span></pre></td></tr></table></figure>

<p>但是结果不是你预期的那样是吧。<code>1,+4</code>的确切意思是从1开始，显示4行。<br>如果有人重名，可以显示邮箱来区分。添加参数<code>-e</code>或者<code>--show-email</code>即可。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git blame -e a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">705</span>d9622 (<span class="symbol">veedrin@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">09</span>:<span class="number">04</span> +<span class="number">0800</span> <span class="number">1</span>) 第一行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">74</span>eff2ee (<span class="symbol">abby@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">44</span> +<span class="number">0800</span> <span class="number">2</span>) 第二行</span></pre></td></tr><tr><td class="code"><pre><span class="line">a65b29bd (<span class="symbol">bob@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">17</span>:<span class="number">02</span> +<span class="number">0800</span> <span class="number">3</span>) 第三行</span></pre></td></tr><tr><td class="code"><pre><span class="line">ee27077f (<span class="symbol">veedrin@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">05</span> +<span class="number">0800</span> <span class="number">4</span>) 第四行</span></pre></td></tr><tr><td class="code"><pre><span class="line">a7e09bd3 (<span class="symbol">veedrin@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">19</span> +<span class="number">0800</span> <span class="number">5</span>) 第五行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">97</span>cc0e87 (<span class="symbol">veedrin@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">21</span>:<span class="number">55</span> +<span class="number">0800</span> <span class="number">6</span>) 第六行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">67029</span>a81 (<span class="symbol">veedrin@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">22</span>:<span class="number">15</span> +<span class="number">0800</span> <span class="number">7</span>) 第七行</span></pre></td></tr><tr><td class="code"><pre><span class="line">ad95ae3f (<span class="symbol">zhangsan@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">23</span>:<span class="number">20</span> +<span class="number">0800</span> <span class="number">8</span>) 第八行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span>d5e75c7 (<span class="symbol">lisi@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">23</span>:<span class="number">37</span> +<span class="number">0800</span> <span class="number">9</span>) 第九行</span></pre></td></tr></table></figure>

<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/position.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/position.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（10）：view</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%8810%EF%BC%89%EF%BC%9Aview/</url>
    <content><![CDATA[<p>有四个git命令可以用来查看git仓库相关信息。</p>
<a id="more"></a>

<h2 id="status"><a href="#status" class="headerlink" title="status"></a>status</h2><p><code>git status</code>命令的作用是同时展示工作区和暂存区的diff、暂存区和当前版本的diff、以及没有被git追踪的文件。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   <span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes not staged <span class="keyword">for</span> commi<span class="variable">t:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will <span class="keyword">be</span> committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard <span class="keyword">changes</span> in working directory)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   <span class="keyword">b</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked <span class="keyword">file</span><span class="variable">s:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> include in what will <span class="keyword">be</span> committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">c</span>.md</span></pre></td></tr></table></figure>

<p>这个命令应该是最常用的git命令之一了，每次提交之前都要看一下。<br><code>git status -v</code>命令相当于<code>git status</code>命令和<code>git diff --staged</code>之和。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status -v</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked files:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">include</span> <span class="keyword">in</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">index</span> <span class="number">5646</span>a65.<span class="number">.4</span>c479de <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-1</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">-apple</span></pre></td></tr><tr><td class="code"><pre><span class="line">+banana</span></pre></td></tr></table></figure>

<p><code>git status -vv</code>命令相当于<code>git status</code>命令和<code>git diff</code>之和。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status -vv</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked files:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">include</span> <span class="keyword">in</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">to</span> be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git c/a.md i/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">index</span> <span class="number">5646</span>a65.<span class="number">.4</span>c479de <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- c/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ i/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-1</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">-apple</span></pre></td></tr><tr><td class="code"><pre><span class="line">+banana</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--------------------------------------------------</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git i/b.md w/b.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">index</span> e69de29.<span class="number">.637</span>a09b <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- i/b.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ w/b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-0</span>,<span class="number">0</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">+<span class="comment">## git is awesome</span></span></pre></td></tr></table></figure>

<p>还有一个<code>-s</code>参数，给出的结果很有意思。</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">$ git status -s</span></pre></td></tr><tr><td class="code"><pre><span class="line">M  a.<span class="built_in">md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> M b.<span class="built_in">md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">?? c.<span class="built_in">md</span></span></pre></td></tr></table></figure>

<p>注意看，前面的字母位置是不一样的。<br>第一个位置是该文件在暂存区的状态，第二个位置是该文件在工作区的状态。比如，以下信息显示<code>a.md</code>文件在暂存区有改动待提交，在工作区也有改动待暂存。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">MM</span> <span class="selector-tag">a</span><span class="selector-class">.md</span></span></pre></td></tr></table></figure>

<p>缩写的状态码主要有这么几种：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>M</td>
<td>文件内容有改动</td>
</tr>
<tr>
<td>A</td>
<td>文件被添加</td>
</tr>
<tr>
<td>D</td>
<td>文件被删除</td>
</tr>
<tr>
<td>R</td>
<td>文件被重命名</td>
</tr>
<tr>
<td>C</td>
<td>文件被复制</td>
</tr>
<tr>
<td>U</td>
<td>文件冲突未解决</td>
</tr>
<tr>
<td>?</td>
<td>文件未被git追踪</td>
</tr>
<tr>
<td>!</td>
<td>文件被git忽略</td>
</tr>
</tbody></table>
<blockquote>
<p><code>?</code>和<code>!</code>所代表的状态因为没有进入git版本系统，所以任何时候两个位置都是一样的。就像<code>??</code>或者<code>!!</code>这样。</p>
</blockquote>
<h2 id="show"><a href="#show" class="headerlink" title="show"></a>show</h2><p><code>git show</code>命令<code>show</code>的是什么呢？git对象。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git show</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">2</span>bd3c9d7de54cec10f0896db9af04c90a41a8160</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Fri Dec <span class="number">28</span> <span class="number">11</span>:<span class="number">23</span>:<span class="number">27</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    update</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/README.md b/README.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">index e8ab145.<span class="number">.75625</span>ce <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">--- a/README.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/README.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-5</span>,<span class="number">3</span> +<span class="number">5</span>,<span class="number">5</span> @@ one</span></pre></td></tr><tr><td class="code"><pre><span class="line"> two</span></pre></td></tr><tr><td class="code"><pre><span class="line"> three</span></pre></td></tr><tr><td class="code"><pre><span class="line">+</span></pre></td></tr><tr><td class="code"><pre><span class="line">+four</span></pre></td></tr></table></figure>

<p><code>git show</code>相当于<code>git show HEAD</code>，显示当前HEAD指向的commit对象的信息。<br>当然，你也可以查看某个git对象的信息，后面跟上git对象的校验和就行。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git show <span class="number">38728</span>d8</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree <span class="number">38728</span>d8</span></pre></td></tr><tr><td class="code"><pre><span class="line">README.md</span></pre></td></tr></table></figure>

<h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p><code>git diff</code>命令可以显示两个主体之间的差异。</p>
<h3 id="工作区与暂存区的差异"><a href="#工作区与暂存区的差异" class="headerlink" title="工作区与暂存区的差异"></a>工作区与暂存区的差异</h3><p>单纯的<code>git diff</code>命令显示工作区与暂存区之间的差异。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git diff</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index e69de29.<span class="number">.5646</span>a65 <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/<span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-0</span>,<span class="number">0</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">+<span class="comment">## git is awesome</span></span></pre></td></tr></table></figure>

<p>因为是两个主体之间的比较，git永远将两个主体分别命名为<code>a</code>和<code>b</code>。<br>也可以只查看某个文件的diff。当然这里依然是工作区与暂存区之间的差异。</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">$ git diff a.<span class="built_in">md</span></span></pre></td></tr></table></figure>

<h3 id="暂存区与当前commit的差异"><a href="#暂存区与当前commit的差异" class="headerlink" title="暂存区与当前commit的差异"></a>暂存区与当前commit的差异</h3><p><code>git diff --staged</code>命令显示暂存区与当前commit的差异。<br><code>git diff --cached</code>也可以达到相同的效果，它比较老，不如<code>--staged</code>语义化。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ git diff --staged</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/<span class="selector-tag">b</span><span class="selector-class">.md</span> b/<span class="selector-tag">b</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">index e69de29..<span class="number">4</span>c479de <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">--- a/<span class="selector-tag">b</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/<span class="selector-tag">b</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ -<span class="number">0</span>,<span class="number">0</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">+apple</span></pre></td></tr></table></figure>

<p>同样，显示某个文件暂存区与当前commit的差异。</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">$ git diff <span class="comment">--staged a.md</span></span></pre></td></tr></table></figure>

<h3 id="两个commit之间的差异"><a href="#两个commit之间的差异" class="headerlink" title="两个commit之间的差异"></a>两个commit之间的差异</h3><p>我们还可以用<code>git diff</code>查看两个commit之间的差异。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git diff C1 C2</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index e69de29.<span class="number">.5646</span>a65 <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/<span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-0</span>,<span class="number">0</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">+<span class="comment">## git is awesome</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/b.md b/b.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">new</span> <span class="built_in">file</span> mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">0000000.</span>.e69de29</span></pre></td></tr></table></figure>

<p>注意先后顺序很重要，假如我改一下顺序。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git diff C2 C1</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">5646</span>a65..e69de29 <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/<span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-1</span> +<span class="number">0</span>,<span class="number">0</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">-<span class="comment">## git is awesome</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/b.md b/b.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">deleted <span class="built_in">file</span> mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index e69de29.<span class="number">.0000000</span></span></pre></td></tr></table></figure>

<p>比较两个commit之间某个文件的差异。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git diff C1:<span class="keyword">a</span>.md C2:<span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index e69de29.<span class="number">.5646</span>a65 <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/<span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-0</span>,<span class="number">0</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">+<span class="comment">## git is awesome</span></span></pre></td></tr></table></figure>

<h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p><code>git log</code>命令显示提交历史。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git log</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">7e2514419</span>ec0f75d1557d3d8165a7e7969f08349</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">53</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">4</span>d346773212b208380f71885979f93da65f07ea6</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">41</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit cde34665b49033d7b8aed3a334c3e2db2200b4dd</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">54</span>:<span class="number">59</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    a.md</span></pre></td></tr></table></figure>

<p>如果要查看每个commit具体的改动，添加<code>-p</code>参数，它是<code>--patch</code>的缩写。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git log -p</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">7e2514419</span>ec0f75d1557d3d8165a7e7969f08349</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">53</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/c.md b/c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">new file mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">0000000.</span>.e69de29</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">4</span>d346773212b208380f71885979f93da65f07ea6</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">41</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/b.md b/b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">new file mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">0000000.</span>.e69de29</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit cde34665b49033d7b8aed3a334c3e2db2200b4dd</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">54</span>:<span class="number">59</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/a.md b/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">new file mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">0000000.</span>.e69de29</span></pre></td></tr></table></figure>

<p>你还可以控制显示最近几条。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git log -p <span class="number">-1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">7e2514419</span>ec0f75d1557d3d8165a7e7969f08349</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">53</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/c.md b/c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">new file mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">0000000.</span>.e69de29</span></pre></td></tr></table></figure>

<p><code>-p</code>有点过于冗余，只是想查看文件修改的统计信息的话，可以使用<code>--stat</code>参数。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git log --stat</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">7e2514419</span>ec0f75d1557d3d8165a7e7969f08349</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">53</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"> c.md | <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">4</span>d346773212b208380f71885979f93da65f07ea6</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">41</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"> b.md | <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit cde34665b49033d7b8aed3a334c3e2db2200b4dd</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">54</span>:<span class="number">59</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"> a.md | <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr></table></figure>

<p>还觉得冗余？只想看提交说明，有一个<code>--oneline</code>可以帮到你。</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">$ git log --oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span>ad50f6 (HEAD -&gt; master) 添加c.<span class="built_in">md</span>文件</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span>d34677 添加b.<span class="built_in">md</span>文件</span></pre></td></tr><tr><td class="code"><pre><span class="line">cde3466 添加a.<span class="built_in">md</span>文件</span></pre></td></tr></table></figure>

<p>想在命令行工具看git提交历史的树形图表，用<code>--graph</code>参数。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git log --graph</span></pre></td></tr><tr><td class="code"><pre><span class="line">* commit <span class="number">7e2514419</span>ec0f75d1557d3d8165a7e7969f08349 (HEAD -&gt; master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">| Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">| Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">53</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|     c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">* commit <span class="number">4</span>d346773212b208380f71885979f93da65f07ea6</span></pre></td></tr><tr><td class="code"><pre><span class="line">| Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">| Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">41</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|     b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">* commit cde34665b49033d7b8aed3a334c3e2db2200b4dd</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">54</span>:<span class="number">59</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      a.md</span></pre></td></tr></table></figure>

<p>我知道你们肯定又觉得冗余，<code>--graph</code>和<code>--oneline</code>食用更佳哟。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span> --graph --oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* 7e25144 (HEAD -&gt; master) c.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* 4d34677 b.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* cde3466 a.md</span></span></pre></td></tr></table></figure>

<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/view.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/view.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（9）：stash</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%889%EF%BC%89%EF%BC%9Astash/</url>
    <content><![CDATA[<p>你在一个分支上开展了一半的工作，突然有一件急事要你去处理。这时候你得切换到一个新的分支，可是手头上的工作你又不想立即提交。<br>这种场景就需要用到git的储藏功能。</p>
<a id="more"></a>

<h2 id="储藏"><a href="#储藏" class="headerlink" title="储藏"></a>储藏</h2><p>想要储藏手头的工作，只需运行<code>git stash</code>命令。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked files:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">include</span> <span class="keyword">in</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git stash</span></pre></td></tr><tr><td class="code"><pre><span class="line">Saved working <span class="keyword">directory</span> <span class="keyword">and</span> <span class="keyword">index</span> state WIP <span class="keyword">on</span> <span class="keyword">master</span>: <span class="number">974</span>a2f2 <span class="keyword">update</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">WIP是<span class="keyword">work</span> <span class="keyword">in</span> progress的缩写，指的是进行中的工作。$ git <span class="keyword">status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked files:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">include</span> <span class="keyword">in</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">nothing</span> added <span class="keyword">to</span> <span class="keyword">commit</span> but untracked files <span class="keyword">present</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">to</span> track)</span></pre></td></tr></table></figure>

<p>可以看到，除了未被git跟踪的文件之外，工作区和暂存区的内容都会被储藏起来。现在你可以切换到其他分支进行下一步工作了。</p>
<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>我们看一下储藏列表。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git stash list</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">stash@</span>&#123;<span class="number">0</span>&#125;: WIP on master: <span class="number">974</span>a2f2 apple</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">stash@</span>&#123;<span class="number">1</span>&#125;: WIP on master: c27b351 banana</span></pre></td></tr></table></figure>

<h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>等我们完成其他工作，肯定要回到这里，继续进行中断的任务。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git stash apply</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes not staged for <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked files:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">include</span> <span class="keyword">in</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span></pre></td></tr></table></figure>

<p>诶，等等。怎么<code>a.md</code>的变更也跑到工作区了？是的，<code>git stash</code>默认会将暂存区和工作区的储藏全部恢复到工作区。如果我就是想原样恢复呢？</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git stash apply --<span class="built_in">index</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   <span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes not staged <span class="keyword">for</span> commi<span class="variable">t:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will <span class="keyword">be</span> committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard <span class="keyword">changes</span> in working directory)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   <span class="keyword">b</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked <span class="keyword">file</span><span class="variable">s:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> include in what will <span class="keyword">be</span> committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">c</span>.md</span></pre></td></tr></table></figure>

<p>加一个参数<code>--index</code>就会让工作区的归工作区，让暂存区的归暂存区。<br>还有一点需要注意，恢复储藏的操作可以应用在任何分支，它也不关心即将恢复储藏的分支上，工作区和暂存区是否干净。如果有冲突，自行解决就是了。<br>我们浏览过储藏列表，说明<code>git stash apply</code>仅仅是恢复了最新的那一次储藏。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git stash apply <span class="symbol">stash@</span>&#123;<span class="number">1</span>&#125;</span></pre></td></tr></table></figure>

<p>指定储藏的名字，我们就可以恢复列表中的任意储藏了。<br>这个时候我们再看一下储藏列表。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git stash list</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">stash@</span>&#123;<span class="number">0</span>&#125;: WIP on master: <span class="number">974</span>a2f2 apple</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">stash@</span>&#123;<span class="number">1</span>&#125;: WIP on master: c27b351 banana</span></pre></td></tr></table></figure>

<p>诶，发现还是两条。我不是已经恢复了一条么？<br><code>apply</code>这个词很巧妙，它只是应用，它可不会清理。</p>
<h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><p>想要清理储藏列表，咱们得显式的运行<code>git stash drop</code>命令。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git stash drop <span class="symbol">stash@</span>&#123;<span class="number">1</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git stash list</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">stash@</span>&#123;<span class="number">0</span>&#125;: WIP on master: <span class="number">974</span>a2f2 apple</span></pre></td></tr></table></figure>

<p>现在就真的没有了。希望你没有喝酒🙃。<br>git还给我们提供了一个快捷操作，运行<code>git stash pop</code>命令，同时恢复储藏和清理储藏。</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">$ git stash <span class="keyword">pop</span></span></pre></td></tr></table></figure>

<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/stash.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/stash.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（8）：revert</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%888%EF%BC%89%EF%BC%9Arevert/</url>
    <content><![CDATA[<p>有时候我们想撤回一个commit，但是这个commit已经在公共的分支上。如果直接修改分支历史，可能会引起一些不必要的混乱。这个时候，<code>git revert</code>命令就派上用场了。<br><code>revert</code>翻译成中文是<code>还原</code>。我觉得称它为对冲更合理。对冲指的是同时进行两笔行情相关、方向相反、数量相当、盈亏相抵的交易，这么理解<code>git revert</code>命令一针见血。<br>因为它的作用就是生成一个新的、完全相反的commit。</p>
<a id="more"></a>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><code>git revert</code>后跟你想要对冲的commit即可。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git revert HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line">Revert <span class="string">"add c.md"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">This reverts commit <span class="number">8a23</span>dad059b60ba847a621b6058fb32fa531b20a.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Please enter the commit message for your changes. Lines starting</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># with '#' will be ignored, and an empty message aborts the commit.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># On branch master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Changes to be committed:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#	deleted:    c.md</span></span></pre></td></tr></table></figure>

<p>git会弹出默认或者自定义的编辑器要求你输入commit信息。然后一个新的commit就生成了。</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">[master a8c4205] Revert <span class="string">"add c.md"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file <span class="section">changed</span>, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> delete mode <span class="number">100644</span> c.md</span></pre></td></tr></table></figure>

<p>可以看到，原本我添加了一个文件<code>a.md</code>，<code>revert</code>操作就会执行删除命令。在工作目录看起来就像添加文件操作被撤销了一样，其实是被对冲了。<br>它不会改变commit历史，只会增加一个新的对冲commit。这是它最大的优点。</p>
<h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>反向操作也会有冲突？你逗我的吧。<br>如果你操作的是最新的commit，那当然不会有冲突了。<br>那要操作的是以前的commit呢？</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span>(HEAD -&gt; master)</span></pre></td></tr></table></figure>

<p>比如<code>a.md</code>在<code>C0</code>内容为空，<code>C1</code>修改文件内容为<code>apple</code>，<code>C2</code>修改文件内容为<code>banana</code>。这时候你想撤销<code>C1</code>的修改。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">revert</span> HEAD~</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">error</span>: could <span class="keyword">not</span> <span class="built_in">revert</span> <span class="number">483b537</span>... apple</span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: after resolving the conflicts, mark the corrected paths</span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: with 'git add &lt;paths&gt;' <span class="keyword">or</span> 'git rm &lt;paths&gt;'</span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: <span class="keyword">and</span> commit the result with 'git commit'</span></pre></td></tr></table></figure>

<p>我们看一下文件内容。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line">banana</span></pre></td></tr><tr><td class="code"><pre><span class="line">=======</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; parent of 483b537... apple</span></pre></td></tr></table></figure>

<p>手动解决冲突，执行<code>git add</code>命令然后执行<code>git revert --continue</code>命令完成对冲操作。<br>取消<code>revert</code>操作只需要执行<code>git revert --abort</code>即可。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/revert.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/revert.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（7）：reset</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%887%EF%BC%89%EF%BC%9Areset/</url>
    <content><![CDATA[<p><code>git checkout</code>命令可以在版本之间随意切换，它的本质是移动HEAD指针。<br>那git有没有办法移动分支指针呢？<br>当然有，这就是<code>git reset</code>命令。</p>
<a id="more"></a>

<h2 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h2><p><code>git reset</code>命令与<code>git checkout</code>命令的区别在于，它会把HEAD指针和分支指针一起移动，如果HEAD指针指向的是一个分支指针的话。<br>我们前面说过使用<code>git checkout</code>命令从有分支指向的commit切换到一个没有分支指向的commit上，这个时候的HEAD指针被称为<code>detached HEAD</code>。这是非常危险的。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span>(HEAD -&gt; master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout <span class="built_in">C1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span>(HEAD) -- <span class="built_in">C2</span>(master)</span></pre></td></tr></table></figure>

<p>但是<code>git reset</code>命令没有这个问题，因为它会把当前的分支指针也带过去。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span>(HEAD -&gt; master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git reset <span class="built_in">C1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span>(HEAD -&gt; master) -- <span class="built_in">C2</span></span></pre></td></tr></table></figure>

<p>这就是<code>重置</code>的含义所在。它可以重置分支。<br>看另一种情况。如果是从一个没有分支指向的commit切换到另一个没有分支指向的commit上，那它们就是两个韩国妹子，傻傻分不清楚了。<br>这是<code>git checkout</code>命令的效果。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span>(HEAD) -- <span class="built_in">C3</span>(master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout <span class="built_in">C1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span>(HEAD) -- <span class="built_in">C2</span> -- <span class="built_in">C3</span>(master)</span></pre></td></tr></table></figure>

<p>这是<code>git reset</code>命令的效果。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span>(HEAD) -- <span class="built_in">C3</span>(master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git reset <span class="built_in">C1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span>(HEAD) -- <span class="built_in">C2</span> -- <span class="built_in">C3</span>(master)</span></pre></td></tr></table></figure>

<h2 id="同时重置暂存区和工作区的改动"><a href="#同时重置暂存区和工作区的改动" class="headerlink" title="同时重置暂存区和工作区的改动"></a>同时重置暂存区和工作区的改动</h2><p>当你在 <code>git reset</code> 命令后面加 <code>--hard</code> 参数时，暂存区和工作区的内容都会重置为重置后的commit内容。也就是说暂存区和工作区的改动都会清空，相当于撤销暂存区和工作区的改动。<br>而且是没有确认操作的哟。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--hard HEAD^</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">HEAD</span> <span class="keyword">is</span> <span class="keyword">now</span> <span class="keyword">at</span> <span class="number">58</span>b0040 <span class="keyword">commit</span> <span class="keyword">for</span> <span class="keyword">nothing</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">nothing</span> <span class="keyword">to</span> <span class="keyword">commit</span>, working tree clean</span></pre></td></tr></table></figure>

<h2 id="仅重置暂存区的改动"><a href="#仅重置暂存区的改动" class="headerlink" title="仅重置暂存区的改动"></a>仅重置暂存区的改动</h2><p><code>git reset</code> 命令后面加 <code>--mixed</code> 参数，或者不加参数，因为<code>--mixed</code>参数是默认值，暂存区的内容会重置为重置后的commit内容，工作区的改动不会清空，相当于撤销暂存区的改动。<br>同样也是没有确认操作的哟。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="keyword">HEAD</span>^</span></pre></td></tr><tr><td class="code"><pre><span class="line">Unstaged changes <span class="keyword">after</span> <span class="keyword">reset</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">M	a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span></pre></td></tr></table></figure>

<p>打个趣，如果<code>git reset</code>命令什么都不加会怎样呢？<br>你可以脑补一下，<code>git reset</code>命令不加参数默认就是<code>--mixed</code>，不加操作对象默认就是<code>HEAD</code>，所以单纯的<code>git reset</code>命令相当于<code>git reset --mixed HEAD</code>命令。<br>那这又意味着什么呢？<br>这意味着从当前commit重置到当前commit，没有变化对吧？但是<code>--mixed</code>参数会撤销暂存区的改动对不对，这就是它的效果。</p>
<h2 id="同时保留暂存区和工作区的改动"><a href="#同时保留暂存区和工作区的改动" class="headerlink" title="同时保留暂存区和工作区的改动"></a>同时保留暂存区和工作区的改动</h2><p>如果 <code>git reset</code> 命令后面加 <code>--soft</code> 参数，钢铁直男的温柔，你懂的。仅仅是重置commit而已，暂存区和工作区的改动都会保留下来。<br>更温柔的是，重置前的commit内容与重置后的commit内容的diff也会放入暂存区。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git diff <span class="comment">--staged</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">index</span> <span class="number">4</span>a77268..fde8dcd <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-1</span>,<span class="number">2</span> +<span class="number">1</span>,<span class="number">3</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line"> apple</span></pre></td></tr><tr><td class="code"><pre><span class="line"> banana</span></pre></td></tr><tr><td class="code"><pre><span class="line">+cherry</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--soft HEAD^</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">to</span> be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git diff <span class="comment">--staged</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">index</span> <span class="number">4</span>a77268..fde8dcd <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-1</span> +<span class="number">1</span>,<span class="number">3</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line"> apple</span></pre></td></tr><tr><td class="code"><pre><span class="line">+banana</span></pre></td></tr><tr><td class="code"><pre><span class="line">+cherry</span></pre></td></tr></table></figure>

<p><code>banana</code>就是重置前的commit内容与重置后的commit内容的diff，可以看到，它已经在暂存区了。</p>
<h2 id="文件暂存区内容撤回工作区"><a href="#文件暂存区内容撤回工作区" class="headerlink" title="文件暂存区内容撤回工作区"></a>文件暂存区内容撤回工作区</h2><p><code>git reset</code>命令后面也可以跟文件名，它的作用是将暂存区的内容重置为工作区的内容，是<code>git add --</code>的反向操作。<br><code>git reset --</code>命令是<code>git reset HEAD --mixed --</code>的简写。在操作文件时，参数只有默认的<code>--mixed</code>一种。<br>它并不会撤销工作区原有的改动。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="comment">-- a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Unstaged changes <span class="keyword">after</span> <span class="keyword">reset</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">M	a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span></pre></td></tr></table></figure>

<p><code>git checkout</code>命令后面也可以跟文件名，它的作用是撤销工作区的改动，需要注意区分。</p>
<h2 id="文件若干commit版本撤回工作区"><a href="#文件若干commit版本撤回工作区" class="headerlink" title="文件若干commit版本撤回工作区"></a>文件若干commit版本撤回工作区</h2><p>如果<code>git reset</code>命令后跟一个commit校验和，它会把该commit与所有后代commit的diff重置到工作区。<br>意思就是将该文件重置回你指定的commit版本，但是在你指定的commit之后的改动我也给你留着，就放到工作区里吧。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git diff <span class="comment">--staged</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 空</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="keyword">HEAD</span>~<span class="number">4</span> <span class="comment">-- a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Unstaged changes <span class="keyword">after</span> <span class="keyword">reset</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">M	a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git diff <span class="comment">--staged</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">index</span> <span class="number">6</span>f195b4.<span class="number">.72943</span>a1 <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-1</span>,<span class="number">5</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line"> aaa</span></pre></td></tr><tr><td class="code"><pre><span class="line">-bbb</span></pre></td></tr><tr><td class="code"><pre><span class="line">-ccc</span></pre></td></tr><tr><td class="code"><pre><span class="line">-ddd</span></pre></td></tr><tr><td class="code"><pre><span class="line">-eee</span></pre></td></tr></table></figure>

<p><code>git diff --staged</code>命令比较工作区和暂存区的内容。可以看到初始工作区和暂存区是一致的，重置文件到4个版本之前，发现工作区比暂存区多了很多改动，这些都是指定commit之后的提交被重置到工作区了。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/reset.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/reset.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（6）：rebase</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%886%EF%BC%89%EF%BC%9Arebase/</url>
    <content><![CDATA[<p><code>git merge</code>命令会生成一个新的合并commit。如果你有强迫症，不喜欢这个新的合并commit，git也有更加清爽的方案可以满足你，它就是<code>git rebase</code>命令。<br>git就是哆啦A梦的口袋。<br><code>rebase</code>翻译过来是<code>变基</code>。意思就是将所有要合并进来的commit在新的基础上重新提交一次。</p>
<a id="more"></a>

<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p><code>git rebase</code>会计算当前分支和目标分支的最近共同祖先，然后将最近共同祖先与当前分支之间的所有commit都变基到目标分支上，使得提交历史变成一条直线。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span> -- <span class="built_in">C3</span>(master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">C4</span> -- <span class="built_in">C5</span> -- <span class="built_in">C6</span>(HEAD -&gt; dev)</span></pre></td></tr></table></figure>

<p><code>merge</code>与<code>rebase</code>后跟的分支名是不一样的。合并是合并进来，变基是变基过去，你们感受一下。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git rebase master</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">First</span>, rewinding head to replay your work on top of <span class="keyword">it...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Applying: </span><span class="built_in">C4</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">Applying</span>: <span class="built_in">C5</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">Applying</span>: <span class="built_in">C6</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span> -- <span class="built_in">C3</span>(master) -- <span class="built_in">C4</span><span class="string">' -- C5'</span> -- <span class="built_in">C6</span><span class="string">'(HEAD -&gt; dev)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">       \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">        C4 -- C5 -- C6</span></span></pre></td></tr></table></figure>

<p>现在最近共同祖先与当前分支之间的所有commit都被复制到master分支之后，并且将HEAD指针与当前分支指针切换过去。这招移花接木玩的很溜啊，如果你置身其中根本分不出区别。<br>原来的commit还在吗？还在，如果你记得它的commit校验和，仍然可以切换过去，git会提示你当前处于<code>detached HEAD</code>状态下。只不过没有任何分支指针指向它们，它们已经被抛弃了，剩余的时光就是等待git垃圾回收命令清理它们。<br>好在，还有人记得它们，不是么？<br><code>git rebase</code>完并没有结束，因为我变基的目标分支是master，而当前分支是dev。我需要切换到master分支上，然后再合并一次。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git checkout <span class="literal">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git merge dev</span></pre></td></tr></table></figure>

<p>诶，说来说去，还是要合并啊？<br>别急，这种合并是<code>Fast forward</code>的，并不会生成一个新的合并commit。<br>如果我要变基的本体分支不是当前分支行不行？也是可以的。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git rebase <span class="keyword">master</span> <span class="title">dev</span></span></pre></td></tr></table></figure>

<p>你在任何一个分支上，这种写法都可以将dev分支变基到master分支上，变基完成当前分支会变成dev分支。</p>
<h2 id="裁剪commit变基"><a href="#裁剪commit变基" class="headerlink" title="裁剪commit变基"></a>裁剪commit变基</h2><p>变基有点像基因编辑，git有更精确的工具达到你想要的效果。</p>
<blockquote>
<p>有了精确的基因编辑技术，妈妈再也不用担心你长的<strong>丑</strong>啦。</p>
</blockquote>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span> -- <span class="built_in">C3</span>(master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">C4</span> -- <span class="built_in">C5</span> -- <span class="built_in">C6</span>(dev)</span></pre></td></tr><tr><td class="code"><pre><span class="line">         \</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="built_in">C7</span> -- <span class="built_in">C8</span>(HEAD -&gt; hotfix)</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git rebase --onto master dev hotfix</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">First</span>, rewinding head to replay your work on top of <span class="keyword">it...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Applying: </span><span class="built_in">C7</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">Applying</span>: <span class="built_in">C8</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span> -- <span class="built_in">C3</span>(master) -- <span class="built_in">C7</span><span class="string">' -- C8'</span>(HEAD -&gt; hotfix)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">C4</span> -- <span class="built_in">C5</span> -- <span class="built_in">C6</span>(dev)</span></pre></td></tr><tr><td class="code"><pre><span class="line">         \</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="built_in">C7</span> -- <span class="built_in">C8</span></span></pre></td></tr></table></figure>

<p><code>--onto</code>参数就是那把基因编辑的剪刀。<br>它会把<code>hotfix分支</code>到<code>hotfix分支与dev分支的最近共同祖先</code>之间的commit裁剪下来，复制到目标基础点上。注意，所谓的之间指的都是不包括<code>最近共同祖先commit</code>的范围，比如这里就不会复制<code>C4</code>commit。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ git rebase <span class="comment">--onto master dev</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">First, rewinding head <span class="keyword">to</span> replay your work <span class="keyword">on</span> top <span class="keyword">of</span> <span class="keyword">it</span>...</span></pre></td></tr><tr><td class="code"><pre><span class="line">Applying: C7.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Applying: C8.md</span></pre></td></tr></table></figure>

<p>如果<code>--onto</code>后面只写两个分支(或者commit)名，第三个分支(或者commit)默认就是HEAD指针指向的分支(或者commit)。</p>
<h2 id="变基冲突解决"><a href="#变基冲突解决" class="headerlink" title="变基冲突解决"></a>变基冲突解决</h2><p>变基也会存在冲突的情况，我们看看冲突怎么解决。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">C0 <span class="comment">-- C1 -- C2(HEAD -&gt; master)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        C3 <span class="comment">-- C4(dev)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git rebase master dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">First, rewinding head to replay your work on top of it...</span></pre></td></tr><tr><td class="code"><pre><span class="line">Applying: c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Applying: a.md add banana</span></pre></td></tr><tr><td class="code"><pre><span class="line">Using index info to reconstruct a base tree...</span></pre></td></tr><tr><td class="code"><pre><span class="line">M	a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Falling back to patching base and 3-way merge...</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Auto</span>-merging a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">CONFLICT (<span class="keyword">content</span>): <span class="keyword">Merge</span> conflict <span class="keyword">in</span> a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">error</span>: <span class="keyword">Failed</span> <span class="keyword">to</span> <span class="keyword">merge</span> <span class="keyword">in</span> the changes.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Patch</span> <span class="keyword">failed</span> <span class="keyword">at</span> <span class="number">0002</span> a.md dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">The copy <span class="keyword">of</span> the <span class="keyword">patch</span> that <span class="keyword">failed</span> <span class="keyword">is</span> <span class="keyword">found</span> <span class="keyword">in</span>: .git/rebase-<span class="keyword">apply</span>/<span class="keyword">patch</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Resolve <span class="keyword">all</span> conflicts manually, mark them <span class="keyword">as</span> resolved <span class="keyword">with</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">"git add/rm &lt;conflicted_files&gt;"</span>, <span class="keyword">then</span> run <span class="string">"git rebase --continue"</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">You can instead <span class="keyword">skip</span> this <span class="keyword">commit</span>: run <span class="string">"git rebase --skip"</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">To</span> <span class="keyword">abort</span> <span class="keyword">and</span> <span class="keyword">get</span> back <span class="keyword">to</span> the state <span class="keyword">before</span> <span class="string">"git rebase"</span>, run <span class="string">"git rebase --abort"</span>.</span></pre></td></tr></table></figure>

<p>C2和C4同时修改了<code>a.md</code>的某一行，引发冲突。git已经给我们提示了，大体上和<code>merge</code>的操作一致。<br>我们可以手动解决冲突，然后执行<code>git add</code>和<code>git rebase --continue</code>来完成变基。<br>如果你不想覆盖目标commit的内容，也可以跳过这个commit，执行<code>git rebase --skip</code>。但是注意，这会跳过有冲突的整个commit，而不仅仅是有冲突的部分。<br>后悔药也是有的，执行<code>git rebase --abort</code>，干脆就放弃变基了。</p>
<h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><p><code>git rebase --onto</code>命令可以裁剪分支以变基到另一个分支上。但它依然是挑选连续的一段commit，只是允许你指定头和尾罢了。<br>别急，<code>git cherry-pick</code>命令虽然是一个独立的git命令，它的效果却还是变基，而且是commit级别的变基。<br><code>git cherry-pick</code>命令可以挑选任意commit变基到目标commit上。你负责挑，它负责基。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>只需要在<code>git cherry-pick</code>命令后跟commit校验和，就可以将它应用到目标commit上。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span>(HEAD -&gt; master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">C3</span> -- <span class="built_in">C4</span> -- <span class="built_in">C5</span>(dev)</span></pre></td></tr><tr><td class="code"><pre><span class="line">               \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">C6</span> -- <span class="built_in">C7</span>(hotfix)</span></pre></td></tr></table></figure>

<p>将当前分支切换到master分支。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">git</span> <span class="string">cherry-pick</span> <span class="string">C6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[master</span> <span class="string">dc342e0]</span> <span class="string">c6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="attr">Date:</span> <span class="string">Mon</span> <span class="string">Dec</span> <span class="number">24</span> <span class="number">09</span><span class="string">:13:57</span> <span class="number">2018</span> <span class="string">+0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="string">file</span> <span class="string">changed,</span> <span class="number">0</span> <span class="string">insertions(+),</span> <span class="number">0</span> <span class="string">deletions(-)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="string">create</span> <span class="string">mode</span> <span class="number">100644</span> <span class="string">c6.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">C0</span> <span class="string">--</span> <span class="string">C1</span> <span class="string">--</span> <span class="string">C2</span> <span class="string">--</span> <span class="string">C6'(HEAD</span> <span class="string">-&gt;</span> <span class="string">master)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="string">\</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">C3</span> <span class="string">--</span> <span class="string">C4</span> <span class="string">--</span> <span class="string">C5(dev)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="string">\</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="string">C6</span> <span class="string">--</span> <span class="string">C7(hotfix)</span></span></pre></td></tr></table></figure>

<p><code>C6</code>commit就按原样重新提交到master分支上了。<code>cherry-pick</code>并不会修改原有的commit。<br>同时挑选多个commit也很方便，往后面叠加就行。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick C4 C7</span></pre></td></tr><tr><td class="code"><pre><span class="line">[master ab1e7c7] c4</span></pre></td></tr><tr><td class="code"><pre><span class="line"> Date: Mon Dec <span class="number">24</span> <span class="number">09</span>:<span class="number">12</span>:<span class="number">58</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode <span class="number">100644</span> c4.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">[master <span class="number">161</span>d993] c7</span></pre></td></tr><tr><td class="code"><pre><span class="line"> Date: Mon Dec <span class="number">24</span> <span class="number">09</span>:<span class="number">14</span>:<span class="number">12</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode <span class="number">100644</span> c7.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">C0 -- C1 -- C2 -- C4<span class="string">' -- C7'</span>(HEAD -&gt; master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        C3 -- C4 -- C5(dev)</span></pre></td></tr><tr><td class="code"><pre><span class="line">               \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                C6 -- C7(hotfix)</span></pre></td></tr></table></figure>

<p>如果这多个commit正好是连续的呢？</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">git</span> <span class="string">cherry-pick</span> <span class="string">C3...C7</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[master</span> <span class="string">d16c42e]</span> <span class="string">c4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="attr">Date:</span> <span class="string">Mon</span> <span class="string">Dec</span> <span class="number">24</span> <span class="number">09</span><span class="string">:12:58</span> <span class="number">2018</span> <span class="string">+0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="string">file</span> <span class="string">changed,</span> <span class="number">0</span> <span class="string">insertions(+),</span> <span class="number">0</span> <span class="string">deletions(-)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="string">create</span> <span class="string">mode</span> <span class="number">100644</span> <span class="string">c4.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[master</span> <span class="string">d16c42e]</span> <span class="string">c6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="attr">Date:</span> <span class="string">Mon</span> <span class="string">Dec</span> <span class="number">24</span> <span class="number">09</span><span class="string">:13:57</span> <span class="number">2018</span> <span class="string">+0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="string">file</span> <span class="string">changed,</span> <span class="number">0</span> <span class="string">insertions(+),</span> <span class="number">0</span> <span class="string">deletions(-)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="string">create</span> <span class="string">mode</span> <span class="number">100644</span> <span class="string">c6.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[master</span> <span class="string">a4d5976]</span> <span class="string">c7</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="attr">Date:</span> <span class="string">Mon</span> <span class="string">Dec</span> <span class="number">24</span> <span class="number">09</span><span class="string">:14:12</span> <span class="number">2018</span> <span class="string">+0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="string">file</span> <span class="string">changed,</span> <span class="number">0</span> <span class="string">insertions(+),</span> <span class="number">0</span> <span class="string">deletions(-)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="string">create</span> <span class="string">mode</span> <span class="number">100644</span> <span class="string">c7.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">C0</span> <span class="string">--</span> <span class="string">C1</span> <span class="string">--</span> <span class="string">C2</span> <span class="string">--</span> <span class="string">C4'</span> <span class="string">--</span> <span class="string">C6'</span> <span class="string">--</span> <span class="string">C7'(HEAD</span> <span class="string">-&gt;</span> <span class="string">master)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="string">\</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">C3</span> <span class="string">--</span> <span class="string">C4</span> <span class="string">--</span> <span class="string">C5(dev)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="string">\</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="string">C6</span> <span class="string">--</span> <span class="string">C7(hotfix)</span></span></pre></td></tr></table></figure>

<p>需要注意，git所谓的从某某开始，一般都是不包括某某的，这里也一样。<br>有没有发现操作连续commit的<code>git cherry-pick</code>和<code>git rebase</code>的功能已经非常接近了？所以呀，<code>git cherry-pick</code>也是变基，只不过一边变基一边喂樱桃给你吃。</p>
<h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>git各种命令解决冲突的方法都大同小异。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">C0 <span class="comment">-- C1(HEAD -&gt; master)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  C2(dev)</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git cherry-pick C2</span></pre></td></tr><tr><td class="code"><pre><span class="line">error: could <span class="keyword">not</span> apply <span class="number">051</span>c24c... banana</span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: <span class="keyword">after</span> resolving <span class="keyword">the</span> conflicts, mark <span class="keyword">the</span> corrected paths</span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: <span class="keyword">with</span> <span class="string">'git add &lt;paths&gt;'</span> <span class="keyword">or</span> <span class="string">'git rm &lt;paths&gt;'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: <span class="keyword">and</span> commit <span class="keyword">the</span> <span class="built_in">result</span> <span class="keyword">with</span> <span class="string">'git commit'</span></span></pre></td></tr></table></figure>

<p>手动解决冲突，执行<code>git add</code>命令然后执行<code>git cherry-pick --continue</code>命令。<br>如果被唬住了想还原，执行<code>git cherry-pick --abort</code>即可。</p>
<h2 id="变基还是合并"><a href="#变基还是合并" class="headerlink" title="变基还是合并"></a>变基还是合并</h2><p>这是一个哲学问题。<br>有一种观点认为，仓库的commit历史应该记录<code>实际发生过什么</code>。所以如果你将一个分支合并进另一个分支，commit历史中就应该有这一次合并的痕迹，因为它是实实在在发生过的。<br>另一种观点则认为，仓库的commit历史应该记录<code>项目过程中发生过什么</code>。合并不是项目开发本身带来的，它是一种额外的操作，会使commit历史变的冗长。<br>我是一个极简主义者，所以我支持首选变基。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/rebase.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/rebase.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（5）：merge</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%885%EF%BC%89%EF%BC%9Amerge/</url>
    <content><![CDATA[<p>可以方便的创建分支是git如此受欢迎的重要原因，利用<code>git checkout</code>也让开发者在分支之间穿梭自如。然而百川终入海，其他分支上完成的工作终究是要合并到主分支上去的。<br>所以我们来看看git中的合并操作。</p>
<a id="more"></a>

<p>首先说明，执行<code>git merge</code>命令之前需要一些准备工作。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">merge</span> dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">error: Your <span class="built_in">local</span> changes <span class="built_in">to</span> <span class="keyword">the</span> following <span class="built_in">files</span> would be overwritten <span class="keyword">by</span> <span class="built_in">merge</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Please commit your changes <span class="keyword">or</span> stash them <span class="keyword">before</span> you <span class="built_in">merge</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Aborting</span></pre></td></tr></table></figure>

<p>合并操作之前必须保证暂存区内没有待提交内容，否则git会阻止合并。这是因为合并之后，git会将合并后的版本覆盖暂存区。所以会有丢失工作成果的危险。<br>至于工作区有待添加到暂存区的内容，git倒不会阻止你。可能git觉得它不重要吧。<br>不过最好还是保持一个干净的工作区再执行合并操作。</p>
<h2 id="不同分支的合并"><a href="#不同分支的合并" class="headerlink" title="不同分支的合并"></a>不同分支的合并</h2><p>不同分支指的是要合并的两个commit在某个祖先commit之后开始分叉。</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">C0</span> -- <span class="variable">C1</span> -- <span class="function"><span class="title">C2</span>(<span class="variable">HEAD</span> -&gt; <span class="variable">master</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="title">C3</span>(<span class="variable">dev</span>)</span></span></pre></td></tr></table></figure>

<p><code>git merge</code>后跟合并客体，表示要将它合并进来。</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">merge</span> dev</span></pre></td></tr></table></figure>

<p>进行到这里，如果没有冲突，git会弹出默认或者自定义的编辑器，让你填写commit说明。当然它会给你填写一个默认的commit说明。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Merge</span> branch <span class="string">'dev'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Please enter a commit message to explain why this merge is necessary,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># especially if it merges an updated upstream into a topic branch.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Lines starting with '#' will be ignored, and an empty message aborts</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># the commit.</span></span></pre></td></tr></table></figure>

<p>为什么要你填写commit说明？因为这种情况的<code>git merge</code>实际上会创建一个新的commit对象，记录此次合并的信息，并将当前分支指针移动到它上面来。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span> -- <span class="built_in">C4</span>(HEAD -&gt; master)(merge commit)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       \          /</span></pre></td></tr><tr><td class="code"><pre><span class="line">        \        /</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="built_in">C3</span>(dev)</span></pre></td></tr></table></figure>

<p>大家常说不同分支的<code>git merge</code>操作是一个三方合并，这里的三方指的是<code>合并主体commit</code>、<code>合并客体commit</code>以及<code>合并主客体的共同祖先commit</code>。<br>所谓的三方和并到底是什么意思呢？<br>git会提取出<code>合并主体commit</code>相对于<code>合并主客体的共同祖先commit</code>的diff与<code>合并客体commit</code>相对于<code>合并主客体的共同祖先commit</code>的diff，再去比较这两份diff有没有修改同一个地方，这里同一个地方的单位是文件的行。如果没有，那就将这两份diff合并生成一个新的commit，当前分支指针向右移。如果有那就要求开发者自行解决。<br>所以在三方合并中，<code>合并主客体的共同祖先commit</code>只是一个参照物。</p>
<h2 id="合并主体在合并客体的上游"><a href="#合并主体在合并客体的上游" class="headerlink" title="合并主体在合并客体的上游"></a>合并主体在合并客体的上游</h2><p>它指的是开发者当前在一个commit节点上，要将同一个分支上更新的commit节点合并进来。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">C0 -- C1 -- C2(<span class="name">HEAD</span> -&gt; master) -- C3(<span class="name">dev</span>)</span></pre></td></tr></table></figure>

<p>这时候会发生什么呢？<br>这相当于更新当前分支指针，所以只需要将当前分支指针向下游移动，让合并主体与合并客体指向同一个commit即可。这时并不会产生一个新的commit。<br>用三方合并的概念来理解，<code>合并主体commit</code>与<code>合并主客体的共同祖先commit</code>是同一个commit，<code>合并主体commit</code>相对于<code>合并主客体的共同祖先commit</code>的diff为空，<code>合并客体commit</code>相对于<code>合并主客体的共同祖先commit</code>的diff与空diff合并还是它自己，所以移动过去就行了，并不需要生成一个新的commit。</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">$ git merge dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Updating <span class="number">9242078.</span><span class="number">.631</span>ef3a</span></pre></td></tr><tr><td class="code"><pre><span class="line">Fast-forward</span></pre></td></tr><tr><td class="code"><pre><span class="line"> a.md | <span class="number">2</span> ++</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file <span class="section">changed</span>, <span class="number">2</span> insertions(+)</span></pre></td></tr><tr><td class="code"><pre><span class="line">C0 -- C1 -- C2 -- C3(HEAD -&gt; master, dev)</span></pre></td></tr></table></figure>

<p>这种操作在git中有一个专有名词，叫<code>Fast forward</code>。<br>比如说<code>git pull</code>的时候经常发生这种情况。通常因为远端有更新的commit我们才需要执行<code>git pull</code>命令，这时远端就是合并客体，本地就是合并主体，远端的分支指针在下游，也会触发<code>Fast forward</code>。</p>
<h2 id="合并主体在合并客体的下游"><a href="#合并主体在合并客体的下游" class="headerlink" title="合并主体在合并客体的下游"></a>合并主体在合并客体的下游</h2><p>如果合并主体在合并客体的下游，那合并主体本身就包含合并客体，合并操作并不会产生任何效果。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">C0 -- C1 -- <span class="constructor">C2(<span class="params">dev</span>)</span> -- <span class="constructor">C3(HEAD -&gt; <span class="params">master</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git merge dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Already up <span class="keyword">to</span> date.</span></pre></td></tr><tr><td class="code"><pre><span class="line">C0 -- C1 -- <span class="constructor">C2(<span class="params">dev</span>)</span> -- <span class="constructor">C3(HEAD -&gt; <span class="params">master</span>)</span></span></pre></td></tr></table></figure>

<p>依然用三方合并的概念来理解，这时<code>合并客体commit</code>与<code>合并主客体的共同祖先commit</code>是同一个commit，<code>合并客体commit</code>相对于<code>合并主客体的共同祖先commit</code>的diff为空，<code>合并主体commit</code>相对于<code>合并主客体的共同祖先commit</code>的diff与空diff合并还是它自己。但是这回它都不用移动，因为合并后的diff就是它自己原有的diff。<br>注意，这时候dev分支指针会不会动呢？<br>当然不会，<code>git merge</code>操作对合并客体是没有任何影响的。</p>
<h2 id="同时合并多个客体"><a href="#同时合并多个客体" class="headerlink" title="同时合并多个客体"></a>同时合并多个客体</h2><p>如果你在<code>git merge</code>后面跟不止一个分支，这意味着你想同时将它们合并进当前分支。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ git merge<span class="built_in"> aaa </span>bbb ccc</span></pre></td></tr><tr><td class="code"><pre><span class="line">Fast-forwarding <span class="keyword">to</span>: aaa</span></pre></td></tr><tr><td class="code"><pre><span class="line">Trying<span class="built_in"> simple </span>merge with bbb</span></pre></td></tr><tr><td class="code"><pre><span class="line">Trying<span class="built_in"> simple </span>merge with ccc</span></pre></td></tr><tr><td class="code"><pre><span class="line">Merge made by the <span class="string">'octopus'</span> strategy.</span></pre></td></tr><tr><td class="code"><pre><span class="line"> aaa.md | 0</span></pre></td></tr><tr><td class="code"><pre><span class="line"> bbb.md | 0</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ccc.md | 0</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 3 files changed, 0 insertions(+), 0 deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode 100644 aaa.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode 100644 bbb.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode 100644 ccc.md</span></pre></td></tr></table></figure>

<p>git合并有多种策略，上面使用的是<code>&#39;octopus&#39; strategy</code>章鱼策略，因为同时合并的多个分支最终都会指向新的commit，看起来像章鱼的触手。</p>
<h2 id="合并有冲突"><a href="#合并有冲突" class="headerlink" title="合并有冲突"></a>合并有冲突</h2><p><code>git merge</code>操作并不总是如此顺利的。因为有时候要合并的两个分支不是同一个人的，就会有很大的概率遇到两人同时修改文件某一行的情况。git不知道该用谁的版本，它认为两个分支遇到了冲突。<br>这时就需要开发者手动的解决冲突，才能让git继续合并。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git merge dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Auto-merging a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">CONFLICT</span> (content): Merge <span class="keyword">conflict</span> <span class="keyword">in</span> a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Automatic merge failed; fix conflicts <span class="keyword">and</span> <span class="keyword">then</span> <span class="keyword">commit</span> the result.</span></pre></td></tr></table></figure>

<p>我们来看一下有冲突的文件是什么样的。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line">apple</span></pre></td></tr><tr><td class="code"><pre><span class="line">=======</span></pre></td></tr><tr><td class="code"><pre><span class="line">banana</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</span></pre></td></tr></table></figure>

<p>运行<code>git status</code>命令。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">You have unmerged paths.</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (fix conflicts and run "git <span class="keyword">commit</span><span class="string">")</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">  (use "</span>git <span class="keyword">merge</span> <span class="comment">--abort" to abort the merge)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Unmerged paths:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> mark resolution)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">both</span> modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span></pre></td></tr></table></figure>

<p>解决完冲突之后，你需要再提交，告诉git可以完成合并了。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> -m "fix merge conflict"</span></pre></td></tr><tr><td class="code"><pre><span class="line">U	a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">error: Committing <span class="keyword">is</span> <span class="keyword">not</span> possible because you have unmerged files.</span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: Fix them up <span class="keyword">in</span> the <span class="keyword">work</span> tree, <span class="keyword">and</span> <span class="keyword">then</span> use <span class="string">'git add/rm &lt;file&gt;'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: <span class="keyword">as</span> appropriate <span class="keyword">to</span> mark resolution <span class="keyword">and</span> make a <span class="keyword">commit</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">fatal: Exiting because <span class="keyword">of</span> an unresolved <span class="keyword">conflict</span>.</span></pre></td></tr></table></figure>

<p>诶，被拒绝了。是不是想起了自己的情场故事？<br>当我们解决冲突的时候，工作区已经有改动，所以需要先提交到暂存区。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span> a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> -m "fix merge conflict"</span></pre></td></tr><tr><td class="code"><pre><span class="line">[master <span class="number">9</span>b32d4d] fix merge <span class="keyword">conflict</span></span></pre></td></tr></table></figure>

<p>运行<code>git add</code>命令之后你也可以用<code>git merge --continue</code>来替代<code>git commit</code>命令。它会让后面的行为跟没有冲突时的行为表现的一样。<br>如果你遇到冲突以后不知道如何解决，因为你要去询问你的合作伙伴为什么这样改。这时你肯定想回到合并以前的状态。<br>这对git来说很容易。只需要运行<code>git merge --abort</code>命令即可。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git merge --<span class="keyword">abort</span></span></pre></td></tr></table></figure>

<p>该命令无法保证恢复工作区的修改，所以最好是在合并之前先让工作区保持干净。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/merge.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/merge.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（4）：checkout</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%884%EF%BC%89%EF%BC%9Acheckout/</url>
    <content><![CDATA[<p>在git中，暂存区里有若干备份，版本库里有若干版本。留着这些东西肯定是拿来用的对吧，怎么用呢？当我需要哪一份的时候我就切换到哪一份。<br><code>git checkout</code>命令就是用来干这个的，官方术语叫做<code>签出</code>。<br>怎么理解<code>checkout</code>这个词呢？<code>checkout</code>原本指的是消费结束服务员要与你核对一下账单，结完账之后你就可以走了。在git中核对指的是diff，比较两份版本的差异，如果发现没有冲突那就可以切换过来了。</p>
<a id="more"></a>

<h2 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h2><p>我们知道HEAD指针指向当前版本，而<code>git checkout</code>命令的作用是切换版本，它们肯定有所关联。<br>目前HEAD指针指向master分支。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ cat .git/HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">ref</span>: <span class="built_in">ref</span>s/heads/master</span></pre></td></tr></table></figure>

<p>如果我切换到另一个分支，会发生什么？</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git checkout dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched to branch <span class="string">'dev'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>cat .git/HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">ref:</span> refs/heads/dev</span></pre></td></tr></table></figure>

<p>果然，<code>git checkout</code>命令的原理就是改变了HEAD指针。而一旦HEAD指针改变，git就会取出HEAD指针指向的版本作为当前工作目录的版本。签出到一个没有分支引用的commit也是一样的。</p>
<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>在进入正题之前，我们要先聊聊git中的两个符号<code>~</code>和<code>^</code>。<br>如果我们要从一个分支切换到另一个分支，那还好说，足够语义化。但是如果我们要切换到某个commit，除了兢兢业业的找到它的SHA-1值，还有什么办法快速的引用到它呢？<br>比如说我们可以根据commit之间的谱系关系快速定位。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span> --graph --oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* 4e76510 (HEAD -&gt; master) c4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*   2ec8374 c3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|\</span></pre></td></tr><tr><td class="code"><pre><span class="line">| * <span class="number">7</span>c0a8e3 c2</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* | fb60f51 c1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|/</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* dc96a29 c0</span></span></pre></td></tr></table></figure>

<blockquote>
<p><code>~</code>的作用是在纵向上定位。它可以一直追溯到最早的祖先commit。如果commit历史有分叉，那它就选第一个，也就是主干上的那个。<br><code>^</code>的作用是在横向上定位。它无法向上追溯，但是如果commit历史有分叉，它能定位所有分叉中的任意一支。</p>
</blockquote>
<h3 id="HEAD不加任何符号、加-0-符号或者加-0符号时，定位的都是当前版本"><a href="#HEAD不加任何符号、加-0-符号或者加-0符号时，定位的都是当前版本" class="headerlink" title="HEAD不加任何符号、加~0 符号或者加^0符号时，定位的都是当前版本"></a>HEAD不加任何符号、加<code>~0</code> 符号或者加<code>^0</code>符号时，定位的都是当前版本</h3><p>这个不用说，定位当前commit。</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4e76510</span>fe8bb3c69de12068ab354ef37bba6da9d</span></pre></td></tr></table></figure>

<p>它表示定位第零代父commit，也就是当前commit。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD~<span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4e76510f</span>e8bb3c69de12068ab354ef37bba6da9d</span></pre></td></tr></table></figure>

<p>它表示定位当前commit的第零个父commit，也就是当前commit。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD^<span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4e76510f</span>e8bb3c69de12068ab354ef37bba6da9d</span></pre></td></tr></table></figure>

<h3 id="用-符号数量的堆砌或者-数量的写法定位第几代父commit"><a href="#用-符号数量的堆砌或者-数量的写法定位第几代父commit" class="headerlink" title="用~符号数量的堆砌或者~数量的写法定位第几代父commit"></a>用<code>~</code>符号数量的堆砌或者<code>~数量</code>的写法定位第几代父commit</h3><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD~~</span></pre></td></tr><tr><td class="code"><pre><span class="line">fb60f519a59e9ceeef039f7efd2a8439aa7efd4b</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD~<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">fb60f519a59e9ceeef039f7efd2a8439aa7efd4b</span></pre></td></tr></table></figure>

<h3 id="用-数量的写法定位第几个父commit"><a href="#用-数量的写法定位第几个父commit" class="headerlink" title="用^数量的写法定位第几个父commit"></a>用<code>^数量</code>的写法定位第几个父commit</h3><p>注意，<code>^</code>定位的是当前基础的父commit。</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD^</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span>ec837440051af433677f786e502d1f6cdeb0a4a</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD^<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span>ec837440051af433677f786e502d1f6cdeb0a4a</span></pre></td></tr></table></figure>

<p>因为当前commit只有一个父commit，所以定位第二个父commit会失败。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD^<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HEAD^<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">fata<span class="variable">l:</span> ambiguous <span class="keyword">argument</span> <span class="string">'HEAD^2'</span>: unknown revision <span class="built_in">or</span> path not in the working tree.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Use <span class="string">'--'</span> <span class="keyword">to</span> separate paths from revisions, like thi<span class="variable">s:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]'</span></span></pre></td></tr></table></figure>

<h3 id="用-数量-数量的写法或者-数量-数量的写法定位第几代父commit的第几个父commit"><a href="#用-数量-数量的写法或者-数量-数量的写法定位第几代父commit的第几个父commit" class="headerlink" title="用~数量^数量的写法或者^数量^数量的写法定位第几代父commit的第几个父commit"></a>用<code>~数量^数量</code>的写法或者<code>^数量^数量</code>的写法定位第几代父commit的第几个父commit</h3><p>当前commit的第一代父commit的第零个父commit，意思就是第一代父commit咯。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD~^<span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span>ec837440051af433677f786e502d1f6cdeb0a4a</span></pre></td></tr></table></figure>

<p>比如这里定位的是当前commit的第一代父commit的第一个父commit。再次注意，<code>^</code>定位的是当前基础的父commit。</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD~^<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">fb60f519a59e9ceeef039f7efd2a8439aa7efd4b</span></pre></td></tr></table></figure>

<p>这里定位的是当前commit的第一代父commit的第二个父commit。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD~^<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">7</span><span class="keyword">c</span><span class="number">0</span>a<span class="number">8e3</span>a<span class="number">325</span>ce<span class="number">1</span>b<span class="number">5</span>a<span class="number">1</span>cdeb<span class="number">8</span><span class="keyword">c</span><span class="number">89</span>bef<span class="number">1</span>ecf<span class="number">17</span><span class="keyword">c</span><span class="number">10</span><span class="keyword">c</span><span class="number">9</span></span></pre></td></tr></table></figure>

<p>同样，定位到一个不存在的commit会失败。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD~^<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HEAD~^<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">fata<span class="variable">l:</span> ambiguous <span class="keyword">argument</span> <span class="string">'HEAD~^3'</span>: unknown revision <span class="built_in">or</span> path not in the working tree.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Use <span class="string">'--'</span> <span class="keyword">to</span> separate paths from revisions, like thi<span class="variable">s:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]'</span></span></pre></td></tr></table></figure>

<p>和<code>~</code>不同，<code>^2</code>和<code>^^</code>的效果是不一样的。<code>^2</code>指的是第二个父commit，<code>^^</code>指的是第一个父commit的第一个父commit。</p>
<h2 id="切换到HEAD"><a href="#切换到HEAD" class="headerlink" title="切换到HEAD"></a>切换到HEAD</h2><p><code>git checkout</code>命令如果不带任何参数，默认会加上HEAD参数。而HEAD指针指向的就是当前commit。所以它并不会有任何签出动作。<br>前面没有提到的是，<code>git checkout</code>命令会有一个顺带效果：比较签出后的版本和暂存区之间的差异。<br>所以<code>git checkout</code>命令不带任何参数，意思就是比较当前commit和暂存区之间的差异。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ git checkout</span></pre></td></tr><tr><td class="code"><pre><span class="line">A	<span class="selector-tag">b</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line">A	<span class="selector-tag">b</span>.md</span></pre></td></tr></table></figure>

<h2 id="切换到commit"><a href="#切换到commit" class="headerlink" title="切换到commit"></a>切换到commit</h2><p>开发者用的最多的当然是切换分支。其实<code>checkout</code>后面不仅可以跟分支名，也可以跟commit的校验和，还可以用符号定位commit。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git checkout dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched to branch 'dev'</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout acb71fe</span></pre></td></tr><tr><td class="code"><pre><span class="line">Note: checking out 'acb71fe11f78d230b860692ea6648906153f3d27'.</span></pre></td></tr><tr><td class="code"><pre><span class="line">You are in 'detached HEAD' state. You can look around, make experimental</span></pre></td></tr><tr><td class="code"><pre><span class="line">changes and <span class="keyword">commit</span> them, <span class="keyword">and</span> you can discard <span class="keyword">any</span> commits you make <span class="keyword">in</span> this</span></pre></td></tr><tr><td class="code"><pre><span class="line">state <span class="keyword">without</span> impacting <span class="keyword">any</span> branches <span class="keyword">by</span> performing another checkout.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">If</span> you want <span class="keyword">to</span> <span class="keyword">create</span> a <span class="keyword">new</span> branch <span class="keyword">to</span> retain commits you <span class="keyword">create</span>, you may</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> so (<span class="keyword">now</span> <span class="keyword">or</span> later) <span class="keyword">by</span> <span class="keyword">using</span> -b <span class="keyword">with</span> the checkout command again. Example:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  git checkout -b &lt;<span class="keyword">new</span>-branch-<span class="keyword">name</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">HEAD</span> <span class="keyword">is</span> <span class="keyword">now</span> <span class="keyword">at</span> acb71fe... <span class="literal">null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout <span class="keyword">HEAD</span>~<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Note: checking <span class="keyword">out</span> <span class="string">'acb71fe11f78d230b860692ea6648906153f3d27'</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">You <span class="keyword">are</span> <span class="keyword">in</span> <span class="string">'detached HEAD'</span> state. You can look around, make experimental</span></pre></td></tr><tr><td class="code"><pre><span class="line">changes <span class="keyword">and</span> <span class="keyword">commit</span> them, <span class="keyword">and</span> you can discard <span class="keyword">any</span> commits you make <span class="keyword">in</span> this</span></pre></td></tr><tr><td class="code"><pre><span class="line">state <span class="keyword">without</span> impacting <span class="keyword">any</span> branches <span class="keyword">by</span> performing another checkout.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">If</span> you want <span class="keyword">to</span> <span class="keyword">create</span> a <span class="keyword">new</span> branch <span class="keyword">to</span> retain commits you <span class="keyword">create</span>, you may</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> so (<span class="keyword">now</span> <span class="keyword">or</span> later) <span class="keyword">by</span> <span class="keyword">using</span> -b <span class="keyword">with</span> the checkout command again. Example:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  git checkout -b &lt;<span class="keyword">new</span>-branch-<span class="keyword">name</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">HEAD</span> <span class="keyword">is</span> <span class="keyword">now</span> <span class="keyword">at</span> acb71fe... <span class="literal">null</span></span></pre></td></tr></table></figure>

<h2 id="创建分支并切换"><a href="#创建分支并切换" class="headerlink" title="创建分支并切换"></a>创建分支并切换</h2><p>有时候我们在创建分支时希望同时切换到创建后的分支，仅仅<code>git branch</code>是做不到的。这时<code>git checkout</code>命令可以提供一个快捷操作，创建分支和切换分支一步到位。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched <span class="built_in">to</span> <span class="keyword">a</span> <span class="built_in">new</span> branch <span class="string">'dev'</span></span></pre></td></tr></table></figure>

<h2 id="暂存区文件覆盖工作区文件"><a href="#暂存区文件覆盖工作区文件" class="headerlink" title="暂存区文件覆盖工作区文件"></a>暂存区文件覆盖工作区文件</h2><p><code>git checkout</code>不仅可以执行切换commit这种全量切换，它还能以文件为单位执行微观切换。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">No commits yet</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git rm --cached &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">new</span> <span class="keyword">file</span>:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout <span class="comment">-- a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">No</span> commits yet</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">to</span> be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git rm --cached &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">new</span> <span class="keyword">file</span>:   a.md</span></pre></td></tr></table></figure>

<p>因为暂存区覆盖了工作区，所以工作区的改动就被撤销了，现在只剩下暂存区的改动等待提交。其实相当于撤销文件在工作区的改动，只不过它的语义是覆盖。这个命令没有任何提示，直接撤销工作区改动，要谨慎使用。<br>我们看到git提示语中有一个<code>git checkout --</code>命令，这又是干嘛用的呢？<br>提醒一下，这个参数的写法不是<code>git checkout --</code>，而是<code>git checkout --</code>。<br>其实它和<code>git checkout</code>的效果是一样的。但是别急，我是说这两个命令<strong>想要</strong>达到的效果是一样的，但<strong>实际</strong>效果却有略微的差别。<br>独立的<code>--</code>参数在Linux命令行中指的是：视后面的参数为文件名。当后面跟的是文件名的时候，最好加上独立的<code>--</code>参数，以免有歧义。<br>也就是说，如果该项目正好有一个分支名为<code>a.md</code>(皮一下也不是不行对吧)，那加独立的<code>--</code>参数就不会操作分支，而是操作文件。<br>如果你觉得仅仅撤销一个文件在工作区的改动不过瘾，你不是针对谁，你是觉得工作区的改动都是垃圾。那么还有一个更危险的命令。</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">$ git checkout <span class="comment">-- .</span></span></pre></td></tr></table></figure>

<p><code>.</code>代表当前目录下的所有文件和子目录。这条命令会撤销所有工作区的改动。</p>
<h2 id="当前commit文件覆盖暂存区文件和工作区文件"><a href="#当前commit文件覆盖暂存区文件和工作区文件" class="headerlink" title="当前commit文件覆盖暂存区文件和工作区文件"></a>当前commit文件覆盖暂存区文件和工作区文件</h2><p>如果执行<code>git checkout --</code>的时候加上一个分支名或者commit的校验和，效果就是该文件的当前版本会同时覆盖暂存区和工作区。相当于同时撤销文件在暂存区和工作区的改动。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout <span class="keyword">HEAD</span> <span class="comment">-- a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">nothing</span> <span class="keyword">to</span> <span class="keyword">commit</span>, working tree clean</span></pre></td></tr></table></figure>

<p>最后再提醒一下，运行<code>git checkout</code>命令作用于文件时，即便覆盖内容与被覆盖内容有冲突，也会直接覆盖，所以这真的是闷声打雷式的git命令，一定要抽自己几个耳刮子方可放心食用。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/checkout.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/checkout.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（3）：branch</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%883%EF%BC%89%EF%BC%9Abranch/</url>
    <content><![CDATA[<p>分支是使得git如此灵活的强大武器，正是因为有巧妙的分支设计，众多的git工作流才成为可能。<br>现在我们已经知道commit对象其实就是git中的版本。那我们要在版本之间切换难道只能通过指定commit对象毫无意义的SHA-1值吗？<br>当然不是。<br>在git中，我们可以通过将一些指针指向commit对象来方便操作，这些指针便是分支。</p>
<a id="more"></a>

<blockquote>
<p>分支在git中是一个模棱两可的概念。<br>你可以认为它仅仅是一个指针，指向一个commit对象节点。<br>你也可以认为它是指针指向的commit对象节点追溯到某个交叉节点之间的commit历史。</p>
</blockquote>
<p>严格的来说，一种叫分支指针，一种叫分支历史。不过实际使用中，它们在名字上常常不作区分。<br>所以我们需要意会文字背后的意思，它究竟说的是分支指针还是分支历史。<br>大多数时候，它指的都是分支指针。</p>
<h2 id="master分支"><a href="#master分支" class="headerlink" title="master分支"></a>master分支</h2><p>刚刚初始化的git仓库，会发现<code>.git/refs/heads</code>目录下面是空的。这是因为目前版本库里还没有任何commit对象，而分支一定是指向commit对象的。<br>一旦版本库里有了第一个commit对象，git都会在<code>.git/refs/heads</code>目录下面自动生成一个<code>master</code>文件，它就是git的默认分支。不过它并不特殊，只是它充当的是一个默认角色而已。<br>刚刚初始化的git仓库会显示目前在master分支上，其实这个master分支是假的，<code>.git/refs/heads</code>目录下根本没有这个文件。只有等提交历史不为空时才有会真正的默认分支。<br>我们看一下<code>master</code>文件到底有什么。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ cat .git/refs/heads/<span class="literal">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">6</span>b5a94158cc141286ac98f30bb189b8a83d61347</span></pre></td></tr></table></figure>

<p>40个字符，明显是某个git对象的引用。再识别一下它的类型，发现是一个commit对象。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git cat-<span class="keyword">file</span> -t <span class="number">6</span>b5a941</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit</span></pre></td></tr></table></figure>

<p>就这么简单，所谓的分支(分支指针)就是一个指向某个commit对象的指针。</p>
<h2 id="HEAD指针"><a href="#HEAD指针" class="headerlink" title="HEAD指针"></a>HEAD指针</h2><p>形象的讲，HEAD就是景区地图上标注你当前在哪里的一个图标。<br>你当前在哪里，HEAD就在哪里。它一般指向某个分支，因为一般我们都会在某个分支之上。<br>因为HEAD是用来标注当前位置的，所以一旦HEAD的位置被改变，工作目录就会切换到HEAD指向的分支。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">log</span> <span class="comment">--oneline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">f53aaa7 (HEAD -&gt; master) <span class="keyword">commit</span> <span class="keyword">for</span> <span class="keyword">nothing</span></span></pre></td></tr></table></figure>

<p>但是也有例外，比如我直接签出到某个没有分支引用的commit。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> <span class="comment">--oneline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cb64064 (HEAD -&gt; master) commit <span class="keyword">for</span> nothing again</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">324</span>a3c0 commit <span class="keyword">for</span> nothing</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout <span class="number">324</span>a3c0</span></pre></td></tr><tr><td class="code"><pre><span class="line">Note: checking out <span class="string">'324a3c0'</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">You are <span class="keyword">in</span> <span class="string">'detached HEAD'</span> state. You can look around, make experimental</span></pre></td></tr><tr><td class="code"><pre><span class="line">changes <span class="keyword">and</span> commit them, <span class="keyword">and</span> you can discard <span class="keyword">any</span> commits you make <span class="keyword">in</span> this</span></pre></td></tr><tr><td class="code"><pre><span class="line">state <span class="keyword">without</span> impacting <span class="keyword">any</span> branches <span class="keyword">by</span> performing another checkout.</span></pre></td></tr><tr><td class="code"><pre><span class="line">If you want <span class="built_in">to</span> <span class="built_in">create</span> <span class="keyword">a</span> <span class="built_in">new</span> branch <span class="built_in">to</span> retain commits you <span class="built_in">create</span>, you may</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">do</span> so (now <span class="keyword">or</span> later) <span class="keyword">by</span> <span class="keyword">using</span> -b <span class="keyword">with</span> <span class="keyword">the</span> checkout <span class="keyword">command</span> <span class="title">again</span>. <span class="title">Example</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  git checkout -b &lt;<span class="built_in">new</span>-branch-name&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">HEAD is now <span class="keyword">at</span> <span class="number">324</span>a3c0... commit <span class="keyword">for</span> nothing</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> <span class="comment">--oneline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">324</span>a3c0 commit <span class="keyword">for</span> nothing</span></pre></td></tr></table></figure>

<p>这个时候的HEAD就叫做<code>detached HEAD</code>。<br>要知道，只有在初始提交和某个分支之间的commit才是有效的。当你的HEAD处于<code>detached HEAD</code>状态时，在它之上新建的commit没有被任何分支包裹。一旦你切换到别的分支，这个commit(可能)再也不会被引用到，最终会被垃圾回收机制删除。因此这是很危险的操作。</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="number">324</span><span class="variable">a3c0</span> -- <span class="function"><span class="title">cb64064</span>(<span class="variable">master</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   \</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">3899</span><span class="function"><span class="title">a24</span>(<span class="variable">HEAD</span>)</span></span></pre></td></tr></table></figure>

<p>如果不小心这么做了，要么在原地新建一个分支，要么将已有的分支强行移动过来。确保它不会被遗忘。</p>
<blockquote>
<p>死亡不是终结，遗忘才是。——寻梦环游记</p>
</blockquote>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>除了默认的<code>master</code>分支，我们可以随意创建新的分支。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>dev</span></pre></td></tr></table></figure>

<p>一个dev分支就创建好了。</p>
<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>或许有时我们也想要查看本地仓库有多少个分支，因为在git中新建分支实在是太容易了。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git branch</span></pre></td></tr><tr><td class="code"><pre><span class="line">  dev</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* master</span></span></pre></td></tr></table></figure>

<p>当前分支的前面会有一个<code>*</code>号标注。<br>同时查看本地分支和远端分支引用，添加<code>-a</code>参数。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git branch -a</span></pre></td></tr><tr><td class="code"><pre><span class="line">* <span class="literal">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  remotes/origin/HEAD -&gt; origin/<span class="literal">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  remotes/origin/<span class="literal">master</span></span></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>一般分支合并完之后就不再需要了，这时就要将它删除。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-d dev</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">Deleted</span> <span class="keyword">branch </span>dev (was <span class="number">657142</span>d).</span></pre></td></tr></table></figure>

<p>有时候我们会得到不一样的提示。</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">$ git branch -d dev</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">error: </span>The branch 'dev' is not fully merged.</span></pre></td></tr><tr><td class="code"><pre><span class="line">If you are sure you want to delete it, run 'git branch -D dev'.</span></pre></td></tr></table></figure>

<p>这是git的一种保护措施。<code>is not fully merged</code>是针对当前分支来说的，意思是你要删除的分支还有内容没有合并进<strong>当前分支</strong>，你确定要删除它吗？<br>大多数时候，当然是要的。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-D dev</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">Deleted</span> <span class="keyword">branch </span>dev (was <span class="number">657142</span>d).</span></pre></td></tr></table></figure>

<p><code>-D</code>是<code>--delete --force</code>的缩写，你也可以写成<code>-df</code>。<br>需要注意的是，删除分支仅仅是删除一个指针而已，并不会删除对应的commit对象。不过有可能删除分支以后，这一串commit对象就无法再被引用了，从而被垃圾回收机制删除。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/branch.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/branch.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（2）：commit</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%882%EF%BC%89%EF%BC%9Acommit/</url>
    <content><![CDATA[<p>git是一个版本管理系统。它的终极目的就是将项目特定时间的信息保留成一个版本，以便将来的回退和查阅。<br>我们已经介绍了暂存区，暂存区的下一步就是版本库，而促成这一步操作的是<code>git commit</code>命令。</p>
<a id="more"></a>

<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>暂存区有待提交内容的情况下，如果直接运行<code>git commit</code>命令，git会跳往默认编辑器要求你输入提交说明，你也可以自定义要跳往的编辑器。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Please enter the commit message for your changes. Lines starting</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># with '#' will be ignored, and an empty message aborts the commit.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># On branch master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Initial commit</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Changes to be committed:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#	new file:   a.md</span></span></pre></td></tr></table></figure>

<p>提交之后我们就看到这样的信息。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">[master (root-commit) <span class="number">99558b4</span>] commit <span class="keyword">for</span> nothing</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode <span class="number">100644</span> a.md</span></pre></td></tr></table></figure>

<p>如果我就是不写提交说明呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Aborting <span class="keyword">commit</span> due <span class="keyword">to</span> <span class="keyword">empty</span> <span class="keyword">commit</span> message.</span></pre></td></tr></table></figure>

<p>看到没有，提交信息在git中时必填的。<br>如果提交说明不多，可以加参数<code>-m</code>直接在命令后面填写提交说明。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git commit -m <span class="string">"commit for nothing"</span></span></pre></td></tr></table></figure>

<p>你甚至可以将加入暂存区和提交一并做了。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git commit -am <span class="string">"commit for nothing"</span></span></pre></td></tr></table></figure>

<p>但是要注意，和<code>git add -u</code>命令一样，未跟踪的文件是无法提交上去的。</p>
<h2 id="重写提交"><a href="#重写提交" class="headerlink" title="重写提交"></a>重写提交</h2><p><code>amend</code>翻译成中文是<code>修改</code>的意思。<code>git commit --amend</code>命令允许你修改最近的一次commit。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">log</span> <span class="comment">--oneline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">8274473</span> (HEAD -&gt; master) <span class="keyword">commit</span> <span class="keyword">for</span> <span class="keyword">nothing</span></span></pre></td></tr></table></figure>

<p>目前项目提交历史中只有一个commit。我突然想起来这次提交中有一个笔误，我把<code>高圆圆</code>写成了<code>高晓松</code>(真的是笔误)。但是呢，我又不想为了这个笔误增加一个commit，毕竟它仅仅是一个小小的笔误而已。最重要的是我想悄无声息的改正它，以免被别人笑话。<br>这时我就可以使用<code>git commit --amend</code>命令。<br>首先修改<code>高晓松</code>成<code>高圆圆</code>。<br>然后执行<code>git add a.md</code>命令。<br>最后重写提交。git会跳往默认或者自定义编辑器提示你修改commit说明。当然你也可以不改。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> <span class="comment">--amend</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">commit</span> <span class="keyword">for</span> <span class="keyword">nothing</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Please enter the commit message for your changes. Lines starting</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># with '#' will be ignored, and an empty message aborts the commit.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Date:      Thu Jan 3 09:33:56 2019 +0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># On branch master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Initial commit</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Changes to be committed:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#	new file:   a.md</span></span></pre></td></tr></table></figure>

<p>我们再来看提交历史。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">log</span> <span class="comment">--oneline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">8</span>a71ae1 (HEAD -&gt; master) <span class="keyword">commit</span> <span class="keyword">for</span> <span class="keyword">nothing</span></span></pre></td></tr></table></figure>

<p>提交历史中同样只有一个commit。但是注意哟，commit已经不是之前的那个commit了，它们的校验和是不一样的。这就是所谓的重写。</p>
<h2 id="tree对象和commit对象"><a href="#tree对象和commit对象" class="headerlink" title="tree对象和commit对象"></a>tree对象和commit对象</h2><p>commit操作涉及到两个git对象。<br>第一是tree对象。<br>它存储子目录和子文件的引用。如果只有blob对象，那版本库将是一团散沙。正因为有tree对象将它们的关系登记在册，才能构成一个有结构的版本库。<br>添加到暂存区操作并不会生成tree对象，这时项目的结构信息存储在<code>index</code>文件中，直到提交版本库操作，才会为每一个目录分别生成tree对象。<br>第二是commit对象。<br>它存储每个提交的信息，包括当前提交的根tree对象的引用，父commit对象的引用，作者和提交者，还有提交信息。所谓的版本，其实指的就是这个commit对象。<br>作者和提交者通常是一个人，但也存在不同人的情况。</p>
<h2 id="objects"><a href="#objects" class="headerlink" title="objects"></a>objects</h2><p>初始化一个git项目，新建一些文件和目录。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">src/</span></pre></td></tr><tr><td class="code"><pre><span class="line">src/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">lib</span>/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">lib</span>/<span class="title">b</span>.<span class="title">md</span></span></span></pre></td></tr></table></figure>

<p>首先运行<code>git add</code>命令。我们清楚，这会在<code>.git/objects</code>目录下生成一个blob对象，因为目前两个文件都是空文件，共享一个blob对象。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/info/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/pack/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391</span></span></pre></td></tr></table></figure>

<p>现在我们运行<code>git commit</code>命令，看看有什么变化。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/objects/info/</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/pack/</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/e6/<span class="number">9</span>de29bb2d1d6434b8b29ae775ad8c2e48c5391</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">93</span>/<span class="number">810</span>bbde0f994d41ef550324a2c1ad5f9278e19</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">52</span>/<span class="number">0</span>c9f9f61657ca1e65a288ea77d229a27a8171b</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">0</span>b/<span class="number">785f</span>a11cd93f95b1cab8b9cbab188edc7e04df</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">49</span>/<span class="number">11f</span>f67189d8d5cc2f94904fdd398fc16410d56</span></pre></td></tr></table></figure>

<p>有意思。刚刚只有一个blob对象，怎么突然蹦出来这么多git对象呢？想一想之前说的<code>commit操作涉及到两个git对象</code>这句话，有没有可能多出来的几个，分别是tree对象和commit对象？<br>我们使用git底层命令<code>git cat-file -t</code>查看这些对象的类型发现，其中有一个blob对象，三个tree对象，一个commit对象。<br>这是第一个tree对象。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git cat-<span class="keyword">file</span> -t <span class="number">93810</span>bb</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git cat-<span class="keyword">file</span> -p <span class="number">93810</span>bb</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">100644</span> blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391	b.md</span></pre></td></tr></table></figure>

<p>这是第二个tree对象。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git cat-<span class="keyword">file</span> -t <span class="number">520</span>c9f9</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git cat-<span class="keyword">file</span> -p <span class="number">520</span>c9f9</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">100644</span> blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391	a.md</span></pre></td></tr></table></figure>

<p>这是第三个tree对象。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">$ git cat-file -t <span class="number">0</span>b785fa</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git cat-file -p <span class="number">0</span>b785fa</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0</span>40000 tree <span class="number">93810</span>bbde0f994d41ef550324a2c1ad5f9278e19	<span class="class"><span class="keyword">lib</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0</span>40000 tree <span class="number">520</span>c9f9f61657ca1e65a288ea77d229a27a8171b	src</span></pre></td></tr></table></figure>

<p>可以看到，提交时每个目录都会生成对应的tree对象。<br>然后我们再来看commit对象。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git cat-file -t <span class="number">4911f</span>f6</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git cat-file -p <span class="number">4911f</span>f6</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree <span class="number">0</span>b785fa11cd93f95b1cab8b9cbab188edc7e04df</span></pre></td></tr><tr><td class="code"><pre><span class="line">parent c4731cfab38f036c04de93facf07cae496a124a2</span></pre></td></tr><tr><td class="code"><pre><span class="line">author veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt; <span class="number">1546395770</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">committer veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt; <span class="number">1546395770</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="keyword">for</span> nothing</span></pre></td></tr></table></figure>

<p>可以看到，commit会关联根目录的tree对象，因为关联它就可以关联到所有的项目结构信息，所谓擒贼先擒王嘛。它也要关联父commit，也就是它的上一个commit，这样才能组成版本历史。当然，如果是第一个commit那就没有父commit了。然后就是commit说明和一些参与者信息。<br>我们总结一下，<code>git add</code>命令会为加入暂存区的内容或文件生成blob对象，<code>git commit</code>命令会为加入版本库的内容或文件生成tree对象和commit对象。至此，四种git对象我们见识了三种。<br>为啥不在<code>git add</code>的时候就生成tree对象呢？<br>所谓暂存区，就是不一定会保存为版本的信息，只是一个准备的临时场所。git认为在<code>git add</code>的时候生成tree对象是不够高效的，完全可以等版本定型时再生成。而版本定型之前的结构信息存在<code>index</code>文件中就好了。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/commit.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/commit.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（1）：add</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%881%EF%BC%89%EF%BC%9Aadd/</url>
    <content><![CDATA[<p>git是一个数据库系统，git是一个内容寻址文件系统，git是一个版本管理系统。<br>没错，它都是。<br>不过我们不纠结于git是什么，我们单刀直入，介绍git命令。<br>要将未跟踪的文件和已跟踪文件的改动加入暂存区，我们可以使用<code>git add</code>命令。<br>不过很多人嫌<code>git add</code>命令不够语义化，毕竟这一步操作是加入暂存区呀。所以git又增加了另外一个命令<code>git stage</code>，它们的效果是一模一样的。</p>
<a id="more"></a>

<h2 id="git仓库、工作区和暂存区"><a href="#git仓库、工作区和暂存区" class="headerlink" title="git仓库、工作区和暂存区"></a>git仓库、工作区和暂存区</h2><p>进入主题之前，我们先要介绍一下git仓库、工作区和暂存区的概念。</p>
<h3 id="git仓库"><a href="#git仓库" class="headerlink" title="git仓库"></a>git仓库</h3><p>所谓的git仓库就是一个有<code>.git</code>目录的文件夹。它是和git有关的一切故事开始的地方。<br>可以使用<code>git init</code>命令初始化一个git仓库。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git init</span></pre></td></tr></table></figure>

<p>也可以使用<code>git clone</code>命令从服务器上克隆仓库到本地。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">git</span>@github.com:veedrin/horseshoe.git</span></pre></td></tr></table></figure>

<p>然后你的本地就有了一个和服务器上一模一样的git仓库。<br>这里要说明的是，<code>clone</code>操作并不是将整个仓库下载下来，而是只下载<code>.git</code>目录。因为关于git的一切秘密都在这个目录里面，只要有了它，git就能复原到仓库的任意版本。</p>
<h3 id="工作区-working-directory"><a href="#工作区-working-directory" class="headerlink" title="工作区(working directory)"></a>工作区(working directory)</h3><p>工作区，又叫工作目录，就是不包括<code>.git</code>目录的项目根目录。我们要在这个目录下进行手头的工作，它就是版本管理的素材库。你甚至可以称任何与工作有关的目录为工作区，只不过没有<code>.git</code>目录git是不认的。</p>
<h3 id="暂存区-stage或者index"><a href="#暂存区-stage或者index" class="headerlink" title="暂存区(stage或者index)"></a>暂存区(stage或者index)</h3><p><code>stage</code>在英文中除了有<code>舞台、阶段</code>之意外，还有作为动词的<code>准备、筹划</code>之意，所谓的暂存区就是一个为提交到版本库做准备的地方。<br>那它为什么又被称作<code>index</code>呢？因为暂存区在物理上仅仅是<code>.git</code>目录下的<code>index</code>二进制文件。它就是一个索引文件，将工作区中的文件和暂存区中的备份一一对应起来。<br><code>stage</code>是表意的，<code>index</code>是表形的。<br>你可以把暂存区理解为一个猪猪储钱罐。我们还是孩子的时候，手里有一毛钱就会丢进储钱罐里。等到储钱罐摇晃的声音变的浑厚时，或者我们有一个心愿急需用钱时，我们就砸开储钱罐，一次性花完。<br>类比到软件开发，每当我们写完一个小模块，就可以将它放入暂存区。等到一个完整的功能开发完，我们就可以从暂存区一次性提交到版本库里。<br>这样做的好处是明显的：</p>
<ul>
<li>它可以实现更小颗粒度的撤销。</li>
<li>它可以实现批量提交到版本库。</li>
</ul>
<p>另外，添加到暂存区其实包含两种操作。一种是将还未被git跟踪过的文件放入暂存区；一种是已经被git跟踪的文件，将有改动的内容放入暂存区。</p>
<h2 id="放入暂存区"><a href="#放入暂存区" class="headerlink" title="放入暂存区"></a>放入暂存区</h2><p>git默认是不会把工作区的文件放入暂存区的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">No commits yet</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked files:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">include</span> <span class="keyword">in</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">nothing</span> added <span class="keyword">to</span> <span class="keyword">commit</span> but untracked files <span class="keyword">present</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">to</span> track)</span></pre></td></tr></table></figure>

<p>我们看到文件现在被标注为<code>Untracked files</code>。表示git目前还无法追踪它们的变化，也就是说它们还不在暂存区里。<br>那么我们如何手动将文件或文件夹放入暂存区呢？</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> .</span></span></pre></td></tr></table></figure>

<p>上面的命令表示将工作目录所有未放入暂存区的文件都放入暂存区。这时文件的状态已经变成了<code>Changes to be committed</code>，表示文件已经放入暂存区，等待下一步提交。每一次add操作其实就是为加入的文件或内容生成一份备份。<br>下面的命令也能达到相同的效果。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> -A</span></span></pre></td></tr></table></figure>

<p>假如我只想暂存单个文件呢？后跟相对于当前目录的文件名即可。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> README.md</span></span></pre></td></tr></table></figure>

<p>暂存整个文件夹也是一样的道理。因为git会递归暂存文件夹下的所有文件。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> src</span></span></pre></td></tr></table></figure>

<p>把从来没有被标记过的文件放入暂存区的命令是<code>git add</code>，暂存区中的文件有改动也需要使用<code>git add</code>命令将改动放入暂存区。<br>这时状态变成了<code>Changes not staged for commit</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes not staged for <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span></pre></td></tr></table></figure>

<p>针对已经加入暂存区的文件，要将文件改动加入暂存区，还有一个命令。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> -u</span></span></pre></td></tr></table></figure>

<p>它和<code>git add -A</code>命令的区别在于，它只能将已加入暂存区文件的改动放入暂存区，而<code>git add -A</code>通吃两种情况。</p>
<h2 id="跟踪内容"><a href="#跟踪内容" class="headerlink" title="跟踪内容"></a>跟踪内容</h2><p>假设我们已经将文件加入暂存区，现在我们往文件中添加内容，再次放入暂存区，然后查看状态。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">No commits yet</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git rm --cached &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">new</span> <span class="keyword">file</span>:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr></table></figure>

<p>哎，突然变的有意思了。为什么一个文件会同时存在两种状态，它是薛定谔的猫么？<br>想象一下，我想在一个文件中先修复一个bug然后增加一个feather，我肯定希望分两次放入暂存区，这样可以实现颗粒度更细的撤销和提交。但是如果git是基于文件做版本管理的，它就无法做到。<br>所以git只能是基于内容做版本管理，而不是基于文件。版本管理的最小单位叫做hunk，所谓的hunk就是一段连续的改动。一个文件同时有两种状态也就不稀奇了。</p>
<h2 id="objects"><a href="#objects" class="headerlink" title="objects"></a>objects</h2><p>git项目的<code>.git</code>目录下面有一个目录<code>objects</code>，一开始这个目录下面只有两个空目录：<code>info</code>和<code>pack</code>。<br>一旦我们执行了<code>git add</code>命令，<code>objects</code>目录下面就会多出一些东西。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="title">.git/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/e6/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391</span></span></pre></td></tr></table></figure>

<p>它多出了一个2个字符命名的目录和一个38个字符命名的文件。加起来正好是40个字符。增加一个2个字符的目录是为了提高检索效率。<br>SHA-1是一种哈希加密算法，它的特点是只要加密的内容相同，得到的校验和也相同。当然这种说法是不准确的，但是碰撞的概率极低。<br>git除了用内容来计算校验和之外，还加入了一些其他信息，目的也是为了进一步降低碰撞的概率。<br>重点是，SHA-1算法是根据内容来计算校验和的，跟前面讲的git跟踪内容相呼应。git被称为一个内容寻址文件系统不是没有道理的。<br>我们可以做个实验。初始化本地仓库两次，每次都新建一个markdown文件，里面写<code>## git is awesome</code>，记下完整的40个字符的校验和，看看它们是否一样。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">56</span>/<span class="number">46</span>a656f6331e1b30988472fefd48686a99e10f</span></pre></td></tr></table></figure>

<p>如果你真的做了实验，你会发现即便两个文件的文件名和文件格式都不一样，只要内容一样，它们的校验和就是一样的，并且就是上面列出的校验和。<br>现在大家应该对<code>git跟踪内容</code>这句话有更深的理解了。</p>
<h3 id="相同内容引用一个对象"><a href="#相同内容引用一个对象" class="headerlink" title="相同内容引用一个对象"></a>相同内容引用一个对象</h3><p>虽然开发者要极力避免这种情况，但是如果一个仓库有多个内容相同的文件，git会如何处理呢？<br>我们初始化一个本地仓库，新建两个不同名的文件，但文件内容都是<code>## git is awesome</code>。运行<code>git add .</code>命令之后看看神秘的<code>objects</code>目录下会发生什么？</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">56</span>/<span class="number">46</span>a656f6331e1b30988472fefd48686a99e10f</span></pre></td></tr></table></figure>

<p>只有一个目录，而且校验和跟之前一模一样。<br>其实大家肯定早就想到了，git这么优秀的工具，怎么可能会让浪费磁盘空间的事情发生呢？既然多个文件的内容相同，肯定只保存一个对象，让它们引用到这里来就好了。</p>
<h3 id="文件改动对应新对象"><a href="#文件改动对应新对象" class="headerlink" title="文件改动对应新对象"></a>文件改动对应新对象</h3><p>现在我们猜测工作区的文件和<code>objects</code>目录中的对象是一一对应起来的。但事实真的是这样吗？<br>我们初始化一个本地仓库，新建一个markdown文件，运行<code>git add .</code>命令。现在<code>objects</code>目录中已经有了一个对象。然后往文件中添加内容<code>## git is awesome</code>。再次运行<code>git add .</code>命令。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/objects/e6/<span class="number">9</span>de29bb2d1d6434b8b29ae775ad8c2e48c5391</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">56</span>/<span class="number">46</span>a656f6331e1b30988472fefd48686a99e10f</span></pre></td></tr></table></figure>

<p>哎，<code>objects</code>目录中出现了两个对象。第一个对象肯定对应空文件。第二个对象我们太熟悉了，对应的是添加内容后的文件。<br>再次强调，git是一个版本管理系统，文件在它这里不是主角，版本才是。刚才我们暂存了两次，可以认为暂存区现在已经有了两个版本(暂存区的版本实际上是内容备份，并不是真正的版本)。当然就需要两个对象来保存。</p>
<h3 id="文件改动全量保存"><a href="#文件改动全量保存" class="headerlink" title="文件改动全量保存"></a>文件改动全量保存</h3><p>初始化一个本地仓库，往工作区添加<code>lodash.js</code>未压缩版本，版本号是<code>4.17.11</code>，体积大约是<code>540KB</code>。运行<code>git add .</code>命令后<code>objects</code>目录下面出现一个对象，体积大约是<code>96KB</code>。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/objects/cb/<span class="number">139</span>dd81ebee6f6ed5f5a9198471f5cdc876d70</span></pre></td></tr></table></figure>

<p>我们对<code>lodash.js</code>文件内容作一个小小的改动，将版本号从<code>4.17.11</code>改为<code>4.17.10</code>，再次运行<code>git add .</code>命令。然后大家会惊奇的发现<code>objects</code>目录下有两个对象了。惊奇的不是这个，而是第二个对象的体积也是大约<code>96KB</code>。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/cb/139dd81ebee6f6ed5f5a9198471f5cdc876d70</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/bf/c087eec7e61f106df8f5149091b8790e6f3636</span></span></pre></td></tr></table></figure>

<p>明明只改了一个数字而已，第二个对象却还是这么大。<br>前面刚夸git会精打细算，怎么到这里就不知深浅了？这是因为多个文件内容相同的情况，引用到同一个对象并不会造成查询效率的降低，而暂存区的多个对象之间如果只保存增量的话，版本之间的查询和切换需要花费额外的时间，这样做是不划算的。<br>但是全量保存也不是个办法吧。然而git鱼和熊掌想兼得，它也做到了。后面会讲到。</p>
<h3 id="重命名会拆分成删除和新建两个动作"><a href="#重命名会拆分成删除和新建两个动作" class="headerlink" title="重命名会拆分成删除和新建两个动作"></a>重命名会拆分成删除和新建两个动作</h3><p>初始化一个本地仓库，新建一个文件，运行<code>git add .</code>命令。然后重命名该文件，查看状态信息。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">No commits yet</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git rm --cached &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">new</span> <span class="keyword">file</span>:   <span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes not staged <span class="keyword">for</span> commi<span class="variable">t:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git add/rm &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will <span class="keyword">be</span> committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard <span class="keyword">changes</span> in working directory)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  deleted:    <span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked <span class="keyword">file</span><span class="variable">s:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> include in what will <span class="keyword">be</span> committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">b</span>.md</span></pre></td></tr></table></figure>

<p>这是由于git的内部机制导致的。生成对象的时候，它发现仓库中叫这个名字的文件不见了，于是标记为已删除，又发现有一个新的文件名是之前没有标记过的，于是标记为未跟踪。因为它只是重命名而已，文件内容并没有改变，所以可以共享对象，并不会影响效率。</p>
<h2 id="blob对象"><a href="#blob对象" class="headerlink" title="blob对象"></a>blob对象</h2><p>git的一切秘密都在<code>.git</code>目录里。因为它拥有项目的完整信息，所以git一定是把备份存在了某个地方。git把它们存在了哪里，又是如何存储它们的呢？<br>这些备份信息，git统一称它们为对象。git总共有四种对象类型，都存在<code>.git/objects</code>目录下。<br>这一次我们只介绍blob对象。<br>它存储文件的内容和大小。当开发者把未跟踪的文件或跟踪文件的改动加入暂存区，就会生成若干blob对象。git会对blob对象进行<code>zlib</code>压缩，以减少空间占用。<br>因为它只存储内容和大小，所以两个文件即便文件名和格式完全不一样，只要内容相同，就可以共享一个blob对象。<br>注意blob对象和工作目录的文件并不是一一对应的，因为工作目录的文件几乎会被多次添加到暂存区，这时一个文件会对应多个blob对象。</p>
<h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><p>仓库的<code>.git</code>目录下面有一个文件，它就是大名鼎鼎的暂存区。<br>是的，暂存区并不是一块区域，只是一个文件，确切的说，是一个索引文件。<br>它保存了项目结构、文件名、时间戳以及blob对象的引用。<br>工作区的文件和blob对象之间就是通过这个索引文件关联起来的。</p>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>还记得我们在<code>文件改动全量保存</code>小节里讲到，git鱼和熊掌想兼得么？<br>又想全量保存，不降低检索和切换速度，又想尽可能压榨体积。git是怎么做到的呢？<br>git会定期或者在推送到远端之前对git对象进行打包处理。<br>打包的时候保存文件最新的全量版本，基于该文件的历史版本的改动则只保存diff信息。因为开发者很少会切换到较早的版本中，所以这时候效率就可以部分牺牲。<br>需要注意的是，所有的git对象都会被打包，而不仅仅是blob对象。<br>git也有一个<code>git gc</code>命令可以手动执行打包。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git gc</span></pre></td></tr><tr><td class="code"><pre><span class="line">Counting objects: <span class="number">11</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Delta compression using up to <span class="number">4</span> threads.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">9</span>/<span class="number">9</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">11</span>/<span class="number">11</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="number">11</span> (delta <span class="number">3</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span></pre></td></tr></table></figure>

<p>之前的git对象文件都不见了，<code>pack</code>文件夹多了两个文件。其中 <code>.pack</code> 后缀文件存储的就是打包前git对象文件的实际内容。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/info/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/info/packs</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/pack/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/pack/pack-99b4704a207ea3cc4924c9f0febb6ea45d4cdfd2.idx</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/pack/pack-99b4704a207ea3cc4924c9f0febb6ea45d4cdfd2.pack</span></span></pre></td></tr></table></figure>

<p>只能说，<code>git gc</code>的语义化不够好。它的功能不仅仅是垃圾回收，还有打包。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/add.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/add.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>动态代理（AOP）使用及实现原理分析</title>
    <url>/2019/12/26/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%88AOP%EF%BC%89%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="一、什么是代理？"><a href="#一、什么是代理？" class="headerlink" title="一、什么是代理？"></a>一、什么是代理？</h1><p>代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。</p>
<a id="more"></a>

<p>代理模式UML图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190830132920-220f2.png" alt="img"></p>
<p>简单结构示意图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190830132921-94ede.png" alt="img"></p>
<p>为了保持行为的一致性，代理类和委托类通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。通过代理类这中间一层，能有效控制对委托类对象的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。Java 动态代理机制以巧妙的方式近乎完美地实践了代理模式的设计理念。</p>
<h1 id="二、Java-动态代理类"><a href="#二、Java-动态代理类" class="headerlink" title="二、Java 动态代理类"></a>二、Java 动态代理类</h1><p>Java动态代理类位于java.lang.reflect包下，一般主要涉及到以下两个类：<br>(1)Interface InvocationHandler：该接口中仅定义了一个方法</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> object invoke(Object obj,<span class="function"><span class="keyword">Method</span> <span class="title">method</span>, <span class="title">Object</span>[] <span class="title">args</span>)</span></span></pre></td></tr></table></figure>

<p>在实际使用时，第一个参数obj一般是指代理类，method是被代理的方法，如上例中的request()，args为该方法的参数数组。这个抽象方法在代理类中动态实现。<br>(2)Proxy：该类即为动态代理类，其中主要包含以下内容：<br>protected Proxy(InvocationHandler h)：构造函数，用于给内部的h赋值。<br>static Class getProxyClass(<br>ClassLoader loader,<br>Class[] interfaces)：获得一个代理类，其中loader是类装载器，interfaces是真实类所拥有的全部接口的数组。<br>static Object newProxyInstance(ClassLoaderloader, Class[] interfaces,InvocationHandler h)：返回代理类的一个实例，返回后的代理类可以当作被代理类使用(可使用被代理类的在Subject接口中声明过的方法)<br>所谓DynamicProxy是这样一种class：它是在运行时生成的class，在生成它时你必须提供一组interface给它，然后该class就宣称它实现了这些interface。你当然可以把该class的实例当作这些interface中的任何一个来用。当然，这个DynamicProxy其实就是一个Proxy，它不会替你作实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工作。<br>在使用动态代理类时，我们必须实现InvocationHandler接口<br>通过这种方式，被代理的对象(RealSubject)可以在运行时动态改变，需要控制的接口(Subject接口)可以在运行时改变，控制的方式(DynamicSubject类)也可以动态改变，从而实现了非常灵活的动态代理关系。<br>动态代理步骤：</p>
<ol>
<li>创建一个实现接口InvocationHandler的类，它必须实现invoke方法</li>
<li>创建被代理的类以及接口</li>
<li>通过Proxy的静态方法</li>
</ol>
<p>newProxyInstance(ClassLoaderloader,Class[]interfaces,InvocationHandler h)创建一个代理</p>
<ol>
<li>通过代理调用方法</li>
</ol>
<h1 id="三、JDK的动态代理怎么使用？"><a href="#三、JDK的动态代理怎么使用？" class="headerlink" title="三、JDK的动态代理怎么使用？"></a>三、JDK的动态代理怎么使用？</h1><p>1、需要动态代理的接口：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jiankunking;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 需要动态代理的接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 你好</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * @param name</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * @return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> SayHello(<span class="keyword">String</span> name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 再见</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * @return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> SayGoodBye();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>2、需要代理的实际对象</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">package jiankunking;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>实际对象</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> */</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>你好</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param name</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public <span class="built_in">String</span> SayHello(<span class="built_in">String</span> name) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>再见</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public <span class="built_in">String</span> SayGoodBye() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">" good bye "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>3、调用处理器实现类（有木有感觉这里就是传说中的AOP啊）</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">package jiankunking;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>调用处理器实现类</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>每次生成动态代理类对象时都需要指定一个实现了该接口的调用处理器对象</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> */</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">InvocationHandlerImpl</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>这个就是我们要代理的真实对象</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    private <span class="built_in">Object</span> subject;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>构造方法，给我们要代理的真实对象赋初值</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param subject</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public InvocationHandlerImpl(<span class="built_in">Object</span> subject) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.subject = subject;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>该方法负责集中处理动态代理类上的所有方法调用。</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param proxy  代理类实例</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param method 被调用的方法对象</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param args   调用参数</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@throws Throwable</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public <span class="built_in">Object</span> invoke(<span class="built_in">Object</span> proxy, Method method, <span class="built_in">Object</span>[] args) throws Throwable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//在代理真实对象前我们可以添加一些自己的操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"在调用之前，我要干点啥呢？"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Method:"</span> + method);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">Object</span> returnValue = method.invoke(subject, args);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//在代理真实对象后我们也可以添加一些自己的操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"在调用之后，我要干点啥呢？"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> returnValue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>4、测试</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package jiankunking;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.lang.reflect.Proxy;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 动态代理演示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> DynamicProxyDemonstration &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//代理的真实对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Subject realSubject = <span class="keyword">new</span> <span class="constructor">RealSubject()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 即：要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        InvocationHandler handler = <span class="keyword">new</span> <span class="constructor">InvocationHandlerImpl(<span class="params">realSubject</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ClassLoader loader = handler.get<span class="constructor">Class()</span>.get<span class="constructor">ClassLoader()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Class&lt;?&gt;<span class="literal">[]</span> interfaces = realSubject.get<span class="constructor">Class()</span>.get<span class="constructor">Interfaces()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Subject subject = (Subject) <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(<span class="params">loader</span>, <span class="params">interfaces</span>, <span class="params">handler</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"动态代理对象的类型："</span> + subject.get<span class="constructor">Class()</span>.get<span class="constructor">Name()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String hello = subject.<span class="constructor">SayHello(<span class="string">"jiankunking"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(hello);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//        String goodbye = subject.SayGoodBye();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//        System.out.println(goodbye);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>5、输出结果如下：</p>
<p><img src="http://image.winrains.cn/2019/08/20190830132921-616a4.png" alt="img"></p>
<h1 id="四、动态代理怎么实现的？"><a href="#四、动态代理怎么实现的？" class="headerlink" title="四、动态代理怎么实现的？"></a>四、动态代理怎么实现的？</h1><p>从使用代码中可以看出，关键点在：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Subject subject = (Subject) <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(<span class="params">loader</span>, <span class="params">interfaces</span>, <span class="params">handler</span>)</span>;</span></pre></td></tr></table></figure>

<p>通过跟踪提示代码可以看出：当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用。<br>也就是说，当代码执行到：subject.SayHello(“jiankunking”)这句话时，会自动调用InvocationHandlerImpl的invoke方法。这是为啥呢？</p>
<blockquote>
<p>下面是代码跟分析的过程，不想看的朋友可以直接看结论</p>
</blockquote>
<p>以下代码来自:JDK1.8.0_92<br>既然生成代理对象是用的Proxy类的静态方newProxyInstance，那么我们就去它的源码里看一下它到底都做了些什么？</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Returns </span>an<span class="markdown"> instance of </span>a<span class="markdown"> proxy class for </span>the<span class="markdown"> specified interfaces</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>that dispatches method invocations to </span>the<span class="markdown"> specified invocation</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>handler.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> *</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>&#123;@code Proxy.newProxyInstance&#125; throws</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#123;@code IllegalArgumentException&#125; for </span>the<span class="markdown"> same reasons that</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#123;@code Proxy.getProxyClass&#125; does.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> *</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param   loader </span>the<span class="markdown"> class loader to define </span>the<span class="markdown"> proxy class</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param   interfaces </span>the<span class="markdown"> list of interfaces for </span>the<span class="markdown"> proxy class</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>to implement</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param   h </span>the<span class="markdown"> invocation handler to dispatch method invocations to</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@return  </span>a<span class="markdown"> proxy instance with </span>the<span class="markdown"> specified invocation handler of </span>a</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>proxy class that is defined by </span>the<span class="markdown"> specified class loader</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>and that implements </span>the<span class="markdown"> specified interfaces</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@throws  IllegalArgumentException if any of </span>the<span class="markdown"> restrictions on </span>the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>parameters that may be passed to &#123;@code getProxyClass&#125;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span></span>are<span class="markdown"> violated</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@throws  SecurityException if </span>a<span class="markdown"> security manager, <span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span></span>s<span class="xml"><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span>, is present</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>and any of </span>the<span class="markdown"> following conditions is met:</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span> </span>the<span class="markdown"> given &#123;@code loader&#125; is &#123;@code null&#125; and</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span></span>the<span class="markdown"> caller's class loader is not &#123;@code null&#125; and </span>the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>invocation of &#123;@link SecurityManager#checkPermission</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>s.checkPermission&#125; with</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>&#123;@code RuntimePermission("getClassLoader")&#125; permission</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>denies access;<span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span> for each proxy interface, &#123;@code intf&#125;,</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span></span>the<span class="markdown"> caller's class loader is not </span>the<span class="markdown"> same as or </span>an</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>ancestor of </span>the<span class="markdown"> class loader for &#123;@code intf&#125; and</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>invocation of &#123;@link SecurityManager#checkPackageAccess</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>s.checkPackageAccess()&#125; denies access to &#123;@code intf&#125;;<span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span> any of </span>the<span class="markdown"> given proxy interfaces is non-public and </span>the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>caller class is not in </span>the<span class="markdown"> same &#123;@linkplain Package runtime package&#125;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>as </span>the<span class="markdown"> non-public interface and </span>the<span class="markdown"> invocation of</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>&#123;@link SecurityManager#checkPermission s.checkPermission&#125; with</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>&#123;@code ReflectPermission("newProxyInPackage.&#123;package name&#125;")&#125;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>permission denies access.<span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@throws  NullPointerException if </span>the<span class="markdown"> &#123;@code interfaces&#125; array</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>argument or any of its elements </span>are<span class="markdown"> &#123;@code null&#125;, or</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>if </span>the<span class="markdown"> invocation handler, &#123;@code h&#125;, is</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>&#123;@code null&#125;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> */</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="built_in">Object</span> newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throws IllegalArgumentException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 检查h 不为空，否则抛异常</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Objects.requireNonNull(h);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 获得与指定类装载器和一组接口相关的代理类类型对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 通过反射获取构造函数对象并生成代理类实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 获取代理对象的构造方法（也就是$Proxy0(InvocationHandler h)）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                public Void run() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    cons.setAccessible(<span class="keyword">true</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 生成代理类的实例并把InvocationHandlerImpl的实例传给它的构造方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="built_in">Object</span>[] &#123; h &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Throwable t = e.getCause();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (t instanceof RuntimeException) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们再进去getProxyClass0方法看一下：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Generate a proxy class. Must call the checkProxyAccess method to perform</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * permission checks before calling this.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">Class</span>&lt;?&gt; getProxyClass0(ClassLoader loader, <span class="keyword">Class</span>&lt;?&gt;... interfaces) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// If the proxy class defined by the given loader implementing</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>真相还是没有来到，继续，看一下 proxyClassCache</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * a cache of proxy classes</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, <span class="keyword">Class</span>&lt;?&gt;[], <span class="keyword">Class</span>&lt;?&gt;&gt; proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span></pre></td></tr></table></figure>

<p>奥，原来用了一下缓存啊<br>那么它对应的get方法啥样呢？</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Look-up </span>the<span class="markdown"> value through </span>the<span class="markdown"> cache. This always evaluates </span>the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#123;@code subKeyFactory&#125; function and optionally evaluates</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#123;@code valueFactory&#125; function if there is no entry in </span>the<span class="markdown"> cache for given</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>pair of (key, subKey) or </span>the<span class="markdown"> entry has already been cleared.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> *</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param key</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *            </span>possibly null key</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param parameter</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *            </span>parameter used together with key to create sub-key and value</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *            </span>(</span>should<span class="markdown"> not be null)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@return </span>the<span class="markdown"> cached value (never null)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@throws NullPointerException</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *             </span>if &#123;@code parameter&#125; passed in or &#123;@code sub-key&#125; calculated</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *             </span>by &#123;@code subKeyFactory&#125; or &#123;@code value&#125; calculated by</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *             </span>&#123;@code valueFactory&#125; is null.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> */</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public V <span class="keyword">get</span>(K key, P parameter) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Objects.requireNonNull(parameter);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    expungeStaleEntries();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">Object</span> cacheKey = CacheKey.valueOf(key, refQueue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// lazily install the 2nd level valuesMap for the particular cacheKey</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ConcurrentMap&lt;<span class="built_in">Object</span>, Supplier&lt;V&gt;&gt; valuesMap = map.<span class="keyword">get</span>(cacheKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (valuesMap == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// putIfAbsent这个方法在key不存在的时候加入一个值,如果key存在就不放入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ConcurrentMap&lt;<span class="built_in">Object</span>, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                valuesMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (oldValuesMap != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            valuesMap = oldValuesMap;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// subKey from valuesMap</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">Object</span> subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.<span class="keyword">get</span>(subKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Factory <span class="keyword">factory</span> = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// supplier might be a Factory or a CacheValue&lt;V&gt; instance</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            V value = supplier.<span class="keyword">get</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// else no supplier in cache</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// or a supplier that returned null (could be a cleared CacheValue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// or a Factory that wasn't successful in installing the CacheValue)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// lazily construct a Factory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">factory</span> == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">factory</span> = <span class="keyword">new</span> Factory(key, parameter, subKey, valuesMap);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            supplier = valuesMap.putIfAbsent(subKey, <span class="keyword">factory</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// successfully installed Factory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                supplier = <span class="keyword">factory</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// else retry with winning supplier</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (valuesMap.replace(subKey, supplier, <span class="keyword">factory</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// successfully replaced</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// cleared CacheEntry / unsuccessful Factory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// with our Factory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                supplier = <span class="keyword">factory</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// retry with current supplier</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                supplier = valuesMap.<span class="keyword">get</span>(subKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们可以看到它调用了 supplier.get(); 获取动态代理类，其中supplier是Factory,这个类定义在WeakCach的内部。<br>来瞅瞅，get里面又做了什么？</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> synchronized V <span class="title">get</span>(<span class="params"></span>)</span> &#123; <span class="comment">// serialize access</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// re-check</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.<span class="keyword">get</span>(subKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (supplier != <span class="keyword">this</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// something changed while we were waiting:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// might be that we were replaced by a CacheValue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// or were removed because of failure -&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// return null to signal WeakCache.get() to retry</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// the loop</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// else still us (supplier == this)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// create new value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    V <span class="keyword">value</span> = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">value</span> = Objects.requireNonNull(valueFactory.apply(key, parameter));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="literal">null</span>) &#123; <span class="comment">// remove us on failure</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            valuesMap.<span class="keyword">remove</span>(subKey, <span class="keyword">this</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// the only path to reach here is with non-null value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    assert <span class="keyword">value</span> != <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// wrap value with CacheValue (WeakReference)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    CacheValue&lt;V&gt; cacheValue = <span class="keyword">new</span> CacheValue&lt;&gt;(<span class="keyword">value</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// try replacing us with CacheValue (this should always succeed)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (valuesMap.replace(subKey, <span class="keyword">this</span>, cacheValue)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// put also in reverseMap</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        reverseMap.put(cacheValue, Boolean.TRUE);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Should not reach here"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// successfully replaced us with new CacheValue -&gt; return the value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// wrapped by it</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">value</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>发现重点还是木有出现，但我们可以看到它调用了valueFactory.apply(key, parameter)方法：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * A factory function that generates, defines and returns the proxy class</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * given the ClassLoader and array of interfaces.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> ProxyClassFactory <span class="keyword">implements</span> BiFunction&lt;ClassLoader, <span class="keyword">Class</span>&lt;?&gt;[], <span class="keyword">Class</span>&lt;?&gt;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// prefix for all proxy class names</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// next number to use for generation of unique proxy class names</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">Class</span>&lt;?&gt; apply(ClassLoader loader, <span class="keyword">Class</span>&lt;?&gt;[] interfaces) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Map&lt;<span class="keyword">Class</span>&lt;?&gt;, <span class="keyword">Boolean</span>&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">Class</span>&lt;?&gt; intf : interfaces) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * Verify that the class loader resolves the name of this</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * interface to the same Class object.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">Class</span>&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                interfaceClass = <span class="keyword">Class</span>.forName(intf.getName(), <span class="keyword">false</span>, loader);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (interfaceClass != intf) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(intf + <span class="string">" is not visible from class loader"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * Verify that the Class object actually represents an</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * interface.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * Verify that this interface is not a duplicate.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (interfaceSet.put(interfaceClass, <span class="keyword">Boolean</span>.<span class="keyword">TRUE</span>) != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"repeated interface: "</span> + interfaceClass.getName());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String proxyPkg = <span class="keyword">null</span>; <span class="comment">// package to define proxy class in</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> accessFlags = Modifier.<span class="keyword">PUBLIC</span> | Modifier.<span class="keyword">FINAL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * Record the package of a non-public proxy interface so that the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * proxy class will be defined in the same package. Verify that all</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * non-public proxy interfaces are in the same package.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">Class</span>&lt;?&gt; intf : interfaces) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> flags = intf.getModifiers();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                accessFlags = Modifier.<span class="keyword">FINAL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                String name = intf.getName();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    proxyPkg = pkg;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"non-public interfaces from different packages"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * Choose a name for the proxy class to generate.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String proxyName = proxyPkg + proxyClassNamePrefix + num;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * Generate the specified proxy class.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> defineClass0(loader, proxyName, proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * A ClassFormatError here means that (barring bugs in the proxy</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * class generation code) there was some other invalid aspect of</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * the arguments supplied to the proxy class creation (such as</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * virtual machine limitations exceeded).</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过看代码终于找到了重点：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成字节码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">byte<span class="literal">[]</span> proxyClassFile = <span class="module-access"><span class="module"><span class="identifier">ProxyGenerator</span>.</span></span>generate<span class="constructor">ProxyClass(<span class="params">proxyName</span>, <span class="params">interfaces</span>, <span class="params">accessFlags</span>)</span>;</span></pre></td></tr></table></figure>

<p>那么接下来我们也使用测试一下，使用这个方法生成的字节码是个什么样子：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package jiankunking;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import sun.misc.ProxyGenerator;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.File;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.FileNotFoundException;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.FileOutputStream;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.IOException;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.lang.reflect.Proxy;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 动态代理演示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> DynamicProxyDemonstration &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//代理的真实对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Subject realSubject = <span class="keyword">new</span> <span class="constructor">RealSubject()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 即：要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        InvocationHandler handler = <span class="keyword">new</span> <span class="constructor">InvocationHandlerImpl(<span class="params">realSubject</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ClassLoader loader = handler.get<span class="constructor">Class()</span>.get<span class="constructor">ClassLoader()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Class<span class="literal">[]</span> interfaces = realSubject.get<span class="constructor">Class()</span>.get<span class="constructor">Interfaces()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Subject subject = (Subject) <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(<span class="params">loader</span>, <span class="params">interfaces</span>, <span class="params">handler</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"动态代理对象的类型："</span>+subject.get<span class="constructor">Class()</span>.get<span class="constructor">Name()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String hello = subject.<span class="constructor">SayHello(<span class="string">"jiankunking"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(hello);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 将生成的字节码保存到本地，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        create<span class="constructor">ProxyClassFile()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> static void create<span class="constructor">ProxyClassFile()</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String name = <span class="string">"ProxySubject"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        byte<span class="literal">[]</span> data = <span class="module-access"><span class="module"><span class="identifier">ProxyGenerator</span>.</span></span>generate<span class="constructor">ProxyClass(<span class="params">name</span>,<span class="params">new</span> Class[]&#123;Subject.<span class="params">class</span>&#125;)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        FileOutputStream out =null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            out = <span class="keyword">new</span> <span class="constructor">FileOutputStream(<span class="params">name</span>+<span class="string">".class"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println((<span class="keyword">new</span> <span class="constructor">File(<span class="string">"hello"</span>)</span>).get<span class="constructor">AbsolutePath()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            out.write(data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.print<span class="constructor">StackTrace()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; catch (IOException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.print<span class="constructor">StackTrace()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;finally &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(null!=out) <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                out.close<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; catch (IOException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                e.print<span class="constructor">StackTrace()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看一下这里代理对象的类型：</p>
<p><img src="http://image.winrains.cn/2019/08/20190830132922-3ea54.png" alt="img"></p>
<p>我们用jd-jui 工具将生成的字节码反编译：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jiankunking.Subject;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> final <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">Proxy</span></span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Subject</span></span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> ProxySubject(InvocationHandler paramInvocationHandler) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">super</span>(paramInvocationHandler);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> final boolean equals(Object paramObject) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> ((Boolean) <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="type">Object</span>[] &#123; paramObject &#125;)).booleanValue();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Error | RuntimeException localError) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> localError;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> final <span class="keyword">String</span> SayGoodBye() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> (<span class="keyword">String</span>) <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Error | RuntimeException localError) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> localError;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> final <span class="keyword">String</span> SayHello(<span class="keyword">String</span> paramString) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> (<span class="keyword">String</span>) <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m4, <span class="keyword">new</span> <span class="type">Object</span>[] &#123; paramString &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Error | RuntimeException localError) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> localError;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> final <span class="keyword">String</span> toString() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> (<span class="keyword">String</span>) <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m2, <span class="literal">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Error | RuntimeException localError) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> localError;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> final int hashCode() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> ((Integer) <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m0, <span class="literal">null</span>)).intValue();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Error | RuntimeException localError) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> localError;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">new</span> <span class="type">Class</span>[] &#123; Class.forName(<span class="string">"java.lang.Object"</span>) &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m3 = Class.forName(<span class="string">"jiankunking.Subject"</span>).getMethod(<span class="string">"SayGoodBye"</span>, <span class="keyword">new</span> <span class="type">Class</span>[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m4 = Class.forName(<span class="string">"jiankunking.Subject"</span>).getMethod(<span class="string">"SayHello"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">new</span> <span class="type">Class</span>[] &#123; Class.forName(<span class="string">"java.lang.String"</span>) &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> <span class="type">Class</span>[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> <span class="type">Class</span>[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException localNoSuchMethodException) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchMethodError</span>(localNoSuchMethodException.getMessage());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException localClassNotFoundException) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoClassDefFoundError</span>(localClassNotFoundException.getMessage());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这就是最终真正的代理类，它继承自Proxy并实现了我们定义的Subject接口，也就是说：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Subject subject = (Subject) <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(<span class="params">loader</span>, <span class="params">interfaces</span>, <span class="params">handler</span>)</span>;</span></pre></td></tr></table></figure>

<p>这里的subject实际是这个类的一个实例，那么我们调用它的：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">String</span> SayHello(<span class="keyword">String</span> paramString)</span></pre></td></tr></table></figure>

<p>就是调用我们定义的InvocationHandlerImpl的 invoke方法：</p>
<p><img src="http://image.winrains.cn/2019/08/20190830132923-38112.png" alt="img"></p>
<blockquote>
<p>上面是代码跟分析的过程，不想看的朋友可以直接看结论</p>
</blockquote>
<h1 id="五、结论"><a href="#五、结论" class="headerlink" title="五、结论"></a>五、结论</h1><p>到了这里，终于解答了：<br>subject.SayHello(“jiankunking”)这句话时，为什么会自动调用InvocationHandlerImpl的invoke方法？<br>因为JDK生成的最终真正的代理类，它继承自Proxy并实现了我们定义的Subject接口，在实现Subject接口方法的内部，通过反射调用了InvocationHandlerImpl的invoke方法。<br>通过分析代码可以看出Java 动态代理，具体有如下四步骤：</p>
<ol>
<li>通过实现 InvocationHandler 接口创建自己的调用处理器；</li>
<li>通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；</li>
<li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li>
<li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li>
</ol>
<p>演示代码下载： <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fjiankunking%2FDynamicProxyDemo">github.com/jiankunking…</a></p>
<blockquote>
<p>作者：衣舞晨风</p>
<p>来源：<a href="https://juejin.im/post/5d31c1b7f265da1b9421845d" target="_blank" rel="noopener">https://juejin.im/post/5d31c1b7f265da1b9421845d</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL探索（8）：InnoDB的事务</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%888%EF%BC%89%EF%BC%9AInnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>事务是数据库最为重要的机制之一，凡是使用过数据库的人，都了解数据库的事务机制，也对ACID四个基本特性如数家珍。但是聊起事务或者ACID的底层实现原理，往往言之不详，不明所以。所以，今天我们就一起来分析和探讨InnoDB的事务机制，希望能建立起对事务底层实现原理的具体了解。</p>
<a id="more"></a>

<p><img src="http://image.winrains.cn/2019/10/20191031175432-e26fb.jpeg" alt="img"></p>
<p>事务的四大特性</p>
<p>数据库事务具有ACID四大特性。ACID是以下4个词的缩写：</p>
<ul>
<li>原子性(atomicity) ：事务最小工作单元，要么全成功，要么全失败 。</li>
<li>一致性(consistency)： 事务开始和结束后，数据库的完整性不会被破坏 。</li>
<li>隔离性(isolation) ：不同事务之间互不影响，四种隔离级别为RU（读未提交）、RC（读已提交）、RR（可重复读）、SERIALIZABLE （串行化）。</li>
<li>持久性(durability) ：事务提交后，对数据的修改是永久性的，即使系统故障也不会丢失 。</li>
</ul>
<p>下面，我们就以一个具体实例来介绍数据库事务的原理，并介绍InnoDB是如何实现ACID四大特性的。</p>
<h2 id="示例介绍"><a href="#示例介绍" class="headerlink" title="示例介绍"></a>示例介绍</h2><p>我们首先来看一下具体的示例。大家可以自己亲自试验一下，这样理解和记忆都会更加深刻。<br>首先，使用如下的SQL语句创建两张表，分别是goods和trade，代表货物和交易。并向goods表中插入一条记录，id为1的货物数量为10。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> goods (<span class="keyword">id</span> <span class="built_in">INT</span>, <span class="keyword">num</span> <span class="built_in">INT</span>, PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> trade (<span class="keyword">id</span> <span class="built_in">INT</span>, goods_id <span class="built_in">INT</span>, user_id <span class="built_in">INT</span>, PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> goods <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">10</span>);</span></pre></td></tr></table></figure>

<p>然后打开终端，连接数据库，开启会话一，先用BEGIN显示开启一个事务。会话一先将goods表中id为1的货物的数量减一，然后向trade表中添加一笔交易的记录，最后使用COMMIT显示提交事务。<br>而会话二则先查询goods表中id为1的货物数量，然后向trade表中添加一笔交易记录，接着更新goods表中id为1的货物的数量，最后使用ROLLBACK进行事务的回滚。其中，两个会话中执行的具体语句和先后顺序如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175433-821a1.jpeg" alt="img"></p>
<p>示例具体语句和执行顺序</p>
<p>这个示例可以体现数据库事务的很多特性，我们一一来介绍。首先会话一的操作2更新了id为1的货物的数量，但是会话二的操作5读出来的数量仍然是10，这体现了事务的隔离性，使用InnoDB的<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483698&idx=1&sn=3654042755c7ea0922e5d5b462930946&chksm=fc04c552cb734c443f771eb2075cd4d4ce85df85105805667cc4cf51a67ceed2f9ebdf1a8cde&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">多版本控制机制</a>实现。<br>会话二的操作7也要更新同种货物的数量，此时因为会话一的操作2已经更新了该货物的数量，InnoDB已经锁住了该记录的行锁，所以操作7会被阻塞，直到会话一COMMIT。但是会话一的操作4和会话二的操作7都是向trade表中插入记录，后者却不会因为前者而阻塞，因为二者插入的不是同一行记录。锁机制是一种常见的并发控制机制，它和多版本控制机制一起实现了InnoDB事务的隔离性，关于InnoDB锁相关的具体内容可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483694&idx=1&sn=671ad369f67441c7d1572110066d5695&chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB锁的类型和状态查询</a>和<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483702&idx=1&sn=669fb9f413db0cc744bdb5b9ec8f725e&chksm=fc04c556cb734c40b3c90a55868619b8ca1f3e1f8763be2d6e7f0568d7c992409937c33b7e10&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB行锁算法</a>。</p>
<p>会话一事务最终使用COMMIT提交了事务而会话二事务则使用ROLLBACK回滚了整个事务，这体现了事务的原子性。即事务的一系列操作要么全部执行(COMMIT)，要么就全部不执行(ROLLBACK)，不存在只执行一部分的情况。InnoDB使用事务日志系统来实现事务的原子性。这里有的同学就会问了，如果中途连接断开或者Server Crash会怎么样。能怎么样，直接自动回滚呗。</p>
<p>一旦会话一使用COMMIT操作提交事务成功后，那么数据一定会被写入到数据库中并持久的存储起来，这体现了事务的持久性。InnoDB使用<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483683&idx=1&sn=5225ab3481c38bb57297a36df8e62bce&chksm=fc04c543cb734c556574f9e5331ab70f0c8239d70197f70015f58d4ac3f5c4d0b1260f0478e3&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">redo log机制</a>来实现事务的持久性。</p>
<p>而事务的一致性比较难以理解，简单的讲在事务开始时，此时数据库有一种状态，这个状态是所有的MySQL对象处于一致的状态，例如数据库完整性约束正确，日志状态一致等。当事务提交后，这时数据库又有了一个新的状态，不同的数据，不同的索引，不同的日志等。但此时，约束，数据，索引，日志等MySQL各种状态还是要保持一致性。 也就是说数据库从一个一致性的状态，变到另一个一致性的状态。事务执行后，并没有破坏数据库的完整性约束。</p>
<p>下面我们就来详细讲解一下上述示例涉及的事务的ACID特性的具体实现原理。<strong>总结来说，事务的隔离性由多版本控制机制和锁实现，而原子性、一致性和持久性通过InnoDB的redo log、undo log和Force Log at Commit机制来实现</strong>。</p>
<h2 id="原子性，持久性和一致性"><a href="#原子性，持久性和一致性" class="headerlink" title="原子性，持久性和一致性"></a>原子性，持久性和一致性</h2><p>原子性，持久性和一致性主要是通过redo log、undo log和Force Log at Commit机制机制来完成的。redo log用于在崩溃时恢复数据，undo log用于对事务的影响进行撤销，也可以用于多版本控制。而Force Log at Commit机制保证事务提交后redo log日志都已经持久化。<br>开启一个事务后，用户可以使用COMMIT来提交，也可以用ROLLBACK来回滚。其中COMMIT或者ROLLBACK执行成功之后，数据一定是会被全部保存或者全部回滚到最初状态的，这也体现了事务的原子性。但是也会有很多的异常情况，比如说事务执行中途连接断开，或者是执行COMMIT或者ROLLBACK时发生错误，Server Crash等，此时数据库会自动进行回滚或者重启之后进行恢复。</p>
<p>我们先来看一下redo log的原理，redo log顾名思义，就是重做日志，每次数据库的SQL操作导致的数据变化它都会记录一下，<strong>具体来说，redo log是物理日志，记录的是数据库页的物理修改操作</strong>。如果数据发生了丢失，数据库可以根据redo log进行数据恢复。</p>
<p>InnoDB通过Force Log at Commit机制实现事务的持久性，即当事务COMMIT时，必须先将该事务的所有日志都写入到redo log文件进行持久化之后，COMMIT操作才算完成。<br>当事务的各种SQL操作执行时，即会在缓冲区中修改数据，也会将对应的redo log写入它所属的缓存。当事务执行COMMIT时，与该事务相关的redo log缓冲必须都全部刷新到磁盘中之后COMMIT才算执行成功。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175433-e6413.png" alt="img"></p>
<p>数据库日志和数据落盘机制</p>
<p>redo log写入磁盘时，必须进行一次操作系统的fsync操作，防止redo log只是写入了操作系统的磁盘缓存中。参数innodb_flush_log_at_trx_commit可以控制redo log日志刷新到磁盘的策略，它的具体作用可以查阅<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483683&idx=1&sn=5225ab3481c38bb57297a36df8e62bce&chksm=fc04c543cb734c556574f9e5331ab70f0c8239d70197f70015f58d4ac3f5c4d0b1260f0478e3&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB的磁盘文件及落盘机制</a></p>
<p>redo log全部写入磁盘后事务就算COMMIT成功了，但是此时事务修改的数据还在内存的缓冲区中，称其为脏页，这些数据会依据检查点(CheckPoint)机制择时刷新到磁盘中，然后删除相应的redo log，但是如果在这个过程中数据库Crash了，那么数据库重启时，会依据redo log file将那些还在内存中未更新到磁盘上的数据进行恢复。</p>
<p>数据库为了提高性能，数据页在内存修改后并不是每次都会刷到磁盘上。而是引入checkpoint机制，择时将数据页落盘，checkpoint记录之前的数据页保证一定落盘了，这样相关的redo log就没有用了(由于InnoDB redo log file循环使用，这时这部分日志就可以被覆盖)，checkpoint之后的数据页有可能落盘，也有可能没有落盘，所以checkpoint之后的redo log file在崩溃恢复的时候还是需要被使用的。InnoDB会依据脏页的刷新情况，定期推进checkpoint，从而减少数据库崩溃恢复的时间。检查点的信息在第一个日志文件的头部。</p>
<p>数据库崩溃重启后需要从redo log中把未落盘的脏页数据恢复出来，重新写入磁盘，保证用户的数据不丢失。当然，在崩溃恢复中还需要回滚没有提交的事务。由于回滚操作需要undo日志的支持，undo日志的完整性和可靠性需要redo日志来保证，所以崩溃恢复先做redo恢复数据，然后做undo回滚。</p>
<p>在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175434-53e31.jpeg" alt="img"></p>
<p>数据和回滚日志的逻辑存储结构.jpg</p>
<p>undo log的存储不同于redo log，它存放在数据库内部的一个特殊的段(segment)中，这个段称为回滚段。回滚段位于共享表空间中。undo段中的以undo page为更小的组织单位。undo page和存储数据库数据和索引的页类似。因为redo log是物理日志，记录的是数据库页的物理修改操作。所以undo log的写入也会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。如上图所示，表空间中有回滚段和叶节点段和非叶节点段，而三者都有对应的页结构。</p>
<p>我们再来总结一下数据库事务的整个流程，如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175434-1e1c3.jpeg" alt="img"></p>
<p>事务的相关流程</p>
<p>事务进行过程中，每次sql语句执行，都会记录undo log和redo log，然后更新数据形成脏页，然后redo log按照时间或者空间等条件进行落盘，undo log和脏页按照checkpoint进行落盘，落盘后相应的redo log就可以删除了。此时，事务还未COMMIT，如果发生崩溃，则首先检查checkpoint记录，使用相应的redo log进行数据和undo log的恢复，然后查看undo log的状态发现事务尚未提交，然后就使用undo log进行事务回滚。事务执行COMMIT操作时，会将本事务相关的所有redo log都进行落盘，只有所有redo log落盘成功，才算COMMIT成功。然后内存中的数据脏页继续按照checkpoint进行落盘。如果此时发生了崩溃，则只使用redo log恢复数据。</p>
<h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>InnoDB事务的隔离性主要通过多版本控制机制和锁机制实现，具体可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483698&idx=1&sn=3654042755c7ea0922e5d5b462930946&chksm=fc04c552cb734c443f771eb2075cd4d4ce85df85105805667cc4cf51a67ceed2f9ebdf1a8cde&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">多版本控制</a>，<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483694&idx=1&sn=671ad369f67441c7d1572110066d5695&chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB锁的类型和状态查询</a>和<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483702&idx=1&sn=669fb9f413db0cc744bdb5b9ec8f725e&chksm=fc04c556cb734c40b3c90a55868619b8ca1f3e1f8763be2d6e7f0568d7c992409937c33b7e10&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB行锁算法</a>三篇文章。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本来想一篇文章将MySQL的事务机制讲明白，写完自己读了一遍，还是发现内容有些晦涩难懂，复杂的知识本来就是很难讲明白的，夫夷以近，则游者众；险以远，则至者少，希望读者以本文作为一篇指引性的文章，自己再去更加深入的地方去探秘。不过，能将复杂知识讲解的通俗简单也是一项很大的本领，文字和讲解能力还是需要提示的。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/42d4385c32bb" target="_blank" rel="noopener">https://www.jianshu.com/p/42d4385c32bb</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（7）：InnoDB行锁算法</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%887%EF%BC%89%EF%BC%9AInnoDB%E8%A1%8C%E9%94%81%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>在上一篇<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483698&idx=1&sn=3654042755c7ea0922e5d5b462930946&chksm=fc04c552cb734c443f771eb2075cd4d4ce85df85105805667cc4cf51a67ceed2f9ebdf1a8cde&token=731065842&lang=zh_CN#rd" target="_blank" rel="noopener">《InnoDB一致性非锁定读》</a>中，我们了解到InnoDB使用一致性非锁定读来避免在一般的查询操作(SELECT FOR UPDATE等除外)时使用锁。然而锁这个事情是无法避免的，数据的写入，修改和删除都需要加锁。今天我们就继续学习InnoDB锁相关的知识。</p>
<a id="more"></a>

<p>由于文章涉及的概念比较多，害怕大家看完后会骂人，有一种字我都认识，就不太懂的感觉，文章会给出一些实例和试验，依据具体案例来讲解这些概念。毕竟，实践才能出真知。</p>
<p>InnoDB存储引擎支持表锁和行锁。顾名思义，表锁是锁住整张表，行锁只是锁住某些行。InnoDB通过给索引项加锁来实现行锁，如果没有索引，则通过隐藏的聚簇索引来对记录加锁。如果操作不通过索引条件检索数据，InnoDB 则对表中的所有记录加锁，实际效果就和表锁一样。InnoDB存储引擎有3种行锁的算法，分别是：</p>
<ul>
<li>Record Lock: 单个记录上的锁</li>
<li>Gap Lock: 间隙锁，锁定一个范围，但不包括记录本上</li>
<li>Next-Key Lock: Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身</li>
</ul>
<p>如下图所示，</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175010-58b28.jpeg" alt="img"></p>
<p>三种锁算法</p>
<p>例如一个索引有10,11,13,20这四个值。InnoDB可以根据需要使用Record Lock将10，11，13，20四个索引锁住，也可以使用Gap Lock将(-∞,10)，(10,11)，(11,13)，(13,20)，(20, +∞)五个范围区间锁住。Next-Key Locking类似于上述两种锁的结合，它可以锁住的区间有为(-∞,10]，(10,11]，(11,13]，(13,20]，(20, +∞)，可以看出它即锁定了一个范围，也会锁定记录本身。</p>
<p>InnoDB存储引擎的锁算法的一些规则如下所示，后续章节会给出对应的实验案例和详细讲解。</p>
<ul>
<li>在不通过索引条件查询时，InnoDB 会锁定表中的所有记录。所以，如果考虑性能，WHERE语句中的条件查询的字段都应该加上索引。</li>
<li>InnoDB通过索引来实现行锁，而不是通过锁住记录。因此，当操作的两条不同记录拥有相同的索引时，也会因为行锁被锁而发生等待。</li>
<li>由于InnoDB的索引机制，数据库操作使用了主键索引，InnoDB会锁住主键索引；使用非主键索引时，InnoDB会先锁住非主键索引，再锁定主键索引。</li>
<li>当查询的索引是唯一索引(不存在两个数据行具有完全相同的键值)时，InnoDB存储引擎会将Next-Key Lock降级为Record Lock，即只锁住索引本身，而不是范围。</li>
<li>InnoDB对于辅助索引有特殊的处理，不仅会锁住辅助索引值所在的范围，还会将其下一键值加上Gap LOCK。</li>
<li>InnoDB使用Next-Key Lock机制来避免Phantom Problem（幻读问题）。</li>
</ul>
<h2 id="真的了解本质吗"><a href="#真的了解本质吗" class="headerlink" title="真的了解本质吗?"></a>真的了解本质吗?</h2><p>在不通过索引条件查询时，InnoDB 会锁定表中的所有记录。大家可以登录上自己的MySQL服务器，亲自试验一下。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175011-8d9fc.jpeg" alt="img"></p>
<p>示例一</p>
<p>试验发现，会话二的查询操作真的是会发生等待。那么，这句话真的是对的吗？我们可以使用<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483694&idx=1&sn=671ad369f67441c7d1572110066d5695&chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&token=731065842&lang=zh_CN#rd" target="_blank" rel="noopener">《InnoDB锁的类型和状态查询》</a>中查询数据锁的方法查询一下，<strong>注意必须在会话二操作还在等待时进行查询，否则查询不到</strong>。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175011-a2fad.png" alt="img"></p>
<p>查询锁信息</p>
<p>其中lock_trx_id为1851的事务是会话二的事务，另一个是会话一的事务。我们可以看到两个锁都要对值为1的主键索引加锁。<em>需要注意的是，这里是对主键进行加锁</em>。二者之间的关系是怎么确定的呢?我们可以通过<code>information_schema.INNODB_LOCK_WAITS</code>中的数据确定。</p>
<p>奇怪，不是说好的锁定表中的所有记录嘛？查找了很多资料，发现<code>INNODB_LOCKS</code>的定义如下：</p>
<blockquote>
<p>The INNODB_LOCKS table contains information about each lock that an InnoDB transaction has requested but not yet acquired, and each lock that a transaction holds that is blocking another transaction.</p>
</blockquote>
<p>也就是说，这张表并不会显示所有锁的信息，而是只显示要申请却没有申请到，和已经持有锁并且阻塞其他线程的锁信息。怪不得必须在会话二进行等待时进行查询才能查得到数据。</p>
<p>因为两个会话的操作都要锁住所有的行，所以发现每次在第一行记录上就发生了锁等待。那我们使用插入语句试试。表e1的主键a的值为1-4，我们分别插入主键为1-4(当然会有主键重复问题，但是由于有锁，一直等待)的新记录，分别查询锁信息，就能看到会话一的事务对所有的主键都加了锁，也就是对所有的记录都加了锁。</p>
<h2 id="是索引，而不是记录"><a href="#是索引，而不是记录" class="headerlink" title="是索引，而不是记录"></a>是索引，而不是记录</h2><p>InnoDB存储引擎的行锁是通过锁住索引实现的，而不是记录。这是理解很多数据库锁问题的关键。</p>
<p>由于InnoDB特殊的索引机制，数据库操作使用主键索引时，InnoDB会锁住主键索引；使用非主键索引时，InnoDB会先锁住非主键索引，再锁定主键索引。不了解InnoDB索引机制的可以参考这篇<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483664&idx=1&sn=a4aea45edf13b367ee17539eaff4874b&chksm=fc04c570cb734c66447aec4344288025bfe6ba7d715af31dc6d60d65411cd90a05d9b02e749d&token=731065842&lang=zh_CN#rd" target="_blank" rel="noopener">文章</a></p>
<p>如下图所示，当InnoDB锁定非主键索引b时，它也会锁住其对应的主键索引，所以锁住b值为2和3的非主键索引，那么与其相关的a值为6,5的主键索引也需要被锁住。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175013-450b9.jpeg" alt="img"></p>
<p>非主键索引的加锁</p>
<p>比如说，一种常见的死锁情况一般出现在如下图所示的操作场景中。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175013-1ca41.jpeg" alt="img"></p>
<p>示例2</p>
<p>会话一的语句使用了b上的索引，因为它是非主键索引，所以会先在b索引上添加锁，再去a索引上加锁。而会话二的语句恰恰相反，会先在索引a上加锁，再去索引b加锁。这种情况下，就可能出现死锁。</p>
<h2 id="Next-Key-Lock锁到底有什么用？"><a href="#Next-Key-Lock锁到底有什么用？" class="headerlink" title="Next-Key Lock锁到底有什么用？"></a>Next-Key Lock锁到底有什么用？</h2><p>默认隔离级别REPEATABLE-READ下，InnoDB中行锁默认使用算法Next-Key Lock，只有当查询的索引是唯一索引或主键时，InnoDB会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围。当查询的索引为辅助索引时，InnoDB则会使用Next-Key Lock进行加锁。InnoDB对于辅助索引有特殊的处理，不仅会锁住辅助索引值所在的范围，还会将其下一键值加上Gap LOCK。</p>
<p>废话不多说，我们来看一下相关的实验，先做一下准备。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> e4 (a <span class="built_in">INT</span>, b <span class="built_in">INT</span>, PRIMARY <span class="keyword">KEY</span>(a), <span class="keyword">KEY</span>(b));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">1</span>,<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">3</span>,<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">5</span>,<span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">7</span>,<span class="number">6</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">10</span>,<span class="number">8</span>;</span></pre></td></tr></table></figure>

<p>然后开启一个会话执行下面的语句。</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> e4 <span class="keyword">WHERE</span> b=<span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span></pre></td></tr></table></figure>

<p>因为通过索引b来进行查询，所以InnoDB会使用Next-Key Lock进行加锁，并且索引b是非主键索引，所以还会对主键索引a进行加锁。对于主键索引a，仅仅对值为5的索引加上Record Lock（因为之前的规则）。而对于索引b，需要加上Next-Key Lock索引，锁定的范围是(1,3]。除此之外，还会对其下一个键值加上Gap Lock，即还有一个范围为(3,6)的锁。<br>大家可以再新开一个会话，执行下面的SQL语句，会发现都会被阻塞。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> e4 <span class="keyword">WHERE</span> a = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;  <span class="comment"># 主键a被锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">4</span>,<span class="number">2</span>;   <span class="comment"># 插入行b的值为2，在锁定的(1,3]范围内</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">6</span>,<span class="number">5</span>; <span class="comment"># 插入行b的值为5，在锁定的(3,6)范围内</span></span></pre></td></tr></table></figure>

<p>InnoDB引擎采用Next-Key Lock来解决幻读问题。因为Next-Key Lock是锁住一个范围，所以就不会产生幻读问题。但是需要注意的是，InnoDB只在Repeatable Read隔离级别下使用该机制。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/7d050498d9da" target="_blank" rel="noopener">https://www.jianshu.com/p/7d050498d9da</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（6）：InnoDB一致性非锁定读</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%886%EF%BC%89%EF%BC%9AInnoDB%E4%B8%80%E8%87%B4%E6%80%A7%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB/</url>
    <content><![CDATA[<p>一致性非锁定读(consistent nonlocking read)是指InnoDB存储引擎通过多版本控制(MVVC)读取当前数据库中行数据的方式。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB会去读取行的一个快照。</p>
<a id="more"></a>

<p><img src="http://image.winrains.cn/2019/10/20191031174517-7a2e1.jpeg" alt="img"></p>
<p>一致性非锁定读示意图</p>
<p>上图直观地展现了InnoDB一致性非锁定读的机制。之所以称其为非锁定读，是因为不需要等待行上排他锁的释放。快照数据是指该行的之前版本的数据，每行记录可能有多个版本，一般称这种技术为行多版本技术。由此带来的并发控制，称之为多版本并发控制(Multi Version Concurrency Control, MVVC)。InnoDB是通过undo log来实现MVVC。undo log本身用来在事务中回滚数据，因此快照数据本身是没有额外开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。</p>
<p>一致性非锁定读是InnoDB默认的读取方式，即读取不会占用和等待行上的锁。但是并不是在每个事务隔离级别下都是采用此种方式。此外，即使都是使用一致性非锁定读，但是对于快照数据的定义也各不相同。</p>
<p>在事务隔离级别READ COMMITTED和REPEATABLE READ下，InnoDB使用一致性非锁定读。然而，对于快照数据的定义却不同。在READ COMMITTED事务隔离级别下，一致性非锁定读总是读取被锁定行的最新一份快照数据。而在REPEATABLE READ事务隔离级别下，则读取事务开始时的行数据版本。</p>
<p>我们下面举个例子来详细说明一下上述的情况。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">session</span> A</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">BEGIN</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> id = <span class="number">1</span>;</span></pre></td></tr></table></figure>

<p>我们首先在会话A中显示地开启一个事务，然后读取test表中的id为1的数据，但是事务并没有结束。于此同时，用户在开启另一个会话B，这样可以模拟并发的操作，然后对会话B做出如下的操作：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">session</span> B</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">BEGIN</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">UPDATE</span> test <span class="keyword">SET</span> id = <span class="number">3</span> <span class="keyword">WHERE</span> id = <span class="number">1</span>;</span></pre></td></tr></table></figure>

<p>在会话B的事务中，将test表中id为1的记录修改为id=3，但是事务同样也没有提交，这样id=1的行其实加了一个排他锁。由于InnoDB在READ COMMITTED和REPEATABLE READ事务隔离级别下使用一致性非锁定读，这时如果会话A再次读取id为1的记录，仍然能够读取到相同的数据。此时，READ COMMITTED和REPEATABLE READ事务隔离级别没有任何区别。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174517-65081.jpeg" alt="img"></p>
<p>会话A和会话B示意图</p>
<p>如上图所示，当会话B提交事务后，会话A再次运行<code>SELECT * FROM test WHERE id = 1</code>的SQL语句时，两个事务隔离级别下得到的结果就不一样了。<br>对于READ COMMITTED的事务隔离级别，它总是读取行的最新版本，如果行被锁定了，则读取该行版本的最新一个快照。因为会话B的事务已经提交，所以在该隔离级别下上述SQL语句的结果集是空的。<br>对于REPEATABLE READ的事务隔离级别，总是读取事务开始时的行数据，因此，在该隔离级别下，上述SQL语句仍然会获得相同的数据。</p>
<h2 id="MVVC"><a href="#MVVC" class="headerlink" title="MVVC"></a>MVVC</h2><p>我们首先来看一下wiki上对MVVC的定义：</p>
<blockquote>
<p>Multiversion concurrency control (MCC or MVCC), is a concurrency control method commonly used by database management systems to provide concurrent access to the database and in programming languages to implement transactional memory.</p>
</blockquote>
<p>由定义可知，MVVC是用于数据库提供并发访问控制的并发控制技术。<br>数据库的并发控制机制有很多，最为常见的就是锁机制。锁机制一般会给竞争资源加锁，阻塞读或者写操作来解决事务之间的竞争条件，最终保证事务的可串行化。而MVVC则引入了另外一种并发控制，它让读写操作互不阻塞，每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回，由此解决了事务的竞争条件。<br>考虑一个现实场景。管理者要查询所有用户的存款总额，假设除了用户A和用户B之外，其他用户的存款总额都为0，A、B用户各有存款1000，所以所有用户的存款总额为2000。但是在查询过程中，用户A会向用户B进行转账操作。转账操作和查询总额操作的时序图如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174517-1fed0.jpeg" alt="img"></p>
<p>转账和查询的时序图</p>
<p>如果没有任何的并发控制机制，查询总额事务先读取了用户A的账户存款，然后转账事务改变了用户A和用户B的账户存款，最后查询总额事务继续读取了转账后的用户B的账号存款，导致最终统计的存款总额多了100元，发生错误。</p>
<p>使用锁机制可以解决上述的问题。查询总额事务会对读取的行加锁，等到操作结束后再释放所有行上的锁。因为用户A的存款被锁，导致转账操作被阻塞，直到查询总额事务提交并将所有锁都释放。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174518-4a989.jpeg" alt="img"></p>
<p>使用锁机制</p>
<p>但是这时可能会引入新的问题，当转账操作是从用户B向用户A进行转账时会导致死锁。转账事务会先锁住用户B的数据，等待用户A数据上的锁，但是查询总额的事务却先锁住了用户A数据，等待用户B的数据上的锁。</p>
<p>使用MVVC机制也可以解决这个问题。查询总额事务先读取了用户A的账户存款，然后转账事务会修改用户A和用户B账户存款，查询总额事务读取用户B存款时不会读取转账事务修改后的数据，而是读取本事务开始时的数据副本(在REPEATABLE READ隔离等级下)。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174518-c3ba9.jpeg" alt="img"></p>
<p>使用MVVC机制</p>
<p>MVCC使得数据库读不会对数据加锁，普通的SELECT请求不会加锁，提高了数据库的并发处理能力。借助MVCC，数据库可以实现READ COMMITTED，REPEATABLE READ等隔离级别，用户可以查看当前数据的前一个或者前几个历史版本，保证了ACID中的I特性（隔离性)</p>
<h2 id="InnoDB的MVVC实现"><a href="#InnoDB的MVVC实现" class="headerlink" title="InnoDB的MVVC实现"></a>InnoDB的MVVC实现</h2><p>多版本并发控制仅仅是一种技术概念，并没有统一的实现标准， 其的核心理念就是数据快照，不同的事务访问不同版本的数据快照，从而实现不同的事务隔离级别。虽然字面上是说具有多个版本的数据快照，但这并不意味着数据库必须拷贝数据，保存多份数据文件，这样会浪费大量的存储空间。InnoDB通过事务的undo日志巧妙地实现了多版本的数据快照。<br>数据库的事务有时需要进行回滚操作，这时就需要对之前的操作进行undo。因此，在对数据进行修改时，InnoDB会产生undo log。当事务需要进行回滚时，InnoDB可以利用这些undo log将数据回滚到修改之前的样子。<br>根据行为的不同 undo log 分为两种 insert undo log和update undo log。<br>insert undo log 是在 insert 操作中产生的 undo log。因为 insert 操作的记录只对事务本身可见，对于其它事务此记录是不可见的，所以 insert undo log 可以在事务提交后直接删除而不需要进行 purge 操作。<br>update undo log 是 update 或 delete 操作中产生的 undo log，因为会对已经存在的记录产生影响，为了提供 MVCC机制，因此 update undo log 不能在事务提交时就进行删除，而是将事务提交时放到入 history list 上，等待 purge 线程进行最后的删除操作。<br>为了保证事务并发操作时，在写各自的undo log时不产生冲突，InnoDB采用回滚段的方式来维护undo log的并发写入和持久化。回滚段实际上是一种 Undo 文件组织方式。<br>InnoDB行记录有三个隐藏字段：分别对应该行的rowid、事务号db_trx_id和回滚指针db_roll_ptr，其中db_trx_id表示最近修改的事务的id，db_roll_ptr指向回滚段中的undo log。如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174518-74ed7.jpeg" alt="img"></p>
<p>初始状态</p>
<p>当事务2使用UPDATE语句修改该行数据时，会首先使用排他锁锁定改行，将该行当前的值复制到undo log中，然后再真正地修改当前行的值，最后填写事务ID，使用回滚指针指向undo log中修改前的行。如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174519-e14b3.jpeg" alt="img"></p>
<p>第一次修改</p>
<p>当事务3进行修改与事务2的处理过程类似，如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174519-a9e7e.jpeg" alt="img"></p>
<p>第二次修改</p>
<p>REPEATABLE READ隔离级别下事务开始后使用MVVC机制进行读取时，会将当时活动的事务id记录下来，记录到Read View中。READ COMMITTED隔离级别下则是每次读取时都创建一个新的Read View。<br>Read View是InnoDB中用于判断记录可见性的数据结构，记录了一些用于判断可见性的属性。</p>
<ul>
<li>low_limit_id：某行记录的db_trx_id &lt; 该值，则该行对于当前Read View是一定可见的</li>
<li>up_limit_id：某行记录的db_trx_id &gt;= 该值，则该行对于当前read view是一定不可见的</li>
<li>low_limit_no：用于purge操作的判断</li>
<li>rw_trx_ids：读写事务数组</li>
</ul>
<p>Read View创建后，事务再次进行读操作时比较记录的db_trx_id和Read View中的low_limit_id，up_limit_id和读写事务数组来判断可见性。</p>
<p>如果该行中的db_trx_id等于当前事务id，说明是事务内部发生的更改，直接返回该行数据。否则的话，如果db_trx_id小于up_limit_id，说明是事务开始前的修改，则该记录对当前Read View是可见的，直接返回该行数据。</p>
<p>如果db_trx_id大于或者等于low_limit_id，则该记录对于该Read View一定是不可见的。如果db_trx_id位于[up_limit_id, low_limit_id)范围内，需要在活跃读写事务数组(rw_trx_ids)中查找db_trx_id是否存在，如果存在，记录对于当前Read View是不可见的。<br>如果记录对于Read View不可见，需要通过记录的DB_ROLL_PTR指针遍历undo log，构造对当前Read View可见版本数据。<br>简单来说，Read View记录读开始时及其之后，所有的活动事务，这些事务所做的修改对于Read View是不可见的。除此之外，所有其他的小于创建Read View的事务号的所有记录均可见。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/f6d4d5c37d66" target="_blank" rel="noopener">https://www.jianshu.com/p/f6d4d5c37d66</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（5）：InnoDB锁的类型和状态查询</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%885%EF%BC%89%EF%BC%9AInnoDB%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%8A%B6%E6%80%81%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>锁是数据库系统区分于文件系统的一个关键特性。数据库使用锁来支持对共享资源进行并发访问，提供数据的完整性和一致性。此外，数据库事务的隔离性也是通过锁实现的。InnoDB在此方面一直优于其他数据库引擎。InnoDB会在行级别上对表数据上锁，而MyISAM只能在表级别上锁，二者性能差异可想而知。</p>
<a id="more"></a>

<h2 id="InnoDB存储引擎中的锁"><a href="#InnoDB存储引擎中的锁" class="headerlink" title="InnoDB存储引擎中的锁"></a>InnoDB存储引擎中的锁</h2><p>InnoDB存储引擎实现了如下两种标准的行级锁：</p>
<ul>
<li>共享锁(S Lock)，允许事务读取一行</li>
<li>排他锁(X Lock)，允许事务删除或更新一行数据</li>
</ul>
<p>如果一个事务T1已经获取了行r的共享锁，那么另外一个事务T2可以立刻获得行r的共享锁，因为读取并不会改变数据，可以进行并发的读取操作；但若其他的事务T3想要获取行r的排他锁，则必须等待事务T1和T2释放行r上的共享锁之后才能继续，因为获取排他锁一般是为了改变数据，所以不能同时进行读取或则其他写入操作。</p>
<table>
<thead>
<tr>
<th></th>
<th>X</th>
<th>S</th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>S</td>
<td>不兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p>InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种称为意向锁的锁方式。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。</p>
<p>InnoDB存储引擎的意向锁即为表级别的锁。设计目的主要是为了在一个事务中揭示下一行将被请求的锁类型。其支持两种意向锁：</p>
<ul>
<li>意向共享锁(IS Lock)，事务想要获得一张表中某几行的共享锁</li>
<li>意向排他锁(IX Lock)，事务想要获得一张表中某几行的排他锁</li>
</ul>
<p>需要注意的是意向锁是表级别的锁，它不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。故表级别的意向锁和表级别的锁的兼容性如下表所示。</p>
<table>
<thead>
<tr>
<th></th>
<th>IS</th>
<th>IX</th>
<th>S</th>
<th>X</th>
</tr>
</thead>
<tbody><tr>
<td>IS</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>IX</td>
<td>兼容</td>
<td>兼容</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>S</td>
<td>兼容</td>
<td>不兼容</td>
<td>兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>X</td>
<td>不兼容</td>
<td>不兼容</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
</tbody></table>
<p>向一个表添加表级X锁的时候(执行ALTER TABLE, DROP TABLE, LOCK TABLES等操作)，如果没有意向锁的话，则需要遍历所有整个表判断是否有行锁的存在，以免发生冲突。如果有了意向锁，只需要判断该意向锁与即将添加的表级锁是否兼容即可。因为意向锁的存在代表了，有行级锁的存在或者即将有行级锁的存在，因而无需遍历整个表，即可获取结果。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174021-c0450.jpeg" alt="img"></p>
<p>层次结构.jpg</p>
<p>如果将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。如上图所示，如果需要对表1的记录m行上X锁，那么需要先对表1加意向IX锁，然后对记录m上X锁。如果其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成。</p>
<h2 id="InnoDB锁相关状态查询"><a href="#InnoDB锁相关状态查询" class="headerlink" title="InnoDB锁相关状态查询"></a>InnoDB锁相关状态查询</h2><p>用户可以使用INFOMATION_SCHEMA库下的INNODB_TRX、INNODB_LOCKS和INNODB_LOCK_WAITS表来监控当前事务并分析可能出现的锁问题。INNODB_TRX的定义如下表所示，其由8个字段组成。</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>trx_id</td>
<td>InnoDB存储引擎内部唯一的事务ID</td>
</tr>
<tr>
<td>trx_state</td>
<td>当前事务的状态</td>
</tr>
<tr>
<td>trx_started</td>
<td>事务的开始时间</td>
</tr>
<tr>
<td>trx_request_lock_id</td>
<td>等待事务的锁ID。如果trx_state的状态为LOCK WAIT,那么该字段代表当前事务等待之前事务占用的锁资源ID</td>
</tr>
<tr>
<td>trx_wait_started</td>
<td>事务等待的时间</td>
</tr>
<tr>
<td>trx_weight</td>
<td>事务的权重，反映了一个事务修改和锁住的行数，当发生死锁需要回滚时，会选择该数值最小的进行回滚</td>
</tr>
<tr>
<td>trx_mysql_thread_id</td>
<td>线程ID，SHOW PROCESSLIST 显示的结果</td>
</tr>
<tr>
<td>trx_query</td>
<td>事务运行的SQL语句</td>
</tr>
</tbody></table>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM information_schema.INNODB_TRX\G;</span></pre></td></tr><tr><td class="code"><pre><span class="line">************************************* <span class="number">1.</span>row *********************************************</span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_id:  <span class="number">7311</span>F4</span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_state: LOCK WAIT</span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_started: <span class="number">2010</span><span class="number">-01</span><span class="number">-04</span> <span class="number">10</span>:<span class="number">49</span>:<span class="number">33</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_requested_lock_id: <span class="number">7311</span>F4:<span class="number">96</span>:<span class="number">3</span>:<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_wait_started: <span class="number">2010</span><span class="number">-01</span><span class="number">-04</span> <span class="number">10</span>:<span class="number">49</span>:<span class="number">33</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_weight: <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_mysql_thread_id: <span class="number">471719</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_query: select * <span class="keyword">from</span> parent lock <span class="keyword">in</span> share mode</span></pre></td></tr></table></figure>

<p>INNODB_TRX表只能显示当前运行的InnoDB事务，并不能直接判断锁的一些情况。如果需要查看锁，则还需要访问表INNODB_LOCKS，该表的字段组成如下表所示。</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock_id</td>
<td>锁的ID</td>
</tr>
<tr>
<td>lock_trx_id</td>
<td>事务的ID</td>
</tr>
<tr>
<td>lock_mode</td>
<td>锁的模式</td>
</tr>
<tr>
<td>lock_type</td>
<td>锁的类型，表锁还是行锁</td>
</tr>
<tr>
<td>lock_table</td>
<td>要加锁的表</td>
</tr>
<tr>
<td>lock_index</td>
<td>锁住的索引</td>
</tr>
<tr>
<td>lock_space</td>
<td>锁住的space id</td>
</tr>
<tr>
<td>lock_page</td>
<td>事务锁定页的数量，若是表锁，则该值为NULL</td>
</tr>
<tr>
<td>lock_rec</td>
<td>事务锁定行的数量，如果是表锁，则该值为NULL</td>
</tr>
<tr>
<td>lock_data</td>
<td>事务锁住记录的主键值，如果是表锁，则该值为NULL</td>
</tr>
</tbody></table>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM information<span class="emphasis">_schema.INNODB_</span>LOCKS\G;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">**** 1.row **</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_id: 7311F4:96:3:2</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock<span class="emphasis">_trx_</span>id: 7311F4</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_mode: S</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_type: RECORD</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_type: 'mytest'.'parent'</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_index: 'PRIMARY'</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_space: 96</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_page: 3</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_rec: 2</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_data: 1</span></pre></td></tr></table></figure>

<p>通过表INNODB_LOCKS查看每张表上锁的情况后，用户就可以来判断由此引发的等待情况。当时当事务量非常大，其中锁和等待也时常发生，这个时候就不那么容易判断。但是通过表INNODB_LOCK_WAITS，可以很直观的反应当前事务的等待。表INNODB_LOCK_WAITS由四个字段组成，如下表所示。</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>requesting_trx_id</td>
<td>申请锁资源的事务ID</td>
</tr>
<tr>
<td>requesting_lock_id</td>
<td>申请的锁的ID</td>
</tr>
<tr>
<td>blocking_trx_id</td>
<td>阻塞的事务ID</td>
</tr>
<tr>
<td>blocking_lock_id</td>
<td>阻塞的锁的ID</td>
</tr>
</tbody></table>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM information<span class="emphasis">_schema.INNODB_</span>LOCK_WAITS\G;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">***1.row**</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span>*</span></pre></td></tr><tr><td class="code"><pre><span class="line">requesting<span class="emphasis">_trx_</span>id: 7311F4</span></pre></td></tr><tr><td class="code"><pre><span class="line">requesting<span class="emphasis">_lock_</span>id: 7311F4:96:3:2</span></pre></td></tr><tr><td class="code"><pre><span class="line">blocking<span class="emphasis">_trx_</span>id: 730FEE</span></pre></td></tr><tr><td class="code"><pre><span class="line">blocking<span class="emphasis">_lock_</span>id: 730FEE:96:3:2</span></pre></td></tr></table></figure>

<p>通过上述的SQL语句，用户可以清楚直观地看到哪个事务阻塞了另一个事务，然后使用上述的事务ID和锁ID，去INNODB_TRX和INNDOB_LOCKS表中查看更加详细的信息。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/160371211b10" target="_blank" rel="noopener">https://www.jianshu.com/p/160371211b10</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（4）：InnoDB的磁盘文件及落盘机制</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%884%EF%BC%89%EF%BC%9AInnoDB%E7%9A%84%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E5%8F%8A%E8%90%BD%E7%9B%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>任何一个技术都有其底层的关键基础技术，这些关键技术很有可能也是其他技术的关键技术，学习这些底层技术，就可以一通百通，让你很快的掌握其他技术。如何在磁盘上存储数据，如何使用日志文件保证数据不丢失以及如何落盘，不仅是MySQL等数据库的关键技术，也是MQ消息队列或者其他中间件的关键技术之一。</p>
<a id="more"></a>

<p><img src="http://image.winrains.cn/2019/10/20191031173512-1a975.png" alt="img"></p>
<p>InnoDB整体架构</p>
<p>上图详细显示了InnoDB存储引擎的体系架构，从图中可见，InnoDB存储引擎由内存池，后台线程和磁盘文件三大部分组成。接下来我们就来简单了解一下磁盘文件相关的概念和原理。</p>
<p>InnoDB的主要的磁盘文件主要分为三大块：一是系统表空间，二是用户表空间，三是redo日志文件和归档文件。二进制文件(binlog)等文件是MySQL Server层维护的文件，所以未列入InnoDB的磁盘文件中。</p>
<h2 id="系统表空间和用户表空间"><a href="#系统表空间和用户表空间" class="headerlink" title="系统表空间和用户表空间"></a>系统表空间和用户表空间</h2><p>InnoDB系统表空间包含InnoDB数据字典(元数据以及相关对象)并且doublewrite buffer,change buffer,undo logs的存储区域。系统表空间也默认包含任何用户在系统表空间创建的表数据和索引数据。系统表空间是一个共享的表空间因为它是被多个表共享的</p>
<p>系统表空间是由一个或者多个数据文件组成。默认情况下,1个初始大小为10MB，名为ibdata1的系统数据文件在MySQL的data目录下被创建。用户可以使用innodb_data_file_path对数据文件的大小和数量进行配置。</p>
<p>innodb_data_file_path的格式如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">innodb_data_file_path</span>=datafile1[,datafile2]<span class="built_in">..</span>.</span></pre></td></tr></table></figure>

<p>用户可以通过多个文件组成一个表空间，同时制定文件的属性：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">innodb_data_file_path = <span class="regexp">/db/</span><span class="string">ibdata1:</span><span class="number">1000</span>M;<span class="regexp">/dr2/</span>db/<span class="string">ibdata2:</span><span class="number">1000</span><span class="string">M:</span>autoextend</span></pre></td></tr></table></figure>

<p>这里讲/db/ibdata1和/dr2/db/ibdata2两个文件组成系统表空间。如果这两个文件位于不同的磁盘上，磁盘的负载可能被平均，因此可以提高数据库的整体性能。两个文件的文件名之后都跟了属性，表示文件ibdata1的大小为1000MB，文件ibdata2的大小为1000MB，而且用完空间之后可以自动增长(autoextend)。</p>
<p>设置innodb_data_file_path参数之后，所以基于InnoDB存储引擎的表的数据都会记录到该系统表空间中，如果设置了参数innodb_file_per_table，则用户可以将每个基于InnoDB存储引擎的表产生一个独立的用户表空间。用户表空间的命名规则为：表名.ibd。<br>通过这种方式，用户不用将所有数据都存放于默认的系统表空间中，但是用户表空只存储该表的数据、索引和插入缓冲BITMAP等信息，其余信息还是存放在默认的表空间中。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031173513-39774.png" alt="img"></p>
<p>InnoDB表存储引擎文件</p>
<p>上图显示InnoDB存储引擎对于文件的存储方式，其中frm文件是表结构定义文件，记录每个表的表结构定义。</p>
<h2 id="重做日志文件和归档文件"><a href="#重做日志文件和归档文件" class="headerlink" title="重做日志文件和归档文件"></a>重做日志文件和归档文件</h2><p>默认情况下，在InnoDB存储引擎的数据目录下会有两个名为ib_logfile0和ib_logfile1的文件，这就是InnoDB的重做日志文件(redo log fiel)，它记录了对于InnoDB存储引擎的事务日志。<br>当InnoDB的数据存储文件发生错误时，重做日志文件就能派上用场。InnoDB存储引擎可以使用重做日志文件将数据恢复为正确状态，以此来保证数据的正确性和完整性。</p>
<p>每个InnoDB存储引擎至少有1个重做日志文件组(group)，每个文件组下至少有2个重做日志文件，如默认的ib_logfile0和ib_logfile1。<br>为了得到更高的可靠性，用户可以设置多个镜像日志组，将不同的文件组放在不同的磁盘上，以此来提高重做日志的高可用性。</p>
<p>在日志组中每个重做日志文件的大小一致，并以循环写入的方式运行。InnoDB存储引擎先写入重做日志文件1，当文件被写满时，会切换到重做日志文件2，再当重做日志文件2也被写满时，再切换到重做日志文件1。</p>
<p>用户可以使用innodb_log_file_size来设置重做日志文件的大小，这对InnoDB存储引擎的性能有着非常大的影响。</p>
<p>如果重做日志文件设置的太大，数据丢失时，恢复时可能需要很长的时间；另一方面，如果设置的太小，重做日志文件太小会导致依据checkpoint的检查需要频繁刷新脏页到磁盘中，导致性能的抖动。<br>重做日志相关和Checkpoint的机制可以阅读我之前文章的相应章节。<a href="https://mp.weixin.qq.com/s/JCXdP59OUvQEB3q1V9YrCA" target="_blank" rel="noopener">MySQL探秘(三):InnoDB的内存结构和特性
</a></p>
<h2 id="重做日志的落盘机制"><a href="#重做日志的落盘机制" class="headerlink" title="重做日志的落盘机制"></a>重做日志的落盘机制</h2><p>InnoDB对于数据文件和日志文件的刷盘遵守WAL(Write ahead redo log) 和Force-log-at-commit两种规则，二者保证了事务的持久性。WAL要求数据的变更写入到磁盘前，首先必须将内存中的日志写入到磁盘；Force-log-at-commit要求当一个事务提交时，所有产生的日志都必须刷新到磁盘上，如果日志刷新成功后，缓冲池中的数据刷新到磁盘前数据库发生了宕机，那么重启时，数据库可以从日志中恢复数据。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031173514-36d2a.jpeg" alt="img"></p>
<h3 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h3><p>如上图所示，InnoDB在缓冲池中变更数据时，会首先将相关变更写入重做日志缓冲中，然后再按时或者当事务提交时写入磁盘，这符合Force-log-at-commit原则；当重做日志写入磁盘后，缓冲池中的变更数据才会依据checkpoint机制择时写入到磁盘中，这符合WAL原则。<br>在checkpoint择时机制中，就有重做日志文件写满的判断，所以，如前文所述，如果重做日志文件太小，经常被写满，就会频繁导致checkpoint将更改的数据写入磁盘，导致性能抖动。</p>
<p>操作系统的文件系统是带有缓存的，当InnoDB向磁盘写入数据时，有可能只是写入到了文件系统的缓存中，没有真正的“落袋为安”。<br>InnoDB的innodb_flush_log_at_trx_commit属性可以控制每次事务提交时InnoDB的行为。当属性值为0时，事务提交时，不会对重做日志进行写入操作，而是等待主线程按时写入；当属性值为1时，事务提交时，会将重做日志写入文件系统缓存，并且调用文件系统的fsync，将文件系统缓冲中的数据真正写入磁盘存储，确保不会出现数据丢失；当属性值为2时，事务提交时，也会将日志文件写入文件系统缓存，但是不会调用fsync，而是让文件系统自己去判断何时将缓存写入磁盘。日志的刷盘机制如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031173514-227a0.png" alt="img"></p>
<h3 id="log刷盘机制"><a href="#log刷盘机制" class="headerlink" title="log刷盘机制"></a>log刷盘机制</h3><p>innodb_flush_log_at_commit是InnoDB性能调优的一个基础参数，涉及InnoDB的写入效率和数据安全。当参数值为0时，写入效率最高，但是数据安全最低；参数值为1时，写入效率最低，但是数据安全最高；参数值为2时，二者都是中等水平。一般建议将该属性值设置为1，以获得较高的数据安全性，而且也只有设置为1，才能保证事务的持久性。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/e546ea1fc067" target="_blank" rel="noopener">https://www.jianshu.com/p/e546ea1fc067</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（3）：InnoDB的内存结构和特性</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%883%EF%BC%89%EF%BC%9AInnoDB%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%92%8C%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>常言说得好，每个成功男人背后都有一个为他默默付出的女人，而对于MySQL来说，这个“人”就是InnoDB存储引擎。<br>MySQL区别于其他数据库的最为重要的特点就是其插件式的表存储引擎。而在众多存储引擎中，InnoDB是最为常用的存储引擎。从MySQL5.5.8版本开始，InnoDB存储引擎是默认的存储引擎。<br>InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理(OLTP)的应用。其特点是行锁设计、支持外键，并支持非锁定读，即默认读操作不会产生锁。</p>
<a id="more"></a>

<p>InnoDB通过使用多版本并发控制(MVCC)来获取高并发性，并且实现了SQL标准的4中隔离级别，默认为REPEATABLE级别。同时，使用一种被称为next-key-locking的策略来避免幻读现象的产生。除此之外，InnoDB存储引擎还提供了插入缓冲(insert buffer)、二次写(double write)、自适应哈希索引(adaptive hash index)、预读(read ahead)等高性能和高可用的功能。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031172740-361a4.png" alt="img"></p>
<p>InnoDB整体架构.png</p>
<p>上图详细显示了InnoDB存储引擎的体系架构，从图中可见，InnoDB存储引擎由内存池，后台线程和磁盘文件三大部分组成。接下来我们就来简单了解一下内存相关的概念和原理。</p>
<h2 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h2><p>InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。但是由于CPU速度和磁盘速度之间的鸿沟，基于磁盘的数据库系统通常使用缓冲池记录来提高数据库的的整体性能。</p>
<p>在数据库中进行读取操作，首先将从磁盘中读到的页放在缓冲池中，下次再读相同的页中时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取该页。否则，读取磁盘上的页。</p>
<p>对于数据库中页的修改操作，则首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是通过一种称为CheckPoint的机制刷新回磁盘。</p>
<p>所以，缓冲池的大小直接影响着数据库的整体性能，可以通过配置参数innodb_buffer_pool_size来设置。</p>
<p>具体来看，缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲(insert buffer)、自适应哈希索引(adaptive hash index)、InnoDB存储的锁信息(lock info)和数据字典信息(data dictionary)。</p>
<p>在架构图上可以看到，InnoDB存储引擎的内存区域除了有缓冲池之外，还有重做日志缓冲和额外内存池。InnoDB存储引擎首先将重做日志信息先放到这个缓冲区中，然后按照一定频率将其刷新到重做日志文件中。重做日志缓冲一般不需要设置的很大，该值可由配置参数innodb_log_buffer_size控制。</p>
<h2 id="数据页和索引页"><a href="#数据页和索引页" class="headerlink" title="数据页和索引页"></a>数据页和索引页</h2><p>Page是Innodb存储的最基本结构，也是Innodb磁盘管理的最小单位，与数据库相关的所有内容都存储在Page结构里。Page分为几种类型，数据页和索引页就是其中最为重要的两种类型。</p>
<h2 id="插入缓冲-Insert-Buffer"><a href="#插入缓冲-Insert-Buffer" class="headerlink" title="插入缓冲(Insert Buffer)"></a>插入缓冲(Insert Buffer)</h2><p>我们都知道，在InnoDB引擎上进行插入操作时，一般需要按照主键顺序进行插入，这样才能获得较高的插入性能。当一张表中存在非聚簇的且不唯一的索引时，在插入时，数据页的存放还是按照主键进行顺序存放，但是对于非聚簇索引叶节点的插入不再是顺序的了，这时就需要离散的访问非聚簇索引页，由于随机读取的存在导致插入操作性能下降。</p>
<p>InnoDB为此设计了Insert Buffer来进行插入优化。对于非聚簇索引的插入或者更新操作，不是每一次都直接插入到索引页中，而是先判断插入的非聚集索引是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer中。看似数据库这个非聚集的索引已经查到叶节点，而实际没有，这时存放在另外一个位置。然后再以一定的频率和情况进行Insert Buffer和非聚簇索引页子节点的合并操作。这时通常能够将多个插入合并到一个操作中，这样就大大提高了对于非聚簇索引的插入性能。</p>
<h2 id="两次写-Double-Write"><a href="#两次写-Double-Write" class="headerlink" title="两次写(Double Write)"></a>两次写(Double Write)</h2><p>如果说Insert Buffer给InnoDB存储引擎带来了性能上的提升，那么Double Write带给InnoDB存储引擎的是数据页的可靠性。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031172743-bdca7.jpeg" alt="img"></p>
<p>doublewrite示意图</p>
<p>如上图所示，Double Write由两部分组成，一部分是内存中的double write buffer，大小为2MB，另一部分是物理磁盘上共享表空间连续的128个页，大小也为2MB。在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是通过memcpy函数将脏页先复制到内存中的该区域，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免操作系统缓冲写带来的问题。在完成doublewrite页的写入后，再讲doublewirite buffer中的页写入各个表空间文件中。</p>
<p>如果操作系统在将页写入磁盘的过程中发生了崩溃，在恢复过程中，InnoDB存储引擎可以从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件中，再应用重做日志。</p>
<h2 id="重做日志-Redo-Log-Buffer"><a href="#重做日志-Redo-Log-Buffer" class="headerlink" title="重做日志(Redo Log Buffer)"></a>重做日志(Redo Log Buffer)</h2><p>当缓冲池中的页的版本比磁盘要新时，数据库需要将新版本的页从缓冲池刷新到磁盘。但是如果每次一个页发送变化，就进行刷新，那么性能开发是非常大的，于是InnoDB采用了Write Ahead Log策略，即当事务提交时，先写重做日志，然后再择时将脏页写入磁盘。如果发生宕机导致数据丢失，就通过重做日志进行数据恢复。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031172743-45863.jpeg" alt="img"></p>
<p>InnoDB数据写入示意图</p>
<p>InnoDB存储引擎会首先将重做日志信息先放入重做日志缓冲中，然后再按照一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置得很大，因为一般情况每一秒钟都会讲重做日志缓冲刷新到日志文件中。可通过配置参数innodb_log_buffer_size控制，默认为8MB。</p>
<p>除了每秒刷新机制之外，每次事务提交时重做日志缓冲也会刷新到日志中。InnoDB是事务的存储引擎，其通过Force Log at Commit机制实现事务的持久性，即当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，然后事务的提交操作完成才算完成。InnoDB的写入机制大致入下图所示。</p>
<p>为了确保每次日志都写入到重做日志文件，在每次讲重做日志缓冲写入重做日志后，必须调用一次fsync操作，将缓冲文件从文件系统缓存中真正写入磁盘。</p>
<p>可以通过innodb_flush_log_at_trx_commit来控制重做日志刷新到磁盘的策略。该参数默认值为1，表示事务提交必须进行一次fsync操作，还可以设置为0和2。0表示事务提交时不进行写入重做日志操作，该操作只在主线程中完成，2表示提交时写入重做日志，但是只写入文件系统缓存，不进行fsync操作。由此可见，设置为0时，性能最高，但是丧失了事务的一致性。</p>
<h2 id="自适应哈希索引-Adaptive-Hash-Index"><a href="#自适应哈希索引-Adaptive-Hash-Index" class="headerlink" title="自适应哈希索引(Adaptive Hash Index)"></a>自适应哈希索引(Adaptive Hash Index)</h2><p>InnoDB会根据访问的频率和模式，为热点页建立哈希索引，来提高查询效率。InnoDB存储引擎会监控对表上各个索引页的查询，如果观察到建立哈希索引可以带来速度上的提升，则建立哈希索引，所以叫做自适应哈希索引。</p>
<p>自适应哈希索引是通过缓冲池的B+树页构建而来，因此建立速度很快，而且不需要对整张数据表建立哈希索引。其有一个要求，即对这个页的连续访问模式必须是一样的，也就是说其查询的条件(WHERE)必须完全一样，而且必须是连续的。</p>
<h2 id="锁信息-lock-info"><a href="#锁信息-lock-info" class="headerlink" title="锁信息(lock info)"></a>锁信息(lock info)</h2><p>我们都知道，InnoDB存储引擎会在行级别上对表数据进行上锁。不过InnoDB也会在数据库内部其他很多地方使用锁，从而允许对多种不同资源提供并发访问。数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。关于锁的具体知识我们之后再进行详细学习。</p>
<h2 id="数据字典信息-Data-Dictionary"><a href="#数据字典信息-Data-Dictionary" class="headerlink" title="数据字典信息(Data Dictionary)"></a>数据字典信息(Data Dictionary)</h2><p>InnoDB有自己的表缓存，可以称为表定义缓存或者数据字典。当InnoDB打开一张表，就增加一个对应的对象到数据字典。</p>
<p>数据字典是对数据库中的数据、库对象、表对象等的元信息的集合。在MySQL中，数据字典信息内容就包括表结构、数据库名或表名、字段的数据类型、视图、索引、表字段信息、存储过程、触发器等内容。MySQL INFORMATION_SCHEMA库提供了对数据局元数据、统计信息、以及有关MySQL server的访问信息（例如：数据库名或表名，字段的数据类型和访问权限等）。该库中保存的信息也可以称为MySQL的数据字典。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/1c1f83d0bb72" target="_blank" rel="noopener">https://www.jianshu.com/p/1c1f83d0bb72</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（2）：SQL语句执行过程详解</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%882%EF%BC%89%EF%BC%9ASQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>昔日庖丁解牛，未见全牛，所赖者是其对牛内部骨架结构的了解，对于MySQL亦是如此，只有更加全面地了解SQL语句执行的每个过程，才能更好的进行SQL的设计和优化。<br>当希望MySQL能够以更高的性能运行查询时，最好的办法就是弄清楚MySQL是如何优化和执行查询的。一旦理解了这一点，很多查询优化工作实际上就是遵循一些原则能够按照预想的合理的方式运行。</p>
<a id="more"></a>

<p>如下图所示，当向MySQL发送一个请求的时候，MySQL到底做了什么：</p>
<ol>
<li>客户端发送一条查询给服务器。</li>
<li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</li>
<li>服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。</li>
<li>MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询。</li>
<li>将结果返回给客户端。</li>
</ol>
<p><img src="http://image.winrains.cn/2019/10/20191031172218-253a8.png" alt="img"></p>
<p>SQL语句执行过程</p>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>MySQL查询缓存保存查询返回的完整结构。当查询命中该缓存时，MySQL会立刻返回结果，跳过了解析、优化和执行阶段。<br>查询缓存系统会跟踪查询中涉及的每个表，如果这些表发生了变化，那么和这个表相关的所有缓存数据都将失效。<br>MySQL将缓存存放在一个引用表中，通过一个哈希值引用，这个哈希值包括了以下因素，即查询本身、当前要查询的数据库、客户端协议的版本等一些其他可能影响返回结果的信息。<br>当判断缓存是否命中时，MySQL不会进行解析查询语句，而是直接使用SQL语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。<br>当查询语句中有一些不确定的数据时，则不会被缓存。例如包含函数NOW()或者CURRENT_DATE()的查询不会缓存。包含任何用户自定义函数，存储函数，用户变量，临时表，mysql数据库中的系统表或者包含任何列级别权限的表，都不会被缓存。<br>有一点需要注意，MySQL并不是会因为查询中包含一个不确定的函数而不检查查询缓存，因为检查查询缓存之前，MySQL不会解析查询语句，所以也无法知道语句中是否有不确定的函数。<br>事实则是，如果查询语句中包含任何的不确定的函数，那么其查询结果不会被缓存，因为查询缓存中也无法找到对应的缓存结果。<br>有关查询缓存的配置如下所示。</p>
<ul>
<li>query_cache_type:是否打开查询缓存。可以设置为OFF、ON和DEMAND。DEMAND表示只有在查询语句中明确写明SQL_CACHE的语句才会放入查询缓存。</li>
<li>query_cache_size:查询缓存使用的总内存空间。</li>
<li>query_cache_min_res_unit:在查询缓存中分配内存块时的最小单元。较小的该值可以减少碎片导致的内存空间浪费，但是会导致更频繁的内存块操作。</li>
<li>query_cache_limit:MySQL能够查询的最大查询结果。如果查询结果大于这个值，则不会被缓存。因为查询缓存在数据生成的时候就开始尝试缓存数据，所以当结果全部返回后，MySQL才知道查询结果是否超出限制。超出之后，才会将结果从查询缓存中删除。</li>
</ul>
<p>对查询缓存的优化是数据库性能优化的重要一环。判断流程大致如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031172218-253a8.png" alt="img"></p>
<p>查询缓存判断流程图</p>
<p>缓存命中率可以通过如下公式计算：Qcache_hits/(Qcache_hits + Com_select)来计算。</p>
<h2 id="解析和预处理"><a href="#解析和预处理" class="headerlink" title="解析和预处理"></a>解析和预处理</h2><p>解析器通过关键字将SQL语句进行解析，并生成对应的解析树。MySQL解析器将使用MySQL语法规则验证和解析查询。<br>预处理器则根据一些MySQL规则进行进一步检查解析书是否合法，例如检查数据表和数据列是否存在，还会解析名字和别名，看看它们是否有歧义。</p>
<h2 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h2><p>查询优化器会将解析树转化成执行计划。一条查询可以有多种执行方法，最后都是返回相同结果。优化器的作用就是找到这其中最好的执行计划。<br>生成执行计划的过程会消耗较多的时间，特别是存在许多可选的执行计划时。如果在一条SQL语句执行的过程中将该语句对应的最终执行计划进行缓存，当相似的语句再次被输入服务器时，就可以直接使用已缓存的执行计划，从而跳过SQL语句生成执行计划的整个过程，进而可以提高语句的执行速度。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031172220-78b8b.png" alt="img"></p>
<p>执行计划缓存</p>
<p>MySQL使用基于成本的查询优化器(Cost-Based Optimizer，CBO)。它会尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最少的一个。<br>优化器会根据优化规则对关系表达式进行转换，这里的转换是说一个关系表达式经过优化规则后会生成另外一个关系表达式，同时原有表达式也会保留，经过一系列转换后会生成多个执行计划，然后CBO会根据统计信息和代价模型(Cost Model)计算每个执行计划的Cost，从中挑选Cost最小的执行计划。由上可知，CBO中有两个依赖：统计信息和代价模型。统计信息的准确与否、代价模型的合理与否都会影响CBO选择最优计划。<br>有关优化器的原理十分复杂，这里就不进行详细讲解了，大家可以自行学习。</p>
<h2 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h2><p>在解析和优化阶段，MySQL将生成查询对应的执行计划，MySQL的查询执行引擎根据这个执行计划来完成整个查询。这里执行计划是一个数据结构，而不是和其他的关系型数据库那样生成对应的字节码。</p>
<h2 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h2><p>如果查询可以被缓存，那么MySQL在这个阶段页会将结果存放到查询缓存中。<br>MySQL将结果集返回给客户端是一个增量、逐步返回的过程。在查询生成第一条结果时，MySQL就可以开始向客户端逐步返回结果集了。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/56fe9bf91448" target="_blank" rel="noopener">https://www.jianshu.com/p/56fe9bf91448</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（1）：B-Tree索引</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%881%EF%BC%89%EF%BC%9AB-Tree%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>MySQL是目前业界最为流行的关系型数据库之一，而索引的优化也是数据库性能优化的关键之一。所以，充分地了解MySQL索引有助于提升开发人员对MySQL数据库的使用优化能力。<br>MySQL的索引有很多种类型，可以为不同的场景提供更好的性能。而B-Tree索引是最为常见的MySQL索引类型，一般谈论MySQL索引时，如果没有特别说明，就是指B-Tree索引。本文就详细讲解一下B-Tree索引的的底层结构，使用原则和特性。</p>
<a id="more"></a>

<p>为了节约你的时间，本文的主要内容如下：</p>
<ul>
<li>B-Tree索引的底层结构</li>
<li>B-Tree索引的使用规则</li>
<li>聚簇索引</li>
<li>InnoDB和MyISAM引擎索引的差异</li>
<li>松散索引</li>
<li>覆盖索引</li>
</ul>
<h2 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h2><p>B-Tree索引使用B-Tree来存储数据，当然不同存储引擎的实现方式不同。B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同，图1展示了B-Tree索引的抽象表示，由此可以看出MySQL的B-Tree索引的大致工作机制。<br>B-Tree索引的底层数据结构一般是B+树，其具体数据结构和优势这里就不作详细描述，图1展示了B-树索引的抽象表示，大致反应了MyISAM索引是如何工作的，而InnoDB使用的结构有所不同。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031171835-cd3fe.png" alt="img"></p>
<p>图1 B-Tree索引的底层结构示意图</p>
<p>MySQL可以在单独一列上添加B-Tree索引，也可以在多列数据上添加B-Tree索引，多列的数据按照添加索引声明的顺序组合起来，存储在B-Tree的页中。假设有如下数据表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People (</span></pre></td></tr><tr><td class="code"><pre><span class="line">      last_name    <span class="built_in">varchar</span>(<span class="number">50</span>)    <span class="keyword">not</span> <span class="literal">null</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      first_name   <span class="built_in">varchar</span>(<span class="number">50</span>)    <span class="keyword">not</span> <span class="literal">null</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      birthday     <span class="built_in">date</span>           <span class="keyword">not</span> <span class="literal">null</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      gender       enum(<span class="string">'m'</span>,<span class="string">'f'</span>)  <span class="keyword">not</span> <span class="literal">null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">key</span>(last_name, first_name, birthday)</span></pre></td></tr><tr><td class="code"><pre><span class="line">);</span></pre></td></tr></table></figure>

<p>对于表中的每一行数据，索引中包含了last_name，first_name和birthday列的值，图2展示了该索引是如何组织数据的存储的。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031171836-50d95.png" alt="img"></p>
<p>图2 多列索引</p>
<p>B-Tree索引使用B-Tree作为其存储数据的数据结构，其使用的查询规则也由此决定。一般来说，B-Tree索引适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于根据最左前缀查找。B-Tree索引支持的查询原则如下所示：</p>
<ul>
<li>全值匹配：全值匹配指的是和索引中的所有列进行匹配，</li>
<li>匹配最左前缀：前边提到的索引可以用于查找所有姓Allen的人，即只使用索引中的第一列。</li>
<li>匹配列前缀：也可以只匹配某一列的值的开头部分。例如前面提到的索引可用于查找所有以J开头的姓的人。这里也只用到了索引的第一列。</li>
<li>匹配范围值：例如前边提到的索引可用于查找姓在Allen和Barrymore之间的人。这里也只使用了索引的第一列。</li>
<li>精确匹配某一列并范围匹配另外一列：前边提到的索引也可用于查找所有姓为Allen，并且名字是字母K开头(比如Kim,Karl等)的人。即第一列last_name全匹配，第二列first_name范围匹配。</li>
</ul>
<p>因为索引树的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的ORDER BY操作(按顺序查找)，如果ORDER BY子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。<br>下面是一些关于B-Tree索引的限制：</p>
<ul>
<li>如果不是按照索引的最左列开始查找，则无法使用索引。例如上面例子中的索引无法查找名字为Bill的人，也无法查找某个特定生日的日，因为这两列都不是最左数据列。</li>
<li>如果查询中有某个列的范围查询，则其右侧所有列都无法使用索引优化查找。</li>
</ul>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于其实现方式，但是InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。<br>当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中，这也就是说数据行和相邻的键值紧凑地存储在一起。<br>图3展示了聚簇索引中的记录是如何存放的。注意到，叶子页包含了行的全部数据行，但是节点页只包含了索引列。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031171836-2a3fb.png" alt="img"></p>
<p>图3 聚簇索引</p>
<p>聚簇索引可能对性能有帮助，但也可能导致严重的性能问题。聚簇的数据是有一些重要的优点：</p>
<ul>
<li>数据访问更快，聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li>
</ul>
<p>如果在设计表和查询时能充分利用上面的优点，那么就能极大地提升性能。同时，聚簇索引也有一些缺点：</p>
<ul>
<li>插入顺序严重依赖插入顺序。按照主键的顺序插入是向InnoDB表中插入数据速度最快的方式，需要避免主键键值随机的(不连续且值得分布范围非常大)聚簇索引，比如使用UUID作为主键，而应该使用类似AUTO_INCREMENT的自增列。</li>
<li>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动位置到新的位置。</li>
<li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行时，可能面临“页分裂”的问题。当行的主键值要求必须将这行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间</li>
<li>二级索引可能比想象的更大，因为在二级索引中的叶节点包含了引用行的主键列</li>
<li>二级索引访问需要两次索引查找，而不是一次。</li>
</ul>
<h2 id="InnoDB和MyISAM的索引区别"><a href="#InnoDB和MyISAM的索引区别" class="headerlink" title="InnoDB和MyISAM的索引区别"></a>InnoDB和MyISAM的索引区别</h2><p>聚簇索引和非聚簇索引的数据分布有区别，以及对应的主键索引和二级索引的数据分布也有区别，通常会让人感到困惑和意外。图4展示了MyISAM和InnoDB的不同索引和数据存储方式。<br>MyISAM的数据分布非常简单，按照数据插入的顺序存储在磁盘上，主键索引和二级索引的叶节点存储着指针，指向对应的数据行。<br>InnoDB中，聚簇索引“就是”表，所以不会像MyISAM那样需要独立的行存储。聚簇索引的每个叶节点都包含了主键值和所有的剩余列(在此例中是col2)。<br>InnoDB的二级索引和聚簇索引很不同。InnoDB二级索引的叶节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031171837-1e9a0.png" alt="img"></p>
<p>图4 InnoDB和MyISAM的区别</p>
<h2 id="松散索引扫描"><a href="#松散索引扫描" class="headerlink" title="松散索引扫描"></a>松散索引扫描</h2><p>MySQL并不支持松散索引扫描，也就是无法按照不连续的方式扫描一个索引。通常，MySQL的索引扫描需要先定义一个起点和终点，即使需要的数据只是这段索引中很少数的几个，MySQL仍然需要扫描这段索引中的每个条目。<br>下面，我们通过一个示例说明这点，假设我们有如下索引(a,b)，有下面的查询：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">mysql&gt;<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb1 <span class="keyword">WHERE</span> b <span class="keyword">BETWEEN</span> <span class="number">2</span> <span class="keyword">AND</span> <span class="number">3</span>;</span></pre></td></tr></table></figure>

<p>因为索引的前导字段是列a，但是在查询中只指定了字段b，MySQL无法使用这个索引，从而只能通过全表扫描找到匹配的行，如图5所示。<br><img src="http://image.winrains.cn/2019/10/20191031171837-a11d6.png" alt="img"></p>
<p>图5 全表扫描</p>
<p>了解索引的物理结构的话，不难发现还可以有一个更快的办法执行上面的查询。索引的物理结构(不是存储引擎的API)是的可以先扫描a列第一个值对应的b列的范围，然后再跳到a列第二个不不同值扫描对应的b列的范围。图6展示了如果由MySQL来实现这个过程会怎样。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031171838-b59f9.png" alt="img"></p>
<p>图6 松散索引</p>
<p>注意到，这时就无须再使用WHERE子句过滤，因为松散索引扫描已经跳过了所有不需要的记录。<br>MySQL 5.0之后的版本，在某些特殊的场景下是可以使用松散索引扫描的，例如，在一个分组查询中需要找到分组的最大值和最小值：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT actor_id, MAX(film_id)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        -&gt; <span class="keyword">FROM</span> sakila.film.film_actor</span></pre></td></tr><tr><td class="code"><pre><span class="line">        -&gt;<span class="built_in"> GROUP </span>BY actor_id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">********************************************* 1. row ***********************************</span></pre></td></tr><tr><td class="code"><pre><span class="line">id: 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">select_type: SIMPLE</span></pre></td></tr><tr><td class="code"><pre><span class="line">table: film_actor</span></pre></td></tr><tr><td class="code"><pre><span class="line">type: range</span></pre></td></tr><tr><td class="code"><pre><span class="line">possible_keys: <span class="literal">NULL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">key: PRIMARY</span></pre></td></tr><tr><td class="code"><pre><span class="line">key_len: 2</span></pre></td></tr><tr><td class="code"><pre><span class="line">ref: <span class="literal">NULL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">rows: 396</span></pre></td></tr><tr><td class="code"><pre><span class="line">Extra: Using index <span class="keyword">for</span> group-by</span></pre></td></tr></table></figure>

<p>在EXPLAIN中的Extra字段显示”Using index for group-by”，表示这里将使用松散索引扫描。</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>索引除了是一种查找数据的高效方式之外，也是一种列数据的直接获取方式。MySQL可以使用索引来直接获取列的数据，这样就不需要读取数据行。如果一个索引包含所有需要查询的字段的值，我们就称之为“覆盖索引”。<br>覆盖索引是非常有用的工具，能够极大地提高性能。SQL查询只需要扫描索引而无需回表，会带来很多好处：</p>
<ul>
<li>索引条目数量和大小通常远小于数据行的条目和大小，所以如果只需要读取索引，那么MySQL就会极大地减少数据访问量。</li>
<li>因为索引是按照列顺序存储的，所以对于I/O密集型的范围查找会比随机从磁盘读取每一行数据的I/O要少的多。</li>
<li>由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键，索引如果二级主键能够覆盖查询，则避免对主键索引的第二次查询。</li>
</ul>
<p>当发起一个被覆盖索引的查询(也叫索引覆盖查询)时，在EXPLAIN的Extra列可以看到”Using Index”的信息。例如，表sakila.inventory有一个多列索引(store_id, film_id)。MySQL如果只需要访问这两列，就可以使用这个索引做覆盖索引，如下所示：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT store<span class="emphasis">_id, film_</span>id FROM sakila.inventory</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">***1.row**</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**</span></pre></td></tr><tr><td class="code"><pre><span class="line">id:1</span></pre></td></tr><tr><td class="code"><pre><span class="line">select_type:SIMPLE</span></pre></td></tr><tr><td class="code"><pre><span class="line">table:inventory</span></pre></td></tr><tr><td class="code"><pre><span class="line">type:index</span></pre></td></tr><tr><td class="code"><pre><span class="line">possible_keys:NULL</span></pre></td></tr><tr><td class="code"><pre><span class="line">key:idx<span class="emphasis">_store_</span>id<span class="emphasis">_film_</span>id</span></pre></td></tr><tr><td class="code"><pre><span class="line">key_len:3</span></pre></td></tr><tr><td class="code"><pre><span class="line">ref:NULL</span></pre></td></tr><tr><td class="code"><pre><span class="line">rows:4673</span></pre></td></tr><tr><td class="code"><pre><span class="line">Extra:Using Index</span></pre></td></tr></table></figure>

<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/9e00633958e6" target="_blank" rel="noopener">https://www.jianshu.com/p/9e00633958e6</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Redis使用方法</title>
    <url>/2019/12/26/Redis%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本文将从Redis的基本特性入手，通过讲述Redis的数据结构和主要命令对Redis的基本能力进行直观介绍。</p>
<p>然后概览Redis提供的高级能力，并在部署、维护、性能调优等多个方面进行更深入的介绍和指导。</p>
<p>本文适合使用Redis的普通开发人员，以及对Redis进行选型、架构设计和性能调优的架构设计人员。</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h1><p>Redis是一个开源的，基于内存的结构化数据存储媒介，可以作为数据库、缓存服务或消息服务使用。<br>Redis支持多种数据结构，包括字符串、哈希表、链表、集合、有序集合、位图、Hyperloglogs等。<br>Redis具备LRU淘汰、事务实现、以及不同级别的硬盘持久化等能力，并且支持副本集和通过Redis Sentinel实现的高可用方案，同时还支持通过Redis Cluster实现的数据自动分片能力。<br>Redis的主要功能都基于单线程模型实现，也就是说Redis使用一个线程来服务所有的客户端请求<br>同时Redis采用了非阻塞式IO，并精细地优化各种命令的算法时间复杂度，这些信息意味着：</p>
<ul>
<li>Redis是线程安全的（因为只有一个线程），其所有操作都是原子的，不会因并发产生数据异常</li>
<li>Redis的速度非常快（因为使用非阻塞式IO，且大部分命令的算法时间复杂度都是O(1))</li>
<li>使用高耗时的Redis命令是很危险的，会占用唯一的一个线程的大量处理时间，导致所有的请求都被拖慢。（例如时间复杂度为O(N)的KEYS命令，严格禁止在生产环境中使用）</li>
</ul>
<h1 id="Redis的数据结构和相关常用命令"><a href="#Redis的数据结构和相关常用命令" class="headerlink" title="Redis的数据结构和相关常用命令"></a><strong>Redis的数据结构和相关常用命令</strong></h1><p>本节将介绍Redis支持的主要数据结构，以及相关的常用Redis命令</p>
<h2 id="Key"><a href="#Key" class="headerlink" title="Key"></a><strong>Key</strong></h2><p>Redis采用Key-Value型的基本数据结构，任何二进制序列都可以作为Redis的Key使用（例如普通的字符串或一张JPEG图片）<br>关于Key的一些注意事项：</p>
<ul>
<li><strong>不要使用过长的Key</strong>。例如使用一个1024字节的key就不是一个好主意，不仅会消耗更多的内存，还会导致查找的效率降低</li>
<li><strong>Key短到缺失了可读性也是不好的</strong>，例如”u1000flw”比起”user:1000:followers”来说，节省了寥寥的存储空间，却引发了可读性和可维护性上的麻烦</li>
<li><strong>最好使用统一的规范来设计Key</strong>，比如”object-type:id:attr”，以这一规范设计出的Key可能是”user:1000”或”comment:1234:reply-to”</li>
<li><strong>Redis允许的最大Key长度是512MB</strong>（对Value的长度限制也是512MB）</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a><strong>String</strong></h2><p>String是Redis的基础数据类型，Redis没有Int、Float、Boolean等数据类型的概念，所有的基本类型在Redis中都以String体现。<br>与String相关的常用命令：</p>
<ul>
<li><strong>SET</strong>：为一个key设置value，可以配合EX/PX参数指定key的有效期，通过NX/XX参数针对key是否存在的情况进行区别操作，时间复杂度O(1)</li>
<li><strong>GET</strong>：获取某个key对应的value，时间复杂度O(1)</li>
<li><strong>GETSET</strong>：为一个key设置value，并返回该key的原value，时间复杂度O(1)</li>
<li><strong>MSET</strong>：为多个key设置value，时间复杂度O(N)</li>
<li><strong>MSETNX</strong>：同MSET，如果指定的key中有任意一个已存在，则不进行任何操作，时间复杂度O(N)</li>
<li><strong>MGET</strong>：获取多个key对应的value，时间复杂度O(N)</li>
</ul>
<p>上文提到过，Redis的基本数据类型只有String，但Redis可以把String作为整型或浮点型数字来使用，主要体现在INCR、DECR类的命令上：</p>
<ul>
<li><strong>INCR</strong>：将key对应的value值自增1，并返回自增后的值。只对可以转换为整型的String数据起作用。时间复杂度O(1)</li>
<li><strong>INCRBY</strong>：将key对应的value值自增指定的整型数值，并返回自增后的值。只对可以转换为整型的String数据起作用。时间复杂度O(1)</li>
<li><strong>DECR/DECRBY</strong>：同INCR/INCRBY，自增改为自减。</li>
</ul>
<p>INCR/DECR系列命令要求操作的value类型为String，并可以转换为64位带符号的整型数字，否则会返回错误。<br>也就是说，进行INCR/DECR系列命令的value，必须在[-2^63 ~ 2^63 - 1]范围内。<br>前文提到过，Redis采用单线程模型，天然是线程安全的，这使得INCR/DECR命令可以非常便利的实现高并发场景下的精确控制。</p>
<h3 id="例1：库存控制"><a href="#例1：库存控制" class="headerlink" title="例1：库存控制"></a><strong>例1：库存控制</strong></h3><p>在高并发场景下实现库存余量的精准校验，确保不出现超卖的情况。<br>设置库存总量：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> inv:remain <span class="comment">"100"</span></span></pre></td></tr></table></figure>

<p>库存扣减+余量校验：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">DECR</span> <span class="selector-tag">inv</span><span class="selector-pseudo">:remain</span></span></pre></td></tr></table></figure>

<p>当DECR命令返回值大于等于0时，说明库存余量校验通过，如果返回小于0的值，则说明库存已耗尽。<br>假设同时有300个并发请求进行库存扣减，Redis能够确保这300个请求分别得到99到-200的返回值，每个请求得到的返回值都是唯一的，绝对不会找出现两个请求得到一样的返回值的情况。</p>
<h3 id="例2：自增序列生成"><a href="#例2：自增序列生成" class="headerlink" title="例2：自增序列生成"></a><strong>例2：自增序列生成</strong></h3><p>实现类似于RDBMS的Sequence功能，生成一系列唯一的序列号<br>设置序列起始值：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> sequence <span class="comment">"10000"</span></span></pre></td></tr></table></figure>

<p>获取一个序列值：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">INCR sequence</span></span></pre></td></tr></table></figure>

<p>直接将返回值作为序列使用即可。<br>获取一批（如100个）序列值：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">INCRBY sequence <span class="number">100</span></span></pre></td></tr></table></figure>

<p>假设返回值为N，那么[N - 99 ~ N]的数值都是可用的序列值。<br>当多个客户端同时向Redis申请自增序列时，Redis能够确保每个客户端得到的序列值或序列范围都是全局唯一的，绝对不会出现不同客户端得到了重复的序列值的情况。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a><strong>List</strong></h2><p>Redis的List是链表型的数据结构，可以使用LPUSH/RPUSH/LPOP/RPOP等命令在List的两端执行插入元素和弹出元素的操作。<br>虽然List也支持在特定index上插入和读取元素的功能，但其时间复杂度较高（O(N)），应小心使用。<br>与List相关的常用命令：</p>
<ul>
<li><strong>LPUSH</strong>：向指定List的左侧（即头部）插入1个或多个元素，返回插入后的List长度。时间复杂度O(N)，N为插入元素的数量</li>
<li><strong>RPUSH</strong>：同LPUSH，向指定List的右侧（即尾部）插入1或多个元素</li>
<li><strong>LPOP</strong>：从指定List的左侧（即头部）移除一个元素并返回，时间复杂度O(1)</li>
<li><strong>RPOP</strong>：同LPOP，从指定List的右侧（即尾部）移除1个元素并返回</li>
<li><strong>LPUSHX/RPUSHX</strong>：与LPUSH/RPUSH类似，区别在于，LPUSHX/RPUSHX操作的key如果不存在，则不会进行任何操作</li>
<li><strong>LLEN</strong>：返回指定List的长度，时间复杂度O(1)</li>
<li><strong>LRANGE</strong>：返回指定List中指定范围的元素（双端包含，即LRANGE key 0 10会返回11个元素），时间复杂度O(N)。</li>
</ul>
<p>注意：应尽可能控制一次获取的元素数量，一次获取过大范围的List元素会导致延迟，同时对长度不可预知的List，避免使用LRANGE key 0 -1这样的完整遍历操作。</p>
<p>应谨慎使用的List相关命令：</p>
<ul>
<li><strong>LINDEX</strong>：返回指定List指定index上的元素，如果index越界，返回nil。index数值是回环的，即-1代表List最后一个位置，-2代表List倒数第二个位置。时间复杂度O(N)</li>
<li><strong>LSET</strong>：将指定List指定index上的元素设置为value，如果index越界则返回错误，时间复杂度O(N)，如果操作的是头/尾部的元素，则时间复杂度为O(1)</li>
<li><strong>LINSERT</strong>：向指定List中指定元素之前/之后插入一个新元素，并返回操作后的List长度。如果指定的元素不存在，返回-1。如果指定key不存在，不会进行任何操作，时间复杂度O(N)</li>
</ul>
<p>由于Redis的List是链表结构的，上述的三个命令的算法效率较低，需要对List进行遍历，命令的耗时无法预估，在List长度大的情况下耗时会明显增加，应谨慎使用。<br>换句话说，Redis的List实际是设计来用于实现队列，而不是用于实现类似ArrayList这样的列表的。<br>如果你不是想要实现一个双端出入的队列，那么请尽量不要使用Redis的List数据结构。<br>为了更好支持队列的特性，Redis还提供了一系列阻塞式的操作命令，如BLPOP/BRPOP等，能够实现类似于BlockingQueue的能力，即在List为空时，阻塞该连接，直到List中有对象可以出队时再返回。</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a><strong>Hash</strong></h2><p>Hash即哈希表，Redis的Hash和传统的哈希表一样，是一种field-value型的数据结构，可以理解成将HashMap搬入Redis。<br>Hash非常适合用于表现对象类型的数据，用Hash中的field对应对象的field即可。<br>Hash的优点包括：</p>
<ul>
<li>可以实现二元查找，如”查找ID为1000的用户的年龄”</li>
<li>比起将整个对象序列化后作为String存储的方法，Hash能够有效地减少网络传输的消耗</li>
<li>当使用Hash维护一个集合时，提供了比List效率高得多的随机访问命令</li>
</ul>
<p>与Hash相关的常用命令：</p>
<ul>
<li><p><strong>HSET</strong>：将key对应的Hash中的field设置为value。如果该Hash不存在，会自动创建一个。时间复杂度O(1)</p>
</li>
<li><p><strong>HGET</strong>：返回指定Hash中field字段的值，时间复杂度O(1)</p>
</li>
<li><p><strong>HMSET/HMGET</strong>：同HSET和HGET，可以批量操作同一个key下的多个field，时间复杂度：O(N)，N为一次操作的field数量</p>
</li>
<li><p><strong>HSETNX</strong>：同HSET，但如field已经存在，HSETNX不会进行任何操作，时间复杂度O(1)</p>
</li>
<li><p><strong>HEXISTS</strong>：判断指定Hash中field是否存在，存在返回1，不存在返回0，时间复杂度O(1)</p>
</li>
<li><p><strong>HDEL</strong>：删除指定Hash中的field（1个或多个），时间复杂度：O(N)，N为操作的field数量</p>
</li>
<li><p><strong>HINCRBY</strong>：同INCRBY命令，对指定Hash中的一个field进行INCRBY，时间复杂度O(1)</p>
</li>
</ul>
<p>应谨慎使用的Hash相关命令：</p>
<ul>
<li><strong>HGETALL</strong>：返回指定Hash中所有的field-value对。返回结果为数组，数组中field和value交替出现。时间复杂度O(N)</li>
<li><strong>HKEYS/HVALS</strong>：返回指定Hash中所有的field/value，时间复杂度O(N)</li>
</ul>
<p>上述三个命令都会对Hash进行完整遍历，Hash中的field数量与命令的耗时线性相关<br>对于尺寸不可预知的Hash，应严格避免使用上面三个命令，而改为使用HSCAN命令进行游标式的遍历</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a><strong>Set</strong></h2><p>Redis Set是无序的，不可重复的String集合。<br>与Set相关的常用命令：</p>
<ul>
<li><strong>SADD</strong>：向指定Set中添加1个或多个member，如果指定Set不存在，会自动创建一个。时间复杂度O(N)，N为添加的member个数</li>
<li><strong>SREM</strong>：从指定Set中移除1个或多个member，时间复杂度O(N)，N为移除的member个数</li>
<li><strong>SRANDMEMBER</strong>：从指定Set中随机返回1个或多个member，时间复杂度O(N)，N为返回的member个数</li>
<li><strong>SPOP</strong>：从指定Set中随机移除并返回count个member，时间复杂度O(N)，N为移除的member个数</li>
<li><strong>SCARD</strong>：返回指定Set中的member个数，时间复杂度O(1)</li>
<li><strong>SISMEMBER</strong>：判断指定的value是否存在于指定Set中，时间复杂度O(1)</li>
<li><strong>SMOVE</strong>：将指定member从一个Set移至另一个Set</li>
</ul>
<p>慎用的Set相关命令：</p>
<ul>
<li><strong>SMEMBERS</strong>：返回指定Hash中所有的member，时间复杂度O(N)</li>
<li><strong>SUNION/SUNIONSTORE</strong>：计算多个Set的并集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数</li>
<li><strong>SINTER/SINTERSTORE</strong>：计算多个Set的交集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数</li>
<li><strong>SDIFF/SDIFFSTORE</strong>：计算1个Set与1或多个Set的差集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数</li>
</ul>
<p>上述几个命令涉及的计算量大，应谨慎使用，特别是在参与计算的Set尺寸不可知的情况下，应严格避免使用。</p>
<h2 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a><strong>Sorted Set</strong></h2><p>Redis Sorted Set是有序的、不可重复的String集合。<br>Sorted Set中的每个元素都需要指派一个分数(score)，Sorted Set会根据score对元素进行升序排序。<br>如果多个member拥有相同的score，则以字典序进行升序排序。Sorted Set非常适合用于实现排名。<br>Sorted Set的主要命令：</p>
<ul>
<li><strong>ZADD</strong>：向指定Sorted Set中添加1个或多个member，时间复杂度O(Mlog(N))，M为添加的member数量，N为Sorted Set中的member数量</li>
<li><strong>ZREM</strong>：从指定Sorted Set中删除1个或多个member，时间复杂度O(Mlog(N))，M为删除的member数量，N为Sorted Set中的member数量</li>
<li><strong>ZCOUNT</strong>：返回指定Sorted Set中指定score范围内的member数量，时间复杂度：O(log(N))</li>
<li><strong>ZCARD</strong>：返回指定Sorted Set中的member数量，时间复杂度O(1)</li>
<li><strong>ZSCORE</strong>：返回指定Sorted Set中指定member的score，时间复杂度O(1)</li>
<li><strong>ZRANK/ZREVRANK</strong>：返回指定member在Sorted Set中的排名，ZRANK返回按升序排序的排名，ZREVRANK则返回按降序排序的排名。时间复杂度O(log(N))</li>
<li><strong>ZINCRBY</strong>：同INCRBY，对指定Sorted Set中的指定member的score进行自增，时间复杂度O(log(N))</li>
</ul>
<p>慎用的Sorted Set相关命令：</p>
<ul>
<li><strong>ZRANGE/ZREVRANGE</strong>：返回指定Sorted Set中指定排名范围内的所有member，ZRANGE为按score升序排序，ZREVRANGE为按score降序排序，时间复杂度O(log(N)+M)，M为本次返回的member数</li>
<li><strong>ZRANGEBYSCORE/ZREVRANGEBYSCORE</strong>：返回指定Sorted Set中指定score范围内的所有member，返回结果以升序/降序排序，min和max可以指定为-inf和+inf，代表返回所有的member。时间复杂度O(log(N)+M)</li>
<li><strong>ZREMRANGEBYRANK/ZREMRANGEBYSCORE</strong>：移除Sorted Set中指定排名范围/指定score范围内的所有member。时间复杂度O(log(N)+M)</li>
</ul>
<p>上述几个命令，应尽量避免传递[0 -1]或[-inf +inf]这样的参数，来对Sorted Set做一次性的完整遍历，特别是在Sorted Set的尺寸不可预知的情况下。</p>
<h2 id="Bitmap和HyperLogLog"><a href="#Bitmap和HyperLogLog" class="headerlink" title="Bitmap和HyperLogLog"></a><strong>Bitmap和HyperLogLog</strong></h2><p>Redis的这两种数据结构相较之前的并不常用，在本文中只做简要介绍<br>Bitmap在Redis中不是一种实际的数据类型，而是一种将String作为Bitmap使用的方法。<br>可以理解为将String转换为bit数组。使用Bitmap来存储true/false类型的简单数据极为节省空间。<br>HyperLogLogs是一种主要用于数量统计的数据结构，它和Set类似，维护一个不可重复的String集合<br>但是HyperLogLogs并不维护具体的member内容，只维护member的个数。<br>也就是说，HyperLogLogs只能用于计算一个集合中不重复的元素数量，所以它比Set要节省很多内存空间。</p>
<h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a><strong>其他常用命令</strong></h2><ul>
<li><strong>EXISTS</strong>：判断指定的key是否存在，返回1代表存在，0代表不存在，时间复杂度O(1)</li>
<li><strong>DEL</strong>：删除指定的key及其对应的value，时间复杂度O(N)，N为删除的key数量</li>
<li><strong>EXPIRE/PEXPIRE</strong>：为一个key设置有效期，单位为秒或毫秒，时间复杂度O(1)</li>
<li><strong>TTL/PTTL</strong>：返回一个key剩余的有效时间，单位为秒或毫秒，时间复杂度O(1)</li>
<li><strong>RENAME/RENAMENX</strong>：将key重命名为newkey。使用RENAME时，如果newkey已经存在，其值会被覆盖；使用RENAMENX时，如果newkey已经存在，则不会进行任何操作，时间复杂度O(1)</li>
<li><strong>TYPE</strong>：返回指定key的类型，string, list, set, zset, hash。时间复杂度O(1)</li>
<li><strong>CONFIG GET</strong>：获得Redis某配置项的当前值，可以使用*通配符，时间复杂度O(1)</li>
<li><strong>CONFIG SET</strong>：为Redis某个配置项设置新值，时间复杂度O(1)</li>
<li><strong>CONFIG REWRITE</strong>：让Redis重新加载redis.conf中的配置</li>
</ul>
<h1 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a><strong>数据持久化</strong></h1><p>Redis提供了将数据定期自动持久化至硬盘的能力，包括RDB和AOF两种方案。<br>两种方案分别有其长处和短板，可以配合起来同时运行，确保数据的稳定性。</p>
<h2 id="必须使用数据持久化吗？"><a href="#必须使用数据持久化吗？" class="headerlink" title="必须使用数据持久化吗？"></a><strong>必须使用数据持久化吗？</strong></h2><p>Redis的数据持久化机制是可以关闭的，如果你只把Redis作为缓存服务使用，Redis中存储的所有数据都不是该数据的主体而仅仅是同步过来的备份，那么可以关闭Redis的数据持久化机制。<br>但通常来说，仍然建议至少开启RDB方式的数据持久化，因为：</p>
<ul>
<li>RDB方式的持久化几乎不损耗Redis本身的性能，在进行RDB持久化时，Redis主进程唯一需要做的事情就是fork出一个子进程，所有持久化工作都由子进程完成</li>
<li>Redis无论因为什么原因crash掉之后，重启时能够自动恢复到上一次RDB快照中记录的数据。这省去了手工从其他数据源（如DB）同步数据的过程，而且要比其他任何的数据恢复方式都要快</li>
<li>现在硬盘那么大，真的不缺那一点地方</li>
</ul>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a><strong>RDB</strong></h2><p>采用RDB持久方式，Redis会定期保存数据快照至一个rbd文件中，并在启动时自动加载rdb文件，恢复之前保存的数据。<br>可以在配置文件中配置Redis进行快照保存的时机：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">save</span> <span class="selector-attr">[seconds]</span> <span class="selector-attr">[changes]</span></span></pre></td></tr></table></figure>

<p>意为在[seconds]秒内如果发生了[changes]次数据修改，则进行一次RDB快照保存，例如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">save <span class="number">60</span> <span class="number">100</span></span></pre></td></tr></table></figure>

<p>会让Redis每60秒检查一次数据变更情况，如果发生了100次或以上的数据变更，则进行RDB快照保存。<br>可以配置多条save指令，让Redis执行多级的快照保存策略。<br>Redis默认开启RDB快照，默认的RDB策略如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span>s</span></pre></td></tr><tr><td class="code"><pre><span class="line">save <span class="number">300</span> <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">save <span class="number">60</span> <span class="number">10000</span></span></pre></td></tr></table></figure>

<p>也可以通过<strong>BGSAVE</strong>命令手工触发RDB快照保存。<br><strong>RDB的优点：</strong></p>
<ul>
<li>对性能影响最小。如前文所述，Redis在保存RDB快照时会fork出子进程进行，几乎不影响Redis处理客户端请求的效率。</li>
<li>每次快照会生成一个完整的数据快照文件，所以可以辅以其他手段保存多个时间点的快照（例如把每天0点的快照备份至其他存储媒介中），作为非常可靠的灾难恢复手段。</li>
<li>使用RDB文件进行数据恢复比使用AOF要快很多。</li>
</ul>
<p><strong>RDB的缺点：</strong></p>
<ul>
<li>快照是定期生成的，所以在Redis crash时或多或少会丢失一部分数据。</li>
<li>如果数据集非常大且CPU不够强（比如单核CPU），Redis在fork子进程时可能会消耗相对较长的时间（长至1秒），影响这期间的客户端请求。</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a><strong>AOF</strong></h2><p>采用AOF持久方式时，Redis会把每一个写请求都记录在一个日志文件里。<br>在Redis重启时，会把AOF文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。<br>AOF默认是关闭的，如要开启，进行如下配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">appendonly</span> <span class="literal">yes</span></span></pre></td></tr></table></figure>

<p>AOF提供了三种fsync配置，always/everysec/no，通过配置项[appendfsync]指定：</p>
<ul>
<li><strong>appendfsync no</strong>：不进行fsync，将flush文件的时机交给OS决定，速度最快</li>
<li><strong>appendfsync always</strong>：每写入一条日志就进行一次fsync操作，数据安全性最高，但速度最慢</li>
<li><strong>appendfsync everysec</strong>：折中的做法，交由后台线程每秒fsync一次</li>
</ul>
<p>随着AOF不断地记录写操作日志，必定会出现一些无用的日志<br>例如某个时间点执行了命令<strong>SET key1 “abc”</strong>，在之后某个时间点又执行了<strong>SET key1 “bcd”</strong>，那么第一条命令很显然是没有用的。<br>大量的无用日志会让AOF文件过大，也会让数据恢复的时间过长。<br>所以Redis提供了AOF rewrite功能，可以重写AOF文件，只保留能够把数据恢复到最新状态的最小写操作集。<br>AOF rewrite可以通过<strong>BGREWRITEAOF</strong>命令触发，也可以配置Redis定期自动进行：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">auto</span>-aof-rewrite-percentage <span class="number">100</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">auto</span>-aof-rewrite-min-size <span class="number">64</span>mb</span></pre></td></tr></table></figure>

<p>上面两行配置的含义是，Redis在每次AOF rewrite时，会记录完成rewrite后的AOF日志大小，当AOF日志大小在该基础上增长了100%后，自动进行AOF rewrite。同时如果增长的大小没有达到64mb，则不会进行rewrite。<br><strong>AOF的优点：</strong></p>
<ul>
<li>最安全，在启用appendfsync always时，任何已写入的数据都不会丢失，使用在启用appendfsync everysec也至多只会丢失1秒的数据。</li>
<li>AOF文件在发生断电等问题时也不会损坏，即使出现了某条日志只写入了一半的情况，也可以使用redis-check-aof工具轻松修复。</li>
<li>AOF文件易读，可修改，在进行了某些错误的数据清除操作后，只要AOF文件没有rewrite，就可以把AOF文件备份出来，把错误的命令删除，然后恢复数据。</li>
</ul>
<p><strong>AOF的缺点：</strong></p>
<ul>
<li>AOF文件通常比RDB文件更大</li>
<li>性能消耗比RDB高</li>
<li>数据恢复速度比RDB慢</li>
</ul>
<h1 id="内存管理与数据淘汰机制"><a href="#内存管理与数据淘汰机制" class="headerlink" title="内存管理与数据淘汰机制"></a><strong>内存管理与数据淘汰机制</strong></h1><h2 id="最大内存设置"><a href="#最大内存设置" class="headerlink" title="最大内存设置"></a><strong>最大内存设置</strong></h2><p>默认情况下，在32位OS中，Redis最大使用3GB的内存，在64位OS中则没有限制。<br>在使用Redis时，应该对数据占用的最大空间有一个基本准确的预估，并为Redis设定最大使用的内存。<br>否则在64位OS中Redis会无限制地占用内存（当物理内存被占满后会使用swap空间），容易引发各种各样的问题。<br>通过如下配置控制Redis使用的最大内存：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">maxmemory <span class="number">100</span>mb</span></pre></td></tr></table></figure>

<p>在内存占用达到了maxmemory后，再向Redis写入数据时，Redis会：</p>
<ul>
<li>根据配置的数据淘汰策略尝试淘汰数据，释放空间</li>
<li>如果没有数据可以淘汰，或者没有配置数据淘汰策略，那么Redis会对所有写请求返回错误，但读请求仍然可以正常执行</li>
</ul>
<p>在为Redis设置maxmemory时，需要注意：</p>
<p>如果采用了Redis的主从同步，主节点向从节点同步数据时，会占用掉一部分内存空间</p>
<p>如果maxmemory过于接近主机的可用内存，会导致数据同步时内存不足。</p>
<p>所以设置的maxmemory不要过于接近主机可用的内存，留出一部分预留用作主从同步。</p>
<h2 id="数据淘汰机制"><a href="#数据淘汰机制" class="headerlink" title="数据淘汰机制"></a><strong>数据淘汰机制</strong></h2><p>Redis提供了5种数据淘汰策略：</p>
<ul>
<li><strong>volatile-lru</strong>：使用LRU算法进行数据淘汰（淘汰上次使用时间最早的，且使用次数最少的key），只淘汰设定了有效期的key</li>
<li><strong>allkeys-lru</strong>：使用LRU算法进行数据淘汰，所有的key都可以被淘汰</li>
<li><strong>volatile-random</strong>：随机淘汰数据，只淘汰设定了有效期的key</li>
<li><strong>allkeys-random</strong>：随机淘汰数据，所有的key都可以被淘汰</li>
<li><strong>volatile-ttl</strong>：淘汰剩余有效期最短的key</li>
</ul>
<p>最好为Redis指定一种有效的数据淘汰策略以配合maxmemory设置，避免在内存使用满后发生写入失败的情况。<br>一般来说，推荐使用的策略是volatile-lru，并辨识Redis中保存的数据的重要性。<br>对于那些重要的，绝对不能丢弃的数据（如配置类数据等），应不设置有效期，这样Redis就永远不会淘汰这些数据。<br>对于那些相对不是那么重要的，并且能够热加载的数据（比如缓存最近登录的用户信息，当在Redis中找不到时，程序会去DB中读取），可以设置上有效期，这样在内存不够时Redis就会淘汰这部分数据。<br>配置方法：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">maxmemory-policy <span class="keyword">volatile</span>-lru <span class="meta">#默认是noeviction，即不进行数据淘汰</span></span></pre></td></tr></table></figure>

<h2 id="Pipelining"><a href="#Pipelining" class="headerlink" title="Pipelining"></a><strong>Pipelining</strong></h2><p>Redis提供许多批量操作的命令，如MSET/MGET/HMSET/HMGET等等，这些命令存在的意义是减少维护网络连接和传输数据所消耗的资源和时间。<br>例如连续使用5次SET命令设置5个不同的key，比起使用一次MSET命令设置5个不同的key，效果是一样的<br>但前者会消耗更多的RTT(Round Trip Time)时长，永远应优先使用后者。<br>然而，如果客户端要连续执行的多次操作无法通过Redis命令组合在一起，例如：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> a <span class="comment">"abc"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">INCR <span class="comment">b</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HSET <span class="comment">c name</span> <span class="comment">"hi"</span></span></pre></td></tr></table></figure>

<p>此时便可以使用Redis提供的pipelining功能来实现在一次交互中执行多条命令。<br>使用pipelining时，只需要从客户端一次向Redis发送多条命令（以\r\n）分隔，Redis就会依次执行这些命令，并且把每个命令的返回按顺序组装在一起一次返回，比如：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">$ (printf <span class="string">"PING\r<span class="subst">\n</span>PING\r<span class="subst">\n</span>PING\r<span class="subst">\n</span>"</span>; sleep <span class="number">1</span>) | nc localhost <span class="number">6379</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+PONG</span></pre></td></tr><tr><td class="code"><pre><span class="line">+PONG</span></pre></td></tr><tr><td class="code"><pre><span class="line">+PONG</span></pre></td></tr></table></figure>

<p>大部分的Redis客户端都对Pipelining提供支持，所以开发者通常并不需要自己手工拼装命令列表。</p>
<h3 id="Pipelining的局限性"><a href="#Pipelining的局限性" class="headerlink" title="Pipelining的局限性"></a><strong>Pipelining的局限性</strong></h3><p>Pipelining只能用于执行<strong>连续且无相关性</strong>的命令，当某个命令的生成需要依赖于前一个命令的返回时，就无法使用Pipelining了。<br>通过Scripting功能，可以规避这一局限性</p>
<h2 id="事务与Scripting"><a href="#事务与Scripting" class="headerlink" title="事务与Scripting"></a><strong>事务与Scripting</strong></h2><p>Pipelining能够让Redis在一次交互中处理多条命令，然而在一些场景下，我们可能需要在此基础上确保这一组命令是连续执行的。<br>比如获取当前累计的PV数并将其清0</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt; <span class="builtin-name">GET</span> vCount</span></pre></td></tr><tr><td class="code"><pre><span class="line">12384</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; <span class="builtin-name">SET</span> vCount 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">OK</span></pre></td></tr></table></figure>

<p>如果在GET和SET命令之间插进来一个INCR vCount，就会使客户端拿到的vCount不准确。<br>Redis的事务可以确保复数命令执行时的原子性。<br>也就是说Redis能够保证：一个事务中的一组命令是绝对连续执行的，在这些命令执行完成之前，绝对不会有来自于其他连接的其他命令插进去执行。<br>通过MULTI和EXEC命令来把这两个命令加入一个事务中：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt; MULTI</span></pre></td></tr><tr><td class="code"><pre><span class="line">OK</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; GET vCount</span></pre></td></tr><tr><td class="code"><pre><span class="line">QUEUED</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; SET vCount <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">QUEUED</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; EXEC</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="number">12384</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span>) OK</span></pre></td></tr></table></figure>

<p>Redis在接收到MULTI命令后便会开启一个事务，这之后的所有读写命令都会保存在队列中但并不执行<br>直到接收到EXEC命令后，Redis会把队列中的所有命令连续顺序执行，并以数组形式返回每个命令的返回结果。<br>可以使用DISCARD命令放弃当前的事务，将保存的命令队列清空。<br>需要注意的是，<strong>Redis事务不支持回滚</strong>：如果一个事务中的命令出现了语法错误，大部分客户端驱动会返回错误<br>2.6.5版本以上的Redis也会在执行EXEC时检查队列中的命令是否存在语法错误，如果存在，则会自动放弃事务并返回错误。<br>但如果一个事务中的命令有非语法类的错误（比如对String执行HSET操作），无论客户端驱动还是Redis都无法在真正执行这条命令之前发现，所以事务中的所有命令仍然会被依次执行。<br>在这种情况下，会出现一个事务中部分命令成功部分命令失败的情况，然而与RDBMS不同，Redis不提供事务回滚的功能，所以只能通过其他方法进行数据的回滚。</p>
<h2 id="通过事务实现CAS"><a href="#通过事务实现CAS" class="headerlink" title="通过事务实现CAS"></a><strong>通过事务实现CAS</strong></h2><p>Redis提供了WATCH命令与事务搭配使用，实现CAS乐观锁的机制。<br>假设要实现将某个商品的状态改为已售：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">if(exec(HGET stock:<span class="number">1001</span> <span class="keyword">state</span>) == <span class="string">"in stock"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    exec(HSET stock:<span class="number">1001</span> <span class="keyword">state</span> <span class="string">"sold"</span>);</span></pre></td></tr></table></figure>

<p>这一伪代码执行时，无法确保并发安全性，有可能多个客户端都获取到了”in stock”的状态，导致一个库存被售卖多次。<br>使用WATCH命令和事务可以解决这一问题：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">exec(WATCH stock:<span class="number">1001</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">if(exec(HGET stock:<span class="number">1001</span> <span class="keyword">state</span>) == <span class="string">"in stock"</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    exec(MULTI);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    exec(HSET stock:<span class="number">1001</span> <span class="keyword">state</span> <span class="string">"sold"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    exec(EXEC);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>WATCH的机制是</strong>：在事务EXEC命令执行时，Redis会检查被WATCH的key，只有被WATCH的key从WATCH起始时至今没有发生过变更，EXEC才会被执行。<br>如果WATCH的key在WATCH命令到EXEC命令之间发生过变化，则EXEC命令会返回失败。</p>
<h2 id="Scripting"><a href="#Scripting" class="headerlink" title="Scripting"></a><strong>Scripting</strong></h2><p>通过EVAL与EVALSHA命令，可以让Redis执行LUA脚本。这就类似于RDBMS的存储过程一样，可以把客户端与Redis之间密集的读/写交互放在服务端进行，避免过多的数据交互，提升性能。<br>Scripting功能是作为事务功能的替代者诞生的，事务提供的所有能力Scripting都可以做到。Redis官方推荐使用LUA Script来代替事务，前者的效率和便利性都超过了事务。<br>关于Scripting的具体使用，本文不做详细介绍，请参考官方文档 <a href="https://redis.io/commands/eval" target="_blank" rel="noopener">https://redis.io/commands/eval</a></p>
<h1 id="Redis性能调优"><a href="#Redis性能调优" class="headerlink" title="Redis性能调优"></a><strong>Redis性能调优</strong></h1><p>尽管Redis是一个非常快速的内存数据存储媒介，也并不代表Redis不会产生性能问题。<br>前文中提到过，Redis采用单线程模型，所有的命令都是由一个线程串行执行的<br>所以当某个命令执行耗时较长时，会拖慢其后的所有命令，这使得Redis对每个任务的执行效率更加敏感。<br>针对Redis的性能优化，主要从下面几个层面入手：</p>
<ul>
<li>最初的也是最重要的，确保没有让Redis执行耗时长的命令</li>
<li>使用pipelining将连续执行的命令组合执行</li>
<li>操作系统的Transparent huge pages功能必须关闭：</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">echo never &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/mm/</span>transparent_hugepage<span class="regexp">/enabled</span></span></pre></td></tr></table></figure>

<ul>
<li>如果在虚拟机中运行Redis，可能天然就有虚拟机环境带来的固有延迟。</li>
<li>可以通过./redis-cli –intrinsic-latency 100命令查看固有延迟。同时如果对Redis的性能有较高要求的话，应尽可能在物理机上直接部署Redis。</li>
<li>检查数据持久化策略</li>
<li>考虑引入读写分离机制</li>
</ul>
<h2 id="长耗时命令"><a href="#长耗时命令" class="headerlink" title="长耗时命令"></a><strong>长耗时命令</strong></h2><p>Redis绝大多数读写命令的时间复杂度都在O(1)到O(N)之间，在本文和官方文档中均对每个命令的时间复杂度有说明。<br>通常来说，O(1)的命令是安全的，O(N)命令在使用时需要注意，如果N的数量级不可预知，则应避免使用。<br>例如对一个field数未知的Hash数据执行HGETALL/HKEYS/HVALS命令，通常来说这些命令执行的很快，但如果这个Hash中的field数量极多，耗时就会成倍增长。<br>又如使用SUNION对两个Set执行Union操作，或使用SORT对List/Set执行排序操作等时，都应该严加注意。<br>避免在使用这些O(N)命令时发生问题主要有几个办法：</p>
<ul>
<li>不要把List当做列表使用，仅当做队列来使用</li>
<li>通过机制严格控制Hash、Set、Sorted Set的大小</li>
<li>可能的话，将排序、并集、交集等操作放在客户端执行</li>
<li>绝对禁止使用KEYS命令</li>
<li>避免一次性遍历集合类型的所有成员，而应使用SCAN类的命令进行分批的，游标式的遍历</li>
</ul>
<p>Redis提供了SCAN命令，可以对Redis中存储的所有key进行游标式的遍历，避免使用KEYS命令带来的性能问题。<br>同时还有SSCAN/HSCAN/ZSCAN等命令，分别用于对Set/Hash/Sorted Set中的元素进行游标式遍历。<br>SCAN类命令的使用请参考官方文档：<br><a href="https://redis.io/commands/scan" target="_blank" rel="noopener">https://redis.io/commands/scan</a><br>Redis提供了Slow Log功能，可以自动记录耗时较长的命令。相关的配置参数有两个：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">slowlog-<span class="built_in">log</span>-slower-than xxxms #执行时间慢于xxx毫秒的命令计入Slow <span class="built_in">Log</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">slowlog-<span class="built_in">max</span>-<span class="built_in">len</span> xxx #Slow <span class="built_in">Log</span>的长度，即最大纪录多少条Slow <span class="built_in">Log</span></span></pre></td></tr></table></figure>

<p>使用<strong>SLOWLOG GET [number]</strong>命令，可以输出最近进入Slow Log的number条命令。<br>使用<strong>SLOWLOG RESET</strong>命令，可以重置Slow Log</p>
<h2 id="网络引发的延迟"><a href="#网络引发的延迟" class="headerlink" title="网络引发的延迟"></a><strong>网络引发的延迟</strong></h2><ul>
<li>尽可能使用长连接或连接池，避免频繁创建销毁连接</li>
<li>客户端进行的批量数据操作，应使用Pipeline特性在一次交互中完成。具体请参照本文的Pipelining章节</li>
</ul>
<h2 id="数据持久化引发的延迟"><a href="#数据持久化引发的延迟" class="headerlink" title="数据持久化引发的延迟"></a><strong>数据持久化引发的延迟</strong></h2><p>Redis的数据持久化工作本身就会带来延迟，需要根据数据的安全级别和性能要求制定合理的持久化策略：</p>
<ul>
<li>AOF + fsync always的设置虽然能够绝对确保数据安全，但每个操作都会触发一次fsync，会对Redis的性能有比较明显的影响。</li>
<li>AOF + fsync every second是比较好的折中方案，每秒fsync一次</li>
<li>AOF + fsync never会提供AOF持久化方案下的最优性能</li>
<li>使用RDB持久化通常会提供比使用AOF更高的性能，但需要注意RDB的策略配置</li>
<li>每一次RDB快照和AOF Rewrite都需要Redis主进程进行fork操作。fork操作本身可能会产生较高的耗时，与CPU和Redis占用的内存大小有关。根据具体的情况合理配置RDB快照和AOF Rewrite时机，避免过于频繁的fork带来的延迟</li>
</ul>
<blockquote>
<p>Redis在fork子进程时需要将内存分页表拷贝至子进程以占用了24GB内存的Redis实例为例，共需要拷贝24GB / 4kB * 8 = 48MB的数据。在使用单Xeon 2.27Ghz的物理机上，这一fork操作耗时216ms。可以通过<strong>INFO</strong>命令返回的latest_fork_usec字段查看上一次fork操作的耗时（微秒）</p>
</blockquote>
<h2 id="Swap引发的延迟"><a href="#Swap引发的延迟" class="headerlink" title="Swap引发的延迟"></a><strong>Swap引发的延迟</strong></h2><p>当Linux将Redis所用的内存分页移至swap空间时，将会阻塞Redis进程，导致Redis出现不正常的延迟。<br>Swap通常在物理内存不足或一些进程在进行大量I/O操作时发生，应尽可能避免上述两种情况的出现。<br>/proc//smaps文件中会保存进程的swap记录，通过查看这个文件，能够判断Redis的延迟是否由Swap产生。<br>如果这个文件中记录了较大的Swap size，则说明延迟很有可能是Swap造成的。</p>
<h2 id="数据淘汰引发的延迟"><a href="#数据淘汰引发的延迟" class="headerlink" title="数据淘汰引发的延迟"></a><strong>数据淘汰引发的延迟</strong></h2><p>当同一秒内有大量key过期时，也会引发Redis的延迟。在使用时应尽量将key的失效时间错开。</p>
<h2 id="引入读写分离机制"><a href="#引入读写分离机制" class="headerlink" title="引入读写分离机制"></a><strong>引入读写分离机制</strong></h2><p>Redis的主从复制能力可以实现一主多从的多节点架构，在这一架构下，主节点接收所有写请求，并将数据同步给多个从节点。<br>在这一基础上，我们可以让从节点提供对实时性要求不高的读请求服务，以减小主节点的压力。<br>尤其是针对一些使用了长耗时命令的统计类任务，完全可以指定在一个或多个从节点上执行，避免这些长耗时命令影响其他请求的响应。</p>
<h1 id="主从复制与集群分片"><a href="#主从复制与集群分片" class="headerlink" title="主从复制与集群分片"></a><strong>主从复制与集群分片</strong></h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a><strong>主从复制</strong></h2><p>Redis支持一主多从的主从复制架构。一个Master实例负责处理所有的写请求，Master将写操作同步至所有Slave。<br>借助Redis的主从复制，可以实现读写分离和高可用：</p>
<ul>
<li>实时性要求不是特别高的读请求，可以在Slave上完成，提升效率。特别是一些周期性执行的统计任务，这些任务可能需要执行一些长耗时的Redis命令，可以专门规划出1个或几个Slave用于服务这些统计任务</li>
<li>借助Redis Sentinel可以实现高可用，当Master crash后，Redis Sentinel能够自动将一个Slave晋升为Master，继续提供服务</li>
</ul>
<p>启用主从复制非常简单，只需要配置多个Redis实例，在作为Slave的Redis实例中配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">slaveof</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> <span class="number">6379</span> <span class="comment">#指定Master的IP和端口</span></span></pre></td></tr></table></figure>

<p>当Slave启动后，会从Master进行一次冷启动数据同步<br>由Master触发BGSAVE生成RDB文件推送给Slave进行导入，导入完成后Master再将增量数据通过Redis Protocol同步给Slave<br>之后主从之间的数据便一直以Redis Protocol进行同步</p>
<h2 id="使用Sentinel做自动failover"><a href="#使用Sentinel做自动failover" class="headerlink" title="使用Sentinel做自动failover"></a><strong>使用Sentinel做自动failover</strong></h2><p>Redis的主从复制功能本身只是做数据同步，并不提供监控和自动failover能力<br>要通过主从复制功能来实现Redis的高可用，还需要引入一个组件：Redis Sentinel<br>Redis Sentinel是Redis官方开发的监控组件，可以监控Redis实例的状态，通过Master节点自动发现Slave节点，并在监测到Master节点失效时选举出一个新的Master，并向所有Redis实例推送新的主从配置。<br>Redis Sentinel需要至少部署3个实例才能形成选举关系。<br>关键配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">sentinel</span> <span class="string">monitor</span> <span class="string">mymaster</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> <span class="number">2</span> <span class="comment">#Master实例的IP、端口，以及选举需要的赞成票数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">sentinel</span> <span class="string">down-after-milliseconds</span> <span class="string">mymaster</span> <span class="number">60000</span> <span class="comment">#多长时间没有响应视为Master失效</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">sentinel</span> <span class="string">failover-timeout</span> <span class="string">mymaster</span> <span class="number">180000</span> <span class="comment">#两次failover尝试间的间隔时长</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">sentinel</span> <span class="string">parallel-syncs</span> <span class="string">mymaster</span> <span class="number">1</span> <span class="comment">#如果有多个Slave，可以通过此配置指定同时从新Master进行数据同步的Slave数，避免所有Slave同时进行数据同步导致查询服务也不可用</span></span></pre></td></tr></table></figure>

<p>另外需要注意的是，Redis Sentinel实现的自动failover不是在同一个IP和端口上完成的<br>也就是说自动failover产生的新Master提供服务的IP和端口与之前的Master是不一样的，所以要实现HA，还要求客户端必须支持Sentinel，能够与Sentinel交互获得新Master的信息才行。</p>
<h2 id="集群分片"><a href="#集群分片" class="headerlink" title="集群分片"></a><strong>集群分片</strong></h2><p>为何要做集群分片：</p>
<ul>
<li>Redis中存储的数据量大，一台主机的物理内存已经无法容纳</li>
<li>Redis的写请求并发量大，一个Redis实例以无法承载</li>
</ul>
<p>当上述两个问题出现时，就必须要对Redis进行分片了。<br>Redis的分片方案有很多种，例如很多Redis的客户端都自行实现了分片功能，也有像Twemproxy这样的以代理方式实现的Redis分片方案。<br>然而首选的方案还应该是Redis官方在3.0版本中推出的Redis Cluster分片方案。<br>本文不会对Redis Cluster的具体安装和部署细节进行介绍，重点介绍Redis Cluster带来的好处与弊端。</p>
<h3 id="Redis-Cluster的能力"><a href="#Redis-Cluster的能力" class="headerlink" title="Redis Cluster的能力"></a><strong>Redis Cluster的能力</strong></h3><ul>
<li>能够自动将数据分散在多个节点上</li>
<li>当访问的key不在当前分片上时，能够自动将请求转发至正确的分片</li>
<li>当集群中部分节点失效时仍能提供服务</li>
</ul>
<p>其中第三点是基于主从复制来实现的，Redis Cluster的每个数据分片都采用了主从复制的结构，原理和前文所述的主从复制完全一致<br>唯一的区别是省去了Redis Sentinel这一额外的组件，由Redis Cluster负责进行一个分片内部的节点监控和自动failover。</p>
<h3 id="Redis-Cluster分片原理"><a href="#Redis-Cluster分片原理" class="headerlink" title="Redis Cluster分片原理"></a><strong>Redis Cluster分片原理</strong></h3><p>Redis Cluster中共有16384个hash slot，Redis会计算每个key的CRC16，将结果与16384取模，来决定该key存储在哪一个hash slot中，<br>同时需要指定Redis Cluster中每个数据分片负责的Slot数，Slot的分配在任何时间点都可以进行重新分配。<br>客户端在对key进行读写操作时，可以连接Cluster中的任意一个分片，如果操作的key不在此分片负责的Slot范围内，Redis Cluster会自动将请求重定向到正确的分片上。</p>
<h3 id="hash-tags"><a href="#hash-tags" class="headerlink" title="hash tags"></a><strong>hash tags</strong></h3><p>在基础的分片原则上，Redis还支持hash tags功能，以hash tags要求的格式明明的key，将会确保进入同一个Slot中。<br>例如：{uiv}user:1000和{uiv}user:1001拥有同样的hash tag {uiv}，会保存在同一个Slot中。<br>使用Redis Cluster时，pipelining、事务和LUA Script功能涉及的key必须在同一个数据分片上，否则将会返回错误。<br>如要在Redis Cluster中使用上述功能，就必须通过hash tags来确保一个pipeline或一个事务中操作的所有key都位于同一个Slot中。</p>
<blockquote>
<p>有一些客户端（如Redisson）实现了集群化的pipelining操作，可以自动将一个pipeline里的命令按key所在的分片进行分组，分别发到不同的分片上执行。但是Redis不支持跨分片的事务，事务和LUA Script还是必须遵循所有key在一个分片上的规则要求。</p>
</blockquote>
<h2 id="主从复制-vs-集群分片"><a href="#主从复制-vs-集群分片" class="headerlink" title="主从复制 vs 集群分片"></a><strong>主从复制 vs 集群分片</strong></h2><p>在设计软件架构时，要如何在主从复制和集群分片两种部署方案中取舍呢？<br>从各个方面看，Redis Cluster都是优于主从复制的方案</p>
<ul>
<li>Redis Cluster能够解决单节点上数据量过大的问题</li>
<li>Redis Cluster能够解决单节点访问压力过大的问题</li>
<li>Redis Cluster包含了主从复制的能力</li>
</ul>
<p>那是不是代表Redis Cluster永远是优于主从复制的选择呢？<br>并不是！！！<br>软件架构永远不是越复杂越好，复杂的架构在带来显著好处的同时，一定也会带来相应的弊端。采用Redis Cluster的弊端包括：</p>
<p><strong>1、维护难度增加</strong>。</p>
<p>在使用Redis Cluster时，需要维护的Redis实例数倍增，需要监控的主机数量也相应增加，数据备份/持久化的复杂度也会增加。</p>
<p>同时在进行分片的增减操作时，还需要进行reshard操作，远比主从模式下增加一个Slave的复杂度要高。</p>
<p><strong>2、客户端资源消耗增加</strong></p>
<p>当客户端使用连接池时，需要为每一个数据分片维护一个连接池，客户端同时需要保持的连接数成倍增多，加大了客户端本身和操作系统资源的消耗。</p>
<p><strong>3、性能优化难度增加</strong></p>
<p>你可能需要在多个分片上查看Slow Log和Swap日志才能定位性能问题。</p>
<p><strong>4、事务和LUA Script的使用成本增加</strong></p>
<p>在Redis Cluster中使用事务和LUA Script特性有严格的限制条件</p>
<p>事务和Script中操作的key必须位于同一个分片上，这就使得在开发时必须对相应场景下涉及的key进行额外的规划和规范要求。</p>
<p>如果应用的场景中大量涉及事务和Script的使用，如何在保证这两个功能的正常运作前提下把数据平均分到多个数据分片中就会成为难点。</p>
<p>所以，在主从复制和集群分片两个方案中做出选择时，应该从应用软件的功能特性、数据和访问量级、未来发展规划等方面综合考虑，只在<strong>确实有必要</strong>引入数据分片时再使用Redis Cluster。<br><strong>下面是一些建议：</strong></p>
<ul>
<li>需要在Redis中存储的数据有多大？未来2年内可能发展为多大？这些数据是否都需要长期保存？是否可以使用LRU算法进行非热点数据的淘汰？综合考虑前面几个因素，评估出Redis需要使用的物理内存。</li>
<li>用于部署Redis的主机物理内存有多大？有多少可以分配给Redis使用？对比(1)中的内存需求评估，是否足够用？</li>
<li>Redis面临的并发写压力会有多大？在不使用pipelining时，Redis的写性能可以超过10万次/秒（更多的benchmark可以参考 <a href="https://redis.io/topics/benchmarks" target="_blank" rel="noopener">https://redis.io/topics/benchmarks</a> ）</li>
<li>在使用Redis时，是否会使用到pipelining和事务功能？使用的场景多不多？</li>
</ul>
<p>综合上面几点考虑，如果单台主机的可用物理内存完全足以支撑对Redis的容量需求，且Redis面临的并发写压力距离Benchmark值还尚有距离，建议采用主从复制的架构，可以省去很多不必要的麻烦。<br>同时，如果应用中大量使用pipelining和事务，也建议尽可能选择主从复制架构，可以减少设计和开发时的复杂度。</p>
<h1 id="Redis-Java客户端的选择"><a href="#Redis-Java客户端的选择" class="headerlink" title="Redis Java客户端的选择"></a><strong>Redis Java客户端的选择</strong></h1><p>Redis的Java客户端很多，官方推荐的有三种：Jedis、Redisson和lettuce。<br>在这里对Jedis和Redisson进行对比介绍<br>Jedis：</p>
<ul>
<li>轻量，简洁，便于集成和改造</li>
<li>支持连接池</li>
<li>支持pipelining、事务、LUA Scripting、Redis Sentinel、Redis Cluster</li>
<li>不支持读写分离，需要自己实现</li>
<li>文档差（真的很差，几乎没有……）</li>
</ul>
<p>Redisson：</p>
<ul>
<li>基于Netty实现，采用非阻塞IO，性能高</li>
<li>支持异步请求</li>
<li>支持连接池</li>
<li>支持pipelining、LUA Scripting、Redis Sentinel、Redis Cluster</li>
<li>不支持事务，官方建议以LUA Scripting代替事务</li>
<li>支持在Redis Cluster架构下使用pipelining</li>
<li>支持读写分离，支持读负载均衡，在主从复制和Redis Cluster架构下都可以使用</li>
<li>内建Tomcat Session Manager，为Tomcat 6/7/8提供了会话共享功能</li>
<li>可以与Spring Session集成，实现基于Redis的会话共享</li>
<li>文档较丰富，有中文文档</li>
</ul>
<p>对于Jedis和Redisson的选择，同样应遵循前述的原理，尽管Jedis比起Redisson有各种各样的不足，但也应该在需要使用Redisson的高级特性时再选用Redisson，避免造成不必要的程序复杂度提升。</p>
]]></content>
      <categories>
        <category>Java技术</category>
        <category>Redis</category>
      </categories>
  </entry>
</search>
