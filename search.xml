<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaEE完整体系架构</title>
    <url>/2019/12/26/JavaEE%E5%AE%8C%E6%95%B4%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<blockquote>
<p>理想的建筑师应该既是文学家又是数字家，他还应通晓历史，热衷于哲学研究，精通音乐，懂得医药知识，具有法学造诣，深谙天文学及天文计算。 ——Vitruvius（古罗马建筑师） 约公元前25年</p>
</blockquote>
<p>软件架构同样需要方方面面的知识和积累。本文是我自己学习JavaEE的体系架构的时候，根据各种资料学习涂涂画画整理所得，有不对之处求轻喷，也请指出便于改正。<br>JavaEE是一套使用Java进行企业级Web应用开发的大家一致遵循的工业标准。 JavaEE平台提供了一个基于组件的方法来加快设计、开发、装配及部署企业应用程序。 相较于Microsoft的.NET，Sun公司的Java*E和一系列标准、技术及协议更接近或更满足互联网在智能化Web服务方面对开放性、分布性和平台无关性的要求。</p>
<a id="more"></a>

<h3 id="JavaEE的13种核心技术规范："><a href="#JavaEE的13种核心技术规范：" class="headerlink" title="JavaEE的13种核心技术规范："></a>JavaEE的13种核心技术规范：</h3><h4 id="1、JDBC（Java-Database）数据库连接"><a href="#1、JDBC（Java-Database）数据库连接" class="headerlink" title="1、JDBC（Java Database）数据库连接"></a>1、JDBC（Java Database）数据库连接</h4><p>JDBC是一组用于执行SQL的Java API ，为访问不同的数据库提供了一种统一的途径，几乎所有的关系型数据库厂商（DBMS）都提供了JDBC的服务或驱动。JDBC对数据库的访问也具有平台无关性。<br><a href="http://image.winrains.cn/2019/08/20190826100510-ae0c6.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/20190826100510-ae0c6.png" alt="JDBC处理模型"></a></p>
<h4 id="2、JNDI（Java-Naming-and-Directory-Interfaces）Java-的命名和目录接口"><a href="#2、JNDI（Java-Naming-and-Directory-Interfaces）Java-的命名和目录接口" class="headerlink" title="2、JNDI（Java Naming and Directory Interfaces）Java 的命名和目录接口"></a>2、JNDI（Java Naming and Directory Interfaces）Java 的命名和目录接口</h4><p>JNDI是命名目录服务的抽象接口集合，为企业级应用提供了统一的标准化连接，使Java能够无缝地获取任何可目录化的企业信息。在JavaEE体系中，JNDI用来定位各种对象，包括EJB、数据库驱动、JDBC数据源及消息连接等。由于JNDI是独立于目录协议的，因此还可以用JNDI访问各种特定的目录服务，如LDAP（轻量目录访问协议）、NDS（服务器目录访问服务）。<br><a href="http://image.winrains.cn/2019/08/20190826100512-cc297.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/20190826100512-cc297.png" alt="JNDI数据源"></a></p>
<h4 id="3、EJB（Enterprise-JavaBean）"><a href="#3、EJB（Enterprise-JavaBean）" class="headerlink" title="3、EJB（Enterprise JavaBean）"></a>3、EJB（Enterprise JavaBean）</h4><p>EJB组件：JavaBean是在编程环境（IDE）中能够被可视化处理的可重用组件，是实现分布式业务逻辑的 Java 组件。我们在开发的时候可以利用这些组件，像搭积木一样建立面向对象的分布式应用。 EJB容器：是EJB组件的运行环境，为部署EJB组件提供服务，包括事务、安全、远程客户端的网络发布、资源管理等。 EJB服务器：管理EJB容器的高端进程或应用程序，并提供对系统服务的访问。 调用EJB组件的应该称为EJB客户端，客户端可以运行在Web容器中。<br><a href="http://image.winrains.cn/2019/08/20190826100514-71d36.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/20190826100514-71d36.png" alt="EJB"></a></p>
<h4 id="4、RMI（Remote-Method-Invoke）远程方法调用"><a href="#4、RMI（Remote-Method-Invoke）远程方法调用" class="headerlink" title="4、RMI（Remote Method Invoke）远程方法调用"></a>4、RMI（Remote Method Invoke）远程方法调用</h4><p>RMI协议能够让在某个Java虚拟机上的对象，像调用本地对象一样调用另一个Java虚拟机中的对象上的方法。它使用了序列化方式在客户端和服务器端传送数据。RMI是一种被EJB使用的更底层的协议。（stub/skeleton层提供了客户程序和服务程序彼此交互的接口）<br><a href="http://image.winrains.cn/2019/08/20190826100515-cb4da.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/20190826100515-cb4da.png" alt="RMI远程调用"></a></p>
<h4 id="5、Java-IDL（Interface-Description-Language）-CORBA（Common-Object-Broker-Architecture）Java-接口定义语言-公用对象请求代理程序体系结构"><a href="#5、Java-IDL（Interface-Description-Language）-CORBA（Common-Object-Broker-Architecture）Java-接口定义语言-公用对象请求代理程序体系结构" class="headerlink" title="5、Java IDL（Interface Description Language）/CORBA（Common Object Broker Architecture）Java 接口定义语言/公用对象请求代理程序体系结构"></a>5、Java IDL（Interface Description Language）/CORBA（Common Object Broker Architecture）Java 接口定义语言/公用对象请求代理程序体系结构</h4><p>IDL是用来描述软件组件接口的一种计算机语言。IDL通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以相互通信交流。</p>
<h4 id="6、JSP（Java-Server-Pages）"><a href="#6、JSP（Java-Server-Pages）" class="headerlink" title="6、JSP（Java Server Pages）"></a>6、JSP（Java Server Pages）</h4><p>JSP页面由HTML代码和嵌入其中的Java代码所组成。服务器在页面被客户端所请求以后对这些Java代码进行处理，然后将生成的HTML页面返回给客户端的浏览器。 JSP可以使用Servlet提供的API，一般和JavaBean结合使用，从而将界面表现和业务逻辑分离。<br><a href="http://image.winrains.cn/2019/08/20190826100518-a5469.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/20190826100518-a5469.png" alt="JSP"></a></p>
<h4 id="7、Servlet"><a href="#7、Servlet" class="headerlink" title="7、Servlet"></a>7、Servlet</h4><p>Servlet是一种小型的Java程序，它扩展了Web服务器的功能。作为一种服务器端的应用，当被请求时开始执行。Servlet提供的功能大多与JSP类似，不过实现的方式不同。JSP通常是大多数HTML代码中嵌入少量的Java代码，而servlets全部由Java写成并且生成HTML。</p>
<h4 id="8、XML（Extensible-Markup-Language）可扩展白标记语言"><a href="#8、XML（Extensible-Markup-Language）可扩展白标记语言" class="headerlink" title="8、XML（Extensible Markup Language）可扩展白标记语言"></a>8、XML（Extensible Markup Language）可扩展白标记语言</h4><p>XML是一种用于标记电子文件使其具有结构性的标记语言。它被用来在不同的商务过程中共享数据。XML的发展和Java是相互独立的，但是它和Java有着相同的目标，即平台独立性。通过Java和XML的组合，可以得到一个完美的具有平台独立性的解决方案。</p>
<h4 id="9、JMS（Java-Message-Service）Java-消息服务"><a href="#9、JMS（Java-Message-Service）Java-消息服务" class="headerlink" title="9、JMS（Java Message Service）Java 消息服务"></a>9、JMS（Java Message Service）Java 消息服务</h4><p>JMS是Java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。JMS用于和面向消息的中间件相互通信的应用程序接口(API)。它既支持点对点的域，有支持发布/订阅(publish/subscribe)类型的域，并且提供对下列类型的支持：经认可的消息传递,事务型消息的传递，一致性消息和具有持久性的订阅者支持。 JMS消息系统带来的好处：1、提供消息灵活性；2、松散耦合；3、异步性。<br><a href="http://image.winrains.cn/2019/08/20190826100519-dd5eb.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/20190826100519-dd5eb.png" alt="JMS点对点"></a></p>
<h4 id="10、JTA（Java-Transaction-API）Java-事务-API"><a href="#10、JTA（Java-Transaction-API）Java-事务-API" class="headerlink" title="10、JTA（Java Transaction API）Java 事务 API"></a>10、JTA（Java Transaction API）Java 事务 API</h4><p>在JavaEE应用中，事务是一个不可或缺的组件模型，它保证了用户操作ACID（即原子、一致、隔离、持久）属性。对于那些跨数据源（例如多个数据库，或者数据库与JMS）的大型应用，则必须使用全局事务JTA。应用系统可以由JTA定义的标准API访问各种事务监控，JTA为JavaEE平台提供了分布式事务服务，它隔离了事务与底层的资源，实现了透明的事务管理方式。<br><a href="http://image.winrains.cn/2019/08/20190826100521-73c90.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/20190826100521-73c90.png" alt="JTA"></a></p>
<h4 id="11、JTS（Java-Transaction-Service）Java-事务服务"><a href="#11、JTS（Java-Transaction-Service）Java-事务服务" class="headerlink" title="11、JTS（Java Transaction Service）Java 事务服务"></a>11、JTS（Java Transaction Service）Java 事务服务</h4><p>JTS是一个组件事务监视器。JTS是CORBA OTS事务监控的基本实现。JTS规定了事务管理器的实现方式。JTS事务管理器为应用服务器、资源管理器、独立的应用以及通信资源管理器提供了事务服务。</p>
<h4 id="12、JavaMail"><a href="#12、JavaMail" class="headerlink" title="12、JavaMail"></a>12、JavaMail</h4><p>JavaMail是用于存取邮件服务器的API，它提供了一套邮件服务器的抽象类。不仅支持SMTP服务器，也支持IMAP服务器和POP服务器。</p>
<h4 id="13、JAF（JavaBean-Activation-Framework）"><a href="#13、JAF（JavaBean-Activation-Framework）" class="headerlink" title="13、JAF（JavaBean Activation Framework）"></a>13、JAF（JavaBean Activation Framework）</h4><p>JavaMail利用JAF来处理MIME编码的邮件附件。MIME的字节流可以被转换成Java对象，或者转换自Java对象。大多数应用都可以不需要直接使用JAF。</p>
<h3 id="JavaEE软件开发体系架构"><a href="#JavaEE软件开发体系架构" class="headerlink" title="JavaEE软件开发体系架构"></a>JavaEE软件开发体系架构</h3><h4 id="两层架构"><a href="#两层架构" class="headerlink" title="两层架构"></a>两层架构</h4><p>传统的客户服务器系统仅只简单地基于两层体系来构建，即客户端（前台）和企业信息系统（后台），没有任何中间件，业务逻辑层与表示层或数据层混在一起。这种两层架构无论从开发、部署、扩展、维护来说，综其只有一个特点——成本高。</p>
<h4 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h4><p>三层架构自上而下将系统分为表示层、逻辑层、持久层。 表示层由处理用户交互的客户端组件及其容器所组成； 业务逻辑层由解决业务问题的组件组成； 数据层由一个或多个数据库组成，并可包含存储过程。 这种三层架构，在处理客户端的请求时，使客户端不用进行复杂的数据库处理；透明地为客户端执行许多工作，如查询数据库、执行业务规则和连接现有的应用程序；并且能够帮助开发人员创建适用于企业的大型分布式应用程序。<br><a href="http://image.winrains.cn/2019/08/20190826100523-5dc7d.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/20190826100523-5dc7d.png" alt="三层架构"></a></p>
<h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><p>在MVC模式中，应用程序被划分为模型层（Model）、视图层（View）、控制层（Controller）三部分。MVC模型就是把一个应用程序的开发按照业务逻辑、数据、视图进行分离分层并组织代码。MVC要求把应用的模型按一定的层次规则抽取出来，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。模型层负责封装应用的状态，并实现功能，视图层负责将内容呈现给用户，控制层负责控制视图层发送的请求以及程序的流程。 <code>Servlet</code>+<code>JSP</code>+<code>JavaBean</code>（MVC）这种模式比较适合开发复杂的web应用，在这种模式下，Servlet负责处理用户请求，JSP负责数据显示，JavaBean负责封装数据。 <a href="http://image.winrains.cn/2019/08/20190826100525-e1499.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/20190826100525-e1499.png" alt="MVC"></a></p>
<h4 id="基于JavaEE架构模式下的MVC"><a href="#基于JavaEE架构模式下的MVC" class="headerlink" title="基于JavaEE架构模式下的MVC"></a>基于JavaEE架构模式下的MVC</h4><p>在这种架构模式下，模型层（Model）定义了数据模型和业务逻辑。为了将数据访问与业务逻辑分离，降低代码之间的耦合，提高业务精度，模型层又具体划分为了DAO层和业务层，DAO即Data Access Object，其主要职能是将访问数据库的代码封装起来，让这些代码不会在其它层出现或者暴露出来给其它层；业务层是整个系统最核心也是最具有价值的一层，该层封装应用程序的业务逻辑，处理数据，关注客户需求，在业务处理过程中会访问原始数据或产生新数据，DAO层提供的DAO类能很好地帮助业务层完成数据处理，业务层本身侧重于对客户需求的理解和业务规则的适应，总体说来，DAO层不处理业务逻辑，只为业务层提供辅助，完成获取原始数据或持久层数据等操作。<br><a href="http://image.winrains.cn/2019/08/20190826100526-35044.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/20190826100526-35044.png" alt="基于JavaEE架构模式下的MVC"></a></p>
<ul>
<li>JSP：JSP被用来产生Web的动态内容。这层把应用数据以网页的形式呈现给浏览器，然后数据按照在JSP中开发的预定的方式表示出来，这层也可以称之为布局层。</li>
<li>Servlet：JSP建立在Servlet之上，Servlet是J2EE的重要组成部分。Servlet负责处理用户请求，Java Web项目的所有配置都写在了<code>web.xml</code>配置文件里，当项目运行的时候，<code>web.xml</code>会将http请求映射给对应的Servlet类。</li>
<li>JavaBean：由一些具有私有属性的Java类组成，对外提供get和set方法。JavaBean负责数据，负责处理视图层和业务逻辑之间的通信。</li>
<li>Service：业务处理类，对数据进行一些预处理。</li>
<li>DAO：数据访问层，JDBC调用存储过程，从数据库（DataBase）那里获取到数据，再封装到Model实体类中去。</li>
</ul>
<blockquote>
<p>作者：十豆三展</p>
<p>来源：<a href="https://blog.csdn.net/zz13995900221/article/details/80435304" target="_blank" rel="noopener">https://blog.csdn.net/zz13995900221/article/details/80435304</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>什么是POJO，JavaBean</title>
    <url>/2019/12/26/%E4%BB%80%E4%B9%88%E6%98%AFPOJO%EF%BC%8CJavaBean/</url>
    <content><![CDATA[<p>总结：<br>POJO：<br>一个简单的Java类，这个类没有实现/继承任何特殊的java接口或者类，不遵循任何主要java模型，约定或者框架的java对象。在理想情况下，POJO不应该有注解。<br>JavaBean：</p>
<ul>
<li>JavaBean是可序列化的，实现了serializable接口</li>
<li>具有一个无参构造器</li>
<li>有按照命名规范的set和gett，is（可以用于访问布尔类型的属性）方法</li>
</ul>
<a id="more"></a>

<h2 id="pojo"><a href="#pojo" class="headerlink" title="pojo"></a>pojo</h2><blockquote>
<p>点击链接：<a href="https://www.jianshu.com/p/224489dfdec8" target="_blank" rel="noopener">java对象 POJO和JavaBean的区别</a><br>点击链接：<a href="https://link.jianshu.com?t=https://stackoverflow.com/questions/1612334/difference-between-dto-vo-pojo-javabeans" target="_blank" rel="noopener">Difference between DTO, VO, POJO, JavaBeans?</a><br>点击链接：<a href="https://link.jianshu.com?t=https://en.wikipedia.org/wiki/Plain_old_Java_object" target="_blank" rel="noopener">维基百科：Plain old Java object</a></p>
</blockquote>
<p>POJO的创始人(<a href="https://link.jianshu.com?t=https://www.martinfowler.com/bliki/POJO.html" target="_blank" rel="noopener">martinfowler</a>)博客：</p>
<blockquote>
<p>The term was coined while Rebecca Parsons, Josh MacKenzie and I were preparing for a talk at a conference in September 2000. In the talk we were pointing out the many benefits of encoding business logic into regular java objects rather than using Entity Beans. We wondered why people were so against using regular objects in their systems and concluded that it was because simple objects lacked a fancy name. So we gave them one, and it’s caught on very nicely.<br>…在谈话中我们指出，编写业务逻辑的时候，使用常规的java对象要比实体bean要好的多。我们怀疑为什么一些人极力反对在他们的代码中使用常规对象，还辩解称因为这些常规对象没有一个花哨的名字，所以我们给他们起了一个非常好听的名字。（Plain Old Java Object）</p>
</blockquote>
<p>维基百科原文————（以下代码和示例均来源于此）</p>
<blockquote>
<p>The term “POJO” initially denoted a Java object which does not follow any of the major Java object models, conventions, or frameworks; nowadays “POJO” may be used as an acronym for “Plain Old JavaScript Object” as well, in which case the term denotes a JavaScript object of similar pedigree.[2]<br>术语POJO起初表示为不遵任何主要的java模型，约定或者框架的java对象，现在，pojo也可以用作’Plain Old JavaScript Object’的缩写，这样的话和javascript对象有着相似的渊源。</p>
</blockquote>
<p>理想状态下，pojo应该是一个不受Java语言规范限制的java对象。换句话说，pojo<strong>不应该</strong>：<br>1.继承预先设定的类，如：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">javax</span>.<span class="title">servlet</span>.<span class="title">http</span>.<span class="title">HttpServlet</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>2.实现预先设定的接口，如：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">implements</span> <span class="title">javax</span>.<span class="title">ejb</span>.<span class="title">EntityBean</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>3.包含预先指定的注解，如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">@javax.persistence.Entity</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Baz</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>However, due to technical difficulties and other reasons, many software products or frameworks described as POJO-compliant actually still require the use of prespecified annotations for features such as persistence to work properly. The idea is that if the object (actually class) was a POJO before any annotations were added, and would return to POJO status if the annotations are removed then it can still be considered a POJO. Then the basic object remains a POJO in that it has no special characteristics (such as an implemented interface) that makes it a “Specialized Java Object” (SJO or (sic) SoJO).<br>然而，由于技术和其他原因，很多被称之为POJO标准的软件产品或框架仍然需要使用特定的注解来保证持久化等功能。这个想法是，如果对象（类）在任何注解添加之前是一个pojo的话，并且注解移除之后仍然是pojo。所以最基础的pojo解释是没有特别的特征（尤其是实现接口之类的），使其称之为“专用java对象”</p>
</blockquote>
<h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><blockquote>
<p>点此链接：<a href="https://link.jianshu.com?t=https://en.wikipedia.org/wiki/JavaBeans" target="_blank" rel="noopener">维基百科中JavaBeans的概念</a></p>
</blockquote>
<blockquote>
<p>A JavaBean is a POJO that is serializable, has a no-argument constructor, and allows access to properties using getter and setter methods that follow a simple naming convention. Because of this convention, simple declarative references can be made to the properties of arbitrary JavaBeans. Code using such a declarative reference does not have to know anything about the type of the bean, and the bean can be used with many frameworks without these frameworks having to know the exact type of the bean. The JavaBeans specification, if fully implemented, slightly breaks the POJO model as the class must implement the Serializable interface to be a true JavaBean. Many POJO classes still called JavaBeans do not meet this requirement. Since Serializable is a marker (method-less) interface, this is not much of a burden.<br>JavaBean是一个可序列化的POJO，具有一个无参构造器，并且允许使用遵循简单命名约定的getter和setter方法来访问属性。由于这个惯例，可以对任意JavaBean属性进行简单的声明引用。使用这种声明引用的代码不需要知道bean的具体类型。并且，这个bean还可以被很多框架使用，这些java框架也不需要知道bean的类型。由于java.io.Serializable是一个标记接口（无方法），所以这并不是一个多大的负担。如果JavaBean完全实现的话，稍微打破了一些POJO模型。很多被称之为JavaBean的POJO类并不符合这个要求，因为JavaBean必须实现Serializable接口才能成为真正的JavaBean。</p>
</blockquote>
<p>JavaBean的优点：</p>
<blockquote>
<p>The properties, events, and methods of a bean can be exposed to another application.<br>A bean may register to receive events from other objects and can generate events that are sent to those other objects.<br>Auxiliary software can be provided to help configure a bean.<br>The configuration settings of a bean can be saved to persistent storage and restored.</p>
</blockquote>
<ol>
<li>bean中的属性，事件和方法可以暴露给另一个应用程序</li>
<li>一个bean可以注册来自于其他对象的事件，也可以产生事件并发送给其他对象</li>
<li>辅助代码可以提供javabean的配置</li>
<li>一个bean的配置设置可以永远被存储和恢复</li>
</ol>
<blockquote>
<p>作者：施瓦</p>
<p>来源：<a href="https://www.jianshu.com/p/6f3e2bd50cb1" target="_blank" rel="noopener">https://www.jianshu.com/p/6f3e2bd50cb1</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>java对象 POJO和JavaBean的区别</title>
    <url>/2019/12/26/java%E5%AF%B9%E8%B1%A1-POJO%E5%92%8CJavaBean%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h1><p>“Plain Ordinary Java Object”，简单普通的java对象。主要用来指代那些没有遵循特定的java对象模型，约定或者框架的对象。<br>POJO的内在含义是指那些:<br>有一些private的参数作为对象的属性，然后针对每一个参数定义get和set方法访问的接口。<br>没有从任何类继承、也没有实现任何接口，更没有被其它框架侵入的java对象。</p>
<a id="more"></a>

<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicInfoVo</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> orderId;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Integer uid;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getOrderId</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> orderId;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderId</span><span class="params">(<span class="keyword">String</span> orderId)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.orderId = orderId;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getUid</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> uid;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUid</span><span class="params">(Integer uid)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.uid = uid;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h1 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h1><p>JavaBean 是一种JAVA语言写成的可重用组件。JavaBean符合一定规范编写的Java类，不是一种技术，而是一种规范。大家针对这种规范，总结了很多开发技巧、工具函数。符合这种规范的类，可以被其它的程序员或者框架使用。它的方法命名，构造及行为必须符合特定的约定：</p>
<ol>
<li>所有属性为private。</li>
<li>这个类必须有一个公共的缺省构造函数。即是提供无参数的构造器。</li>
<li>这个类的属性使用getter和setter来访问，其他方法遵从标准命名规范。</li>
<li>这个类应是可序列化的。实现serializable接口。</li>
</ol>
<p>因为这些要求主要是靠约定而不是靠实现接口，所以许多开发者把JavaBean看作遵从特定命名约定的POJO。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="title">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 实现serializable接口。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 无参构造器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserInfo</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> age;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.age = age;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// javabean当中可以有其它的方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userInfoPrint</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">""</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h1 id="两者有什么区别"><a href="#两者有什么区别" class="headerlink" title="两者有什么区别"></a>两者有什么区别</h1><ol>
<li>POJO其实是比javabean更纯净的简单类或接口。POJO严格地遵守简单对象的概念，而一些JavaBean中往往会封装一些简单逻辑。</li>
<li>POJO主要用于数据的临时传递，它只能装载数据， 作为数据存储的载体，而不具有业务逻辑处理的能力。</li>
<li>Javabean虽然数据的获取与POJO一样，但是javabean当中可以有其它的方法。</li>
</ol>
<blockquote>
<p>作者：匠丶</p>
<p>来源：<a href="https://www.jianshu.com/p/224489dfdec8" target="_blank" rel="noopener">https://www.jianshu.com/p/224489dfdec8</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>Mybatis数据源和连接池</title>
    <url>/2019/12/26/Mybatis%E6%95%B0%E6%8D%AE%E6%BA%90%E5%92%8C%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<p>本文将从以下几个方面介绍Mybatis的数据源和连接池：</p>
<blockquote>
<ul>
<li>MyBatis数据源DataSource分类</li>
<li>数据源DataSource的创建过程</li>
<li>DataSource什么时候创建Connection对象</li>
</ul>
</blockquote>
<a id="more"></a>

<h3 id="MyBatis数据源DataSource分类"><a href="#MyBatis数据源DataSource分类" class="headerlink" title="MyBatis数据源DataSource分类"></a>MyBatis数据源DataSource分类</h3><p>MyBatis数据源实现是在以下四个包中：</p>
<p><img src="http://image.winrains.cn/2019/08/20190826111423-c3e09.png" alt="http://image.winrains.cn/2019/08/20190826111423-c3e09.png"></p>
<p>MyBatis把数据源DataSource分为三种：<br><strong>1、UNPOOLED：</strong>不使用连接池的数据源<br><strong>2、POOLED：</strong> 使用连接池的数据源<br><strong>3、JNDI：</strong>使用JNDI实现的数据源（JNDI是 Java 命名与目录接口（Java Naming and Directory Interface），在J2EE规范中是重要的规范之一。JNDI由j2ee容器提供，避免了程序与数据库之间的紧耦合，使应用更加易于配置、易于部署）</p>
<p><img src="http://image.winrains.cn/2019/08/20190826111438-ec05b.png" alt="http://image.winrains.cn/2019/08/20190826111438-ec05b.png"></p>
<h3 id="DataSource的创建过程"><a href="#DataSource的创建过程" class="headerlink" title="DataSource的创建过程"></a>DataSource的创建过程</h3><p>通过上一篇文章<a href="https://www.jianshu.com/p/b61f2fde49a7" target="_blank" rel="noopener">Mybatis初始化机制解析</a>可以知道，在Mybatis初始化过程中，会将DataSource实例放到Configuration对象内的Environment对象中。在解析xml配置时：</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;driver&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;url&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;username&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;password&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span></span></pre></td></tr></table></figure>

<p>通过<code>DataSourceFactory.getDataSource()</code>方法来创建数据源DataSource。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826111438-71e24.png" alt="http://image.winrains.cn/2019/08/20190826111438-71e24.png"></p>
<h3 id="DataSource什么时候创建Connection对象"><a href="#DataSource什么时候创建Connection对象" class="headerlink" title="DataSource什么时候创建Connection对象"></a>DataSource什么时候创建Connection对象</h3><p>当我们需要创建SqlSession对象并需要执行SQL语句时，这时候MyBatis才会去调用dataSource对象来创建<code>java.sql.Connection</code>对象。也就是说，java.sql.Connection对象的创建一直延迟到执行SQL语句的时候。例如：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">String<span class="built_in"> resource </span>= <span class="string">"mybatis-config.xml"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span></pre></td></tr><tr><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span></pre></td></tr><tr><td class="code"><pre><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span></pre></td></tr><tr><td class="code"><pre><span class="line">sqlSession.selectList(<span class="string">"SELECT * FROM STUDENTS"</span>);</span></pre></td></tr></table></figure>

<p>前4句都不会导致<code>java.sql.Connection</code>对象的创建，只有当第5句<code>sqlSession.selectList(&quot;SELECT * FROM STUDENTS&quot;)</code>，才会触发MyBatis在底层执行下面这个方法来创建<code>java.sql.Connection</code>对象：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">//<span class="keyword">Transaction</span>的实现类中创建，最终调用到DataSource的实现类</span></pre></td></tr><tr><td class="code"><pre><span class="line">protected <span class="type">void</span> openConnection() throws SQLException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">log</span>.isDebugEnabled()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">log</span>.<span class="keyword">debug</span>("Opening JDBC Connection");</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">connection</span> = dataSource.getConnection();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">level</span> != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">connection</span>.setTransactionIsolation(<span class="keyword">level</span>.getLevel());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    setDesiredAutoCommit(autoCommmit);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="UnpooledDataSource-getConnection"><a href="#UnpooledDataSource-getConnection" class="headerlink" title="UnpooledDataSource.getConnection()"></a>UnpooledDataSource.getConnection()</h3><p>使用<code>UnpooledDataSource</code>的<code>getConnection()</code>,每调用一次就会产生一个新的<code>Connection</code>实例对象。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public Connection get<span class="constructor">Connection()</span> throws SQLException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return <span class="keyword">do</span><span class="constructor">GetConnection(<span class="params">username</span>, <span class="params">password</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Connection <span class="keyword">do</span><span class="constructor">GetConnection(String <span class="params">username</span>, String <span class="params">password</span>)</span> throws SQLException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 封装username和password成properties</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Properties props = <span class="keyword">new</span> <span class="constructor">Properties()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (driverProperties != null) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        props.put<span class="constructor">All(<span class="params">driverProperties</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (username != null) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        props.set<span class="constructor">Property(<span class="string">"user"</span>, <span class="params">username</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (password != null) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        props.set<span class="constructor">Property(<span class="string">"password"</span>, <span class="params">password</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return <span class="keyword">do</span><span class="constructor">GetConnection(<span class="params">props</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 获取数据连接</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Connection <span class="keyword">do</span><span class="constructor">GetConnection(Properties <span class="params">properties</span>)</span> throws SQLException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 1.初始化驱动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    initialize<span class="constructor">Driver()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 2.从DriverManager中获取连接，获取新的Connection对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Connection connection = <span class="module-access"><span class="module"><span class="identifier">DriverManager</span>.</span></span>get<span class="constructor">Connection(<span class="params">url</span>, <span class="params">properties</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 3.配置connection属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    configure<span class="constructor">Connection(<span class="params">connection</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return connection;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="为什么要使用连接池？"><a href="#为什么要使用连接池？" class="headerlink" title="为什么要使用连接池？"></a>为什么要使用连接池？</h3><p>创建一个<code>Connection</code>对象的代价很大，因为创建一个<code>Connection</code>对象的过程，在底层就相当于和数据库建立的通信连接，在建立通信连接的过程，会消耗很多时间，而往往我们建立连接后（即创建<code>Connection</code>对象后），就执行一个简单的SQL语句，然后就要抛弃掉，这是一个非常大的资源浪费！<br>对于需要频繁地跟数据库交互的应用程序，可以在创建了<code>Connection</code>对象，并操作完数据库后，可以不释放掉资源，而是将它放到内存中，当下次需要操作数据库时，可以直接从内存中取出<code>Connection</code>对象，不需要再创建了，这样就极大地节省了创建<code>Connection</code>对象的资源消耗。</p>
<h3 id="PooledDataSource-getConnection"><a href="#PooledDataSource-getConnection" class="headerlink" title="PooledDataSource.getConnection()"></a>PooledDataSource.getConnection()</h3><p><code>PooledDataSource</code>将<code>java.sql.Connection</code>对象包裹成<code>PooledConnection</code>对象放到了<code>PoolState</code>类型的容器中维护。 MyBatis将连接池中的<code>PooledConnection</code>分为两种状态： 空闲状态（idle）和活动状态(active)，这两种状态的<code>PooledConnection</code>对象分别被存储到PoolState容器内的<code>idleConnections</code>和<code>activeConnections</code>两个List集合中。<br><strong>idleConnections：</strong>空闲(idle)状态<code>PooledConnection</code>对象被放置到此集合中，表示当前闲置的没有被使用的<code>PooledConnection</code>集合，调用<code>PooledDataSource</code>的<code>getConnection()</code>方法时，会优先从此集合中取PooledConnection对象。当用完一个<code>java.sql.Connection</code>对象时，MyBatis会将其包裹成<code>PooledConnection</code>对象放到此集合中。<br><strong>activeConnections：</strong>活动(active)状态的<code>PooledConnection</code>对象被放置到名为<code>activeConnections</code>的ArrayList中，表示当前正在被使用的<code>PooledConnection</code>集合，调用<code>PooledDataSource</code>的<code>getConnection()</code>方法时，会优先从<code>idleConnections</code>集合中取<code>PooledConnection</code>对象,如果没有，则看此集合是否已满，如果未满，<code>PooledDataSource</code>会创建出一个<code>PooledConnection</code>，添加到此集合中，并返回。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> Connection </span>getConnection() throws SQLException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return popConnection(dataSource.getUsername(), dataSource.getPassword()).getProxyConnection();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public<span class="built_in"> Connection </span>getConnection(String username, String password) throws SQLException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return popConnection(username, password).getProxyConnection();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>现在让我们看一下<code>popConnection()</code>方法到底做了什么：</p>
<ol>
<li>先看是否有空闲(idle)状态下的<code>PooledConnection</code>对象，如果有，就直接返回一个可用的<code>PooledConnection</code>对象；否则进行第2步。</li>
<li>查看活动状态的<code>PooledConnection</code>池<code>activeConnections</code>是否已满；如果没有满，则创建一个新的<code>PooledConnection</code>对象，然后放到<code>activeConnections</code>池中，然后返回此<code>PooledConnection</code>对象；否则进行第三步；</li>
<li>看最先进入<code>activeConnections</code>池中的<code>PooledConnection</code>对象是否已经过期：如果已经过期，从<code>activeConnections</code>池中移除此对象，然后创建一个新的<code>PooledConnection</code>对象，添加到<code>activeConnections</code>中，然后将此对象返回；否则进行第4步。</li>
<li>线程等待，循环2步</li>
</ol>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">private PooledConnection popConnection(String username, String password) throws SQLException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    boolean countedWait = false;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    PooledConnection conn = null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    long t = System.currentTimeMillis();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int localBadConnectionCount = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    while (conn == null) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        synchronized (<span class="keyword">state</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            if (<span class="keyword">state</span>.idleConnections.size() &gt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                // 连接池中有空闲连接，取出第一个</span></pre></td></tr><tr><td class="code"><pre><span class="line">                conn = <span class="keyword">state</span>.idleConnections.remove(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                if (<span class="keyword">log</span>.isDebugEnabled()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">log</span>.<span class="keyword">debug</span>(<span class="string">"Checked out connection "</span> + conn.getRealHashCode() + <span class="string">" from pool."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                // 连接池中没有空闲连接，则取当前正在使用的连接数小于最大限定值，</span></pre></td></tr><tr><td class="code"><pre><span class="line">                if (<span class="keyword">state</span>.activeConnections.size() <span class="variable">&lt; poolMaximumActiveConnections) &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">                    // 创建一个新的connection对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">                    conn = new PooledConnection(dataSource.getConnection(), this);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">                    @SuppressWarnings("unused")</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">                    // used in logging, if enabled</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">                    Connection realConn = conn.getRealConnection();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">                    if (log.isDebugEnabled()) &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">                        log.debug("Created connection " + conn.getRealHashCode() + ".");</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">                    &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">                &#125; else &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">                    // Cannot create new connection</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">                    // 当活动连接池已满，不能创建时，取出活动连接池的第一个，即最先进入连接池的PooledConnection对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">                    // 计算它的校验时间，如果校验时间大于连接池规定的最大校验时间，则认为它已经过期了，利用这个PoolConnection内部的realConnection重新生成一个PooledConnection</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">                    //</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">                    PooledConnection oldestActiveConnection = state.activeConnections.get(0);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">                    long longestCheckoutTime = oldestActiveConnection.getCheckoutTime();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">                    if (longestCheckoutTime &gt;</span> poolMaximumCheckoutTime) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        // Can claim overdue connection</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">state</span>.claimedOverdueConnectionCount++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">state</span>.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">state</span>.accumulatedCheckoutTime += longestCheckoutTime;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">state</span>.activeConnections.remove(oldestActiveConnection);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        if (!oldestActiveConnection.getRealConnection().getAutoCommit()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            oldestActiveConnection.getRealConnection().rollback();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        conn = new PooledConnection(oldestActiveConnection.getRealConnection(), this);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        oldestActiveConnection.invalidate();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        if (<span class="keyword">log</span>.isDebugEnabled()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="keyword">log</span>.<span class="keyword">debug</span>(<span class="string">"Claimed overdue connection "</span> + conn.getRealHashCode() + <span class="string">"."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125; else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        // 如果不能释放，则必须等待有</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        // Must wait</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        try &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            if (!countedWait) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                <span class="keyword">state</span>.hadToWaitCount++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                countedWait = true;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            if (<span class="keyword">log</span>.isDebugEnabled()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                <span class="keyword">log</span>.<span class="keyword">debug</span>(<span class="string">"Waiting as long as "</span> + poolTimeToWait + <span class="string">" milliseconds for connection."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            long wt = System.currentTimeMillis();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="keyword">state</span>.wait(poolTimeToWait);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="keyword">state</span>.accumulatedWaitTime += System.currentTimeMillis() - wt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        &#125; catch (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            break;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            // 如果获取PooledConnection成功，则更新其信息</span></pre></td></tr><tr><td class="code"><pre><span class="line">            if (conn != null) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                if (conn.isValid()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    if (!conn.getRealConnection().getAutoCommit()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        conn.getRealConnection().rollback();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    conn.<span class="built_in">set</span>ConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    conn.<span class="built_in">set</span>CheckoutTimestamp(System.currentTimeMillis());</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    conn.<span class="built_in">set</span>LastUsedTimestamp(System.currentTimeMillis());</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">state</span>.activeConnections.add(conn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">state</span>.requestCount++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">state</span>.accumulatedRequestTime += System.currentTimeMillis() - t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    if (<span class="keyword">log</span>.isDebugEnabled()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">log</span>.<span class="keyword">debug</span>(<span class="string">"A bad connection ("</span> + conn.getRealHashCode()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                + <span class="string">") was returned from the pool, getting another connection."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">state</span>.badConnectionCount++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    localBadConnectionCount++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    conn = null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    if (localBadConnectionCount &gt; (poolMaximumIdleConnections + <span class="number">3</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        if (<span class="keyword">log</span>.isDebugEnabled()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="keyword">log</span>.<span class="keyword">debug</span>(<span class="string">"PooledDataSource: Could not get a good connection to the database."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        throw new SQLException(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                <span class="string">"PooledDataSource: Could not get a good connection to the database."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (conn == null) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if (<span class="keyword">log</span>.isDebugEnabled()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">log</span>.<span class="keyword">debug</span>(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="string">"PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw new SQLException(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="string">"PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return conn;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>对应的处理流程图如下所示：</p>
<p><img src="http://image.winrains.cn/2019/08/20190826111438-e1605.png" alt="http://image.winrains.cn/2019/08/20190826111438-e1605.png"></p>
<p><strong>Connection对象的回收</strong><br>这里使用了代理模式，为真正的<code>Connection</code>对象创建一个代理对象，代理对象所有的方法都是调用相应的真正<code>Connection</code>对象的方法实现。当代理对象执行<code>close()</code>方法时，要特殊处理，不调用真正<code>Connection</code>对象的close()方法，而是将<code>Connection</code>对象添加到连接池中。MyBatis的<code>PooledDataSource</code>的<code>PoolState</code>内部维护的对象是<code>PooledConnection</code>类型的对象，而<code>PooledConnection</code>则是对真正的数据库连接<code>java.sql.Connection</code>实例对象的包裹器。<br><code>PooledConnection</code>对象内持有一个真正的数据库连接<code>java.sql.Connection</code>实例对象和一个<code>java.sql.Connection</code>的代理：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">PooledConnection</span> <span class="symbol">implements</span> <span class="symbol">InvocationHandler</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 所创建它的datasource引用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> PooledDataSource dataSource;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 真正的Connection对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Connection realConnection;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 代理自己的代理Connection</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Connection proxyConnection;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>让我们看一下<code>PooledConnection</code>类中的<code>invoke()</code>方法定义：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method <span class="keyword">method</span>, Object<span class="literal">[]</span> args) throws Throwable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    String methodName = <span class="keyword">method</span>.get<span class="constructor">Name()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 当调用关闭的时候，回收此Connection到PooledDataSource中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">CLOSE</span>.</span></span>hash<span class="constructor">Code()</span><span class="operator"> == </span>methodName.hash<span class="constructor">Code()</span><span class="operator"> &amp;&amp; </span><span class="module-access"><span class="module"><span class="identifier">CLOSE</span>.</span></span>equals(methodName)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dataSource.push<span class="constructor">Connection(<span class="params">this</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!<span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span><span class="keyword">class</span>.equals(<span class="keyword">method</span>.get<span class="constructor">DeclaringClass()</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                check<span class="constructor">Connection()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return <span class="keyword">method</span>.invoke(realConnection, args);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; catch (Throwable t) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throw <span class="module-access"><span class="module"><span class="identifier">ExceptionUtil</span>.</span></span>unwrap<span class="constructor">Throwable(<span class="params">t</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>作者：匠丶</p>
<p>来源：<a href="https://www.jianshu.com/p/d586b8cb7903" target="_blank" rel="noopener">https://www.jianshu.com/p/d586b8cb7903</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>连接池</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis初始化机制解析</title>
    <url>/2019/12/26/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。本文从深入分析Mybatis的初始化过程。</p>
<a id="more"></a>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>任何框架的初始化，都是从配置信息开始。MyBatis的配置信息，大概包含以下信息，其<a href="http://www.mybatis.org/mybatis-3/zh/configuration.html" target="_blank" rel="noopener">层级结构</a>如下图所示：</p>
<p><img src="http://image.winrains.cn/2019/08/20190826111205-5c0e4.png" alt="http://image.winrains.cn/2019/08/20190826111205-5c0e4.png"></p>
<p>MyBatis的上述配置信息会配置在XML配置文件中，初始化时使用<code>Configuration</code>对象作为配置信息的容器。下面从一个简单例子分析创建<code>Configuration</code>对象的过程：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">String<span class="built_in"> resource </span>= <span class="string">"mybatis-config.xml"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span></pre></td></tr><tr><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span></pre></td></tr><tr><td class="code"><pre><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span></pre></td></tr></table></figure>

<p><code>SqlSessionFactoryBuilder</code>根据传入的数据流生成<code>Configuration</code>对象，然后根据<code>Configuration</code>对象创建默认的<code>SqlSessionFactory</code>实例。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826111205-37063.png" alt="http://image.winrains.cn/2019/08/20190826111205-37063.png"></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">SqlSessionFactoryBuilder.build()</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> build(inputStream, null, null);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, <span class="keyword">String</span> environment, Properties properties)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 2. 创建XMLConfigBuilder对象用来解析XML配置文件，生成Configuration对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 3. 将XML配置文件内的信息解析成Java对象Configuration对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Configuration <span class="built_in">config</span> = parser.parse();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 4. 根据Configuration对象创建出SqlSessionFactory对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> build(<span class="built_in">config</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; finally &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ErrorContext.instance().reset();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            inputStream.<span class="built_in">close</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// Intentionally ignore. Prefer previous error.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 从此处可以看出，MyBatis内部通过Configuration对象来创建SqlSessionFactory,用户也可以自己通过API构造好Configuration对象，调用此方法创建SqlSessionFactory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration <span class="built_in">config</span>)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(<span class="built_in">config</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">XMLConfigBuilder.parser()</span></pre></td></tr></table></figure>

<ol>
<li><pre><code>XMLConfigBuilder
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">会将<span class="built_in">XML</span>配置文件的信息转换为Document对象，而<span class="built_in">XML</span>配置定义文件DTD转换成</span></pre></td></tr></table></figure>
XMLMapperEntityResolver
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   对象，然后将二者封装到XpathParser对象中，XpathParser的作用是提供根据Xpath表达式获取基本的DOM节点Node信息的操作。如下图所示：</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   ![<span class="string">http://image.winrains.cn/2019/08/20190826111206-b678c.png</span>](<span class="link">http://image.winrains.cn/2019/08/20190826111206-b678c.png</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="bullet">2. </span>之后<span class="code">`XMLConfigBuilder`</span>调用<span class="code">`parse()`</span>方法：会从<span class="code">`XPathParser`</span>中取出<span class="code">` `</span>节点对应的Node对象，然后解析此Node节点的子Node：properties, settings, typeAliases,typeHandlers, objectFactory, objectWrapperFactory, plugins, environments,databaseIdProvider, mappers。</span></pre></td></tr></table></figure>
public Configuration parse() {
 if (parsed) {
     throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);
 }
 parsed = true;
 parseConfiguration(parser.evalNode(&quot;/configuration&quot;));
 return configuration;
}
/*
* 解析 &quot;/configuration&quot;节点下的子节点信息，然后将解析的结果设置到Configuration对象中
*/
private void parseConfiguration(XNode root) {
 try {
     // 1.首先处理properties 节点
     propertiesElement(root.evalNode(&quot;properties&quot;)); // issue #117 read
                                                     // properties first
     // 2.处理typeAliases
     typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));
     // 3.处理插件
     pluginElement(root.evalNode(&quot;plugins&quot;));
     // 4.处理objectFactory
     objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));
     // 5.objectWrapperFactory
     objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));
     // 6.settings
     settingsElement(root.evalNode(&quot;settings&quot;));
     // 7.处理environments
     environmentsElement(root.evalNode(&quot;environments&quot;)); // read it after
                                                         // objectFactory
                                                         // and
                                                         // objectWrapperFactory
                                                         // issue #631
     // 8.database
     databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));
     // 9. typeHandlers
     typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));
     // 10 mappers，它将解析Mapper.xml配置文件
     mapperElement(root.evalNode(&quot;mappers&quot;));
 } catch (Exception e) {
     throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);
 }
}</code></pre></li>
</ol>
<p>初始化过程的时序图如下：</p>
<p><img src="http://image.winrains.cn/2019/08/20190826111207-8a6f7.png" alt="http://image.winrains.cn/2019/08/20190826111207-8a6f7.png"></p>
<h3 id="涉及到的设计模式"><a href="#涉及到的设计模式" class="headerlink" title="涉及到的设计模式"></a>涉及到的设计模式</h3><p>初始化的过程涉及到创建各种对象，所以会使用一些创建型的设计模式。在初始化的过程中，Builder模式运用的比较多。例如<code>SqlSessionFactory</code>的创建：对于创建<code>SqlSessionFactory</code>时，会根据情况提供不同的参数。由于构造时参数不定，可以为其创建一个构造器Builder，将<code>SqlSessionFactory</code>的构建过程和表示分开：</p>
<p><img src="http://image.winrains.cn/2019/08/20190826111208-f2086.png" alt="http://image.winrains.cn/2019/08/20190826111208-f2086.png"></p>
<blockquote>
<p>作者：匠丶</p>
<p>来源：<a href="https://www.jianshu.com/p/b61f2fde49a7" target="_blank" rel="noopener">https://www.jianshu.com/p/b61f2fde49a7</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>分布式架构的演进过程</title>
    <url>/2019/12/26/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>一个成熟的大型网站架构并不是一开始就设计的非常完美，也不是一开始就具备高性能、高可用、安全性等特性，而是随着用户量的增加，业务功能的扩展逐步完善演变过来的。在这个过程中，开发模式、技术架构等都会发生非常大的变化。而针对不同业务特征的系统，会有各自的侧重点，比如像淘宝这类的网站，要解决的是海量商品搜索、下单、支付等问题；腾讯，要解决的是数亿级别用户的实时消息传输；百度所要解决的是海量数据的搜索。</p>
<blockquote>
<p>架构是演变而来的，不是设计出来的。没有最好的架构，只有最适合的架构。</p>
</blockquote>
<p>下面以一个简单的电商系统为例，当数据量、访问量提升，观察这个系统可能会发生的结构变化。假如我们系统具备以下功能：用户模块（用户注册和管理），商品模块（商品展示和管理），交易模块（创建交易及支付结算）。</p>
<a id="more"></a>

<h3 id="阶段一、单应用架构"><a href="#阶段一、单应用架构" class="headerlink" title="阶段一、单应用架构"></a>阶段一、单应用架构</h3><p><img src="http://image.winrains.cn/2019/08/20190826112259-cdcee.png" alt="img"></p>
<p>网站的初期也可以认为是互联网发展的早起，我们经常会在单机上跑我们所有的程序和软件。把所有软件和应用都部署在一台机器上，这样就完成一个简单系统的搭建，这个时候的讲究的是效率。</p>
<h3 id="阶段二、应用服务器和数据库服务器分离"><a href="#阶段二、应用服务器和数据库服务器分离" class="headerlink" title="阶段二、应用服务器和数据库服务器分离"></a>阶段二、应用服务器和数据库服务器分离</h3><p>随着网站的上线，访问量逐步上升，服务器的负载慢慢提高，在服务器还没有超载的时候，我们应该做好规划，提升网站的负载能力。假如代码层面的优化已经没办法继续提高，在不提高单台机器的性能，增加机器是一个比较好的方式，投入产出比非常高。这个阶段增加机器的主要目的是将web 服务器和数据库服务器拆分，这样不仅提高了单机的负载能力，也提高了容灾能力。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826112259-c27ab.png" alt="img"></p>
<h3 id="阶段三、应用服务器集群"><a href="#阶段三、应用服务器集群" class="headerlink" title="阶段三、应用服务器集群"></a>阶段三、应用服务器集群</h3><p>随着访问量的继续增加，单台应用服务器已经无法满足需求。在假设数据库服务器还没有遇到性能问题的时候，我们可以增加应用服务器，通过应用服务器集群将用户请求分流到各个服务器中，从而继续提升负载能力。此时多台应用服务器之间没有直接的交互，他们都是依赖数据库各自对外提供服务。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826112300-7cb33.png" alt="img"></p>
<p>架构发展到这个阶段，各种问题也会慢慢呈现，比如用户请求由谁来转发到具体的应用服务器，这时候可能会出现下面的架构模型。<br><img src="http://image.winrains.cn/2019/08/20190826112300-5467f.png" alt="img"></p>
<h3 id="阶段四、数据库读写分离"><a href="#阶段四、数据库读写分离" class="headerlink" title="阶段四、数据库读写分离"></a>阶段四、数据库读写分离</h3><p>当数据库压力变大时，那么怎么去提高数据库层面的负载呢？有了前面的思路以后，自然会想到增加服务器。但是假如我们单纯的把数据库一分为二，然后对于后续数据库的请求，分别负载到两台数据库服务器上，那么一定会造成数据库不统一的问题。所以我们一般先考虑读写分离的方式。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826112300-58c97.png" alt="img"></p>
<h3 id="阶段五、使用搜索引擎缓解读库的压力"><a href="#阶段五、使用搜索引擎缓解读库的压力" class="headerlink" title="阶段五、使用搜索引擎缓解读库的压力"></a>阶段五、使用搜索引擎缓解读库的压力</h3><p>数据库做读库的话，常常对模糊查找效率不是特别好，像电商类的网站，搜索是非常核心的功能，即便是做了读写分离，这个问题也不能有效解决。那么这个时候可以引入搜索引擎，使用搜索引擎能够大大提高我们的查询速度。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826112300-d3dcf.png" alt="img"></p>
<h3 id="阶段六、引入缓存机制缓解数据库的压力"><a href="#阶段六、引入缓存机制缓解数据库的压力" class="headerlink" title="阶段六、引入缓存机制缓解数据库的压力"></a>阶段六、引入缓存机制缓解数据库的压力</h3><p>随着访问量的持续增加，逐渐出现许多用户访问同一部分内容的情况。对于这些热点数据，没必要每次都从数据库去读取，我们可以使用缓存技术，比如memcache、redis 来作为我们应用层的缓存；另外在某些场景下，比如我们对用户的某些IP 的访问频率做限制，那这个放内存中又不合适，放数据库又太麻烦，这个时候可以使用Nosql 的方式比如mongDB 来代替传统的关系型数据库。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826112301-8384b.png" alt="img"></p>
<h3 id="阶段七、数据库的水平-垂直拆分"><a href="#阶段七、数据库的水平-垂直拆分" class="headerlink" title="阶段七、数据库的水平/垂直拆分"></a>阶段七、数据库的水平/垂直拆分</h3><p>我们的网站演进的变化过程，交易、商品、用户的数据都还在同一个数据库中，尽管采取了增加缓存，读写分离的方式，但是随着数据库的压力持续增加，数据库的瓶颈仍然是个最大的问题。因此我们可以考虑对数据的垂直拆分和水平拆分。<br>垂直拆分：把数据库中不同业务数据拆分到不同的数据库。<br>水平拆分：把同一个表中的数据拆分到两个甚至更多的表中。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826112301-3de11.png" alt="img"></p>
<h3 id="阶段八、应用的拆分"><a href="#阶段八、应用的拆分" class="headerlink" title="阶段八、应用的拆分"></a>阶段八、应用的拆分</h3><p>随着业务的发展，业务越来越多，应用的压力越来越大，工程规模也越来越庞大。这个时候就可以考虑将应用拆分，按照领域模型将系统拆成用户、商品、交易子系统。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826112301-c85d9.png" alt="img"></p>
<p>这样拆分以后，可能会有一些相同的代码，比如用户操作，在商品和交易都需要查询，所以会导致每个系统都会有用户查询访问相关操作。这些相同的操作一定是要抽象出来，可以通过服务化的方式来解决。</p>
<h3 id="阶段九、服务化"><a href="#阶段九、服务化" class="headerlink" title="阶段九、服务化"></a>阶段九、服务化</h3><p>服务拆分以后，各个服务之间可以通过RPC 技术进行通信，比较典型的有：webservice、hessian、http、RMI等。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826112302-d971e.png" alt="img"></p>
<blockquote>
<p>作者：匠丶</p>
<p>来源：<a href="https://www.jianshu.com/p/09e3251ce310" target="_blank" rel="noopener">https://www.jianshu.com/p/09e3251ce310</a></p>
</blockquote>
]]></content>
      <categories>
        <category>系统架构</category>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式架构概述</title>
    <url>/2019/12/26/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>随着计算机系统规模变得越来越大，将所有的业务单元集中部署在一个或若干个大型机上的体系架构，已经越来越不能满足当今计算机系统。同时，随着微型计算机的出现，越来越多廉价的PC机成为了各大企业IT架构的首选，分布式的处理方式越来越受到业界的青睐。本文将介绍分布式架构的发展历史和分布式架构的一些相关概念。</p>
<a id="more"></a>

<h3 id="分布式架构的发展历史"><a href="#分布式架构的发展历史" class="headerlink" title="分布式架构的发展历史"></a>分布式架构的发展历史</h3><p>自20世纪60年代大型主机被发明出来之后，凭借其超强的计算和I/O处理能力，以及在稳定性和安全性方面的卓越表现，在很长一段时间内，大型主机引领了计算机行业以及商业计算领域的发展。在大型主机的研发上最知名的当属IBM，其主导研发的革命性产物SYSTEM/360系列大型主机，是计算机发展史上的一个里程碑。<br>伴随着大型主机时代的到来，集中式的计算机系统架构也成为了主流。但从20世纪80年代以来，计算机系统向网络化和微型化的发展日趋明显，传统的集中式处理模式越来越不能适应人们的需求。<br><strong>集中式架构的劣势：</strong><br>1、通常一台大型主机汇集了大量精密的计算机组件，操作非常复杂，导致培养一个能够熟练运维大型主机的人的成本很高；<br>2、大型主机非常昂贵，一台配置较好的IBM大型主机，其售价可能在上百万美元，因此也只有像政府、金融和电信等企业才有能力采购大型主机；<br>3、集中式系统具有明显的单点问题。一旦一台大型主机出现了故障，那么整个系统将处于不可用状态；<br>4、在单一大型主机上进行系统的扩容往往比较困难。</p>
<h4 id="“去-IOE”运动"><a href="#“去-IOE”运动" class="headerlink" title="“去 IOE”运动"></a>“去 IOE”运动</h4><p>IOE 指的是 IBM 小型机、Oracle 数据库、EMC 的高端存储。阿里巴巴在 2009 年发起了一项”去 IOE”运动。阿里巴巴过去一直采用的是 Oracle 数据库，并利用小型机和高端存储设备提供高性能的数据处理和存储服务。随着业务的不断发展，数据量和业务量呈爆发性增长，传统的集中式Oracle 数据库架构在扩展性方面遭遇瓶颈。</p>
<h3 id="分布式架构的常见概念"><a href="#分布式架构的常见概念" class="headerlink" title="分布式架构的常见概念"></a>分布式架构的常见概念</h3><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><p>小饭店原来只有一个厨师，切菜洗菜备料炒菜全干。后来客人多了，厨房一个厨师忙不过来，又请了个厨师，两个厨师都能炒一样的菜，这两个厨师的关系是集群。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826112814-3370d.png" alt="img"></p>
<h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p>为了让厨师专心炒菜，把菜做到极致，又请了个配菜师负责切菜，备菜，备料，厨师和配菜师的关系是分布式，一个配菜师也忙不过来了，又请了个配菜师，两个配菜师关系是集群。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826112815-4d4e5.png" alt="img"></p>
<h4 id="副本机制"><a href="#副本机制" class="headerlink" title="副本机制"></a>副本机制</h4><p>副本(replica/copy)指在分布式系统中为数据或服务提供的冗余。数据副本指在不同的节点上持久化同一份数据，当出现某一个节点的数据丢失时，可以从副本上读取到数据。服务副本表示多个节点提供相同的服务，通过主从关系来实现服务的高可用方案。</p>
<h3 id="分布式系统的难点"><a href="#分布式系统的难点" class="headerlink" title="分布式系统的难点"></a>分布式系统的难点</h3><p>毫无疑问，分布式系统对于集中式系统而言，在实现上会更加复杂。分布式系统将会是更难理解、设计、构建和管理的，同时意味着应用程序的根源问题更难发现。</p>
<h4 id="三态"><a href="#三态" class="headerlink" title="三态"></a>三态</h4><p>在集中式架构中，我们调用一个接口返回的结果只有两种，成功或者失败，但是在分布式领域中，会出现“超时”这个状态。</p>
<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>这是一个老生常谈的问题，我们都知道事务就是对一系统操作的原子性保证。在单机的情况下，我们能够依靠本机的数据库连接和组件轻易做到事务的控制，但是分布式情况下，业务原子性操作很可能是跨服务的，这样就导致了分布式事务。<br>例如 A和 B 操作分别是不同服务下的同一个事务操作内的操作，A 调用 B，A 如果可以清楚的知道 B 是否成功提交从而控制自身的提交还是回滚操作，但是在分布式系统中调用会出现一个新状态就是超时，就是 A 无法知道 B 是成功还是失败，这个时候 A是提交本地事务还是回滚呢？其实这是一个很难的问题，如果强行保证事务一致性，可以采取分布式锁，但是那样会增加系统复杂度而且会增大系统的开销，而且事务跨越的服务越多，消耗的资源越大，性能越低，所以最好的解决方案就是避免分布式事务。<br>还有一种解决方案就是重试机制，但是重试如果不是查询接口，必然涉及到数据库的变更，如果第一次调用成功但是没返回成功结果，那调用方第二次调用对调用方来说依然是重试，但是对于被调用方来说是重复调用，例如 A 向 B 转账，A-100，B + 100，这样会导致 A 扣了 100，而 B 增加 200。这样的结果不是我们期望的，因此需在要写入的接口做幂等设计。多次调用和单次调用是一样的效果。通常可以设置一个唯一键，在写入的时候查询是否已经存在，避免重复写入。但是幂等设计的一个前提就是服务是高可用，否则无论怎么重试都不能调用返回一个明确的结果调用方会一直等待，虽然可以限制重试的次数，但是这已经进入了异常状态了。根据 CAP 和 BASE 理论，不可能在分布式情况下做到高可用和强一致性，一般都是保证最终一致性。</p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>每个服务单独部署，为了达到高可用，每个服务至少是两台机器，因为互联网公司一般使用可靠性不是特别高的普通机器，长期运行宕机概率很高，所以两台机器能够大大降低服务不可用的可能性，这正大型项目会采用十几台甚至上百台来部署一个服务，这不仅是保证服务的高可用，更是提升服务的QPS。但是这样又带来一个问题，一个请求过来到底该路由到哪台机器？</p>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>数据被分散或者复制到不同的机器上，如何保证各台主机之间的数据的一致性将成为一个难点。</p>
<h4 id="节点故障"><a href="#节点故障" class="headerlink" title="节点故障"></a>节点故障</h4><p>分布式系统由多个节点组成，整个分布式系统完全出问题的概率是存在的，但是更多的情况是某个节点出问题。这种情况下我们实现分布式系统时需要考虑的问题。</p>
<blockquote>
<p>作者：匠丶</p>
<p>来源：<a href="https://www.jianshu.com/p/2e228ff3331e" target="_blank" rel="noopener">https://www.jianshu.com/p/2e228ff3331e</a></p>
</blockquote>
]]></content>
      <categories>
        <category>系统架构</category>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>TCP的三次握手与四次挥手</title>
    <url>/2019/12/26/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<h3 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式"></a>TCP报文格式</h3><p><img src="http://image.winrains.cn/2019/08/20190826113124-f3044.png" alt="img"></p>
<p>1、源端口和目的端口，各占2个字节，分别写入源端口和目的端口；<br>2、序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；<br>3、确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；</p>
<a id="more"></a>

<p>4、数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；<br>5、保留，占6位，保留今后使用，但目前应都位0；<br>6、紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；<br>7、确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；<br>8、推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；<br>9、复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；<br>10、同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；<br>11、终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；<br>12、窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；<br>13、检验和，占2字节，校验首部和数据这两部分；<br>14、紧急指针，占2字节，指出本报文段中的紧急数据的字节数；<br>15、选项，长度可变，定义一些其他的可选的参数。</p>
<h3 id="TCP连接的建立"><a href="#TCP连接的建立" class="headerlink" title="TCP连接的建立"></a>TCP连接的建立</h3><p><img src="http://image.winrains.cn/2019/08/20190826113124-f041b.png" alt="img"></p>
<p>三次握手</p>
<p>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。<br>1、TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；<br>2、TCP客户进程也是先创建传输控制块TCB，然后向服务器发出<strong>连接请求报文</strong>，这时报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。<br>3、TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。<br>4、TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。<br>5、当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。<strong>简单理解三次握手：</strong><br>how are you ?<br>fine.And you?<br>Fine.<br><strong>为什么TCP客户端最后还要发送一次确认</strong>？<br>主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p>
<h3 id="TCP连接的断开"><a href="#TCP连接的断开" class="headerlink" title="TCP连接的断开"></a>TCP连接的断开</h3><p><img src="http://image.winrains.cn/2019/08/20190826113125-6e5bb.png" alt="img"></p>
<p>四次挥手</p>
<p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。<br>1、客户端进程发出<strong>连接释放报文</strong>，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。<br>2、服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端和服务器的连接就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。<br>3、客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。<br>4、服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。<br>5、客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。<br>6、服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。<strong>为什么客户端最后还要等待2MSL？</strong><br>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。<br><strong>为什么建立连接是三次握手，关闭连接确是四次挥手</strong>？<br>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p>
<blockquote>
<p>作者：匠丶</p>
<p>来源：<a href="https://www.jianshu.com/p/0e5efbcc9d6f" target="_blank" rel="noopener">https://www.jianshu.com/p/0e5efbcc9d6f</a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络技术</category>
        <category>网络协调</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类的加载和初始化</title>
    <url>/2019/12/26/Java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h3 id="为什么说Java是跨平台语言"><a href="#为什么说Java是跨平台语言" class="headerlink" title="为什么说Java是跨平台语言"></a>为什么说Java是跨平台语言</h3><p>Java语言的运行环境是在Java虚拟机中。 Java虚拟机消除了各个平台之间的差异，只要操作系统平台下安装了Java虚拟机，那么使用Java开发的东西都能在其上面运行。如下图所示：</p>
<p><img src="http://image.winrains.cn/2019/08/20190826133014-69ce9.png" alt="img"></p>
<p>Java虚拟机对各个平台而言，实质上是一个可执行程序。例如在windows平台下，java虚拟机就是一个java.exe进程而已。</p>
<a id="more"></a>

<h3 id="JVM虚拟机启动和加载类过程"><a href="#JVM虚拟机启动和加载类过程" class="headerlink" title="JVM虚拟机启动和加载类过程"></a>JVM虚拟机启动和加载类过程</h3><p>下面以一个简单的java程序，分析虚拟机启动过程。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"hello world"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>当我们运行上面程序时，将会启动一个虚拟机进程，不管Java程序有多么复杂，启动了多少线程，它们都将处于该Java虚拟机进程里。具体过程如下：</p>
<h4 id="1、根据JVM的内存配置，为JVM申请特定大小的内存空间"><a href="#1、根据JVM的内存配置，为JVM申请特定大小的内存空间" class="headerlink" title="1、根据JVM的内存配置，为JVM申请特定大小的内存空间"></a>1、根据JVM的内存配置，为JVM申请特定大小的内存空间</h4><p><img src="http://image.winrains.cn/2019/08/20190826133014-7d648.png" alt="img"></p>
<h4 id="2、创建一个引导类加载器实例"><a href="#2、创建一个引导类加载器实例" class="headerlink" title="2、创建一个引导类加载器实例"></a>2、创建一个引导类加载器实例</h4><p>JVM申请好内存空间后，JVM会创建一个引导类加载器（Bootstrap Classloader）实例，引导类加载器是使用C++实现的，负责加载JVM虚拟机运行时所需的基本系统级别的类，如java.lang.String, java.lang.Object等。引导类加载器(Bootstrap Classloader)会读取 {JRE_HOME}/lib 下的jar包和配置，然后将这些系统类加载到方法区内。<br>方法区用于存储已经被虚拟机加载过的类信息、常量、静态变量、即时编译器编译出的代码等数据。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826133015-e2bcd.png" alt="img"></p>
<blockquote>
<p>Class是一个实实在在的类，在包 java.lang 下。它跟我们自己定义的类一样，是一个实实在在的类，Class对象就是这个Class类的实例了。在Java里，所有的类的根源都是Object类，Class也不例外，它是继承自Object的一个特殊的类，它内部可以记录类的成员、接口等信息。</p>
</blockquote>
<h4 id="3、创建JVM-启动器实例-Launcher-并取得类加载器ClassLoader"><a href="#3、创建JVM-启动器实例-Launcher-并取得类加载器ClassLoader" class="headerlink" title="3、创建JVM 启动器实例 Launcher,并取得类加载器ClassLoader"></a>3、创建JVM 启动器实例 Launcher,并取得类加载器ClassLoader</h4><p>上述步骤完成，JVM基本运行环境就准备就绪了。此时，JVM虚拟机会调用已经加载在方法区的类sun.misc.Launcher 的静态方法getLauncher()， 获取sun.misc.Launcher 实例：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">sun.misc.Launcher launcher = sun.misc.<span class="module-access"><span class="module"><span class="identifier">Launcher</span>.</span></span>get<span class="constructor">Launcher()</span>; <span class="comment">//获取Java启动器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ClassLoader classLoader = launcher.get<span class="constructor">ClassLoader()</span>;          <span class="comment">//获取类加载器ClassLoader用来加载class到内存来</span></span></pre></td></tr></table></figure>

<p>sun.misc.Launcher 使用了单例模式设计，保证一个JVM虚拟机内只有一个sun.misc.Launcher实例。在Launcher的内部，其定义了两个类加载器(ClassLoader)，分别是sun.misc.Launcher.ExtClassLoader和sun.misc.Launcher.AppClassLoader，这两个类加载器分别被称为拓展类加载器(Extension ClassLoader) 和 应用类加载器(Application ClassLoader).如下图所示：<br><img src="http://image.winrains.cn/2019/08/20190826133015-96d11.png" alt="img"><br>此时的 launcher.getClassLoader() 方法将会返回 AppClassLoader实例。<br>当AppClassLoader加载类时，会首先尝试让父加载器ExtClassLoader进行加载，如果父加载器ExtClassLoader加载成功，则AppClassLoader直接返回父加载器ExtClassLoader加载的结果；<br>如果父加载器ExtClassLoader加载失败，AppClassLoader则会判断该类是否是引导的系统类(即是否是通过Bootstrap类加载器加载，这会调用Native方法进行查找)；<br>若要加载的类不是系统引导类，那么ClassLoader将会尝试自己加载，加载失败将会抛出“ClassNotFoundException”。</p>
<blockquote>
<p>上面讨论的应用类加载器AppClassLoader的加载类的模式就是我们常说的双亲委派模型(parent-delegation model).<br>对于某个特定的类加载器而言，应该为其指定一个父类加载器，当用其进行加载类的时候：</p>
<ol>
<li>委托父类加载器帮忙加载；</li>
<li>父类加载器加载不了，则查询引导类加载器有没有加载过该类；</li>
<li>如果引导类加载器没有加载过该类，则当前的类加载器应该自己加载该类；</li>
<li>若加载成功，返回 对应的Class<T> 对象；若失败，抛出异常“ClassNotFoundException”。</li>
</ol>
</blockquote>
<h4 id="4、使用类加载器ClassLoader加载HelloWorld类"><a href="#4、使用类加载器ClassLoader加载HelloWorld类" class="headerlink" title="4、使用类加载器ClassLoader加载HelloWorld类"></a>4、使用类加载器ClassLoader加载HelloWorld类</h4><p>通过 launcher.getClassLoader()方法返回AppClassLoader实例，接着就是AppClassLoader加载HelloWorld类的时候了。</p>
<h4 id="5、加载完成时候JVM会执行HelloWorld类的main方法入口"><a href="#5、加载完成时候JVM会执行HelloWorld类的main方法入口" class="headerlink" title="5、加载完成时候JVM会执行HelloWorld类的main方法入口"></a>5、加载完成时候JVM会执行HelloWorld类的main方法入口</h4><h4 id="6、java程序运行结束，JVM销毁"><a href="#6、java程序运行结束，JVM销毁" class="headerlink" title="6、java程序运行结束，JVM销毁"></a>6、java程序运行结束，JVM销毁</h4><h3 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h3><p>在Java类中对类变量指定初始值有两种方式，一是声明类变量时指定初始值；二是使用静态初始化块为类变量指定初始值。<br>JVM会按照这些语句在程序中的排列顺序依次执行它们。另外，如果类的父类还没初始化，会先初始化父类。例如下面的类：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        b = <span class="number">6</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"---------"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">5</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">9</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(Test.b);<span class="comment">//结果为9</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>作者：匠丶</p>
<p>来源：<a href="https://www.jianshu.com/p/2000f9d805ef" target="_blank" rel="noopener">https://www.jianshu.com/p/2000f9d805ef</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
        <category>类加载机制</category>
      </categories>
  </entry>
  <entry>
    <title>Java对象的创建和初始化</title>
    <url>/2019/12/26/Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<p>建议结合上一篇Java类的加载和初始化一起阅读，将帮助你理解：</p>
<blockquote>
<ul>
<li>什么是Class，什么是class</li>
<li>Java虚拟机启动和类的加载过程</li>
<li>对象的创建方式和初始化顺序</li>
</ul>
</blockquote>
<a id="more"></a>

<h3 id="对象的创建方式"><a href="#对象的创建方式" class="headerlink" title="对象的创建方式"></a>对象的创建方式</h3><p>下面结合代码介绍几种对象的创建方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//待实例化的类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> String name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Integer age;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name = <span class="string">""</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.age = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String name, Integer age)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.age = age;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(name + <span class="string">"is working"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Worker <span class="title">clone</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Worker worker = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> (Worker) <span class="keyword">super</span>.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> worker;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>方式1： 直接使用<code>new</code>的方式,不使用参数</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Worker <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"直接使用new的方式,不使用参数"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Worker();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>方式2： 使用<code>new</code>方式，带参数</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static Worker create<span class="constructor">Worker(String <span class="params">name</span>, <span class="params">int</span> <span class="params">age</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"使用new方式，带参数"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return <span class="keyword">new</span> <span class="constructor">Worker(<span class="params">name</span>, <span class="params">age</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>方式3： 使用反射机制，不带参数的 <code>newInstance()</code> 方法</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Worker createWorker1() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">Class</span> clazz = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Worker worker = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        clazz = <span class="keyword">Class</span>.forName(<span class="string">"com.code.loader.Worker"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        worker = (Worker) clazz.newInstance();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.<span class="keyword">println</span>(<span class="string">"使用反射机制，不带参数的newInstance()方法"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> worker;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>方式4： 使用反射机制 ， <code>Constructor</code>的 <code>newInstance</code>方法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Worker createWorker2() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Worker worker = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Class clazz = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        clazz = Class.forName(<span class="string">"com.code.loader.Worker"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 获取不带参数的构造器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Constructor <span class="keyword">constructor</span> = clazz.getConstructor(<span class="params"></span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 使用构造器创建对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        worker = (Worker) <span class="keyword">constructor</span>.newInstance(<span class="params"></span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"使用反射机制，Constructor的newInstance方法"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> worker;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>方式5： 使用反射机制 ：带参数的构造函数创建新对象</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static Worker create<span class="constructor">Worker3(String <span class="params">name</span>, Integer <span class="params">age</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Worker worker = null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Class clazz = null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        clazz = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name(<span class="string">"com.code.loader.Worker"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 获取带参数的构造器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Constructor constructor = clazz.get<span class="constructor">Constructor(<span class="params">name</span>.<span class="params">getClass</span>()</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                age.get<span class="constructor">Class()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 使用构造器创建对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        worker = (Worker) constructor.<span class="keyword">new</span><span class="constructor">Instance(<span class="params">name</span>, <span class="params">age</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.print<span class="constructor">StackTrace()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; catch (InstantiationException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.print<span class="constructor">StackTrace()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; catch (IllegalAccessException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.print<span class="constructor">StackTrace()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; catch (SecurityException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.print<span class="constructor">StackTrace()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; catch (NoSuchMethodException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.print<span class="constructor">StackTrace()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; catch (IllegalArgumentException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.print<span class="constructor">StackTrace()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; catch (InvocationTargetException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.print<span class="constructor">StackTrace()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"使用反射机制，带参数的构造函数创建新对象"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return worker;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>方式6： 使用序列化和反序列化创建对象</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static Worker create<span class="constructor">Worker4(String <span class="params">name</span>, Integer <span class="params">age</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Worker person = <span class="keyword">new</span> <span class="constructor">Worker()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    person.set<span class="constructor">Name(<span class="params">name</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    person.set<span class="constructor">Age(<span class="params">age</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 序列化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    OutputStream outputStream = <span class="keyword">new</span> <span class="constructor">FileOutputStream(<span class="string">"person.txt"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ObjectOutputStream objectOutputStream = <span class="keyword">new</span> <span class="constructor">ObjectOutputStream(<span class="params">outputStream</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    objectOutputStream.write<span class="constructor">Object(<span class="params">person</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    outputStream.close<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    objectOutputStream.close<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 反序列化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    InputStream inputStream = <span class="keyword">new</span> <span class="constructor">FileInputStream(<span class="string">"person.txt"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ObjectInputStream objectInputStream = <span class="keyword">new</span> <span class="constructor">ObjectInputStream(<span class="params">inputStream</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return (Worker) objectInputStream.read<span class="constructor">Object()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>方式7： 使用对象的<code>clone</code>方法，创建对象</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Worker <span class="title">createWorker5</span><span class="params">(Worker worker)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"使用对象的复制，创建对象"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (Worker) worker.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="对象的初始化顺序"><a href="#对象的初始化顺序" class="headerlink" title="对象的初始化顺序"></a>对象的初始化顺序</h3><p>结合代码，分析对象的初始化顺序</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Child child = <span class="keyword">new</span> Child();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> fatherStr1 = <span class="string">"fatherStr1（静态字段初始化值）"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> fatherStr2 = <span class="string">"fatherStr2（字段初始化值）"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"父类静态代码块："</span> + fatherStr1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fatherStr1 = <span class="string">"fatherStr1（静态代码块赋值）"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"父类构造代码块："</span> + fatherStr2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fatherStr2 = <span class="string">"fatherStr2（构造代码块赋值）"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"父类构造函数块："</span> + fatherStr2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fatherStr2 = <span class="string">"fatherStr2（构造函数赋值）"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="title">extends</span> <span class="title">Father</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> childStr1 = <span class="string">"childStr1（静态字段初始化值）"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> childStr2 = <span class="string">"childStr2（字段初始化值）"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"子类静态代码块："</span> + childStr1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        childStr1 = <span class="string">"childStr1（静态代码块赋值）"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"子类构造代码块："</span> + childStr2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        childStr2 = <span class="string">"childStr2（构造代码块赋值）"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"子类构造函数："</span> + childStr2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        childStr2 = <span class="string">"childStr2（构造函数赋值）"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="comment">/*输出结果：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    父类静态代码块：fatherStr1（静态字段初始化值）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    子类静态代码块：childStr1（静态字段初始化值）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    父类构造代码块：fatherStr2（字段初始化值）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    父类构造函数块：fatherStr2（构造代码块赋值）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    子类构造代码块：childStr2（字段初始化值）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    子类构造函数：childStr2（构造代码块赋值）*/</span></span></pre></td></tr></table></figure>

<p>总结如下，其中静态字段和静态代码块属于类的初始化过程<br>1、父类静态字段初始化，静态代码块初始化<br>2、子类静态字段初始化，子类静态代码块初始化<br>3、父类普通字段初始化，普通代码块初始化<br>4、父类构造函数<br>5、子类普通字段初始化，普通代码块初始化<br>6、子类构造函数</p>
<blockquote>
<p>作者：匠丶</p>
<p>来源：<a href="https://www.jianshu.com/p/a4ff6b0a9661" target="_blank" rel="noopener">https://www.jianshu.com/p/a4ff6b0a9661</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>HotSpot虚拟机中对象的分配、布局和访问</title>
    <url>/2019/12/26/HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E9%85%8D%E3%80%81%E5%B8%83%E5%B1%80%E5%92%8C%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<p>本篇文章以HotSpot虚拟机和常用的内存区域Java堆为例，深入探讨HotSpot在Java堆中对象分配、布局和访问的全过程。</p>
<a id="more"></a>

<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>在<a href="https://www.jianshu.com/p/a4ff6b0a9661" target="_blank" rel="noopener">Java对象的创建和初始化</a>一文中，我们知道了创建对象的几种方式。虚拟机在遇到创建指令时，首先会去检查对象所代表的类是否已经被加载、解析和初始化过。如果没有，那么必须执行相应的类加载过程，详细细节可参考<a href="https://www.jianshu.com/p/2000f9d805ef" target="_blank" rel="noopener">Java类的加载和初始化</a>。<br><strong>空间分配</strong><br>在类加载完成后，将为对象分配空间（把一块确定大小的内存从堆中划分出来）。分配方式包括以下两种：<br>1、假设Java堆中内存是绝对规律的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，分配内存就仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为<strong>指针碰撞</strong>。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826134244-92aa8.png" alt="img"></p>
<p>2、如果堆内存不是规律的，已使用的内存和空闲内存相互交错，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为<strong>空闲列表</strong>。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826134244-87e6f.png" alt="img"></p>
<p>选择哪种分配方式由Java堆是否规整决定，而堆是否规整又是由所采用的垃圾收集器是否带有压缩整理功能决定。因为，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。在分配空间时，还需考虑并发问题。可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：<br>1、对分配空间的动作进行同步处理，实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。<br>2、把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。<br>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值。然后对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在HotSpot虚拟机中，对象在内存中存储的布局分为3块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对象填充</strong>。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826134245-98699.png" alt="img"></p>
<p><img src="http://image.winrains.cn/2019/08/20190826134245-96a47.png" alt="img"></p>
<p>HotSpot对象头Mark Word</p>
<h3 id="对象的访问"><a href="#对象的访问" class="headerlink" title="对象的访问"></a>对象的访问</h3><p>建立对象是为了使用对象，Java程序需要通过栈上的reference数据来操作堆上的具体对象。reference类型是一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种：<br>1、使用句柄访问，Java堆中会划分出一块内存来作为句柄池，reference存储对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826134245-1db93.png" alt="img"></p>
<p>2、使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息（对象头中的类型指针），而reference中存储的直接就是对象地址。<br><img src="http://image.winrains.cn/2019/08/20190826134246-ea3b0.png" alt="img"><br>这两种对象访问方式各有优劣，使用句柄的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只需改变句柄中的实例数据指针，而reference本身不需要修改。<br>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销。就HotSpot虚拟机而言使用的是直接指针方式。</p>
<blockquote>
<p>作者：匠丶</p>
<p>来源：<a href="https://www.jianshu.com/p/99048cd94088" target="_blank" rel="noopener">https://www.jianshu.com/p/99048cd94088</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>HotSpot</tag>
      </tags>
  </entry>
  <entry>
    <title>消息中间件选型</title>
    <url>/2019/12/26/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%80%89%E5%9E%8B/</url>
    <content><![CDATA[<p>目前开源的消息中间件可谓是琳琅满目，能让大家耳熟能详的就有很多，比如 ActiveMQ、RabbitMQ、Kafka、RocketMQ、ZeroMQ 等。不管选择其中的哪一款，都会有用的不趁手的地方。有些大厂在长期的使用过程中积累了一定的经验，其消息队列的使用场景也相对稳定固化，或者目前市面上的消息中间件无法满足自身需求，并且也具备足够的精力和人力而选择自研来为自己量身打造一款消息中间件。但是绝大多数公司还是不会选择重复造轮子，那么选择一款合适自己的消息中间件显得尤为重要。就算是前者，那么在自研出稳定且可靠的相关产品之前还是会经历这样一个选型过程。<br>在整体架构中引入消息中间件，势必要考虑很多因素，比如成本及收益问题，怎么样才能达到最优的性价比？虽然消息中间件种类繁多，但是各自都有各自的侧重点，选择合适自己、扬长避短无疑是最好的方式。</p>
<a id="more"></a>

<h3 id="各类消息队列简述"><a href="#各类消息队列简述" class="headerlink" title="各类消息队列简述"></a>各类消息队列简述</h3><p><strong>ActiveMQ</strong> 是 Apache 出品的、采用 Java 语言编写的完全基于 JMS1.1 规范的面向消息的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信。不过由于历史原因包袱太重，目前市场份额没有后面三种消息中间件多。<br><strong>RabbitMQ</strong> 是采用 Erlang 语言实现的 AMQP 协议的消息中间件，最初起源于金融系统，用于在分布式系统中存储转发消息。RabbitMQ 发展到今天，被越来越多的人认可，这和它在可靠性、可用性、扩展性、功能丰富等方面的卓越表现是分不开的。<br><strong>Kafka</strong> 起初是由 LinkedIn 公司采用 Scala 语言开发的一个分布式、多分区、多副本且基于 zookeeper 协调的分布式消息系统，现已捐献给 Apache 基金会。它是一种高吞吐量的分布式发布订阅消息系统，以可水平扩展和高吞吐率而被广泛使用。目前越来越多的开源分布式处理系统如 Cloudera、Apache Storm、Spark、Flink 等都支持与 Kafka 集成。<br><strong>RocketMQ</strong> 是阿里开源的消息中间件，目前已经捐献个 Apache 基金会，它是由 Java 语言开发的，具备高吞吐量、高可用性、适合大规模分布式系统应用等特点，经历过双 11 的洗礼，实力不容小觑。<br><strong>ZeroMQ</strong> 号称史上最快的消息队列，基于 C 语言开发。ZeroMQ 是一个消息处理队列库，可在多线程、多内核和主机之间弹性伸缩，虽然大多数时候我们习惯将其归入消息队列家族之中，但是其和前面的几款有着本质的区别，ZeroMQ 本身就不是一个消息队列服务器，更像是一组底层网络通讯库，对原有的 Socket API 上加上一层封装而已。</p>
<h3 id="选型要点概述"><a href="#选型要点概述" class="headerlink" title="选型要点概述"></a>选型要点概述</h3><h4 id="功能维度"><a href="#功能维度" class="headerlink" title="功能维度"></a>功能维度</h4><p>衡量一款消息中间件是否符合需求需要从多个维度进行考察，首要的就是功能维度，这个直接决定了你能否最大程度上的实现开箱即用，进而缩短项目周期、降低成本等。如果一款消息中间件的功能达不到想要的功能，那么就需要进行二次开发，这样会增加项目的技术难度、复杂度以及增大项目周期等。<br><strong>优先级队列：</strong><br>优先级队列不同于先进先出队列，优先级高的消息具备优先被消费的特权，这样可以为下游提供不同消息级别的保证。不过这个优先级也是需要有一个前提的：如果消费者的消费速度大于生产者的速度，并且消息中间件服务器（一般简单的称之为 Broker）中没有消息堆积，那么对于发送的消息设置优先级也就没有什么实质性的意义了，因为生产者刚发送完一条消息就被消费者消费了，那么就相当于 Broker 中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。<br><strong>延迟队列：</strong><br>当你在网上购物的时候是否会遇到这样的提示：“三十分钟之内未付款，订单自动取消”？这个是延迟队列的一种典型应用场景。延迟队列存储的是对应的延迟消息，所谓“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。延迟队列一般分为两种：基于消息的延迟和基于队列的延迟。基于消息的延迟是指为每条消息设置不同的延迟时间，那么每当队列中有新消息进入的时候就会重新根据延迟时间排序，当然这也会对性能造成极大的影响。实际应用中大多采用基于队列的延迟，设置不同延迟级别的队列，比如 5s、10s、30s、1min、5mins、10mins 等，每个队列中消息的延迟时间都是相同的，这样免去了延迟排序所要承受的性能之苦，通过一定的扫描策略（比如定时）即可投递超时的消息。<br><strong>死信队列：</strong><br>由于某些原因消息无法被正确的投递，为了确保消息不会被无故的丢弃，一般将其置于一个特殊角色的队列，这个队列一般称之为死信队列。与此对应的还有一个“回退队列”的概念，试想如果消费者在消费时发生了异常，那么就不会对这一次消费进行确认（Ack）, 进而发生回滚消息的操作之后消息始终会放在队列的顶部，然后不断被处理和回滚，导致队列陷入死循环。为了解决这个问题，可以为每个队列设置一个回退队列，它和死信队列都是为异常的处理提供的一种机制保障。实际情况下，回退队列的角色可以由死信队列和重试队列来扮演。<br><strong>重试队列：</strong><br>重试队列其实可以看成是一种回退队列，具体指消费端消费消息失败时，为防止消息无故丢失而重新将消息回滚到 Broker 中。与回退队列不同的是重试队列一般分成多个重试等级，每个重试等级一般也会设置重新投递延时，重试次数越多投递延时就越大。举个例子：消息第一次消费失败入重试队列 Q1，Q1 的重新投递延迟为 5s，在 5s 过后重新投递该消息；如果消息再次消费失败则入重试队列 Q2，Q2 的重新投递延迟为 10s，在 10s 过后再次投递该消息。以此类推，重试越多次重新投递的时间就越久，为此需要设置一个上限，超过投递次数就入死信队列。重试队列与延迟队列有相同的地方，都是需要设置延迟级别，它们彼此的区别是：延迟队列动作由内部触发，重试队列动作由外部消费端触发；延迟队列作用一次，而重试队列的作用范围会向后传递。<br><strong>消费模式：</strong><br>消费模式分为推（push）模式和拉（pull）模式。推模式是指由 Broker 主动推送消息至消费端，实时性较好，不过需要一定的流制机制来确保服务端推送过来的消息不会压垮消费端。而拉模式是指消费端主动向 Broker 端请求拉取（一般是定时或者定量）消息，实时性较推模式差，但是可以根据自身的处理能力而控制拉取的消息量。<br><strong>消息回溯：</strong><br>一般消息在消费完成之后就被处理了，之后再也不能消费到该条消息。消息回溯正好相反，是指消息在消费完成之后，还能消费到之前被消费掉的消息。对于消息而言，经常面临的问题是“消息丢失”，至于是真正由于消息中间件的缺陷丢失还是由于使用方的误用而丢失一般很难追查，如果消息中间件本身具备消息回溯功能的话，可以通过回溯消费复现“丢失的”消息进而查出问题的源头之所在。消息回溯的作用远不止与此，比如还有索引恢复、本地缓存重建，有些业务补偿方案也可以采用回溯的方式来实现。<br><strong>消息堆积 + 持久化：</strong><br>流量削峰是消息中间件的一个非常重要的功能，而这个功能其实得益于其消息堆积能力。从某种意义上来讲，如果一个消息中间件不具备消息堆积的能力，那么就不能把它看做是一个合格的消息中间件。消息堆积分内存式堆积和磁盘式堆积。一般来说，磁盘的容量会比内存的容量要大得多，对于磁盘式的堆积其堆积能力就是整个磁盘的大小。从另外一个角度讲，消息堆积也为消息中间件提供了冗余存储的功能。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>功能维度是消息中间件选型中的一个重要的参考维度，但这并不是唯一的维度。有时候性能比功能还要重要，况且性能和功能很多时候是相悖的，鱼和熊掌不可兼得。消息中间件的性能一般是指其吞吐量和时延。<br>消息中间件的吞吐量始终会受到硬件层面的限制。就以网卡带宽为例，如果单机单网卡的带宽为 1Gbps，如果要达到百万级的吞吐，那么消息体大小不得超过 (1Gb/8)/100W，即约等于 134B，换句话说如果消息体大小超过 134B，那么就不可能达到百万级别的吞吐。这种计算方式同样可以适用于内存和磁盘。<br>时延作为性能维度的一个重要指标，却往往在消息中间件领域所被忽视，因为一般使用消息中间件的场景对时效性的要求并不是很高，如果要求时效性完全可以采用 RPC 的方式实现。虽然不建议在时效性很高的场景下使用消息中间件，但是如果所使用的消息中间件的时延方面比较优秀，那么对于整体系统的性能将会是一个不小的提升。</p>
<h4 id="可靠性-可用性"><a href="#可靠性-可用性" class="headerlink" title="可靠性 + 可用性"></a>可靠性 + 可用性</h4><p>消息丢失是使用消息中间件时所不得不面对的一个同点，其背后消息可靠性也是衡量消息中间件好坏的一个关键因素。尤其是在金融支付领域，消息可靠性尤为重要。然而说到可靠性必然要说到可用性，注意这两者之间的区别，消息中间件的可靠性是指对消息不丢失的保障程度；而消息中间件的可用性是指无故障运行的时间百分比。</p>
<h4 id="运维管理"><a href="#运维管理" class="headerlink" title="运维管理"></a>运维管理</h4><p>在消息中间件的使用过程中难免会出现各式各样的异常情况，有客户端的，也有服务端的，那么怎样及时有效的进行监测及修复。业务线流量有峰值又低谷，尤其是电商领域，那么怎样前进行有效的容量评估，尤其是大促期间？脚踢电源、网线被挖等事件层出不穷，如何有效的做好异地多活？这些都离不开消息中间件的衍生产品——运维管理。<br>运维管理也可以进行进一步的细分，比如：申请、审核、监控、告警、管理、容灾、部署等。<br>申请、审核很好理解，在源头对资源进行管控，既可以进行有效校正应用方的使用规范，配和监控也可以做好流量统计与流量评估工作，一般申请、审核与公司内部系统交融性较大，不适合使用开源类的产品。<br>监控、告警也比较好理解，对消息中间件的使用进行全方位的监控，即可以为系统提供基准数据，也可以在检测到异常的情况配合告警，以便运维、开发人员的迅速介入。除了一般的监控项（比如硬件、GC 等）之外，对于消息中间件还需要关注端到端时延、消息审计、消息堆积等方面。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826134709-7a19a.png" alt="img"></p>
<blockquote>
<p>作者：匠丶</p>
<p>来源：<a href="https://www.jianshu.com/p/3db21eb22eec" target="_blank" rel="noopener">https://www.jianshu.com/p/3db21eb22eec</a></p>
</blockquote>
]]></content>
      <categories>
        <category>其它技术</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>消息中间件简介</title>
    <url>/2019/12/26/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h3 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h3><p>消息中间件是指利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下提供应用解耦、弹性伸缩、冗余存储、流量削峰、异步通信、数据同步等功能。</p>
<a id="more"></a>

<h4 id="消息中间件的传递模式"><a href="#消息中间件的传递模式" class="headerlink" title="消息中间件的传递模式"></a>消息中间件的传递模式</h4><p>消息中间件一般有两种传递模式：点对点模式(P2P)和发布-订阅模式(Pub/Sub)。<br><strong>点对点模式</strong></p>
<p><img src="http://image.winrains.cn/2019/08/20190826134909-85797.png" alt="img"></p>
<p>P2P的特点：<br>1.每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)；<br>2.消息的生产者和消费者之间没有时间上的相关性。无论消费者在生产者发送消息的时候是否处于运行状态，它都可以提取消息。<br><strong>发布-订阅模式(Pub/Sub)</strong></p>
<p><img src="http://image.winrains.cn/2019/08/20190826134910-791ee.png" alt="img"></p>
<p>发布/订阅消息的特点：<br>1.每个消息可以有多个消费者；<br>2.生产者和消费者之间有时间上的相关性。订阅一个主题的消费者只能消费自它订阅之后发布的消息。</p>
<h3 id="消息传递协议"><a href="#消息传递协议" class="headerlink" title="消息传递协议"></a>消息传递协议</h3><p>目前对于网络消息传递的协议版本很多，不同的协议有不同的规范</p>
<h4 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h4><p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。AMQP协议是一种二进制协议，提供客户端应用与消息中间件之间异步、安全、高效地交互。<br>与JMS不同，AMQP是一个Wire级的协议，它描述了在网络上传输的数据的格式，以字节为流。因此任何遵守此数据格式的工具，其创建和解释消息，都能与其他兼容工具进行互操作。<br>AMQP的实现有：<br>1）OpenAMQ<br>AMQP的开源实现，用C语言编写，运行于Linux、AIX、Solaris、Windows、OpenVMS。<br>2）Apache Qpid<br>Apache的开源项目，支持C++、Ruby、Java、JMS、Python和.NET。<br>3）Redhat Enterprise MRG<br>实现了AMQP的最新版本0-10，提供了丰富的特征集，比如完全管理、联合、Active-Active集群，有Web控制台，还有许多企业级特征，客户端支持C++、Ruby、Java、JMS、Python和.NET。<br>4）RabbitMQ<br>一个独立的开源实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。RabbitMQ发布在Ubuntu、FreeBSD平台。<br>5）AMQP Infrastructure<br>Linux下，包括Broker、管理工具、Agent和客户端。<br>6）Zyre<br>是一个Broker，实现了RestMS协议和AMQP协议，提供了RESTful HTTP访问网络AMQP的能力。</p>
<h3 id="JMS协议"><a href="#JMS协议" class="headerlink" title="JMS协议"></a>JMS协议</h3><p>JMS（Java Messaging Service）是Java平台上有关面向消息中间件的技术规范，它便于消息系统中的Java应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发。<br>JMS本身只定义了一系列的接口规范，是一种与厂商无关的 API，用来访问消息收发系统。它类似于 JDBC(Java Database Connectivity)：这里，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。许多厂商目前都支持 JMS，包括 IBM 的 MQSeries、BEA的 Weblogic JMS service和 Progress 的 SonicMQ。</p>
<h4 id="STOMP协议"><a href="#STOMP协议" class="headerlink" title="STOMP协议"></a>STOMP协议</h4><p>STOMP，Streaming Text Orientated Message Protocol，是流文本定向消息协议，是一种为MOM(Message Oriented Middleware，面向消息的中间件)设计的简单文本协议。<br>它提供了一个可互操作的连接格式，允许STOMP客户端与任意STOMP消息代理(Broker)进行交互，类似于OpenWire(一种二进制协议)。<br>由于其设计简单，很容易开发客户端，因此在多种语言和多种平台上得到广泛应用。<br>STOMP协议工作于TCP协议之上，使用了下列命令：</p>
<ul>
<li>SEND 发送</li>
<li>SUBSCRIBE 订阅</li>
<li>UNSUBSCRIBE 退订</li>
<li>BEGIN 开始</li>
<li>COMMIT 提交</li>
<li>ABORT 取消</li>
<li>ACK 确认</li>
<li>DISCONNECT 断开</li>
</ul>
<blockquote>
<p>作者：匠丶</p>
<p>来源：<a href="https://www.jianshu.com/p/edf41bb8878e" target="_blank" rel="noopener">https://www.jianshu.com/p/edf41bb8878e</a></p>
</blockquote>
]]></content>
      <categories>
        <category>其它技术</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>从JMS规范了解ActiveMQ</title>
    <url>/2019/12/26/%E4%BB%8EJMS%E8%A7%84%E8%8C%83%E4%BA%86%E8%A7%A3ActiveMQ/</url>
    <content><![CDATA[<h3 id="ActiveMQ-简介"><a href="#ActiveMQ-简介" class="headerlink" title="ActiveMQ 简介"></a>ActiveMQ 简介</h3><p>ActiveMQ 是完全基于 JMS 规范实现的一个消息中间件产品。是 Apache 开源基金会研发的消息中间件。ActiveMQ主要应用在分布式系统架构中，帮助构建高可用、高性能、可伸缩的企业级面向消息服务的系统。<br>ActiveMQ 特性：<br>1、多语言和协议编写客户端，语言：java/C/C++/C#/Ruby/Perl/Python/PHP，应用协议：openwire/stomp/REST/ws/notification/XMPP/AMQP；<br>2、完全支持 jms1.1 和 J2ee1.4 规范；<br>3、对 spring 的支持，ActiveMQ 可以很容易内嵌到 spring模块中。</p>
<h3 id="从-JMS-规范来了解-ActiveMQ"><a href="#从-JMS-规范来了解-ActiveMQ" class="headerlink" title="从 JMS 规范来了解 ActiveMQ"></a>从 JMS 规范来了解 ActiveMQ</h3><p>JMS 定义，Java 消息服务（Java Message Service）是 java 平台中关于面向消息中间件的 API，用于在两个应用程序之间，或者分布式系统中发送消息，进行异步通信。<br>JMS 规范的目的是为了使得 Java 应用程序能够访问现有 MOM (消息中间件)系统，形成一套统一的标准规范，解决不同消息中间件之间的协作问题。<br>JMS的体系结构，如下图所示：<br><img src="http://image.winrains.cn/2019/08/20190826135322-ade1b.png" alt="img"><br>生产者发送消息到ActiveMQ：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"> ConnectionFactory connectionFactory= <span class="built_in">new</span> ActiveMQConnectionFactory("tcp://192.168.11.153:61616");</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="keyword">Connection</span> <span class="keyword">connection</span>=connectionFactory.createConnection();</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="keyword">connection</span>.<span class="keyword">start</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="keyword">Session</span> <span class="keyword">session</span>=<span class="keyword">connection</span>.createSession (<span class="type">Boolean</span>.<span class="keyword">FALSE</span>,<span class="keyword">Session</span>.AUTO_ACKNOWLEDGE);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> //创建目的地</span></pre></td></tr><tr><td class="code"><pre><span class="line"> Destination destination=<span class="keyword">session</span>.createQueue("myQueue");</span></pre></td></tr><tr><td class="code"><pre><span class="line">//创建发送者</span></pre></td></tr><tr><td class="code"><pre><span class="line"> MessageProducer producer=<span class="keyword">session</span>.createProducer(destination);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> producer.setDeliveryMode(DeliveryMode.PERSISTENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> TextMessage message = <span class="keyword">session</span>.createTextMessage("Hello World:"+i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">//<span class="type">Text</span>   Map  Bytes  Stream  <span class="keyword">Object</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> producer.send(message);</span></pre></td></tr></table></figure>

<p>消费者消费消息:</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"> ConnectionFactory connectionFactory= <span class="built_in">new</span> ActiveMQConnectionFactory("tcp://192.168.11.153:61616");</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="keyword">Connection</span> <span class="keyword">connection</span>=connectionFactory.createConnection();</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="keyword">connection</span>.<span class="keyword">start</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="keyword">Session</span> <span class="keyword">session</span>=<span class="keyword">connection</span>.createSession (<span class="type">Boolean</span>.<span class="keyword">FALSE</span>,<span class="keyword">Session</span>.AUTO_ACKNOWLEDGE);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> //创建目的地</span></pre></td></tr><tr><td class="code"><pre><span class="line"> Destination destination=<span class="keyword">session</span>.createQueue("myQueue");</span></pre></td></tr><tr><td class="code"><pre><span class="line">//创建消费者</span></pre></td></tr><tr><td class="code"><pre><span class="line"> MessageConsumer consumer=<span class="keyword">session</span>.createConsumer(destination);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> TextMessage message = (TextMessage) consumer.receive();</span></pre></td></tr></table></figure>

<p><img src="http://image.winrains.cn/2019/08/20190826135322-dc665.png" alt="img"></p>
<h3 id="JMS-的基本功能"><a href="#JMS-的基本功能" class="headerlink" title="JMS 的基本功能"></a>JMS 的基本功能</h3><p>消息传递域：<br>JMS 规范中定义了两种消息传递域：点对点（point-to-point ） 消 息 传 递 域 和 发 布 / 订 阅 消 息 传 递 域(publish/subscribe)。<br><strong>点对点消息传递域：</strong></p>
<ol>
<li>每个消息只能有一个消费者；</li>
<li>消息的生产者和消费者之间没有时间上的相关性。无论消费者在生产者发送消息的时候是否处于运行状态，都可以提取消息。<img src="http://image.winrains.cn/2019/08/20190826135322-a2911.png" alt="img"></li>
</ol>
<p><strong>发布订阅消息传递域：</strong></p>
<ol>
<li>每个消息可以有多个消费者；</li>
<li>生产者和消费者之间有时间上的相关性。订阅一个主题的消费者只能消费自它订阅之后发布的消息。JMS 规范允许客户创建持久订阅，这在一定程度上降低了时间上的相关性要求。持久订阅允许消费者消费它在未处于激活状态时发送的消息。<img src="http://image.winrains.cn/2019/08/20190826135322-9ab08.png" alt="img"></li>
</ol>
<p>消息组成结构：<br>JMS 消息组成部分：消息头、属性、消息体。<br><strong>消息头：</strong><br>消息头(Header) - 消息头包含消息的识别信息和路由信息，消息头包含一些标准的属性如：<br>JMSDestination 消息发送的目的地(queue或者topic)；<br>JMSDeliveryMode 传送模式。持久模式和非持久模式；<br>JMSPriority 消息优先级（优先级分为 10 个级别，从 0(最低)到 9(最高)，如果不设定优先级，默认级别是4；<br>JMSMessageID 唯一识别每个消息的标识。<br><strong>属性：</strong><br>按类型可以分为应用设置的属性，标准属性和消息中间件定义的属性。</p>
<ol>
<li>应用程序设置和添加的属性，比如Message.setStringProperty(“key”,”value”)；</li>
<li>JMS 定义的属性，使用“JMSX”作为属性名的前缀；</li>
<li>JMS provider 特定的属性。</li>
</ol>
<p><strong>消息体：</strong><br>就是我们需要传递的消息内容，JMS API 定义了 5 中消息体格式，可以使用不同形式发送接收数据，并可以兼容现有的消息格式，其中包括：</p>
<table>
<thead>
<tr>
<th>格式</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>TextMessage</td>
<td>java.lang.String 对象，如 xml 文件内容</td>
</tr>
<tr>
<td>MapMessage</td>
<td>key是 String 对象，value类型可以是 Java 任何基本类型</td>
</tr>
<tr>
<td>BytesMessage</td>
<td>字节流</td>
</tr>
<tr>
<td>StreamMessage</td>
<td>Java 中的输入输出流</td>
</tr>
<tr>
<td>ObjectMessage</td>
<td>Java 中的可序列化对象</td>
</tr>
<tr>
<td>Message</td>
<td>没有消息体，只有消息头和属性</td>
</tr>
</tbody></table>
<p><strong>持久订阅：</strong></p>
<ol>
<li>持久订阅者和非持久订阅者针对的是 Pub/Sub</li>
<li>当 Broker 发送消息给订阅者时，如果订阅者处于未激活状态状态：持久订阅者可以收到消息，而非持久订阅者则收不到消息。</li>
</ol>
<p>这种方式也有一定的影响：当持久订阅者处于未激活状态时，Broker 需要为持久订阅者保存消息；如果持久订阅者订阅的消息太多则会溢出。</p>
<h3 id="JMS-消息的可靠性机制"><a href="#JMS-消息的可靠性机制" class="headerlink" title="JMS 消息的可靠性机制"></a>JMS 消息的可靠性机制</h3><p>理论上来说，我们需要保证消息中间件上的消息，只有被消费者确认过以后才会被签收，相当于我们寄一个快递出去，收件人没有收到快递，就认为这个包裹还是属于待签收状态，这样才能保证包裹能够安全达到收件人手里。消息中间件也是一样。<br>消息的消费通常包含 3 个阶段：客户接收消息、客户处理消息、消息被确认。<br>首先，简单了解 JMS 的事务性会话和非事务性会话的概念。<br><strong>事务型会话：</strong><br>在事务状态下进行发送操作，消息并未真正投递到中间件，而只有进行 session.commit 操作之后，消息才会发送到中间件，再转发到适当的消费者进行处理。如果是调用rollback 操作，则表明，当前事务期间内所发送的消息都取消。通过在创建 session 的时候使用 true or false 来决定当前的会话是事务性还是非事务性。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">connection</span>.createSession(<span class="type">Boolean</span>.<span class="keyword">TRUE</span>,<span class="keyword">Session</span>.AUTO_ACKNOWLEDGE);</span></pre></td></tr></table></figure>

<p>在事务性会话中，消息的确认是自动进行，也就是通过session.commit()以后，消息会自动确认。并且必须保证发送端和接收端都是事务性会话。<br><strong>非事务型会话：</strong><br>消 息 何 时 被 确 认 取 决 于 创 建 会 话 时 的 应 答 模 式(acknowledgement mode)，有三个可选项：<br>1、Session.AUTO_ACKNOWLEDGE，当客户成功的从 receive 方法返回的时候，或者从MessageListenner.onMessage 方法成功返回的时候，会话自动确认客户收到消息。<br>2、Session.CLIENT_ACKNOWLEDGE，客户通过调用消息的 acknowledge 方法确认消息。<br>3、Session.DUPS_ACKNOWLEDGE，消息延迟确认。指定消息提供者在消息接收者没有确认发送时重新发送消息，这种模式不在乎接受者收到重复的消息。<br><strong>消息的持久化</strong><br>消息的持久化存储也是保证可靠性最重要的机制之一，也就是消息发送到 Broker 上以后，如果 broker 出现故障宕机了，那么存储在 broker 上的消息不会丢失。<br>对于非持久的消息，JMS provider 不会将它存到文件/数据库等稳定的存储介质中。也就是说非持久消息驻留在内存中，如果 jms provider 宕机，那么内存中的非持久消息会丢失。<br>对于持久消息，消息提供者会使用存储-转发机制，先将消息存储到稳定介质中，等消息发送成功后再删除。</p>
<h4 id="消息的幂等"><a href="#消息的幂等" class="headerlink" title="消息的幂等"></a>消息的幂等</h4><p><strong>为什么会有重复消息</strong><br>主要是分布式系统可能出现网络不稳定、应用宕机等异常情况，简单分为：<br>1、生产者发送重复消息，当一条消息成功发送到broker并持久化到硬盘之后，此时出现了网络抖动、客户端宕机、应用重启，导致broker回复客户端失败，客户端没有收到发送成功的通知，会重试三次发送给broker，这时消费者可能收到两条内容相同、消息id也相同的消息；重要业务系统通常会针对发送失败的消息定时重发，这时消费组可能收到两条内容相同、消息id不同的消息；<br>2、broker发送重复消息，当消费者成功执行消费业务逻辑之后，此时客户端与broker之间出现网络抖动、客户端宕机、应用重启等意外情况，提交给broker的消费进度更新失败。为了确保消息至少被消费一次，此时broker会再次投递，消费者便收到了两条消息内容相同的消息。<br><strong>如何去重</strong><br>1、在消费业务逻辑之前，去除业务唯一键，如订单id、任务id等，判断是否在Mysql或Redis存在，存在则跳过消费，对于重要消息，如订单、交易等需要考虑消费的原子性。禁止使用msgid来去重，由于网络抖动或者业务补偿可能出现msgid不同但消息内容的情况。<br>2、使用业务层面的状态机去重</p>
<blockquote>
<p>作者：匠丶</p>
<p>来源：<a href="https://www.jianshu.com/p/136ef95765d4" target="_blank" rel="noopener">https://www.jianshu.com/p/136ef95765d4</a></p>
</blockquote>
]]></content>
      <categories>
        <category>其它技术</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>ActiveMQ发送消息原理解析</title>
    <url>/2019/12/26/ActiveMQ%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>本文将对ActiveMQ发送消息的源码进行解析，并分析ActiveMQ持久化消息和非持久化消息的发送策略和消息的存储策略。</p>
<a id="more"></a>

<h3 id="消息的发送原理"><a href="#消息的发送原理" class="headerlink" title="消息的发送原理"></a>消息的发送原理</h3><h4 id="消息同步发送和异步发送"><a href="#消息同步发送和异步发送" class="headerlink" title="消息同步发送和异步发送"></a>消息同步发送和异步发送</h4><p>ActiveMQ支持同步、异步两种发送模式将消息发送到broker上。<br>同步发送过程中，发送者发送一条消息会阻塞直到broker反馈一个确认消息，表示消息已经被broker处理。这个机制提供了消息的安全性保障，但是由于是阻塞的操作，会影响到客户端消息发送的性能。<br>异步发送的过程中，发送者不需要等待broker提供反馈，所以性能相对较高。但是可能会出现消息丢失的情况。所以使用异步发送的前提是在某些情况下允许出现数据丢失的情况。<br>默认情况下，非持久化消息是异步发送的，持久化消息并且是在非事务模式下是同步发送的。<br>但是在开启事务的情况下，消息都是异步发送。由于异步发送的效率会比同步发送性能更高。所以在发送持久化消息的时候，尽量去开启事务会话。<br>除了持久化消息和非持久化消息的同步和异步特性以外，我们还可以通过以下几种方式来设置异步发送：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> <span class="constructor">ActiveMQConnectionFactory(<span class="string">"tcp://192.168.11.153:61616?jms.useAsyncSend=true"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">((ActiveMQConnectionFactory) connectionFactory).set<span class="constructor">UseAsyncSend(<span class="params">true</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">((ActiveMQConnection)connection).set<span class="constructor">UseAsyncSend(<span class="params">true</span>)</span>;</span></pre></td></tr></table></figure>

<h4 id="消息发送源码分析"><a href="#消息发送源码分析" class="headerlink" title="消息发送源码分析"></a>消息发送源码分析</h4><p>消息发送的流程图如下：</p>
<p><img src="http://image.winrains.cn/2019/08/20190826140519-f1b4d.png" alt="img"></p>
<p>以<code>ActiveMQMessageProducer.send</code>为入口：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> send(Destination destination, Message message, <span class="keyword">int</span> deliveryMode, <span class="keyword">int</span> priority, <span class="keyword">long</span> timeToLive,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        AsyncCallback onComplete) <span class="keyword">throws</span> JMSException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    checkClosed(); <span class="comment">// 检查session的状态，如果session以关闭则抛异常</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (destination == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (info.getDestination() == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"A destination must be specified."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidDestinationException(<span class="string">"Don't understand null destinations"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ActiveMQDestination dest;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (destination.equals(info.getDestination())) &#123;<span class="comment">// 检查destination的类型，如果符合要求，就转变为ActiveMQDestination</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        dest = (ActiveMQDestination) destination;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info.getDestination() == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dest = ActiveMQDestination.transform(destination);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="string">"This producer can only send messages to: "</span> + <span class="keyword">this</span>.info.getDestination().getPhysicalName());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (dest == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JMSException(<span class="string">"No destination specified"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (transformer != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Message transformedMessage = transformer.producerTransform(session, <span class="keyword">this</span>, message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (transformedMessage != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            message = transformedMessage;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (producerWindow != <span class="keyword">null</span>) &#123;<span class="comment">// 如果发送窗口大小不为空，则判断发送窗口的大小决定是否阻塞</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            producerWindow.waitForSpace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JMSException(<span class="string">"Send aborted due to thread interrupt."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 发送消息到broker的topic</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">this</span>.session.send(<span class="keyword">this</span>, dest, message, deliveryMode, priority, timeToLive, producerWindow, sendTimeout, onComplete);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    stats.onMessage();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>ActiveMQSession</code>的send方法（设置消息头、属性，并判断是同步发送还是异步发送）：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">protected void send(ActiveMQMessageProducer producer, ActiveMQDestination destination, Message message,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">int</span> deliveryMode, <span class="built_in">int</span> priority, long timeToLive, MemoryUsage producerWindow, <span class="built_in">int</span> sendTimeout,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        AsyncCallback onComplete) throws JMSException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    check<span class="constructor">Closed()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (destination.is<span class="constructor">Temporary()</span><span class="operator"> &amp;&amp; </span>connection.is<span class="constructor">Deleted(<span class="params">destination</span>)</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw <span class="keyword">new</span> <span class="constructor">InvalidDestinationException(<span class="string">"Cannot publish to a deleted Destination: "</span> + <span class="params">destination</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    synchronized (sendMutex) &#123; <span class="comment">// 互斥锁，如果一个session的多个producer发送消息到这里，会保证消息发送的有序性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// tell the Broker we are about to start a new transaction</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">do</span><span class="constructor">StartTransaction()</span>;<span class="comment">// 告诉broker开始一个新事务，只有事务型会话中才会开启</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        TransactionId txid = transactionContext.get<span class="constructor">TransactionId()</span>;<span class="comment">// 从事务上下文中获取事务id</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        long sequenceNumber = producer.get<span class="constructor">MessageSequence()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Set the "JMS" header fields on the original message, see 1.1 spec</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// section 3.4.11</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        message.set<span class="constructor">JMSDeliveryMode(<span class="params">deliveryMode</span>)</span>; <span class="comment">// 在JMS协议头中设置是否持久化标识</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        long expiration = <span class="number">0L</span>;<span class="comment">// 计算消息过期时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!producer.get<span class="constructor">DisableMessageTimestamp()</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            long timeStamp = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>current<span class="constructor">TimeMillis()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            message.set<span class="constructor">JMSTimestamp(<span class="params">timeStamp</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (timeToLive &gt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                expiration = timeToLive + timeStamp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        message.set<span class="constructor">JMSExpiration(<span class="params">expiration</span>)</span>;<span class="comment">// 设置消息过期时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        message.set<span class="constructor">JMSPriority(<span class="params">priority</span>)</span>;<span class="comment">// 设置消息的优先级</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        message.set<span class="constructor">JMSRedelivered(<span class="params">false</span>)</span>;<span class="comment">// 设置消息为非重发</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// transform to our own message format here</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 将不通的消息格式统一转化为ActiveMQMessage</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ActiveMQMessage msg = <span class="module-access"><span class="module"><span class="identifier">ActiveMQMessageTransformation</span>.</span></span>transform<span class="constructor">Message(<span class="params">message</span>, <span class="params">connection</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        msg.set<span class="constructor">Destination(<span class="params">destination</span>)</span>;<span class="comment">// 设置目的地</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 生成并设置消息id</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        msg.set<span class="constructor">MessageId(<span class="params">new</span> MessageId(<span class="params">producer</span>.<span class="params">getProducerInfo</span>()</span>.get<span class="constructor">ProducerId()</span>, sequenceNumber));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Set the message id.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (msg != message) &#123;<span class="comment">// 如果消息是经过转化的，则更新原来的消息id和目的地</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            message.set<span class="constructor">JMSMessageID(<span class="params">msg</span>.<span class="params">getMessageId</span>()</span>.<span class="keyword">to</span><span class="constructor">String()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// Make sure the JMS destination is set on the foreign messages</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// too.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            message.set<span class="constructor">JMSDestination(<span class="params">destination</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// clear the brokerPath in case we are re-sending this message</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        msg.set<span class="constructor">BrokerPath(<span class="params">null</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        msg.set<span class="constructor">TransactionId(<span class="params">txid</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (connection.is<span class="constructor">CopyMessageOnSend()</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            msg = (ActiveMQMessage) msg.copy<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        msg.set<span class="constructor">Connection(<span class="params">connection</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        msg.on<span class="constructor">Send()</span>;<span class="comment">// 把消息属性和消息体都设置为只读，防止被修改</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        msg.set<span class="constructor">ProducerId(<span class="params">msg</span>.<span class="params">getMessageId</span>()</span>.get<span class="constructor">ProducerId()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">LOG</span>.</span></span>is<span class="constructor">TraceEnabled()</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="module-access"><span class="module"><span class="identifier">LOG</span>.</span></span>trace(get<span class="constructor">SessionId()</span> + <span class="string">" sending message: "</span> + msg);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 如果onComplete没有设置，且发送超时时间小于0，且消息不需要反馈，且连接器不是同步发送模式，且消息非持久化或者连接器是异步发送模式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 或者存在事务id的情况下，走异步发送，否则走同步发送</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (onComplete<span class="operator"> == </span>null<span class="operator"> &amp;&amp; </span>sendTimeout &lt;= <span class="number">0</span><span class="operator"> &amp;&amp; </span>!msg.is<span class="constructor">ResponseRequired()</span><span class="operator"> &amp;&amp; </span>!connection.is<span class="constructor">AlwaysSyncSend()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="operator">                &amp;&amp; </span>(!msg.is<span class="constructor">Persistent()</span><span class="operator"> || </span>connection.is<span class="constructor">UseAsyncSend()</span><span class="operator"> || </span>txid != null)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            this.connection.async<span class="constructor">SendPacket(<span class="params">msg</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (producerWindow != null) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// Since we defer lots of the marshaling till we hit the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// wire, this might not</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// provide and accurate size. We may change over to doing</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// more aggressive marshaling,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// to get more accurate sizes.. this is more important once</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// users start using producer window</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// flow control.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">int</span> size = msg.get<span class="constructor">Size()</span>; <span class="comment">// 异步发送的情况下，需要设置producerWindow的大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                producerWindow.increase<span class="constructor">Usage(<span class="params">size</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (sendTimeout &gt; <span class="number">0</span><span class="operator"> &amp;&amp; </span>onComplete<span class="operator"> == </span>null) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                this.connection.sync<span class="constructor">SendPacket(<span class="params">msg</span>, <span class="params">sendTimeout</span>)</span>; <span class="comment">// 带超时时间的同步发送</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                this.connection.sync<span class="constructor">SendPacket(<span class="params">msg</span>, <span class="params">onComplete</span>)</span>; <span class="comment">// 带回调的同步发送</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>当为异步发送时，走<code>ActiveMQConnection. doAsyncSendPacket</code>：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">doAsyncSendPacket</span><span class="params">(Command command)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.transport.oneway(command);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> JMSExceptionSupport.create(e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>transport</strong><br>这里调用了<code>transport</code>的方法，下面分析一下<code>transport</code>的实例化过程。在<code>ActiveMQConnectionFactory. createActiveMQConnection</code>这个方法中：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">protected ActiveMQConnection create<span class="constructor">ActiveMQConnection(String <span class="params">userName</span>, String <span class="params">password</span>)</span> throws JMSException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (brokerURL<span class="operator"> == </span>null) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw <span class="keyword">new</span> <span class="constructor">ConfigurationException(<span class="string">"brokerURL not set."</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ActiveMQConnection connection = null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Transport transport = create<span class="constructor">Transport()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        connection = create<span class="constructor">ActiveMQConnection(<span class="params">transport</span>, <span class="params">factoryStats</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        connection.set<span class="constructor">UserName(<span class="params">userName</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        connection.set<span class="constructor">Password(<span class="params">password</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 省略后面的代码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; catch (Exception e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.print<span class="constructor">StackTrace()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>createTransport</code>，调用<code>ActiveMQConnectionFactory.createTransport</code>方法，去创建一个<code>transport</code>对象。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">protected Transport create<span class="constructor">Transport()</span> throws JMSException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        URI connectBrokerUL = brokerURL;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String scheme = brokerURL.get<span class="constructor">Scheme()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (scheme<span class="operator"> == </span>null) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throw <span class="keyword">new</span> <span class="constructor">IOException(<span class="string">"Transport not scheme specified: ["</span> + <span class="params">brokerURL</span> + <span class="string">"]"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (scheme.equals(<span class="string">"auto"</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            connectBrokerUL = <span class="keyword">new</span> <span class="constructor">URI(<span class="params">brokerURL</span>.<span class="params">toString</span>()</span>.replace(<span class="string">"auto"</span>, <span class="string">"tcp"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scheme.equals(<span class="string">"auto+ssl"</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            connectBrokerUL = <span class="keyword">new</span> <span class="constructor">URI(<span class="params">brokerURL</span>.<span class="params">toString</span>()</span>.replace(<span class="string">"auto+ssl"</span>, <span class="string">"ssl"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scheme.equals(<span class="string">"auto+nio"</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            connectBrokerUL = <span class="keyword">new</span> <span class="constructor">URI(<span class="params">brokerURL</span>.<span class="params">toString</span>()</span>.replace(<span class="string">"auto+nio"</span>, <span class="string">"nio"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scheme.equals(<span class="string">"auto+nio+ssl"</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            connectBrokerUL = <span class="keyword">new</span> <span class="constructor">URI(<span class="params">brokerURL</span>.<span class="params">toString</span>()</span>.replace(<span class="string">"auto+nio+ssl"</span>, <span class="string">"nio+ssl"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return <span class="module-access"><span class="module"><span class="identifier">TransportFactory</span>.</span></span>connect(connectBrokerUL);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; catch (Exception e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw <span class="module-access"><span class="module"><span class="identifier">JMSExceptionSupport</span>.</span></span>create(<span class="string">"Could not create Transport. Reason: "</span> + e, e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ol>
<li>构建一个URI（默认使用的是tcp的协议）</li>
<li>根据URI去创建一个连接TransportFactory.connect</li>
</ol>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> static Transport <span class="keyword">connect</span>(URI <span class="keyword">location</span>) throws <span class="keyword">Exception</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    TransportFactory tf = findTransportFactory(<span class="keyword">location</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> tf.doConnect(<span class="keyword">location</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>TransportFactory. findTransportFactory</code>会从<code>TRANSPORT_FACTORYS</code>这个Map集合中，根据scheme去获得一个<code>TransportFactory</code>指定的实例对象，如果Map集合中不存在，则通过<code>TRANSPORT_FACTORY_FINDER</code>去找一个并且构建实例。<br>这个地方又有点类似于Java SPI的思想。他会从<code>META-INF/services/org/apache/activemq/transport/</code> 这个路径下，根据URI组装的scheme去找到匹配的class对象并且实例化，所以根据tcp为key去对应的路径下可以找到<code>TcpTransportFactory</code>。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static TransportFactory find<span class="constructor">TransportFactory(URI <span class="params">location</span>)</span> throws IOException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    String scheme = location.get<span class="constructor">Scheme()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (scheme<span class="operator"> == </span>null) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw <span class="keyword">new</span> <span class="constructor">IOException(<span class="string">"Transport not scheme specified: ["</span> + <span class="params">location</span> + <span class="string">"]"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    TransportFactory tf = <span class="module-access"><span class="module"><span class="identifier">TRANSPORT_FACTORYS</span>.</span></span>get(scheme);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (tf<span class="operator"> == </span>null) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Try to load if from a META-INF property.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            tf = (TransportFactory) <span class="module-access"><span class="module"><span class="identifier">TRANSPORT_FACTORY_FINDER</span>.</span></span><span class="keyword">new</span><span class="constructor">Instance(<span class="params">scheme</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="module-access"><span class="module"><span class="identifier">TRANSPORT_FACTORYS</span>.</span></span>put(scheme, tf);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; catch (Throwable e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throw <span class="module-access"><span class="module"><span class="identifier">IOExceptionSupport</span>.</span></span>create(<span class="string">"Transport scheme NOT recognized: ["</span> + scheme + <span class="string">"]"</span>, e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return tf;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>调用<code>TransportFactory.doConnect</code>去构建一个连接：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public Transport <span class="keyword">do</span><span class="constructor">Connect(URI <span class="params">location</span>)</span> throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Map&lt;String, String&gt; options = <span class="keyword">new</span> HashMap&lt;String, String&gt;(<span class="module-access"><span class="module"><span class="identifier">URISupport</span>.</span></span>parse<span class="constructor">Parameters(<span class="params">location</span>)</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!options.contains<span class="constructor">Key(<span class="string">"wireFormat.host"</span>)</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            options.put(<span class="string">"wireFormat.host"</span>, location.get<span class="constructor">Host()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        WireFormat wf = create<span class="constructor">WireFormat(<span class="params">options</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Transport transport = create<span class="constructor">Transport(<span class="params">location</span>, <span class="params">wf</span>)</span>; <span class="comment">// 创建一个Transport，创建一个socket连接</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                             <span class="comment">// -&gt; 终于找到真相了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Transport rc = configure(transport, wf, options);<span class="comment">// 配置configure，这个里面是对Transport做链路包装</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// remove auto</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">IntrospectionSupport</span>.</span></span>extract<span class="constructor">Properties(<span class="params">options</span>, <span class="string">"auto."</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!options.is<span class="constructor">Empty()</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throw <span class="keyword">new</span> <span class="constructor">IllegalArgumentException(<span class="string">"Invalid connect parameters: "</span> + <span class="params">options</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return rc;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; catch (URISyntaxException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw <span class="module-access"><span class="module"><span class="identifier">IOExceptionSupport</span>.</span></span>create(e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>configure(transport, wf, options)</code>：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public Transport configure(Transport transport, WireFormat wf, Map options) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 组装一个复合的transport，这里会包装两层，一个是IactivityMonitor.另一个是WireFormatNegotiator</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    transport = composite<span class="constructor">Configure(<span class="params">transport</span>, <span class="params">wf</span>, <span class="params">options</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    transport = <span class="keyword">new</span> <span class="constructor">MutexTransport(<span class="params">transport</span>)</span>; <span class="comment">// 再做一层包装,MutexTransport</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    transport = <span class="keyword">new</span> <span class="constructor">ResponseCorrelator(<span class="params">transport</span>)</span>; <span class="comment">// 包装ResponseCorrelator</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    return transport;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>到目前为止，这个<code>transport</code>实际上就是一个调用链了，它的链结构为：<code>ResponseCorrelator(MutexTransport(WireFormatNegotiator(IactivityMonitor(TcpTransport()))</code>每一层包装的作用：<br><code>ResponseCorrelator</code> 用于实现异步请求。<br><code>MutexTransport</code> 实现写锁，表示同一时间只允许发送一个请求。<br><code>WireFormatNegotiator</code> 实现了客户端连接broker的时候先发送数据解析相关的协议信息，比如解析版本号，是否使用缓存等。<br><code>InactivityMonitor</code> 用于实现连接成功成功后的心跳检查机制，客户端每10s发送一次心跳信息。服务端每30s读取一次心跳信息。<br><strong>同步发送和异步发送的区别</strong><br>在<code>ResponseCorrelator</code>的request方法中，通过response.getResult去获得broker的结果，如果没有获取到则阻塞。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">Object <span class="title">request</span><span class="params">(Object command, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    FutureResponse response = asyncRequest(command, <span class="keyword">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">return</span> response.<span class="title">getResult</span><span class="params">(timeout)</span></span>; <span class="comment">// 从future方法阻塞等待返回</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="持久化消息和非持久化消息的存储原理"><a href="#持久化消息和非持久化消息的存储原理" class="headerlink" title="持久化消息和非持久化消息的存储原理"></a>持久化消息和非持久化消息的存储原理</h3><p>正常情况下，非持久化消息是存储在内存中的，持久化消息是存储在文件中的。能够存储的最大消息数据在<br><code>${ActiveMQ_HOME}/conf/activemq.xml</code>文件中的systemUsage节点配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">systemUsage</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">systemUsage</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">memoryUsage</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--该子标记设置整个ActiveMQ节点的“可用内存限制”。这个值不能超过ActiveMQ本身设置的最大内存大小。其中的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">percentOfJvmHeap属性表示百分比。占用70%的堆内存--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">memoryUsage</span> <span class="attr">percentOfJvmHeap</span>=<span class="string">"70"</span> /&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">memoryUsage</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">storeUsage</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--该标记设置整个ActiveMQ节点，用于存储“持久化消息”的“可用磁盘空间”。该子标记的limit属性必须要进行设置--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">storeUsage</span> <span class="attr">limit</span>=<span class="string">"100 gb"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">storeUsage</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tempUsage</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--一旦ActiveMQ服务节点存储的消息达到了memoryUsage的限制，非持久化消息就会被转储到 temp store区域，虽然非持久化消息不进行持久化存储，但是ActiveMQ为了防止“数据洪峰”出现时非持久化消息大量堆积致使内存耗尽的情况出现，还是会将非持久化消息写入到磁盘的临时区域——temp store。这个子标记就是为了设置这个tempstore区域的“可用磁盘空间限制”。--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tempUsage</span> <span class="attr">limit</span>=<span class="string">"50 gb"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">tempUsage</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">systemUsage</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">systemUsage</span>&gt;</span></span></pre></td></tr></table></figure>

<p>从上面的配置可以知道，当非持久化消息堆积到一定程度的时候，也就是内存超过指定的设置阀值时，ActiveMQ会将内存中的非持久化消息写入到临时文件，以便腾出内存。但是它和持久化消息的区别是，重启之后，持久化消息会从文件中恢复，非持久化的临时文件会直接删除。</p>
<h4 id="消息的持久化策略分析"><a href="#消息的持久化策略分析" class="headerlink" title="消息的持久化策略分析"></a>消息的持久化策略分析</h4><p>消息持久性对于可靠消息传递来说是一种比较好的方法，即时发送者和接受者不是同时在线或者消息中心在发送者发送消息后宕机了，在消息中心重启后仍然可以将消息发送出去。消息持久性的原理很简单，就是在发送消息出去后，消息中心首先将消息存储在本地文件、内存或者远程数据库，然后把消息发送给接受者，发送成功后再把消息从存储中删除，失败则继续尝试。<br>ActiveMQ支持多种不同的持久化方式，主要有以下几种：</p>
<ul>
<li>KahaDB存储（默认存储方式）</li>
<li>JDBC存储</li>
<li>Memory存储</li>
<li>LevelDB存储</li>
<li>JDBC With ActiveMQ Journal</li>
</ul>
<p><strong>KahaDB存储</strong><br>KahaDB是目前默认的存储方式,可用于任何场景,提高了性能和恢复能力。消息存储使用一个事务日志和仅仅用一个索引文件来存储它所有的地址。KahaDB是一个专门针对消息持久化的解决方案,它对典型的消息使用模式进行了优化。在Kaha中,数据被追加到data logs中。当不再需要log文件中的数据的时候，log文件会被丢弃。<br>KahaDB的存储原理：<br>在data/kahadb这个目录下，会生成四个文件：<br>Ø db.data 它是消息的索引文件，本质上是B-Tree（B树），使用B-Tree作为索引指向db-<em>.log里面存储的消息<br>Ø db.redo 用来进行消息恢复<br>Ø db-</em>.log 存储消息内容。新的数据以APPEND的方式追加到日志文件末尾。属于顺序写入，因此消息存储是比较快的。默认是32M，达到阀值会自动递增<br>Ø lock文件 锁，表示当前获得kahadb读写权限的broker<br><strong>JDBC存储</strong><br>使用JDBC持久化方式，数据库会创建3个表：activemq_msgs，activemq_acks和activemq_lock。<br>ACTIVEMQ_MSGS 消息表，queue和topic都存在这个表中<br>ACTIVEMQ_ACKS 存储持久订阅的信息和最后一个持久订阅接收的消息ID<br>ACTIVEMQ_LOCKS 锁表，用来确保某一时刻，只能有一个ActiveMQ broker实例来访问数据库<br><strong>LevelDB存储</strong><br>LevelDB持久化性能高于KahaDB，虽然目前默认的持久化方式仍然是KahaDB。并且，在ActiveMQ 5.9版本提供了基于LevelDB和Zookeeper的数据复制方式，用于Master-slave方式的首选数据复制方案。不过，据ActiveMQ官网对LevelDB的表述：LevelDB官方建议使用以及不再支持，推荐使用的是KahaDB。<br><strong>Memory 消息存储</strong><br>基于内存的消息存储，内存消息存储主要是存储所有的持久化的消息在内存中。<code>persistent=”false”</code>,表示不设置持久化存储，直接存储到内存中。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">broker</span> <span class="attr">brokerName</span>=<span class="string">"test-broker"</span> <span class="attr">persistent</span>=<span class="string">"false"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">"http://activemq.apache.org/schema/core"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transportConnectors</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">uri</span>=<span class="string">"tcp://localhost:61635"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">transportConnectors</span>&gt;</span> <span class="tag">&lt;/<span class="name">broker</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<p><strong>JDBC Message store with ActiveMQ Journal</strong><br>这种方式克服了JDBC Store的不足，JDBC每次消息过来，都需要去写库和读库。ActiveMQ Journal，使用高速缓存写入技术，大大提高了性能。<br>当消费者的消费速度能够及时跟上生产者消息的生产速度时，journal文件能够大大减少需要写入到DB中的消息。举个例子，生产者生产了1000条消息，这1000条消息会保存到journal文件，如果消费者的消费速度很快的情况下，在journal文件还没有同步到DB之前，消费者已经消费了90%的以上的消息，那么这个时候只需要同步剩余的10%的消息到DB。<br>如果消费者的消费速度很慢，这个时候journal文件可以使消息以批量方式写到DB。</p>
<blockquote>
<p>作者：匠丶</p>
<p>来源：<a href="https://www.jianshu.com/p/3a29b032827a" target="_blank" rel="noopener">https://www.jianshu.com/p/3a29b032827a</a></p>
</blockquote>
]]></content>
      <categories>
        <category>其它技术</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>ActiveMQ消费消息原理解析</title>
    <url>/2019/12/26/ActiveMQ%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>ActiveMQ消费消息有两种方式。一种是使用同步阻塞的MessageConsumer.receive()方法；另一种是使用消息监听器MessageListener。这里需要注意的是，在同一个session下，只能选择其中一种方式。</p>
<a id="more"></a>

<h3 id="消费消息流程图"><a href="#消费消息流程图" class="headerlink" title="消费消息流程图"></a>消费消息流程图</h3><p><img src="http://image.winrains.cn/2019/08/20190826144852-2d1b0.png" alt="img"></p>
<h3 id="消费消息源码分析"><a href="#消费消息源码分析" class="headerlink" title="消费消息源码分析"></a>消费消息源码分析</h3><p><code>ActiveMQMessageConsumer.receive</code>，消费端同步接收消息的源码入口：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public Message receive<span class="literal">()</span> throws JMSException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    check<span class="constructor">Closed()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    check<span class="constructor">MessageListener()</span>; <span class="comment">// 检查receive和MessageListener是否同时配置在当前的会话中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    send<span class="constructor">PullCommand(0)</span>; <span class="comment">// 如果PrefetchSizeSize为0并且unconsumerMessage为空，则发起pull命令</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MessageDispatch md = dequeue<span class="number">(-1)</span>; <span class="comment">// 从unconsumerMessage出队列获取消息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (md<span class="operator"> == </span>null) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    before<span class="constructor">MessageIsConsumed(<span class="params">md</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    after<span class="constructor">MessageIsConsumed(<span class="params">md</span>, <span class="params">false</span>)</span>; <span class="comment">// 发送ack给到broker</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    return create<span class="constructor">ActiveMQMessage(<span class="params">md</span>)</span>;<span class="comment">// 获取消息并返回</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public Message receive<span class="literal">()</span> throws JMSException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    check<span class="constructor">Closed()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    check<span class="constructor">MessageListener()</span>; <span class="comment">// 检查receive和MessageListener是否同时配置在当前的会话中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    send<span class="constructor">PullCommand(0)</span>; <span class="comment">// 如果PrefetchSizeSize为0并且unconsumerMessage为空，则发起pull命令</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    MessageDispatch md = dequeue<span class="number">(-1)</span>; <span class="comment">// 从unconsumerMessage出队列获取消息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (md<span class="operator"> == </span>null) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    before<span class="constructor">MessageIsConsumed(<span class="params">md</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    after<span class="constructor">MessageIsConsumed(<span class="params">md</span>, <span class="params">false</span>)</span>; <span class="comment">// 发送ack给到broker</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    return create<span class="constructor">ActiveMQMessage(<span class="params">md</span>)</span>;<span class="comment">// 获取消息并返回</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>sendPullCommand()</code>，发送pull命令从broker上获取消息，前提是<code>prefetchSize=0</code>并且<code>unconsumedMessages</code>为空。<code>unconsumedMessage</code>表示未消费的消息，这里面预读取的消息大小为<code>prefetchSize</code>的值。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">protected void send<span class="constructor">PullCommand(<span class="params">long</span> <span class="params">timeout</span>)</span> throws JMSException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    clear<span class="constructor">DeliveredList()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (info.get<span class="constructor">CurrentPrefetchSize()</span><span class="operator"> == </span><span class="number">0</span><span class="operator"> &amp;&amp; </span>unconsumedMessages.is<span class="constructor">Empty()</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        MessagePull messagePull = <span class="keyword">new</span> <span class="constructor">MessagePull()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        messagePull.configure(info);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        messagePull.set<span class="constructor">Timeout(<span class="params">timeout</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        session.async<span class="constructor">SendPacket(<span class="params">messagePull</span>)</span>; <span class="comment">// 向服务端异步发送messagePull指令</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>clearDeliveredList()</code>，主要用来清理已经分发的消息链表<code>deliveredMessages</code>。<code>deliveredMessages</code>，存储分发给消费者但还为应答的消息链表。如果session是事务的，则会遍历<code>deliveredMessage</code>中的消息放入到<code>previouslyDeliveredMessage</code>中来做重发；如果session是非事务的，根据ACK的模式来选择不同的应答操作。<br><code>dequeue()</code>，从<code>unconsumedMessage</code>中取出一个消息，在创建一个消费者时，会对这个消费者创建一个未消费的消息通道，这个通道分为两种，一种是简单优先级队列分发通道<code>SimplePriorityMessageDispatchChannel</code> ；另一种是先进先出的分发通道<code>FifoMessageDispatchChannel</code>。<br>通过这样的设计可以允许session能够一次性将多条消息分发给一个消费者，而不用消费者每次消费完一个消息以后再去broker拿消息，提高效率。默认情况下对于queue来说，prefetchSize的值是1000。<br><code>beforeMessageIsConsumed()</code>，这里面主要是做消息消费之前的一些准备工作，如果ACK类型不是<code>DUPS_OK_ACKNOWLEDGE</code>或者队列模式（简单来说就是除了Topic和DupAck这两种情况），所有的消息先放到<code>deliveredMessages</code>链表的开头。并且如果当前是事务类型的会话，则判断<code>transactedIndividualAck</code>，如果为true，表示单条消息直接返回ack。否则，调用ackLater，批量应答, client端在消费消息后暂且不发送ACK，而是把它缓存下来(pendingACK)，等到这些消息的条数达到一定阀值时，只需要通过一个ACK指令把它们全部确认，这比对每条消息都逐个确认，在性能上要提高很多。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void before<span class="constructor">MessageIsConsumed(MessageDispatch <span class="params">md</span>)</span> throws JMSException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        md.set<span class="constructor">DeliverySequenceId(<span class="params">session</span>.<span class="params">getNextDeliveryId</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        lastDeliveredSequenceId = md.get<span class="constructor">Message()</span>.get<span class="constructor">MessageId()</span>.get<span class="constructor">BrokerSequenceId()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!is<span class="constructor">AutoAcknowledgeBatch()</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            synchronized (deliveredMessages) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                deliveredMessages.add<span class="constructor">First(<span class="params">md</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (session.get<span class="constructor">Transacted()</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (transactedIndividualAck) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    immediate<span class="constructor">IndividualTransactedAck(<span class="params">md</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    ack<span class="constructor">Later(<span class="params">md</span>, MessageAck.DELIVERED_ACK_TYPE)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>

<p><code>afterMessageIsConsumed()</code>，这个方法的主要作用是执行应答操作，这里面做以下几个操作：<br>Ø 如果消息过期，则返回消息过期的ack<br>Ø 如果是事务类型的会话，则不做任何处理<br>Ø 如果是AUTOACK或者（DUPS_OK_ACK且是队列），并且是优化ack操作，则走批量确认ack<br>Ø 如果是DUPS_OK_ACK，则走ackLater逻辑<br>Ø 如果是CLIENT_ACK，则执行ackLater逻辑</p>
<h3 id="消息的确认过程"><a href="#消息的确认过程" class="headerlink" title="消息的确认过程"></a>消息的确认过程</h3><p>消息确认有四种 <strong>ACK_MODE</strong>，分别是：<br>AUTO_ACKNOWLEDGE = 1 自动确认<br>CLIENT_ACKNOWLEDGE = 2 客户端手动确认<br>DUPS_OK_ACKNOWLEDGE = 3 自动批量确认<br>SESSION_TRANSACTED = 0 事务提交并确认<br>虽然 Client 端指定了 ACK 模式，但是在 Client 与 broker 在交换 ACK 指令的时候，还需要告知ACK_TYPE。ACK_TYPE 表示此确认指令的类型，不同的ACK_TYPE 将传递着消息的状态，broker 可以根据不同的 ACK_TYPE 对消息进行不同的操作。<br><strong>ACK_TYPE：</strong><br>DELIVERED_ACK_TYPE = 0 消息”已接收”，但尚未处理结束；<br>STANDARD_ACK_TYPE = 2 “标准”类型,通常表示为消息”处理成功”，broker 端可以删除消息；<br>POSION_ACK_TYPE = 1 消息”错误”,通常表示”抛弃”此消息，比如消息重发多次后，都无法正确处理时，消息将会被删除或者 DLQ(死信队列)；<br>REDELIVERED_ACK_TYPE = 3 消息需”重发”，比如 consumer 处理消息时抛出了异常，broker 稍后会重新发送此消息；<br>INDIVIDUAL_ACK_TYPE = 4 表示只确认”单条消息”,无论在任何 ACK_MODE ；<br>UNMATCHED_ACK_TYPE = 5 在 Topic 中，如果一条消息在转发给“订阅者”时，发现此消息不符合 Selector 过滤条件，那么此消息将 不会转发给订阅者，消息将会被存储引擎删除(相当于在 Broker 上确认了消息)。</p>
<h3 id="消息的重发机制原理"><a href="#消息的重发机制原理" class="headerlink" title="消息的重发机制原理"></a>消息的重发机制原理</h3><p>在正常情况下，有几中情况会导致消息重新发送：<br>Ø 在事务性会话中，没有调用 session.commit 确认消息或者调用session.rollback 方法回滚消息；<br>Ø 在非事务性会话中，ACK 模式为 CLIENT_ACKNOWLEDGE 的情况下，没有调用 acknowledge 或者调用了 recover 方法。<br>一个消息被重发超过默认的最大重发次数（默认 6 次）时，消费端会给 broker 发送一个”poison ack，告诉 broker 不要再发了。这个时候 broker 会把这个消息放到 DLQ（死信队列）。</p>
<h3 id="ActiveMQ-的优缺点"><a href="#ActiveMQ-的优缺点" class="headerlink" title="ActiveMQ 的优缺点"></a>ActiveMQ 的优缺点</h3><p>ActiveMQ 采用消息推送方式，所以最适合的场景是默认消息都可在短时间内被消费。数据量越大，查找和消费消息就越慢，消息积压程度与消息速度成反比。<br><strong>缺点：</strong><br>1.吞吐量低。由于 ActiveMQ 需要建立索引，导致吞吐量下降。<br>2.无分片功能。这是一个功能缺失，JMS 并没有规定消息中间件的集群、分片机制。而由于 ActiveMQ 是为企业级开发设计的消息中间件，初衷并不是为了处理海量消息和高并发请求。如果一台服务器不能承受更多消息，则需要横向拆分。ActiveMQ 官方不提供分片机制，需要自己实现。<br><strong>适用场景：</strong><br>对 TPS 要求比较低的系统，可以使用 ActiveMQ 来实现，一方面比较简单，能够快速上手开发，另一方面可控性也比较好，还有比较好的监控机制和界面。<br><strong>不适用的场景：</strong><br>消息量巨大的场景。ActiveMQ 不支持消息自动分片机制，如果消息量巨大，导致一台服务器不能处理全部消息，就需要自己开发消息分片功能。</p>
<blockquote>
<p>作者：匠丶</p>
<p>来源：<a href="https://www.jianshu.com/p/8cf82006504e" target="_blank" rel="noopener">https://www.jianshu.com/p/8cf82006504e</a></p>
</blockquote>
]]></content>
      <categories>
        <category>其它技术</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池Executor框架详解</title>
    <url>/2019/12/26/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0Executor%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>Java的线程既是工作单元，也是执行机制。从JDK 5开始，把工作单元与执行机制分离开来。工作单元包括Runnable和Callable，而执行机制由Executor框架提供。</p>
<a id="more"></a>

<h3 id="Executor框架简介"><a href="#Executor框架简介" class="headerlink" title="Executor框架简介"></a>Executor框架简介</h3><p>在HotSpot VM的线程模型中，Java线程（java.lang.Thread）被一对一映射为本地操作系统线程。Java线程启动时会创建一个本地操作系统线程；当该Java线程终止时，这个操作系统线程也会被回收。操作系统会调度所有线程并将它们分配给可用的CPU。<br>在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。<br><img src="http://image.winrains.cn/2019/08/20190826145240-3e58d.png" alt="img"><br>任务：包括被执行任务需要实现的接口：<code>Runnable</code>接口或<code>Callable</code>接口。<br>任务的执行：包括任务执行机制的核心接口<code>Executor</code>，以及继承自<code>Executor</code>的<code>ExecutorService</code>接口。<code>Executor</code>框架有两个关键类实现了<code>ExecutorService</code>接口（<code>ThreadPoolExecutor</code>和<code>ScheduledThreadPoolExecutor</code>）。<br>异步计算的结果：包括接口<code>Future</code>和实现<code>Future</code>接口的<code>FutureTask</code>类。<br><img src="http://image.winrains.cn/2019/08/20190826145241-8cf03.png" alt="img"></p>
<p><img src="http://image.winrains.cn/2019/08/20190826145242-1febe.png" alt="img"></p>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p><strong>1、<code>FixedThreadPool</code></strong>：称为可重用固定线程数的线程池。下面是<code>FixedThreadPool</code>的源代码实<br>现。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>FixedThreadPool</code>的<code>corePoolSize</code>和<code>maximumPoolSize</code>都被设置为创建<code>FixedThreadPool</code>时指定的参数<code>nThreads</code>。<br>当线程池中的线程数大于<code>corePoolSize</code>时，<code>keepAliveTime</code>为多余的空闲线程等待新任务的最长时间，超过这个时间后多余的线程将被终止。这里把<code>keepAliveTime</code>设置为0L，意味着多余的空闲线程会被立即终止。<br><code>FixedThreadPool</code>使用无界队列<code>LinkedBlockingQueue</code>作为线程池的工作队列（队列的容量为<code>Integer.MAX_VALUE</code>）。使用无界队列作为工作队列会对线程池带来如下影响。<br>1）当线程池中的线程数达到<code>corePoolSize</code>后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize。<br>2）由于1，使用无界队列时<code>maximumPoolSize</code>将是一个无效参数。<br>3）由于1和2，使用无界队列时<code>keepAliveTime</code>将是一个无效参数。<br>4）由于使用无界队列，运行中的<code>FixedThreadPool</code>（未执行方法<code>shutdown()</code>或<code>shutdownNow()</code>）不会拒绝任务（不会调用<code>RejectedExecutionHandler.rejectedExecution</code>方法）。<br><strong>2、SingleThreadExecutor</strong>：使用单个<code>worker</code>线程的<code>Executor</code>。下面是<code>SingleThreadExecutor</code>的源代码实现。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FinalizableDelegatedExecutorService</span>(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>3、CachedThreadPool</strong>：是一个会根据需要创建新线程的线程池。下面是创建<code>CachedThreadPool</code>的源代码。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>L,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            TimeUnit.SECONDS, <span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>CachedThreadPool</code>的<code>corePoolSize</code>被设置为0，即<code>corePool</code>为空；<code>maximumPoolSize</code>被设置为<code>Integer.MAX_VALUE</code>，即<code>maximumPool</code>是无界的。这里把<code>keepAliveTime</code>设置为60L，意味着<code>CachedThreadPool</code>中的空闲线程等待新任务的最长时间为60秒，空闲线程超过60秒后将会被终止。<br><code>CachedThreadPool</code>使用没有容量的<code>SynchronousQueue</code>作为线程池的工作队列，但<code>CachedThreadPool</code>的<code>maximumPool</code>是无界的。这意味着，如果主线程提交任务的速度高于<code>maximumPool</code>中线程处理任务的速度时，<code>CachedThreadPool</code>会不断创建新线程。极端情况下，<code>CachedThreadPool</code>会因为创建过多线程而耗尽CPU和内存资源。</p>
<h3 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h3><p><code>ScheduledThreadPoolExecutor</code>继承自<code>ThreadPoolExecutor</code>。它主要用来在给定的延迟之后运行任务，或者定期执行任务。<br><img src="http://image.winrains.cn/2019/08/20190826145243-86a31.png" alt="img"><br><code>ScheduledThreadPoolExecutor</code>会把待调度的任务（<code>ScheduledFutureTask</code>）放到一个<code>DelayQueue</code>中。<br><code>ScheduledFutureTask</code>主要包含3个成员变量，如下：<br>long型成员变量time，表示这个任务将要被执行的具体时间。<br>long型成员变量<code>sequenceNumber</code>，表示这个任务被添加到<code>ScheduledThreadPoolExecutor</code>中<br>的序号。<br>long型成员变量period，表示任务执行的间隔周期。<br>DelayQueue封装了一个<code>PriorityQueue</code>，这个<code>PriorityQueue</code>会对队列中的<code>ScheduledFutureTask</code>进行排序。排序时，time小的排在前面（时间早的任务将被先执行）。如果两个<code>ScheduledFutureTask</code>的time相同，就比较<code>sequenceNumber</code>，<code>sequenceNumber</code>小的排在前面（也就是说，如果两个任务的执行时间相同，那么先提交的任务将被先执行）。</p>
<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p><code>Future</code>接口和实现<code>Future</code>接口的<code>FutureTask</code>类，代表异步计算的结果。<code>FutureTask</code>可以处于下面3种状态：<br>1）未启动。<code>FutureTask.run()</code>方法还没有被执行之前，<code>FutureTask</code>处于未启动状态。当创建一个<code>FutureTask</code>，且没有执行<code>FutureTask.run()</code>方法之前，这个<code>FutureTask</code>处于未启动状态。<br>2）已启动。<code>FutureTask.run()</code>方法被执行的过程中，<code>FutureTask</code>处于已启动状态。<br>3）已完成。<code>FutureTask.run()</code>方法执行完后正常结束，或被取消（<code>FutureTask.cancel（…）</code>），或执行<code>FutureTask.run()</code>方法时抛出异常而异常结束，<code>FutureTask</code>处于已完成状态。<br>当<code>FutureTask</code>处于未启动或已启动状态时，执行<code>FutureTask.get()</code>方法将导致调用线程阻塞；<br>当<code>FutureTask</code>处于已完成状态时，执行<code>FutureTask.get()</code>方法将导致调用线程立即返回结果或抛出异常。<br>当<code>FutureTask</code>处于未启动状态时，执行<code>FutureTask.cancel()</code>方法将导致此任务永远不会被执行；当<code>FutureTask</code>处于已启动状态时，执行<code>FutureTask.cancel（true）</code>方法将以中断执行此任务线程的方式来试图停止任务；当<code>FutureTask</code>处于已启动状态时，执行<code>FutureTask.cancel（false）</code>方法将不会对正在执行此任务的线程产生影响（让正在执行的任务运行完成）；当<code>FutureTask</code>处于已完成状态时，执行<code>FutureTask.cancel（…）</code>方法将返回false。<br><img src="http://image.winrains.cn/2019/08/20190826145243-ad92b.png" alt="img"><br><code>FutureTask</code>的实现也是基于<code>AbstractQueuedSynchronizer</code>（AQS）。<br><img src="http://image.winrains.cn/2019/08/20190826145245-1e4ef.png" alt="img"><br><code>Sync</code>是<code>FutureTask</code>的内部私有类，它继承自AQS。创建<code>FutureTask</code>时会创建内部私有的成员对象<code>Sync</code>，<code>FutureTask</code>所有的的公有方法都直接委托给了内部私有的<code>Sync</code>。</p>
<blockquote>
<p>作者：匠丶</p>
<p>来源：<a href="https://www.jianshu.com/p/aa7167b4f281" target="_blank" rel="noopener">https://www.jianshu.com/p/aa7167b4f281</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池的使用和原理</title>
    <url>/2019/12/26/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来3个好处。</p>
<blockquote>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。</li>
</ul>
</blockquote>
<p>线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</p>
<a id="more"></a>

<h3 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h3><h4 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h4><p>可以通过<code>ThreadPoolExecutor</code>来创建一个线程池：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,<span class="comment">//核心线程数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">int</span> maximumPoolSize,<span class="comment">//最大线程数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">long</span> keepAliveTime,<span class="comment">//超时时间,超出核心线程数量以外的线程空余存活时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           TimeUnit unit,<span class="comment">//存活时间单位</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           BlockingQueue&lt;Runnable&gt; workQueue,<span class="comment">//保存执行任务的队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           ThreadFactory threadFactory,<span class="comment">//创建新线程使用的工厂</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           RejectedExecutionHandler <span class="keyword">handler</span>)<span class="comment">//当任务无法执行的时候的处理方式</span></span></pre></td></tr></table></figure>

<p>workQueue参数可以选择以下几个阻塞队列：<br><strong>ArrayBlockingQueue</strong>：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。<br><strong>LinkedBlockingQueue</strong>：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。<br><strong>SynchronousQueue</strong>：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，提交的任务不会被真实的保存，而总是将新任务提交给线程执行，如果没有空闲的线程，则尝试创建新的线程，如果线程的数量已经达到了最大值，则执行拒绝策略，静态工厂方法Executors.newCachedThreadPool使用了这个队列。<br><strong>PriorityBlockingQueue</strong>：一个具有优先级的无限阻塞队列。<br>handler参数可以以下几个拒绝策略：<br><strong>AbortPolicy</strong>：直接抛出异常。<br><strong>CallerRunsPolicy</strong>：使用调用者所在线程来运行任务。<br><strong>DiscardOldestPolicy</strong>：丢弃队列里最近的一个任务，并执行当前任务。<br><strong>DiscardPolicy</strong>：不处理，丢弃掉。<br>当然，也可以根据应用场景需要来实现<code>RejectedExecutionHandler</code>接口自定义策略。如记录日志或持久化存储不能处理的任务。</p>
<h4 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h4><p>可以使用两个方法向线程池提交任务，分别为<code>execute()</code>和<code>submit()</code>方法。<br><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。<code>execute()</code>方法输入的任务是一个<code>Runnable</code>类的实例。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">threadsPool.execute(<span class="keyword">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p><code>submit()</code>方法用于提交需要返回值的任务，参数可以是是<code>Runnable</code>或<code>Callable</code>。线程池会返回一个<code>future</code>类型的对象，通过这个<code>future</code>对象可以判断任务是否执行成功，并且可以通过<code>future</code>的<code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用<code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">Future&lt;Object&gt; <span class="built_in">future</span> = executor.submit(harReturnValuetask);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Object s = <span class="built_in">future</span>.<span class="built_in">get</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 处理中断异常</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 处理无法执行任务异常</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; finally &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 关闭线程池</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    executor.<span class="built_in">shutdown</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h4><p>可以通过调用线程池的<code>shutdown</code>或<code>shutdownNow</code>方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的<code>interrupt</code>方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，<code>shutdownNow</code>首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而<code>shutdown</code>只是将线程池的状态设置成<code>SHUTDOWN</code>状态，然后中断所有没有正在执行任务的线程。<br>只要调用了这两个关闭方法中的任意一个，<code>isShutdown</code>方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用<code>isTerminaed</code>方法会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用<code>shutdownNow</code>方法。</p>
<h4 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h4><p>如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以根据线程池的使用状况快速定位问题。可以通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性。<br>taskCount：线程池需要执行的任务数量。<br>completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。<br>largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。<br>getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。<br>getActiveCount：获取活动的线程数。<br>通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。<br>当向线程池提交一个任务之后，线程池的处理流程如下：<br><img src="http://image.winrains.cn/2019/08/20190826152122-d3297.png" alt="img"></p>
<p><img src="http://image.winrains.cn/2019/08/20190826152123-56b07.png" alt="img"></p>
<h3 id="线程池的原理"><a href="#线程池的原理" class="headerlink" title="线程池的原理"></a>线程池的原理</h3><p>线程池用一个<code>AtomicInteger</code>来保存 [线程数量] 和 [线程池状态] ,一个int数值一共有32位,高3位用于保存运行状态,低29位用于保存线程数量。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>)); <span class="comment">//一个原子操作类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>; <span class="comment">//32-3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY  = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>; <span class="comment">//将1的二进制向右位移29位,再减1表示最大线程容量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//运行状态保存在int值的高3位 (所有数值左移29位)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING   = <span class="number">-1</span> &lt;&lt; COUNT_BITS;<span class="comment">// 接收新任务,并执行队列中的任务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN  =  <span class="number">0</span> &lt;&lt; COUNT_BITS;<span class="comment">// 不接收新任务,但是执行队列中的任务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP    =  <span class="number">1</span> &lt;&lt; COUNT_BITS;<span class="comment">// 不接收新任务,不执行队列中的任务,中断正在执行中的任务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING   =  <span class="number">2</span> &lt;&lt; COUNT_BITS; <span class="comment">//所有的任务都已结束,线程数量为0,处于该状态的线程池即将调用terminated()方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;<span class="comment">// terminated()方法执行完成</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Packing and unpacking ctl</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>   </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125; <span class="comment">//获取运行状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125; <span class="comment">//获取线程数量</span></span></pre></td></tr></table></figure>

<p><code>execute()</code>方法源码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (command<span class="operator"> == </span>null)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw <span class="keyword">new</span> <span class="constructor">NullPointerException()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">int</span> c = ctl.get<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (worker<span class="constructor">CountOf(<span class="params">c</span>)</span> &lt; corePoolSize) &#123;<span class="comment">// 1.当前池中线程比核心数少，新建一个线程执行任务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (add<span class="constructor">Worker(<span class="params">command</span>, <span class="params">true</span>)</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        c = ctl.get<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (is<span class="constructor">Running(<span class="params">c</span>)</span><span class="operator"> &amp;&amp; </span>workQueue.offer(command)) &#123;<span class="comment">// 2.核心池已满，但任务队列未满，添加到队列中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">int</span> recheck = ctl.get<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 任务成功添加到队列以后，再次检查是否需要添加新的线程，因为已存在的线程可能被销毁了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!is<span class="constructor">Running(<span class="params">recheck</span>)</span><span class="operator"> &amp;&amp; </span>remove(command))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            reject(command);<span class="comment">// 如果线程池处于非运行状态，并且把当前的任务从任务队列中移除成功，则拒绝该任务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (worker<span class="constructor">CountOf(<span class="params">recheck</span>)</span><span class="operator"> == </span><span class="number">0</span>)<span class="comment">// 如果之前的线程已被销毁完，新建一个线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            add<span class="constructor">Worker(<span class="params">null</span>, <span class="params">false</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!add<span class="constructor">Worker(<span class="params">command</span>, <span class="params">false</span>)</span>) <span class="comment">// 3.核心池已满，队列已满，试着创建一个新线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        reject(command); <span class="comment">// 如果创建新线程失败了，说明线程池被关闭或者线程池完全满了，拒绝任务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>作者：匠丶</p>
<p>来源：<a href="https://www.jianshu.com/p/251d2e51e727" target="_blank" rel="noopener">https://www.jianshu.com/p/251d2e51e727</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized和volatile原理解析</title>
    <url>/2019/12/26/synchronized%E5%92%8Cvolatile%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><strong>synchronized</strong>和<strong>volatile</strong>是java提供的两个解决并发问题的关键字，本文将深入解析<strong>synchronized</strong>和<strong>volatile</strong>的实现原理，并可从中了解内存屏障、对象头、自旋锁、偏向锁等内容。</p>
<a id="more"></a>

<h3 id="volatile特性"><a href="#volatile特性" class="headerlink" title="volatile特性"></a>volatile特性</h3><p><strong>volatile</strong>是java虚拟机提供的最轻量级的同步机制。当一个变量定义为volatile之后，它将具备两种特性：<br>1、保证此变量对所有线程的可见性，即当一个线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。<br>2、禁止指令重排序</p>
<h4 id="volatile如何保证可见性"><a href="#volatile如何保证可见性" class="headerlink" title="volatile如何保证可见性"></a>volatile如何保证可见性</h4><p>以单例模式的demo为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDoubleSyn</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazyDoubleSyn lazyDoubleSyn = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyDoubleSyn</span><span class="params">()</span></span>&#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyDoubleSyn <span class="title">getLazyDoubleSyn</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(lazyDoubleSyn == <span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">synchronized</span> (LazyDoubleSyn<span class="class">.<span class="keyword">class</span>)</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(lazyDoubleSyn == <span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    lazyDoubleSyn  = <span class="keyword">new</span> LazyDoubleSyn();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> lazyDoubleSyn;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过生成汇编代码，可以清晰的看到加入volatile和未加入volatile的差别。volatile变量修饰的共享变量，在进行写操作的时候会多出一个lock前缀的汇编指令，这个指令会触发总线锁或者缓存锁，通过缓存一致性协议来解决可见性问题。（可从<a href="https://www.jianshu.com/p/7d3425a78d72" target="_blank" rel="noopener">Java内存模型简介</a>了解缓存一致性协议）</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x01a3de1d</span>:movb $<span class="number">0x0</span>,<span class="number">0x1104800</span>(%esi)  ; ...c6860048 <span class="number">100100</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0x01a3de24</span>:lock addl $<span class="number">0x0</span>,(%esp)  ; ...f0830424 <span class="number">00</span></span></pre></td></tr></table></figure>

<h4 id="volatile如何保证有序性"><a href="#volatile如何保证有序性" class="headerlink" title="volatile如何保证有序性"></a>volatile如何保证有序性</h4><p>在分析保证有序性前，有必要了解一下内存屏障。<strong>内存屏障</strong>（Memory Barriers，Intel称之Memory Fence）指令是指，重排序时不能把后面的指令重排序到内存屏障之前的位置。CPU把内存屏障分成三类：写屏障(store barrier)、读屏障(load barrier)和全屏障(Full Barrier)。<br><strong>写屏障store barrier</strong>相当于storestore barrier, 强制所有在storestore内存屏障之前的所有执行，都要在该内存屏障之前执行，并发送缓存失效的信号。所有在storestore barrier指令之后的store指令，都必须在storestore barrier屏障之前的指令执行完后再被执行。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826153602-36515.png" alt="img"></p>
<p><strong>读屏障load barrier</strong>相当于loadload barrier，强制所有在load barrier读屏障之后的load指令，都在loadbarrier屏障之后执行。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826153602-373f6.png" alt="img"></p>
<p><strong>全屏障full barrier</strong>相当于storeload，是一个全能型的屏障，因为它同时具备前面两种屏障的效果。强制了所有在storeload barrier之前的store/load指令，都在该屏障之前被执行，所有在该屏障之后的的store/load指令，都在该屏障之后被执行。<br><img src="http://image.winrains.cn/2019/08/20190826153603-9af95.png" alt="img"><br>在JMM中把内存屏障指令分为4类：<br>LoadLoad Barriers，load1 ; LoadLoad; load2 ，确保load1数据的装载优先于load2及所有后续装载指令的装载。<br>StoreStore Barriers，store1; storestore;store2 ，确保store1数据对其他处理器可见优先于store2及所有后续存储指令的存储。<br>LoadStore Barries， load1;loadstore;store2，确保load1数据装载优先于store2以及后续的存储指令刷新到内存。<br>StoreLoad Barries， store1; storeload;load2， 确保store1数据对其他处理器变得可见， 优先于load2及所有后续装载指令的装载；这条内存屏障指令是一个全能型的屏障同时具有其他3条屏障的效果。编译器在生成字节码时，会在<strong>volatile</strong>指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略。<br>在每个volatile写操作的前面插入一个StoreStore屏障。<br>在每个volatile写操作的后面插入一个StoreLoad屏障。<br>在每个volatile读操作的前面插入一个LoadLoad屏障。<br>在每个volatile读操作的后面插入一个LoadStore屏障。</p>
<h4 id="volatile为什么不能保证原子性"><a href="#volatile为什么不能保证原子性" class="headerlink" title="volatile为什么不能保证原子性"></a>volatile为什么不能保证原子性</h4><p>下面以volatile变量自增为例：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        race++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws InterruptedException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">20</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;<span class="number">20</span>;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        increase();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            threads[i].start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt;<span class="number">1</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Thread.<span class="built_in">yield</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.<span class="built_in">println</span>(race);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>反编译字节码文件可以看到，自增操作会分为三个步骤：1.读取volatile变量的值到local；2.增加变量的值；3.把local的值写回让其他线程可见。可以看到，volatile不能保证原子性。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Code:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">0:</span> <span class="string">iconst_0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">1:</span> <span class="string">istore_1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">2:</span> <span class="string">iload_1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">3:</span> <span class="string">sipush</span>        <span class="number">1000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">6:</span> <span class="string">if_icmpge</span>     <span class="number">18</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">9:</span> <span class="string">invokestatic</span>  <span class="comment">#2</span></span></pre></td></tr></table></figure>

<h3 id="synchronized特性"><a href="#synchronized特性" class="headerlink" title="synchronized特性"></a>synchronized特性</h3><p>在多线程并发编程中synchronized一直是元老级角色，很多人都会称呼它为重量级锁。通过反编译成字节码指令可以看到，synchronized会在同步块的前后分别形成<strong>monitorenter</strong>和<strong>monitorexit</strong>这两个字节码指令。根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计算器减1，当计数器为0时，锁就被释放。<br>Java的线程是映射到操作系统的原生线程上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从<strong>用户态</strong>转换到<strong>核心态</strong>，状态转换需要耗费很多处理器的时间。这也是为什么synchronized被称为重量级锁的原因。JDK1.6后加入了很多针对锁的优化措施，包含偏向锁、轻量级锁、重量级锁; 在了解synchronized锁之前，需要了解两个重要的概念，一个是对象头，另一个是monitor。</p>
<h4 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h4><p>在HotSpot虚拟机中，对象在内存中的布局分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。<br>HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，官方称它为<strong>Mark Word</strong>。考虑到虚拟机的空间效率，<strong>Mark Word</strong>被设计成一个非固定的数据结构，下图为32位MarkWord的数据结构，synchronized源码实现就用了Mark Word来标识对象加锁状态。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826153603-7d697.png" alt="img"></p>
<p>对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定对象是哪个类的实例。</p>
<h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h4><p>Java中每个对象都有一个监视器ObjectMonitor，监视器锁的数据结构为：<br>oopDesc–继承–&gt;markOopDesc–方法monitor()–&gt;ObjectMonitor–&gt;enter、exit 获取、释放锁<br>1、oopDesc，openjdk\hotspot\src\share\vm\oops\oop.hpp下oopDesc类是JVM对象的顶级基类,故每个object都包含markOop。如下图所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">oopDesc</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VMStructs</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">volatile</span> markOop _mark;<span class="comment">// markOop:Mark Word标记字段</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">union</span> _metadata &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         Klass*      _klass;<span class="comment">//对象类型元数据的指针</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">         narrowKlass _compressed_klass;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &#125;_metadata;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Fast access to barrier set. Must be initialized.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> BarrierSet* _bs;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">markOop  <span class="title">mark</span><span class="params">()</span> <span class="keyword">const</span>         </span>&#123; <span class="keyword">return</span> _mark; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">markOop* <span class="title">mark_addr</span><span class="params">()</span> <span class="keyword">const</span>    </span>&#123; <span class="keyword">return</span> (markOop*) &amp;_mark; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set_mark</span><span class="params">(<span class="keyword">volatile</span> markOop m)</span> </span>&#123; _mark = m; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">release_set_mark</span><span class="params">(markOop m)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">markOop <span class="title">cas_set_mark</span><span class="params">(markOop new_mark, markOop old_mark)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Used only to re-initialize the mark word (e.g., of promoted</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// objects during a GC) -- requires a valid klass pointer</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init_mark</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">Klass* <span class="title">klass</span><span class="params">()</span> <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">Klass* <span class="title">klass_or_null</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">volatile</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">Klass** <span class="title">klass_addr</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">narrowKlass* <span class="title">compressed_klass_addr</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>2、markOopDesc，openjdk\hotspot\src\share\vm\oops\markOop.hpp下markOopDesc继承自oopDesc，并拓展了自己的方法monitor(),如下图</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">ObjectMonitor* monitor() const &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span>(has_monitor(), "check");</span></pre></td></tr><tr><td class="code"><pre><span class="line">    // Use xor <span class="keyword">instead</span> <span class="keyword">of</span> &amp;~ <span class="keyword">to</span> provide one extra tag-<span class="type">bit</span> <span class="keyword">check</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (ObjectMonitor*) (<span class="keyword">value</span>() ^ monitor_value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>3、ObjectMonitor，在HotSpot虚拟机中，最终采用ObjectMonitor类实现monitor openjdk\hotspot\src\share\vm\runtime\objectMonitor.hpp源码如下：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     _header       = NULL;<span class="comment">//markOop对象头</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     _count        = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     _waiters      = <span class="number">0</span>,<span class="comment">//等待线程数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     _recursions   = <span class="number">0</span>;<span class="comment">//重入次数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     _object       = NULL;<span class="comment">//监视器锁寄生的对象。锁不是平白出现的，而是寄托存储于对象中。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     _owner        = NULL;<span class="comment">//指向获得ObjectMonitor对象的线程或基础锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     _WaitSet      = NULL;<span class="comment">//处于wait状态的线程，会被加入到wait set；</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     _WaitSetLock  = <span class="number">0</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     _Responsible  = NULL ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     _succ         = NULL ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     _cxq          = NULL ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     FreeNext      = NULL ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     _EntryList    = NULL ;<span class="comment">//处于等待锁block状态的线程，会被加入到entry set；</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     _SpinFreq     = <span class="number">0</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     _SpinClock    = <span class="number">0</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     OwnerIsThread = <span class="number">0</span> ;<span class="comment">// _owner is (Thread *) vs SP/BasicLock</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     _previous_owner_tid = <span class="number">0</span>;<span class="comment">// 监视器前一个拥有者线程的ID</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>每个线程都有两个ObjectMonitor对象列表，分别为free和used列表，如果当前free列表为空，线程将向全局global list请求分配ObjectMonitor。<br>ObjectMonitor对象中有两个队列：_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表；</p>
<p><img src="http://image.winrains.cn/2019/08/20190826153603-20c3d.png" alt="img"></p>
<h4 id="synchronized锁的获取和升级过程"><a href="#synchronized锁的获取和升级过程" class="headerlink" title="synchronized锁的获取和升级过程"></a>synchronized锁的获取和升级过程</h4><p>在jdk1.6中对锁的实现引入了大量的优化来减少锁操作的开销：<br>锁粗化（Lock Coarsening）：将多个连续的锁扩展成一个范围更大的锁，用以减少频繁互斥同步导致的性能损耗。<br>锁消除（Lock Elimination）：JVM及时编译器在运行时，通过逃逸分析，如果判断一段代码中，堆上的所有数据不会逃逸出去从来被其他线程访问到，就可以去除这些锁。<br>轻量级锁（Lightweight Locking）：JDK1.6引入。在没有多线程竞争的情况下避免重量级互斥锁，只需要依靠一条CAS原子指令就可以完成锁的获取及释放。<br>偏向锁（Biased Locking）：JDK1.6引入。目的是消除数据再无竞争情况下的同步原语。使用CAS记录获取它的线程。下一次同一个线程进入则偏向该线程，无需任何同步操作。<br>适应性自旋（Adaptive Spinning）：为了避免线程频繁挂起、恢复的状态切换消耗。产生了忙循环（循环时间固定），即自旋。JDK1.6引入了自适应自旋。自旋时间根据之前锁自旋时间和线程状态，动态变化，用以期望能减少阻塞的时间。<br>锁升级：自适应自旋锁–》偏向锁–》轻量级锁–》重量级锁</p>
<h5 id="自旋锁和自适应自旋锁："><a href="#自旋锁和自适应自旋锁：" class="headerlink" title="自旋锁和自适应自旋锁："></a><strong>自旋锁和自适应自旋锁：</strong></h5><p>虚拟机的开发团队注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。这项技术就是所谓的自选锁。<br>自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有获取到锁，则该线程应该被挂起。在JDK1.6中引入了自适应的自旋锁，自适应意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p>
<h5 id="偏向锁："><a href="#偏向锁：" class="headerlink" title="偏向锁："></a><strong>偏向锁：</strong></h5><p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。<br><img src="http://image.winrains.cn/2019/08/20190826153604-a4f4f.png" alt="img"></p>
<h5 id="轻量级锁："><a href="#轻量级锁：" class="headerlink" title="轻量级锁："></a><strong>轻量级锁：</strong></h5><p>如果MarkWord不是自己的ThreadId,锁升级，这时候，用CAS来执行切换，新的线程根据MarkWord里面现有的ThreadId，通知之前线程暂停，之前线程将Markword的内容置为空。<br>两个线程都把对象的Mark Word复制到自己新建的用于存储锁的记录空间（在当前线程的栈帧中建立一个名为Lock Record的空间，官方把这份拷贝称为Displaced Mark Word），接着开始通过CAS操作，把共享对象的MarKword更新为指向Lock Record的指针。<br><img src="http://image.winrains.cn/2019/08/20190826153605-88130.png" alt="img"></p>
<h5 id="重量级锁："><a href="#重量级锁：" class="headerlink" title="重量级锁："></a><strong>重量级锁：</strong></h5><p>自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于轻量级锁的状态，如果自旋失败则进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己，需要从用户态切换到内核态实现。1）只有一个线程进入临界区，偏向锁<br>2）多个线程交替进入临界区，轻量级锁<br>3）多线程同时进入临界区，重量级锁</p>
<blockquote>
<p>作者：匠丶</p>
<p>来源：<a href="https://www.jianshu.com/p/1ae887521cf3" target="_blank" rel="noopener">https://www.jianshu.com/p/1ae887521cf3</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>synchronized</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Java RMI</title>
    <url>/2019/12/26/%E7%90%86%E8%A7%A3Java-RMI/</url>
    <content><![CDATA[<h3 id="Java-RMI是什么"><a href="#Java-RMI是什么" class="headerlink" title="Java RMI是什么"></a>Java RMI是什么</h3><p>Java RMI（Java Remote Method Invocation），即Java远程方法调用。是Java编程语言里，一种用于实现远程过程调用的应用程序<strong>编程接口</strong>。</p>
<blockquote>
<p>注：很多文章或博客把RMI说成是一种消息协议，官方定义是java 编程接口。</p>
</blockquote>
<p>RMI 使用 JRMP（Java Remote Message Protocol，Java远程消息交换协议）实现，使得客户端运行的程序可以调用远程服务器上的对象。是实现RPC的一种方式。</p>
<a id="more"></a>

<h3 id="RMI-的使用"><a href="#RMI-的使用" class="headerlink" title="RMI 的使用"></a>RMI 的使用</h3><p>1、server端：创建远程对象，并注册远程对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义远程对象的接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">String <span class="title">say</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//接口的实现</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">super</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//注册远程对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException, MalformedURLException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        HelloServiceImpl helloService = <span class="keyword">new</span> HelloServiceImpl();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Naming.bind(<span class="string">"rmi://127.0.0.1/hello"</span>,helloService);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>2、client端：查找远程对象，调用远程方法</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public class<span class="built_in"> Client </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String[] args) throws RemoteException, NotBoundException, MalformedURLException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        HelloService helloService = (HelloService) Naming.lookup(<span class="string">"rmi://127.0.0.1/hello"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(helloService.say());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="RMI-的原理"><a href="#RMI-的原理" class="headerlink" title="RMI 的原理"></a>RMI 的原理</h3><p>RMI本质是TCP网络通信，内部封装了序列化和通信过程，使用代理实现接口调用。下一篇文章带大家手写一个RPC框架，会更加清晰的明白RMI原理。<br><img src="http://image.winrains.cn/2019/08/20190826154302-af6fa.png" alt="img"></p>
<p>调用过程</p>
<p>1、服务端</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用UnicastRemoteObject构造函数，发布对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">protected <span class="constructor">UnicastRemoteObject(<span class="params">int</span> <span class="params">port</span>)</span> throws RemoteException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    this.port = port;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    export<span class="constructor">Object((Remote)</span> this, port);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 创建UnicastServerRef对象，对象内有引用LiveRef(tcp通信)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public static Remote export<span class="constructor">Object(Remote <span class="params">obj</span>, <span class="params">int</span> <span class="params">port</span>)</span> throws RemoteException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return export<span class="constructor">Object(<span class="params">obj</span>, <span class="params">new</span> UnicastServerRef(<span class="params">port</span>)</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public Remote export<span class="constructor">Object(Remote <span class="params">var1</span>, Object <span class="params">var2</span>, <span class="params">boolean</span> <span class="params">var3</span>)</span> throws RemoteException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Class var4 = var1.get<span class="constructor">Class()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Remote var5;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 创建远程代理类，getClientRef提供的InvocationHandler提供了TCP连接</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        var5 = <span class="module-access"><span class="module"><span class="identifier">Util</span>.</span></span>create<span class="constructor">Proxy(<span class="params">var4</span>, <span class="params">this</span>.<span class="params">getClientRef</span>()</span>, this.forceStubUse);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; catch (IllegalArgumentException var7) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw <span class="keyword">new</span> <span class="constructor">ExportException(<span class="string">"remote object implements illegal remote interface"</span>, <span class="params">var7</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (var5 instanceof RemoteStub) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.set<span class="constructor">Skeleton(<span class="params">var1</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 包装实际对象，并将其暴露在TCP端口上，等待客户端调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Target var6 = <span class="keyword">new</span> <span class="constructor">Target(<span class="params">var1</span>, <span class="params">this</span>, <span class="params">var5</span>, <span class="params">this</span>.<span class="params">ref</span>.<span class="params">getObjID</span>()</span>, var3);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    this.<span class="built_in">ref</span>.export<span class="constructor">Object(<span class="params">var6</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    this.hashToMethod_Map = (Map) hashToMethod_Maps.get(var4);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return var5;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><img src="http://image.winrains.cn/2019/08/20190826154302-3e051.png" alt="img"></p>
<p>时序图</p>
<p>2、客户端</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端通过LocateRegistry的getRegistry方法创建RegistryImpl_Stub代理，调用RegistryImpl_Stub的newCall方法建立与服务端Skeleton的映射</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Registry getRegistry(<span class="keyword">String</span> host, int port,</span></pre></td></tr><tr><td class="code"><pre><span class="line">           RMIClientSocketFactory csf) throws RemoteException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Registry registry = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (port &lt;= <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            port = Registry.REGISTRY_PORT;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (host == <span class="literal">null</span> || host.length() == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// If host is blank (as returned by "file:" URL in 1.0.2 used in</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// java.rmi.Naming), try to convert to real local host name so</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// that the RegistryImpl's checkAccess will not fail.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                host = java.net.InetAddress.getLocalHost().getHostAddress();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// If that failed, at least try "" (localhost) anyway...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                host = <span class="string">""</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 调用RegistryImpl_Stub的lookup方法时，看似本地调用，实则通过tcp连接发送消息到服务端</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Remote lookup(<span class="keyword">String</span> var1) throws AccessException, NotBoundException, RemoteException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        RemoteCall var2 = <span class="keyword">super</span>.ref.<span class="keyword">new</span><span class="type">Call</span>(<span class="built_in">this</span>, operations, <span class="number">2</span>, <span class="number">4905912898345647071</span>L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ObjectOutput var3 = var2.getOutputStream();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            var3.writeObject(var1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (IOException var18) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">MarshalException</span>(<span class="string">"error marshalling arguments"</span>, var18);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">super</span>.ref.invoke(var2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Remote var23;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ObjectInput var6 = var2.getInputStream();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            var23 = (Remote) var6.readObject();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (IOException var15) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnmarshalException</span>(<span class="string">"error unmarshalling return"</span>, var15);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var16) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnmarshalException</span>(<span class="string">"error unmarshalling return"</span>, var16);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; finally &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">super</span>.ref.done(var2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> var23;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException var19) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> var19;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException var20) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> var20;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (NotBoundException var21) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> var21;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Exception var22) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnexpectedException</span>(<span class="string">"undeclared checked exception"</span>, var22);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="RMI-的优劣"><a href="#RMI-的优劣" class="headerlink" title="RMI 的优劣"></a>RMI 的优劣</h3><p>1、优势<br>给分布计算的系统设计、编程都带来了极大的方便。只要按照RMI规则设计程序，可以不必再过问在RMI之下的网络细节了，如：TCP和Socket等等。任意两台计算机之间的通讯完全由RMI负责。调用远程计算机上的对象就像本地对象一样方便。<br>2、劣势<br>RMI对服务器的IP地址和端口依赖很紧密，但是在开发的时候不知道将来的服务器IP和端口如何，而客户端程序又依赖这个IP和端口。即客户端如何维护服务端地址和动态感知服务端地址变化的问题。<br>另一局限性是，RMI是Java语言的远程调用，两端的程序语言必须是Java实现。</p>
<blockquote>
<p>作者：匠丶</p>
<p>来源：<a href="https://www.jianshu.com/p/5c6f2b6d458a" target="_blank" rel="noopener">https://www.jianshu.com/p/5c6f2b6d458a</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>RMI</tag>
      </tags>
  </entry>
  <entry>
    <title>Java序列化与反序列化</title>
    <url>/2019/12/26/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="一、什么是序列化与反序列化？"><a href="#一、什么是序列化与反序列化？" class="headerlink" title="一、什么是序列化与反序列化？"></a>一、什么是序列化与反序列化？</h2><blockquote>
<p>Java 序列化是指把 Java 对象转换为字节序列的过程；<br>Java 反序列化是指把字节序列恢复为 Java 对象的过程；</p>
</blockquote>
<a id="more"></a>

<h2 id="二、为什么要用序列化与反序列化？"><a href="#二、为什么要用序列化与反序列化？" class="headerlink" title="二、为什么要用序列化与反序列化？"></a>二、为什么要用序列化与反序列化？</h2><p>在 <strong>为什么要用序列化与反序列化</strong> 之前我们先了解一下对象序列化的两种用途：</p>
<ol>
<li>把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；</li>
<li>在网络上传送对象的字节序列。</li>
</ol>
<p>我们可以想想如果没有序列化之前，又是怎样一种情景呢？<br>举例：<br>Web 服务器中的 Session 会话对象，当有10万用户并发访问，就有可能出现10万个 Session 对象，显然这种情况内存可能是吃不消的。<br>于是 Web 容器就会把一些 Session 先序列化，让他们离开内存空间，序列化到硬盘中，当需要调用时，再把保存在硬盘中的对象还原到内存中。</p>
<hr>
<p>我们知道，当两个进程进行远程通信时，彼此可以发送各种类型的数据，包括文本、图片、音频、视频等， 而这些数据都会以二进制序列的形式在网络上传送。<br>同样的序列化与反序列化则实现了 <strong>进程通信间的对象传送</strong>，发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。</p>
<blockquote>
<p>初步总结：Java 序列化和反序列化，其一，实现了数据的持久化，通过序列化可以把数据永久的保存在硬盘上；其二，利用序列化实现远程通信，即在网络上传递对象的字节序列。</p>
</blockquote>
<h2 id="三、如何实现序列化与反序列化？"><a href="#三、如何实现序列化与反序列化？" class="headerlink" title="三、如何实现序列化与反序列化？"></a>三、如何实现序列化与反序列化？</h2><h3 id="3-1-JDK-类库中序列化-API"><a href="#3-1-JDK-类库中序列化-API" class="headerlink" title="3.1 JDK 类库中序列化 API"></a>3.1 JDK 类库中序列化 API</h3><p>使用到JDK中关键类 <code>ObjectOutputStream</code>(对象输出流) 和<code>ObjectInputStream</code>(对象输入流)<br><code>ObjectOutputStream</code> 类中：通过使用<code>writeObject(Object object)</code> 方法，将对象以二进制格式进行写入。<br><code>ObjectInputStream</code> 类中：通过使用 <code>readObject（）</code>方法，从输入流中读取二进制流，转换成对象。</p>
<h3 id="3-2-目标对象实现-Serializable-接口"><a href="#3-2-目标对象实现-Serializable-接口" class="headerlink" title="3.2 目标对象实现 Serializable 接口"></a>3.2 目标对象实现 Serializable 接口</h3><p>我们创建一个 <code>User</code> 类，实现 <code>Serializable</code> 接口，并生成一个版本号 ：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="title">implements</span> <span class="title">Serializable</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">long</span> serialVersionUID = <span class="number">3604972003323896788L</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> transient <span class="keyword">int</span> age;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> sex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> age;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> sex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.age = age;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">String</span> sex)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.sex = sex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>首先：<br>1、<code>Serializable</code> 接口的作用只是用来标识我们这个类是需要进行序列化，并且 <code>Serializable</code> 接口中并没有提供任何方法。<br>2、<code>SerialVersionUid</code> 序列化版本号的作用是用来区分我们所编写的类的版本，用于判断反序列化时类的版本是否一直，如果不一致会出现版本不一致异常。<br>3、<code>transient</code> 关键字，主要用来忽略我们不希望进行序列化的变量<br>由于第一种形式太不常见，故不再啰嗦演示，直接来看第二种实现 <code>Serializable</code> 接口的写入方式：<br><em>定义一个<code>Person</code>类，实现<code>Serializable</code>接口</em></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">implements</span> <span class="title">Serializable</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">long</span> serialVersionUID = <span class="number">-5809452578272945389L</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> sex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">get</span>..</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">set</span>...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><em>序列化和反序列化<code>Person</code>类对象</em></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">import java.io.FileInputStream;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.FileNotFoundException;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.FileOutputStream;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.IOException;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.ObjectInputStream;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.ObjectOutputStream;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.text.MessageFormat;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * &lt;p&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Description: 测试对象的序列化和反序列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * &lt;p&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> TestObjSerializeAndDeserialize &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String<span class="literal">[]</span> args) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="constructor">SerializePerson()</span>;<span class="comment">// 序列化Person对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Person p = <span class="constructor">DeserializePerson()</span>;<span class="comment">// 反序列Perons对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">MessageFormat</span>.</span></span>format(<span class="string">"name=&#123;0&#125;,age=&#123;1&#125;,sex=&#123;2&#125;"</span>, p.get<span class="constructor">Name()</span>, p.get<span class="constructor">Age()</span>, p.get<span class="constructor">Sex()</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * Description: 序列化Person对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> static void <span class="constructor">SerializePerson()</span> throws FileNotFoundException, IOException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Person person = <span class="keyword">new</span> <span class="constructor">Person()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        person.set<span class="constructor">Name(<span class="string">"gacl"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        person.set<span class="constructor">Age(25)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        person.set<span class="constructor">Sex(<span class="string">"男"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// ObjectOutputStream</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 对象输出流，将Person对象存储到E盘的Person.txt文件中，完成对Person对象的序列化操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ObjectOutputStream oo = <span class="keyword">new</span> <span class="constructor">ObjectOutputStream(<span class="params">new</span> FileOutputStream(<span class="params">new</span> File(<span class="string">"E:/Person.txt"</span>)</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        oo.write<span class="constructor">Object(<span class="params">person</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"Person对象序列化成功！"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        oo.close<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * Description: 反序列Perons对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> static Person <span class="constructor">DeserializePerson()</span> throws Exception, IOException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> <span class="constructor">ObjectInputStream(<span class="params">new</span> FileInputStream(<span class="params">new</span> File(<span class="string">"E:/Person.txt"</span>)</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Person person = (Person) ois.read<span class="constructor">Object()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"Person对象反序列化成功！"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return person;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><em>代码运行结果:</em><br><img src="http://image.winrains.cn/2019/08/42fff-1104426-20190325203837032-969156071.png" alt="img"></p>
<blockquote>
<p>疑问：<em>Person 实体中的 serialVersionUID 是个什么鬼？</em></p>
</blockquote>
<p><strong>答：</strong>序列化版本号，取值是 Java 运行时环境根据类的内部细节自动生成的。如果对类的源代码作了修改，再重新编译，新生成的类文件的 <code>serialVersionUID</code> 的取值有可能也会发生变化。。</p>
<h4 id="既然程序帮我门自动生成，那为何还要去定义该属性？"><a href="#既然程序帮我门自动生成，那为何还要去定义该属性？" class="headerlink" title="既然程序帮我门自动生成，那为何还要去定义该属性？"></a>既然程序帮我门自动生成，那为何还要去定义该属性？</h4><p>序列化和反序列化就是通过对比其 <code>SerialversionUID</code> 来进行的，我们修改一个实现 <code>Serializable</code> 接口的实体类，重新编译后，显然程序会重新会生成新值，那么一旦<code>SerialversionUID</code> 跟之前不匹配，反序列化就无法成功。<br>在实际的生产环境中，我们可能会建一系列的中间 Object 来反序列化我们的 pojo，为了解决这个问题，我们就需要在实体类中自定义 SerialversionUID，就像上方示例，不管我们序列化之后如何更改我们的 实体（不删除原有字段），最终都可以反序列化成功。。</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><h3 id="什么是序列化，如何实现序列化？"><a href="#什么是序列化，如何实现序列化？" class="headerlink" title="什么是序列化，如何实现序列化？"></a>什么是序列化，如何实现序列化？</h3><blockquote>
<p>Java 中对象的序列化就是将对象转换成二进制序列，反序列化则是将二进制序列转换成对象。<br>采用Java序列化与反序列化技术：</p>
<ul>
<li>一是可以实现数据的持久化，在MVC模式中很是有用；</li>
<li>二是可以对象数据的远程通信。</li>
</ul>
</blockquote>
<h3 id="Java-实现序列化的多种方式"><a href="#Java-实现序列化的多种方式" class="headerlink" title="Java 实现序列化的多种方式"></a>Java 实现序列化的多种方式</h3><ol>
<li>首先需要使用到工具类 ObjectInputStream 和ObjectOutputStream 两个IO类</li>
<li>实现 Serializable 接口</li>
<li>实现 Externalizable 接口</li>
</ol>
<blockquote>
<p>作者：niceyoo</p>
<p>来源：<a href="https://www.cnblogs.com/niceyoo/p/10596657.html" target="_blank" rel="noopener">https://www.cnblogs.com/niceyoo/p/10596657.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载机制</title>
    <url>/2019/12/26/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在学习 java 基础的时候，从宏观上了解一个类到运行大致是：.java 文件通过 javac 编译器编译得到 .class 文件，在用到该类时，jvm 会加载该 class 文件，并创建对应的 class 对象，将 class 文件加载到 jvm 的内存当中，这个过程也被称之为类加载过程。<br>下面我们将详细了解这个过程，本篇过长建议先收藏。</p>
<a id="more"></a>

<h2 id="1、类加载过程"><a href="#1、类加载过程" class="headerlink" title="1、类加载过程"></a>1、类加载过程</h2><p>其实关于类加载过程是分为5个阶段的：</p>
<blockquote>
<p>加载，验证，准备，解析，初始化</p>
</blockquote>
<p><img src="http://image.winrains.cn/2019/08/c9dd8-1104426-20190724234547657-749926780.png" alt="img">接下来我们看一下这五个阶段：</p>
<h3 id="1-1-加载"><a href="#1-1-加载" class="headerlink" title="1.1 加载"></a>1.1 加载</h3><p>JVM 在该阶段的主要目的是将字节码从不同的数据源（可能是 class 文件、也可能是 jar 包，甚至网络）转化为二进制字节流加载到内存中，并生成一个代表该类的 java.lang.Class 对象。</p>
<h3 id="1-2-验证"><a href="#1-2-验证" class="headerlink" title="1.2 验证"></a>1.2 验证</h3><p>这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全，只有符合 JVM 字节码规范的才能被 JVM 正确执行。该阶段是保证 JVM 安全的重要屏障，下面是一些主要的检查。</p>
<ul>
<li>确保二进制字节流格式符合预期（比如说是否以 cafe bene 咖啡北鼻开头）。</li>
<li>是否所有方法都遵守访问控制关键字的限定。</li>
<li>方法调用的参数个数和类型是否正确。</li>
<li>确保变量在使用之前被正确初始化了。</li>
<li>检查变量是否被赋予恰当类型的值。</li>
</ul>
<h3 id="1-3-准备"><a href="#1-3-准备" class="headerlink" title="1.3 准备"></a>1.3 准备</h3><p>JVM 会在该阶段对类变量（也称为静态变量，static 关键字修饰的）分配内存并初始化（对应数据类型的默认初始值，如 0、0L、null、false 等）。<br>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> static <span class="built_in">int</span> value1 = <span class="number">123</span>;</span></pre></td></tr></table></figure>

<p>实际上变量 value1 在准备阶段过后的初始值为 0 而不是 123（如果是String类型，初始值为null），将 value1 赋值为 123 的 putstatic 指令是程序被编译后，存放于类构造器方法之中。<br>但是注意如果声明为:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> <span class="built_in">int</span> value2 = <span class="number">123</span>;</span></pre></td></tr></table></figure>

<p>在编译阶段会为 value2 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 value2 赋值为 123。<br>也就是，static final 修饰的变量被称作为常量，和类变量不同。常量一旦赋值就不会改变了，所以 value2 在准备阶段的值为 123 而不是 0。</p>
<h3 id="1-4-解析"><a href="#1-4-解析" class="headerlink" title="1.4 解析"></a>1.4 解析</h3><p>该阶段将常量池中的符号引用转化为直接引用。<br>what？符号引用，直接引用？<br>符号引用以一组符号（任何形式的字面量，只要在使用时能够无歧义的定位到目标即可）来描述所引用的目标。<br>在编译时，Java 类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如 club.sscai.Test1 类引用了 club.sscai.Test2 类，编译时 Test1 类并不知道 Test2 类的实际内存地址，因此只能使用符号 club.sscai.Test2。<br>直接引用通过对符号引用进行解析，找到引用的实际内存地址。</p>
<h3 id="1-5-初始化"><a href="#1-5-初始化" class="headerlink" title="1.5 初始化"></a>1.5 初始化</h3><p>该阶段是类加载过程的最后一步。在准备阶段，类变量已经被赋过默认初始值，而在初始化阶段，类变量将被赋值为代码期望赋的值。换句话说，初始化阶段是执行类构造器方法的过程。<br>上面这段话说得比较抽象，不好理解，我来举个例子。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> niceyoo = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"感谢关注"</span>);</span></pre></td></tr></table></figure>

<p>上面这段代码使用了 new 关键字来实例化一个字符串对象，那么这时候，就会调用 String 类的构造方法对 niceyoo 进行实例化，怎么个实例化？就是赋值呗。</p>
<h3 id="本节点总结"><a href="#本节点总结" class="headerlink" title="本节点总结"></a>本节点总结</h3><p>其实看完类加载过程，由于大部分偏理论，乏味的同时又很难理解，也不容易记忆。所以将类加载过程结合面试题来进一步扩展，如下：</p>
<h3 id="建议先思考后再看答案"><a href="#建议先思考后再看答案" class="headerlink" title="建议先思考后再看答案"></a><strong>建议先思考后再看答案</strong></h3><p>题目一：如下代码中，执行 main 函数会通过编译吗？如果可以通过，打印结果是什么呢？</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">A</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun1</span>(<span class="params"></span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"fun1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span>(<span class="params"></span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"fun2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ((A) <span class="literal">null</span>).fun1();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ((A) <span class="literal">null</span>).fun2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>答案：</strong> 首先代码是可以通过编译的，null 可以强制转为任意类型，调用其类中的静态方法 fun1 不报异常，调用其类中的非静态方法 fun2 会报空指针异常。<br><img src="http://image.winrains.cn/2019/08/e0d2d-1104426-20190724234610277-1294325212.png" alt="img"><strong>分析：</strong> 编译是否正常通过最大的干扰项应该是 null 强转吧，估计有的小伙伴都不一定见过，<strong>null 可以被强制类型转换成任意类型的对象</strong>，知识点，下次要考。<br>关于打印结果则主要是类加载过程的考察：当加载类对象时，首先初始化静态属性，然后静态代码块；当实例化对象时，首先执行构造块（直接写在类中的代码块{ xxx }），然后执行构造方法。至于各静态块和静态属性初始化哪个些执行，是按代码的先后顺序。属性、构造块、构造方法之间的执行顺序（但构造块一定会在构造方法前执行），也是按代码的先后顺序。<br>综上，对象即便被将转为空时，静态方法也是可以被调用的，这也是我们平时在使用一些工具类时，直接通过对象.来访问其方法的原因。</p>
<hr>
<p>题目二：请指出下面程序的运行结果。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">print</span>(<span class="string">"1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">print</span>(<span class="string">"2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">extends</span> <span class="title">A</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">print</span>(<span class="string">"a"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">print</span>(<span class="string">"b"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        A ab = <span class="keyword">new</span> B();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ab = <span class="keyword">new</span> B();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>分析：</strong> 通过上一题目的分析中，我们可能机智的得到了静态代码块是优于构造方法的执行的，但是这个题目中出现了A\B类的继承关系，所以可能带来困扰，但是没关系，静态代码块就是优于构造方法的，只是父类优先级相对高一级罢了，比如 new B() 会先调用父类 A 的静态代码块，其次是 B 的静态代码块，然后是 A 的构造方法，最后是 B 的构造方法。<br>汇总：执行顺序是先执行父类的静态代码块，然后执行子类的静态代码块；然后执行父类的非静态代码块，再执行父类的构造方法；之后再执行子类的非静态代码块，再执行子类的构造方法。静态代码块&gt;非静态代码块&gt;构造方法。<br>再就是对象的创建只会调用一次静态代码块，因为类初始化信息是存在方法区里，当加载类的时候去检查，第二次的时候它会发现已经初始化过了，就不会再执行，所以再去 new B() 的时候，是不会再去打印 1a 的。<br>如果觉得比较绕，再举个例子，就好比你玩王者荣耀的时候，有个赵云的6元首充礼包，你第一次充钱，创建了这个首充礼包的对象，当你第二次充钱时就不会再有首充礼包了。<br>答案：1a2b2b</p>
<h2 id="2、类加载器"><a href="#2、类加载器" class="headerlink" title="2、类加载器"></a>2、类加载器</h2><p>聊完类加载过程的五个阶段，我们再来看看加载阶段用到的类加载器。<br>系统运行时，是由类加载器将 .class 文件的二进制数据从外部存储器（如光盘，硬盘）调入内存中，CPU再从内存中读取指令和数据进行运算，并将运算结果存入内存中的，显然类加载器是很重要的第一步。<br><img src="http://image.winrains.cn/2019/08/3b739-1104426-20190724234641496-310684500.png" alt="img">一般来说，Java 程序员并不需要直接同类加载器进行交互。JVM 默认的行为就已经足够满足大多数情况的需求了。不过，如果遇到了需要和类加载器进行交互的情况，而对类加载器的机制又不是很了解的话，就不得不花大量的时间去调试 ClassNotFoundException 和 NoClassDefFoundError 等异常。<br>对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在 JVM 中的唯一性。也就是说，如果两个类的加载器不同，即使两个类来源于同一个字节码文件，那这两个类就必定不相等（比如两个类的 Class 对象不 equals）。</p>
<p>Java 类加载器可以分为三种：</p>
<p>1）启动类加载器（Bootstrap Class-Loader），加载 jre/lib 包下面的 jar 文件，比如说常见的 rt.jar。</p>
<blockquote>
<p>启动类加载器主要加载的是JVM自身需要的类，这个类加载使用 C++ 语言实现的，是虚拟机自身的一部分，它负责将 <java_home style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">/lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中，注意必由于虚拟机是按照文件名识别加载jar包的，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的(出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类)。</p>
</blockquote>
<p>2）扩展类加载器（Extension or Ext Class-Loader），加载 jre/lib/ext 包下面的 jar 文件。</p>
<blockquote>
<p>扩展类加载器是指Sun公司(已被Oracle收购)实现的sun.misc.Launcher$ExtClassLoader类，由Java语言实现的，是Launcher的静态内部类，它负责加载<java_home style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用标准扩展类加载器。</p>
</blockquote>
<p>3）应用类加载器（Application or App Clas-Loader），根据程序的类路径（classpath）来加载 Java 类。</p>
<blockquote>
<p>也称应用程序加载器是指 Sun公司实现的sun.misc.Launcher$AppClassLoader。它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器。</p>
</blockquote>
<p>来来来，通过一段简单的代码了解下。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> Test1 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ClassLoader currentLoader = <span class="module-access"><span class="module"><span class="identifier">Test</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">ClassLoader()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(currentLoader.<span class="keyword">to</span><span class="constructor">String()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ClassLoader parentLoader = currentLoader.get<span class="constructor">Parent()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(parentLoader.<span class="keyword">to</span><span class="constructor">String()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ClassLoader parentParentLoader = parentLoader.get<span class="constructor">Parent()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(parentParentLoader);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>每个 Java 类都维护着一个指向定义它的类加载器的引用，通过 <strong>类名.class.getClassLoader()</strong> 可以获取到此引用；然后通过 <strong>.getParent()</strong> 可以获取类加载器的上层类加载器。<br>这段代码的输出结果如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">sun.misc.Launcher$<span class="symbol">AppClassLoader@</span><span class="number">18</span>b4aac2</span></pre></td></tr><tr><td class="code"><pre><span class="line">sun.misc.Launcher$<span class="symbol">ExtClassLoader@</span><span class="number">4554617</span>c</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="literal">null</span></span></pre></td></tr></table></figure>

<p>第一行输出为 Test 的类加载器，即应用类加载器，它是 <strong>sun.misc.Launcher<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAqCAYAAACQoioFAAAAIElEQVQ4T2P8////fwYsgHFUAj1URoMEI52MBsmwDRIAKbOng7HKdTAAAAAASUVORK5CYII=" alt="img"></strong> 类的实例；第二行输出为扩展类加载器，是 <strong>sun.misc.LauncherAppClassLoader∗∗类的实例；第二行输出为扩展类加载器，是∗∗sun.misc.LauncherExtClassLoader</strong> 类的实例。那启动类加载器呢？按理说，扩展类加载器的上层类加载器是启动类加载器，但在我这个版本的 JDK 中， 扩展类加载器的 getParent() 返回 null。<br>在 Java 的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，需要注意的是，Java 虚拟机对 class 文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象，而且加载某个类的 class 文件时， Java 虚拟机采用的是双亲委派模式即把请求交由父类处理，它一种任务委派模式，下面我们进一步了解它。</p>
<blockquote>
<p>别放弃，加油！</p>
</blockquote>
<h2 id="3、双亲委派模型"><a href="#3、双亲委派模型" class="headerlink" title="3、双亲委派模型"></a>3、双亲委派模型</h2><p><img src="http://image.winrains.cn/2019/08/f141e-1104426-20190724234703000-1379193788.png" alt="img">双亲委派模式是在 Java 1.2 后引入的，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成，这不就是传说中的实力坑爹啊？那么采用这种模式有啥用呢?</p>
<h3 id="双亲委派模式优势"><a href="#双亲委派模式优势" class="headerlink" title="双亲委派模式优势"></a>双亲委派模式优势</h3><p>采用双亲委派模式的是好处是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子 ClassLoader 再加载一次。<br>其次是考虑到安全因素，java 核心 api 中定义类型不会被随意替换，假设通过网络传递一个名为 java.lang.Integer 的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心 Java API 发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的 java.lang.Integer，而直接返回已加载过的 Integer.class，这样便可以防止核心API库被随意篡改。<br>可能你会想，如果我们在 classpath 路径下自定义一个名为 java.lang.SingleInterge 类(该类是胡编的)呢？该类并不存在 java.lang 中，经过双亲委托模式，传递到启动类加载器中，由于父类加载器路径下并没有该类，所以不会加载，将反向委托给子类加载器加载，最终会通过系统类加载器加载该类。但是这样做是不允许，因为 java.lang 是核心 API 包，需要访问权限，强制加载将会报出如下异常：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.SecurityException</span>: <span class="selector-tag">Prohibited</span> <span class="selector-tag">package</span> <span class="selector-tag">name</span>: <span class="selector-tag">java</span><span class="selector-class">.lang</span></span></pre></td></tr></table></figure>

<p>文字内容太乏味，上个例子吧，我们通过自定义类加载器去证实双亲委派模式。<br>先简单了解一下这个类加载器的主要方法：<br>loadClass：该方法中的逻辑就是双亲委派模式的实现，当类加载请求到来时，先从缓存中查找该类对象，如果存在直接返回，如果不存在则交给该类加载去的父加载器去加载，倘若没有父加载则交给顶级启动类加载器去加载，最后倘若仍没有找到，则使用findClass()方法去加载。<br>findClass：findClass()方法是在loadClass()方法中被调用的，当loadClass()方法中父加载器加载失败后，则会调用自己的findClass()方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。<br>defineClass：通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，defineClass()方法通常与findClass()方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象。<br>resolveClass：使用该方法可以使用类的Class对象创建完成也同时被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。<br>自定义类加载器 MyClassLoader ：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> club.sscai.test7;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * author: niceyoo blog: https://cnblogs.com/niceyoo desc: 自定义类加载器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="title">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> String path;<span class="comment">/* 加载器的路径 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> String name;<span class="comment">/* 类加载器名称 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> MyClassLoader(String path, String name) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">super</span>();<span class="comment">/* 让起同类加载器成为该类的父加载器 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.path = path;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 父类加载器构造方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> MyClassLoader(ClassLoader parent, String path, String name) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">super</span>(parent);<span class="comment">/* 显示指定父类加载器 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.path = path;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 加载我们自己定义的类，通过我们自定义的这个 ClassLoader 例如：club.sscai.test7.Demo</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/* 读取 class 文件，转换成二进制数组 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        byte[] <span class="keyword">data</span> = readClassFileToByteArray(name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(name, <span class="keyword">data</span>, <span class="number">0</span>, <span class="keyword">data</span>.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> String toString() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 获取 .class 字节数组 【读取 class 文件，将类转换成二进制数组】 club.sscai.test7.Demo &gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * F:/idea_workspace/test/Demo.class</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> byte[] readClassFileToByteArray(String name) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        InputStream <span class="keyword">is</span> = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        byte[] returnData = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        name = name.replace(<span class="string">"\\."</span>, <span class="string">"/"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String filePath = <span class="keyword">this</span>.path + name + <span class="string">".class"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        File file = new File(filePath);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ByteArrayOutputStream os = new ByteArrayOutputStream();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">is</span> = new FileInputStream(file);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            int tep = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span> ((tep = <span class="keyword">is</span>.read()) != -<span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                os.write(tep);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            returnData = os.toByteArray();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">is</span>.close();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                os.close();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> returnData;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name, resolve);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>当前项目位于 F:\idea_workspace\Demo</strong><br><img src="http://image.winrains.cn/2019/08/3b96d-1104426-20190724234731079-2119520945.png" alt="img">当前项目中的干扰项 Demo.java：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package club.sscai.test7;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * author: niceyoo blog: https://cnblogs.com/niceyoo desc: 干扰项Demo</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> Demo &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public <span class="constructor">Demo()</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"我是父加载器加载的Demo:"</span> + <span class="module-access"><span class="module"><span class="identifier">Demo</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">ClassLoader()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>存放在 <strong>F:/idea_workspace/test/</strong> 目录下的 Demo.java，注意如下代码需要通过 javac 编译成 Demo.class<br><img src="http://image.winrains.cn/2019/08/ab668-1104426-20190724234801916-368051353.png" alt="img"></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Demo:"</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>测试代码 TestDemo.java 如下：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/* 参数一为读取class路径，参数二为自定义类加载器名称 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        MyClassLoader xwLoader = <span class="keyword">new</span> <span class="type">MyClassLoader</span>(<span class="string">"F:/idea_workspace/test/"</span>, <span class="string">"xiaowang"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Class&lt;?&gt; demo = xwLoader.loadClass(<span class="string">"Demo"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        demo.<span class="keyword">new</span><span class="type">Instance</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>执行 main 方法后会打印什么呢？</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Demo:</span>xiaowang</span></pre></td></tr></table></figure>

<p>我们改一下测试代码：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        MyClassLoader xwLoader = <span class="keyword">new</span> <span class="type">MyClassLoader</span>(<span class="string">"F:/idea_workspace/test/"</span>, <span class="string">"xiaowang"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Class&lt;?&gt; demo = xwLoader.loadClass(<span class="string">"club.sscai.test7.Demo"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        demo.<span class="keyword">new</span><span class="type">Instance</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>再次执行会打印什么呢？</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">我是父加载器加载的Demo:sun.misc.Launcher$<span class="symbol">AppClassLoader@</span><span class="number">18</span>b4aac2</span></pre></td></tr></table></figure>

<p>显然第二次并没有加载 <strong>F:/idea_workspace/test/</strong> 目录下的 Demo，而是执行了当前项目中的 Demo，为什么？<br>这就是双亲委派模式，由于当前启动类 TestDemo 的父级是 AppClassLoader，显然该包下已经加载过 Demo 类了，所以不会再去加载目标 Demo</p>
<h2 id="4、热部署与热加载（扩展）"><a href="#4、热部署与热加载（扩展）" class="headerlink" title="4、热部署与热加载（扩展）"></a>4、热部署与热加载（扩展）</h2><p>上边算是说了一堆理论吧，热部署、热加载则算是实际应用了，相信这两者应该并不陌生，或多或少的应该也有所了解吧。<br>热加载的实现原理主要依赖java的类加载机制，在实现方式可以概括为在容器启动的时候起一条后台线程，定时的检测类文件的时间戳变化，如果类的时间戳变掉了，则将类重新载入。<br>热部署原理类似，但它是直接重新加载整个应用，这种方式会释放内存，比热加载更加干净彻底，但同时也更费时间。</p>
<h3 id="简单总结一下两者的区别与联系："><a href="#简单总结一下两者的区别与联系：" class="headerlink" title="简单总结一下两者的区别与联系："></a>简单总结一下两者的区别与联系：</h3><p>Java热部署与热加载的联系</p>
<ol>
<li>不重启服务器编译/部署项目</li>
<li>基于Java的类加载器实现</li>
</ol>
<h3 id="Java热部署与热加载的区别："><a href="#Java热部署与热加载的区别：" class="headerlink" title="Java热部署与热加载的区别："></a>Java热部署与热加载的区别：</h3><ul>
<li>部署方式<br>– 热部署在服务器运行时重新部署项目<br>– 热加载在运行时重新加载class</li>
<li>实现原理<br>– 热部署直接重新加载整个应用<br>– 热加载在运行时重新加载class</li>
<li>使用场景<br>– 热部署更多的是在生产环境使用<br>– 热加载则更多的实在开发环境使用</li>
</ul>
<h3 id="想要实现热部署可以分以下三个步骤："><a href="#想要实现热部署可以分以下三个步骤：" class="headerlink" title="想要实现热部署可以分以下三个步骤："></a>想要实现热部署可以分以下三个步骤：</h3><ol>
<li>销毁该自定义ClassLoader</li>
<li>更新class类文件</li>
<li>创建新的ClassLoader去加载更新后的class类文件。</li>
</ol>
<h6 id="相关代码："><a href="#相关代码：" class="headerlink" title="相关代码："></a>相关代码：</h6><p><strong>User没有被修改类：</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public class<span class="built_in"> User </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void <span class="builtin-name">add</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"addV1,没有修改过..."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>User更新类</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public class<span class="built_in"> User </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void <span class="builtin-name">add</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"我把之前的user add方法修改啦!"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>自定义类加载器：</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> <span class="type">Class</span>&lt;?&gt; findClass(<span class="type">String</span> name) <span class="keyword">throws</span> <span class="type">ClassNotFoundException</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">/* 文件名称 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="type">String</span> fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">/* 获取文件输入流 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="type">InputStream</span> is = <span class="keyword">this</span>.getClass().getResourceAsStream(fileName);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">/* 读取字节 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            byte[] b = <span class="keyword">new</span> byte[is.available()];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            is.read(b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">/* 将byte字节流解析成jvm能够识别的Class对象 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">Exception</span> e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">ClassNotFoundException</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>更新代码：</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Hotswap &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throws ClassNotFoundException, InstantiationException,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    IllegalAccessException, NoSuchMethodException,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    SecurityException, IllegalArgumentException,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    InvocationTargetException, InterruptedException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        loadUser();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.gc();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Thread.sleep(<span class="number">1000</span>);<span class="comment">/* 等待资源回收 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/* 需要被热部署的class文件 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        File file1 = <span class="built_in">new</span> File("F:\\test\\User.class");</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/* 之前编译好的class文件 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        File file2 = <span class="built_in">new</span> File(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                "F:\\idea_workspace\\target\\classes\\club\\sscai\\User.class");</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/* 删除旧版本的class文件 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="type">boolean</span> isDelete = file2.<span class="keyword">delete</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!isDelete) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.println("热部署失败.");</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        file1.renameTo(file2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("update success!");</span></pre></td></tr><tr><td class="code"><pre><span class="line">        loadUser();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> loadUser()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throws ClassNotFoundException, InstantiationException,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    IllegalAccessException, NoSuchMethodException,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    SecurityException, IllegalArgumentException,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    InvocationTargetException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        MyClassLoader myLoader = <span class="built_in">new</span> MyClassLoader();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">Class</span>&lt;?&gt; class1 = myLoader.findClass("club.sscai.User");</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">Object</span> obj1 = class1.newInstance();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">Method</span> <span class="keyword">method</span> = class1.getMethod("add");</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">method</span>.invoke(obj1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(obj1.getClass());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(obj1.getClass().getClassLoader());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="5、最后"><a href="#5、最后" class="headerlink" title="5、最后"></a>5、最后</h2><p>本篇有点过长了，其实大致看下来，类加载无非也就那么回事。<br>类加载机制：JVM 将类的信息动态添加到内存并使用的一种机制。</p>
<blockquote>
<p>作者：niceyoo</p>
<p>来源：<a href="https://www.cnblogs.com/niceyoo/p/11241660.html" target="_blank" rel="noopener">https://www.cnblogs.com/niceyoo/p/11241660.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
        <category>类加载机制</category>
      </categories>
  </entry>
  <entry>
    <title>JVM原理</title>
    <url>/2019/12/26/JVM%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="1：什么是JVM"><a href="#1：什么是JVM" class="headerlink" title="1：什么是JVM"></a>1：什么是JVM</h1><p>JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。 JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。</p>
<a id="more"></a>

<h1 id="2：JRE-JDK-JVM是什么关系"><a href="#2：JRE-JDK-JVM是什么关系" class="headerlink" title="2：JRE/JDK/JVM是什么关系"></a>2：JRE/JDK/JVM是什么关系</h1><p><strong>JRE(JavaRuntimeEnvironment，Java运行环境)</strong>，也就是Java平台。所有的Java 程序都要在JRE下才能运行。普通用户只需要运行已开发好的java程序，安装JRE即可。<br><strong>JDK(Java Development Kit)</strong>是程序开发者用来来编译、调试java程序用的开发工具包。JDK的工具也是Java程序，也需要JRE才能运行。为了保持JDK的独立性和完整性，在JDK的安装过程中，JRE也是 安装的一部分。所以，在JDK的安装目录下有一个名为jre的目录，用于存放JRE文件。<br><strong>JVM(JavaVirtualMachine，Java虚拟机)</strong>是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。</p>
<h1 id="3：JVM原理"><a href="#3：JVM原理" class="headerlink" title="3：JVM原理"></a>3：JVM原理</h1><p>JVM是java的核心和基础，在java编译器和os平台之间的虚拟处理器。它是一种利用软件方法实现的抽象的计算机基于下层的操作系统和硬件平台，可以在上面执行java的字节码程序。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826165532-bf0de.jpeg" alt="BAT面试必问之JVM原理"></p>
<p>java编译器只要面向JVM，生成JVM能理解的代码或字节码文件。Java源文件经编译成字节码程序，通过JVM将每一条指令翻译成不同平台机器码，通过特定平台运行。</p>
<h1 id="4：JVM的体系结构"><a href="#4：JVM的体系结构" class="headerlink" title="4：JVM的体系结构"></a>4：JVM的体系结构</h1><p><img src="http://image.winrains.cn/2019/08/20190826165532-1c666.jpeg" alt="BAT面试必问之JVM原理"></p>
<p>类装载器（ClassLoader）（用来装载.class文件）<br>执行引擎（执行字节码，或者执行本地方法）<br>运行时数据区（方法区、堆、java栈、PC寄存器、本地方法栈）</p>
<h1 id="5：JVM运行时数据区"><a href="#5：JVM运行时数据区" class="headerlink" title="5：JVM运行时数据区"></a>5：JVM运行时数据区</h1><p><img src="http://image.winrains.cn/2019/08/20190826165532-3a2c7.jpeg" alt="BAT面试必问之JVM原理"></p>
<p><strong>第一块：PC寄存器</strong><br>PC寄存器是用于存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。<br><strong>第二块：JVM栈</strong><br>JVM栈是线程私有的，每个线程创建的同时都会创建JVM栈，JVM栈中存放的为当前线程中局部基本类型的变量（java中定义的八种基本类型：boolean、char、byte、short、int、long、float、double）、部分的返回结果以及Stack Frame，非基本类型的对象在JVM栈上仅存放一个指向堆上的地址。<br><strong>第三块：堆（Heap）</strong><br>它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配，Heap中的对象的内存需要等待GC进行回收。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826165533-53809.jpeg" alt="BAT面试必问之JVM原理"></p>
<p>（1） 堆是JVM中所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也导致了new对象的开销是比较大的<br>（2） Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间TLAB（Thread Local Allocation Buffer），其大小由JVM根据运行的情况计算而得，在TLAB上分配对象时不需要加锁，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配<br>（3） TLAB仅作用于新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效。<br>（4） 所有新创建的Object 都将会存储在新生代Yong Generation中。如果Young Generation的数据在一次或多次GC后存活下来，那么将被转移到OldGeneration。新的Object总是创建在Eden Space。<br><strong>第四块：方法区域（Method Area）</strong><br>（1）在Sun JDK中这块区域对应的为PermanetGeneration，又称为持久代。<br>（2）方法区域存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当开发人员在程序中通过Class对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。<br><strong>第五块：运行时常量池（Runtime Constant Pool）</strong><br>存放的为类中的固定的常量信息、方法和Field的引用信息等，其空间从方法区域中分配。<br><strong>第六块：本地方法堆栈（Native Method Stacks）</strong><br>JVM采用本地方法堆栈来支持native方法的执行，此区域用于存储每个native方法调用的状态。</p>
<h1 id="6：对象“已死”的判定算法"><a href="#6：对象“已死”的判定算法" class="headerlink" title="6：对象“已死”的判定算法"></a>6：对象“已死”的判定算法</h1><p>由于程序计数器、Java虚拟机栈、本地方法栈都是线程独享，其占用的内存也是随线程生而生、随线程结束而回收。而Java堆和方法区则不同，线程共享，是GC的所关注的部分。<br>在堆中几乎存在着所有对象，GC之前需要考虑哪些对象还活着不能回收，哪些对象已经死去可以回收。<br><strong>有两种算法可以判定对象是否存活：</strong><br>1.）引用计数算法：给对象中添加一个引用计数器，每当一个地方应用了对象，计数器加1；当引用失效，计数器减1；当计数器为0表示该对象已死、可回收。但是它很难解决两个对象之间相互循环引用的情况。<br>2.）可达性分析算法：通过一系列称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（即对象到GC Roots不可达），则证明此对象已死、可回收。Java中可以作为GC Roots的对象包括：虚拟机栈中引用的对象、本地方法栈中Native方法引用的对象、方法区静态属性引用的对象、方法区常量引用的对象。<br>在主流的商用程序语言（如我们的Java）的主流实现中，都是通过可达性分析算法来判定对象是否存活的。</p>
<h1 id="7：JVM垃圾回收"><a href="#7：JVM垃圾回收" class="headerlink" title="7：JVM垃圾回收"></a>7：JVM垃圾回收</h1><p>GC (Garbage Collection)的基本原理：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停<br>（1）对新生代的对象的收集称为minor GC；<br>（2）对旧生代的对象的收集称为Full GC；<br>（3）程序中主动调用System.gc()强制执行的GC为Full GC。<br>不同的对象引用类型， GC会采用不同的方法进行回收，JVM对象的引用分为了四种类型：<br>（1）强引用：默认情况下，对象采用的均为强引用（这个对象的实例没有其他对象引用，GC时才会被回收）<br>（2）软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）<br>（3）弱引用：在GC时一定会被GC回收<br>（4）虚引用：由于虚引用只是用来得知对象是否被GC</p>
<h1 id="8：垃圾收集算法"><a href="#8：垃圾收集算法" class="headerlink" title="8：垃圾收集算法"></a>8：垃圾收集算法</h1><h2 id="1、标记-清除算法"><a href="#1、标记-清除算法" class="headerlink" title="1、标记-清除算法"></a><strong>1、标记-清除算法</strong></h2><p>最基础的算法，分标记和清除两个阶段：首先标记处所需要回收的对象，在标记完成后统一回收所有被标记的对象。<br>它有两点不足：一个效率问题，标记和清除过程都效率不高；一个是空间问题，标记清除之后会产生大量不连续的内存碎片（类似于我们电脑的磁盘碎片），空间碎片太多导致需要分配大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826165533-bed71.jpeg" alt="BAT面试必问之JVM原理"></p>
<h2 id="2、复制算法"><a href="#2、复制算法" class="headerlink" title="2、复制算法"></a><strong>2、复制算法</strong></h2><p>为了解决效率问题，出现了“复制”算法，他将可用内存按容量划分为大小相等的两块，每次只需要使用其中一块。当一块内存用完了，将还存活的对象复制到另一块上面，然后再把刚刚用完的内存空间一次清理掉。这样就解决了内存碎片问题，但是代价就是可以用内容就缩小为原来的一半。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826165533-40f22.jpeg" alt="BAT面试必问之JVM原理"></p>
<h2 id="3、标记-整理算法"><a href="#3、标记-整理算法" class="headerlink" title="3、标记-整理算法"></a><strong>3、标记-整理算法</strong></h2><p>复制算法在对象存活率较高时就会进行频繁的复制操作，效率将降低。因此又有了标记-整理算法，标记过程同标记-清除算法，但是在后续步骤不是直接对对象进行清理，而是让所有存活的对象都向一侧移动，然后直接清理掉端边界以外的内存。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826165533-91850.jpeg" alt="BAT面试必问之JVM原理"></p>
<h2 id="4、分代收集算法"><a href="#4、分代收集算法" class="headerlink" title="4、分代收集算法"></a><strong>4、分代收集算法</strong></h2><p>当前商业虚拟机的GC都是采用分代收集算法，这种算法并没有什么新的思想，而是根据对象存活周期的不同将堆分为：新生代和老年代，方法区称为永久代（在新的版本中已经将永久代废弃，引入了元空间的概念，永久代使用的是JVM内存而元空间直接使用物理内存）。<br>这样就可以根据各个年代的特点采用不同的收集算法。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826165533-eb40d.jpeg" alt="BAT面试必问之JVM原理"></p>
<p>新生代中的对象“朝生夕死”，每次GC时都会有大量对象死去，少量存活，使用复制算法。新生代又分为Eden区和Survivor区（Survivor from、Survivor to），大小比例默认为8:1:1。<br>老年代中的对象因为对象存活率高、没有额外空间进行分配担保，就使用标记-清除或标记-整理算法。<br>新产生的对象优先进去Eden区，当Eden区满了之后再使用Survivor from，当Survivor from 也满了之后就进行Minor GC（新生代GC），将Eden和Survivor from中存活的对象copy进入Survivor to，然后清空Eden和Survivor from，这个时候原来的Survivor from成了新的Survivor to，原来的Survivor to成了新的Survivor from。复制的时候，如果Survivor to 无法容纳全部存活的对象，则根据老年代的分配担保（类似于银行的贷款担保）将对象copy进去老年代，如果老年代也无法容纳，则进行Full GC（老年代GC）。<br>大对象直接进入老年代：JVM中有个参数配置-XX:PretenureSizeThreshold，令大于这个设置值的对象直接进入老年代，目的是为了避免在Eden和Survivor区之间发生大量的内存复制。<br>长期存活的对象进入老年代：JVM给每个对象定义一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳，将被移入Survivor并且年龄设定为1。没熬过一次Minor GC，年龄就加1，当他的年龄到一定程度（默认为15岁，可以通过XX:MaxTenuringThreshold来设定），就会移入老年代。但是JVM并不是永远要求年龄必须达到最大年龄才会晋升老年代，如果Survivor 空间中相同年龄（如年龄为x）所有对象大小的总和大于Survivor的一半，年龄大于等于x的所有对象直接进入老年代，无需等到最大年龄要求。</p>
<h1 id="9：垃圾收集器"><a href="#9：垃圾收集器" class="headerlink" title="9：垃圾收集器"></a>9：垃圾收集器</h1><p>垃圾收集算法是方法论，垃圾收集器是具体实现。JVM规范对于垃圾收集器的应该如何实现没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器差别较大，这里只看HotSpot虚拟机。<br>JDK7/8后，HotSpot虚拟机所有收集器及组合（连线）如下：</p>
<p><img src="http://image.winrains.cn/2019/08/20190826165533-455ef.jpeg" alt="BAT面试必问之JVM原理"></p>
<h2 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1.Serial收集器"></a><strong>1.Serial收集器</strong></h2><p>Serial收集器是最基本、历史最久的收集器，曾是新生代手机的唯一选择。他是单线程的，只会使用一个CPU或一条收集线程去完成垃圾收集工作，并且它在收集的时候，必须暂停其他所有的工作线程，直到它结束，即“Stop the World”。停掉所有的用户线程，对很多应用来说难以接受。比如你在做一件事情，被别人强制停掉，你心里奔腾而过的“羊驼”还数的过来吗？<br>尽管如此，它仍然是虚拟机运行在client模式下的默认新生代收集器：简单而高效（与其他收集器的单个线程相比，因为没有线程切换的开销等）。<br><strong>工作示意图：</strong></p>
<p><img src="http://image.winrains.cn/2019/08/20190826165534-d86ef.jpeg" alt="BAT面试必问之JVM原理"></p>
<h2 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2.ParNew收集器"></a><strong>2.ParNew收集器</strong></h2><p>ParNew收集器是Serial收集器的多线程版本，除了使用了多线程之外，其他的行为（收集算法、stop the world、对象分配规则、回收策略等）同Serial收集器一样。<br>是许多运行在Server模式下的JVM中首选的新生代收集器，其中一个很重还要的原因就是除了Serial之外，只有他能和老年代的CMS收集器配合工作。<br><strong>工作示意图：</strong></p>
<p><img src="http://image.winrains.cn/2019/08/20190826165534-62647.jpeg" alt="BAT面试必问之JVM原理"></p>
<h2 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3.Parallel Scavenge收集器"></a><strong>3.Parallel Scavenge收集器</strong></h2><p>新生代收集器，并行的多线程收集器。它的目标是达到一个可控的吞吐量（就是CPU运行用户代码的时间与CPU总消耗时间的比值，即 吞吐量=行用户代码的时间/[行用户代码的时间+垃圾收集时间]），这样可以高效率的利用CPU时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p>
<h2 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="4.Serial Old收集器"></a><strong>4.Serial Old收集器</strong></h2><p>Serial 收集器的老年代版本，单线程，“标记整理”算法，主要是给Client模式下的虚拟机使用。<br>另外还可以在Server模式下：<br>JDK 1.5之前的版本中雨Parallel Scavenge 收集器搭配使用<br>可以作为CMS的后背方案，在CMS发生Concurrent Mode Failure是使用<br><strong>工作示意图：</strong></p>
<p><img src="http://image.winrains.cn/2019/08/20190826165534-89425.jpeg" alt="BAT面试必问之JVM原理"></p>
<h2 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="5.Parallel Old收集器"></a><strong>5.Parallel Old收集器</strong></h2><p>Parallel Scavenge的老年代版本，多线程，“标记整理”算法，JDK 1.6才出现。在此之前Parallel Scavenge只能同Serial Old搭配使用，由于Serial Old的性能较差导致Parallel Scavenge的优势发挥不出来，尴了个尬~~<br>Parallel Old收集器的出现，使“吞吐量优先”收集器终于有了名副其实的组合。在吞吐量和CPU敏感的场合，都可以使用Parallel Scavenge/Parallel Old组合。组合的工作<strong>示意图如下：</strong></p>
<p><img src="http://image.winrains.cn/2019/08/20190826165534-78fb1.jpeg" alt="BAT面试必问之JVM原理"></p>
<h2 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6.CMS收集器"></a><strong>6.CMS收集器</strong></h2><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。<br>基于“标记清除”算法，并发收集、低停顿，运作过程复杂，分4步：<br><em>1)初始标记：</em>仅仅标记GC Roots能直接关联到的对象，速度快，但是需要“Stop The World”<br><em>2)并发标记：</em>就是进行追踪引用链的过程，可以和用户线程并发执行。<br><em>3)重新标记：</em>修正并发标记阶段因用户线程继续运行而导致标记发生变化的那部分对象的标记记录，比初始标记时间长但远比并发标记时间短，需要“Stop The World”<br><em>4)并发清除：</em>清除标记为可以回收对象，可以和用户线程并发执行<br>由于整个过程耗时最长的并发标记和并发清除都可以和用户线程一起工作，所以总体上来看，CMS收集器的内存回收过程和用户线程是并发执行的。<br><strong>工作示意图：</strong></p>
<p><img src="http://image.winrains.cn/2019/08/20190826165534-413da.jpeg" alt="BAT面试必问之JVM原理"></p>
<p><strong>CSM收集器有3个缺点：</strong><br><strong>1)对CPU资源非常敏感</strong><br>并发收集虽然不会暂停用户线程，但因为占用一部分CPU资源，还是会导致应用程序变慢，总吞吐量降低。<br>CMS的默认收集线程数量是=(CPU数量+3)/4；当CPU数量多于4个，收集线程占用的CPU资源多于25%，对用户程序影响可能较大；不足4个时，影响更大，可能无法接受。<br><strong>2)无法处理浮动垃圾</strong>（在并发清除时，用户线程新产生的垃圾叫浮动垃圾）,可能出现”Concurrent Mode Failure”失败。<br>并发清除时需要预留一定的内存空间，不能像其他收集器在老年代几乎填满再进行收集；如果CMS预留内存空间无法满足程序需要，就会出现一次”Concurrent Mode Failure”失败；这时JVM启用后备预案：临时启用Serail Old收集器，而导致另一次Full GC的产生；<br><strong>3)产生大量内存碎片：</strong>CMS基于”标记-清除”算法，清除后不进行压缩操作产生大量不连续的内存碎片，这样会导致分配大内存对象时，无法找到足够的连续内存，从而需要提前触发另一次Full GC动作。</p>
<h2 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7.G1收集器"></a><strong>7.G1收集器</strong></h2><p>G1（Garbage-First）是JDK7-u4才正式推出商用的收集器。G1是面向服务端应用的垃圾收集器。它的使命是未来可以替换掉CMS收集器。<br><strong>G1收集器特性：</strong><br>并行与并发：能充分利用多CPU、多核环境的硬件优势，缩短停顿时间；能和用户线程并发执行。<br><strong>分代收集：</strong>G1可以不需要其他GC收集器的配合就能独立管理整个堆，采用不同的方式处理新生对象和已经存活一段时间的对象。<br><strong>空间整合：</strong>整体上看采用标记整理算法，局部看采用复制算法（两个Region之间），不会有内存碎片，不会因为大对象找不到足够的连续空间而提前触发GC，这点优于CMS收集器。<br><strong>可预测的停顿：</strong>除了追求低停顿还能建立可以预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超N毫秒，这点优于CMS收集器。<br><strong>为什么能做到可预测的停顿？</strong><br>是因为可以有计划的避免在整个Java堆中进行全区域的垃圾收集。<br>G1收集器将内存分大小相等的独立区域（Region），新生代和老年代概念保留，但是已经不再物理隔离。<br>G1跟踪各个Region获得其收集价值大小，在后台维护一个优先列表；<br>每次根据允许的收集时间，优先回收价值最大的Region（名称Garbage-First的由来）；<br>这就保证了在有限的时间内可以获取尽可能高的收集效率。<br><strong>对象被其他Region的对象引用了怎么办？</strong></p>
<blockquote>
<p>判断对象存活时，是否需要扫描整个Java堆才能保证准确？在其他的分代收集器，也存在这样的问题（而G1更突出）：新生代回收的时候不得不扫描老年代？<br>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描：<br>每个Region都有一个对应的Remembered Set；<br>每次Reference类型数据写操作时，都会产生一个Write Barrier 暂时中断操作；<br>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的 Region（其他收集器：检查老年代对象是否引用了新生代对象）；<br>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；<br>进行垃圾收集时，在GC根节点的枚举范围加入 Remembered Set ，就可以保证不进行全局扫描，也不会有遗漏。</p>
</blockquote>
<p>不计算维护Remembered Set的操作，回收过程可以分为4个步骤（与CMS较为相似）：<br>1)初始标记：仅仅标记GC Roots能直接关联到的对象，并修改TAMS(Next Top at Mark Start)的值，让下一阶段用户程序并发运行时能在正确可用的Region中创建新对象，需要“Stop The World”<br>2)并发标记：从GC Roots开始进行可达性分析，找出存活对象，耗时长，可与用户线程并发执行<br>3)最终标记：修正并发标记阶段因用户线程继续运行而导致标记发生变化的那部分对象的标记记录。并发标记时虚拟机将对象变化记录在线程Remember Set Logs里面，最终标记阶段将Remember Set Logs整合到Remember Set中，比初始标记时间长但远比并发标记时间短，需要“Stop The World”<br>4)筛选回收：首先对各个Region的回收价值和成本进行排序，然后根据用户期望的GC停顿时间来定制回收计划，最后按计划回收一些价值高的Region中垃圾对象。回收时采用复制算法，从一个或多个Region复制存活对象到堆上的另一个空的Region，并且在此过程中压缩和释放内存；可以并发进行，降低停顿时间，并增加吞吐量。<br>工作示意图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190826165534-5704f.jpeg" alt="BAT面试必问之JVM原理"></p>
<blockquote>
<p>作者：Java架构师资讯</p>
<p>来源：<a href="https://www.toutiao.com/a6631118760528855565/" target="_blank" rel="noopener">https://www.toutiao.com/a6631118760528855565/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Tomcat系统架构</title>
    <url>/2019/12/26/Tomcat%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<blockquote>
<p>俗话说，站在巨人的肩膀上看世界，一般学习的时候也是先总览一下整体，然后逐个部分个个击破，最后形成思路，了解具体细节，Tomcat的结构很复杂，但是 Tomcat 非常的模块化，找到了 Tomcat最核心的模块，问题才可以游刃而解，了解了Tomcat的整体架构对以后深入了解Tomcat来说至关重要！</p>
</blockquote>
<a id="more"></a>

<h2 id="一、Tomcat顶层架构"><a href="#一、Tomcat顶层架构" class="headerlink" title="一、Tomcat顶层架构**"></a>一、Tomcat顶层架构**</h2><p>先上一张Tomcat的顶层结构图（图A），如下：</p>
<p><img src="http://image.winrains.cn/2019/08/20190826165807-92b84.jpeg" alt="四张图带你了解Tomcat系统架构——让面试官颤抖的Tomcat回答系列！"></p>
<p>Tomcat中最顶层的容器是Server，代表着整个服务器，从上图中可以看出，一个Server可以包含至少一个Service，用于具体提供服务。<br>Service主要包含两个部分：Connector和Container。从上图中可以看出 Tomcat 的心脏就是这两个组件，他们的作用如下：</p>
<blockquote>
<p>1、Connector用于处理连接相关的事情，并提供Socket与Request和Response相关的转化;<br>2、Container用于封装和管理Servlet，以及具体处理Request请求；</p>
</blockquote>
<p>一个Tomcat中只有一个Server，一个Server可以包含多个Service，一个Service只有一个Container，但是可以有多个Connectors，这是因为一个服务可以有多个连接，如同时提供Http和Https链接，也可以提供向相同协议不同端口的连接,示意图如下（Engine、Host、Context下边会说到）：</p>
<p><img src="http://image.winrains.cn/2019/08/20190826165807-756eb.jpeg" alt="四张图带你了解Tomcat系统架构——让面试官颤抖的Tomcat回答系列！"></p>
<p>多个 Connector 和一个 Container 就形成了一个 Service，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了！所以整个 Tomcat 的生命周期由 Server 控制。<br>另外，上述的包含关系或者说是父子关系，都可以在tomcat的conf目录下的server.xml配置文件中看出，下图是删除了注释内容之后的一个完整的server.xml配置文件（Tomcat版本为8.0）</p>
<p><img src="http://image.winrains.cn/2019/08/20190826165808-f1898.jpeg" alt="四张图带你了解Tomcat系统架构——让面试官颤抖的Tomcat回答系列！"></p>
<p>详细的配置文件文件内容可以到Tomcat官网查看：<a href="http://tomcat.apache.org/tomcat-8.0-doc/index.html" target="_blank" rel="noopener">http://tomcat.apache.org/tomcat-8.0-doc/index.html</a><br>上边的配置文件，还可以通过下边的一张结构图更清楚的理解：</p>
<p><img src="http://image.winrains.cn/2019/08/20190826165808-8f57b.jpeg" alt="四张图带你了解Tomcat系统架构——让面试官颤抖的Tomcat回答系列！"></p>
<p>Server标签设置的端口号为8005，shutdown=”SHUTDOWN” ，表示在8005端口监听“SHUTDOWN”命令，如果接收到了就会关闭Tomcat。一个Server有一个Service，当然还可以进行配置，一个Service有多个，Service左边的内容都属于Container的，Service下边是Connector。</p>
<h2 id="二、Tomcat顶层架构小结："><a href="#二、Tomcat顶层架构小结：" class="headerlink" title="二、Tomcat顶层架构小结："></a><strong>二、Tomcat顶层架构小结：</strong></h2><p>（1）Tomcat中只有一个Server，一个Server可以有多个Service，一个Service可以有多个Connector和一个Container；<br>（2） Server掌管着整个Tomcat的生死大权；<br>（4）Service 是对外提供服务的；<br>（5）Connector用于接受请求并将请求封装成Request和Response来具体处理；<br>（6）Container用于封装和管理Servlet，以及具体处理request请求；<br>知道了整个Tomcat顶层的分层架构和各个组件之间的关系以及作用，对于绝大多数的开发人员来说Server和Service对我们来说确实很远，而我们开发中绝大部分进行配置的内容是属于Connector和Container的，所以接下来介绍一下Connector和Container。</p>
<h2 id="三、Connector和Container的微妙关系"><a href="#三、Connector和Container的微妙关系" class="headerlink" title="三、Connector和Container的微妙关系"></a><strong>三、Connector和Container的微妙关系</strong></h2><p>由上述内容我们大致可以知道一个请求发送到Tomcat之后，首先经过Service然后会交给我们的Connector，Connector用于接收请求并将接收的请求封装为Request和Response来具体处理，Request和Response封装完之后再交由Container进行处理，Container处理完请求之后再返回给Connector，最后在由Connector通过Socket将处理的结果返回给客户端，这样整个请求的就处理完了！<br>Connector最底层使用的是Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connector同时需要实现TCP/IP协议和HTTP协议！<br>Tomcat既然处理请求，那么肯定需要先接收到这个请求，接收请求这个东西我们首先就需要看一下Connector！</p>
<h2 id="四、Connector架构分析"><a href="#四、Connector架构分析" class="headerlink" title="四、Connector架构分析"></a><strong>四、Connector架构分析</strong></h2><p>Connector用于接受请求并将请求封装成Request和Response，然后交给Container进行处理，Container处理完之后在交给Connector返回给客户端。<br>因此，我们可以把Connector分为四个方面进行理解：<br>（1）Connector如何接受请求的？<br>（2）如何将请求封装成Request和Response的？<br>（3）封装完之后的Request和Response如何交给Container进行处理的？<br>（4）Container处理完之后如何交给Connector并返回给客户端的？<br>首先看一下Connector的结构图（图B），如下所示：</p>
<p><img src="http://image.winrains.cn/2019/08/20190826165808-d5684.jpeg" alt="四张图带你了解Tomcat系统架构——让面试官颤抖的Tomcat回答系列！"></p>
<p>Connector就是使用ProtocolHandler来处理请求的，不同的ProtocolHandler代表不同的连接类型，比如：Http11Protocol使用的是普通Socket来连接的，Http11NioProtocol使用的是NioSocket来连接的。<br>其中ProtocolHandler由包含了三个部件：Endpoint、Processor、Adapter。<br>（1）Endpoint用来处理底层Socket的网络连接，Processor用于将Endpoint接收到的Socket封装成Request，Adapter用于将Request交给Container进行具体的处理。<br>（2）Endpoint由于是处理底层的Socket网络连接，因此Endpoint是用来实现TCP/IP协议的，而Processor用来实现HTTP协议的，Adapter将请求适配到Servlet容器进行具体的处理。<br>（3）Endpoint的抽象实现AbstractEndpoint里面定义的Acceptor和AsyncTimeout两个内部类和一个Handler接口。Acceptor用于监听请求，AsyncTimeout用于检查异步Request的超时，Handler用于处理接收到的Socket，在内部调用Processor进行处理。<br>至此，我们应该很轻松的回答（1）（2）（3）的问题了，但是（4）还是不知道，那么我们就来看一下Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？</p>
<h2 id="五、Container架构分析"><a href="#五、Container架构分析" class="headerlink" title="五、Container架构分析"></a><strong>五、Container架构分析</strong></h2><p>Container用于封装和管理Servlet，以及具体处理Request请求，在Connector内部包含了4个子容器，结构图如下（图C）：</p>
<p><img src="http://image.winrains.cn/2019/08/20190826165808-3bdae.jpeg" alt="四张图带你了解Tomcat系统架构——让面试官颤抖的Tomcat回答系列！"></p>
<p>4个子容器的作用分别是：<br>（1）Engine：引擎，用来管理多个站点，一个Service最多只能有一个Engine；<br>（2）Host：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点；<br>（3）Context：代表一个应用程序，对应着平时开发的一套程序，或者一个WEB-INF目录以及下面的web.xml文件；<br>（4）Wrapper：每一Wrapper封装着一个Servlet；<br>下面找一个Tomcat的文件目录对照一下，如下图所示：</p>
<p><img src="http://image.winrains.cn/2019/08/20190826165808-bbc3d.jpeg" alt="四张图带你了解Tomcat系统架构——让面试官颤抖的Tomcat回答系列！"></p>
<p>Context和Host的区别是Context表示一个应用，我们的Tomcat中默认的配置下webapps下的每一个文件夹目录都是一个Context，其中ROOT目录中存放着主应用，其他目录存放着子应用，而整个webapps就是一个Host站点。<br>我们访问应用Context的时候，如果是ROOT下的则直接使用域名就可以访问，例如：<a href="http://www.ledouit.com,如果是Host（webapps）下的其他应用，则可以使用www.ledouit.com/docs进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主营用是ROOT目录下的。" target="_blank" rel="noopener">www.ledouit.com,如果是Host（webapps）下的其他应用，则可以使用www.ledouit.com/docs进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主营用是ROOT目录下的。</a><br>看到这里我们知道Container是什么，但是还是不知道Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？别急！下边就开始探讨一下Container是如何进行处理的！</p>
<h2 id="六、Container如何处理请求的"><a href="#六、Container如何处理请求的" class="headerlink" title="六、Container如何处理请求的"></a><strong>六、Container如何处理请求的</strong></h2><p>Container处理请求是使用Pipeline-Valve管道来处理的！（Valve是阀门之意）<br>Pipeline-Valve是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将处理后的请求返回，再让下一个处理着继续处理。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826165809-91b38.jpeg" alt="四张图带你了解Tomcat系统架构——让面试官颤抖的Tomcat回答系列！"></p>
<p>但是！Pipeline-Valve使用的责任链模式和普通的责任链模式有些不同！区别主要有以下两点：<br>（1）每个Pipeline都有特定的Valve，而且是在管道的最后一个执行，这个Valve叫做BaseValve，BaseValve是不可删除的；<br>（2）在上层容器的管道的BaseValve中会调用下层容器的管道。<br>我们知道Container包含四个子容器，而这四个子容器对应的BaseValve分别在：StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve。<br>Pipeline的处理流程图如下（图D）：</p>
<p><img src="http://image.winrains.cn/2019/08/20190826165809-2edbc.jpeg" alt="四张图带你了解Tomcat系统架构——让面试官颤抖的Tomcat回答系列！"></p>
<p>（1）Connector在接收到请求后会首先调用最顶层容器的Pipeline来处理，这里的最顶层容器的Pipeline就是EnginePipeline（Engine的管道）；<br>（2）在Engine的管道中依次会执行EngineValve1、EngineValve2等等，最后会执行StandardEngineValve，在StandardEngineValve中会调用Host管道，然后再依次执行Host的HostValve1、HostValve2等，最后在执行StandardHostValve，然后再依次调用Context的管道和Wrapper的管道，最后执行到StandardWrapperValve。<br>（3）当执行到StandardWrapperValve的时候，会在StandardWrapperValve中创建FilterChain，并调用其doFilter方法来处理请求，这个FilterChain包含着我们配置的与请求相匹配的Filter和Servlet，其doFilter方法会依次调用所有的Filter的doFilter方法和Servlet的service方法，这样请求就得到了处理！<br>（4）当所有的Pipeline-Valve都执行完之后，并且处理完了具体的请求，这个时候就可以将返回的结果交给Connector了，Connector在通过Socket的方式将结果返回给客户端。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>至此，我们已经对Tomcat的整体架构有了大致的了解，从图A、B、C、D可以看出来每一个组件的基本要素和作用。我们在脑海里应该有一个大概的轮廓了！如果你面试的时候，让你简单的聊一下Tomcat，上面的内容你能脱口而出吗？当你能够脱口而出的时候，这位面试官一定会对你刮目相看的！</p>
<blockquote>
<p>作者：互联网技能图谱</p>
<p>来源：<a href="https://www.toutiao.com/a6669312174453686795/" target="_blank" rel="noopener">https://www.toutiao.com/a6669312174453686795/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
        <category>Tomcat</category>
      </categories>
  </entry>
  <entry>
    <title>使用JNA访问Java外部功能接口</title>
    <url>/2019/12/26/%E4%BD%BF%E7%94%A8JNA%E8%AE%BF%E9%97%AEJava%E5%A4%96%E9%83%A8%E5%8A%9F%E8%83%BD%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="1-JNA简单介绍"><a href="#1-JNA简单介绍" class="headerlink" title="1. JNA简单介绍"></a>1. JNA简单介绍</h1><p>先说JNI(Java Native Interface)吧，有过不同语言间通信经历的一般都知道，它允许Java代码和其他语言（尤其C/C++）写的代码进行交互，只要遵守调用约定即可。首先看下JNI调用C/C++的过程，注意写程序时自下而上，调用时自上而下。<br><img src="http://image.winrains.cn/2019/08/90fb4-311340147974036.png" alt="img"></p>
<a id="more"></a>

<p>可 见步骤非常的多，很麻烦，使用JNI调用.dll/.so共享库都能体会到这个痛苦的过程。如果已有一个编译好的.dll/.so文件，如果使用JNI技 术调用，我们首先需要使用C语言另外写一个.dll/.so共享库，使用SUN规定的数据结构替代C语言的数据结构，调用已有的 dll/so中公布的函 数。然后再在Java中载入这个库dll/so，最后编写Java native函数作为链接库中函数的代理。经过这些繁琐的步骤才能在Java中调用 本地代码。因此，很少有Java程序员愿意编写调用dll/.so库中原生函数的java程序。这也使Java语言在客户端上乏善可陈，可以说JNI是 Java的一大弱点！<br>那么JNA是什么呢？<br>JNA(Java Native Access)是一个开源的Java框架，是Sun公司推出的一种调用本地方法的技术，是建立在经典的JNI基础之上的一个框架。之所以说它是JNI的替 代者，是因为JNA大大简化了调用本地方法的过程，使用很方便，基本上不需要脱离Java环境就可以完成。<br>如果要和上图做个比较，那么JNA调用C/C++的过程大致如下：<br><img src="http://image.winrains.cn/2019/08/68b10-311340321101993.png" alt="img"><br>可以看到步骤减少了很多，最重要的是我们不需要重写我们的动态链接库文件，而是有直接调用的API，大大简化了我们的工作量。<br>JNA只需要我们写Java代码而不用写JNI或本地代码。功能相对于Windows的Platform/Invoke和Python的ctypes。</p>
<h1 id="2-JNA技术原理"><a href="#2-JNA技术原理" class="headerlink" title="2. JNA技术原理"></a>2. JNA技术原理</h1><p>JNA使用一个小型的JNI库插桩程序来动态调用本地代码。开发者使用Java接口描述目标本地库的功能和结构，这使得它很容易利用本机平台的功能，而不会产生多平台配置和生成JNI代码的高开销。这样的性能、准确性和易用性显然受到很大的重视。<br>此外，JNA包括一个已与许多本地函数映射的平台库，以及一组简化本地访问的公用接口。<br><strong>注意：</strong><br>JNA是建立在JNI技术基础之上的一个Java类库，它使您可以方便地使用java直接访问动态链接库中的函数。<br>原来使用JNI，你必须手工用C写一个动态链接库，在C语言中映射Java的数据类型。<br>JNA中，它提供了一个动态的C语言编写的转发器，可以自动实现Java和C的数据类型映射，你不再需要编写C动态链接库。<br>也许这也意味着，使用JNA技术比使用JNI技术调用动态链接库会有些微的性能损失。但总体影响不大，因为JNA也避免了JNI的一些平台配置的开销。</p>
<h1 id="3-JNA简单使用"><a href="#3-JNA简单使用" class="headerlink" title="3. JNA简单使用"></a>3. JNA简单使用</h1><p>JNA的项目已迁移至<a href="https://github.com/twall/jna" target="_blank" rel="noopener">Github</a>，目前最新版本是4.1.0，已有打包好的jar文件可供下载。<br>JNA把一个.dll/.so文件看做是一个Java接口，下面以一个简单的实例来说明怎么使用。<br>当然要从最经典的HelloWorld开始，我们调用C的printf函数打印出“HelloWorld”（官方的例子），前提是已将jar包加入你的classpath。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.jna.examples;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.jna.Library;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.jna.Native;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.jna.Platform;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/** Simple example of JNA interface mapping and usage. */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// This is the standard, stable way of mapping, which supports extensive</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// customization and mapping of Java to native types.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CLibrary</span> <span class="keyword">extends</span> <span class="title">Library</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        CLibrary INSTANCE = (CLibrary)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Native.loadLibrary((Platform.isWindows() ? <span class="string">"msvcrt"</span> : <span class="string">"c"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                               CLibrary<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(String format, Object... args)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        CLibrary.INSTANCE.printf(<span class="string">"Hello, World\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; args.length;i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            CLibrary.INSTANCE.printf(<span class="string">"Argument %d: %s\n"</span>, i, args[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>运行程序，如果没有带参数则只打印出“Hello, World”，如果带了参数，则会打印出所有的参数。<br>很简单，不需要写一行C代码，就可以直接在Java中调用外部动态链接库中的函数！<br><strong>下面来解释下这个程序。</strong></p>
<h2 id="（1）需要定义一个接口，继承自Library或StdCallLibrary"><a href="#（1）需要定义一个接口，继承自Library或StdCallLibrary" class="headerlink" title="（1）需要定义一个接口，继承自Library或StdCallLibrary"></a>（1）需要定义一个接口，继承自<code>Library</code>或<code>StdCallLibrary</code></h2><p>``默认的是继承<code>Library</code>，如果动态链接库里的函数是以stdcall方式输出的，那么就继承<code>StdCallLibrary</code>，比如众所周知的kernel32库。比如上例中的接口定义：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>CLibrary extends Library &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="（2）接口内部定义"><a href="#（2）接口内部定义" class="headerlink" title="（2）接口内部定义"></a>（2）接口内部定义</h2><p>接口内部需要一个公共静态常量：<code>INSTANCE，</code>通过这个常量，就可以获得这个接口的实例，从而使用接口的方法，也就是调用外部dll/so的函数。<br>该常量通过Native.loadLibrary()这个API函数获得，该函数有2个参数：</p>
<ul>
<li>第 一个参数是动态链接库dll/so的名称，但不带.dll或.so这样的后缀，这符合JNI的规范，因为带了后缀名就不可以跨操作系统平台了。搜索动态链 接库路径的顺序是：先从当前类的当前文件夹找，如果没有找到，再在工程当前文件夹下面找win32/win64文件夹，找到后搜索对应的dll文件，如果 找不到再到WINDOWS下面去搜索，再找不到就会抛异常了。比如上例中printf函数在Windows平台下所在的dll库名称是msvcrt，而在 其它平台如Linux下的so库名称是c。</li>
<li>第二个参数是本接口的Class类型。JNA通过这个Class类型，根据指定的.dll/.so文件，动态创建接口的实例。该实例由JNA通过反射自动生成。</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">CLibrary<span class="built_in"> INSTANCE </span>= (CLibrary)</span></pre></td></tr><tr><td class="code"><pre><span class="line">      Native.loadLibrary((Platform.isWindows() ? <span class="string">"msvcrt"</span> : <span class="string">"c"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                               CLibrary.class);</span></pre></td></tr></table></figure>

<p>接口中只需要定义你要用到的函数或者公共变量，不需要的可以不定义，如上例只定义printf函数：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">String</span> format, Object... args)</span></span>;</span></pre></td></tr></table></figure>

<p>注意参数和返回值的类型，应该和链接库中的函数类型保持一致。</p>
<h2 id="（3）调用链接库中的函数"><a href="#（3）调用链接库中的函数" class="headerlink" title="（3）调用链接库中的函数"></a>（3）调用链接库中的函数</h2><p>定义好接口后，就可以使用接口中的函数即相应dll/so中的函数了，前面说过调用方法就是通过接口中的实例进行调用，非常简单，如上例中：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">CLibrary</span>.</span><span class="module"><span class="identifier">INSTANCE</span>.</span></span>printf(<span class="string">"Hello, World\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">for (<span class="built_in">int</span> i=<span class="number">0</span>;i &lt; args.length;i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">CLibrary</span>.</span><span class="module"><span class="identifier">INSTANCE</span>.</span></span>printf(<span class="string">"Argument %d: %s\n"</span>, i, args<span class="literal">[<span class="identifier">i</span>]</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这就是JNA使用的简单例子，可能有人认为这个例子太简单了，因为使用的是系统自带的动态链接库，应该还给出一个自己实现的库函数例子。其实我觉得这个完全没有必要，这也是JNA的方便之处，不像JNI使用用户自定义库时还得定义一大堆配置信息，对于JNA来说，使用用户自定义库与使用系统自带的库是完全一样的方法，不需要额外配置什么信息。比如我在Windows下建立一个动态库程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>_declspec(dllexport) <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> a + b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后编译成一个dll文件（比如CDLL.dll），放到当前目录下，然后编写JNA程序调用即可：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public class DllTest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public<span class="built_in"> interface </span>CLibrary extends Library &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        CLibrary<span class="built_in"> INSTANCE </span>= (CLibrary)Native.loadLibrary(<span class="string">"CDLL"</span>, CLibrary.class);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        int <span class="builtin-name">add</span>(int a, int b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        int sum = CLibrary.INSTANCE.<span class="builtin-name">add</span>(3, 6);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(sum);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h1 id="4-JNA技术难点"><a href="#4-JNA技术难点" class="headerlink" title="4. JNA技术难点"></a>4. JNA技术难点</h1><p>有过跨语言、跨平台开发的程序员都知道，跨平台、语言调用的难点，就是不同语言之间数据类型不一致造成的问题。绝大部分跨平台调用的失败，都是这个问题造成的。关于这一点，不论何种语言，何种技术方案，都无法解决这个问题。JNA也不例外。<br>上面说到接口中使用的函数必须与链接库中的函数原型保持一致，这是JNA甚至所有跨平台调用的难点，因为C/C++的类型与Java的类型是不一样的，你必须转换类型让它们保持一致，比如printf函数在C中的原型为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, [argument])</span></span>;</span></pre></td></tr></table></figure>

<p>你不可能在Java中也这么写，Java中是没有char <em>指针类型的，因此const char <em>转到Java下就是String类型了。<br>这就是</em></em>类型映射（Type Mappings）**，JNA官方给出的默认类型映射表如下：<br><img src="http://image.winrains.cn/2019/08/664cb-311340592035669.png" alt="img"><br>还有很多其它的类型映射，需要的请到JNA官网查看。<br>另外，JNA还支持<code>类型映射定制，比如有的Java中可能找不到对应的类型（在Windows API中可能会有很多类型，在Java中找不到其对应的类型）</code>，JNA中TypeMapper类和相关的接口就提供了这样的功能。</p>
<h1 id="5-JNA能完全替代JNI吗？"><a href="#5-JNA能完全替代JNI吗？" class="headerlink" title="5. JNA能完全替代JNI吗？"></a>5. JNA能完全替代JNI吗？</h1><p>这可能是大家比较关心的问题，但是遗憾的是，<strong>JNA是不能完全替代JNI的</strong>，因为有些需求还是必须求助于JNI。<br>使用JNI技术，不仅可以实现Java访问C函数，也可以实现C语言调用Java代码。<br>而JNA只能实现Java访问C函数，作为一个Java框架，自然不能实现C语言调用Java代码。此时，你还是需要使用JNI技术。<br>JNI是JNA的基础，是Java和C互操作的技术基础。有时候，你必须回归到基础上来。</p>
<h1 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h1><p>（1）<a href="http://blog.csdn.net/shendl/article/details/3589676" target="_blank" rel="noopener">JNA—JNI终结者</a><br>（2）<a href="http://blog.csdn.net/xupan_jsj/article/details/9028937" target="_blank" rel="noopener">C++DLL编程详解</a></p>
<blockquote>
<p>作者：Alexia</p>
<p>来源：<a href="https://www.cnblogs.com/lanxuezaipiao/p/3635556.html" target="_blank" rel="noopener">https://www.cnblogs.com/lanxuezaipiao/p/3635556.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>JNA</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomact8部署在linux下启动很慢详解</title>
    <url>/2019/12/26/Tomact8%E9%83%A8%E7%BD%B2%E5%9C%A8linux%E4%B8%8B%E5%90%AF%E5%8A%A8%E5%BE%88%E6%85%A2%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>Tomcat 8启动很慢，且日志上无任何错误，在日志中查看到如下信息：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Log4j:[2015-10-29 15:47:11] <span class="builtin-name">INFO</span> ReadProperty:172 - Loading properties file <span class="keyword">from</span> class path<span class="built_in"> resource </span>[resources/jdbc.properties]</span></pre></td></tr><tr><td class="code"><pre><span class="line">Log4j:[2015-10-29 15:47:11] <span class="builtin-name">INFO</span> ReadProperty:172 - Loading properties file <span class="keyword">from</span> class path<span class="built_in"> resource </span>[resources/common.properties]</span></pre></td></tr><tr><td class="code"><pre><span class="line">29-Oct-2015 15:52:53.587 <span class="builtin-name">INFO</span> [localhost-startStop-1] org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom Creation of SecureRandom<span class="built_in"> instance </span><span class="keyword">for</span> session ID generation using [SHA1PRNG] took [342,445] milliseconds.</span></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>Tomcat 7/8都使用org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom类产生安全随机类SecureRandom的实例作为会话ID，这里花去了<strong>342</strong>秒，也即接近6分钟。<br>SHA1PRNG算法是基于SHA-1算法实现且保密性较强的伪随机数生成器。<br>在SHA1PRNG中，有一个种子产生器，它根据配置执行各种操作。<br>1）如果java.security.egd属性或securerandom.source属性指定的是”file:/dev/random”或”file:/dev/urandom”，那么JVM会使用本地种子产生器NativeSeedGenerator，它会调用super()方法，即调用SeedGenerator.URLSeedGenerator(/dev/random)方法进行初始化。<br>2）如果java.security.egd属性或securerandom.source属性指定的是其它已存在的URL，那么会调用SeedGenerator.URLSeedGenerator(url)方法进行初始化。<br>这就是为什么我们设置值为”file:///dev/urandom”或者值为”file:/./dev/random”都会起作用的原因。<br>在这个实现中，产生器会评估熵池（entropy pool）中的噪声数量。随机数是从熵池中进行创建的。当读操作时，/dev/random设备会只返回熵池中噪声的随机字节。/dev/random非常适合那些需要非常高质量随机性的场景，比如一次性的支付或生成密钥的场景。<br>当熵池为空时，来自/dev/random的读操作将被阻塞，直到熵池收集到足够的环境噪声数据。这么做的目的是成为一个密码安全的伪随机数发生器，熵池要有尽可能大的输出。对于生成高质量的加密密钥或者是需要长期保护的场景，一定要这么做。<br>那么什么是环境噪声？<br>随机数产生器会手机来自设备驱动器和其它源的环境噪声数据，并放入熵池中。产生器会评估熵池中的噪声数据的数量。当熵池为空时，这个噪声数据的收集是比较花时间的。这就意味着，Tomcat在生产环境中使用熵池时，会被阻塞较长的时间。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>有两种解决办法：<br>1）在Tomcat环境中解决<br>可以通过配置JRE使用非阻塞的Entropy Source。<br>在catalina.sh中加入这么一行：-Djava.security.egd=file:/dev/./urandom 即可。<br>加入后再启动Tomcat，整个启动耗时下降到Server startup in 2912 ms。<br>2）在JVM环境中解决<br>打开$JAVA_PATH/jre/lib/security/java.security这个文件，找到下面的内容：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">securerandom.<span class="keyword">source</span>=<span class="keyword">file</span>:<span class="regexp">/dev/u</span>random</span></pre></td></tr></table></figure>

<p>替换成</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">securerandom.<span class="keyword">source</span>=<span class="keyword">file</span>:<span class="regexp">/dev/</span>.<span class="regexp">/urandom</span></span></pre></td></tr></table></figure>

<blockquote>
<p>作者：God_Ming</p>
<p>来源：<a href="https://blog.csdn.net/jinzhencs/article/details/50554583" target="_blank" rel="noopener">https://blog.csdn.net/jinzhencs/article/details/50554583</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
        <category>Tomcat</category>
      </categories>
  </entry>
  <entry>
    <title>IBM服务器配置RAID</title>
    <url>/2019/12/26/IBM%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AERAID/</url>
    <content><![CDATA[<p>服务器在做系统之前都会把硬盘做一下raid，保证数据的安全和性能的提升，今天就来那一台IBM的服务器，详细的介绍一下raid的做法，这次我配置的是raide5，其他的raide也是大同小异的做法。</p>
<a id="more"></a>

<ol>
<li><ol>
<li><p>当服务器开机后，等待出现进入整列卡的提示后，按照提示进入阵列卡，我这里提示为 Ctrl+H进入raid卡选项，选择start开始配置</p>
</li>
<li><p>选择configuration wizard 选项</p>
<p><img src="http://image.winrains.cn/2019/08/2e2eb9389b504fc2e841b900e9dde71190ef6d9c.png" alt="img"></p>
</li>
<li><p>选择new configuration ，选择后会清楚现在阵列卡所有数据，如果要添加新盘到原有阵列组则选择 add configuration</p>
<p><img src="http://image.winrains.cn/2019/08/96dda144ad345982901b909700f431adcbef8425.png" alt="img"></p>
</li>
<li><p>选择yes确定</p>
<p><img src="http://image.winrains.cn/2019/08/eaf81a4c510fd9f9d575206c292dd42a2834a450.png" alt="img"></p>
</li>
<li><p>选择手动配置manual configuration</p>
<p><img src="http://image.winrains.cn/2019/08/a1ec08fa513d2697bf237d5859fbb2fb4216d8c7.png" alt="img"></p>
</li>
<li><p>选中要配置的硬盘，按add to array 从左边选到右边的driver groups中</p>
<p><img src="http://image.winrains.cn/2019/08/1ad5ad6eddc451da0d1879eebafd5266d11632cc.png" alt="img"></p>
</li>
<li><p>选择好后，点击accept dg 然后点击next</p>
<p><img src="http://image.winrains.cn/2019/08/1b4c510fd9f9d72a63a36518d82a2834359bbbeb.png" alt="img"></p>
</li>
<li><p>从左侧的arraywithfreespace中选择刚做好的diask 按add to span 添加到右边，然后点击next</p>
<p><img src="http://image.winrains.cn/2019/08/c8177f3e6709c93d01f27af2933df8dcd10054b6.png" alt="img"></p>
</li>
<li><p>virtual disk配置界面，选择好参数后，点击accept接受配置，点击next</p>
<p><img src="http://image.winrains.cn/2019/08/0df3d7ca7bcb0a4604beff3c6763f6246b60af13.png" alt="img"></p>
</li>
<li><p>点击accept接受配置，会有提示初始化清楚数据，选择yes，然后点击保存回到主界面中，在主界面中可以看到阵列状态，阵列中每个硬盘都是在线的online状态</p>
<p><img src="http://image.winrains.cn/2019/08/d833c895d143ad4b4f1231c58e025aafa40f06f2.png" alt="img"></p>
</li>
<li><p>配置好后点击exit，保存后按ctrl+alt+delete重启系统</p>
<p><img src="http://image.winrains.cn/2019/08/b151f8198618367a659e08d822738bd4b31ce5a4.png" alt="img"></p>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>作者：青城丶</p>
<p>来源：<a href="https://jingyan.baidu.com/article/da1091fb60acb0027849d6ce.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/da1091fb60acb0027849d6ce.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据存储</category>
      </categories>
      <tags>
        <tag>RAID</tag>
      </tags>
  </entry>
  <entry>
    <title>磁盘阵列详解</title>
    <url>/2019/12/26/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>RAID，独立硬盘冗余阵列（RAID, Redundant Array of Independent Disks），简称磁盘阵列。其基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。<br>根据选择的版本不同，RAID比单颗硬盘有以下一个或多个方面的好处：增强数据集成度，增强容错功能，增加处理量或容量。另外，磁盘阵列对于电脑来说，看起来就像一个单独的硬盘或逻辑存储单元。</p>
<a id="more"></a>

<h2 id="RAID基础知识"><a href="#RAID基础知识" class="headerlink" title="RAID基础知识"></a><strong>RAID基础知识</strong></h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a><strong>基本原理</strong></h3><p>RAID （ Redundant Array of Independent Disks ）即独立磁盘冗余阵列，通常简称为磁盘阵列。简单地说， RAID 是由多个独立的高性能磁盘驱动器组成的磁盘子系统，从而提供比单个磁盘更高的存储性能和数据冗余的技术。 RAID 是一类多磁盘管理技术，其向主机环境提供了成本适中、数据可靠性高的高性能存储。 SNIA 对 RAID 的定义是 ：一种磁盘阵列，部分物理存储空间用来记录保存在剩余空间上的用户数据的冗余信息。当其中某一个磁盘或访问路径发生故障时，冗余信息可用来重建用户数据。磁盘条带化虽然与 RAID 定义不符，通常还是称为 RAID （即 RAID0 ）。<br>RAID 的初衷是为大型服务器提供高端的存储功能和冗余的数据安全。在整个系统中， RAID 被看作是由两个或更多磁盘组成的存储空间，通过并发地在多个磁盘上读写数据来提高存储系统的 I/O 性能。大多数 RAID 等级具有完备的数据校验、纠正措施，从而提高系统的容错性，甚至镜像方式，大大增强系统的可靠性， Redundant 也由此而来。<br>RAID 的两个关键目标是提高数据可靠性和 I/O 性能。磁盘阵列中，数据分散在多个磁盘中，然而对于计算机系统来说，就像一个单独的磁盘。通过把相同数据同时写入到多块磁盘（典型地如镜像），或者将计算的校验数据写入阵列中来获得冗余能力，当单块磁盘出现故障时可以保证不会导致数据丢失。有些 RAID 等级允许更多地 磁盘同时发生故障，比如 RAID6 ，可以是两块磁盘同时损坏。在这样的冗余机制下，可以用新磁盘替换故障磁盘， RAID 会自动根据剩余磁盘中的数据和校验数据重建丢失的数据，保证数据一致性和完整性。数据分散保存在 RAID 中的多个不同磁盘上，并发数据读写要大大优于单个磁盘，因此可以获得更高的聚合 I/O 带宽。当然，磁盘阵列会减少全体磁盘的总可用存储空间，牺牲空间换取更高的可靠性和性能。比如， RAID1 存储空间利用率仅有 50% ， RAID5 会损失其中一个磁盘的存储容量，空间利用率为 (n-1)/n 。<br>磁盘阵列可以在部分磁盘（单块或多块，根据实现而论）损坏的情况下，仍能保证系统不中断地连续运行。在重建故障磁盘数据至新磁盘的过程中，系统可以继续正常运行，但是性能方面会有一定程度上的降低。一些磁盘阵列在添加或删除磁盘时必须停机，而有些则支持热交换 （ Hot Swapping ），允许不停机下替换磁盘驱动器。这种高端磁盘阵列主要用于要求高可能性的应用系统，系统不能停机或尽可能少的停机时间。一般来说， RAID 不可作为数据备份的替代方案，它对非磁盘故障等造成的数据丢失无能为力，比如病毒、人为破坏、意外删除等情形。此时的数据丢失是相对操作系统、文件系统、卷管理器或者应用系统来说的，对于 RAID 系统来身，数据都是完好的，没有发生丢失。所以，数据备份、灾 备等数据保护措施是非常必要的，与 RAID 相辅相成，保护数据在不同层次的安全性，防止发生数据丢失。<br>RAID 中主要有三个关键概念和技术：镜像（ Mirroring ）、数据条带（ Data Stripping ）和数据校验（ Data parity ）。镜像，将数据复制到多个磁盘，一方面可以提高可靠性，另一方面可并发从两个或多个副本读取数据来提高读性能。显而易见，镜像的写性能要稍低， 确保数据正确地写到多个磁盘需要更多的时间消耗。数据条带，将数据分片保存在多个不同的磁盘，多个数据分片共同组成一个完整数据副本，这与镜像的多个副本是不同的，它通常用于性能考虑。数据条带具有更高的并发粒度，当访问数据时，可以同时对位于不同磁盘上数据进行读写操作， 从而获得非常可观的 I/O 性能提升 。数据校验，利用冗余数据进行数据错误检测和修复，冗余数据通常采用海明码、异或操作等算法来计算获得。利用校验功能，可以很大程度上提高磁盘阵列的可靠性、鲁棒性和容错能力。不过，数据校验需要从多处读取数据并进行计算和对比，会影响系统性能。 不同等级的 RAID 采用一个或多个以上的三种技术，来获得不同的数据可靠性、可用性和 I/O 性能。至于设计何种 RAID （甚至新的等级或类型）或采用何种模式的 RAID ，需要在深入理解系统需求的前提下进行合理选择，综合评估可靠性、性能和成本来进行折中的选择。<br>RAID 思想从提出后就广泛被业界所接纳，存储工业界投入了大量的时间和财力来研究和开发相关产品。而且，随着处理器、内存、计算机接口等技术的不断发展， RAID 不断地发展和革新，在计算机存储领域得到了广泛的应用，从高端系统逐渐延伸到普通的中低端系统。 RAID 技术如此流行，源于其具有显著的特征和优势，基本可以满足大部分的数据存储需求。<br>总体说来， RAID 主要优势有如下几点：<br>(1) 大容量<br>这是 RAID 的一个显然优势，它扩大了磁盘的容量，由多个磁盘组成的 RAID 系统具有海量的存储空间。现在单个磁盘的容量就可以到 1TB 以上，这样 RAID 的存储容量就可以达到 PB 级，大多数的存储需求都可以满足。一般来说， RAID 可用容量要小于所有成员磁盘的总容量。不同等级的 RAID 算法需要一定的冗余开销，具体容量开销与采用算法相关。如果已知 RAID 算法和容量，可以计算出 RAID 的可用容量。通常， RAID 容量利用率在 50% ~ 90% 之间。<br>(2) 高性能<br>RAID 的高性能受益于数据条带化技术。单个磁盘的 I/O 性能受到接口、带宽等计算机技术的限制，性能往往很有 限，容易成为系统性能的瓶颈。通过数据条带化， RAID 将数据 I/O 分散到各个成员磁盘上，从而获得比单个磁盘成倍增长的聚合 I/O 性能。<br>(3) 可靠性<br>可用性和可靠性是 RAID 的另一个重要特征。从理论上讲，由多个磁盘组成的 RAID 系统在可靠性方面应该比单个磁盘要差。这里有个隐含假定：单个磁盘故障将导致整个 RAID 不可用。 RAID 采用镜像和数据校验等数据冗余技术，打破了这个假定。 镜像是最为原始的冗余技术，把某组磁盘驱动器上的数据完全复制到另一组磁盘驱动器上，保证总有数据副本可用。 比起镜像 50% 的冗余开销 ，数据校验要小很多，它利用校验冗余信息对数据进行校验和纠错。 RAID 冗余技术大幅提升数据可用性和可靠性，保证了若干磁盘出错时，不 会导致数据的丢失，不影响系统的连续运行。<br>(4) 可管理性<br>实际上， RAID 是一种虚拟化技术，它对多个物理磁盘驱动器虚拟成一个大容量的逻辑驱动器。对于外部主机系统来说， RAID 是一个单一的、快速可靠的大容量磁盘驱动器。这样，用户就可以在这个虚拟驱动器上来组织和存储应用系统数据。 从用户应用角度看，可使存储系统简单易用，管理也很便利。 由于 RAID 内部完成了大量的存储管理工作，管理员只需要管理单个虚拟驱动器，可以节省大量的管理工作。 RAID 可以动态增减磁盘驱动器，可自动进行数据校验和数据重建，这些都可以 大大简化管理工作。</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a><strong>关键技术</strong></h3><blockquote>
<p>镜像</p>
</blockquote>
<p>镜像是一种冗余技术，为磁盘提供保护功能，防止磁盘发生故障而造成数据丢失。对于 RAID 而言，采用镜像技术 典型地 将会同时在阵列中产生两个完全相同的数据副本，分布在两个不同的磁盘驱动器组上。镜像提供了完全的数据冗余能力，当一个数据副本失效不可用时，外部系统仍可正常访问另一副本，不会对应用系统运行和性能产生影响。而且，镜像不需要额外的计算和校验，故障修复非常快，直接复制即可。镜像技术可以从多个副本进行并发读取数据，提供更高的读 I/O 性能，但不能并行写数据，写多个副本会会导致一定的 I/O 性能降低。<br>镜像技术提供了非常高的数据安全性，其代价也是非常昂贵的，需要至少双倍的存储空间。高成本限制了镜像的广泛应用，主要应用于至关重要的数据保护，这种场合下数据丢失会造成巨大的损失。另外，镜像通过 “ 拆分 ” 能获得特定时间点的上数据快照，从而可以实现一种备份窗口几乎为零的数据备份技术。</p>
<blockquote>
<p>数据条带</p>
</blockquote>
<p>磁盘存储的性能瓶颈在于磁头寻道定位，它是一种慢速机械运动，无法与高速的 CPU 匹配。再者，单个磁盘驱动器性能存在物理极限， I/O 性能非常有限。 RAID 由多块磁盘组成，数据条带技术将数据以块的方式分布存储在多个磁盘中，从而可以对数据进行并发处理。这样写入和读取数据就可以在多个磁盘上同时进行，并发产生非常高的聚合 I/O ，有效提高了整体 I/O 性能，而且具有良好的线性扩展性。这对大容量数据尤其显著，如果不分块，数据只能按顺序存储在磁盘阵列的磁盘上，需要时再按顺序读取。而通过条带技术，可获得数倍与顺序访问的性能提升。<br>数据条带技术的分块大小选择非常关键。条带粒度可以是一个字节至几 KB 大小，分块越小，并行处理能力就越强，数据存取速度就越高，但同时就会增加块存取的随机性和块寻址时间。实际应用中，要根据数据特征和需求来选择合适的分块大小，在数据存取随机性和并发处理能力之间进行平衡，以争取尽可能高的整体性能。<br>数据条带是基于提高 I/O 性能而提出的，也就是说它只关注性能， 而对数据可靠性、可用性没有任何改善。实际上，其中任何一个数据条带损坏都会导致整个数据不可用，采用数据条带技术反而增加了数据发生丢失的概念率。</p>
<blockquote>
<p>数据校验</p>
</blockquote>
<p>镜像具有高安全性、高读性能，但冗余开销太昂贵。数据条带通过并发性来大幅提高性能，然而对数据安全性、可靠性未作考虑。数据校验是一种冗余技术，它用校验数据来提供数据的安全，可以检测数据错误，并在能力允许的前提下进行数据重构。相对镜像，数据校验大幅缩减了冗余开销，用较小的代价换取了极佳的数据完整性和可靠性。数据条带技术提供高性能，数据校验提供数据安全性， RAID 不同等级往往同时结合使用这两种技术。<br>采用数据校验时， RAID 要在写入数据同时进行校验计算，并将得到的校验数据存储在 RAID 成员磁盘中。校验数据可以集中保存在某个磁盘或分散存储在多个不同磁盘中，甚至校验数据也可以分块，不同 RAID 等级实现各不相同。当其中一部分数据出错时，就可以对剩余数据和校验数据进行反校验计算重建丢失的数据。校验技术相对于镜像技术的优势在于节省大量开销，但由于每次数据读写都要进行大量的校验运算，对计算机的运算速度要求很高，必须使用硬件 RAID 控制器。在数据重建恢复方面，检验技术比镜像技术复杂得多且慢得多。<br>海明校验码和 异或校验是两种最为常用的 数据校验算法。海明校验码是由理查德 · 海明提出的，不仅能检测错误，还能给出错误位置并自动纠正。海明校验的基本思想是：将有效信息按照某种规律分成若干组，对每一个组作奇偶测试并安排一个校验位，从而能提供多位检错信息，以定位错误点并纠正。可见海明校验实质上是一种多重奇偶校验。异或校验通过异或逻辑运算产生，将一个有效信息与一个给定的初始值进行异或运算，会得到校验信息。如果有效信息出现错误，通过校验信息与初始值的异或运算能还原正确的有效信息。</p>
<h3 id="常见RAID类型"><a href="#常见RAID类型" class="headerlink" title="常见RAID类型"></a><strong>常见RAID类型</strong></h3><blockquote>
<p>常见5种RAID类型对比，n位磁盘数量。</p>
</blockquote>
<p><strong>RAID 等级</strong><br><strong>标准 RAID 等级</strong><br>SNIA 、 Berkeley 等组织机构把 RAID0 、 RAID1 、 RAID2 、 RAID3 、 RAID4 、 RAID5 、 RAID6 七个等级定为标准的 RAID 等级，这也被业界和学术界所公认。标准等级是最基本的 RAID 配置集合，单独或综合利用数据条带、镜像和数据校验技术。标准 RAID 可以组合，即 RAID 组合等级，满足 对性能、安全性、可靠性要求更高的存储应用需求。<br><strong>JBOD</strong><br>JBOD （ Just a Bunch Of Disks ）不是标准的 RAID 等级，它通常用来表示一个没有控制软件提供协调控制的磁盘集合。 JBOD 将多个物理磁盘串联起来，提供一个巨大的逻辑磁盘。 JBOD 的数据存放机制是由第一块磁盘开始按顺序往后存储，当前磁盘存储空间用完后，再依次往后面的磁盘存储数据。 JBOD 存储性能完全等同于单块磁盘，而且也不提供数据安全保护。它只是简单提供一种扩展存储空间的机制， JBOD 可用存储容量等于所有成员磁盘的存储空间之和。目前 JBOD 常指磁盘柜，而不论其是否提供 RAID 功能。<br><strong>RAID0</strong><br>RAID0 是一种简单的、无数据校验的数据条带化技术。实际上不是一种真正的 RAID ，因为它并不提供任何形式的冗余策略。 RAID0 将所在磁盘条带化后组成大容量的存储空间，将数据分散存储在所有磁盘中，以独立访问方式实现多块磁盘的并读访问。由于可以并发执行 I/O 操作，总线带宽得到充分利用。再加上不需要进行数据校验， RAID0 的性能在所有 RAID 等级中是最高的。理论上讲，一个由 n 块磁盘组成的 RAID0 ，它的读写性能是单个磁盘性能的 n 倍，但由于总线带宽等多种因素的限制，实际的性能提升低于理论值。<br>RAID0 具有低成本、高读写性能、 100% 的高存储空间利用率等优点，但是它不提供数据冗余保护，一旦数据损坏，将无法恢复。 因此， RAID0 一般适用于对性能要求严格但对数据安全性和可靠性不高的应用，如视频、音频存储、临时数据缓存空间等。<br><strong>RAID1</strong><br>RAID1 称为镜像，它将数据完全一致地分别写到工作磁盘和镜像 磁盘，它的磁盘空间利用率为 50% 。 RAID1 在数据写入时，响应时间会有所影响，但是读数据的时候没有影响。 RAID1 提供了最佳的数据保护，一旦工作磁盘发生故障，系统自动从镜像磁盘读取数据，不会影响用户工作。<br>RAID1 与 RAID0 刚好相反，是为了增强数据安全性使两块 磁盘数据呈现完全镜像，从而达到安全性好、技术简单、管理方便。 RAID1 拥有完全容错的能力，但实现成本高。 RAID1 应用于对顺序读写性能要求高以及对数据保护极为重视的应用，如对邮件系统的数据保护。<br><strong>RAID 2、3、4</strong><br>RAID2、3、4较少实际应用，它们大多只在研究领域有实作。<br><strong>RAID5</strong><br>RAID5 应该是目前最常见的 RAID 等级，它的原理与 RAID4 相似，区别在于校验数据分布在阵列中的所有磁盘上，而没有采用专门的校验磁盘。对于数据和校验数据，它们的写操作可以同时发生在完全不同的磁盘上。因此， RAID5 不存在 RAID4 中的并发写操作时的校验盘性能瓶颈问题。另外， RAID5 还具备很好的扩展性。当阵列磁盘 数量增加时，并行操作量的能力也随之增长，可比 RAID4 支持更多的磁盘，从而拥有更高的容量以及更高的性能。<br>RAID5 的磁盘上同时存储数据和校验数据，数据块和对应的校验信息存保存在不同的磁盘上，当一个数据盘损坏时，系统可以根据同一条带的其他数据块和对应的校验数据来重建损坏的数据。与其他 RAID 等级一样，重建数据时， RAID5 的性能会受到较大的影响。<br>RAID5 兼顾存储性能、数据安全和存储成本等各方面因素，它可以理解为 RAID0 和 RAID1 的折中方案，是目前综合性能最佳的数据保护解决方案。 RAID5 基本上可以满足大部分的存储应用需求，数据中心大多采用它作为应用数据的保护方案。<br><strong>RAID6</strong><br>前面所 述的各个 RAID 等级都只能保护因单个磁盘失效而造成的数据丢失。如果两个磁盘同时发生故障，数据将无法恢复。 RAID6 引入双重校验的概念，它可以保护阵列中同时出现两个磁盘失效时，阵列仍能够继续工作，不会发生数据丢失。 RAID6 等级是在 RAID5 的基础上为了进一步增强数据保护而设计的一种 RAID 方式，它可以看作是一种扩展的 RAID5 等级。<br>RAID6 不仅要支持数据的恢复，还要支持校验数据的恢复，因此实现代价很高，控制器的设计也比其他等级更复杂、更昂贵。 RAID6 思想最常见的实现方式是采用两个独立的校验算法，假设称为 P 和 Q ，校验数据可以分别存储在两个不同的校验盘上，或者分散存储在所有成员磁盘中。当两个磁盘同时失效时，即可通过求解两元方程来重建两个磁盘上的数据。<br>RAID6 具有快速的读取性能、更高的容错能力。但是，它的成本要高于 RAID5 许多，写性能也较差，并有设计和实施非常复杂。因此， RAID6 很少得到实际应用，主要用于对数据安全等级要求非常高的场合。它一般是替代 RAID10 方案的经济性选择<br><img src="http://image.winrains.cn/2019/08/20190826173051-4e871.jpeg" alt="关于磁盘阵列，这是我见过最全面、最好的一篇文章！"><br><strong>RAID 7</strong><br>RAID 7并非公开的RAID标准，而是Storage Computer Corporation的专利硬件产品名称。<br>RAID 7的效能超越了许多其他RAID标准的实做产品，但也因为如此，在价格方面非常的高昂。<br><strong>RAID 组合等级</strong><br>标准 RAID 等级各有优势和不足。自然地，我们想到把多个 RAID 等级组合起来，实现优势互补，弥补相互的不足，从而达到在性能、数据安全性等指标上更高的 RAID 系统。目前在业界和学术研究中提到的 RAID 组合等级主要有 RAID00 、 RAID01 、 RAID10 、 RAID100 、 RAID30 、 RAID50 、 RAID53 、 RAID60 ，但实际得到较为广泛应用的只有 RAID01 和 RAID10 两个等级。当然，组合等级的实现成本一般都非常昂贵，只是在 少数特定场合应用。<br><strong>RAID10 和 RAID01</strong><br>一些文献把这两种 RAID 等级看作是等同的，本文认为是不同的。 RAID01 是先做条带化再作镜像，本质是对物理磁盘实现镜像；而 RAID10 是先做镜像再作条带化，是对虚拟磁盘实现镜像。相同的配置下，通常 RAID01 比 RAID10 具有更好的容错能力。<br>RAID01 兼备了 RAID0 和 RAID1 的优点，它先用两块磁盘建立镜像，然后再在镜像内部做条带化。 RAID01 的数据将同时写入到两个磁盘阵列中，如果其中一个阵列损坏，仍可继续工作，保证数据安全性的同时又提高了性能。 RAID01 和 RAID10 内部都含有 RAID1 模式，因此整体磁盘利用率均仅为 50% 。<br><img src="http://image.winrains.cn/2019/08/20190826173052-84a11.jpeg" alt="关于磁盘阵列，这是我见过最全面、最好的一篇文章！"><br><img src="http://image.winrains.cn/2019/08/20190826173052-ef8dd.jpeg" alt="关于磁盘阵列，这是我见过最全面、最好的一篇文章！"><br><strong>RAID 50</strong><br>RAID 5与RAID 0的组合，先作RAID 5，再作RAID 0，也就是对多组RAID 5彼此构成Stripe访问。由于RAID 50是以RAID 5为基础，而RAID 5至少需要3颗硬盘，因此要以多组RAID 5构成RAID 50，至少需要6颗硬盘。以RAID 50最小的6颗硬盘配置为例，先把6颗硬盘分为2组，每组3颗构成RAID 5，如此就得到两组RAID 5，然后再把两组RAID 5构成RAID 0。<br>RAID 50在底层的任一组或多组RAID 5中出现1颗硬盘损坏时，仍能维持运作，不过如果任一组RAID 5中出现2颗或2颗以上硬盘损毁，整组RAID 50就会失效。<br>RAID 50由于在上层把多组RAID 5构成Stripe，性能比起单纯的RAID 5高，容量利用率比RAID5要低。比如同样使用9颗硬盘，由各3颗RAID 5再组成RAID 0的RAID 50，每组RAID 5浪费一颗硬盘，利用率为(1-3/9)，RAID 5则为(1-1/9)。<br><img src="http://image.winrains.cn/2019/08/20190826173052-29ad6.jpeg" alt="关于磁盘阵列，这是我见过最全面、最好的一篇文章！"><br><strong>RAID 60</strong><br>RAID 6与RAID 0的组合：先作RAID 6，再作RAID 0。换句话说，就是对两组以上的RAID 6作Stripe访问。RAID 6至少需具备4颗硬盘，所以RAID 60的最小需求是8颗硬盘。<br>由于底层是以RAID 6组成，所以RAID 60可以容许任一组RAID 6中损毁最多2颗硬盘，而系统仍能维持运作；不过只要底层任一组RAID 6中损毁3颗硬盘，整组RAID 60就会失效，当然这种情况的概率相当低。<br>比起单纯的RAID 6，RAID 60的上层通过结合多组RAID 6构成Stripe访问，因此性能较高。不过使用门槛高，而且容量利用率低是较大的问题。<br><img src="http://image.winrains.cn/2019/08/20190826173052-7aa6d.jpeg" alt="关于磁盘阵列，这是我见过最全面、最好的一篇文章！"></p>
<h3 id="理解-RAID-2-0-和-RAID-2-0"><a href="#理解-RAID-2-0-和-RAID-2-0" class="headerlink" title="理解 RAID 2.0 和 RAID 2.0+"></a><strong>理解 RAID 2.0 和 RAID 2.0+</strong></h3><p>RAID 2.0（独立磁盘冗余数组2.0, Redundant Array of Independent Disks Version 2.0），为增强型RAID技术，有效解决了机械硬盘容量越来越大，重构一块机械硬盘所需时间越来越长，传统RAID组重构窗口越来越大而导致重构期间又故障一块硬盘而彻底丢失数据风险的问题。其基本思想就是把大容量机械硬盘先按照固定的容量切割成多个更小的分块（Chunk，通常为64MB），RAID组建立在这些小分块上，而不是某些硬盘上，我们称为分块组（Chunk Group）。此时硬盘间不再组成传统的RAID关系，而是组成更大硬盘数量的硬盘组（建议最大硬盘数量为96-120,不建议超过120块盘），每个硬盘上不同的分块可与此硬盘组上不同硬盘上的分块组成不同RAID类型的分块组，这样一个硬盘上的分块可以属于多个RAID类型的多个分块组。以这样的组织形式，基于 RAID2.0 技术的存储系统能够做到在一块硬盘故障后，在硬盘组上的所有硬盘上并发进行重构，而不再是传统 RAID 的单个热备盘上进行重构，从而大大降低重构时间，减少重构窗口扩大导致的数据丢失风险，在硬盘容量大幅增加的同时确保存储系统的性能和可靠性。RAID 2.0 并没有改变传统的各种RAID类型的算法，而是把RAID范围缩小到分块组上。<br>因此，RAID2.0技术具备以下技术特征：</p>
<ul>
<li>几个、几十个甚至上百个机械硬盘组成硬盘组；</li>
<li>硬盘组中的硬盘被分割成几十兆、上百兆的分块，不同硬盘上的分块组成的分块组 (Chunk Group)；</li>
<li>RAID 计算在分块组 (Chunk Group) 内进行，系统不再有热备盘，而是被同一分块组内保留的热备块所代替。</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190826173053-6630e.jpeg" alt="关于磁盘阵列，这是我见过最全面、最好的一篇文章！"></p>
<h4 id="基于传统RAID技术的存储阵列故障恢复机制"><a href="#基于传统RAID技术的存储阵列故障恢复机制" class="headerlink" title="基于传统RAID技术的存储阵列故障恢复机制"></a>基于传统RAID技术的存储阵列故障恢复机制</h4><p><img src="http://image.winrains.cn/2019/08/20190826173053-53021.jpeg" alt="关于磁盘阵列，这是我见过最全面、最好的一篇文章！"></p>
<h4 id="基于RAID-2-0技术的存储阵列故障恢复机制"><a href="#基于RAID-2-0技术的存储阵列故障恢复机制" class="headerlink" title="基于RAID 2.0技术的存储阵列故障恢复机制"></a>基于RAID 2.0技术的存储阵列故障恢复机制</h4><p>由于RAID 2.0系统中一块硬盘故障后，重构可以在同一硬盘组内其他所有硬盘保留的热备空间上并发进行，使用RAID 2.0技术的存储系统具备以下优势：</p>
<ul>
<li>快速重构：存储池内所有硬盘参与重构，相对于传统RAID重构速度大幅提；</li>
<li>自动负载均衡：RAID 2.0使得各硬盘均衡分担负载，不再有热点硬盘，提升了系统的性能和硬盘可靠性；</li>
<li>系统性能提升：LUN基于分块组创建，可以不受传统RAID硬盘数量的限制分布在更多的物理硬盘上，因而系统性能随硬盘IO带宽增加得以有效提升；</li>
<li>自愈合：当出现硬盘预警时，无需热备盘，无需立即更换故障盘，系统可快速重构，实现自愈合。</li>
</ul>
<p>RAID2.0+（独立磁盘冗余数组2.0, Redundant Array of Independent Disks Version 2.0+）在 RAID 2.0 的基础上提供了更细粒度 (可以达几十KB粒度) 的资源颗粒，形成存储资源的标准分配及回收单位，类似计算虚拟化中的虚拟机，我们称之为虚拟块。这些容量单位一致的虚拟块构成了一个统一的存储资源池，所有应用、中间件、虚拟机、操作系统所需的资源可以在这个资源池中按需分配及回收。相对传统 RAID 系统，RAID2.0+ 技术实现了存储资源的虚拟化及预配置，存储资源的申请及释放完全自动化的通过存储池实现，而不再需要传统 RAID 阵列的RAID组创建，LUN创建，LUN格式化等耗时而容易出错的手工配置过程。因此，RAID 2.0+ 技术解决了虚拟机环境下，存储资源必须动态按需分配及释放的问题。<br>在 RAID 2.0 基础上，RAID2.0+技术具备以下技术特征：</p>
<ul>
<li>在 RAID 2.0 基础上，分块组（Chunk Group）被切分为容量从256KB到64MB的虚拟化存储颗粒（Extent）；</li>
<li>存储资源以以上颗粒为单位自动分配及释放；</li>
<li>可以以以上颗粒度为单位在存储池内或不同存储池间进行细粒度分级存储；</li>
<li>在系统通过扩展控制器扩展性能或容量后，可以通过自动化的迁移这些标准颗粒来达到负载均衡的目的。</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190826173053-5433b.jpeg" alt="关于磁盘阵列，这是我见过最全面、最好的一篇文章！"></p>
<h4 id="基于RAID-2-0-技术的存储阵列"><a href="#基于RAID-2-0-技术的存储阵列" class="headerlink" title="基于RAID 2.0+技术的存储阵列"></a>基于RAID 2.0+技术的存储阵列</h4><p>技术优点<br>RAID2.0+技术主要用于实现系统资源的智能分配，满足虚拟机环境对存储的需求：</p>
<ul>
<li>存储资源按需自动化分配及释放，满足了虚拟机对存储最本质的需求；</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190826173053-f1218.jpeg" alt="关于磁盘阵列，这是我见过最全面、最好的一篇文章！"></p>
<h4 id="基于RAID-2-0-技术的存储容量虚拟化"><a href="#基于RAID-2-0-技术的存储容量虚拟化" class="headerlink" title="基于RAID 2.0+技术的存储容量虚拟化"></a>基于RAID 2.0+技术的存储容量虚拟化</h4><ul>
<li>可根据业务实时情况，将不同数据分级存储，通过灵活调配SSD等高性能存储资源满足高性能业务需求；</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190826173053-44fb3.jpeg" alt="关于磁盘阵列，这是我见过最全面、最好的一篇文章！"></p>
<h4 id="基于RAID-2-0-技术的实时资源调配"><a href="#基于RAID-2-0-技术的实时资源调配" class="headerlink" title="基于RAID 2.0+技术的实时资源调配"></a>基于RAID 2.0+技术的实时资源调配</h4><ul>
<li>根据业务特点自动迁移数据，提高存储利用效率；</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190826173054-c2e9f.jpeg" alt="关于磁盘阵列，这是我见过最全面、最好的一篇文章！"></p>
<h4 id="基于RAID-2-0-技术的自动数据迁移"><a href="#基于RAID-2-0-技术的自动数据迁移" class="headerlink" title="基于RAID 2.0+技术的自动数据迁移"></a>基于RAID 2.0+技术的自动数据迁移</h4><p>RAID 2.0与传统RAID的对比<br><img src="http://image.winrains.cn/2019/08/20190826173054-68008.jpeg" alt="关于磁盘阵列，这是我见过最全面、最好的一篇文章！"></p>
<h4 id="传统-RAID-和-RAID2-0-两种技术重构原理的对比"><a href="#传统-RAID-和-RAID2-0-两种技术重构原理的对比" class="headerlink" title="传统 RAID 和 RAID2.0+两种技术重构原理的对比"></a>传统 RAID 和 RAID2.0+两种技术重构原理的对比</h4><p><img src="http://image.winrains.cn/2019/08/20190826173054-64e0d.jpeg" alt="关于磁盘阵列，这是我见过最全面、最好的一篇文章！"><br>传统 RAID 和 RAID2.0+两种技术重构性能的对比</p>
<h2 id="不适合使用RAID的场景"><a href="#不适合使用RAID的场景" class="headerlink" title="不适合使用RAID的场景"></a><strong>不适合使用RAID的场景</strong></h2><p>Hadoop集群中为何不使用RAID？<br>尽管建议采用RAID (Redundant Array of Independent Disk,即磁盘阵列) 作为 namenode 的存储器以保护元数据，但是若将 RAID 作为 datanode 的存储设备则不会给 HDFS 带来益处。HDFS 所提供的节点间数据复制技术已可满足数据备份需求，无需使用 RAID 的冗余机制。<br>此外，尽管 RAID 条带化技术 (RAID 0) 被广泛用户提升性能，但是其速度仍然比用在 HDFS 里的 JBOD (Just a Bunch Of Disks) 配置慢。JBOD 在所有磁盘之间循环调度 HDFS 块。RAID 0 的读写操作受限于磁盘阵列中最慢盘片的速度，而 JBOD 的磁盘操作均独立，因而平均读写速度高于最慢盘片的读写速度。需要强调的是，各个磁盘的性能在实际使用中总存在相当大的差异，即使对于相同型号的磁盘。针对某一雅虎集群的评测报告(<a href="http://markmail.org/message/xmzc45zi25htr7ry)表明，在一个测试(Gridmix)中，JBOD" target="_blank" rel="noopener">http://markmail.org/message/xmzc45zi25htr7ry)表明，在一个测试(Gridmix)中，JBOD</a> 比 RAID 0 快10%；在另一测试(HDFS写吞吐量)中，JBOD 比 RAID 0 快30%。<br>最后，若 JBOD 配置的某一磁盘出现故障，HDFS 可以忽略该磁盘，继续工作。而 RAID 的某一盘片故障会导致整个磁盘阵列不可用，进而使相应节点失效。</p>
<blockquote>
<p>作者：重庆图牛DIY电脑</p>
<p>来源：<a href="https://www.toutiao.com/a6538639859211305486/" target="_blank" rel="noopener">https://www.toutiao.com/a6538639859211305486/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据存储</category>
      </categories>
      <tags>
        <tag>RAID</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令行下!的十个神奇用法</title>
    <url>/2019/12/26/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E6%84%9F%E5%8F%B9%E5%8F%B7%E7%9A%84%E5%8D%81%E4%B8%AA%E7%A5%9E%E5%A5%87%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>Linux 系统中，“!” 符号或者操作符通常被用做逻辑否定的操作符，同时也通过一些调整和改动命令来从历史记录中找出你需要的命令行。下面演示的命令行在bash Shell中都已经明确检查过可用了。不过我没有在其他的 Shell 解释器下测试过，不过我相信这些命令也不会在其他的解释器下运行。那么现在就让我们学习一下 “!” 这神奇而独特的用法吧！</p>
<a id="more"></a>

<h2 id="1-从历史记录中使用命令号来运行命令"><a href="#1-从历史记录中使用命令号来运行命令" class="headerlink" title="1.从历史记录中使用命令号来运行命令"></a>1.从历史记录中使用命令号来运行命令</h2><p>你也许从没意识到过可以从命令行历史记录(之前执行过的命令)里执行一条命令，首先输入 “history” 命令得到命令的序号。<br><img src="http://image.winrains.cn/2019/08/c8ef8-150520165049233.png" alt="img"><br><img src="http://image.winrains.cn/2019/08/cc7d2-150520165049231.gif" alt="img"><br>这时你可以通过命令 history 的输出中的命令序号来执行一条命令。<br><img src="http://image.winrains.cn/2019/08/c7f20-150520165049237.png" alt="img"><br><img src="http://image.winrains.cn/2019/08/37d88-150520165049236.gif" alt="img"><br>上面可以看到它执行了号码为1551的 top 命令，这种执行方式对执行某些特别长的命令非常有用，你只要使用”!”符号加上命令的序号就能执行该命令啦。</p>
<h2 id="2-执行指定的之前执行过的命令"><a href="#2-执行指定的之前执行过的命令" class="headerlink" title="2.执行指定的之前执行过的命令"></a>2.执行指定的之前执行过的命令</h2><p>你可以运行 !-1、!-2 或者 !-7 等命令来执行你记录序列中的倒数第一条命令、倒数第二条命令已经倒数第七条等等。。。和上面的方式一样，你需要先用 history 命令来列出命令列表。其实这个命令非常有用，你可以通过它来确定没有执行过某些错误命令比如 “rm command &gt;file” 或者别的危险指令。这里给出了执行倒数第六个、第八个和第十个命令的效果。<br><img src="http://image.winrains.cn/2019/08/c2d1e-150520165049239.png" alt="img"><br><img src="http://image.winrains.cn/2019/08/d5a74-150520165049238.gif" alt="img"></p>
<h2 id="3-向一条新命令传递旧命令的参数避免重复输入"><a href="#3-向一条新命令传递旧命令的参数避免重复输入" class="headerlink" title="3.向一条新命令传递旧命令的参数避免重复输入"></a>3.向一条新命令传递旧命令的参数避免重复输入</h2><p>比如说我需要列出 ‘/home/$USER/Binary/firefox’ 这个目录。<br><img src="http://image.winrains.cn/2019/08/7a116-1505201650492312.png" alt="img"><br>但是这个时候我又想用 “ls-l“查看这个目录下的具体信息，那么我需要重新输入上面的命令吗？当然不需要，你只要用下面这个命令：<br><img src="http://image.winrains.cn/2019/08/992e7-1505201650492314.png" alt="img"><br>“!$” 符号可以将上一条命令的参数传递给下一条命令参数：<br><img src="http://image.winrains.cn/2019/08/c7454-1505201650492310.gif" alt="img"></p>
<h2 id="4-如何用-处理两个以上的参数-例如我在桌面上创建了一个-1-txt-文件"><a href="#4-如何用-处理两个以上的参数-例如我在桌面上创建了一个-1-txt-文件" class="headerlink" title="4.如何用(!)处理两个以上的参数?例如我在桌面上创建了一个 1.txt 文件"></a>4.如何用(!)处理两个以上的参数?例如我在桌面上创建了一个 1.txt 文件</h2><p><img src="http://image.winrains.cn/2019/08/d7a18-1505201650492315.png" alt="img"><br>然后使用CP命令把它复制到 ‘home/avi/Downloads’ 目录<br><img src="http://image.winrains.cn/2019/08/a981c-1505201650492316.png" alt="img"><br>这样我们就向CP命令传递了两个参数。第一个是 ‘/home/avi/Desktop/1.txt’ ，第二个是’/home/avi/Downloads’，为了区分它们，我们 使用 echo 来打印每个参数。<br><img src="http://image.winrains.cn/2019/08/9b921-150520165049232.png" alt="img"><br>可以注意到第一个参数可以使用 “!^” 来表示，剩下的参数就可以使用 “命令名：参数序号”这种方式来表示，比如 “!cp:2″。再举个例子，如果你执行的某个命令为 “xyz”，命令 后面有5个参数而你想调用第四个参数，就可以使用 “!xyz:4″ 来调用它。当然，你可以使用 “!* “ 来表示所有参数。<br><img src="http://image.winrains.cn/2019/08/ae72d-1505201650492311.gif" alt="img"></p>
<h2 id="5-通过关键词来执行之前的命令"><a href="#5-通过关键词来执行之前的命令" class="headerlink" title="5.通过关键词来执行之前的命令"></a>5.通过关键词来执行之前的命令</h2><p>我们可以通过执行关键词来执行之前的命令。可以按照下面的命令来理解：<br><img src="http://image.winrains.cn/2019/08/6ef4f-150520165049234.png" alt="img"><br>上面是相同的ls命令对应了不同参数和文件夹。此外我们将每一个标准输出都传递到了 ‘/dev/null’ 因为我们并不希望处理程序的标准输出。现在我们可以调用命令的关键词来实现它们。<br><img src="http://image.winrains.cn/2019/08/88d5e-150520165049235.png" alt="img"><br>当你使用 “ls” 关键词来执行之前命令的时候，你一定会被标准输出给惊讶到。<br><img src="http://image.winrains.cn/2019/08/95bc1-1505201650492313.gif" alt="img"></p>
<blockquote>
<p>作者：Here or There</p>
<p>来源：<a href="https://www.linuxidc.com/Linux/2015-05/117774.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2015-05/117774.htm</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux技术</category>
      </categories>
  </entry>
  <entry>
    <title>集中式架构与分布式架构比较</title>
    <url>/2019/12/26/%E9%9B%86%E4%B8%AD%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h2 id="应用现状比较"><a href="#应用现状比较" class="headerlink" title="应用现状比较"></a>应用现状比较</h2><p>由于历史原因，集中式架构多用于传统银行、电信等行业。主机资源集中在大型主机或小型机上。集中式架构下，包括操作系统，中间件，数据库等“基础软件” 均为闭源商用系统。集中式架构的典型案例是 IOE（IBM， Oracle，EMC）提供的计算设备、数据库技术和存储设备共同组成的系统。<br>近年来，分布式架构在 Google、 Amazon、Facebook、阿里巴巴、腾讯等互联网公司广泛应用基础上、也越来越多被金融行业关注和应用。分布式架构一般采用性价比更高的 PC 服务器、分布式数据库和大量 PC 内存闪存，程序同时运行在众多 PC 服务器上。</p>
<a id="more"></a>

<p><img src="http://image.winrains.cn/2019/08/20190826174003-3e411.png" alt="img"></p>
<h2 id="核心对比"><a href="#核心对比" class="headerlink" title="核心对比"></a>核心对比</h2><p>以下是两种架构的核心要素的对比分析：<br><img src="http://image.winrains.cn/2019/08/20190826174006-aca3f.png" alt="img"></p>
<h2 id="业务支撑能力"><a href="#业务支撑能力" class="headerlink" title="业务支撑能力"></a>业务支撑能力</h2><p>客观讲，分布式架构在价格成本、自主研发、灵活兼容、伸缩扩展方面有比较显著的优势。互联网行业具有请求量大，数据量大的特点，业务上又可能在集中的时间段出现高于日常流量数倍的业务高峰，这些特征对架构的可扩展性提出了极高的要求。<br>在集中式架构下，为了应对更高的性能，更大的数据量，往往只能向上升级到更高配置的机器，如升级更强的 CPU，升级多核，升级内存，升级存储等，一般这种方式被称为 Scale Up，但单机的性能永远都有瓶颈,随着业务量的增长，只能通过 Scale Out 的方式来支持，即横向扩展出同样架构的服务器。在集中式架构下，由于单个服务器的造价昂贵，所以 Scale Out 的方式成本非常高，无法做到按需扩展。而分布式架构的解决方案是基于廉价的 PC Server 来做 Scale Out, 借助高速网络组建的 PC 集群在整体上提供的计算能力已大幅高于传统主机，并且成本很低，横向的扩展性还可带来系统良好的成长性。<br>蚂蚁金服通过几年架构演进，已经从初级的服务器可扩展、数据层可扩展发展到 IDC 层面的可扩展。一旦采用了分布式架构，天然支持按需扩展，唯一的要求是在设计上保持每个应用节点不保存状态信息。随着业务量从几百笔/秒到几万笔/秒级别时，需要更多的服务器来支撑，数据库单表的性能会成为瓶颈。数据量也会从 GB 迅速飙升到 TB、PB，单数据库实例的容量也会成为瓶颈。数据层会采用分库分表的策略来支持业务量的增长,具体策略根据业务场景可分为垂直拆分（按业务）、水平拆分（按请求/用户做哈希，或者做区间拆分）、读写拆分等。最后会通过统一分布式数据访问组件来屏蔽数据扩展的复杂性。下图简单描绘了服务器扩展性（应用层）和数据层可扩展（持久层）的形态：<br><img src="http://image.winrains.cn/2019/08/20190826174007-41475.png" alt="img"><br>随着业务的发展，应用和数据层弹性伸缩也会受限于到单个机房的电力、面积、散热等物理条件的制约而无法 Scale Out，同城的机房个数也是有限的，所以势必要从机房层面支持弹性的可伸缩。蚂蚁的业务规模早在两年前就已突破这个规模， 因此进行了机房单元化改造，其架构核心思想是把数据水平拆分的思路向上提升到接入层、终端层。从接入层开始，把原来部署在一个 IDC 中的系统集群，进一步分成多个更细粒度的部署单元，从而达到机房级别的扩展。这种机房架构在容灾方面的优势会在第五个小节中展开说明。下面为这种架构的示意图：<br><img src="http://image.winrains.cn/2019/08/20190826174010-98c7f.png" alt="img"><br>下表总结了两种架构模式在业务支撑的几个方面的比较：<br><img src="http://image.winrains.cn/2019/08/20190826174011-35bc0.png" alt="img"></p>
<h2 id="两种架构的可用性和一致性比较"><a href="#两种架构的可用性和一致性比较" class="headerlink" title="两种架构的可用性和一致性比较"></a>两种架构的可用性和一致性比较</h2><p>从架构设计来看，集中式系统的计算、存储都在一套硬件体系内，无需面对网络分区（网络无法连接）问题，能很容易实现高一致性，并通过存储的冗余和软硬件结合的高度优化，达到了较高的可靠性。但在可用性方面，由于集中式架构在设计上是一个单点，单机不可用即全部不可用，所以集中式的系统只能在停机维护时暂停业务，这一点在很多互联网场景下是难以接受的。分布式架构设计，天然就有多个节点，很容易通过主备（HA）、冗余、哈希等手段实现计算和存储冗余备份，从而实现高可用。<br>当然，软件领域没有银弹，分布式架构多个节点的设计也带来了保持一致性和高可靠性上的巨大挑战。2000 年，加州大学伯克利分校计算机教授 Eric Brewer 提出了著名的 CAP 理论，任何基于网络的数据共享系统（即分布式系统）最多只能满足数据一致性（Consistency）、可用性（Availability）和网络分区容忍（Partition Tolerance）三个特性中的两个。在大规模的分布式环境下，网络故障是常态，所以网络分区是必须容忍的现实，只能在可用性和一致性两者间做出选择，即 CP 模型或者 AP 模型，实际的选择需要通过业务场景来权衡。<br>对于一些离线的应用，或者对可用率不敏感的业务，可以适当牺牲可用性来保证强一致，即采用 CP 模型，这样会大大简化设计，系统具备不可用的发现和恢复机制就能让系统保持正常的运转，纯粹的 CP 模型还是比较简单，但适用场景也非常有限，真正复杂的还是 AP 模型。<br>在金融行业中，尤其是互联网金融系统，保证提供连续可靠的服务尤为重要，长时间的业务中断会引发各种社会问题，影响到生活的方方面面，所以，必须考虑如何在采用 AP 模型的时候尽可能保证一致性（Consistency）。关于一致性，不是只有 0 或者 1，是可以有程度的细分，一般可分为强一致性、弱一致性和最终一致性。达成什么程度的一致性，可以从客户端和服务端两个视角来分析。从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。在支付宝系统中，为保证性能，业务数据被垂直和水平拆分到多个数据源中，一次典型的转账操作，会在借贷双方的数据库中分别进行存入和扣除操作，蚂蚁技术团队借鉴了BASE理论（Basically Available, Soft State, Eventual Consistency 基本可用、软状态、最终一致性），设计了基于 TCC（Try Confirm Cancel）模型的两阶段的柔性事务框架，在保证单机事务的 ACID 原则的前提下，确保全局分布式事务的最终一致性，在保证用户体验（性能）的前提下，让客户感受到了一致性，并向用户屏蔽了短暂不一致（故障或者延迟）的恢复细节，满足了业务上对一致性的要求。以下为分布式事务框架的模型示意图：<br><img src="http://image.winrains.cn/2019/08/20190826174013-bce27.png" alt="img"><br>图 4 柔性事务框架原理图<br>为了保证高可用和业务连续性，分布式系统的存储往往会设计成多份冗余，并尽可能在机架、机房甚至城市维度将冗余的数据分散在多处。所以从服务端角度看，最关心一致性问题是如何尽快将更新后的数据分布到整个系统，降低达到最终一致性的时间窗口。Paxos 协议就是一种在保证强一致性前提下把可用性优化到极限的算法。蚂蚁金服自主研发设计的 OceanBase 数据库就将数据存在多份存储上，每个存储都分布在不同机房，任何一份存储出问题，都不影响全局的可用性。为保证这种高可用架构下的一致性， OceanBase 在多份存储的写入过程中，就用到了 Paxos 协议，并针对各种具体场景，对协议做了优化和改进。详细的设计和说明可参考 OB 的资料。<br>下表列出了两种架构的具体案例和相关的技术产品，支付宝的架构体系也经历了从集中式到分布式的演进。<br><img src="http://image.winrains.cn/2019/08/20190826174015-985c9.png" alt="img"></p>
<h2 id="两种架构的运维复杂度和故障恢复能力比较"><a href="#两种架构的运维复杂度和故障恢复能力比较" class="headerlink" title="两种架构的运维复杂度和故障恢复能力比较"></a>两种架构的运维复杂度和故障恢复能力比较</h2><p>集中式架构部署结构简单，设备数量少，在运维复杂度上较分布式架构有天然的优势。分布式架构随着机器数量的线性增长，复杂性也随之增长，无法通过简单的工具和脚本来支撑。这个复杂度包含了发布部署、系统监控和故障恢复等几个方面，下面会逐一对比。<br>集中式的发布部署一般只需应对百台内规模的代码/配置更新，通过简单的脚本或者平台就可以自动化完成，发布时间一般也能控制在小时级别。而且采用集中式架构的系统一般比较稳定，发布周期也不会太频繁。在分布式环境下，千台甚至万台服务器的规模很常见，如果按照传统的串行操作和自动化脚本，整个发布周期会非常长，一旦出现问题，回滚也会非常慢。在分布式架构下，往往需要提供 P2P 分发或类似的技术手段来加速发布过程，同时通过 beta 发布、分组发布、蓝绿发布等手段来解决大规模集群下的发布验证、灰度引流和快速回滚等问题。蚂蚁金服在发展过程中，整个运维体系也随着业务规模的增长而升级演进，逐步形成了一套完整的运维管控平台，支持单人运维千台服务器，避免了分布式架构下运维复杂度的增长。<br>在系统监控方面，集中式架构比较简单。而在分布式环境下做监控，主要挑战在于海量日志的实时分析和秒级展示。系统运行的状态分散在上万台规模的集群中，每时每刻都在产生新的状态。监控系统需要通过日志或者消息的方式采集整个集群的数据做各种统计分析。在巨大的业务量下，每晚一秒钟发现问题就会带来大量的业务异常，在极端情况下还会产生不可估量的损失。因此，也需要监控体系具备秒级的实时计算能力。蚂蚁金服也逐步沉淀这样一套监控平台，很好的弥补了分布式环境下监控的劣势，是整个平台稳定运行的基石。<br>在系统的容灾机制和故障恢复方面，集中式架构一般会采用主备复制和主备切换的方式来实现，几种典型设计原则包括一主多备，同城双活，两地三中心等。集中式的容灾方案比较成熟，也沉淀了数据复制、镜像快照、一体化迁移等一系列容灾相关的技术，可以从容应对各种场景，但仍然在以下几个方面存在不足：</p>
<ul>
<li>成本较高：在集中式架构下，经典的灾备方案一般会做全量备份，在一些改进方案中会通过余量空间做交叉互备等方式来降低成本，但整体上看还成本还是较高。为 1% 甚至概率更低的灾难场景，而付出与支撑当前业务量相等的成本，这对需要承载海量业务的互联网业务来说更是一个巨大的负担；</li>
<li>恢复时间较长：灾备方案中大量用到数据复制技术，但由于网络带宽或者异地延迟等问题，在恢复时，需要等待数据完全一致后才能切换，而且无论备份数据是冷备还是热备，切换都有一个预热的过程。综合切换复杂度和上述的技术限制等因素，很难缩短恢复时间。</li>
<li>业务影响面较大：由于集中式架构本身扩展性的不足，所有业务都跑在一个单点上，一旦发生故障就可能影响到所有用户。在承载海量业务的系统上，这种影响更容易被放大，尤其在金融系统上，更有可能引发一些社会事件。</li>
</ul>
<p>虽然在运维和监控复杂度方面在分布式系统需要通过技术手段来弥补天然的不足，但在容灾恢复方面却有着天然的优势。数据天然分布在不同的存储、机房和城市，而且架构上容易按合适的容量进行水平拆分。随着这几年互联网的高速发展，各家互联网公司都遇到了集中式架构下灾备方案的几个痛点，并进行了类似的架构改造，一般业界称之为单元化改造，其本质是将分布式下可扩展的特性运用到灾备场景，这个在第四章节中有提到。这种架构能将业务影响面控制在一定的范围内（取决于单元的大小），并通过交叉互备降低灾备成本，这种机房架构下的逻辑单元具备以下三个特征：<br>\1. 每个单元在业务处理能力上自包含，对外承载一定业务分片的业务流量，内部的系统调用链路和各类存储访问是局部化在本单元内的；<br>\2. 每个单元的实时数据是独立不共享的，配置类数据或读多写少且对延时性要求不高的数据全局共享；<br>\3. 单元间的通信统一管控，尽量以异步化消息进行通信，同步调用则通过单元间代理方案实现，实现网络上的收敛，便于监控和管控。<br>该架构解决了以下四个关键问题：<br>\1. 由于尽量减少了跨单元交互和使用异步化，使得异地部署成为可能。整个系统的水平可伸缩性大大提高，不再依赖同城 IDC ，真正实现异地多活架构；<br>\2. 可以实现 N+1 的异地灾备策略，大大缩减灾备成本，同时确保灾备设施真实可用；<br>\3. 整个系统已无单点存在，大大提升了整体的高可用性；同城和异地部署的多个单元可用作互备的容灾设施，通过运维管控平台进行快速切换，有机会实现 100% 的持续可用率；<br>\4. 该架构下业务级别的流量入口和出口形成了统一的可管控、可路由的控制点，整体系统的可管控能力得到很大提升。基于该架构，线上压测、流量管控、灰度发布等以前难以实现的运维管控模式，现在能够十分轻松地实现。<br>下图为该架构的示意图，表格中则总结了两种架构在运维和容灾方面的对比。</p>
<p><img src="http://image.winrains.cn/2019/08/20190826174016-341ee.png" alt="img"><br>图 5 单元化架构灾备切换示意图<br><img src="http://image.winrains.cn/2019/08/20190826174019-33f86.png" alt="img"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过上述对集中式和分布式架构在业务支撑、一致性/可用性、运维成本/故障恢复三个方面的分析发现，分布式架构在经济性、安全自主、灵活性、可伸缩性等方面有明显优势，随着金融系统需要处理的交易量与数据量越来越大，分布式架构在这方面的优势也会越来越明显。集中式系统在可维护性、一致性方面有优势，而分布式系统需要达到同等或更高的可维护性与高一致性，需要通过先进的分布式中间件与大规模运维平台来支持。蚂蚁金服的通过自身的实践，证明分布式系统是能够实现金融业务所需要的高一致性与可维护性的，并且将这种技术沉淀到了蚂蚁金融云计算平台上，支撑合作伙伴更好地运用分布式架构和云计算的能力，共同用新技术的力量推进普惠金融的发展。</p>
<blockquote>
<p>作者：chenshiying007</p>
<p>来源：<a href="https://blog.csdn.net/qq_27384769/article/details/80223473" target="_blank" rel="noopener">https://blog.csdn.net/qq_27384769/article/details/80223473</a></p>
</blockquote>
]]></content>
      <categories>
        <category>系统架构</category>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式系统数据层设计模式</title>
    <url>/2019/12/26/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>2013 年 5 月，支付宝最后一台小型机下线，去 “IOE” 取得里程碑进展。支付宝（以及后来的蚂蚁金服）走的是一条跟传统金融行业不同的分布式架构之路。要基于普通硬件资源实现金融级的性能和可靠性，有不少难题要解决。应用层是无状态的，借助 SOA 架构还可以比较方便地扩展。而数据层就没那么简单了，蚂蚁金服在探索的过程中，积累了一些有用的数据层架构设计经验，还是非常模式化的，可以分享出来供参考。<br>传统银行使用的高端硬件资源和商业数据库，单机的性能和稳定性肯定占有绝对的优势。互联网分布式架构，则需要从架构设计上做文章，提高系统整体的并发处理能力和容灾能力，其中容灾能力又主要有两个指标：<br>RTO，Recovery Time Objective，恢复时间目标。表示能容忍的从故障发生到系统恢复正常运转的时间，这个时间越短，容灾要求越高。<br>RPO，Recovery Point Objective，数据恢复点目标。表示能容忍故障造成过去多长时间的数据丢失，RPO 为 0 表示不允许数据丢失。</p>
<a id="more"></a>

<p>分布式领域 CAP 理论告诉我们，一致性、可用性、分区容忍性三者无法同时满足。我们不要奢望寻找能解决所有问题的万能方案，而应该根据不同的场景作出取舍。虽然业务场景五花八门，但是根据实际经验，往往可以归到有限的几种模式中，处理策略也是相对固定的。<br>我们抽象一个简化的支付系统模型来帮助理解，为了叙述方便，不一定跟支付宝的实际业务情况完全一致。它采用 SOA 架构，主要划分了交易、账务、用户、运营支撑这几个子系统，各自有各自的数据库。另外还有一个全局的配置库，存放一些会被各处用到的配置数据。<br><img src="http://image.winrains.cn/2019/08/8ac1e-28.png" alt="image"><br>这几个子系统涵盖了几种常见的模式，先简要介绍它们的主要业务：<br>账务：金融/支付系统中最核心的业务，简化后姑且认为只保存每个账户的余额，主要操作是增减余额。它的特点是要求数据强一致，每一次对余额的增减必须基于一个绝对正确的当前值，否则就会造成资损。<br>交易：负责记录每笔交易的状态和上下文。在电商系统中，它可能是商品订单；在银行系统中可能是转账流水。交易类的数据有生命周期，可能有创建、付款、发货、确认收货、退款等状态变迁。这些都不重要，重要的是它的业务特点：每一笔交易的创建是独立的，不需要依赖其他交易的数据；推进一笔交易状态的时候，要求这条数据是强一致的，但跟其他交易数据无关。<br>用户：维护用户的用户名、密码、邮箱、手机等非账务信息，提供注册、登录、查询业务。在执行核心业务的时候，有多处需要读用户的基本信息，关键业务链路对其有读强依赖。<br>运营支撑：供内部工作人员用的后台系统，包括但不限于工作流、客服等功能。<br>配置数据：这里是个宽泛的说法，笼统地表示各类变更不频繁，但是在主业务流程中需要频繁读取的数据，例如交易类目、机构代码、汇率。它们实际可能是散在各个业务系统中的，为了方便描述，单独用一个配置数据库来表示。<br>把数据库按业务模块进行拆分，是典型的垂直扩展思路，突破了单库的能力限制，使得系统可以支撑更多的业务量。当然这也引入了分布式事务的问题，另有专题介绍暂且不表。拆分开后，就方便不同的业务采取不同的架构设计了。</p>
<h1 id="账务系统"><a href="#账务系统" class="headerlink" title="账务系统"></a>账务系统</h1><p>与垂直拆分对应的，自然就是水平拆分。分库分表已经是一种非常成熟的数据水平拆分方法。例如可以将账号对 10 取模，将数据分散到 10 个逻辑分表中。这 10 个分表又映射到 10 个物理数据库。分库分表中间件可以屏蔽掉底层部署结构和路由逻辑，应用层仍然像使用普通单库一样写 SQL。<br><img src="http://image.winrains.cn/2019/08/7d2de-29.png" alt="image"><br>拆分开后，“有数据库出故障”的概率其实是大大增加的。假设其中一个账务库故障了，就意味着有至少 10% 的核心业务受影响了，实际还不止，因为一笔交易涉及双方账号。这种情况怎么办，立即切换到备库？不行的，前面说过账务要求数据强一致，即 RPO=0。数据库的主备复制一般有延时，不能保证数据无丢失。即使用 Oracle+ 共享存储的方式保证不丢数据，回放 Redo Log、检查数据一致性、切换备库，通常要花费数十分钟，足够用户在社交网络炸锅的了。怎么办？早期其实没什么好办法，情愿牺牲一些 RTO，也要保证 RPO。当然可以做一些体验上的优化，例如界面展示余额时，可以使用只读备库，减少用户恐慌，但不允许基于此余额做实际业务，聊胜于无吧。<br>后来逐渐探索出了一套账务容灾方案，需要业务层参与，还挺复杂的。这个话题足够单独成文，本文先不详细介绍，只说一下基本思路：主备库数据不一致无法避免，但可以想办法锁定有哪些账号的数据是最近刚刚在主库有过变更的，我们没法确定这个变更是否已经同步到备库了，就把这些账户全部加入黑名单，数据库恢复前不允许他们再做业务，避免发生资损。可以采取一些手段，让黑名单范围尽量小，并且确保黑名单以外的账户一定是主备库一致的，实践中可以缩小到几十几百个账户。这样，不可用范围就从库粒度一下子降到账号粒度，不在黑名单中的账户，就可以基于备库余额正常开展业务。<br>这套基于黑名单的容灾方案一直运行了好几年，效果还不错，缺点就是比较复杂，这是账务类业务本身的特点决定的。直到自研数据库 OceanBase 的诞生，情况有了改观。OceanBase 是基于 Paxos 协议的分布式强一致数据库，对于单节点故障，它提供 RPO=0，RTO&lt;30 秒的容灾能力，致力于从数据库层屏蔽容灾细节，为应用层提供简单的使用方式。</p>
<h1 id="交易系统"><a href="#交易系统" class="headerlink" title="交易系统"></a>交易系统</h1><p>交易数据也是非常适合水平拆分的，可以将交易单据号取模，做分库分表。除此之外，根据交易类业务的特点，还有更有意思的玩法。除了正常的交易主库之外，另外再准备一组表结构完全相同的空库，称为 Failover 库（注意不是备库，跟主库没有数据同步关系）。交易系统在创建一笔交易的时候，首先要生成交易单据号，其中有一位叫做弹性位，正常情况下它的值是 1，代表这笔数据应该写入主库。后续根据交易单据号读写该条数据的时候，一看弹性位是 1，就知道到主库找这条数据。<br><img src="http://image.winrains.cn/2019/08/90f35-30.png" alt="image"><br>假设 3 号主库突然故障了，这时就需要自动或手动给交易系统推送一个指令，告诉它以后第 3 分片的新数据应该插入 Failover 库。以后生成的第 3 分片的交易单据号，弹性位就是 2，代表 Failover 库，后续读写这条数据，也可以根据这一位自动找到 Failover 库。这时候主库的存量数据是无法修改的，已创建未付款的交易，用户可以放弃，重新创建一笔，就会落到 Failover 库正常处理。已经付款的交易，就暂时不能做发货、确认收货等状态推进了，但这不是关键业务，迟一点做也问题不大。当主备库数据一致性检查通过，主备切换完成，落在主库的老数据又可以继续处理了。这时再推送指令给交易系统：3 号库恢复正常状态，以后新数据落主库。Failover 机制让主业务（创建交易、付款）在很短的时间内恢复可用，放弃非关键业务（存量数据的状态推进），为主备切换争取了时间。分库分表、Failover 的逻辑，都可以由数据访问层封装，业务层并不用感知。<br>这期间在 Failover 3 号库创建的、弹性位为 2 的数据怎么处理？答案是不用特殊处理，根据弹性位 2，以后仍然可以在 Failover 库访问到这条数据，经过一段时间后，主库、弹性库的数据最终都会迁移到历史库去。Failover 库主要用于临时接管主库的新增数据，只要保持表结构一致即可，容量可以低于主库。当然弹性位也可以启用 3、4、5 更多编号，来灵活切换更多存储，这也是“弹性”的含义所在。</p>
<h1 id="配置数据"><a href="#配置数据" class="headerlink" title="配置数据"></a>配置数据</h1><p>配置数据很好理解，读多写少，读可靠性要求高，非常适合采用读写分离方案。根据具体业务，可以采用读从库、分布式缓存、内存缓存等方式。</p>
<h1 id="用户系统"><a href="#用户系统" class="headerlink" title="用户系统"></a>用户系统</h1><p>用户数据跟账务数据有紧密的对应关系，直观地想，也应该跟账务数据采用同样的处理策略，甚至合并到账务库中。这的确也是可行的，但在实践中，我们根据它的业务特性，采取的却是跟配置数据类似的处理策略，没有做水平拆分，而是做全量复制、读写分离。理由有如下这些： 用户数据更新较少，写操作不在关键路径，读操作在关键路径，跟配置数据的特性非常相似 对数据一致性要求没那么高，可以接受少量延迟同步，没有必要用账务数据那么强的一致性保障，账户余额不可信时，希望至少不影响登录 不全是按账号精确查找，可能有邮箱、手机号等维度的查询，按账号水平拆分后，难以路由<br>所以用户系统实际采用的方案是：一个写库，全量异步复制到多个读库，再加上分布式缓存。如果写库故障，则不能注册新用户、更新个人信息；个别读库故障，不影响业务。</p>
<h1 id="运营支撑系统"><a href="#运营支撑系统" class="headerlink" title="运营支撑系统"></a>运营支撑系统</h1><p>这里用运营支撑系统举例子，实际上是想代表这么一类业务数据：读写比差不多，业务流程依赖写操作，也不适合做水平拆分。这种称之为全局状态型数据。全局状态型数据一般是辅助型的非关键业务，一旦数据库故障，“要么等，要么忍”——牺牲 RTO 等待数据库主备切换，或者牺牲 RPO 立即强切备库。在做架构设计时，需要尽量避免关键业务强依赖全局状态型数据。如果真的有关键业务是全局状态型的，只能依靠 OceanBase 这样的多副本强一致数据库产品了。<br>归纳一下，业务数据主要可以归为三大类：<br>状态型：读写比相当，必须保证可写才有意义，每一次写操作必须基于前一个正确的状态。这是最棘手的一种数据，难以完美兼顾 PTO 和 RPO 。关键业务的状态型数据，应尽量想办法把维度拆细，一是提高并发处理能力，二是方便隔离故障影响。<br>流水型：不断产生新的数据，各条数据间是独立的，可以随时切换新数据的存储位置，每条数据的主键自包含存储位置信息。单条数据的更新需要保证强一致性。流水型数据很方便做水平扩展。<br>配置型：读写比大，强依赖读，弱依赖写，不要求严格的读一致性。可以采用读写分离、一写多读的方式保证读操作的性能和高可靠。<br>在做架构设计的时候，如果能准确地识别出业务数据的“模式”，可以帮助更合理地划分业务模块，更方便套用特定模式的性能扩展和可靠性保障策略，乃至将公共逻辑抽象成通用组件。一个没有经过数据类型拆分的系统，可以先当成最坏的情况：全是全局状态型数据。然后识别出其中的流水型数据、配置型数据，逐渐分离出去，状态型数据尽量做水平拆分。最后肯定还是会存在无法规避的全局状态型数据，则要想办法尽量降低它的重要性，避免关键链路对它的强依赖。<br>金融/支付系统中，最重要的往往就是类似账务的这种状态型数据，是必须要面对的难题。蚂蚁金服的经验是将所有“类账务”的业务（例如余额、余额宝、花呗）做抽象化、平台化，封装黑名单容灾等固定的业务逻辑，减少重复开发。当然，OceanBase 数据库上线后，把复杂度封装在数据库层内部，在性能和容灾能力（RTO/RPO）上达到了业务期望的平衡，对业务开发是一个不小的福音。目前支付宝的核心系统已经 100% 运行在 OceanBase 数据库上。<br>本文介绍的几种数据模式，基本可以覆盖常见的业务，可以作为架构设计的参考。但也不必过于拘泥，业务本身是复杂多样的，不一定是单纯的某种模式。举两个例子：<br>我们日常在支付宝界面上看到的消费记录，并不是直接查询交易系统，而是从一个专门的消费记录系统查询的。交易系统会通过异步消息把数据复制到消费记录系统。双 11 高峰期消费记录展示可能会有少许延迟，就是这个道理。交易是典型的流水型业务，但交易系统和消费记录系统组成的体系，用的却是读写分离思想。<br>账务系统的余额是状态型数据，但每个账户的变更明细，却是流水型数据，可以适用流水型 Failover 容灾方案。<br>本文只讨论了节点级的水平扩展以及容灾能力，没有提及访问距离带来的延时问题。金融系统往往要求机房级甚至城市级的扩展能力和容灾能力，蚂蚁金服就运行在异地多活架构上。这时候数据访问延时就无法忽略了，会冒出很多原本不是问题的问题，架构设计将更加复杂。对数据类型的分类，其实是一个重要的基础，不同类型的数据在异地架构下也有相应的处理模式。</p>
<blockquote>
<p>作者：chenshiying007</p>
<p>来源：<a href="https://blog.csdn.net/qq_27384769/article/details/80234005" target="_blank" rel="noopener">https://blog.csdn.net/qq_27384769/article/details/80234005</a></p>
</blockquote>
]]></content>
      <categories>
        <category>系统架构</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务架构技术栈</title>
    <url>/2019/12/26/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>近年，Spring Cloud 俨然已经成为微服务开发的主流技术栈，在国内开发者社区非常火爆。我近年一直在一线互联网公司（携程，拍拍贷等）开展微服务架构实践，根据我个人的一线实践经验和我平时对 Spring Cloud 的调研，我认为 Spring Cloud 技术栈中的有些组件离生产级开发尚有一定距离。比方说 Spring Cloud Config 和 Spring Cloud Sleuth 都是 Pivotal 自研产品，尚未得到大规模企业级生产应用，很多企业级特性缺失（具体见我后文描述）。<br>另外 Spring Cloud 体系还缺失一些关键的微服务基础组件，比如 Metrics 监控，健康检查和告警等。所以我在参考 Spring Cloud 微服务技术栈的基础上，结合自身的实战落地经验，也结合国内外一线互联网公司（例如 Netflix，点评，携程，Zalando 等）的开源实践，综合提出更贴近国内技术文化特色的轻量级的微服务参考技术栈。希望这个参考技术栈对一线的架构师（或者是初创公司）有一个好的指导，能够少走弯路，快速落地微服务架构。</p>
<a id="more"></a>

<p>这个参考技术栈和总体架构如下图所示：<br><img src="http://image.winrains.cn/2019/08/6642e-45.png" alt="image"><br>主要包含 11 大核心组件，分别是：</p>
<h2 id="二、核心支撑组件"><a href="#二、核心支撑组件" class="headerlink" title="二、核心支撑组件"></a>二、核心支撑组件</h2><ul>
<li>服务网关 Zuul</li>
<li>服务注册发现 Eureka+Ribbon</li>
<li>服务配置中心 Apollo</li>
<li>认证授权中心 Spring Security OAuth2</li>
<li>服务框架 Spring MVC/Boot</li>
</ul>
<h2 id="三、监控反馈组件"><a href="#三、监控反馈组件" class="headerlink" title="三、监控反馈组件"></a>三、监控反馈组件</h2><ul>
<li>数据总线 Kafka</li>
<li>日志监控 ELK</li>
<li>调用链监控 CAT</li>
<li>Metrics 监控 KairosDB</li>
<li>健康检查和告警 ZMon</li>
<li>限流熔断和流聚合 Hystrix/Turbine</li>
</ul>
<h2 id="四、核心支撑组件"><a href="#四、核心支撑组件" class="headerlink" title="四、核心支撑组件"></a>四、核心支撑组件</h2><h3 id="1、服务网关-Zuul"><a href="#1、服务网关-Zuul" class="headerlink" title="1、服务网关 Zuul"></a>1、服务网关 Zuul</h3><p>2013 年左右，InfoQ 曾经对前 Netflix 架构总监 Adrian Cockcroft 有过一次专访 [附录 1]，其中有问 Adrian：“Netflix 开源这么多项目，你认为哪一个是最不可或缺的 (MOST Indispensable)”，Adrian 回答说：“在 NetflixOSS 开源项目中，有一个容易被忽略，但是 Netflix 最强大的基础服务之一，它就是 Zuul 网关服务。Zuul 网关主要用于智能路由，同时也支持认证，区域和内容感知路由，将多个底层服务聚合成统一的对外 API。Zuul 网关的一大亮点是动态可编程，配置可以秒级生效”。从 Adrian 的回答中，我们可以感受到 Zuul 网关对微服务基础架构的重要性<br>Zuul 在英文中是一种怪兽，星际争霸中虫族里头也有 Zuul，Netflix 为网关起名 Zuul，寓意看门神兽。<br>Zuul 网关在 Netflix 经过生产级验证，在纳入 Spring Cloud 体系之后，在社区中也有众多成功的应用。Zuul 网关在携程（日流量超 50 亿），拍拍贷等公司也有成功的落地实践，是微服务基础架构中网关一块的首选。其它开源产品像 Kong 或者 Nginx 等也可以改造支持网关功能，但是较复杂门槛高一点。<br>Zuul 网关虽然不完全支持异步，但是同步模型反而使它简单轻量，易于编程和扩展，当然同步模型需要做好限流熔断（和限流熔断组件 Hystrix 配合），否则可能造成资源耗尽甚至雪崩效应（cascading failure）。</p>
<h3 id="2、服务注册发现-Eureka-Ribbon"><a href="#2、服务注册发现-Eureka-Ribbon" class="headerlink" title="2、服务注册发现 Eureka + Ribbon"></a>2、服务注册发现 Eureka + Ribbon</h3><p>针对微服务注册发现场景，社区里头的开源产品当中，经过生产级大流量验证的，目前只有 Netflix Eureka 一个，它也已经纳入 Spring Cloud 体系，在社区中有众多成功应用，例如携程 Apollo 配置中心也是使用 Eureka 做软负载。其它产品如 Zookeeper/Etcd/Consul 等，都是比较通用的产品，还需要进一步封装定制才可生产级使用。Eureka 支持跨数据中心高可用，但它是 AP 最终一致系统，不是强一致性系统。<br>Ribbon 是可以和 Eureka 配套对接的客户端软负载库，在 Eureka 的配合下能够支持多种灵活的动态路由和负载均衡策略。内部微服务直连可以直接走 Ribbon 客户端软负载，网关上也可以部署 Ribbon，这时网关相当于一个具有路由和软负载能力的超级客户端。<br>Ribbon 是蝴蝶结的意思。</p>
<h3 id="3、服务配置中心-Apollo"><a href="#3、服务配置中心-Apollo" class="headerlink" title="3、服务配置中心 Apollo"></a>3、服务配置中心 Apollo</h3><p>Spring Cloud 体系里头有个 Spring Cloud Config 产品，但是功能远远达不到生产级，只能小规模场景下用，中大规模企业级场景不建议采用。携程框架研发部开源的 Apollo 是一款在携程和其它众多互联网公司生产落地下来的产品，开源两年多，目前在 github 上有超过 4k 星，非常成功，文档齐全也是它的一大亮点，推荐作为企业级的配置中心产品。<br>Apollo 支持完善的管理界面，支持多环境，配置变更实时生效，权限和配置审计等多种生产级功能。Apollo 既可以用于连接字符串等常规配置场景，也可用于发布开关（Feature Flag）和业务配置等高级场景。在《2018 波波的微服务基础架构和实践》课程中，第二个模块就配置中心相关主题，会深度剖析携程 Apollo 的架构和实践，预计 6 月份推出，欢迎大家关注学习。<br>阿波罗是希腊神话中太阳神的意思</p>
<h3 id="4、认证授权中心-Spring-Security-OAuth2"><a href="#4、认证授权中心-Spring-Security-OAuth2" class="headerlink" title="4、认证授权中心 Spring Security OAuth2"></a>4、认证授权中心 Spring Security OAuth2</h3><p>目前开源社区还没有特别成熟的微服务安全认证中心产品，之前我工作过的一些中大型互联网公司，比如携程，唯品会等，在这一块基本都是定制自研的，但是对一般企业来说，定制自研还是有门槛的。OAuth2 是一种基于令牌 Token 的授权框架，已经得到众多大厂（Google, Facebook, Twitter, Microsoft 等）的支持，可以认为是事实上的微服务安全协议标准，适用于开放平台联合登录，现代微服务安全（包括单页浏览器 App/ 无线原生 App/ 服务器端 WebApp 接入微服务，以及微服务之间调用等场景），和企业内部应用认证授权 (IAM/SSO) 等多种场景。<br>Spring Security OAuth2 是 Spring Security 基础上的一个扩展，支持四种主要的 OAuth2 Flows，基本可以作为微服务认证授权中心的推荐产品。但是 Spring Security OAuth2 还只是一个框架，不是一个端到端的开箱即用的产品，企业级应用仍需在其上进行定制，例如提供 Web 端管理界面，对接企业内部的用户认证登录系统，使用 Cache 缓存令牌，和微服务网关对接等，才能作为生产级使用。在《2018 波波的微服务基础架构和实践》课程中，第一个模块就是微服务安全架构和实践相关主题，会深度剖析 OAuth2 原理和 Spring Security OAuth2 实践，欢迎大家关注学习。<br>Spring Security OAuth2 是 Spring Security 框架的一个扩展。</p>
<h3 id="5、服务框架-Spring-Boot"><a href="#5、服务框架-Spring-Boot" class="headerlink" title="5、服务框架 Spring/Boot"></a>5、服务框架 Spring/Boot</h3><p>Spring 可以说是史上最成功的 Web App/API 开发框架之一，它融入了 Java 社区中多年来沉淀下来的最佳实践，虽然有将近 15 年历史，但目前的社区活跃度仍呈上升趋势。Spring Boot 在 Spring 的基础上进一步打包封装，提供更贴心的 Starter 工程，自启动能力，自动依赖管理，基于代码的配置等特性进一步降低接入门槛。另外 Spring Boot 也提供 actuator 这样的生产级监控特性，支持 DevOps 研发模式，它是微服务开发框架的推荐首选。<br>REST 契约规范 Swagger 和 Spring 有比较好的集成，使得 Spring 也支持契约驱动开发 (Contract Driven Development) 模型。对于一些中大规模的企业，如果业务复杂团队较多，考虑到互操作性和集成成本，建议采用契约驱动开发模型，也就是开发时先定义 Swagger 契约，然后再通过契约生成服务端接口和客户端，再实现服务端业务逻辑，这种开发模型能够标准化接口，降低系统间集成成本，对于多团队协同并行开发非常重要。</p>
<h2 id="六、监控反馈组件"><a href="#六、监控反馈组件" class="headerlink" title="六、监控反馈组件"></a>六、监控反馈组件</h2><h3 id="1、数据总线-Kafka"><a href="#1、数据总线-Kafka" class="headerlink" title="1、数据总线 Kafka"></a>1、数据总线 Kafka</h3><p>最初由 Linkedin 研发并在其内部大规模成功应用，然后在 Apache 上开源的 Kafka，是业内数据总线 (Databus) 一块的标配，几乎每一家互联网公司都可以看到 Kafka 的身影。Kafka 堪称开源项目的一个经典成功案例，其创始人团队从 Linkedin 离职后还专门成立了一家叫 confluent 的企业软件服务公司，围绕 Kafka 周边提供配套和增值服务。在监控一块，日志和 Metrics 等数据可以通过 Kafka 做收集、存储和转发，相当于中间增加了一个大容量缓冲，能够应对海量日志数据的场景。除了日志监控数据收集，Kafka 在业务大数据分析，IoT 等场景都有广泛应用。如果对 Kafka 进行适当定制增强，还可以用于传统消息中间件场景。<br>Kafka 的特性是大容量，高吞吐，高可用，数据可重复消费，可水平扩展，支持消费者组等。Kafka 尤其适用于不严格要求实时和不丢数据的大数据日志场景。<br>Kafka 创始人三人组，离开 Linkedin 后，创立了基于 Kafka 的创业公司 Confluent。</p>
<h3 id="2、日志监控-ELK"><a href="#2、日志监控-ELK" class="headerlink" title="2、日志监控 ELK"></a>2、日志监控 ELK</h3><p>ELK（ElasticSearch/Logstash/Kibana）是日志监控一块的标配技术栈，几乎每一家互联网公司都可以看到 ELK 的身影，据称携程是国内 ELK 的最大用户，每日增量日志数据量达到 80~90TB。ELK 已经非常成熟，基本上是开箱即用，后续主要的工作在运维、治理和调优。<br>ELK 一般和 Kafka 配套使用，因为日志分词操作还是比较耗时的，Kafka 主要作为前置缓冲，起到流量消峰作用，抵消日志流量高峰和消费（分词建索引）的不匹配问题。一旦反向索引建立，日志检索是非常快的，所以日志检索快和灵活是 ElasticSearch 的最大亮点。另外 ELK 还有大容量，高吞吐，高可用，可水平扩容等企业级特性。<br>创业公司起步期，考虑到资源时间限制，调用链监控和 Metrics 监控可以不是第一优先级，但是 ELK 是必须搭一套的，应用日志数据一定要收集并建立索引，基本能够覆盖大部分 Trouble Shooting 场景（业务，性能，程序 bug 等）。<br>另外用好 ELK 的关键是治理，需要制定一些规则（比如只收集 Warn 级别以上日志），对应用的日志数据量做好监控，否则开发人员会滥用，什么垃圾数据都往 ELK 里头丢，造成大量空间被浪费，严重的还可能造成性能可用性问题。<br><img src="http://image.winrains.cn/2019/08/e4a48-46.png" alt="image"></p>
<h3 id="3、调用链监控-CAT"><a href="#3、调用链监控-CAT" class="headerlink" title="3、调用链监控 CAT"></a>3、调用链监控 CAT</h3><p>Spring Cloud 支持基于 Zipkin 的调用链监控，我个人基于实践经验认为 Zipkin 还不能算一款企业级调用链监控产品，充其量只能算是一个半成品，很多重要的企业级特性缺失。Zipkin 最早是由 Twitter 在消化 Google Dapper 论文的基础上研发，在 Twitter 内部有较成功应用，但是在开源出来的时候把不少重要的统计报表功能给阉割了（因为依赖于一些比较重的大数据分析平台），只是开源了一个半成品，能简单查询和呈现可视化调用链，但是细粒度的调用性能数据报表没有开源。<br>Google 大致在 2007 年左右开始研发称为 Dapper 的调用链监控系统，但在远远早于这个时间（大致在 2002 左右），eBay 就已经有了自己的调用链监控系统 CAL（Centralized Application Logging），Google 和 eBay 的设计思路大致相同，但是也有一些差别。CAL 在 eBay 有大规模成功应用，被称为是 eBay 的四大神器之一（另外三个是 DAL，Messaging 和 SOA）。<br>开源调用链监控系统 CAT 的作者吴其敏（我曾经和他同事，习惯叫他老吴），曾经在 eBay 工作近十年，期间深入消化吸收了 CAL 的设计。2011 年后老吴离开 eBay 去了点评，用三年时间在点评再造了一款调用链监控产品 CAT（Centralized Application Tracking），CAT 具有 CAL 的基因和影子，同时也融入了老吴在点评的探索实践和创新。<br>CAT 是一款更完整的企业级调用链监控产品，甚至已经接近一个 APM（Application Performance Management）产品的范畴，它不仅支持调用链的查询和可视化，还支持细粒度的调用性能数据统计报表，这块是 CAT 和市面上其它开源调用链监控产品最本质的差异点，实际上开发人员大部分时间用 CAT 是看性能统计报表（主要是 CAT 的 Transaction 和 Problem 报表），这些报表相当于给了开发人员一把尺子，可以自助测量并持续改进应用性能。另外 CAT 还支持应用报错大盘，自助告警等功能，也是企业级监控非常实用的功能。<br>CAT 在点评，携程，陆金所，拍拍贷等公司有成功落地案例，因为是国产调用链监控产品，界面展示和功能等更契合国内文化，更易于在国内公司落地。个人推荐 CAT 作为微服务调用链监控的首选。<br>至于社区里头有人提到 CAT 的侵入性问题，我觉得是要一分为二看，有利有弊，有耦合性但是性能更好，一般企业中基础架构团队会使用 CAT 统一为基础组件埋点，开发人员一般不用自己埋点；另外企业用了一款调用链监控产品以后，一般是不会换的，开发人员用习惯就好了，侵入不是大问题<br><img src="http://image.winrains.cn/2019/08/58614-47.png" alt="image"><br>CAT 的 Transaction 报表</p>
<h3 id="4、Metrics-监控-KariosDB"><a href="#4、Metrics-监控-KariosDB" class="headerlink" title="4、Metrics 监控 KariosDB"></a>4、Metrics 监控 KariosDB</h3><p>除了日志和调用链，Metrics 也是应用监控的重要关注点。互联网应用提倡度量驱动开发（Metrics Driven Development），也就是说开发人员不仅要关注功能实现，做好单元测试（TDD），还要做好业务层（例如注册，登录和下单数等）和应用层（例如调用数，调用延迟等）的监控埋点，这个也是 DevOps（开发即运维）理念的体现，DevOps 要求开发人员必须关注运维需求，监控埋点是一种生产级运维需求。<br>Metrics 监控产品底层依赖于时间序列数据库（TSDB），最近比较热的开源产品有 Prometheus 和 InfluxDB，社区用户数量和反馈都不错，可以采纳。但是这些产品分布式能力比较弱，定制扩展门槛比较高，一般建议刚起步量不大的公司采用。<br>如果企业业务和团队规模发展到一定阶段，建议考虑支持分布式能力的时间序列监控产品，例如 KairosDB 或者 OpenTSDB，我本人对这两款产品都有一些实践经验，KariosDB 基于 Cassandra，相对更轻量一点，建议中大规模公司采用，如果你们公司已经采用 Hadoop/HBase，则 OpenTSDB 也是不错选择。<br>KairosDB 一般也和 Kafka 配套使用，Kafka 作为前置缓冲。另外注意使用 KariosDB 打点的话 tag 的值不能太离散，否则会有查询性能问题，这个和 KariosDB 底层存储结构有关系。Grafana 是 Metrics 展示标配，可以和 KariosDB 无缝集成。<br><img src="http://image.winrains.cn/2019/08/89ad8-48.png" alt="image"><br>Grafana 是 Metrics 展示标配，和主流时间序列数据库都可以集成</p>
<h3 id="5、健康检查和告警-ZMon"><a href="#5、健康检查和告警-ZMon" class="headerlink" title="5、健康检查和告警 ZMon"></a>5、健康检查和告警 ZMon</h3><p>除了上述监控手段，我们仍需要健康检查和告警系统作为配套的监控手段。ZMon 是德国电商公司 Zalando 开源的一款健康检查和告警平台，具备强大灵活的监控告警能力。ZMon 本质上可以认为是一套分布式监控任务调度平台，它提供众多的 Check 脚本（也可以自己再定制扩展），能够对各种硬件资源或者目标服务（例如 HTTP 端口，Spring 的 Actuator 端点，KariosDB 中的 Metrics，ELK 中的错误日志等等）进行定期的健康检查和告警，它的告警逻辑和策略采用 Python 脚本实现，开发人员可以实现自助式告警。ZMon 同时适用于系统，应用，业务，甚至端用户体验层的监控和告警。<br><img src="http://image.winrains.cn/2019/08/6c797-49.png" alt="image"></p>
<h3 id="6、限流熔断和流聚合-Hystrix-Turbine"><a href="#6、限流熔断和流聚合-Hystrix-Turbine" class="headerlink" title="6、限流熔断和流聚合 Hystrix+Turbine"></a>6、限流熔断和流聚合 Hystrix+Turbine</h3><p>2010 年左右，Netflix 也饱受分布式微服务系统中雪崩效应（Cascading Failure）的困扰，于是专门启动了一个叫做弹性工程的项目来解决这个问题，Hystrix 就是弹性工程最终落地下来的一个产品。Hystrix 在 Netflix 微服务系统中大规模推广应用后，雪崩效应问题基本得到解决，整个体统更具弹性。<br>之后 Netflix 把 Hystrix 开源贡献给了社区，短期获得社区的大量正面反馈，目前 Hystrix 在 github 上有超过 1.3 万颗星，据说支持奥巴马总统选举的系统也曾使用 Hystrix 进行限流熔断保护 ，可见限流熔断是分布式系统稳定性的强需求，Netflix 很好的抓住了这个需求并给出了经过生产级验证的解决方案。Hystrix 已经被纳入 Spring Cloud 体系，它是 Java 社区中限流熔断组件的首选（目前还看不到第二个更好的产品）。<br>Turbine 是和 Hystrix 配套的一个流聚合服务，能够对 Hystrix 监控数据流进行聚合，聚合以后可以在 Hystrix Dashboard 上看到集群的流量和性能情况。<br>Hystrix 在英文中是豪猪兽的意思，豪猪兽通过身上的刺保护自己，Netflix 为限流熔断组件起名 Hystrix，寓意 Hystrix 能够保护微服务调用。</p>
<blockquote>
<p>作者：chenshiying007</p>
<p>来源：<a href="https://blog.csdn.net/qq_27384769/article/details/80258846" target="_blank" rel="noopener">https://blog.csdn.net/qq_27384769/article/details/80258846</a></p>
</blockquote>
]]></content>
      <categories>
        <category>系统架构</category>
        <category>微服务</category>
      </categories>
  </entry>
  <entry>
    <title>分布式事务综述</title>
    <url>/2019/12/26/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="一、什么是事务"><a href="#一、什么是事务" class="headerlink" title="一、什么是事务"></a>一、什么是事务</h1><p>数据库事务（简称：事务，Transaction）是指数据库执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。<br>事务拥有以下四个特性，习惯上被称为 ACID 特性：</p>
<ul>
<li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li>
<li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态是指数据库中的数据应满足完整性约束。除此之外，一致性还有另外一层语义，就是事务的中间状态不能被观察到（这层语义也有说应该属于原子性）。</li>
<li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行，如同只有这一个操作在被数据库所执行一样。</li>
<li>持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。在事务结束时，此操作将不可逆转。</li>
</ul>
<a id="more"></a>

<p>起初，事务仅限于对单一数据库资源的访问控制：<br><img src="http://image.winrains.cn/2019/08/e0796-15.png" alt="image"><br>架构服务化以后，事务的概念延伸到了服务中。倘若将一个单一的服务操作作为一个事务，那么整个服务操作只能涉及一个单一的数据库资源：<br><img src="http://image.winrains.cn/2019/08/8e59d-16.png" alt="image"><br>这类基于单个服务单一数据库资源访问的事务，被称为本地事务（Local Transaction）。</p>
<h1 id="二、分布式事务应用架构"><a href="#二、分布式事务应用架构" class="headerlink" title="二、分布式事务应用架构"></a>二、分布式事务应用架构</h1><p>本地事务主要限制在单个会话内，不涉及多个数据库资源。但是在基于SOA（Service-Oriented Architecture，面向服务架构）的分布式应用环境下，越来越多的应用要求对多个数据库资源，多个服务的访问都能纳入到同一个事务当中，分布式事务应运而生。<br>最早的分布式事务应用架构很简单，不涉及服务间的访问调用，仅仅是服务内操作涉及到对多个数据库资源的访问。<br><img src="http://image.winrains.cn/2019/08/eea77-17.png" alt="image"><br>当一个服务操作访问不同的数据库资源，又希望对它们的访问具有事务特性时，就需要采用分布式事务来协调所有的事务参与者。<br>对于上面介绍的分布式事务应用架构，尽管一个服务操作会访问多个数据库资源，但是毕竟整个事务还是控制在单一服务的内部。如果一个服务操作需要调用另外一个服务，这时的事务就需要跨越多个服务了。在这种情况下，起始于某个服务的事务在调用另外一个服务的时候，需要以某种机制流转到另外一个服务，从而使被调用的服务访问的资源也自动加入到该事务当中来。下图反映了这样一个跨越多个服务的分布式事务：<br><img src="http://image.winrains.cn/2019/08/c999b-18.png" alt="image"><br>如果将上面这两种场景（一个服务可以调用多个数据库资源，也可以调用其他服务）结合在一起，对此进行延伸，整个分布式事务的参与者将会组成如下图所示的树形拓扑结构。在一个跨服务的分布式事务中，事务的发起者和提交均系同一个，它可以是整个调用的客户端，也可以是客户端最先调用的那个服务。<br><img src="http://image.winrains.cn/2019/08/7de73-19.png" alt="image"><br>较之基于单一数据库资源访问的本地事务，分布式事务的应用架构更为复杂。在不同的分布式应用架构下，实现一个分布式事务要考虑的问题并不完全一样，比如对多资源的协调、事务的跨服务传播等，实现机制也是复杂多变。尽管有这么多工程细节需要考虑，但分布式事务最核心的还是其 ACID 特性。因此，想要了解一个分布式事务，就先从了解它是怎么实现事务 ACID 特性开始。<br>下文将从两个最常见的分布式事务模型入手，着重分析分布式事务的基础共通点，即如何保证分布式事务的 ACID 特性。</p>
<h1 id="三、常见分布式事务模型-ACID-实现分析"><a href="#三、常见分布式事务模型-ACID-实现分析" class="headerlink" title="三、常见分布式事务模型 ACID 实现分析"></a>三、常见分布式事务模型 ACID 实现分析</h1><h2 id="X-Open-XA-协议"><a href="#X-Open-XA-协议" class="headerlink" title="X/Open XA 协议"></a>X/Open XA 协议</h2><p>最早的分布式事务模型是 X/Open 国际联盟提出的 X/Open Distributed Transaction Processing（DTP）模型，也就是大家常说的 X/Open XA 协议，简称XA 协议。<br><img src="http://image.winrains.cn/2019/08/cd67f-20.png" alt="image"><br>DTP 模型中包含一个全局事务管理器（TM，Transaction Manager）和多个资源管理器（RM，Resource Manager）。全局事务管理器负责管理全局事务状态与参与的资源，协同资源一起提交或回滚；资源管理器则负责具体的资源操作。<br>XA 协议描述了 TM 与 RM 之间的接口，允许多个资源在同一分布式事务中访问。<br>基于 DTP 模型的分布式事务流程大致如下：<br><img src="http://image.winrains.cn/2019/08/3927b-21.png" alt="image"><br>1、应用程序（AP，Application）向 TM 申请开始一个全局事务。<br>2、针对要操作的 RM，AP 会先向 TM 注册（TM 负责记录 AP 操作过哪些 RM，即分支事务），TM 通过 XA 接口函数通知相应 RM 开启分布式事务的子事务，接着 AP 就可以对该 RM 管理的资源进行操作。<br>3、当 AP 对所有 RM 操作完毕后，AP 根据执行情况通知 TM 提交或回滚该全局事务，TM 通过 XA 接口函数通知各 RM 完成操作。TM 会先要求各个 RM 做预提交，所有 RM 返回成功后，再要求各 RM 做正式提交，XA 协议要求，一旦 RM 预提交成功，则后续的正式提交也必须能成功；如果任意一个 RM 预提交失败，则 TM 通知各 RM 回滚。<br>4、所有 RM 提交或回滚完成后，全局事务结束。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>XA 协议使用 2PC（Two Phase Commit，两阶段提交）原子提交协议来保证分布式事务原子性。<br>两阶段提交是指将提交过程分为两个阶段，即准备阶段（投票阶段）和提交阶段（执行阶段）：<br><img src="http://image.winrains.cn/2019/08/d92a6-22.png" alt="image"></p>
<ul>
<li>准备阶段</li>
</ul>
<p>TM 向每个 RM 发送准备消息。如果 RM 的本地事务操作执行成功，则返回成功；如果 RM 的本地事务操作执行失败，则返回失败。</p>
<ul>
<li>提交阶段</li>
</ul>
<p>如果 TM 收到了所有 RM 回复的成功消息，则向每个 RM 发送提交消息；否则发送回滚消息；RM 根据 TM 的指令执行提交或者回滚本地事务操作，释放所有事务处理过程中使用的锁资源。</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>XA 协议中没有描述如何实现分布式事务的隔离性，但是 XA 协议要求DTP 模型中的每个 RM 都要实现本地事务，也就是说，基于 XA 协议实现的分布式事务的隔离性是由每个 RM 本地事务的隔离性来保证的，当一个分布式事务的所有子事务都是隔离的，那么这个分布式事务天然的就实现了隔离性。<br>以 MySQL 来举例，MySQL 使用 2PL（Two-Phase Locking，两阶段锁）机制来控制本地事务的并发，保证隔离性。2PL 与 2PC 类似，也是将锁操作分为加锁和解锁两个阶段，并且保证两个阶段完全不相交。加锁阶段，只加锁，不放锁。解锁阶段，只放锁，不加锁。<br><img src="http://image.winrains.cn/2019/08/b4bd3-23.png" alt="image"><br>如上图所示，在一个本地事务中，每执行一条更新操作之前，都会先获取对应的锁资源，只有获取锁资源成功才会执行该操作，并且一旦获取了锁资源就会持有该锁资源直到本事务执行结束。<br>MySQL 通过这种 2PL 机制，可以保证在本地事务执行过程中，其他并发事务不能操作相同资源，从而实现了事务隔离。</p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>前面提到一致性有两层语义，一层是确保事务执行结束后，数据库从一个一致状态转变为另一个一致状态。另一层语义是事务执行过程中的中间状态不能被观察到。<br>前一层语义的实现很简单，通过原子性、隔离性以及 RM 自身一致性的实现就可以保证。至于后一层语义，我们先来看看单个 RM 上的本地事务是怎么实现的。还是以 MySQL 举例，MySQL 通过 MVCC（Multi Version Concurrency Control，多版本并发控制）机制，为每个一致性状态生成快照（Snapshot），每个事务看到的都是各Snapshot对应的一致性状态，从而也就保证了本地事务的中间状态不会被观察到。<br>虽然单个 RM 上实现了Snapshot，但是在分布式应用架构下，会遇到什么问题呢？<br><img src="http://image.winrains.cn/2019/08/61ecb-24.png" alt="image"><br>如上图所示，在 RM1 的本地子事务提交完毕到 RM2 的本地子事务提交完毕之间，只能读到 RM1 上子事务执行的内容，读不到 RM2 上的子事务。也就是说，虽然在单个 RM 上的本地事务是一致的，但是从全局来看，一个全局事务执行过程的中间状态被观察到了，全局一致性就被破坏了。<br>XA 协议并没有定义怎么实现全局的 Snapshot，像 MySQL 官方文档里就建议使用串行化的隔离级别来保证分布式事务一致性： “As with nondistributed transactions, SERIALIZABLE may be preferred if your applications are sensitive to read phenomena. REPEATABLE READ may not be sufficient for distributed transactions.”（对于分布式事务来说，可重复读隔离级别不足以保证事务一致性，如果你的程序有全局一致性读要求，可以考虑串行化隔离级别.）<br>当然，由于串行化隔离级别的性能较差，所以很多分布式数据库都自己实现了分布式 MVCC 机制来提供全局的一致性读。一个基本思路是用一个集中式或者逻辑上单调递增的东西来控制生成全局 Snapshot，每个事务或者每条 SQL 执行时都去获取一次，从而实现不同隔离级别下的一致性。比如 Google 的 Spanner 就是用 TrueTime 来控制访问全局 Snapshot。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>XA 协议通常实现在数据库资源层，直接作用于资源管理器上。因此，基于 XA 协议实现的分布式事务产品，无论是分布式数据库，还是分布式事务框架，对业务几乎都没有侵入，就像使用普通数据库一样。<br>XA 协议严格保障事务 ACID 特性，能够满足所有业务领域的功能需求，但是，这同样是一把双刃剑。<br>由于隔离性的互斥要求，在事务执行过程中，所有的资源都被锁定，只适用于执行时间确定的短事务。同时，整个事务期间都是独占数据，对于热点数据的并发性能可能会很低，实现了分布式 MVCC 或乐观锁（optimistic locking）以后，性能可能会有所提升。<br>同时，为了保障一致性，要求所有 RM 同等可信、可靠，要求故障恢复机制可靠、快速，在网络故障隔离的情况下，服务基本不可用。</p>
<h2 id="TCC-模型"><a href="#TCC-模型" class="headerlink" title="TCC 模型"></a>TCC 模型</h2><p>TCC（Try-Confirm-Cancel）分布式事务模型相对于 XA 等传统模型，其特征在于它不依赖资源管理器（RM）对分布式事务的支持，而是通过对业务逻辑的分解来实现分布式事务。<br>TCC 模型认为对于业务系统中一个特定的业务逻辑，其对外提供服务时，必须接受一些不确定性，即对业务逻辑初步操作的调用仅是一个临时性操作，调用它的主业务服务保留了后续的取消权。如果主业务服务认为全局事务应该回滚，它会要求取消之前的临时性操作，这就对应从业务服务的取消操作。而当主业务服务认为全局事务应该提交时，它会放弃之前临时性操作的取消权，这对应从业务服务的确认操作。每一个初步操作，最终都会被确认或取消。<br>因此，针对一个具体的业务服务，TCC 分布式事务模型需要业务系统提供三段业务逻辑：<br>1、初步操作 Try：完成所有业务检查，预留必须的业务资源。<br>2、确认操作 Confirm：真正执行的业务逻辑，不作任何业务检查，只使用 Try 阶段预留的业务资源。因此，只要 Try 操作成功，Confirm 必须能成功。另外，Confirm 操作需满足幂等性，保证一笔分布式事务有且只能成功一次。<br>3、取消操作 Cancel：释放 Try 阶段预留的业务资源。同样的，Cancel 操作也需要满足幂等性。<br><img src="http://image.winrains.cn/2019/08/490a3-25.png" alt="image"><br>TCC 分布式事务模型包括三部分：</p>
<ul>
<li>主业务服务：主业务服务为整个业务活动的发起方，服务的编排者，负责发起并完成整个业务活动。</li>
<li>从业务服务：从业务服务是整个业务活动的参与方，负责提供 TCC 业务操作，实现初步操作（Try）、确认操作（Confirm）、取消操作（Cancel）三个接口，供主业务服务调用。</li>
<li>业务活动管理器：业务活动管理器管理控制整个业务活动，包括记录维护 TCC 全局事务的事务状态和每个从业务服务的子事务状态，并在业务活动提交时调用所有从业务服务的 Confirm 操作，在业务活动取消时调用所有从业务服务的 Cancel 操作。</li>
</ul>
<p>一个完整的 TCC 分布式事务流程如下：<br>1、主业务服务首先开启本地事务； 2、主业务服务向业务活动管理器申请启动分布式事务主业务活动； 3、然后针对要调用的从业务服务，主业务活动先向业务活动管理器注册从业务活动，然后调用从业务服务的 Try 接口； 4、当所有从业务服务的 Try 接口调用成功，主业务服务提交本地事务；若调用失败，主业务服务回滚本地事务； 5、若主业务服务提交本地事务，则 TCC 模型分别调用所有从业务服务的 Confirm 接口；若主业务服务回滚本地事务，则分别调用 Cancel 接口； 6、所有从业务服务的 Confirm 或 Cancel 操作完成后，全局事务结束。</p>
<h3 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h3><p>TCC 模型也使用 2PC 原子提交协议来保证事务原子性。Try 操作对应2PC 的一阶段准备（Prepare）；Confirm 对应 2PC 的二阶段提交（Commit），Cancel 对应 2PC 的二阶段回滚（Rollback），可以说 TCC 就是应用层的 2PC。</p>
<h3 id="隔离性-1"><a href="#隔离性-1" class="headerlink" title="隔离性"></a>隔离性</h3><p>TCC 分布式事务模型仅提供两阶段原子提交协议，保证分布式事务原子性。事务的隔离交给业务逻辑来实现。<br>隔离的本质是控制并发，防止并发事务操作相同资源而引起的结果错乱。<br>举个例子，比如金融行业里管理用户资金，当用户发起交易时，一般会先检查用户资金，如果资金充足，则扣除相应交易金额，增加卖家资金，完成交易。如果没有事务隔离，用户同时发起两笔交易，两笔交易的检查都认为资金充足，实际上却只够支付一笔交易，结果两笔交易都支付成功，导致资损。<br>可以发现，并发控制是业务逻辑执行正确的保证，但是像两阶段锁这样的并发访问控制技术要求一直持有数据库资源锁直到整个事务执行结束，特别是在分布式事务架构下，要求持有锁到分布式事务第二阶段执行结束，也就是说，分布式事务会加长资源锁的持有时间，导致并发性能进一步下降。<br>因此，TCC 模型的隔离性思想就是通过业务的改造，在第一阶段结束之后，从底层数据库资源层面的加锁过渡为上层业务层面的加锁，从而释放底层数据库锁资源，放宽分布式事务锁协议，提高业务并发性能。<br>还是以上面的例子举例：<br>1、第一阶段：检查用户资金，如果资金充足，冻结用户本次交易资金，这笔资金被业务隔离，不允许除本事务之外的其它并发事务动用。<br>2、第二阶段：扣除第一阶段预冻结的用户资金，增加卖家资金，完成交易。<br>采用业务加锁的方式，隔离用户冻结资金，在第一阶段结束后直接释放底层资源锁，该用户和卖家的其他交易都可以立刻并发执行，而不用等到整个分布式事务结束，可以获得更高的并发交易能力。</p>
<h3 id="一致性-1"><a href="#一致性-1" class="headerlink" title="一致性"></a>一致性</h3><p>再来看看 TCC 分布式事务模型下的一致性实现。与 XA 协议实现一致性第一层语义类似，通过原子性保证事务的原子提交、业务隔离性控制事务的并发访问，实现分布式事务的一致性状态转变。<br>至于第二层语义：事务的中间状态不能被观察到。我们来看看，在 SOA分布式应用环境下是否是必须的。<br>还是以账务服务举例。转账业务（用户 A -&gt; 用户 B），由交易服务和账务服务组成分布式事务，交易服务作为主业务服务，账务服务作为从业务服务，账务服务的 Try 操作预冻结用户 A 的资金；Commit 操作扣除用户 A 的预冻结资金，增加用户 B 的可用资金；Cancel 操作解冻用户 A 的预冻结资金。<br>当账务服务执行完 Try 阶段后，交易主业务就可以 Commit 了，然后由TCC 框架调用账务的 Commit 阶段。在账务 Commit 阶段还没执行结束的时候，用户 A 可以查询到自己的余额已扣除，但是，此时用户 B 的可用资金还没增加。<br>从系统的角度来看，确实有问题与不确定性。在第一阶段执行结束到第二阶段执行结束之间，有一段时间的延时，在这段时间内，看似任何用户都不享有这笔资产。<br>但是，从用户的角度来考虑这个问题的话，这个时间间隔可能就无所谓或者根本就不存在。特别是当这个时间间隔仅仅是几秒钟，对于具体沟通资产转移的用户来讲，这个过程是隐蔽的或确实可以接受的，且保证了结果的最终一致性。<br>当然，对于这样的系统，如果确实需要查看系统的某个一致性状态，可以采用额外的方法实现。<br>一般来讲，服务之间的一致性比服务内部的一致性要更加容易弱化，这也是为什么 XA 等直接在资源层面上实现通用分布式事务的模型会注重一致性的保证，而当上升到服务层面，服务与服务之间已经实现了功能的划分，逻辑的解耦，也就更容易弱化一致性，这就是 SOA 架构下 BASE 理论的最终一致性思想。<br>BASE 理论是指 BA（Basic Availability，基本业务可用性）；S（Soft state，柔性状态）；E（Eventual consistency，最终一致性）。该理论认为为了可用性、性能与降级服务的需要，可以适当降低一点一致性的要求，即“基本可用，最终一致”。<br>业内通常把严格遵循 ACID 的事务称为刚性事务；而基于 BASE 思想实现的事务称为柔性事务。柔性事务并不是完全放弃了 ACID，仅仅是放宽了一致性要求：事务完成后的一致性严格遵循，事务中的一致性可适当放宽。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>TCC 分布式事务模型的业务实现特性决定了其可以跨 DB、跨服务实现资源管理，将对不同的 DB 访问、不同的业务操作通过 TCC 模型协调为一个原子操作，解决了分布式应用架构场景下的事务问题。<br>TCC 模型通过 2PC 原子提交协议保证分布式事务的的原子性，把资源层的隔离性上升到业务层，交给业务逻辑来实现。TCC 的每个操作对于资源层来说，就是单个本地事务的使用，操作结束则本地事务结束，规避了资源层在 2PC 和 2PL 下对资源占用导致的性能低下问题。<br>同时，TCC 模型也可以根据业务需要，做一些定制化的功能，比如交易异步化实现削峰填谷等。<br>但是，业务接入 TCC 模型需要拆分业务逻辑成两个阶段，并实现 Try、Confirm、Cancel 三个接口，定制化程度高，开发成本高。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文首先介绍了典型的分布式事务的架构场景。分布式事务刚开始是为解决单服务多数据库资源的场景而诞生的。随着技术的发展，特别是 SOA 分布式应用架构以及微服务时代的到来，服务变成了基本业务单元。因此，又产生了跨服务的分布式事务需求。<br>然后从 XA 和 TCC 两种常用的分布式事务模型入手，介绍了其实现机制，着重分析了各模型是如何实现分布式事务 ACID 特性的。</p>
<blockquote>
<p>作者：chenshiying007</p>
<p>来源：<a href="https://blog.csdn.net/qq_27384769/article/details/80226326" target="_blank" rel="noopener">https://blog.csdn.net/qq_27384769/article/details/80226326</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>SimpleDateFormat安全的时间格式化</title>
    <url>/2019/12/26/SimpleDateFormat%E5%AE%89%E5%85%A8%E7%9A%84%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    <content><![CDATA[<p>想必大家对SimpleDateFormat并不陌生。SimpleDateFormat 是 Java 中一个非常常用的类，该类用来对日期字符串进行解析和格式化输出，但如果使用不小心会导致非常微妙和难以调试的问题，因为 DateFormat 和 SimpleDateFormat 类不都是线程安全的，在多线程环境下调用 format() 和 parse() 方法应该使用同步代码来避免问题。下面我们通过一个具体的场景来一步步的深入学习和理解SimpleDateFormat类。</p>
<a id="more"></a>

<h2 id="一、引子"><a href="#一、引子" class="headerlink" title="一、引子"></a><strong>一、引子</strong></h2><p>我们都是优秀的程序员，我们都知道在程序中我们应当尽量少的创建SimpleDateFormat 实例，因为创建这么一个实例需要耗费很大的代价。在一个读取数据库数据导出到excel文件的例子当中，每次处理一个时间信息的时候，就需要创建一个SimpleDateFormat实例对象，然后再丢弃这个对象。大量的对象就这样被创建出来，占用大量的内存和 jvm空间。代码如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package com.peidasoft.dateformat;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="built_in">text</span>.ParseException;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="built_in">text</span>.SimpleDateFormat;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateUtil</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">String</span> <span class="title">formatDate</span><span class="params">(Date date)</span>throws ParseException</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> sdf.format(date);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">parse</span><span class="params">(<span class="keyword">String</span> strDate)</span> throws ParseException</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> sdf.parse(strDate);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>你也许会说，OK，那我就创建一个静态的simpleDateFormat实例，然后放到一个DateUtil类（如下）中，在使用时直接使用这个实例进行操作，这样问题就解决了。改进后的代码如下：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peidasoft.dateformat;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateUtil</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span>  SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="function">String <span class="title">formatDate</span><span class="params">(Date date)</span><span class="keyword">throws</span> ParseException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">return</span> sdf.<span class="title">format</span><span class="params">(date)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Date <span class="title">parse</span><span class="params">(String strDate)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">return</span> sdf.<span class="title">parse</span><span class="params">(strDate)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>当然，这个方法的确很不错，在大部分的时间里面都会工作得很好。但当你在生产环境中使用一段时间之后，你就会发现这么一个事实：它不是线程安全的。在正常的测试情况之下，都没有问题，但一旦在生产环境中一定负载情况下时，这个问题就出来了。他会出现各种不同的情况，比如转化的时间不正确，比如报错，比如线程被挂死等等。我们看下面的测试用例，那事实说话：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peidasoft.dateformat;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateUtil</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span>  SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String <span class="title">formatDate</span><span class="params">(Date date)</span><span class="keyword">throws</span> ParseException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> sdf.format(date);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">parse</span><span class="params">(String strDate)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> sdf.parse(strDate);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peidasoft.dateformat;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateUtilTest</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSimpleDateFormatThreadSafe</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">this</span>.join(<span class="number">2000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    e1.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    System.out.println(<span class="keyword">this</span>.getName()+<span class="string">":"</span>+DateUtil.parse(<span class="string">"2013-05-24 06:02:20"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">new</span> TestSimpleDateFormatThreadSafe().start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>执行输出如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"Thread-1"</span> java.lang.NumberFormatException: multiple points</span></pre></td></tr><tr><td class="code"><pre><span class="line">    at sun.misc.<span class="module-access"><span class="module"><span class="identifier">FloatingDecimal</span>.</span></span>read<span class="constructor">JavaFormatString(FloatingDecimal.<span class="params">java</span>:1082)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    at java.lang.<span class="module-access"><span class="module"><span class="identifier">Double</span>.</span></span>parse<span class="constructor">Double(Double.<span class="params">java</span>:510)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    at java.text.<span class="module-access"><span class="module"><span class="identifier">DigitList</span>.</span></span>get<span class="constructor">Double(DigitList.<span class="params">java</span>:151)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    at java.text.<span class="module-access"><span class="module"><span class="identifier">DecimalFormat</span>.</span></span>parse(<span class="module-access"><span class="module"><span class="identifier">DecimalFormat</span>.</span></span>java:<span class="number">1302</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    at java.text.<span class="module-access"><span class="module"><span class="identifier">SimpleDateFormat</span>.</span></span>sub<span class="constructor">Parse(SimpleDateFormat.<span class="params">java</span>:1589)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    at java.text.<span class="module-access"><span class="module"><span class="identifier">SimpleDateFormat</span>.</span></span>parse(<span class="module-access"><span class="module"><span class="identifier">SimpleDateFormat</span>.</span></span>java:<span class="number">1311</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    at java.text.<span class="module-access"><span class="module"><span class="identifier">DateFormat</span>.</span></span>parse(<span class="module-access"><span class="module"><span class="identifier">DateFormat</span>.</span></span>java:<span class="number">335</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    at com.peidasoft.orm.dateformat.<span class="module-access"><span class="module"><span class="identifier">DateNoStaticUtil</span>.</span></span>parse(<span class="module-access"><span class="module"><span class="identifier">DateNoStaticUtil</span>.</span></span>java:<span class="number">17</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    at com.peidasoft.orm.dateformat.<span class="module-access"><span class="module"><span class="identifier">DateUtilTest$TestSimpleDateFormatThreadSafe</span>.</span></span>run(<span class="module-access"><span class="module"><span class="identifier">DateUtilTest</span>.</span></span>java:<span class="number">20</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"Thread-0"</span> java.lang.NumberFormatException: multiple points</span></pre></td></tr><tr><td class="code"><pre><span class="line">    at sun.misc.<span class="module-access"><span class="module"><span class="identifier">FloatingDecimal</span>.</span></span>read<span class="constructor">JavaFormatString(FloatingDecimal.<span class="params">java</span>:1082)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    at java.lang.<span class="module-access"><span class="module"><span class="identifier">Double</span>.</span></span>parse<span class="constructor">Double(Double.<span class="params">java</span>:510)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    at java.text.<span class="module-access"><span class="module"><span class="identifier">DigitList</span>.</span></span>get<span class="constructor">Double(DigitList.<span class="params">java</span>:151)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    at java.text.<span class="module-access"><span class="module"><span class="identifier">DecimalFormat</span>.</span></span>parse(<span class="module-access"><span class="module"><span class="identifier">DecimalFormat</span>.</span></span>java:<span class="number">1302</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    at java.text.<span class="module-access"><span class="module"><span class="identifier">SimpleDateFormat</span>.</span></span>sub<span class="constructor">Parse(SimpleDateFormat.<span class="params">java</span>:1589)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    at java.text.<span class="module-access"><span class="module"><span class="identifier">SimpleDateFormat</span>.</span></span>parse(<span class="module-access"><span class="module"><span class="identifier">SimpleDateFormat</span>.</span></span>java:<span class="number">1311</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    at java.text.<span class="module-access"><span class="module"><span class="identifier">DateFormat</span>.</span></span>parse(<span class="module-access"><span class="module"><span class="identifier">DateFormat</span>.</span></span>java:<span class="number">335</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    at com.peidasoft.orm.dateformat.<span class="module-access"><span class="module"><span class="identifier">DateNoStaticUtil</span>.</span></span>parse(<span class="module-access"><span class="module"><span class="identifier">DateNoStaticUtil</span>.</span></span>java:<span class="number">17</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    at com.peidasoft.orm.dateformat.<span class="module-access"><span class="module"><span class="identifier">DateUtilTest$TestSimpleDateFormatThreadSafe</span>.</span></span>run(<span class="module-access"><span class="module"><span class="identifier">DateUtilTest</span>.</span></span>java:<span class="number">20</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread-<span class="number">2</span>:Mon May <span class="number">24</span> <span class="number">06</span>:<span class="number">02</span>:<span class="number">20</span> CST <span class="number">2021</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread-<span class="number">2</span>:Fri May <span class="number">24</span> <span class="number">06</span>:<span class="number">02</span>:<span class="number">20</span> CST <span class="number">2013</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread-<span class="number">2</span>:Fri May <span class="number">24</span> <span class="number">06</span>:<span class="number">02</span>:<span class="number">20</span> CST <span class="number">2013</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread-<span class="number">2</span>:Fri May <span class="number">24</span> <span class="number">06</span>:<span class="number">02</span>:<span class="number">20</span> CST <span class="number">2013</span></span></pre></td></tr></table></figure>

<p>说明：<code>Thread-1</code>和<code>Thread-0</code>报<code>java.lang.NumberFormatException: multiple points</code>错误，直接挂死，没起来；<code>Thread-2</code> 虽然没有挂死，但输出的时间是有错误的，比如我们输入的时间是：2013-05-24 06:02:20 ，当会输出：Mon May 24 06:02:20 CST 2021 这样的灵异事件。</p>
<h2 id="二、原因"><a href="#二、原因" class="headerlink" title="二、原因"></a><strong>二、原因</strong></h2><p>作为一个专业程序员，我们当然都知道，相比于共享一个变量的开销要比每次创建一个新变量要小很多。上面的优化过的静态的SimpleDateFormat版，之所在并发情况下回出现各种灵异错误，是因为SimpleDateFormat和DateFormat类不是线程安全的。我们之所以忽视线程安全的问题，是因为从SimpleDateFormat和DateFormat类提供给我们的接口上来看，实在让人看不出它与线程安全有何相干。只是在JDK文档的最下面有如下说明：**<br>**<br>　　SimpleDateFormat中的日期格式不是同步的。推荐（建议）为每个线程创建独立的格式实例。如果多个线程同时访问一个格式，则它必须保持外部同步。<br>JDK原始文档如下：<br>Synchronization：<br>Date formats are not synchronized.<br>It is recommended to create separate format instances for each thread.<br>If multiple threads access a format concurrently, it must be synchronized externally.<br>下面我们通过看JDK源码来看看为什么SimpleDateFormat和DateFormat类不是线程安全的真正原因：<br>SimpleDateFormat继承了DateFormat,在DateFormat中定义了一个protected属性的 Calendar类的对象：calendar。只是因为Calendar累的概念复杂，牵扯到时区与本地化等等，Jdk的实现中使用了成员变量来传递参数，这就造成在多线程的时候会出现错误。<br>在format方法里，有这样一段代码：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> StringBuffer format(Date <span class="keyword">date</span>, StringBuffer toAppendTo, FieldDelegate delegate) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Convert input date to time field list</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    calendar.setTime(<span class="keyword">date</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">boolean</span> useDateFormatSymbols = useDateFormatSymbols();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; compiledPattern.length;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> tag = compiledPattern[i] &gt;&gt;&gt; <span class="number">8</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> <span class="keyword">count</span> = compiledPattern[i++] &amp; <span class="number">0xff</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">count</span> == <span class="number">255</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">count</span> = compiledPattern[i++] &lt;&lt; <span class="number">16</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">count</span> |= compiledPattern[i++];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">switch</span> (tag) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">case</span> TAG_QUOTE_ASCII_CHAR:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            toAppendTo.append((<span class="keyword">char</span>) <span class="keyword">count</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">case</span> TAG_QUOTE_CHARS:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            toAppendTo.append(compiledPattern, i, <span class="keyword">count</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            i += <span class="keyword">count</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">default</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            subFormat(tag, <span class="keyword">count</span>, delegate, toAppendTo, useDateFormatSymbols);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> toAppendTo;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>calendar.setTime(date)这条语句改变了calendar，稍后，calendar还会用到（在subFormat方法里），而这就是引发问题的根源。想象一下，在一个多线程环境下，有两个线程持有了同一个SimpleDateFormat的实例，分别调用format方法：<br>线程1调用format方法，改变了calendar这个字段。<br>中断来了。<br>线程2开始执行，它也改变了calendar。<br>又中断了。<br>线程1回来了，此时，calendar已然不是它所设的值，而是走上了线程2设计的道路。如果多个线程同时争抢calendar对象，则会出现各种问题，时间不对，线程挂死等等。<br>分析一下format的实现，我们不难发现，用到成员变量calendar，唯一的好处，就是在调用subFormat时，少了一个参数，却带来了这许多的问题。其实，只要在这里用一个局部变量，一路传递下去，所有问题都将迎刃而解。<br>这个问题背后隐藏着一个更为重要的问题–无状态：无状态方法的好处之一，就是它在各种环境下，都可以安全的调用。衡量一个方法是否是有状态的，就看它是否改动了其它的东西，比如全局变量，比如实例的字段。format方法在运行过程中改动了SimpleDateFormat的calendar字段，所以，它是有状态的。<br>这也同时提醒我们在开发和设计系统的时候注意下一下三点:<br>　　<strong>1.自己写公用类的时候，要对多线程调用情况下的后果在注释里进行明确说明</strong><br>　　<strong>2.对线程环境下，对每一个共享的可变变量都要注意其线程安全性</strong><br>　　*<em>3.我们的类和方法在做设计的时候，要尽量设计成无状态的<br>*</em></p>
<h2 id="三、解决办法"><a href="#三、解决办法" class="headerlink" title="*三、解决办法 *"></a>*<em>三、解决办法 *</em></h2><p>　　<strong>1.需要的时候创建新实例：</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package com.peidasoft.dateformat;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="built_in">text</span>.ParseException;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="built_in">text</span>.SimpleDateFormat;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateUtil</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">String</span> <span class="title">formatDate</span><span class="params">(Date date)</span>throws ParseException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> sdf.format(date);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">parse</span><span class="params">(<span class="keyword">String</span> strDate)</span> throws ParseException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> sdf.parse(strDate);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>说明：</strong>在需要用到SimpleDateFormat 的地方新建一个实例，不管什么时候，将有线程安全问题的对象由共享变为局部私有都能避免多线程问题，不过也加重了创建对象的负担。在一般情况下，这样其实对性能影响比不是很明显的。<br>　　<strong>2.使用同步：同步SimpleDateFormat对象</strong></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.peidasoft.dateformat;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateSyncUtil</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function">String <span class="title">formatDate</span><span class="params">(Date date)</span><span class="keyword">throws</span> ParseException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">synchronized</span>(sdf) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">return</span> sdf.<span class="title">format</span><span class="params">(date)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Date <span class="title">parse</span><span class="params">(String strDate)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">synchronized</span>(sdf) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">return</span> sdf.<span class="title">parse</span><span class="params">(strDate)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>说明：</strong>当线程较多时，当一个线程调用该方法时，其他想要调用此方法的线程就要block，多线程并发量大的时候会对性能有一定的影响。**<br>**<br>　　<strong>3.使用ThreadLocal：</strong>　</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package com.peidasoft.dateformat;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="built_in">text</span>.DateFormat;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="built_in">text</span>.ParseException;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="built_in">text</span>.SimpleDateFormat;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentDateUtil</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;DateFormat&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">protected</span> DateFormat initialValue() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">parse</span><span class="params">(<span class="keyword">String</span> dateStr)</span> throws ParseException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> threadLocal.<span class="built_in">get</span>().parse(dateStr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> <span class="title">format</span><span class="params">(Date date)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> threadLocal.<span class="built_in">get</span>().format(date);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>另外一种写法：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package com.peidasoft.dateformat;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="built_in">text</span>.DateFormat;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="built_in">text</span>.ParseException;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="built_in">text</span>.SimpleDateFormat;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDateUtil</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">String</span> date_format = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;DateFormat&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DateFormat <span class="title">getDateFormat</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        DateFormat df = threadLocal.<span class="built_in">get</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(df==null)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            df = <span class="keyword">new</span> SimpleDateFormat(date_format);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            threadLocal.<span class="built_in">set</span>(df);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> df;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> <span class="title">formatDate</span><span class="params">(Date date)</span> throws ParseException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> getDateFormat().format(date);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">parse</span><span class="params">(<span class="keyword">String</span> strDate)</span> throws ParseException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> getDateFormat().parse(strDate);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>说明：</strong>使用ThreadLocal, 也是将共享变量变为独享，线程独享肯定能比方法独享在并发环境中能减少不少创建对象的开销。如果对性能要求比较高的情况下，一般推荐使用这种方法。<br>　　*<em>4、抛弃JDK，使用其他类库中的时间格式化类：<br>*</em><br>　　1.使用Apache commons 里的FastDateFormat，宣称是既快又线程安全的SimpleDateFormat, 可惜它只能对日期进行format, 不能对日期串进行解析。<br>　　2.使用Joda-Time类库来处理时间相关问题<br>做一个简单的压力测试，方法一最慢，方法三最快，但是就算是最慢的方法一性能也不差，一般系统方法一和方法二就可以满足，所以说在这个点很难成为你系统的瓶颈所在。从简单的角度来说，建议使用方法一或者方法二，如果在必要的时候，追求那么一点性能提升的话，可以考虑用方法三，用ThreadLocal做缓存。<br>Joda-Time类库对时间处理方式比较完美，建议使用。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>1.<a href="http://dreamhead.blogbus.com/logs/215637834.html" target="_blank" rel="noopener">http://dreamhead.blogbus.com/logs/215637834.html</a><br>2.<a href="http://www.blogjava.net/killme2008/archive/2011/07/10/354062.html" target="_blank" rel="noopener">http://www.blogjava.net/killme2008/archive/2011/07/10/354062.html</a></p>
<blockquote>
<p>作者：peida</p>
<p>来源：<a href="https://www.cnblogs.com/peida/archive/2013/05/31/3070790.html" target="_blank" rel="noopener">https://www.cnblogs.com/peida/archive/2013/05/31/3070790.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring框架的设计理念与设计模式分析</title>
    <url>/2019/12/26/Spring%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Spring-的骨骼架构"><a href="#Spring-的骨骼架构" class="headerlink" title="Spring 的骨骼架构"></a>Spring 的骨骼架构</h1><p>Spring 总共有十几个组件，但是真正核心的组件只有几个，下面是 Spring 框架的总体架构图：</p>
<p>图 1 .Spring 框架的总体架构图</p>
<p><img src="http://image.winrains.cn/2019/08/85a7c-image001.gif" alt="图 1 .Spring 框架的总体架构图"><br>从上图中可以看出 Spring 框架中的核心组件只有三个：Core、Context 和 Beans。它们构建起了整个 Spring 的骨骼架构。没有它们就不可能有 AOP、Web 等上层的特性功能。下面也将主要从这三个组件入手分析 Spring。</p>
<a id="more"></a>

<h1 id="Spring-的设计理念"><a href="#Spring-的设计理念" class="headerlink" title="Spring 的设计理念"></a>Spring 的设计理念</h1><p>前面介绍了 Spring 的三个核心组件，如果再在它们三个中选出核心的话，那就非 Beans 组件莫属了，为何这样说，其实 Spring 就是面向 Bean 的编程（BOP,Bean Oriented Programming），Bean 在 Spring 中才是真正的主角。<br>Bean 在 Spring 中作用就像 Object 对 OOP 的意义一样，没有对象的概念就像没有面向对象编程，Spring 中没有 Bean 也就没有 Spring 存在的意义。就像一次演出舞台都准备好了但是却没有演员一样。为什么要 Bean 这种角色 Bean 或者为何在 Spring 如此重要，这由 Spring 框架的设计目标决定，Spring 为何如此流行，我们用 Spring 的原因是什么，想想你会发现原来 Spring 解决了一个非常关键的问题他可以让你把对象之间的依赖关系转而用配置文件来管理，也就是他的依赖注入机制。而这个注入关系在一个叫 Ioc 容器中管理，那 Ioc 容器就是被 Bean 包裹的对象。Spring 正是通过把对象包装在 Bean 中而达到对这些对象的管理以及一些列额外操作的目的。<br>它这种设计策略完全类似于 Java 实现 OOP 的设计理念，当然了 Java 本身的设计要比 Spring 复杂太多太多，但是都是构建一个数据结构，然后根据这个数据结构设计他的生存环境，并让它在这个环境中按照一定的规律在不停的运动，在它们的不停运动中设计一系列与环境或者与其他个体完成信息交换。这样想来我们用到的其他框架都是大慨类似的设计理念。</p>
<h1 id="核心组件如何协同工作"><a href="#核心组件如何协同工作" class="headerlink" title="核心组件如何协同工作"></a>核心组件如何协同工作</h1><p>前面说 Bean 是 Spring 中关键因素，那 Context 和 Core 又有何作用呢？前面把 Bean 比作一场演出中的演员的话，那 Context 就是这场演出的舞台背景，而 Core 应该就是演出的道具了。只有他们在一起才能具备演出一场好戏的最基本条件。当然有最基本的条件还不能使这场演出脱颖而出，还要他表演的节目足够的精彩，这些节目就是 Spring 能提供的特色功能了。<br>我们知道 Bean 包装的是 Object，而 Object 必然有数据，如何给这些数据提供生存环境就是 Context 要解决的问题，对 Context 来说他就是要发现每个 Bean 之间的关系，为它们建立这种关系并且要维护好这种关系。所以 Context 就是一个 Bean 关系的集合，这个关系集合又叫 Ioc 容器，一旦建立起这个 Ioc 容器后 Spring 就可以为你工作了。那 Core 组件又有什么用武之地呢？其实 Core 就是发现、建立和维护每个 Bean 之间的关系所需要的一些列的工具，从这个角度看来，Core 这个组件叫 Util 更能让你理解。<br>它们之间可以用下图来表示：</p>
<p>图 2. 三个组件关系</p>
<p><img src="http://image.winrains.cn/2019/08/d935d-image002.gif" alt="图 2. 三个组件关系"></p>
<h2 id="核心组件详解"><a href="#核心组件详解" class="headerlink" title="核心组件详解"></a>核心组件详解</h2><p>这里将详细介绍每个组件内部类的层次关系，以及它们在运行时的时序顺序。我们在使用 Spring 是应该注意的地方。</p>
<h3 id="Bean-组件"><a href="#Bean-组件" class="headerlink" title="Bean 组件"></a><strong>Bean 组件</strong></h3><p>前面已经说明了 Bean 组件对 Spring 的重要性，下面看看 Bean 这个组件式怎么设计的。Bean 组件在 Spring 的 <code>org.springframework.beans</code> 包下。这个包下的所有类主要解决了三件事：Bean 的定义、Bean 的创建以及对 Bean 的解析。对 Spring 的使用者来说唯一需要关心的就是 Bean 的创建，其他两个由 Spring 在内部帮你完成了，对你来说是透明的。<br>Spring Bean 的创建时典型的工厂模式，它的顶级接口是 BeanFactory，下图是这个工厂的继承层次关系：</p>
<p>图 4. Bean 工厂的继承关系</p>
<p><img src="http://image.winrains.cn/2019/08/73316-image003.png" alt="图 4. Bean 工厂的继承关系"><br>BeanFactory 有三个子类：ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory。但是从上图中我们可以发现最终的默认实现类是 DefaultListableBeanFactory，实现了所有的接口。那为何要定义这么多层次的接口呢？查阅这些接口的源码和说明发现，每个接口都有使用的场合，它主要是为了区分在 Spring 内部对象的传递和转化过程中，对对象的数据访问所做的限制。例如 ListableBeanFactory 接口表示这些 Bean 是可列表的，而 HierarchicalBeanFactory 表示的这些 Bean 是有继承关系的，也就是每个 Bean 有可能有父 Bean。AutowireCapableBeanFactory 接口定义 Bean 的自动装配规则。这四个接口共同定义了 Bean 的集合、Bean 之间的关系、以及 Bean 行为。<br>Bean 的定义主要有 BeanDefinition 描述，如下图说明了这些类的层次关系：</p>
<p>图 5. Bean 定义的类层次关系图</p>
<p><img src="http://image.winrains.cn/2019/08/ee2cc-image004.png" alt="图 5. Bean 定义的类层次关系图"><br>Bean 的定义就是完整的描述了在 Spring 的配置文件中你定义的 <code>节点中所有的信息，包括各种子节点。当 Spring 成功解析你定义的一个</code> 节点后，在 Spring 的内部就被转化成 BeanDefinition 对象。以后所有的操作都是对这个对象完成的。<br>Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean 的解析主要就是对 Spring 配置文件的解析。这个解析过程主要通过下图中的类完成：</p>
<p>图 6. Bean 的解析类</p>
<p><img src="http://image.winrains.cn/2019/08/48cea-image005.png" alt="图 6. Bean 的解析类"><br>当然还有具体对 tag 的解析这里并没有列出。</p>
<h3 id="Context-组件"><a href="#Context-组件" class="headerlink" title="Context 组件"></a><strong>Context 组件</strong></h3><p>Context 在 Spring 的 <code>org.springframework.context</code> 包下，前面已经讲解了 Context 组件在 Spring 中的作用，他实际上就是给 Spring 提供一个运行时的环境，用以保存各个对象的状态。下面看一下这个环境是如何构建的。<br>ApplicationContext 是 Context 的顶级父类，他除了能标识一个应用环境的基本信息外，他还继承了五个接口，这五个接口主要是扩展了 Context 的功能。下面是 Context 的类结构图：</p>
<p>图 7. Context 相关的类结构图</p>
<p><img src="http://image.winrains.cn/2019/08/d9893-origin_image006.png" alt="http://image.winrains.cn/2019/08/d9893-origin_image006.png"><br>从上图中可以看出 ApplicationContext 继承了 BeanFactory，这也说明了 Spring 容器中运行的主体对象是 Bean，另外 ApplicationContext 继承了 ResourceLoader 接口，使得 ApplicationContext 可以访问到任何外部资源，这将在 Core 中详细说明。<br>ApplicationContext 的子类主要包含两个方面：</p>
<ol>
<li>ConfigurableApplicationContext 表示该 Context 是可修改的，也就是在构建 Context 中用户可以动态添加或修改已有的配置信息，它下面又有多个子类，其中最经常使用的是可更新的 Context，即 AbstractRefreshableApplicationContext 类。</li>
<li>WebApplicationContext 顾名思义，就是为 web 准备的 Context 他可以直接访问到 ServletContext，通常情况下，这个接口使用的少。</li>
</ol>
<p>再往下分就是按照构建 Context 的文件类型，接着就是访问 Context 的方式。这样一级一级构成了完整的 Context 等级层次。<br>总体来说 ApplicationContext 必须要完成以下几件事：</p>
<ul>
<li>标识一个应用环境</li>
<li>利用 BeanFactory 创建 Bean 对象</li>
<li>保存对象关系表</li>
<li>能够捕获各种事件</li>
</ul>
<p>Context 作为 Spring 的 Ioc 容器，基本上整合了 Spring 的大部分功能，或者说是大部分功能的基础。</p>
<h3 id="Core-组件"><a href="#Core-组件" class="headerlink" title="Core 组件"></a><strong>Core 组件</strong></h3><p>Core 组件作为 Spring 的核心组件，他其中包含了很多的关键类，其中一个重要组成部分就是定义了资源的访问方式。这种把所有资源都抽象成一个接口的方式很值得在以后的设计中拿来学习。下面就重要看一下这个部分在 Spring 的作用。<br>下图是 Resource 相关的类结构图：</p>
<p>图 8. Resource 相关的类结构图</p>
<p><img src="http://image.winrains.cn/2019/08/ade75-origin_image007.png" alt="http://image.winrains.cn/2019/08/ade75-origin_image007.png"><br>从上图可以看出 Resource 接口封装了各种可能的资源类型，也就是对使用者来说屏蔽了文件类型的不同。对资源的提供者来说，如何把资源包装起来交给其他人用这也是一个问题，我们看到 Resource 接口继承了 InputStreamSource 接口，这个接口中有个 getInputStream 方法，返回的是 InputStream 类。这样所有的资源都被可以通过 InputStream 这个类来获取，所以也屏蔽了资源的提供者。另外还有一个问题就是加载资源的问题，也就是资源的加载者要统一，从上图中可以看出这个任务是由 ResourceLoader 接口完成，他屏蔽了所有的资源加载者的差异，只需要实现这个接口就可以加载所有的资源，他的默认实现是 DefaultResourceLoader。<br>下面看一下 Context 和 Resource 是如何建立关系的？首先看一下他们的类关系图：</p>
<p>图 9. Context 和 Resource 的类关系图</p>
<p><img src="http://image.winrains.cn/2019/08/e8449-image008.png" alt="图 9. Context 和 Resource 的类关系图"><br>从上图可以看出，Context 是把资源的加载、解析和描述工作委托给了 ResourcePatternResolver 类来完成，他相当于一个接头人，他把资源的加载、解析和资源的定义整合在一起便于其他组件使用。Core 组件中还有很多类似的方式。</p>
<h1 id="Ioc-容器如何工作"><a href="#Ioc-容器如何工作" class="headerlink" title="Ioc 容器如何工作"></a><strong>Ioc 容器如何工作</strong></h1><p>前面介绍了 Core 组件、Bean 组件和 Context 组件的结构与相互关系，下面这里从使用者角度看一下他们是如何运行的，以及我们如何让 Spring 完成各种功能，Spring 到底能有那些功能，这些功能是如何得来的，下面介绍。</p>
<h2 id="如何创建-BeanFactory-工厂"><a href="#如何创建-BeanFactory-工厂" class="headerlink" title="如何创建 BeanFactory 工厂"></a><strong>如何创建 BeanFactory 工厂</strong></h2><p>正如图 2 描述的那样，Ioc 容器实际上就是 Context 组件结合其他两个组件共同构建了一个 Bean 关系网，如何构建这个关系网？构建的入口就在 AbstractApplicationContext 类的 refresh 方法中。这个方法的代码如下：</p>
<p>清单 1. AbstractApplicationContext.refresh</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void refresh<span class="literal">()</span> throws BeansException, IllegalStateException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    synchronized (this.startupShutdownMonitor) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        prepare<span class="constructor">Refresh()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ConfigurableListableBeanFactory beanFactory = obtain<span class="constructor">FreshBeanFactory()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        prepare<span class="constructor">BeanFactory(<span class="params">beanFactory</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            post<span class="constructor">ProcessBeanFactory(<span class="params">beanFactory</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            invoke<span class="constructor">BeanFactoryPostProcessors(<span class="params">beanFactory</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            register<span class="constructor">BeanPostProcessors(<span class="params">beanFactory</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// Initialize message source for this context.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            init<span class="constructor">MessageSource()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            init<span class="constructor">ApplicationEventMulticaster()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            on<span class="constructor">Refresh()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            register<span class="constructor">Listeners()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            finish<span class="constructor">BeanFactoryInitialization(<span class="params">beanFactory</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            finish<span class="constructor">Refresh()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        catch (BeansException ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            destroy<span class="constructor">Beans()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// Reset 'active' flag.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            cancel<span class="constructor">Refresh(<span class="params">ex</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// Propagate exception to caller.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            throw ex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个方法就是构建整个 Ioc 容器过程的完整的代码，了解了里面的每一行代码基本上就了解大部分 Spring 的原理和功能了。<br>这段代码主要包含这样几个步骤：</p>
<ul>
<li>构建 BeanFactory，以便于产生所需的“演员”</li>
<li>注册可能感兴趣的事件</li>
<li>创建 Bean 实例对象</li>
<li>触发被监听的事件</li>
</ul>
<p>下面就结合代码分析这几个过程。<br>第二三句就是在创建和配置 BeanFactory。这里是 refresh 也就是刷新配置，前面介绍了 Context 有可更新的子类，这里正是实现这个功能，当 BeanFactory 已存在是就更新，如果没有就新创建。下面是更新 BeanFactory 的方法代码：</p>
<p>清单 2. AbstractRefreshableApplicationContext. refreshBeanFactory</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        destroyBeans();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        closeBeanFactory();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        beanFactory.setSerializationId(getId());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        customizeBeanFactory(beanFactory);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        loadBeanDefinitions(beanFactory);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.beanFactory = beanFactory;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">"I/O error parsing bean definition source for "</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            + getDisplayName(), ex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个方法实现了 <code>AbstractApplicationContext</code> 的抽象方法 <code>refreshBeanFactory</code>，这段代码清楚的说明了 <code>BeanFactory</code> 的创建过程。注意 <code>BeanFactory</code> 对象的类型的变化，前面介绍了他有很多子类，在什么情况下使用不同的子类这非常关键。<code>BeanFactory</code> 的原始对象是 <code>DefaultListableBeanFactory</code>，这个非常关键，因为他设计到后面对这个对象的多种操作，下面看一下这个类的继承层次类图：</p>
<p>图 10. DefaultListableBeanFactory 类继承关系图</p>
<p><img src="http://image.winrains.cn/2019/08/86f3d-origin_image009.png" alt="http://image.winrains.cn/2019/08/86f3d-origin_image009.png"><br>从这个图中发现除了 <code>BeanFactory</code> 相关的类外，还发现了与 Bean 的 register 相关。这在 <code>refreshBeanFactory</code> 方法中有一行 <code>loadBeanDefinitions(beanFactory)</code> 将找到答案，这个方法将开始加载、解析 Bean 的定义，也就是把用户定义的数据结构转化为 Ioc 容器中的特定数据结构。<br>这个过程可以用下面时序图解释：</p>
<p>图 11. 创建 BeanFactory 时序图</p>
<p><img src="http://image.winrains.cn/2019/08/d475a-origin_image010.png" alt="http://image.winrains.cn/2019/08/d475a-origin_image010.png"><br>Bean 的解析和登记流程时序图如下：</p>
<p>图 12. 解析和登记 Bean 对象时序图</p>
<p><img src="http://image.winrains.cn/2019/08/99248-origin_image011.png" alt="http://image.winrains.cn/2019/08/99248-origin_image011.png"><br>创建好 <code>BeanFactory</code> 后，接下去添加一些 Spring 本身需要的一些工具类，这个操作在 <code>AbstractApplicationContext</code> 的 <code>prepareBeanFactory</code> 方法完成。<br><code>AbstractApplicationContext</code> 中接下来的三行代码对 Spring 的功能扩展性起了至关重要的作用。前两行主要是让你现在可以对已经构建的 BeanFactory 的配置做修改，后面一行就是让你可以对以后再创建 Bean 的实例对象时添加一些自定义的操作。所以他们都是扩展了 Spring 的功能，所以我们要学习使用 Spring 必须对这一部分搞清楚。<br>其中在 <code>invokeBeanFactoryPostProcessors</code> 方法中主要是获取实现 <code>BeanFactoryPostProcessor</code> 接口的子类。并执行它的 <code>postProcessBeanFactory</code> 方法，这个方法的声明如下：</p>
<p>清单 3. BeanFactoryPostProcessor.postProcessBeanFactory</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">throws</span> BeansException;</span></pre></td></tr></table></figure>

<p>它的参数是 <code>beanFactory</code>，说明可以对 <code>beanFactory</code> 做修改，这里注意这个 <code>beanFactory</code> 是 <code>ConfigurableListableBeanFactory</code> 类型的，这也印证了前面介绍的不同 <code>BeanFactory</code> 所使用的场合不同，这里只能是可配置的 <code>BeanFactory</code>，防止一些数据被用户随意修改。<br><code>registerBeanPostProcessors</code> 方法也是可以获取用户定义的实现了 <code>BeanPostProcessor</code> 接口的子类，并执行把它们注册到 <code>BeanFactory</code> 对象中的 <code>beanPostProcessors</code> 变量中。<code>BeanPostProcessor</code> 中声明了两个方法：<code>postProcessBeforeInitialization</code>、<code>postProcessAfterInitialization</code> 分别用于在 Bean 对象初始化时执行。可以执行用户自定义的操作。<br>后面的几行代码是初始化监听事件和对系统的其他监听者的注册，监听者必须是 ApplicationListener 的子类。</p>
<h2 id="如何创建-Bean-实例并构建-Bean-的关系网"><a href="#如何创建-Bean-实例并构建-Bean-的关系网" class="headerlink" title="如何创建 Bean 实例并构建 Bean 的关系网"></a><strong>如何创建 Bean 实例并构建 Bean 的关系网</strong></h2><p>下面就是 Bean 的实例化代码，是从 <code>finishBeanFactoryInitialization</code> 方法开始的。</p>
<p>清单 4. AbstractApplicationContext.finishBeanFactoryInitialization</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> finishBeanFactoryInitialization(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ConfigurableListableBeanFactory beanFactory) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    beanFactory.freezeConfiguration();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    beanFactory.preInstantiateSingletons();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>从上面代码中可以发现 Bean 的实例化是在 <code>BeanFactory</code> 中发生的。<code>preInstantiateSingletons</code> 方法的代码如下：</p>
<p>清单 5. DefaultListableBeanFactory.preInstantiateSingletons</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.logger.info(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (String beanName : <span class="keyword">this</span>.beanDefinitionNames) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &amp;&amp; !bd.isLazyInit()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">final</span> FactoryBean factory =</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        (FactoryBean) getBean(FACTORY_BEAN_PREFIX+ beanName);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">boolean</span> isEagerInit;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                        &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        isEagerInit = AccessController.doPrivileged(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="keyword">public</span> <span class="function">Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                <span class="keyword">return</span> ((SmartFactoryBean) factory).isEagerInit();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        &#125;, getAccessControlContext());</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        isEagerInit = factory <span class="keyword">instanceof</span> SmartFactoryBean</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            &amp;&amp; ((SmartFactoryBean) factory).isEagerInit();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (isEagerInit) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        getBean(beanName);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    getBean(beanName);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里出现了一个非常重要的 Bean —— FactoryBean，可以说 Spring 一大半的扩展的功能都与这个 Bean 有关，这是个特殊的 Bean 是一个工厂 Bean，可以产生 Bean 的 Bean，这里的产生 Bean 是指 Bean 的实例，如果一个类继承 FactoryBean 用户只要实现他的 getObject 方法，就可以自己定义产生实例对象的方法。然而在 Spring 内部这个 Bean 的实例对象是 FactoryBean，通过调用这个对象的 getObject 方法就能获取用户自定义产生的对象，从而为 Spring 提供了很好的扩展性。Spring 获取 FactoryBean 本身的对象是在前面加上 &amp; 来完成的。<br>如何创建 Bean 的实例对象以及如何构建 Bean 实例对象之间的关联关系式 Spring 中的一个核心关键，下面是这个过程的流程图。</p>
<p>图 13.Bean 实例创建流程图</p>
<p><img src="http://image.winrains.cn/2019/08/7df0a-origin_image012.gif" alt="http://image.winrains.cn/2019/08/7df0a-origin_image012.gif"><br>如果是普通的 Bean 就直接创建他的实例，是通过调用 getBean 方法。下面是创建 Bean 实例的时序图：</p>
<p>图 14.Bean 实例创建时序图</p>
<p><img src="http://image.winrains.cn/2019/08/261b0-origin_image013.png" alt="http://image.winrains.cn/2019/08/261b0-origin_image013.png"><br>还有一个非常重要的部分就是建立 Bean 对象实例之间的关系，这也是 Spring 框架的核心竞争力，何时、如何建立他们之间的关系请看下面的时序图：</p>
<p>图 15.Bean 对象关系建立</p>
<p><img src="http://image.winrains.cn/2019/08/bc8a7-origin_image014.png" alt="http://image.winrains.cn/2019/08/bc8a7-origin_image014.png"></p>
<h2 id="Ioc-容器的扩展点"><a href="#Ioc-容器的扩展点" class="headerlink" title="Ioc 容器的扩展点"></a><strong>Ioc 容器的扩展点</strong></h2><p>现在还有一个问题就是如何让这些 Bean 对象有一定的扩展性，就是可以加入用户的一些操作。那么有哪些扩展点呢？ Spring 又是如何调用到这些扩展点的？<br>对 Spring 的 Ioc 容器来说，主要有这么几个。BeanFactoryPostProcessor， BeanPostProcessor。他们分别是在构建 BeanFactory 和构建 Bean 对象时调用。还有就是 InitializingBean 和 DisposableBean， 他们分别是在 Bean 实例创建和销毁时被调用。用户可以实现这些接口中定义的方法，Spring 就会在适当的时候调用他们。还有一个是 FactoryBean 他是个特殊的 Bean，这个 Bean 可以被用户更多的控制。<br>这些扩展点通常也是我们使用 Spring 来完成我们特定任务的地方，如何精通 Spring 就看你有没有掌握好 Spring 有哪些扩展点，并且如何使用他们，要知道如何使用他们就必须了解他们内在的机理。可以用下面一个比喻来解释。<br>我们把 Ioc 容器比作一个箱子，这个箱子里有若干个球的模子，可以用这些模子来造很多种不同的球，还有一个造这些球模的机器，这个机器可以产生球模。那么他们的对应关系就是：BeanFactory 是那个造球模的机器，球模就是 Bean，而球模造出来的球就是 Bean 的实例。那前面所说的几个扩展点又在什么地方呢？ BeanFactoryPostProcessor 对应到当造球模被造出来时，你将有机会可以对其做出适当的修正，也就是他可以帮你修改球模。而 InitializingBean 和 DisposableBean 是在球模造球的开始和结束阶段，你可以完成一些预备和扫尾工作。BeanPostProcessor 就可以让你对球模造出来的球做出适当的修正。最后还有一个 FactoryBean，它可是一个神奇的球模。这个球模不是预先就定型了，而是由你来给他确定它的形状，既然你可以确定这个球模型的形状，当然他造出来的球肯定就是你想要的球了，这样在这个箱子里你可以发现所有你想要的球。</p>
<h2 id="Ioc-容器如何为我所用"><a href="#Ioc-容器如何为我所用" class="headerlink" title="Ioc 容器如何为我所用"></a><strong>Ioc 容器如何为我所用</strong></h2><p>前面的介绍了 Spring 容器的构建过程，那 Spring 能为我们做什么，Spring 的 Ioc 容器又能做什么呢？我们使用 Spring 必须要首先构建 Ioc 容器，没有它 Spring 无法工作，ApplicatonContext.xml 就是 Ioc 容器的默认配置文件，Spring 的所有特性功能都是基于这个 Ioc 容器工作的，比如后面要介绍的 AOP。<br>Ioc 它实际上就是为你构建了一个魔方，Spring 为你搭好了骨骼架构，这个魔方到底能变出什么好的东西出来，这必须要有你的参与。那我们怎么参与？这就是前面说的要了解 Spring 中有哪些扩展点，我们通过实现那些扩展点来改变 Spring 的通用行为。至于如何实现扩展点来得到我们想要的个性结果，Spring 中有很多例子，其中 AOP 的实现就是 Spring 本身实现了其扩展点来达到了它想要的特性功能，可以拿来参考。</p>
<h1 id="Spring-中-AOP-特性详解"><a href="#Spring-中-AOP-特性详解" class="headerlink" title="Spring 中 AOP 特性详解"></a>Spring 中 AOP 特性详解</h1><h2 id="动态代理的实现原理"><a href="#动态代理的实现原理" class="headerlink" title="动态代理的实现原理"></a>动态代理的实现原理</h2><p>要了解 Spring 的 AOP 就必须先了解动态代理的原理，因为 AOP 就是基于动态代理实现的。动态代理还要从 JDK 本身说起。<br>在 Jdk 的 java.lang.reflect 包下有个 Proxy 类，它正是构造代理类的入口。这个类的结构入下：</p>
<p>图 16. Proxy 类结构</p>
<p><img src="http://image.winrains.cn/2019/08/90e4d-image015.png" alt="图 16. Proxy 类结构"><br>从上图发现最后面四个是公有方法。而最后一个方法 newProxyInstance 就是创建代理对象的方法。这个方法的源码如下：</p>
<p>清单 6. Proxy. newProxyInstance</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="keyword">new</span><span class="type">ProxyInstance</span>(ClassLoader loader,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Class&lt;?&gt;[] interfaces,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    InvocationHandler h)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    throws IllegalArgumentException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (h == <span class="literal">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NullPointerException</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Class cl = getProxyClass(loader, interfaces);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Constructor cons = cl.getConstructor(constructorParams);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> (Object) cons.<span class="keyword">new</span><span class="type">Instance</span>(<span class="keyword">new</span> <span class="type">Object</span>[] &#123; h &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InternalError</span>(e.toString());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InternalError</span>(e.toString());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InternalError</span>(e.toString());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InternalError</span>(e.toString());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个方法需要三个参数：ClassLoader，用于加载代理类的 Loader 类，通常这个 Loader 和被代理的类是同一个 Loader 类。Interfaces，是要被代理的那些那些接口。InvocationHandler，就是用于执行除了被代理接口中方法之外的用户自定义的操作，他也是用户需要代理的最终目的。用户调用目标方法都被代理到 InvocationHandler 类中定义的唯一方法 invoke 中。这在后面再详解。<br>下面还是看看 Proxy 如何产生代理类的过程，他构造出来的代理类到底是什么样子？下面揭晓啦。</p>
<p>图 17. 创建代理对象时序图</p>
<p><img src="http://image.winrains.cn/2019/08/bce42-image016.png" alt="图 17. 创建代理对象时序图"><br>其实从上图中可以发现正在构造代理类的是在 <code>ProxyGenerator</code> 的 <code>generateProxyClass</code> 的方法中。<code>ProxyGenerator</code> 类在 <code>sun.misc</code> 包下，感兴趣的话可以看看他的源码。<br>假如有这样一个接口，如下：</p>
<p>清单 7. SimpleProxy 类</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>SimpleProxy &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void simpleMethod1();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void simpleMethod2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>代理来生成的类结构如下：</p>
<p>清单 8. $Proxy2 类</p>
<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy2</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">reflect</span>.<span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">SimpleProxy</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    java.lang.reflect<span class="function">.<span class="keyword">Method</span> <span class="title">m0</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    java.lang.reflect<span class="function">.<span class="keyword">Method</span> <span class="title">m1</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    java.lang.reflect<span class="function">.<span class="keyword">Method</span> <span class="title">m2</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    java.lang.reflect<span class="function">.<span class="keyword">Method</span> <span class="title">m3</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    java.lang.reflect<span class="function">.<span class="keyword">Method</span> <span class="title">m4</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    int hashCode();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    boolean equals(java.lang.Object);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    java.lang.String toString();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void simpleMethod1();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void simpleMethod2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个类中的方法里面将会是调用 <code>InvocationHandler</code> 的 <code>invoke</code> 方法，而每个方法也将对应一个属性变量，这个属性变量 <code>m</code> 也将传给 <code>invoke</code> 方法中的 <code>Method</code> 参数。整个代理就是这样实现的。</p>
<h2 id="Spring-AOP-如何实现"><a href="#Spring-AOP-如何实现" class="headerlink" title="Spring AOP 如何实现"></a>Spring AOP 如何实现</h2><p>从前面代理的原理我们知道，代理的目的是调用目标方法时我们可以转而执行 <code>InvocationHandler</code> 类的 <code>invoke</code> 方法，所以如何在 <code>InvocationHandler</code> 上做文章就是 Spring 实现 Aop 的关键所在。<br>Spring 的 Aop 实现是遵守 Aop 联盟的约定。同时 Spring 又扩展了它，增加了如 Pointcut、Advisor 等一些接口使得更加灵活。<br>下面是 Jdk 动态代理的类图：</p>
<p>图 18. Jdk 动态代理的类图</p>
<p><img src="http://image.winrains.cn/2019/08/c1dc5-image017.png" alt="图 18. Jdk 动态代理的类图"><br>上图清楚的显示了 Spring 引用了 Aop Alliance 定义的接口。姑且不讨论 Spring 如何扩展 Aop Alliance，先看看 Spring 如何实现代理类的，要实现代理类在 Spring 的配置文件中通常是这样定一个 Bean 的，如下：</p>
<p>清单 9. 配置代理类 Bean</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"testBeanSingleton"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;property name=<span class="string">"proxyInterfaces"</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;value&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            org.springframework.aop.framework.PrototypeTargetTests$TestBean</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;<span class="regexp">/value&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    &lt;/</span>property&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;property name=<span class="string">"target"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"testBeanTarget"</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;property name=<span class="string">"singleton"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;property name=<span class="string">"interceptorNames"</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;list&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;value&gt;testInterceptor&lt;<span class="regexp">/value&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">            &lt;value&gt;testInterceptor2&lt;/</span>value&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;<span class="regexp">/list&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    &lt;/</span>property&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;<span class="regexp">/bean&gt;</span></span></pre></td></tr></table></figure>

<p>配置上看到要设置被代理的接口，和接口的实现类也就是目标类，以及拦截器也就在执行目标方法之前被调用，这里 Spring 中定义的各种各样的拦截器，可以选择使用。<br>下面看看 Spring 如何完成了代理以及是如何调用拦截器的。<br>前面提到 Spring Aop 也是实现其自身的扩展点来完成这个特性的，从这个代理类可以看出它正是继承了 FactoryBean 的 ProxyFactoryBean，FactoryBean 之所以特别就在于它可以让你自定义对象的创建方法。当然代理对象要通过 Proxy 类来动态生成。<br>下面是 Spring 创建的代理对象的时序图：</p>
<p>图 19.Spring 代理对象的产生</p>
<p><img src="http://image.winrains.cn/2019/08/e89a0-image018.png" alt="图 19.Spring 代理对象的产生"><br>Spring 创建了代理对象后，当你调用目标对象上的方法时，将都会被代理到 <code>InvocationHandler</code> 类的 <code>invoke</code> 方法中执行，这在前面已经解释。在这里 <code>JdkDynamicAopProxy</code> 类实现了 <code>InvocationHandler</code> 接口。<br>下面再看看 Spring 是如何调用拦截器的，下面是这个过程的时序图：</p>
<p>图 20.Spring 调用拦截器</p>
<p><img src="http://image.winrains.cn/2019/08/49225-image019.png" alt="图 20.Spring 调用拦截器"><br>以上所说的都是 Jdk 动态代理，Spring 还支持一种 CGLIB 类代理，感兴趣自己看吧。</p>
<h1 id="Spring-中设计模式分析"><a href="#Spring-中设计模式分析" class="headerlink" title="Spring 中设计模式分析"></a>Spring 中设计模式分析</h1><p>Spring 中使用的设计模式也很多，比如工厂模式、单例模式、模版模式等，在《 Webx 框架的系统架构与设计模式》、《 Tomcat 的系统架构与模式设计分析》已经有介绍，这里就不赘述了。这里主要介绍代理模式和策略模式。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="代理模式原理"><a href="#代理模式原理" class="headerlink" title="代理模式原理"></a><strong>代理模式原理</strong></h3><p>代理模式就是给某一个对象创建一个代理对象，而由这个代理对象控制对原对象的引用，而创建这个代理对象就是可以在调用原对象时增加一些额外的操作。下面是代理模式的结构：</p>
<p>图 21. 代理模式的结构</p>
<p><img src="http://image.winrains.cn/2019/08/62c55-image020.png" alt="图 21. 代理模式的结构"></p>
<ul>
<li>Subject：抽象主题，它是代理对象的真实对象要实现的接口，当然这可以由多个接口组成。</li>
<li>ProxySubject：代理类除了实现抽象主题定义的接口外，还必须持有所代理对象的引用</li>
<li>RealSubject：被代理的类，是目标对象。</li>
</ul>
<h3 id="Spring-中如何实现代理模式"><a href="#Spring-中如何实现代理模式" class="headerlink" title="Spring 中如何实现代理模式"></a><strong>Spring 中如何实现代理模式</strong></h3><p>Spring Aop 中 Jdk 动态代理就是利用代理模式技术实现的。在 Spring 中除了实现被代理对象的接口外，还会有 <code>org.springframework.aop.SpringProxy</code> 和 <code>org.springframework.aop.framework.Advised</code> 两个接口。Spring 中使用代理模式的结构图如下：</p>
<p>图 22. Spring 中使用代理模式的结构图</p>
<p><img src="http://image.winrains.cn/2019/08/9a290-image021.gif" alt="图 22. Spring 中使用代理模式的结构图"><br><code>$Proxy</code> 就是创建的代理对象，而 <code>Subject</code> 是抽象主题，代理对象是通过 <code>InvocationHandler</code> 来持有对目标对象的引用的。<br>Spring 中一个真实的代理对象结构如下：</p>
<p>清单 10 代理对象 $Proxy4</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">public class $Proxy4 <span class="keyword">extends </span><span class="keyword">java.lang.reflect.Proxy </span>implements</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">org.springframework.aop.framework.PrototypeTargetTests$TestBean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword"> </span>   <span class="keyword">org.springframework.aop.SpringProxy</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword"> </span>   <span class="keyword">org.springframework.aop.framework.Advised </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m16;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m9;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m25;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m5;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m23;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m18;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m26;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m6;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m28;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m14;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m12;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m27;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m11;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m22;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m8;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m4;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m19;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m7;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m15;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m20;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m10;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m17;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m21;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m13;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m24;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int hashCode();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int indexOf(<span class="keyword">org.springframework.aop.Advisor);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword"> </span>   int indexOf(<span class="keyword">org.aopalliance.aop.Advice);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword"> </span>   <span class="keyword">boolean </span>equals(<span class="keyword">java.lang.Object);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword"> </span>   <span class="keyword">java.lang.String </span>toString();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void sayhello();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void doSomething();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void doSomething2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.Class </span>getProxiedInterfaces();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">java.lang.Class </span>getTargetClass();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">boolean </span>isProxyTargetClass();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">org.springframework.aop.Advisor; </span>getAdvisors();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void <span class="keyword">addAdvisor(int, </span><span class="keyword">org.springframework.aop.Advisor)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword"> </span>       throws <span class="keyword">org.springframework.aop.framework.AopConfigException;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword"> </span>   void <span class="keyword">addAdvisor(org.springframework.aop.Advisor)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword"> </span>       throws <span class="keyword">org.springframework.aop.framework.AopConfigException;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword"> </span>   void setTargetSource(<span class="keyword">org.springframework.aop.TargetSource);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword"> </span>   <span class="keyword">org.springframework.aop.TargetSource </span>getTargetSource();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void setPreFiltered(<span class="keyword">boolean);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword"> </span>   <span class="keyword">boolean </span>isPreFiltered();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">boolean </span>isInterfaceProxied(<span class="keyword">java.lang.Class);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword"> </span>   <span class="keyword">boolean </span>removeAdvisor(<span class="keyword">org.springframework.aop.Advisor);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword"> </span>   void removeAdvisor(int)throws <span class="keyword">org.springframework.aop.framework.AopConfigException;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword"> </span>   <span class="keyword">boolean </span>replaceAdvisor(<span class="keyword">org.springframework.aop.Advisor,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword"> </span>       <span class="keyword">org.springframework.aop.Advisor)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword"> </span>       throws <span class="keyword">org.springframework.aop.framework.AopConfigException;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword"> </span>   void <span class="keyword">addAdvice(org.aopalliance.aop.Advice)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword"> </span>       throws <span class="keyword">org.springframework.aop.framework.AopConfigException;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword"> </span>   void <span class="keyword">addAdvice(int, </span><span class="keyword">org.aopalliance.aop.Advice)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword"> </span>       throws <span class="keyword">org.springframework.aop.framework.AopConfigException;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword"> </span>   <span class="keyword">boolean </span>removeAdvice(<span class="keyword">org.aopalliance.aop.Advice);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword"> </span>   <span class="keyword">java.lang.String </span>toProxyConfigString();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">boolean </span>isFrozen();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void setExposeProxy(<span class="keyword">boolean);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword"> </span>   <span class="keyword">boolean </span>isExposeProxy();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="策略模式原理"><a href="#策略模式原理" class="headerlink" title="策略模式原理"></a><strong>策略模式原理</strong></h3><p>策略模式顾名思义就是做某事的策略，这在编程上通常是指完成某个操作可能有多种方法，这些方法各有千秋，可能有不同的适应的场合，然而这些操作方法都有可能用到。各一个操作方法都当作一个实现策略，使用者可能根据需要选择合适的策略。<br>下面是策略模式的结构：</p>
<p>图 23. 策略模式的结构</p>
<p><img src="http://image.winrains.cn/2019/08/26822-image022.png" alt="图 23. 策略模式的结构"></p>
<ul>
<li>Context：使用不同策略的环境，它可以根据自身的条件选择不同的策略实现类来完成所要的操作。它持有一个策略实例的引用。创建具体策略对象的方法也可以由他完成。</li>
<li>Strategy：抽象策略，定义每个策略都要实现的策略方法</li>
<li>ConcreteStrategy：具体策略实现类，实现抽象策略中定义的策略方法</li>
</ul>
<h3 id="Spring-中策略模式的实现"><a href="#Spring-中策略模式的实现" class="headerlink" title="Spring 中策略模式的实现"></a><strong>Spring 中策略模式的实现</strong></h3><p>Spring 中策略模式使用有多个地方，如 Bean 定义对象的创建以及代理对象的创建等。这里主要看一下代理对象创建的策略模式的实现。<br>前面已经了解 Spring 的代理方式有两个 Jdk 动态代理和 CGLIB 代理。这两个代理方式的使用正是使用了策略模式。它的结构图如下所示：</p>
<p>图 24. Spring 中策略模式结构图</p>
<p><img src="http://image.winrains.cn/2019/08/8d793-image023.png" alt="图 24. Spring 中策略模式结构图"><br>在上面结构图中与标准的策略模式结构稍微有点不同，这里抽象策略是 <code>AopProxy</code> 接口，<code>Cglib2AopProxy</code> 和 <code>JdkDynamicAopProxy</code> 分别代表两种策略的实现方式，<code>ProxyFactoryBean</code> 就是代表 <code>Context</code> 角色，它根据条件选择使用 Jdk 代理方式还是 CGLIB 方式，而另外三个类主要是来负责创建具体策略对象，<code>ProxyFactoryBean</code> 是通过依赖的方法来关联具体策略对象的，它是通过调用策略对象的 <code>getProxy(ClassLoader classLoader)</code> 方法来完成操作。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>本文通过从 Spring 的几个核心组件入手，试图找出构建 Spring 框架的骨骼架构，进而分析 Spring 在设计时的一些设计理念，是否从中找出一些好的设计思想，对我们以后程序设计能提供一些思路。接着再详细分析了 Spring 中是如何实现这些理念的，以及在设计模式上是如何使用的。<br>通过分析 Spring 给我一个很大的启示就是这套设计理念其实对我们有很强的借鉴意义，它通过抽象复杂多变的对象，进一步做规范，然后根据它定义的这套规范设计出一个容器，容器中构建它们的复杂关系，其实现在有很多情况都可以用这种类似的处理方法。<br>虽然我很想把我对 Spring 的理解完全阐述清楚，但是所谓“书不尽言，言不尽意”。，有什么不对或者不清楚的地方大家还是看看其源码吧。</p>
<blockquote>
<p>作者：许令波</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 框架简介</title>
    <url>/2019/12/26/Spring-%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>Spring 是一个开源框架，是为了解决企业应用程序开发复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许您选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。<br>在这篇由三部分组成的 <em>Spring 系列</em> 的第 1 部分中，我将介绍 Spring 框架。我先从框架底层模型的角度描述该框架的功能，然后将讨论两个最有趣的模块：Spring 面向方面编程（AOP）和控制反转 （IOC） 容器。接着将使用几个示例演示 IOC 容器在典型应用程序用例场景中的应用情况。这些示例还将成为本系列后面部分进行的展开式讨论的基础，在本文的后面部分，将介绍 Spring 框架通过 Spring AOP 实现 AOP 构造的方式。<br>请参阅 <a href="https://www.ibm.com/developerworks/cn/java/wa-spring1/#artdownload" target="_blank" rel="noopener">下载</a>，下载 Spring 框架和 Apache Ant，运行本系列的示例应用程序需要它们。</p>
<a id="more"></a>

<h2 id="Spring-框架"><a href="#Spring-框架" class="headerlink" title="Spring 框架"></a>Spring 框架</h2><p>Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式，如图 1 所示。</p>
<p>图 1. Spring 框架的 7 个模块</p>
<p><img src="http://image.winrains.cn/2019/08/df481-spring_framework.gif" alt="Spring 框架图示"><br>组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：</p>
<ul>
<li><strong>核心容器</strong>：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 <code>BeanFactory</code>，它是工厂模式的实现。<code>BeanFactory</code> 使用<em>控制反转</em> （IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li>
<li><strong>Spring 上下文</strong>：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li>
<li><strong>Spring AOP</strong>：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</li>
<li><strong>Spring DAO</strong>：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li>
<li><strong>Spring ORM</strong>：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li>
<li><strong>Spring Web 模块</strong>：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li>
<li><strong>Spring MVC 框架</strong>：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li>
</ul>
<p>Spring 框架的功能可以用在任何 J2EE 服务器中，大多数功能也适用于不受管理的环境。Spring 的核心要点是：支持不绑定到特定 J2EE 服务的可重用业务和数据访问对象。毫无疑问，这样的对象可以在不同 J2EE 环境 （Web 或 EJB）、独立应用程序、测试环境之间重用。</p>
<h2 id="IOC-和-AOP"><a href="#IOC-和-AOP" class="headerlink" title="IOC 和 AOP"></a>IOC 和 AOP</h2><p>控制反转模式（也称作依赖性介入）的基本概念是：不创建对象，但是描述创建它们的方式。在代码中不直接与对象和服务连接，但在配置文件中描述哪一个组件需要哪一项服务。容器 （在 Spring 框架中是 IOC 容器） 负责将这些联系在一起。<br>在典型的 IOC 场景中，容器创建了所有对象，并设置必要的属性将它们连接在一起，决定什么时间调用方法。下表列出了 IOC 的一个实现模式。</p>
<table>
<thead>
<tr>
<th>类型 1</th>
<th>服务需要实现专门的接口，通过接口，由对象提供这些服务，可以从对象查询依赖性（例如，需要的附加服务）</th>
</tr>
</thead>
<tbody><tr>
<td>类型 2</td>
<td>通过 JavaBean 的属性（例如 setter 方法）分配依赖性</td>
</tr>
<tr>
<td>类型 3</td>
<td>依赖性以构造函数的形式提供，不以 JavaBean 属性的形式公开</td>
</tr>
</tbody></table>
<p>Spring 框架的 IOC 容器采用类型 2 和类型3 实现。</p>
<h3 id="面向方面的编程"><a href="#面向方面的编程" class="headerlink" title="面向方面的编程"></a>面向方面的编程</h3><p><em>面向方面的编程</em>，即 AOP，是一种编程技术，它允许程序员对横切关注点或横切典型的职责分界线的行为（例如日志和事务管理）进行模块化。AOP 的核心构造是<em>方面</em>，它将那些影响多个类的行为封装到可重用的模块中。<br>AOP 和 IOC 是补充性的技术，它们都运用模块化方式解决企业应用程序开发中的复杂问题。在典型的面向对象开发方式中，可能要将日志记录语句放在所有方法和 Java 类中才能实现日志功能。在 AOP 方式中，可以反过来将日志服务<em>模块化</em>，并以声明的方式将它们应用到需要日志的组件上。当然，优势就是 Java 类不需要知道日志服务的存在，也不需要考虑相关的代码。所以，用 Spring AOP 编写的应用程序代码是松散耦合的。<br>AOP 的功能完全集成到了 Spring 事务管理、日志和其他各种特性的上下文中。</p>
<h2 id="IOC-容器"><a href="#IOC-容器" class="headerlink" title="IOC 容器"></a>IOC 容器</h2><p>Spring 设计的核心是 <code>org.springframework.beans</code> 包，它的设计目标是与 JavaBean 组件一起使用。这个包通常不是由用户直接使用，而是由服务器将其用作其他多数功能的底层中介。下一个最高级抽象是 <code>BeanFactory</code> 接口，它是工厂设计模式的实现，允许通过名称创建和检索对象。<code>BeanFactory</code> 也可以管理对象之间的关系。<br><code>BeanFactory</code> 支持两个对象模型。</p>
<ul>
<li><strong>单态</strong> 模型提供了具有特定名称的对象的共享实例，可以在查询时对其进行检索。Singleton 是默认的也是最常用的对象模型。对于无状态服务对象很理想。</li>
<li><strong>原型</strong> 模型确保每次检索都会创建单独的对象。在每个用户都需要自己的对象时，原型模型最适合。</li>
</ul>
<p>bean 工厂的概念是 Spring 作为 IOC 容器的基础。IOC 将处理事情的责任从应用程序代码转移到框架。正如我将在下一个示例中演示的那样，Spring 框架使用 JavaBean 属性和配置数据来指出必须设置的依赖关系。</p>
<h3 id="BeanFactory-接口"><a href="#BeanFactory-接口" class="headerlink" title="BeanFactory 接口"></a>BeanFactory 接口</h3><p>因为 <code>org.springframework.beans.factory.BeanFactory</code> 是一个简单接口，所以可以针对各种底层存储方法实现。最常用的 <code>BeanFactory</code> 定义是 <code>XmlBeanFactory</code>，它根据 XML 文件中的定义装入 bean，如清单 1 所示。</p>
<p>清单 1. XmlBeanFactory</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">BeanFactory factory = <span class="keyword">new</span> <span class="type">XMLBeanFactory</span>(<span class="keyword">new</span> <span class="type">FileInputSteam</span>(<span class="string">"mybean.xml"</span>));</span></pre></td></tr></table></figure>

<p>在 XML 文件中定义的 Bean 是被消极加载的，这意味在需要 bean 之前，bean 本身不会被初始化。要从 <code>BeanFactory</code> 检索 bean，只需调用 <code>getBean()</code> 方法，传入将要检索的 bean 的名称即可，如清单 2 所示。</p>
<p>清单 2. getBean()</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">MyBean mybean</span> = (MyBean) factory.getBean(<span class="string">"mybean"</span>);</span></pre></td></tr></table></figure>

<p>每个 bean 的定义都可以是 POJO （用类名和 JavaBean 初始化属性定义） 或 <code>FactoryBean</code>。<code>FactoryBean</code> 接口为使用 Spring 框架构建的应用程序添加了一个间接的级别。</p>
<h2 id="IOC-示例"><a href="#IOC-示例" class="headerlink" title="IOC 示例"></a>IOC 示例</h2><p>理解控制反转最简单的方式就是看它的实际应用。在对由三部分组成的 <em>Spring 系列</em> 的第 1 部分进行总结时，我使用了一个示例，演示了如何通过 Spring IOC 容器注入应用程序的依赖关系（而不是将它们构建进来）。<br>我用开启在线信用帐户的用例作为起点。对于该实现，开启信用帐户要求用户与以下服务进行交互：</p>
<ul>
<li>信用级别评定服务，查询用户的信用历史信息。</li>
<li>远程信息链接服务，插入客户信息，将客户信息与信用卡和银行信息连接起来，以进行自动借记（如果需要的话）。</li>
<li>电子邮件服务，向用户发送有关信用卡状态的电子邮件。</li>
</ul>
<h2 id="三个接口"><a href="#三个接口" class="headerlink" title="三个接口"></a>三个接口</h2><p>对于这个示例，我假设服务已经存在，理想的情况是用松散耦合的方式把它们集成在一起。以下清单显示了三个服务的应用程序接口。</p>
<p>清单 3. CreditRatingInterface</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>CreditRatingInterface &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   public boolean getUserCreditHistoryInformation(ICustomer iCustomer);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>清单 3 所示的信用级别评定接口提供了信用历史信息。它需要一个包含客户信息的 <code>Customer</code> 对象。该接口的实现是由 <code>CreditRating</code> 类提供的。</p>
<p>清单 4. CreditLinkingInterface</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CreditLinkingInterface</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">linkCreditBankAccount</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>信用链接接口将信用历史信息与银行信息（如果需要的话）连接在一起，并插入用户的信用卡信息。信用链接接口是一个远程服务，它的查询是通过 <code>getUrl()</code> 方法进行的。URL 由 Spring 框架的 bean 配置机制设置，我稍后会讨论它。该接口的实现是由 <code>CreditLinking</code> 类提供的。</p>
<p>清单 5. EmailInterface</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface EmailInterface &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">(ICustomer iCustomer)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getFromEmail</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFromEmail</span><span class="params">(<span class="keyword">String</span> fromEmail)</span> </span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getPassword</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(<span class="keyword">String</span> password)</span> </span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getSmtpHost</span><span class="params">()</span> </span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSmtpHost</span><span class="params">(<span class="keyword">String</span> smtpHost)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getUserId</span><span class="params">()</span> </span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(<span class="keyword">String</span> userId)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>EmailInterface</code> 负责向客户发送关于客户信用卡状态的电子邮件。邮件配置参数（例如 SMPT 主机、用户名、口令）由前面提到的 bean 配置机制设置。<code>Email</code> 类提供了该接口的实现。</p>
<h2 id="Spring-使其保持松散"><a href="#Spring-使其保持松散" class="headerlink" title="Spring 使其保持松散"></a>Spring 使其保持松散</h2><p>这些接口就位之后，接下来要考虑的就是如何用松散耦合方式将它们集成在一起。在 <a href="https://www.ibm.com/developerworks/cn/java/wa-spring1/listing1.html" target="_blank" rel="noopener">清单 6</a> 中可以看到信用卡帐户用例的实现。<br>注意，所有的 setter 方法都是由 Spring 的配置 bean 实现的。所有的依赖关系 （也就是三个接口）都可以由 Spring 框架用这些 bean 注入。<code>createCreditCardAccount()</code> 方法会用服务去执行其余实现。在 <a href="https://www.ibm.com/developerworks/cn/java/wa-spring1/listing2.html" target="_blank" rel="noopener">清单 7 </a> 中可以看到 Spring 的配置文件。我用箭头突出了这些定义。</p>
<h2 id="运行应用程序"><a href="#运行应用程序" class="headerlink" title="运行应用程序"></a>运行应用程序</h2><p>要运行示例应用程序，首先必须 <a href="http://prdownloads.sourceforge.net/" target="_blank" rel="noopener">下载 Spring 框架</a> 及其所有依赖文件。接下来，将框架释放到（比如说）磁盘 <em>c:*，这会创建 *C:\spring-framework-1.2-rc2</em> （适用于当前发行版本） 这样的文件夹。在继续后面的操作之前，还必须下载和释放 <a href="http://ant.apache.org/" target="_blank" rel="noopener">Apache Ant</a>。<br>接下来，将源代码释放到文件夹，例如 <em>c:\</em> 盘，然后创建 <em>SpringProject*。将 Spring 库（即 *C:\spring-framework-1.2-rc2\dist</em> 下的 <em>spring.jar</em> 和 <em>C:\spring-framework-1.2-rc2\lib\jakarta-commons</em> 下的 <em>commons-logging.jar*）复制到 *SpringProject\lib</em> 文件夹中。完成这些工作之后，就有了必需的构建依赖关系集。<br>打开命令提示符，将当前目录切换到 <em>SpringProject</em>，在命令提示符中输入以下命令：<code>build</code>。<br>这会构建并运行 <code>CreateCreditAccountClient</code> 类，类的运行将创建 <code>Customer</code> 类对象并填充它，还会调用 <code>CreateCreditCardAccount</code> 类创建并链接信用卡帐户。<code>CreateCreditAccountClient</code> 还会通过 <code>ClassPathXmlApplicationContext</code> 装入 Spring 配置文件。装入 bean 之后，就可以通过 <code>getBean()</code> 方法访问它们了，如清单 8 所示。</p>
<p>清单 8. 装入 Spring 配置文件</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ClassPathXmlApplicationContext appContext</span> = new ClassPathXmlApplicationContext(new String[] &#123;<span class="string">"springexample-creditaccount.xml"</span>&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attribute">CreateCreditCardAccountInterface creditCardAccount</span> = (CreateCreditCardAccountInterface) appContext.getBean(<span class="string">"createCreditCard"</span>);</span></pre></td></tr></table></figure>

<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>在这篇由三部分组成的 <em>Spring 系列</em> 的第一篇文章中，我介绍了 Spring 框架的基础。我从讨论组成 Spring 分层架构的 7 个模块开始，然后深入介绍了其中两个模块：Spring AOP 和 IOC 容器。<br>由于学习的最佳方法是实践，所以我用一个工作示例介绍了 IOC 模式 （像 Spring 的 IOC 容器实现的那样）如何用松散耦合的方式将分散的系统集成在一起。在这个示例中可以看到，将依赖关系或服务注入工作中的信用卡帐户应用程序，要比从头开始构建它们容易得多。<br>请继续关注这一系列的下一篇文章，我将在这里学习的知识基础上，介绍 Spring AOP 模块如何在企业应用程序中提供持久支持，并让您开始了解 Spring MVC 模块和相关插件。</p>
<blockquote>
<p>作者：Naveen Balani</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/wa-spring1/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/wa-spring1/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Tomcat 系统架构与设计模式工作原理</title>
    <url>/2019/12/26/Tomcat-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>本文以 Tomcat 5 为基础，也兼顾最新的 Tomcat 6 和 Tomcat 4。Tomcat 的基本设计思路和架构是具有一定连续性的。</p>
<h2 id="Tomcat-总体结构"><a href="#Tomcat-总体结构" class="headerlink" title="Tomcat 总体结构"></a>Tomcat 总体结构</h2><p>Tomcat 的结构很复杂，但是 Tomcat 也非常的模块化，找到了 Tomcat 最核心的模块，您就抓住了 Tomcat 的“七寸”。下面是 Tomcat 的总体结构图：</p>
<p>图 1.Tomcat 的总体结构</p>
<p><img src="http://image.winrains.cn/2019/08/7df0a-image001.gif" alt="图 1.Tomcat 的总体结构"><br>从上图中可以看出 Tomcat 的心脏是两个组件：Connector 和 Container，关于这两个组件将在后面详细介绍。Connector 组件是可以被替换，这样可以提供给服务器设计者更多的选择，因为这个组件是如此重要，不仅跟服务器的设计的本身，而且和不同的应用场景也十分相关，所以一个 Container 可以选择对应多个 Connector。多个 Connector 和一个 Container 就形成了一个 Service，Service 的概念大家都很熟悉了，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了。所以整个 Tomcat 的生命周期由 Server 控制。</p>
<h3 id="以-Service-作为“婚姻”"><a href="#以-Service-作为“婚姻”" class="headerlink" title="以 Service 作为“婚姻”"></a>以 Service 作为“婚姻”</h3><p>我们将 Tomcat 中 Connector、Container 作为一个整体比作一对情侣的话，Connector 主要负责对外交流，可以比作为 Boy，Container 主要处理 Connector 接受的请求，主要是处理内部事务，可以比作为 Girl。那么这个 Service 就是连接这对男女的结婚证了。是 Service 将它们连接在一起，共同组成一个家庭。当然要组成一个家庭还要很多其它的元素。<br>说白了，Service 只是在 Connector 和 Container 外面多包一层，把它们组装在一起，向外面提供服务，一个 Service 可以设置多个 Connector，但是只能有一个 Container 容器。这个 Service 接口的方法列表如下：</p>
<p>图 2. Service 接口</p>
<p><img src="http://image.winrains.cn/2019/08/4effe-image002.png" alt="图 2. Service 接口"><br>从 Service 接口中定义的方法中可以看出，它主要是为了关联 Connector 和 Container，同时会初始化它下面的其它组件，注意接口中它并没有规定一定要控制它下面的组件的生命周期。所有组件的生命周期在一个 Lifecycle 的接口中控制，这里用到了一个重要的设计模式，关于这个接口将在后面介绍。<br>Tomcat 中 Service 接口的标准实现类是 StandardService 它不仅实现了 Service 借口同时还实现了 Lifecycle 接口，这样它就可以控制它下面的组件的生命周期了。StandardService 类结构图如下：</p>
<p>图 3. StandardService 的类结构图</p>
<p><img src="http://image.winrains.cn/2019/08/3b6fe-image003.png" alt="图 3. StandardService 的类结构图"><br>从上图中可以看出除了 Service 接口的方法的实现以及控制组件生命周期的 Lifecycle 接口的实现，还有几个方法是用于在事件监听的方法的实现，不仅是这个 Service 组件，Tomcat 中其它组件也同样有这几个方法，这也是一个典型的设计模式，将在后面介绍。<br>下面看一下 StandardService 中主要的几个方法实现的代码，下面是 setContainer 和 addConnector 方法的源码：</p>
<p>清单 1. StandardService. SetContainer</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> setContainer(Container <span class="keyword">container</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Container oldContainer = <span class="keyword">this</span>.<span class="keyword">container</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> ((oldContainer != <span class="keyword">null</span>) &amp;&amp; (oldContainer instanceof Engine))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ((Engine) oldContainer).setService(<span class="keyword">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">this</span>.<span class="keyword">container</span> = <span class="keyword">container</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> ((<span class="keyword">this</span>.<span class="keyword">container</span> != <span class="keyword">null</span>) &amp;&amp; (<span class="keyword">this</span>.<span class="keyword">container</span> instanceof Engine))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ((Engine) <span class="keyword">this</span>.<span class="keyword">container</span>).setService(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (started &amp;&amp; (<span class="keyword">this</span>.<span class="keyword">container</span> != <span class="keyword">null</span>) &amp;&amp; (<span class="keyword">this</span>.<span class="keyword">container</span> instanceof Lifecycle)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ((Lifecycle) <span class="keyword">this</span>.<span class="keyword">container</span>).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    synchronized (connectors) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connectors.length; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            connectors[i].setContainer(<span class="keyword">this</span>.<span class="keyword">container</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (started &amp;&amp; (oldContainer != <span class="keyword">null</span>) &amp;&amp; (oldContainer instanceof Lifecycle)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ((Lifecycle) oldContainer).stop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    support.firePropertyChange(<span class="string">"container"</span>, oldContainer, <span class="keyword">this</span>.<span class="keyword">container</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这段代码很简单，其实就是先判断当前的这个 Service 有没有已经关联了 Container，如果已经关联了，那么去掉这个关联关系—— oldContainer.setService(null)。如果这个 oldContainer 已经被启动了，结束它的生命周期。然后再替换新的关联、再初始化并开始这个新的 Container 的生命周期。最后将这个过程通知感兴趣的事件监听程序。这里值得注意的地方就是，修改 Container 时要将新的 Container 关联到每个 Connector，还好 Container 和 Connector 没有双向关联，不然这个关联关系将会很难维护。</p>
<p>清单 2. StandardService. addConnector</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void add<span class="constructor">Connector(Connector <span class="params">connector</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    synchronized (connectors) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        connector.set<span class="constructor">Container(<span class="params">this</span>.<span class="params">container</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        connector.set<span class="constructor">Service(<span class="params">this</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Connector results<span class="literal">[]</span> = <span class="keyword">new</span> Connector<span class="literal">[<span class="identifier">connectors</span>.<span class="identifier">length</span> + <span class="number">1</span>]</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>arraycopy(connectors, <span class="number">0</span>, results, <span class="number">0</span>, connectors.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        results<span class="literal">[<span class="identifier">connectors</span>.<span class="identifier">length</span>]</span> = connector;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        connectors = results;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (initialized) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                connector.initialize<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; catch (LifecycleException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                e.print<span class="constructor">StackTrace(System.<span class="params">err</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (started<span class="operator"> &amp;&amp; </span>(connector instanceof Lifecycle)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ((Lifecycle) connector).start<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; catch (LifecycleException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        support.fire<span class="constructor">PropertyChange(<span class="string">"connector"</span>, <span class="params">null</span>, <span class="params">connector</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面是 addConnector 方法，这个方法也很简单，首先是设置关联关系，然后是初始化工作，开始新的生命周期。这里值得一提的是，注意 Connector 用的是数组而不是 List 集合，这个从性能角度考虑可以理解，有趣的是这里用了数组但是并没有向我们平常那样，一开始就分配一个固定大小的数组，它这里的实现机制是：重新创建一个当前大小的数组对象，然后将原来的数组对象 copy 到新的数组中，这种方式实现了类似的动态数组的功能，这种实现方式，值得我们以后拿来借鉴。<br>最新的 Tomcat6 中 StandardService 也基本没有变化，但是从 Tomcat5 开始 Service、Server 和容器类都继承了 MBeanRegistration 接口，Mbeans 的管理更加合理。</p>
<h3 id="以-Server-为“居”"><a href="#以-Server-为“居”" class="headerlink" title="以 Server 为“居”"></a>以 Server 为“居”</h3><p>前面说一对情侣因为 Service 而成为一对夫妻，有了能够组成一个家庭的基本条件，但是它们还要有个实体的家，这是它们在社会上生存之本，有了家它们就可以安心的为人民服务了，一起为社会创造财富。<br>Server 要完成的任务很简单，就是要能够提供一个接口让其它程序能够访问到这个 Service 集合、同时要维护它所包含的所有 Service 的生命周期，包括如何初始化、如何结束服务、如何找到别人要访问的 Service。还有其它的一些次要的任务，如您住在这个地方要向当地政府去登记啊、可能还有要配合当地公安机关日常的安全检查什么的。<br>Server 的类结构图如下：</p>
<p>图 4. Server 的类结构图</p>
<p><img src="http://image.winrains.cn/2019/08/21b96-image004.png" alt="图 4. Server 的类结构图"><br>它的标准实现类 StandardServer 实现了上面这些方法，同时也实现了 Lifecycle、MbeanRegistration 两个接口的所有方法，下面主要看一下 StandardServer 重要的一个方法 addService 的实现：</p>
<p>清单 3. StandardServer.addService</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public void addService(Service service) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    service.setServer(this);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    synchronized (services) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="built_in"> Service </span>results[] = new Service[services.length + 1];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.arraycopy(services, 0, results, 0, services.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        results[services.length] = service;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        services = results;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (initialized) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            try &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                service.initialize();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; catch (LifecycleException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                e.printStackTrace(System.err);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (started &amp;&amp; (service instanceof Lifecycle)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            try &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ((Lifecycle) service).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; catch (LifecycleException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        support.firePropertyChange(<span class="string">"service"</span>, <span class="literal">null</span>, service);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>从上面第一句就知道了 Service 和 Server 是相互关联的，Server 也是和 Service 管理 Connector 一样管理它，也是将 Service 放在一个数组中，后面部分的代码也是管理这个新加进来的 Service 的生命周期。Tomcat6 中也是没有什么变化的。</p>
<h3 id="组件的生命线“Lifecycle”"><a href="#组件的生命线“Lifecycle”" class="headerlink" title="组件的生命线“Lifecycle”"></a>组件的生命线“Lifecycle”</h3><p>前面一直在说 Service 和 Server 管理它下面组件的生命周期，那它们是如何管理的呢？<br>Tomcat 中组件的生命周期是通过 Lifecycle 接口来控制的，组件只要继承这个接口并实现其中的方法就可以统一被拥有它的组件控制了，这样一层一层的直到一个最高级的组件就可以控制 Tomcat 中所有组件的生命周期，这个最高的组件就是 Server，而控制 Server 的是 Startup，也就是您启动和关闭 Tomcat。<br>下面是 Lifecycle 接口的类结构图：</p>
<p>图 5. Lifecycle 类结构图</p>
<p><img src="http://image.winrains.cn/2019/08/da1c6-image005.png" alt="图 5. Lifecycle 类结构图"><br>除了控制生命周期的 Start 和 Stop 方法外还有一个监听机制，在生命周期开始和结束的时候做一些额外的操作。这个机制在其它的框架中也被使用，如在 Spring 中。关于这个设计模式会在后面介绍。<br>Lifecycle 接口的方法的实现都在其它组件中，就像前面中说的，组件的生命周期由包含它的父组件控制，所以它的 Start 方法自然就是调用它下面的组件的 Start 方法，Stop 方法也是一样。如在 Server 中 Start 方法就会调用 Service 组件的 Start 方法，Server 的 Start 方法代码如下：</p>
<p>清单 4. StandardServer.Start</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (started) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        log.debug(sm.getString(<span class="string">"standardServer.start.started"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, <span class="keyword">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    lifecycle.fireLifecycleEvent(START_EVENT, <span class="keyword">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    started = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">synchronized</span> (services) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; services.length; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (services[i] <span class="keyword">instanceof</span> Lifecycle)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ((Lifecycle) services[i]).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    lifecycle.fireLifecycleEvent(AFTER_START_EVENT, <span class="keyword">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>监听的代码会包围 Service 组件的启动过程，就是简单的循环启动所有 Service 组件的 Start 方法，但是所有 Service 必须要实现 Lifecycle 接口，这样做会更加灵活。<br>Server 的 Stop 方法代码如下：</p>
<p>清单 5. StandardServer.Stop</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!started)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    lifecycle.fireLifecycleEvent(BEFORE_STOP_EVENT, <span class="keyword">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    lifecycle.fireLifecycleEvent(STOP_EVENT, <span class="keyword">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    started = <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; services.length; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (services[i] <span class="keyword">instanceof</span> Lifecycle)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ((Lifecycle) services[i]).stop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    lifecycle.fireLifecycleEvent(AFTER_STOP_EVENT, <span class="keyword">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>它所要做的事情也和 Start 方法差不多。</p>
<h2 id="Connector-组件"><a href="#Connector-组件" class="headerlink" title="Connector 组件"></a>Connector 组件</h2><p>Connector 组件是 Tomcat 中两个核心组件之一，它的主要任务是负责接收浏览器的发过来的 tcp 连接请求，创建一个 Request 和 Response 对象分别用于和请求端交换数据，然后会产生一个线程来处理这个请求并把产生的 Request 和 Response 对象传给处理这个请求的线程，处理这个请求的线程就是 Container 组件要做的事了。<br>由于这个过程比较复杂，大体的流程可以用下面的顺序图来解释：</p>
<p>图 6. Connector 处理一次请求顺序图</p>
<p><img src="http://image.winrains.cn/2019/08/31981-origin_image006.png" alt="http://image.winrains.cn/2019/08/31981-origin_image006.png"><br>Tomcat5 中默认的 Connector 是 Coyote，这个 Connector 是可以选择替换的。Connector 最重要的功能就是接收连接请求然后分配线程让 Container 来处理这个请求，所以这必然是多线程的，多线程的处理是 Connector 设计的核心。Tomcat5 将这个过程更加细化，它将 Connector 划分成 Connector、Processor、Protocol, 另外 Coyote 也定义自己的 Request 和 Response 对象。<br>下面主要看一下 Tomcat 中如何处理多线程的连接请求，先看一下 Connector 的主要类图：</p>
<p>图 7. Connector 的主要类图</p>
<p><img src="http://image.winrains.cn/2019/08/de069-origin_image007.png" alt="http://image.winrains.cn/2019/08/de069-origin_image007.png"><br>看一下 HttpConnector 的 Start 方法：</p>
<p>清单 6. HttpConnector.Start</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public void start() throws LifecycleException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (started)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw new LifecycleException</span></pre></td></tr><tr><td class="code"><pre><span class="line">            (sm.getString(<span class="string">"httpConnector.alreadyStarted"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    threadName = <span class="string">"HttpConnector["</span> +<span class="built_in"> port </span>+ <span class="string">"]"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    lifecycle.fireLifecycleEvent(START_EVENT, <span class="literal">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    started = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    threadStart();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (curProcessors &lt; minProcessors) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((maxProcessors &gt; 0) &amp;&amp; (curProcessors &gt;= maxProcessors))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            break;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        HttpProcessor processor = newProcessor();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        recycle(processor);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>threadStart() 执行就会进入等待请求的状态，直到一个新的请求到来才会激活它继续执行，这个激活是在 HttpProcessor 的 assign 方法中，这个方法是代码如下 <code>：</code></p>
<p>清单 7. HttpProcessor.assign</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function">synchronized <span class="keyword">void</span> <span class="title">assign</span><span class="params">(Socket socket)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="built_in">available</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            wait();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">this</span>.socket = socket;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">available</span> = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    notifyAll();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> ((debug &gt;= <span class="number">1</span>) &amp;&amp; (socket != null))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">log</span>(<span class="string">" An incoming request is being assigned"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>创建 HttpProcessor 对象是会把 available 设为 false，所以当请求到来时不会进入 while 循环，将请求的 socket 赋给当期处理的 socket，并将 available 设为 true，当 available 设为 true 是 HttpProcessor 的 run 方法将被激活，接下去将会处理这次请求。<br>Run 方法代码如下：</p>
<p>清单 8. HttpProcessor.Run</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (!stopped) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Socket socket = await();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (socket == null)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">process</span>(socket);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">log</span>(<span class="string">"process.invoke"</span>, t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        connector.recycle(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    synchronized (threadSync) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        threadSync.notifyAll();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>解析 socket 的过程在 process 方法中，process 方法的代码片段如下：</p>
<p>清单 9. HttpProcessor.process</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void process(Socket socket) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    boolean ok = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    boolean finishResponse = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    SocketInputStream input = null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    OutputStream output = null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        input = <span class="keyword">new</span> <span class="constructor">SocketInputStream(<span class="params">socket</span>.<span class="params">getInputStream</span>()</span>,connector.get<span class="constructor">BufferSize()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; catch (Exception e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        log(<span class="string">"process.create"</span>, e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ok = <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    keepAlive = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (!stopped<span class="operator"> &amp;&amp; </span>ok<span class="operator"> &amp;&amp; </span>keepAlive) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        finishResponse = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            request.set<span class="constructor">Stream(<span class="params">input</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            request.set<span class="constructor">Response(<span class="params">response</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            output = socket.get<span class="constructor">OutputStream()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            response.set<span class="constructor">Stream(<span class="params">output</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            response.set<span class="constructor">Request(<span class="params">request</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ((HttpServletResponse) response.get<span class="constructor">Response()</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .set<span class="constructor">Header(<span class="string">"Server"</span>, SERVER_INFO)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; catch (Exception e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            log(<span class="string">"process.create"</span>, e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ok = <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (ok) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                parse<span class="constructor">Connection(<span class="params">socket</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                parse<span class="constructor">Request(<span class="params">input</span>, <span class="params">output</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (!request.get<span class="constructor">Request()</span>.get<span class="constructor">Protocol()</span>.starts<span class="constructor">With(<span class="string">"HTTP/0"</span>)</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    parse<span class="constructor">Headers(<span class="params">input</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (http11) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    ack<span class="constructor">Request(<span class="params">output</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (connector.is<span class="constructor">ChunkingAllowed()</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        response.set<span class="constructor">AllowChunking(<span class="params">true</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        。。。。。。</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ((HttpServletResponse) response).setHeader</span></pre></td></tr><tr><td class="code"><pre><span class="line">                (<span class="string">"Date"</span>, <span class="module-access"><span class="module"><span class="identifier">FastHttpDateFormat</span>.</span></span>get<span class="constructor">CurrentDate()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (ok) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                connector.get<span class="constructor">Container()</span>.invoke(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            。。。。。。</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            shutdown<span class="constructor">Input(<span class="params">input</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            socket.close<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; catch (IOException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; catch (Throwable e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            log(<span class="string">"process.invoke"</span>, e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    socket = null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>当 Connector 将 socket 连接封装成 request 和 response 对象后接下来的事情就交给 Container 来处理了。</p>
<h2 id="Servlet-容器“Container”"><a href="#Servlet-容器“Container”" class="headerlink" title="Servlet 容器“Container”"></a>Servlet 容器“Container”</h2><p>Container 是容器的父接口，所有子容器都必须实现这个接口，Container 容器的设计用的是典型的责任链的设计模式，它有四个子容器组件构成，分别是：Engine、Host、Context、Wrapper，这四个组件不是平行的，而是父子关系，Engine 包含 Host,Host 包含 Context，Context 包含 Wrapper。通常一个 Servlet class 对应一个 Wrapper，如果有多个 Servlet 就可以定义多个 Wrapper，如果有多个 Wrapper 就要定义一个更高的 Container 了，如 Context，Context 通常就是对应下面这个配置：</p>
<p>清单 10. Server.xml</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;Context</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">path</span>=<span class="string">"/library"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">docBase</span>=<span class="string">"D:\projects\library\deploy\target\library.war"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">reloadable</span>=<span class="string">"true"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">/&gt;</span></pre></td></tr></table></figure>

<h3 id="容器的总体设计"><a href="#容器的总体设计" class="headerlink" title="容器的总体设计"></a>容器的总体设计</h3><p>Context 还可以定义在父容器 Host 中，Host 不是必须的，但是要运行 war 程序，就必须要 Host，因为 war 中必有 web.xml 文件，这个文件的解析就需要 Host 了，如果要有多个 Host 就要定义一个 top 容器 Engine 了。而 Engine 没有父容器了，一个 Engine 代表一个完整的 Servlet 引擎。<br>那么这些容器是如何协同工作的呢？先看一下它们之间的关系图：</p>
<p>图 8. 四个容器的关系图</p>
<p><img src="http://image.winrains.cn/2019/08/186db-origin_image008.png" alt="http://image.winrains.cn/2019/08/186db-origin_image008.png"><br>当 Connector 接受到一个连接请求时，将请求交给 Container，Container 是如何处理这个请求的？这四个组件是怎么分工的，怎么把请求传给特定的子容器的呢？又是如何将最终的请求交给 Servlet 处理。下面是这个过程的时序图：</p>
<p>图 9. Engine 和 Host 处理请求的时序图</p>
<p><img src="http://image.winrains.cn/2019/08/60440-origin_image009.png" alt="http://image.winrains.cn/2019/08/60440-origin_image009.png"><br>这里看到了 Valve 是不是很熟悉，没错 Valve 的设计在其他框架中也有用的，同样 Pipeline 的原理也基本是相似的，它是一个管道，Engine 和 Host 都会执行这个 Pipeline，您可以在这个管道上增加任意的 Valve，Tomcat 会挨个执行这些 Valve，而且四个组件都会有自己的一套 Valve 集合。您怎么才能定义自己的 Valve 呢？在 server.xml 文件中可以添加，如给 Engine 和 Host 增加一个 Valve 如下：</p>
<p>清单 11. Server.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Engine</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.RequestDumperValve"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ………</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">Host</span> <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"localhost"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">        <span class="attr">xmlNamespaceAware</span>=<span class="string">"false"</span> <span class="attr">xmlValidation</span>=<span class="string">"false"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.FastCommonAccessLogValve"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">            <span class="attr">directory</span>=<span class="string">"logs"</span>  <span class="attr">prefix</span>=<span class="string">"localhost_access_log."</span> <span class="attr">suffix</span>=<span class="string">".txt"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">            <span class="attr">pattern</span>=<span class="string">"common"</span> <span class="attr">resolveHosts</span>=<span class="string">"false"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    …………</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span></pre></td></tr></table></figure>

<p>StandardEngineValve 和 StandardHostValve 是 Engine 和 Host 的默认的 Valve，它们是最后一个 Valve 负责将请求传给它们的子容器，以继续往下执行。<br>前面是 Engine 和 Host 容器的请求过程，下面看 Context 和 Wrapper 容器时如何处理请求的。下面是处理请求的时序图：</p>
<p>图 10. Context 和 wrapper 的处理请求时序图</p>
<p><img src="http://image.winrains.cn/2019/08/9be13-origin_image010.png" alt="http://image.winrains.cn/2019/08/9be13-origin_image010.png"><br>从 Tomcat5 开始，子容器的路由放在了 request 中，request 中保存了当前请求正在处理的 Host、Context 和 wrapper。</p>
<h3 id="Engine-容器"><a href="#Engine-容器" class="headerlink" title="Engine 容器"></a>Engine 容器</h3><p>Engine 容器比较简单，它只定义了一些基本的关联关系，接口类图如下：</p>
<p>图 11. Engine 接口的类结构</p>
<p><img src="http://image.winrains.cn/2019/08/71a7f-image011.png" alt="图 11. Engine 接口的类结构"><br>它的标准实现类是 StandardEngine，这个类注意一点就是 Engine 没有父容器了，如果调用 setParent 方法时将会报错。添加子容器也只能是 Host 类型的，代码如下：</p>
<p>清单 12. StandardEngine. addChild</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">addChild</span><span class="params">(Container child)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!(child <span class="keyword">instanceof</span> Host))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException</span></pre></td></tr><tr><td class="code"><pre><span class="line">            (sm.getString(<span class="string">"standardEngine.notHost"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">super</span>.addChild(child);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(Container container)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException</span></pre></td></tr><tr><td class="code"><pre><span class="line">        (sm.getString(<span class="string">"standardEngine.notParent"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>它的初始化方法也就是初始化和它相关联的组件，以及一些事件的监听。</p>
<h3 id="Host-容器"><a href="#Host-容器" class="headerlink" title="Host 容器"></a>Host 容器</h3><p>Host 是 Engine 的字容器，一个 Host 在 Engine 中代表一个虚拟主机，这个虚拟主机的作用就是运行多个应用，它负责安装和展开这些应用，并且标识这个应用以便能够区分它们。它的子容器通常是 Context，它除了关联子容器外，还有就是保存一个主机应该有的信息。<br>下面是和 Host 相关的类关联图：</p>
<p>图 12. Host 相关的类图</p>
<p><img src="http://image.winrains.cn/2019/08/c25b2-origin_image012.png" alt="http://image.winrains.cn/2019/08/c25b2-origin_image012.png"><br>从上图中可以看出除了所有容器都继承的 ContainerBase 外，StandardHost 还实现了 Deployer 接口，上图清楚的列出了这个接口的主要方法，这些方法都是安装、展开、启动和结束每个 web application。<br>Deployer 接口的实现是 StandardHostDeployer，这个类实现了的最要的几个方法，Host 可以调用这些方法完成应用的部署等。</p>
<h3 id="Context-容器"><a href="#Context-容器" class="headerlink" title="Context 容器"></a>Context 容器</h3><p>Context 代表 Servlet 的 Context，它具备了 Servlet 运行的基本环境，理论上只要有 Context 就能运行 Servlet 了。简单的 Tomcat 可以没有 Engine 和 Host。<br>Context 最重要的功能就是管理它里面的 Servlet 实例，Servlet 实例在 Context 中是以 Wrapper 出现的，还有一点就是 Context 如何才能找到正确的 Servlet 来执行它呢？ Tomcat5 以前是通过一个 Mapper 类来管理的，Tomcat5 以后这个功能被移到了 request 中，在前面的时序图中就可以发现获取子容器都是通过 request 来分配的。<br>Context 准备 Servlet 的运行环境是在 Start 方法开始的，这个方法的代码片段如下：</p>
<p>清单 13. StandardContext.start</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public synchronized void start<span class="literal">()</span> throws LifecycleException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ………</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>( !initialized ) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            init<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; catch( Exception ex ) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throw <span class="keyword">new</span> <span class="constructor">LifecycleException(<span class="string">"Error initializaing "</span>, <span class="params">ex</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ………</span></pre></td></tr><tr><td class="code"><pre><span class="line">    lifecycle.fire<span class="constructor">LifecycleEvent(BEFORE_START_EVENT, <span class="params">null</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    set<span class="constructor">Available(<span class="params">false</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    set<span class="constructor">Configured(<span class="params">false</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    boolean ok = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    File configBase = get<span class="constructor">ConfigBase()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (configBase != null) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (get<span class="constructor">ConfigFile()</span><span class="operator"> == </span>null) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            File file = <span class="keyword">new</span> <span class="constructor">File(<span class="params">configBase</span>, <span class="params">getDefaultConfigFile</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            set<span class="constructor">ConfigFile(<span class="params">file</span>.<span class="params">getPath</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                File appBaseFile = <span class="keyword">new</span> <span class="constructor">File(<span class="params">getAppBase</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (!appBaseFile.is<span class="constructor">Absolute()</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    appBaseFile = <span class="keyword">new</span> <span class="constructor">File(<span class="params">engineBase</span>()</span>, get<span class="constructor">AppBase()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                String appBase = appBaseFile.get<span class="constructor">CanonicalPath()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                String basePath =</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    (<span class="keyword">new</span> <span class="constructor">File(<span class="params">getBasePath</span>()</span>)).get<span class="constructor">CanonicalPath()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (!basePath.starts<span class="constructor">With(<span class="params">appBase</span>)</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    Server server = <span class="module-access"><span class="module"><span class="identifier">ServerFactory</span>.</span></span>get<span class="constructor">Server()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    ((StandardServer) server).store<span class="constructor">Context(<span class="params">this</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; catch (Exception e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                log.warn(<span class="string">"Error storing config file"</span>, e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                String canConfigFile =  (<span class="keyword">new</span> <span class="constructor">File(<span class="params">getConfigFile</span>()</span>)).get<span class="constructor">CanonicalPath()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (!canConfigFile.startsWith (configBase.get<span class="constructor">CanonicalPath()</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    File file = <span class="keyword">new</span> <span class="constructor">File(<span class="params">configBase</span>, <span class="params">getDefaultConfigFile</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (copy(<span class="keyword">new</span> <span class="constructor">File(<span class="params">canConfigFile</span>)</span>, file)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        set<span class="constructor">ConfigFile(<span class="params">file</span>.<span class="params">getPath</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; catch (Exception e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                log.warn(<span class="string">"Error setting config file"</span>, e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ………</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Container children<span class="literal">[]</span> = find<span class="constructor">Children()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (children<span class="literal">[<span class="identifier">i</span>]</span> instanceof Lifecycle)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ((Lifecycle) children<span class="literal">[<span class="identifier">i</span>]</span>).start<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (pipeline instanceof Lifecycle)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ((Lifecycle) pipeline).start<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ………</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>它主要是设置各种资源属性和管理组件，还有非常重要的就是启动子容器和 Pipeline。<br>我们知道 Context 的配置文件中有个 reloadable 属性，如下面配置：</p>
<p>清单 14. Server.xml</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;Context</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">path</span>=<span class="string">"/library"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">docBase</span>=<span class="string">"D:\projects\library\deploy\target\library.war"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">reloadable</span>=<span class="string">"true"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">/&gt;</span></pre></td></tr></table></figure>

<p>当这个 reloadable 设为 true 时，war 被修改后 Tomcat 会自动的重新加载这个应用。如何做到这点的呢 ? 这个功能是在 StandardContext 的 backgroundProcess 方法中实现的，这个方法的代码如下：</p>
<p>清单 15. StandardContext. backgroundProcess</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void background<span class="constructor">Process()</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!started) return;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    count = (count + <span class="number">1</span>) % managerChecksFrequency;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> ((get<span class="constructor">Manager()</span> != null)<span class="operator"> &amp;&amp; </span>(count<span class="operator"> == </span><span class="number">0</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            get<span class="constructor">Manager()</span>.background<span class="constructor">Process()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; catch ( Exception x ) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            log.warn(<span class="string">"Unable to perform background process on manager"</span>,x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (get<span class="constructor">Loader()</span> != null) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (reloadable<span class="operator"> &amp;&amp; </span>(get<span class="constructor">Loader()</span>.modified<span class="literal">()</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.setContextClassLoader</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    (<span class="module-access"><span class="module"><span class="identifier">StandardContext</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">ClassLoader()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                reload<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; finally &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (get<span class="constructor">Loader()</span> != null) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.setContextClassLoader</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        (get<span class="constructor">Loader()</span>.get<span class="constructor">ClassLoader()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (get<span class="constructor">Loader()</span> instanceof WebappLoader) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ((WebappLoader) get<span class="constructor">Loader()</span>).close<span class="constructor">JARs(<span class="params">false</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>它会调用 reload 方法，而 reload 方法会先调用 stop 方法然后再调用 Start 方法，完成 Context 的一次重新加载。可以看出执行 reload 方法的条件是 reloadable 为 true 和应用被修改，那么这个 backgroundProcess 方法是怎么被调用的呢？<br>这个方法是在 ContainerBase 类中定义的内部类 ContainerBackgroundProcessor 被周期调用的，这个类是运行在一个后台线程中，它会周期的执行 run 方法，它的 run 方法会周期调用所有容器的 backgroundProcess 方法，因为所有容器都会继承 ContainerBase 类，所以所有容器都能够在 backgroundProcess 方法中定义周期执行的事件。</p>
<h3 id="Wrapper-容器"><a href="#Wrapper-容器" class="headerlink" title="Wrapper 容器"></a>Wrapper 容器</h3><p>Wrapper 代表一个 Servlet，它负责管理一个 Servlet，包括的 Servlet 的装载、初始化、执行以及资源回收。Wrapper 是最底层的容器，它没有子容器了，所以调用它的 addChild 将会报错。<br>Wrapper 的实现类是 StandardWrapper，StandardWrapper 还实现了拥有一个 Servlet 初始化信息的 ServletConfig，由此看出 StandardWrapper 将直接和 Servlet 的各种信息打交道。<br>下面看一下非常重要的一个方法 loadServlet，代码片段如下：</p>
<p>清单 16. StandardWrapper.loadServlet</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public synchronized Servlet load<span class="constructor">Servlet()</span> throws ServletException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ………</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Servlet servlet;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ………</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ClassLoader classLoader = loader.get<span class="constructor">ClassLoader()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ………</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Class classClass = null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ………</span></pre></td></tr><tr><td class="code"><pre><span class="line">        servlet = (Servlet) classClass.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((servlet instanceof ContainerServlet) &amp;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            (is<span class="constructor">ContainerProvidedServlet(<span class="params">actualClass</span>)</span> <span class="pattern-match"><span class="operator">||</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">            ((<span class="constructor">Context</span>)get<span class="constructor">Parent()</span>).get<span class="constructor">Privileged()</span> )) &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">                ((<span class="constructor">ContainerServlet</span>) servlet).set<span class="constructor">Wrapper(<span class="params">this</span>)</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">        &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">        <span class="keyword">class</span><span class="constructor">LoadTime</span>=(<span class="built_in">int</span>) (<span class="constructor">System</span>.current<span class="constructor">TimeMillis()</span> -t1);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">        <span class="keyword">try</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">            instance<span class="constructor">Support</span>.fire<span class="constructor">InstanceEvent(InstanceEvent.BEFORE_INIT_EVENT,<span class="params">servlet</span>)</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">            <span class="keyword">if</span>( <span class="constructor">System</span>.get<span class="constructor">SecurityManager()</span> != null) &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">                <span class="constructor">Class</span>[] <span class="keyword">class</span><span class="constructor">Type</span> = <span class="keyword">new</span> <span class="constructor">Class</span>[]&#123;<span class="constructor">ServletConfig</span>.<span class="keyword">class</span>&#125;;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">                <span class="constructor">Object</span>[] args = <span class="keyword">new</span> <span class="constructor">Object</span>[]&#123;((<span class="constructor">ServletConfig</span>)facade)&#125;;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">                <span class="constructor">SecurityUtil</span>.<span class="keyword">do</span><span class="constructor">AsPrivilege(<span class="string">"init"</span>,<span class="params">servlet</span>,<span class="params">classType</span>,<span class="params">args</span>)</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">            &#125; <span class="keyword">else</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">                servlet.init(facade);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">            &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">            <span class="keyword">if</span> ((load<span class="constructor">OnStartup</span> &gt;= 0) <span class="operator">&amp;&amp;</span> (jsp<span class="constructor">File</span> != null)) &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">                ………</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">                <span class="keyword">if</span>( <span class="constructor">System</span>.get<span class="constructor">SecurityManager()</span> != null) &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">                    <span class="constructor">Class</span>[] <span class="keyword">class</span><span class="constructor">Type</span> = <span class="keyword">new</span> <span class="constructor">Class</span>[]&#123;<span class="constructor">ServletRequest</span>.<span class="keyword">class</span>,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">                        <span class="constructor">ServletResponse</span>.<span class="keyword">class</span>&#125;;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">                    <span class="constructor">Object</span>[] args = <span class="keyword">new</span> <span class="constructor">Object</span>[]&#123;req, res&#125;;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">                    <span class="constructor">SecurityUtil</span>.<span class="keyword">do</span><span class="constructor">AsPrivilege(<span class="string">"service"</span>,<span class="params">servlet</span>,<span class="params">classType</span>,<span class="params">args</span>)</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">                &#125; <span class="keyword">else</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">                    servlet.service(req, res);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">                &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">            &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">            instance<span class="constructor">Support</span>.fire<span class="constructor">InstanceEvent(InstanceEvent.AFTER_INIT_EVENT,<span class="params">servlet</span>)</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">            ………</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">    return servlet;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="pattern-match">&#125;</span></span></pre></td></tr></table></figure>

<p>它基本上描述了对 Servlet 的操作，当装载了 Servlet 后就会调用 Servlet 的 init 方法，同时会传一个 StandardWrapperFacade 对象给 Servlet，这个对象包装了 StandardWrapper，ServletConfig 与它们的关系图如下：</p>
<p>图 13. ServletConfig 与 StandardWrapperFacade、StandardWrapper 的关系</p>
<p><img src="http://image.winrains.cn/2019/08/8da5f-image013.png" alt="图 13. ServletConfig 与 StandardWrapperFacade、StandardWrapper 的关系"><br>Servlet 可以获得的信息都在 StandardWrapperFacade 封装，这些信息又是在 StandardWrapper 对象中拿到的。所以 Servlet 可以通过 ServletConfig 拿到有限的容器的信息。<br>当 Servlet 被初始化完成后，就等着 StandardWrapperValve 去调用它的 service 方法了，调用 service 方法之前要调用 Servlet 所有的 filter。</p>
<h2 id="Tomcat-中其它组件"><a href="#Tomcat-中其它组件" class="headerlink" title="Tomcat 中其它组件"></a>Tomcat 中其它组件</h2><p>Tomcat 还有其它重要的组件，如安全组件 security、logger 日志组件、session、mbeans、naming 等其它组件。这些组件共同为 Connector 和 Container 提供必要的服务。</p>
<blockquote>
<p>作者：许令波</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat 系统架构与设计模式分析</title>
    <url>/2019/12/26/Tomcat-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="门面设计模式"><a href="#门面设计模式" class="headerlink" title="门面设计模式"></a>门面设计模式</h2><p>门面设计模式在 Tomcat 中有多处使用，在 Request 和 Response 对象封装中、Standard Wrapper 到 ServletConfig 封装中、ApplicationContext 到 ServletContext 封装中等都用到了这种设计模式。</p>
<a id="more"></a>

<h3 id="门面设计模式的原理"><a href="#门面设计模式的原理" class="headerlink" title="门面设计模式的原理"></a>门面设计模式的原理</h3><p>这么多场合都用到了这种设计模式，那这种设计模式究竟能有什么作用呢？顾名思义，就是将一个东西封装成一个门面好与人家更容易进行交流，就像一个国家的外交部一样。<br>这种设计模式主要用在一个大的系统中有多个子系统组成时，这多个子系统肯定要涉及到相互通信，但是每个子系统又不能将自己的内部数据过多的暴露给其它系统，不然就没有必要划分子系统了。每个子系统都会设计一个门面，把别的系统感兴趣的数据封装起来，通过这个门面来进行访问。这就是门面设计模式存在的意义。<br>门面设计模式示意图如下：</p>
<p>图 1. 门面示意图</p>
<p><img src="http://image.winrains.cn/2019/08/6491b-image001.jpg" alt="图 1. 门面示意图"><br>Client 只能访问到 Façade 中提供的数据是门面设计模式的关键，至于 Client 如何访问 Façade 和 Subsystem 如何提供 Façade 门面设计模式并没有规定死。</p>
<h3 id="Tomcat-的门面设计模式示例"><a href="#Tomcat-的门面设计模式示例" class="headerlink" title="Tomcat 的门面设计模式示例"></a>Tomcat 的门面设计模式示例</h3><p>Tomcat 中门面设计模式使用的很多，因为 Tomcat 中有很多不同组件，每个组件要相互交互数据，用门面模式隔离数据是个很好的方法。<br>下面是 Request 上使用的门面设计模式：</p>
<p>图 2. Request 的门面设计模式类图</p>
<p><img src="http://image.winrains.cn/2019/08/e3dbf-image002.png" alt="图 2. Request 的门面设计模式类图"><br>从图中可以看出 HttpRequestFacade 类封装了 HttpRequest 接口能够提供数据，通过 HttpRequestFacade 访问到的数据都被代理到 HttpRequest 中，通常被封装的对象都被设为 Private 或者 Protected 访问修饰，以防止在 Façade 中被直接访问。</p>
<h2 id="观察者设计模式"><a href="#观察者设计模式" class="headerlink" title="观察者设计模式"></a>观察者设计模式</h2><p>这种设计模式也是常用的设计方法通常也叫发布 - 订阅模式，也就是事件监听机制，通常在某个事件发生的前后会触发一些操作。</p>
<h3 id="观察者模式的原理"><a href="#观察者模式的原理" class="headerlink" title="观察者模式的原理"></a>观察者模式的原理</h3><p>观察者模式原理也很简单，就是你在做事的时候旁边总有一个人在盯着你，当你做的事情是它感兴趣的时候，它就会跟着做另外一些事情。但是盯着你的人必须要到你那去登记，不然你无法通知它。观察者模式通常包含下面这几个角色：</p>
<ul>
<li>Subject 就是抽象主题：它负责管理所有观察者的引用，同时定义主要的事件操作。</li>
<li>ConcreteSubject 具体主题：它实现了抽象主题的所有定义的接口，当自己发生变化时，会通知所有观察者。</li>
<li>Observer 观察者：监听主题发生变化相应的操作接口。</li>
</ul>
<h3 id="Tomcat-的观察者模式示例"><a href="#Tomcat-的观察者模式示例" class="headerlink" title="Tomcat 的观察者模式示例"></a>Tomcat 的观察者模式示例</h3><p>Tomcat 中观察者模式也有多处使用，前面讲的控制组件生命周期的 Lifecycle 就是这种模式的体现，还有对 Servlet 实例的创建、Session 的管理、Container 等都是同样的原理。下面主要看一下 Lifecycle 的具体实现。<br>Lifecycle 的观察者模式结构图：</p>
<p>图 3. Lifecycle 的观察者模式结构图</p>
<p><img src="http://image.winrains.cn/2019/08/2613c-image003.png" alt="图 3. Lifecycle 的观察者模式结构图"><br>上面的结构图中，LifecycleListener 代表的是抽象观察者，它定义一个 lifecycleEvent 方法，这个方法就是当主题变化时要执行的方法。 ServerLifecycleListener 代表的是具体的观察者，它实现了 LifecycleListener 接口的方法，就是这个具体的观察者具体的实现方式。Lifecycle 接口代表的是抽象主题，它定义了管理观察者的方法和它要所做的其它方法。而 StandardServer 代表的是具体主题，它实现了抽象主题的所有方法。这里 Tomcat 对观察者做了扩展，增加了另外两个类：LifecycleSupport、LifecycleEvent，它们作为辅助类扩展了观察者的功能。LifecycleEvent 使得可以定义事件类别，不同的事件可区别处理，更加灵活。LifecycleSupport 类代理了主题对多观察者的管理，将这个管理抽出来统一实现，以后如果修改只要修改 LifecycleSupport 类就可以了，不需要去修改所有具体主题，因为所有具体主题的对观察者的操作都被代理给 LifecycleSupport 类了。这可以认为是观察者模式的改进版。<br>LifecycleSupport 调用观察者的方法代码如下：</p>
<p>清单 1. LifecycleSupport 中的 fireLifecycleEvent 方法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void fire<span class="constructor">LifecycleEvent(String <span class="params">type</span>, Object <span class="params">data</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LifecycleEvent event = <span class="keyword">new</span> <span class="constructor">LifecycleEvent(<span class="params">lifecycle</span>, <span class="params">type</span>, <span class="params">data</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LifecycleListener interested<span class="literal">[]</span> = null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    synchronized (listeners) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        interested = (LifecycleListener<span class="literal">[]</span>) listeners.clone<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; interested.length; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        interested<span class="literal">[<span class="identifier">i</span>]</span>.lifecycle<span class="constructor">Event(<span class="params">event</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>主题是怎么通知观察者呢？看下面代码：</p>
<p>清单 2. 容器中的 start 方法</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, <span class="keyword">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    lifecycle.fireLifecycleEvent(START_EVENT, <span class="keyword">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    started = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">synchronized</span> (services) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; services.length; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (services[i] <span class="keyword">instanceof</span> Lifecycle)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ((Lifecycle) services[i]).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    lifecycle.fireLifecycleEvent(AFTER_START_EVENT, <span class="keyword">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="命令设计模式"><a href="#命令设计模式" class="headerlink" title="命令设计模式"></a>命令设计模式</h2><p>前面把 Tomcat 中两个核心组件 Connector 和 Container，比作一对夫妻。男的将接受过来的请求以命令的方式交给女主人。对应到 Connector 和 Container，Connector 也是通过命令模式调用 Container 的。</p>
<h3 id="命令模式的原理"><a href="#命令模式的原理" class="headerlink" title="命令模式的原理"></a>命令模式的原理</h3><p>命令模式主要作用就是封装命令，把发出命令的责任和执行命令的责任分开。也是一种功能的分工。不同的模块可以对同一个命令做出不同解释。<br>下面是命令模式通常包含下面几个角色：</p>
<ul>
<li>Client：创建一个命令，并决定接受者</li>
<li>Command 命令：命令接口定义一个抽象方法</li>
<li>ConcreteCommand：具体命令，负责调用接受者的相应操作</li>
<li>Invoker 请求者：负责调用命令对象执行请求</li>
<li>Receiver 接受者：负责具体实施和执行一次请求</li>
</ul>
<h3 id="Tomcat-中的命令模式的示例"><a href="#Tomcat-中的命令模式的示例" class="headerlink" title="Tomcat 中的命令模式的示例"></a>Tomcat 中的命令模式的示例</h3><p>Tomcat 中命令模式在 Connector 和 Container 组件之间有体现，Tomcat 作为一个应用服务器，无疑会接受到很多请求，如何分配和执行这些请求是必须的功能。<br>下面看一下 Tomcat 是如何实现命令模式的，下面是 Tomcat 命令模式的结构图：</p>
<p>图 4. Tomcat 命令模式的结构图</p>
<p><img src="http://image.winrains.cn/2019/08/45cb1-image004.png" alt="图 4. Tomcat 命令模式的结构图"><br>Connector 作为抽象请求者，HttpConnector 作为具体请求者。HttpProcessor 作为命令。Container 作为命令的抽象接受者，ContainerBase 作为具体的接受者。客户端就是应用服务器 Server 组件了。Server 首先创建命令请求者 HttpConnector 对象，然后创建命令 HttpProcessor 命令对象。再把命令对象交给命令接受者 ContainerBase 容器来处理命令。命令的最终是被 Tomcat 的 Container 执行的。命令可以以队列的方式进来，Container 也可以以不同的方式来处理请求，如 HTTP1.0 协议和 HTTP1.1 的处理方式就会不同。</p>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>Tomcat 中一个最容易发现的设计模式就是责任链模式，这个设计模式也是 Tomcat 中 Container 设计的基础，整个容器的就是通过一个链连接在一起，这个链一直将请求正确的传递给最终处理请求的那个 Servlet。</p>
<h3 id="责任链模式的原理"><a href="#责任链模式的原理" class="headerlink" title="责任链模式的原理"></a>责任链模式的原理</h3><p>责任链模式，就是很多对象有每个对象对其下家的引用而连接起来形成一条链，请求在这条链上传递，直到链上的某个对象处理此请求，或者每个对象都可以处理请求，并传给下一家，直到最终链上每个对象都处理完。这样可以不影响客户端而能够在链上增加任意的处理节点。<br>通常责任链模式包含下面几个角色：</p>
<ul>
<li>Handler（抽象处理者）：定义一个处理请求的接口</li>
<li>ConcreteHandler（具体处理者）：处理请求的具体类，或者传给下家</li>
</ul>
<h3 id="Tomcat-中责任链模式示例"><a href="#Tomcat-中责任链模式示例" class="headerlink" title="Tomcat 中责任链模式示例"></a>Tomcat 中责任链模式示例</h3><p>在 tomcat 中这种设计模式几乎被完整的使用，tomcat 的容器设置就是责任链模式，从 Engine 到 Host 再到 Context 一直到 Wrapper 都是通过一个链传递请求。<br>Tomcat 中责任链模式的类结构图如下：</p>
<p>图 5. Tomcat 责任链模式的结构图</p>
<p><img src="http://image.winrains.cn/2019/08/81f5a-image005.jpg" alt="图 5. Tomcat 责任链模式的结构图"><br>上图基本描述了四个子容器使用责任链模式的类结构图，对应的责任链模式的角色，Container 扮演抽象处理者角色，具体处理者由 StandardEngine 等子容器扮演。与标准的责任链不同的是，这里引入了 Pipeline 和 Valve 接口。他们有什么作用呢？<br>实际上 Pipeline 和 Valve 是扩展了这个链的功能，使得在链往下传递过程中，能够接受外界的干预。Pipeline 就是连接每个子容器的管子，里面传递的 Request 和 Response 对象好比管子里流的水，而 Valve 就是这个管子上开的一个个小口子，让你有机会能够接触到里面的水，做一些额外的事情。<br>为了防止水被引出来而不能流到下一个容器中，每一段管子最后总有一个节点保证它一定能流到下一个子容器，所以每个容器都有一个 StandardXXXValve。只要涉及到这种有链式是处理流程这是一个非常值得借鉴的模式。</p>
<blockquote>
<p>作者：许令波</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 12 新特性概述</title>
    <url>/2019/12/26/Java-12-%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>Java 12 已如期于 3 月 19 日正式发布，此次更新是 Java 11 这一长期支持版本发布之后的一次常规更新，截至目前，Java 半年为发布周期，并且不会跳票承诺的发布模式，已经成功运行一年多了。通过这样的方式，Java 开发团队能够将一些重要特性尽早的合并到 Java Release 版本中，以便快速得到开发者的反馈，避免出现类似 Java 9 发布时的两次延期的情况。<br>Java 12 早在 2018 年 12 月便进入了 Rampdown Phase One 阶段，这意味着该版本所有新的功能特性被冻结，不会再加入更多的 JEP。该阶段将持续大概一个月，主要修复 P1-P3 级错误。主要时间节点如下：</p>
<ul>
<li>2018-12-13 Rampdown 第一阶段 ( 从主线分离 )</li>
<li>2019-01-17 Rampdown 第二阶段</li>
<li>2019-02-07 发布候选阶段</li>
<li>2019-03-19 正式发布</li>
</ul>
<p>本文主要针对 Java 12 中的新特性展开介绍，让您快速了解 Java 12 带来的变化。</p>
<a id="more"></a>

<h2 id="Shenandoah：一个低停顿垃圾收集器（实验阶段）"><a href="#Shenandoah：一个低停顿垃圾收集器（实验阶段）" class="headerlink" title="Shenandoah：一个低停顿垃圾收集器（实验阶段）"></a>Shenandoah：一个低停顿垃圾收集器（实验阶段）</h2><p>Java 12 中引入一个新的垃圾收集器：Shenandoah，它是作为一中低停顿时间的垃圾收集器而引入到 Java 12 中的，其工作原理是通过与 Java 应用程序中的执行线程同时运行，用以执行其垃圾收集、内存回收任务，通过这种运行方式，给虚拟机带来短暂的停顿时间。<br>Shenandoah 垃圾回收器是 Red Hat 在 2014 年宣布进行的一项垃圾收集器研究项目，旨在针对 JVM 上的内存收回实现低停顿的需求。该设计将与应用程序线程并发，通过交换 CPU 并发周期和空间以改善停顿时间，使得垃圾回收器执行线程能够在 Java 线程运行时进行堆压缩，并且标记和整理能够同时进行，因此避免了在大多数 JVM 垃圾收集器中所遇到的问题。<br>据 Red Hat 研发 Shenandoah 团队对外宣称，Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200 MB 还是 200 GB，都将拥有一致的系统暂停时间，不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>
<p>图 1. Shenandoah GC 工作周期如下所示</p>
<p><img src="http://image.winrains.cn/2019/08/6ce18-image001.png" alt="img"></p>
<p><em>本图片引用自：</em><a href="https://wiki.openjdk.java.net/display/shenandoah/Main#Main-Overview" target="_blank" rel="noopener"><em>Shenandoah GC</em></a><br>上图对应工作周期如下：</p>
<ol>
<li>Init Mark 启动并发标记 阶段</li>
<li>并发标记遍历堆阶段</li>
<li>并发标记完成阶段</li>
<li>并发整理回收无活动区域阶段</li>
<li>并发 Evacuation 整理内存区域阶段</li>
<li>Init Update Refs 更新引用初始化 阶段</li>
<li>并发更新引用阶段</li>
<li>Final Update Refs 完成引用更新阶段</li>
<li>并发回收无引用区域阶段</li>
</ol>
<p>需要了解不是唯有 GC 停顿可能导致常规应用程序响应时间比较长。具有较长的 GC 停顿时间会导致系统响应慢的问题，但响应时间慢并非一定是 GC 停顿时间长导致的，队列延迟、网络延迟、其他依赖服务延迟和操作提供调度程序抖动等都可能导致响应变慢。使用 Shenandoah 时需要全面了解系统运行情况，综合分析系统响应时间。各种 GC 工作负载对比如下所示：</p>
<p>图 2. 各种 GC 工作负载对比</p>
<p><img src="http://image.winrains.cn/2019/08/be6a6-image002.png" alt="img"></p>
<p><em>本图片引用自：</em><a href="https://wiki.openjdk.java.net/display/shenandoah#Main-PerformanceAnalysis" target="_blank" rel="noopener"><em>Shenandoah GC</em></a><br>下面推荐几个配置或调试 Shenandoah 的 JVM 参数:</p>
<ul>
<li><code>-XX:+AlwaysPreTouch</code>：使用所有可用的内存分页，减少系统运行停顿，为避免运行时性能损失。</li>
<li><code>-Xmx == -Xmsv</code>：设置初始堆大小与最大值一致，可以减轻伸缩堆大小带来的压力，与 <code>AlwaysPreTouch</code> 参数配合使用，在启动时提交所有内存，避免在最终使用中出现系统停顿。</li>
<li><code>-XX:+ UseTransparentHugePages</code>：能够大大提高大堆的性能，同时建议在 Linux 上使用时将 <code>/sys/kernel/mm/transparent_hugepage/enabled</code> 和 <code>/sys/kernel/mm/transparent_hugepage/defragv</code> 设置为：<code>madvise</code>，同时与 <code>AlwaysPreTouch</code> 一起使用时，<code>init</code> 和 <code>shutdownv</code> 速度会更快，因为它将使用更大的页面进行预处理。</li>
<li><code>-XX:+UseNUMA</code>：虽然 <code>Shenandoah</code> 尚未明确支持 NUMA（Non-Uniform Memory Access），但最好启用此功能以在多插槽主机上启用 NUMA 交错。与 <code>AlwaysPreTouch</code> 相结合，它提供了比默认配置更好的性能。</li>
<li><code>-XX:+DisableExplicitGC</code>：忽略代码中的 <code>System.gc()</code> 调用。当用户在代码中调用 <code>System.gc()</code> 时会强制 Shenandoah 执行 STW Full GC ，应禁用它以防止执行此操作，另外还可以使用 <code>-XX:+ExplicitGCInvokesConcurrent</code>，在 调用 <code>System.gc()</code> 时执行 CMS GC 而不是 Full GC，建议在有 <code>System.gc()</code> 调用的情况下使用。</li>
</ul>
<p>不过目前 Shenandoah 垃圾回收器还被标记为实验项目，需要使用参数：<code>- XX:+UnlockExperimentalVMOptions</code> 启用。更多有关如何配置、调试 Shenandoah 的信息，请参阅 <a href="https://wiki.openjdk.java.net/display/shenandoah" target="_blank" rel="noopener">henandoah wiki</a>。</p>
<h2 id="增加一套微基准套件"><a href="#增加一套微基准套件" class="headerlink" title="增加一套微基准套件"></a>增加一套微基准套件</h2><p>Java 12 中添加一套新的基本的微基准测试套件，该套微基准测试套件基于 JMH（Java Microbenchmark Harness），使开发人员可以轻松运行现有的微基准测试并创建新的基准测试，其目标在于提供一个稳定且优化过的基准，其中包括将近 100 个基准测试的初始集合，并且能够轻松添加新基准、更新基准测试和提高查找已有基准测试的便利性。<br>微基准套件与 JDK 源代码位于同一个目录中，并且在构建后将生成单个 Jar 文件。但它是一个单独的项目，在支持构建期间不会执行，以方便开发人员和其他对构建微基准套件不感兴趣的人在构建时花费比较少的构建时间。<br>要构建微基准套件，用户需要运行命令：<code>make build-microbenchmark</code>，类似的命令还有：<code>make test TEST=&quot;micro:java.lang.invoke&quot;</code> 将使用默认设置运行 <code>java.lang.invoke</code> 相关的微基准测试。关于配置本地环境可以参照文档 <code>docs/testing.md|html</code>。</p>
<h2 id="Switch-表达式扩展（预览功能）"><a href="#Switch-表达式扩展（预览功能）" class="headerlink" title="Switch 表达式扩展（预览功能）"></a>Switch 表达式扩展（预览功能）</h2><p>Java 11 以及之前 Java 版本中的 Switch 语句是按照类似 C、C++ 这样的语言来设计的，在默认情况下支持 <code>fall-through</code> 语法。虽然这种传统的控制流通常用于编写低级代码，但 Switch 控制语句通常运用在高级别语言环境下的，因此其容易出错性掩盖其灵活性。<br>在 Java 12 中重新拓展了 Switch 让它具备了新的能力，通过扩展现有的 Switch 语句，可将其作为增强版的 Switch 语句或称为 “Switch 表达式”来写出更加简化的代码。<br>Switch 表达式也是作为预览语言功能的第一个语言改动被引入新版 Java 中来的，预览语言功能的想法是在 2018 年初被引入 Java 中的，本质上讲，这是一种引入新特性的测试版的方法。通过这种方式，能够根据用户反馈进行升级、更改，在极端情况下，如果没有被很好的接纳，则可以完全删除该功能。预览功能的关键在于它们没有被包含在 Java SE 规范中。<br>在 Java 11 以及之前版本中传统形式的 Switch 语句写法如下：</p>
<p>清单 1. Switch 语句示例</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dayNumber;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">MONDAY:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">FRIDAY:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">SUNDAY:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        dayNumber = <span class="number">6</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">TUESDAY:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        dayNumber = <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">THURSDAY:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">SATURDAY:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        dayNumber = <span class="number">8</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">WEDNESDAY:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        dayNumber = <span class="number">9</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">    default:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Huh? "</span> + day);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面代码中多处出现 break 语句，显得代码比较冗余，同时如果某处漏写一段 break 语句，将导致程序一直向下穿透执行的逻辑错误，出现异常结果，同时这种写法比较繁琐，也容易出问题。<br>换做 Java 12 中的 Switch 表达式，上述语句写法如下：</p>
<p>清单 2. Switch 表达式示例</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">int dayNumber = <span class="keyword">switch</span> (day) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> MONDAY, FRIDAY, SUNDAY<span class="function"> -&gt;</span> <span class="number">6</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> TUESDAY<span class="function">                -&gt;</span> <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> THURSDAY, SATURDAY<span class="function">     -&gt;</span> <span class="number">8</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> WEDNESDAY<span class="function">              -&gt;</span> <span class="number">9</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">default</span><span class="function">                      -&gt;</span> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Huh? "</span> + day);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用 Java 12 中 Switch 表达式的写法，省去了 break 语句，避免了因少些 break 而出错，同时将多个 case 合并到一行，显得简洁、清晰也更加优雅的表达逻辑分支，其具体写法就是将之前的 case 语句表成了：<code>case L -&gt;</code>，即如果条件匹配 case L，则执行 标签右侧的代码 ，同时标签右侧的代码段只能是表达式、代码块或 throw 语句。为了保持兼容性，case 条件语句中依然可以使用字符 <code>:</code> ，这时 fall-through 规则依然有效的，即不能省略原有的 break 语句，但是同一个 Switch 结构里不能混用 <code>-&gt;</code> 和 <code>:</code> ，否则会有编译错误。并且简化后的 Switch 代码块中定义的局部变量，其作用域就限制在代码块中，而不是蔓延到整个 Switch 结构，也不用根据不同的判断条件来给变量赋值。<br>Java 11 以及之前版本中，Switch 表达式支持下面类型： byte、char、short、int、Byte、Character、Short、Integer、enum、tring，在未来的某个 Java 版本有可能会允许支持 float、double 和 long （以及上面类型的封装类型）。</p>
<h2 id="引入-JVM-常量-API"><a href="#引入-JVM-常量-API" class="headerlink" title="引入 JVM 常量 API"></a>引入 JVM 常量 API</h2><p>Java 12 中引入 JVM 常量 API，用来更容易地对关键类文件 (key class-file) 和运行时构件（artefact）的名义描述 (nominal description) 进行建模，特别是对那些从常量池加载的常量，这是一项非常技术性的变化，能够以更简单、标准的方式处理可加载常量。<br>此项改进主要在新的 <code>java.lang.invoke.constant</code> 包中定义了一系列基于值的符号引用类型，能够描述每种可加载常量。符号引用以纯粹 nominal 的形式描述可加载常量，与类加载或可访问 性上下文分开。同时有些类可以作为自己的符号引用（例如 String），而对于可链接常量，另外定义了一系列符号引用类型，具体包括： ClassDesc (Class 的可加载常量标称描述符) ，MethodTypeDesc(方法类型常量标称描述符) ，MethodHandleDesc (方法句柄常量标称描述符) 和 DynamicConstantDesc (动态常量标称描述符) ，它们包含描述这些常量的 nominal 信息。</p>
<h2 id="改进-AArch64-实现"><a href="#改进-AArch64-实现" class="headerlink" title="改进 AArch64 实现"></a>改进 AArch64 实现</h2><p>Java 12 中将只保留一套 AArch64 实现，删除所有与 arm64 实现相关的代码，只保留 32 位 ARM 端口和 64 位 aarch64 的端口。删除此套实现将允许所有开发人员将目标集中在剩下的这个 64 位 ARM 实现上，消除维护两套端口所需的重复工作。<br>当前 Java 11 中存在两套 64 位 AArch64 端口，它们主要存在于 <code>src/hotspot/cpu/arm</code> 和 <code>open/src/hotspot/cpu/aarch64</code> 目录中。这两套代码中都实现了 AArch64，Java 12 中将删除目录 <code>open/src/hotspot/cpu/arm</code> 中关于 64-bit 的这套实现，只保留其中有关 32-bit 的实现，余下目录的 <code>open/src/hotspot/cpu/aarch64</code> 代码部分就成了 AArch64 的默认实现。</p>
<h2 id="使用默认类数据共享（CDS）存档"><a href="#使用默认类数据共享（CDS）存档" class="headerlink" title="使用默认类数据共享（CDS）存档"></a>使用默认类数据共享（CDS）存档</h2><p>类数据共享机制 (Class Data Sharing ，简称 CDS) ，允许将一组类预处理为共享归档文件，以便在运行时能够进行内存映射以减少 Java 程序的启动时间，当多个 Java 虚拟机（JVM）共享相同的归档文件时，还可以减少动态内存的占用量，同时减少多个虚拟机在同一个物理或虚拟的机器上运行时的资源占用。<br>自 Java 8 以来，在基本 CDS 功能上进行了许多增强、改进，启用 CDS 后应用的启动时间和内存占用量显着减少。使用 Java 11 早期版本在 64 位 Linux 平台上运行 HelloWorld 进行测试，测试结果显示启动时间缩短有 32 ％，同时在其他 64 位平台上，也有类似或更高的启动性能提升。<br>Java 12 针对 64 位平台下的 JDK 构建过程进行了增强改进，使其默认生成类数据共享（CDS）归档，以进一步达到改进应用程序的启动时间的目的，同时也避免了需要手动运行：<code>-Xshare:dump</code> 的需要，修改后的 JDK 将在 <code>lib/server</code> 目录中保留构建时生成的 CDS 存档。<br>当然如果需要，也可以添加其他 GC 参数，来调整堆大小等，以获得更优的内存分布情况，同时用户也可以像之前一样创建自定义的 CDS 存档文件。</p>
<h2 id="改善-G1-垃圾收集器，使其能够中止混合集合"><a href="#改善-G1-垃圾收集器，使其能够中止混合集合" class="headerlink" title="改善 G1 垃圾收集器，使其能够中止混合集合"></a>改善 G1 垃圾收集器，使其能够中止混合集合</h2><p>G1 是垃圾收集器，设计用于具有大量内存的多处理器机器，提高了垃圾回收效率。该垃圾收集器 设计的主要目标之一是满足用户设置的预期的 JVM 停顿时间，G1 采用一个高级分析引擎来选择在收集期间要处理的工作量，此选择过程的结果是一组称为 GC 回收集的区域。一旦收集器确定了 GC 回收集 并且 GC 回收、整理工作已经开始，则 G1 收集器必须完成收集集合集的所有区域中的所有活动对象之后才能停止；但是如果收集器选择过大的 GC 回收集，可能会导致 G1 回收器停顿时间超过预期时间。<br>Java 12 中将把 GC 回收集（混合收集集合）拆分为必需和可选两部分，使 G1 垃圾回收器能中止垃圾回收过程。其中必需处理的部分包括 G1 垃圾收集器不能递增处理的 GC 回收集的部分（如：年轻代），同时也可以包含老年代以提高处理效率。将 GC 回收集拆分为必需和可选部分时，需要为可选 GC 回收集部分维护一些其他数据，这会产生轻微的 CPU 开销，但小于 1 ％的变化，同时在 G1 回收器处理 GC 回收集期间，本机内存使用率也可能会增加，使用上述情况只适用于包含可选 GC 回收部分的 GC 混合回收集合。<br>在 G1 垃圾回收器完成收集需要必需回收的部分之后，便开始收集可选的部分，如果还有时间的话，但是粗粒度的处理，可选部分的处理粒度取决于剩余的时间，一次只能处理可选部分的一个子集区域。在完成可选收集部分的收集后，G1 垃圾回收器可以根据剩余时间决定是否停止收集。如果在处理完 必需处理的 部分后，属于时间不足，总时间花销接近预期时间，G1 垃圾回收器也可以中止可选部分的回收以达到满足预期停顿时间的目标。</p>
<h2 id="增强-G1-垃圾收集器，使其能自动返回未用堆内存给操作系统"><a href="#增强-G1-垃圾收集器，使其能自动返回未用堆内存给操作系统" class="headerlink" title="增强 G1 垃圾收集器，使其能自动返回未用堆内存给操作系统"></a>增强 G1 垃圾收集器，使其能自动返回未用堆内存给操作系统</h2><p>上节中介绍了 Java 12 中增强了 G1 垃圾收集器关于混合收集集合的处理策略，这节主要介绍在 Java 12 中同时也对 G1 垃圾回收器进行了改进，使其能够在空闲时自动将 Java 堆内存返还给操作系统，这也是 Java 12 中的另外一项重大改进。<br>目前 Java 11 版本中包含的 G1 垃圾收集器 暂时无法及时将已提交的 Java 堆内存返回给操作系统， G1 垃圾收集器仅在进行完整 GC (Full GC) 或并发处理周期时才能将 Java 堆返回内存。由于 G1 回收器尽可能避免完整 GC，并且只触发基于 Java 堆占用和分配活动的并发周期，因此在许多情况下 G 1 垃圾回收器不能回收 Java 堆内存，除非有外部强制执行。<br>在使用云平台的容器环境中，这种不利之处特别明显。即使在虚拟机不活动，但如果仍然使用其分配的内存资源，哪怕是其中的一小部分，G1 回收器也仍将保留所有已分配的 Java 堆内存。而这将导致用户需要始终为所有资源付费，哪怕是实际并未用到，而云提供商也无法充分利用其硬件。如果在次期间虚拟机能够检测到 Java 堆内存的实际使用情况，并在利用空闲时间自动将 Java 堆内存返还，则两者都将受益。<br>为了尽可能的向操作系统返回空闲内存，G1 垃圾收集器将在应用程序不活动期间定期生成或持续循环检查整体 Java 堆使用情况，以便 G 1 垃圾收集器能够更及时的将 Java 堆中不使用内存部分返还给操作系统。对于长时间处于空闲状态的应用程序，此项改进将使 JVM 的内存利用率更加高效。<br>如果应用程序为非活动状态，在下面两种情况下，G1 回收器会触发定期垃圾收集：</p>
<ul>
<li>自上次垃圾回收完成 以来已超过 <code>G1PeriodicGCInterva</code> l 毫秒， 并且此时没有正在进行的垃圾回收任务。如果 <code>G1PeriodicGCInterval</code> 值为零表示禁用快速回收内存的定期垃圾收集。</li>
<li>应用所在主机系统上执行方法 <code>getloadavg()</code>，一分钟内系统返回的平均负载值低于 <code>G1PeriodicGCSystemLoadThreshold</code>。如果 <code>G1PeriodicGCSystemLoadThreshold</code> 值为零，则此条件不生效。</li>
</ul>
<p>如果不满足上述条件中的任何一个，则取消当期的定期垃圾回收。等一个 <code>G1PeriodicGCInterval</code> 时间周期后，将重新考虑是否执行定期垃圾回收。<br>G1 定期垃圾收集的类型根据 <code>G1PeriodicGCInvokesConcurrent</code> 参数的值确定：如果设置值了，G1 垃圾回收器将继续上一个或者启动一个新并发周期；如果没有设置值，则 G1 回收器将执行一个完整的 GC。在每次一次 GC 回收末尾，G1 回收器将调整当前的 Java 堆大小，此时便有可能会将未使用内存返还给操作系统。新的 Java 堆内存大小根据现有配置确定，具体包括下列配置：<code>- XX:MinHeapFreeRatio</code>、<code>-XX:MaxHeapFreeRatio</code>、<code>-Xms</code>、<code>-Xmx</code>。<br>默认情况下，G1 回收器在定期垃圾回收期间新启动或继续上一轮并发周期，将最大限度地减少应用程序的中断。如果定期垃圾收集严重影响程序执行，则需要考虑整个系统 CPU 负载，或让用户禁用定期垃圾收集。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>自上次 Java 11 发布后，很快我们又迎来了 Java 12 版本的更新。Java 12 版本虽然是非 LTS 版本，但是这次更新也带来了不少 JVM、GC 功能增强、改进，本文主要针对其中几个影响重大变化以及主要的特性做了介绍。Java 12 已经来了，还跟得上更新的节奏吗？<br>本文只是个人的一点思考，仅代表个人观点，不代表作者所在单位的意见，如有不足之处，还望各位读者能够海涵，如可以，希望读者们能够反馈意见，交流心得，一同进步。</p>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul>
<li>参考 <a href="https://openjdk.java.net/projects/jdk/12/" target="_blank" rel="noopener">JDK 12</a>，查看更多有关 Java 12 的最新信息。</li>
<li>参考 <a href="https://wiki.openjdk.java.net/display/shenandoah" target="_blank" rel="noopener">Shenandoah wiki page</a>，查看更多有关 Shenandoah 的最新信息。</li>
<li>参考 <a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-11/index.html" target="_blank" rel="noopener">Java 11 新特性介绍</a></li>
</ul>
<blockquote>
<p>作者：李林锋</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-12/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-12/index.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>Java 11 新特性介绍</title>
    <url>/2019/12/26/Java-11-%E6%96%B0%E7%89%B9%E6%80%A7%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>Java 11 已于 2018 年 9 月 25 日正式发布，之前在 <a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-10/index.html" target="_blank" rel="noopener">Java 10 新特性介绍</a>中介绍过，为了加快的版本迭代、跟进社区反馈，Java 的版本发布周期调整为每六个月一次——即每半年发布一个大版本，每个季度发布一个中间特性版本，并且做出不会跳票的承诺。通过这样的方式，Java 开发团队能够将一些重要特性尽早的合并到 Java Release 版本中，以便快速得到开发者的反馈，避免出现类似 Java 9 发布时的两次延期的情况。<br>按照官方介绍，新的版本发布周期将会严格按照时间节点，于每年的 3 月和 9 月发布，Java 11 发布的时间节点也正好处于 Java 8 免费更新到期的前夕。与 Java 9 和 Java 10 这两个被称为”功能性的版本”不同，Java 11 仅将提供长期支持服务（LTS, Long-Term-Support），还将作为 Java 平台的默认支持版本，并且会提供技术支持直至 2023 年 9 月，对应的补丁和安全警告等支持将持续至 2026 年。<br>本文主要针对 Java 11 中的新特性展开介绍，让您快速了解 Java 11 带来的变化。</p>
<a id="more"></a>

<h2 id="基于嵌套的访问控制"><a href="#基于嵌套的访问控制" class="headerlink" title="基于嵌套的访问控制"></a>基于嵌套的访问控制</h2><p>与 Java 语言中现有的嵌套类型概念一致, 嵌套访问控制是一种控制上下文访问的策略，允许逻辑上属于同一代码实体，但被编译之后分为多个分散的 class 文件的类，无需编译器额外的创建可扩展的桥接访问方法，即可访问彼此的私有成员，并且这种改进是在 Java 字节码级别的。<br>在 Java 11 之前的版本中，编译之后的 class 文件中通过 InnerClasses 和 Enclosing Method 两种属性来帮助编译器确认源码的嵌套关系，每一个嵌套的类会编译到自己所在的 class 文件中，不同类的文件通过上面介绍的两种属性的来相互连接。这两种属性对于编译器确定相互之间的嵌套关系已经足够了，但是并不适用于访问控制。这里大家可以写一段包含内部类的代码，并将其编译成 class 文件，然后通过 <code>javap</code> 命令行来分析，碍于篇幅，这里就不展开讨论了。<br>Java 11 中引入了两个新的属性：一个叫做 NestMembers 的属性，用于标识其它已知的静态 nest 成员；另外一个是每个 nest 成员都包含的 NestHost 属性，用于标识出它的 nest 宿主类。</p>
<h2 id="标准-HTTP-Client-升级"><a href="#标准-HTTP-Client-升级" class="headerlink" title="标准 HTTP Client 升级"></a>标准 HTTP Client 升级</h2><p>Java 11 对 Java 9 中引入并在 Java 10 中进行了更新的 Http Client API 进行了标准化，在前两个版本中进行孵化的同时，Http Client 几乎被完全重写，并且现在完全支持异步非阻塞。<br>新版 Java 中，Http Client 的包名由 jdk.incubator.http 改为 java.net.http，该 API 通过 CompleteableFutures 提供非阻塞请求和响应语义，可以联合使用以触发相应的动作，并且 <em>RX Flo**w</em> 的概念也在 Java 11 中得到了实现。现在，在用户层请求发布者和响应发布者与底层套接字之间追踪数据流更容易了。这降低了复杂性，并最大程度上提高了 HTTP / 1 和 HTTP / 2 之间的重用的可能性。<br>Java 11 中的新 Http Client API，提供了对 HTTP/2 等业界前沿标准的支持，同时也向下兼容 HTTP/1.1，精简而又友好的 API 接口，与主流开源 API（如：Apache HttpClient、Jetty、OkHttp 等）类似甚至拥有更高的性能。与此同时它是 Java 在 Reactive-Stream 方面的第一个生产实践，其中广泛使用了 Java Flow API，终于让 Java 标准 HTTP 类库在扩展能力等方面，满足了现代互联网的需求，是一个难得的现代 Http/2 Client API 标准的实现，Java 工程师终于可以摆脱老旧的 HttpURLConnection 了。下面模拟 Http GET 请求并打印返回内容：</p>
<p>清单 1. GET 请求示例</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">HttpClient client = <span class="module-access"><span class="module"><span class="identifier">HttpClient</span>.</span></span><span class="keyword">new</span><span class="constructor">HttpClient()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">HttpRequest request = <span class="module-access"><span class="module"><span class="identifier">HttpRequest</span>.</span></span><span class="keyword">new</span><span class="constructor">Builder()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      .uri(<span class="module-access"><span class="module"><span class="identifier">URI</span>.</span></span>create(<span class="string">"http://openjdk.java.net/"</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">      .build<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">client.send<span class="constructor">Async(<span class="params">request</span>, BodyHandlers.<span class="params">ofString</span>()</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">      .<span class="keyword">then</span><span class="constructor">Apply(HttpResponse::<span class="params">body</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      .<span class="keyword">then</span><span class="constructor">Accept(System.<span class="params">out</span>::<span class="params">println</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      .join<span class="literal">()</span>;</span></pre></td></tr></table></figure>

<h2 id="Epsilon：低开销垃圾回收器"><a href="#Epsilon：低开销垃圾回收器" class="headerlink" title="Epsilon：低开销垃圾回收器"></a>Epsilon：低开销垃圾回收器</h2><p>Epsilon 垃圾回收器的目标是开发一个控制内存分配，但是不执行任何实际的垃圾回收工作。它提供一个完全消极的 GC 实现，分配有限的内存资源，最大限度的降低内存占用和内存吞吐延迟时间。<br>Java 版本中已经包含了一系列的高度可配置化的 GC 实现。各种不同的垃圾回收器可以面对各种情况。但是有些时候使用一种独特的实现，而不是将其堆积在其他 GC 实现上将会是事情变得更加简单。<br>下面是 no-op GC 的几个使用场景：</p>
<ul>
<li>性能测试：什么都不执行的 GC 非常适合用于 GC 的差异性分析。no-op （无操作）GC 可以用于过滤掉 GC 诱发的性能损耗，比如 GC 线程的调度，GC 屏障的消耗，GC 周期的不合适触发，内存位置变化等。此外有些延迟者不是由于 GC 引起的，比如 scheduling hiccups, compiler transition hiccups，所以去除 GC 引发的延迟有助于统计这些延迟。</li>
<li>内存压力测试：在测试 Java 代码时，确定分配内存的阈值有助于设置内存压力常量值。这时 no-op 就很有用，它可以简单地接受一个分配的内存分配上限，当内存超限时就失败。例如：测试需要分配小于 1G 的内存，就使用-Xmx1g 参数来配置 no-op GC，然后当内存耗尽的时候就直接 crash。</li>
<li>VM 接口测试：以 VM 开发视角，有一个简单的 GC 实现，有助于理解 VM-GC 的最小接口实现。它也用于证明 VM-GC 接口的健全性。</li>
<li>极度短暂 job 任务：一个短声明周期的 job 任务可能会依赖快速退出来释放资源，这个时候接收 GC 周期来清理 heap 其实是在浪费时间，因为 heap 会在退出时清理。并且 GC 周期可能会占用一会时间，因为它依赖 heap 上的数据量。</li>
<li>延迟改进：对那些极端延迟敏感的应用，开发者十分清楚内存占用，或者是几乎没有垃圾回收的应用，此时耗时较长的 GC 周期将会是一件坏事。</li>
<li>吞吐改进：即便对那些无需内存分配的工作，选择一个 GC 意味着选择了一系列的 GC 屏障，所有的 OpenJDK GC 都是分代的，所以他们至少会有一个写屏障。避免这些屏障可以带来一点点的吞吐量提升。</li>
</ul>
<p>Epsilon 垃圾回收器和其他 OpenJDK 的垃圾回收器一样，可以通过参数 <code>-XX:+UseEpsilonGC</code>开启。<br>Epsilon 线性分配单个连续内存块。可复用现存 VM 代码中的 TLAB 部分的分配功能。非 TLAB 分配也是同一段代码，因为在此方案中，分配 TLAB 和分配大对象只有一点点的不同。Epsilon 用到的 barrier 是空的(或者说是无操作的)。因为该 GC<br>执行任何的 GC 周期，不用关系对象图，对象标记，对象复制等。引进一种新的 barrier-set 实现可能是该 GC 对 JVM 最大的变化。</p>
<h2 id="简化启动单个源代码文件的方法"><a href="#简化启动单个源代码文件的方法" class="headerlink" title="简化启动单个源代码文件的方法"></a>简化启动单个源代码文件的方法</h2><p>Java 11 版本中最令人兴奋的功能之一是增强 Java 启动器，使之能够运行单一文件的 Java 源代码。此功能允许使用 Java 解释器直接执行 Java 源代码。源代码在内存中编译，然后由解释器执行。唯一的约束在于所有相关的类必须定义在同一个 Java 文件中。<br>此功能对于开始学习 Java 并希望尝试简单程序的人特别有用，并且能与 jshell 一起使用，将成为任何初学者学习语言的一个很好的工具集。不仅初学者会受益，专业人员还可以利用这些工具来探索新的语言更改或尝试未知的 API。<br>如今单文件程序在编写小实用程序时很常见，特别是脚本语言领域。从中开发者可以省去用 Java 编译程序等不必要工作，以及减少新手的入门障碍。在基于 Java 10 的程序实现中可以通过三种方式启动：</p>
<ul>
<li>作为 * .class 文件</li>
<li>作为 * .jar 文件中的主类</li>
<li>作为模块中的主类</li>
</ul>
<p>而在最新的 Java 11 中新增了一个启动方式，即可以在源代码中声明类，例如：如果名为 HelloWorld.java 的文件包含一个名为 hello.World 的类，那么该命令：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">$ java <span class="module-access"><span class="module"><span class="identifier">HelloWorld</span>.</span></span>java</span></pre></td></tr></table></figure>

<p>也等同于：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">javac </span>HelloWorld.<span class="keyword">java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">$ </span><span class="keyword">java </span>-cp . hello.World</span></pre></td></tr></table></figure>

<h2 id="用于-Lambda-参数的局部变量语法"><a href="#用于-Lambda-参数的局部变量语法" class="headerlink" title="用于 Lambda 参数的局部变量语法"></a>用于 Lambda 参数的局部变量语法</h2><p>在 Lambda 表达式中使用局部变量类型推断是 Java 11 引入的唯一与语言相关的特性，这一节，我们将探索这一新特性。<br>从 Java 10 开始，便引入了局部变量类型推断这一关键特性。类型推断允许使用关键字 var 作为局部变量的类型而不是实际类型，编译器根据分配给变量的值推断出类型。这一改进简化了代码编写、节省了开发者的工作时间，因为不再需要显式声明局部变量的类型，而是可以使用关键字 var，且不会使源代码过于复杂。<br>可以使用关键字 var 声明局部变量，如下所示：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">var s = <span class="string">"Hello Java 11"</span><span class="comment">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.println(s)<span class="comment">;</span></span></pre></td></tr></table></figure>

<p>但是在 Java 10 中，还有下面几个限制：</p>
<ul>
<li>只能用于局部变量上</li>
<li>声明时必须初始化</li>
<li>不能用作方法参数</li>
<li>不能在 Lambda 表达式中使用</li>
</ul>
<p>Java 11 与 Java 10 的不同之处在于允许开发者在 Lambda 表达式中使用 var 进行参数声明。乍一看，这一举措似乎有点多余，因为在写代码过程中可以省略 Lambda 参数的类型，并通过类型推断确定它们。但是，添加上类型定义同时使用 <code>@Nonnull</code> 和 <code>@Nullable</code> 等类型注释还是很有用的，既能保持与局部变量的一致写法，也不丢失代码简洁。<br>Lambda 表达式使用隐式类型定义，它形参的所有类型全部靠推断出来的。隐式类型 Lambda 表达式如下：</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">(<span class="symbol">x</span>, <span class="symbol">y</span>) -&gt; <span class="symbol">x</span>.process(<span class="symbol">y</span>)</span></pre></td></tr></table></figure>

<p>Java 10 为局部变量提供隐式定义写法如下：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> x = <span class="literal">new</span> Foo();</span></pre></td></tr><tr><td class="code"><pre><span class="line">for (<span class="built_in">var</span> x : xs) &#123; <span class="params">...</span> &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">try (<span class="built_in">var</span> x = <span class="params">...</span>) &#123; <span class="params">...</span> &#125; catch <span class="params">...</span></span></pre></td></tr></table></figure>

<p>为了 Lambda 类型表达式中正式参数定义的语法与局部变量定义语法的不一致，且为了保持与其他局部变量用法上的一致性，希望能够使用关键字 var 隐式定义 Lambda 表达式的形参：</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">(<span class="keywords">var</span> <span class="symbol">x</span>, <span class="keywords">var</span> <span class="symbol">y</span>) -&gt; <span class="symbol">x</span>.process(<span class="symbol">y</span>)</span></pre></td></tr></table></figure>

<p>于是在 Java 11 中将局部变量和 Lambda 表达式的用法进行了统一，并且可以将注释应用于局部变量和 Lambda 表达式：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">@Nonnull <span class="keyword">var</span> x = <span class="keyword">new</span> Foo();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">(@Nonnull <span class="keyword">var</span> x, @Nullable <span class="keyword">var</span> y)</span> -&gt;</span> x.process(y)</span></pre></td></tr></table></figure>

<h2 id="低开销的-Heap-Profiling"><a href="#低开销的-Heap-Profiling" class="headerlink" title="低开销的 Heap Profiling"></a>低开销的 Heap Profiling</h2><p>Java 11 中提供一种低开销的 Java 堆分配采样方法，能够得到堆分配的 Java 对象信息，并且能够通过 JVMTI 访问堆信息。<br>引入这个低开销内存分析工具是为了达到如下目的：</p>
<ul>
<li>足够低的开销，可以默认且一直开启</li>
<li>能通过定义好的程序接口访问</li>
<li>能够对所有堆分配区域进行采样</li>
<li>能给出正在和未被使用的 Java 对象信息</li>
</ul>
<p>对用户来说，了解它们堆里的内存分布是非常重要的，特别是遇到生产环境中出现的高 CPU、高内存占用率的情况。目前有一些已经开源的工具，允许用户分析应用程序中的堆使用情况，比如：Java Flight Recorder、jmap、YourKit 以及 VisualVM tools.。但是这些工具都有一个明显的不足之处：无法得到对象的分配位置，headp dump 以及 heap histogram 中都没有包含对象分配的具体信息，但是这些信息对于调试内存问题至关重要，因为它能够告诉开发人员他们的代码中发生的高内存分配的确切位置，并根据实际源码来分析具体问题，这也是 Java 11 中引入这种低开销堆分配采样方法的原因。</p>
<h2 id="支持-TLS-1-3-协议"><a href="#支持-TLS-1-3-协议" class="headerlink" title="支持 TLS 1.3 协议"></a>支持 TLS 1.3 协议</h2><p>Java 11 中包含了传输层安全性（TLS）1.3 规范（RFC 8446）的实现，替换了之前版本中包含的 TLS，包括 TLS 1.2，同时还改进了其他 TLS 功能，例如 OCSP 装订扩展（RFC 6066，RFC 6961），以及会话散列和扩展主密钥扩展（RFC 7627），在安全性和性能方面也做了很多提升。<br>新版本中包含了 Java 安全套接字扩展（JSSE）提供 SSL，TLS 和 DTLS 协议的框架和 Java 实现。目前，JSSE API 和 JDK 实现支持 SSL 3.0，TLS 1.0，TLS 1.1，TLS 1.2，DTLS 1.0 和 DTLS 1.2。<br>同时 Java 11 版本中实现的 TLS 1.3，重新定义了以下新标准算法名称：</p>
<ol>
<li>TLS 协议版本名称：TLSv1.3</li>
<li>SSLContext 算法名称：TLSv1.3</li>
<li>TLS 1.3 的 TLS 密码套件名称：TLS_AES_128_GCM_SHA256，TLS_AES_256_GCM_SHA384</li>
<li>用于 X509KeyManager 的 keyType：RSASSA-PSS</li>
<li>用于 X509TrustManager 的 authType：RSASSA-PSS</li>
</ol>
<p>还为 TLS 1.3 添加了一个新的安全属性 jdk.tls.keyLimits。当处理了特定算法的指定数据量时，触发握手后，密钥和 IV 更新以导出新密钥。还添加了一个新的系统属性 jdk.tls.server.protocols，用于在 SunJSSE 提供程序的服务器端配置默认启用的协议套件。<br>之前版本中使用的 KRB5​​密码套件实现已从 Java 11 中删除，因为该算法已不再安全。同时注意，TLS 1.3 与以前的版本不直接兼容。<br>升级到 TLS 1.3 之前，需要考虑如下几个兼容性问题：</p>
<ol>
<li>TLS 1.3 使用半关闭策略，而 TLS 1.2 以及之前版本使用双工关闭策略，对于依赖于双工关闭策略的应用程序，升级到 TLS 1.3 时可能存在兼容性问题。</li>
<li>TLS 1.3 使用预定义的签名算法进行证书身份验证，但实际场景中应用程序可能会使用不被支持的签名算法。</li>
<li>TLS 1.3 再支持 DSA 签名算法，如果在服务器端配置为仅使用 DSA 证书，则无法升级到 TLS 1.3。</li>
<li>TLS 1.3 支持的加密套件与 TLS 1.2 和早期版本不同，若应用程序硬编码了加密算法单元，则在升级的过程中需要修改相应代码才能升级使用 TLS 1.3。</li>
<li>TLS 1.3 版本的 session 用行为及秘钥更新行为与 1.2 及之前的版本不同，若应用依赖于 TLS 协议的握手过程细节，则需要注意。</li>
</ol>
<h2 id="ZGC：可伸缩低延迟垃圾收集器"><a href="#ZGC：可伸缩低延迟垃圾收集器" class="headerlink" title="ZGC：可伸缩低延迟垃圾收集器"></a>ZGC：可伸缩低延迟垃圾收集器</h2><p>ZGC 即 Z Garbage Collector（垃圾收集器或垃圾回收器），这应该是 Java 11 中最为瞩目的特性，没有之一。ZGC 是一个可伸缩的、低延迟的垃圾收集器，主要为了满足如下目标进行设计：</p>
<ul>
<li>GC 停顿时间不超过 10ms</li>
<li>即能处理几百 MB 的小堆，也能处理几个 TB 的大堆</li>
<li>应用吞吐能力不会下降超过 15%（与 G1 回收算法相比）</li>
<li>方便在此基础上引入新的 GC 特性和利用 colord</li>
<li>针以及 Load barriers 优化奠定基础</li>
<li>当前只支持 Linux/x64 位平台</li>
</ul>
<p>停顿时间在 10ms 以下，10ms 其实是一个很保守的数据，即便是 10ms 这个数据，也是 GC 调优几乎达不到的极值。根据 SPECjbb 2015 的基准测试，128G 的大堆下最大停顿时间才 1.68ms，远低于 10ms，和 G1 算法相比，改进非常明显。</p>
<p>图 1. 回收算法停顿时间对比</p>
<p><img src="http://image.winrains.cn/2019/08/c047b-image001.png" alt="img"></p>
<p><em>本图片引用自：</em><a href="http://cr.openjdk.java.net/~pliden/slides/ZGC-FOSDEM-2018.pdf" target="_blank" rel="noopener"><em>The Z Garbage Collector - An Introduction</em></a><br>不过目前 ZGC 还处于实验阶段，目前只在 Linux/x64 上可用，如果有足够的需求，将来可能会增加对其他平台的支持。同时作为实验性功能的 ZGC 将不会出现在 JDK 构建中，除非在编译时使用 configure 参数：<code>--with-jvm-features=zgc</code> 显式启用。<br>在实验阶段，编译完成之后，已经迫不及待的想试试 ZGC，需要配置以下 JVM 参数，才能使用 ZGC，具体启动 ZGC 参数如下：<br><code>-XX：+ UnlockExperimentalVMOptions -XX：+ UseZGC -Xmx10g</code><br>其中参数：<code>-Xmx</code>是 ZGC 收集器中最重要的调优选项，大大解决了程序员在 JVM 参数调优上的困扰。ZGC 是一个并发收集器，必须要设置一个最大堆的大小，应用需要多大的堆，主要有下面几个考量：</p>
<ul>
<li>对象的分配速率，要保证在 GC 的时候，堆中有足够的内存分配新对象。</li>
<li>一般来说，给 ZGC 的内存越多越好，但是也不能浪费内存，所以要找到一个平衡。</li>
</ul>
<h2 id="飞行记录器"><a href="#飞行记录器" class="headerlink" title="飞行记录器"></a>飞行记录器</h2><p>飞行记录器之前是商业版 JDK 的一项分析工具，但在 Java 11 中，其代码被包含到公开代码库中，这样所有人都能使用该功能了。<br>Java 语言中的飞行记录器类似飞机上的黑盒子，是一种低开销的事件信息收集框架，主要用于对应用程序和 JVM 进行故障检查、分析。飞行记录器记录的主要数据源于应用程序、JVM 和 OS，这些事件信息保存在单独的事件记录文件中，故障发生后，能够从事件记录文件中提取出有用信息对故障进行分析。<br>启用飞行记录器参数如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:StartFlightRecording</span></span></pre></td></tr></table></figure>

<p>也可以使用 bin/jcmd 工具启动和配置飞行记录器：</p>
<p>清单 2. 飞行记录器启动、配置参数示例</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">jcmd </span>&lt;pid&gt; <span class="keyword">JFR.start</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">$ </span><span class="keyword">jcmd </span>&lt;pid&gt; <span class="keyword">JFR.dump </span>filename=recording.<span class="keyword">jfr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">$ </span><span class="keyword">jcmd </span>&lt;pid&gt; <span class="keyword">JFR.stop</span></span></pre></td></tr></table></figure>

<p>JFR 使用测试：</p>
<p>清单 3. JFR 使用示例</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FlightRecorderTest</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Label</span>(<span class="string">"Hello World"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Description</span>(<span class="string">"Helps the programmer getting started"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    static <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="meta">@Label</span>(<span class="string">"Message"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="type">String</span> message;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(<span class="type">String</span>[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="type">HelloWorld</span> event = <span class="keyword">new</span> <span class="type">HelloWorld</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        event.message = <span class="string">"hello, world!"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        event.commit();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在运行时加上如下参数：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">java -XX:<span class="attribute">StartFlightRecording</span>=duration=1s, <span class="attribute">filename</span>=recording.jfr</span></pre></td></tr></table></figure>

<p>下面读取上一步中生成的 JFR 文件：<code>recording.jfr</code></p>
<p>清单 4. 飞行记录器分析示例</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void read<span class="constructor">RecordFile()</span> throws IOException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    final Path path = <span class="module-access"><span class="module"><span class="identifier">Paths</span>.</span></span>get(<span class="string">"D:\\ java \\recording.jfr"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    final List&lt;RecordedEvent&gt; recordedEvents = <span class="module-access"><span class="module"><span class="identifier">RecordingFile</span>.</span></span>read<span class="constructor">AllEvents(<span class="params">path</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (RecordedEvent event : recordedEvents) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(event.get<span class="constructor">StartTime()</span> + <span class="string">","</span> + event.get<span class="constructor">Value(<span class="string">"message"</span>)</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="动态类文件常量"><a href="#动态类文件常量" class="headerlink" title="动态类文件常量"></a>动态类文件常量</h2><p>为了使 JVM 对动态语言更具吸引力，Java 的第七个版本已将 invokedynamic 引入其指令集。<br>过 Java 开发人员通常不会注意到此功能，因为它隐藏在 Java 字节代码中。通过使用 invokedynamic，可以延迟方法调用的绑定，直到第一次调用。例如，Java 语言使用该技术来实现 Lambda 表达式，这些表达式仅在首次使用时才显示出来。这样做，invokedynamic 已经演变成一种必不可少的语言功能。<br>Java 11 引入了类似的机制，扩展了 Java 文件格式，以支持新的常量池：CONSTANT_Dynamic，它在初始化的时候，像 invokedynamic<br>令生成代理方法一样，委托给 bootstrap 方法进行初始化创建，对上层软件没有很大的影响，降低开发新形式的可实现类文件约束带来的成本和干扰。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>Java 在更新发布周期为每半年发布一次之后，在合并关键特性、快速得到开发者反馈等方面，做得越来越好。Java 11 版本的发布也带来了不少新特性和功能增强、性能提升、基础能力的全面进步和突破，本文针对其中对使用人员影响重大的以及主要的特性做了介绍。Java 12 即将到来，您准备好了吗？<br>本文仅代表作者个人观点，不代表其所在单位的意见，如有不足之处，还望您能够海涵。希望您能够反馈意见，交流心得，一同进步。</p>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul>
<li>参考 <a href="https://openjdk.java.net/projects/jdk/11/" target="_blank" rel="noopener">JDK 11</a>，查看更多有关 Java 10 的最新信息。</li>
<li>参考 <a href="http://cr.openjdk.java.net/~pliden/slides/ZGC-FOSDEM-2018.pdf" target="_blank" rel="noopener">The Z Garbage Collector - An Introduction</a>，查看更多有关 ZGC 的最新信息。</li>
<li><a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-10/index.html" target="_blank" rel="noopener">Java 10 新特性介绍</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-tutorials-migration-to-java-11-made-easy/index.html" target="_blank" rel="noopener">轻松迁移至 Java 11</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-12/index.html" target="_blank" rel="noopener">Java 12 新特性概述</a></li>
</ul>
<blockquote>
<p>作者：李林锋</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-11/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-11/index.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>Java 10 新特性介绍</title>
    <url>/2019/12/26/Java-10-%E6%96%B0%E7%89%B9%E6%80%A7%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>作为当今使用最广泛的编程语言之一的 Java 在 2018 年 3 月 21 日发布了第十个大版本。为了更快地迭代、更好地跟进社区反馈，Java 语言版本发布周期调整为每隔 6 个月发布一次。Java 10 是这一新规则之后，采用新发布周期的第一个大版本。Java 10 版本带来了很多新特性，其中最备受广大开发者关注的莫过于局部变量类型推断。除此之外，还有其他包括垃圾收集器改善、GC 改进、性能提升、线程管控等一批新特性。本文主要针对 Java 10 中的新特性展开介绍，希望读者能从本文的介绍中快速了解 Java 10 带来的变化。</p>
<a id="more"></a>

<h2 id="局部变量类型推断"><a href="#局部变量类型推断" class="headerlink" title="局部变量类型推断"></a>局部变量类型推断</h2><p>局部变量类型推断是 Java 10 中最值得开发人员注意的新特性，这是 Java 语言开发人员为了简化 Java 应用程序的编写而进行的又一重要改进。<br>这一新功能将为 Java 增加一些新语法，允许开发人员省略通常不必要的局部变量类型初始化声明。新的语法将减少 Java 代码的冗长度，同时保持对静态类型安全性的承诺。局部变量类型推断主要是向 Java 语法中引入在其他语言（比如 C#、JavaScript）中很常见的保留类型名称 <code>var</code>。但需要特别注意的是：<code>var</code> 不是一个关键字，而是一个保留字。只要编译器可以推断此种类型，开发人员不再需要专门声明一个局部变量的类型，也就是可以随意定义变量而不必指定变量的类型。这种改进对于链式表达式来说，也会很方便。以下是一个简单的例子：</p>
<p>清单 1. 局部变量类型推断示例</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">list</span> = <span class="literal">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;(); <span class="comment">// ArrayList&lt;String&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> stream = <span class="built_in">list</span>.stream(); <span class="comment">// Stream&lt;String&gt;</span></span></pre></td></tr></table></figure>

<p>看着是不是有点 JS 的感觉？有没有感觉越来越像 JS 了？虽然变量类型的推断在 Java 中不是一个崭新的概念，但在局部变量中确是很大的一个改进。说到变量类型推断，从 Java 5 中引进泛型，到 Java 7 的 <code>&lt;&gt;</code> 操作符允许不绑定类型而初始化 List，再到 Java 8 中的 Lambda 表达式，再到现在 Java 10 中引入的局部变量类型推断，Java 类型推断正大刀阔斧地向前进步、发展。<br>而上面这段例子，在以前版本的 Java 语法中初始化列表的写法为：</p>
<p>清单 2. Java 类型初始化示例</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; stream = getStream();</span></pre></td></tr></table></figure>

<p>在运算符允许在没有绑定 <code>ArrayList &lt;&gt;</code> 的类型的情况下初始化列表的写法为：</p>
<p>清单 3. Java 7 之后版本类型初始化示例</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; stream = getStream();</span></pre></td></tr></table></figure>

<p>但这种 var 变量类型推断的使用也有局限性，仅局限于具有初始化器的局部变量、增强型 for 循环中的索引变量以及在传统 for 循环中声明的局部变量，而不能用于推断方法的参数类型，不能用于构造函数参数类型推断，不能用于推断方法返回类型，也不能用于字段类型推断，同时还不能用于捕获表达式（或任何其他类型的变量声明）。<br>不过对于开发者而言，变量类型显式声明会提供更加全面的程序语言信息，对于理解和维护代码有很大的帮助。Java 10 中新引入的局部变量类型推断能够帮助我们快速编写更加简洁的代码，但是局部变量类型推断的保留字 <code>var</code> 的使用势必会引起变量类型可视化缺失，并不是任何时候使用 var 都能容易、清晰的分辨出变量的类型。一旦 <code>var</code> 被广泛运用，开发者在没有 IDE 的支持下阅读代码，势必会对理解程序的执行流程带来一定的困难。所以还是建议尽量显式定义变量类型，在保持代码简洁的同时，也需要兼顾程序的易读性、可维护性。</p>
<h2 id="整合-JDK-代码仓库"><a href="#整合-JDK-代码仓库" class="headerlink" title="整合 JDK 代码仓库"></a>整合 JDK 代码仓库</h2><p>为了简化开发流程，Java 10 中会将多个代码库合并到一个代码仓库中。<br>在已发布的 Java 版本中，JDK 的整套代码根据不同功能已被分别存储在多个 Mercurial 存储库，这八个 Mercurial 存储库分别是：root、corba、hotspot、jaxp、jaxws、jdk、langtools、nashorn。<br>虽然以上八个存储库之间相互独立以保持各组件代码清晰分离，但同时管理这些存储库存在许多缺点，并且无法进行相关联源代码的管理操作。其中最重要的一点是，涉及多个存储库的变更集无法进行原子提交 （atomic commit）。例如，如果一个 bug 修复时需要对独立存储两个不同代码库的代码进行更改，那么必须创建两个提交：每个存储库中各一个。这种不连续性很容易降低项目和源代码管理工具的可跟踪性和加大复杂性。特别是，不可能跨越相互依赖的变更集的存储库执行原子提交这种多次跨仓库的变化是常见现象。<br>为了解决这个问题，JDK 10 中将所有现有存储库合并到一个 Mercurial 存储库中。这种合并的一个次生效应是，单一的 Mercurial 存储库比现有的八个存储库要更容易地被镜像(作为一个 Git 存储库)，并且使得跨越相互依赖的变更集的存储库运行原子提交成为可能，从而简化开发和管理过程。虽然在整合过程中，外部开发人员有一些阻力，但是 JDK 开发团队已经使这一更改成为 JDK 10 的一部分。</p>
<h2 id="统一的垃圾回收接口"><a href="#统一的垃圾回收接口" class="headerlink" title="统一的垃圾回收接口"></a>统一的垃圾回收接口</h2><p>在当前的 Java 结构中，组成垃圾回收器（GC）实现的组件分散在代码库的各个部分。尽管这些惯例对于使用 GC 计划的 JDK 开发者来说比较熟悉，但对新的开发人员来说，对于在哪里查找特定 GC 的源代码，或者实现一个新的垃圾收集器常常会感到困惑。更重要的是，随着 Java modules 的出现，我们希望在构建过程中排除不需要的 GC，但是当前 GC 接口的横向结构会给排除、定位问题带来困难。<br>为解决此问题，需要整合并清理 GC 接口，以便更容易地实现新的 GC，并更好地维护现有的 GC。Java 10 中，hotspot/gc 代码实现方面，引入一个干净的 GC 接口，改进不同 GC 源代码的隔离性，多个 GC 之间共享的实现细节代码应该存在于辅助类中。这种方式提供了足够的灵活性来实现全新 GC 接口，同时允许以混合搭配方式重复使用现有代码，并且能够保持代码更加干净、整洁，便于排查收集器问题。</p>
<h2 id="并行全垃圾回收器-G1"><a href="#并行全垃圾回收器-G1" class="headerlink" title="并行全垃圾回收器 G1"></a>并行全垃圾回收器 G1</h2><p>大家如果接触过 Java 性能调优工作，应该会知道，调优的最终目标是通过参数设置来达到快速、低延时的内存垃圾回收以提高应用吞吐量，尽可能的避免因内存回收不及时而触发的完整 GC（Full GC 会带来应用出现卡顿）。<br>G1 垃圾回收器是 Java 9 中 Hotspot 的默认垃圾回收器，是以一种低延时的垃圾回收器来设计的，旨在避免进行 Full GC，但是当并发收集无法快速回收内存时，会触发垃圾回收器回退进行 Full GC。之前 Java 版本中的 G1 垃圾回收器执行 GC 时采用的是基于单线程标记扫描压缩算法（mark-sweep-compact）。为了最大限度地减少 Full GC 造成的应用停顿的影响，Java 10 中将为 G1 引入多线程并行 GC，同时会使用与年轻代回收和混合回收相同的并行工作线程数量，从而减少了 Full GC 的发生，以带来更好的性能提升、更大的吞吐量。<br>Java 10 中将采用并行化 mark-sweep-compact 算法，并使用与年轻代回收和混合回收相同数量的线程。具体并行 GC 线程数量可以通过：<code>-XX：ParallelGCThreads</code> 参数来调节，但这也会影响用于年轻代和混合收集的工作线程数。</p>
<h2 id="应用程序类数据共享"><a href="#应用程序类数据共享" class="headerlink" title="应用程序类数据共享"></a>应用程序类数据共享</h2><p>在 Java 5 中就已经引入了类数据共享机制 (Class Data Sharing，简称 CDS)，允许将一组类预处理为共享归档文件，以便在运行时能够进行内存映射以减少 Java 程序的启动时间，当多个 Java 虚拟机（JVM）共享相同的归档文件时，还可以减少动态内存的占用量，同时减少多个虚拟机在同一个物理或虚拟的机器上运行时的资源占用。简单来说，Java 安装程序会把 <code>rt.jar</code> 中的核心类提前转化成内部表示，转储到一个共享存档（shared archive）中。多个 Java 进程（或者说 JVM 实例）可以共享这部分数据。为改善启动和占用空间，Java 10 在现有的 CDS 功能基础上再次拓展，以允许应用类放置在共享存档中。<br>CDS 特性在原来的 bootstrap 类基础之上，扩展加入了应用类的 CDS (Application Class-Data Sharing) 支持。<br>其原理为：在启动时记录加载类的过程，写入到文本文件中，再次启动时直接读取此启动文本并加载。设想如果应用环境没有大的变化，启动速度就会得到提升。<br>可以想像为类似于操作系统的休眠过程，合上电脑时把当前应用环境写入磁盘，再次使用时就可以快速恢复环境。<br>对大型企业应用程序的内存使用情况的分析表明，此类应用程序通常会将数以万计的类加载到应用程序类加载器中，如果能够将 AppCDS 应用于这些应用，将为每个 JVM 进程节省数十乃至数百兆字节的内存。另外对于云平台上的微服务分析表明，许多服务器在启动时会加载数千个应用程序类，AppCDS 可以让这些服务快速启动并改善整个系统响应时间。</p>
<h2 id="线程-局部管控"><a href="#线程-局部管控" class="headerlink" title="线程-局部管控"></a>线程-局部管控</h2><p>在已有的 Java 版本中，JVM 线程只能全部启用或者停止，没法做到对单独某个线程的操作。为了能够对单独的某个线程进行操作，Java 10 中线程管控引入 JVM 安全点的概念，将允许在不运行全局 JVM 安全点的情况下实现线程回调，由线程本身或者 JVM 线程来执行，同时保持线程处于阻塞状态，这种方式使得停止单个线程变成可能，而不是只能启用或停止所有线程。通过这种方式显著地提高了现有 JVM 功能的性能开销，并且改变了到达 JVM 全局安全点的现有时间语义。<br>增加的参数为：<code>-XX:ThreadLocalHandshakes</code> (默认为开启)，将允许用户在支持的平台上选择安全点。</p>
<h2 id="移除-Native-Header-自动生成工具"><a href="#移除-Native-Header-自动生成工具" class="headerlink" title="移除 Native-Header 自动生成工具"></a>移除 Native-Header 自动生成工具</h2><p>自 Java 9 以来便开始了一些对 JDK 的调整，用户每次调用 javah 工具时会被警告该工具在未来的版本中将会执行的删除操作。当编译 JNI 代码时，已不再需要单独的 Native-Header 工具来生成头文件，因为这可以通过 Java 8（JDK-7150368）中添加的 <code>javac</code> 来完成。在未来的某一时刻，JNI 将会被 Panama 项目的结果取代，但是何时发生还没有具体时间表。</p>
<h2 id="额外的-Unicode-语言标签扩展"><a href="#额外的-Unicode-语言标签扩展" class="headerlink" title="额外的 Unicode 语言标签扩展"></a>额外的 Unicode 语言标签扩展</h2><p>自 Java 7 开始支持 BCP 47 语言标记以来， JDK 中便增加了与日历和数字相关的 Unicode 区域设置扩展，在 Java 9 中，新增支持 ca 和 nu 两种语言标签扩展。而在 Java 10 中将继续增加 Unicode 语言标签扩展，具体为：增强 <code>java.util.Locale</code> 类及其相关的 API，以更方便的获得所需要的语言地域环境信息。同时在这次升级中还带来了如下扩展支持：</p>
<p>表 1.Unicode 扩展表</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>cu</td>
<td>货币类型</td>
</tr>
<tr>
<td>fw</td>
<td>一周的第一天</td>
</tr>
<tr>
<td>rg</td>
<td>区域覆盖</td>
</tr>
<tr>
<td>tz</td>
<td>时区</td>
</tr>
</tbody></table>
<p>如 Java 10 加入的一个方法：</p>
<p>清单 4. Unicode 语言标签扩展示例</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">java</span><span class="selector-class">.time</span><span class="selector-class">.format</span><span class="selector-class">.DateTimeFormatter</span><span class="selector-pseudo">::localizedBy</span></span></pre></td></tr></table></figure>

<p>通过这个方法，可以采用某种数字样式，区域定义或者时区来获得时间信息所需的语言地域本地环境信息。</p>
<h2 id="备用存储装置上的堆分配"><a href="#备用存储装置上的堆分配" class="headerlink" title="备用存储装置上的堆分配"></a>备用存储装置上的堆分配</h2><p>硬件技术在持续进化，现在可以使用与传统 DRAM 具有相同接口和类似性能特点的非易失性 RAM。Java 10 中将使得 JVM 能够使用适用于不同类型的存储机制的堆，在可选内存设备上进行堆内存分配。<br>一些操作系统中已经通过文件系统提供了使用非 DRAM 内存的方法。例如：NTFS DAX 模式和 ext4 DAX。这些文件系统中的内存映射文件可绕过页面缓存并提供虚拟内存与设备物理内存的相互映射。与 DRAM 相比，NV-DIMM 可能具有更高的访问延迟，低优先级进程可以为堆使用 NV-DIMM 内存，允许高优先级进程使用更多 DRAM。<br>要在这样的备用设备上进行堆分配，可以使用堆分配参数 <code>-XX：AllocateHeapAt =</code>，这个参数将指向文件系统的文件并使用内存映射来达到在备用存储设备上进行堆分配的预期结果。</p>
<h2 id="基于-Java-的-实验性-JIT-编译器"><a href="#基于-Java-的-实验性-JIT-编译器" class="headerlink" title="基于 Java 的 实验性 JIT 编译器"></a>基于 Java 的 实验性 JIT 编译器</h2><p>Java 10 中开启了基于 Java 的 JIT 编译器 Graal，并将其用作 Linux/x64 平台上的实验性 JIT 编译器开始进行测试和调试工作，另外 Graal 将使用 Java 9 中引入的 JVM 编译器接口（JVMCI）。<br>Graal 是一个以 Java 为主要编程语言、面向 Java bytecode 的编译器。与用 C++实现的 C1 及 C2 相比，它的模块化更加明显，也更加容易维护。Graal 既可以作为动态编译器，在运行时编译热点方法；亦可以作为静态编译器，实现 AOT 编译。在 Java 10 中，Graal 作为试验性 JIT 编译器一同发布（JEP 317）。将 Graal 编译器研究项目引入到 Java 中，或许能够为 JVM 性能与当前 C++ 所写版本匹敌（或有幸超越）提供基础。<br>Java 10 中默认情况下 HotSpot 仍使用的是 C2 编译器，要启用 Graal 作为 JIT 编译器，请在 Java 命令行上使用以下参数：</p>
<p>清单 5. 启用 Graal 为 JIT 编译器示例</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-XX：+ UnlockExperimentalVMOptions -XX：+ UseJVMCICompiler</span></span></pre></td></tr></table></figure>

<h2 id="根证书认证"><a href="#根证书认证" class="headerlink" title="根证书认证"></a>根证书认证</h2><p>自 Java 9 起在 keytool 中加入参数 <code>-cacerts</code>，可以查看当前 JDK 管理的根证书。而 Java 9 中 <code>cacerts</code> 目录为空，这样就会给开发者带来很多不便。从 Java 10 开始，将会在 JDK 中提供一套默认的 CA 根证书。<br>作为 JDK 一部分的 <code>cacerts</code> 密钥库旨在包含一组能够用于在各种安全协议的证书链中建立信任的根证书。但是，JDK 源代码中的 <code>cacerts</code> 密钥库至目前为止一直是空的。因此，在 JDK 构建中，默认情况下，关键安全组件（如 TLS）是不起作用的。要解决此问题，用户必须使用一组根证书配置和 cacerts 密钥库下的 CA 根证书。</p>
<h2 id="基于时间的版本发布模式"><a href="#基于时间的版本发布模式" class="headerlink" title="基于时间的版本发布模式"></a>基于时间的版本发布模式</h2><p>虽然<a href="http://openjdk.java.net/jeps/223" target="_blank" rel="noopener"> JEP 223</a>中引入的版本字符串方案较以往有了显著的改进。但是，该方案并不适合以后严格按照六个月的节奏来发布 Java 新版本的这种情况。<br>按照 JEP 223 的语义中，每个基于 JDK 构建或使用组件的开发者（包括 JDK 的发布者）都必须提前敲定版本号，然后切换过去。开发人员则必须在代码中修改检查版本号的相关代码，这对所有参与者来说都很尴尬和混乱。<br>Java 10 中将重新编写之前 JDK 版本中引入的版本号方案，将使用基于时间模型定义的版本号格式来定义新版本。保留与 JEP 223 版本字符串方案的兼容性，同时也允许除当前模型以外的基于时间的发布模型。使开发人员或终端用户能够轻松找出版本的发布时间，以便开发人员能够判断是否将其升级到具有最新安全修补程序或可能的附加功能的新版本。<br>Oracle Java 平台组的首席架构师 Mark Reinhold 在博客上介绍了有关 Java 未来版本的一些想法（你能接受 Java 9 的下一个版本是 Java 18.3 吗？）。他提到，Java 计划按照时间来发布，每半年一个版本，而不是像之前那样按照重要特性来确定大版本，如果某个大的特性因故延期，这个版本可能一拖再拖。<br>当时，Mark 也提出来一种基于时间命名版本号的机制，比如下一个将于 2018 年 3 月发布的版本，就是 18.3，再下一个版本是 18.9，以后版本依此类推。<br>不过经过讨论，考虑和之前版本号的兼容等问题，最终选择的命名机制是：<br><code>$FEATURE.$INTERIM.$UPDATE.$PATCH</code><br><code>$FEATURE</code>，每次版本发布加 1，不考虑具体的版本内容。2018 年 3 月的版本是 JDK 10，9 月的版本是 JDK 11，依此类推。<br><code>$INTERIM</code>，中间版本号，在大版本中间发布的，包含问题修复和增强的版本，不会引入非兼容性修改。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>尽管距离 Java 9 发布仅有六个月的时间，Java 10 的发布也带来了不少新特性和功能增强，以上只是针对其中对开发人员影响重大的主要的一些特性做了介绍，同时也希望下一个 Java 版本能够带来更多、更大的变化。以上只是个人在实际项目中的一点思考，如有不足之处，还望各位读者能够海涵，如可以，希望读者们能够反馈意见，交流心得，一同进步。</p>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul>
<li>参考 <a href="http://openjdk.java.net/projects/jdk/10/" target="_blank" rel="noopener">JDK 10</a>，查看更多有关 Java 10 的最新信息。</li>
<li>参考<a href="https://www.ibm.com/developerworks/cn/java/j-5things17/index.html" target="_blank" rel="noopener">您不知道的 5 件事: Java 10</a>，查看更多 Java 10 新特性的介绍。</li>
<li>参考 <a href="https://mreinhold.org/blog/forward-faster" target="_blank" rel="noopener">Moving Java Forward Faster</a>，查看更多有关 Mark Reinhold 博客的最新信息。</li>
<li>参考 <a href="http://www.ibm.com/developerworks/cn/" target="_blank" rel="noopener">developerWorks 中国</a> 首页，查看 IBM 软件和开放技术的最新信息。</li>
</ul>
<blockquote>
<p>作者：李林锋</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-10/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-10/index.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>由浅入深体验 Stream 流</title>
    <url>/2019/12/26/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E4%BD%93%E9%AA%8C-Stream-%E6%B5%81/</url>
    <content><![CDATA[<p>Stream 流是 Java 8 新提供给开发者的一组操作集合的 API，将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选、排序、聚合等。元素流在管道中经过中间操作（intermediate operation）的处理，最后由终端操作 (terminal operation) 得到前面处理的结果。Stream 流可以极大的提高开发效率，也可以使用它写出更加简洁明了的代码。我自从接触过 Stream 流之后，可以说对它爱不释手。本文将由浅及深带您体验 Stream 流的使用。那么就让我们从流的简单使用来开启体验之旅。</p>
<a id="more"></a>

<h2 id="流的简单使用"><a href="#流的简单使用" class="headerlink" title="流的简单使用"></a>流的简单使用</h2><p>本节将通过实际的例子带您一起了解 Stream 流：创建流以及简单的使用，并且将其与 Java 8 之前的实现方式做一下对比。<br>我们将创建一个学生类 <code>student</code>，它包含姓名 <code>name</code> 和分数 <code>score</code> 两个属性。并且初始化一个学生的集合，然后分别通过 Stream 流和 Java 7 的集合操作实现筛选未及格（分数&lt;60 分）的学生名单，您可以在 GitHub 上查看<a href="https://github.com/ganchaoyang/java-tutorial/blob/master/stream/src/main/java/cn/itweknow/javatutorial/stream/SimpleUse.java" target="_blank" rel="noopener">本节源代码</a>。</p>
<h3 id="创建流"><a href="#创建流" class="headerlink" title="创建流"></a>创建流</h3><p>有以下两种创建流的方式，第一种方式我们使用的会相对较多。</p>
<ul>
<li>调用集合的 <code>stream()</code> 方法或者 <code>parallelStream()</code> 方法创建流。</li>
<li>Stream 类的静态 <code>of()</code> 方法创建流。</li>
</ul>
<p>清单 1. 创建 Stream 流</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">List&lt; <span class="keyword">String</span>&gt; createStream = <span class="keyword">new</span> ArrayList&lt; <span class="keyword">String</span>&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序流</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">Stream</span>&lt; <span class="keyword">String</span>&gt; stream = createStream.stream();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 并行流</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">Stream</span>&lt; <span class="keyword">String</span>&gt; parallelStream = createStream.parallelStream();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// of()方法创建</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">Stream</span>&lt; <span class="keyword">String</span>&gt; stringStream = <span class="built_in">Stream</span>.of(createStream.toArray(<span class="keyword">new</span> <span class="keyword">String</span>[createStream.<span class="built_in">size</span>()]));</span></pre></td></tr></table></figure>

<h3 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h3><p>清单 2 展示了如何使用 Stream 流筛选未及格学生名单：</p>
<p>清单 2. 使用 Stream 流筛选未及格学生名单</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static void stream<span class="constructor">Impl(List&lt; Student&gt; <span class="params">students</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt; Student&gt; filterStudent = students.stream<span class="literal">()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       .filter(one -&gt; one.get<span class="constructor">Score()</span> &lt;  <span class="number">60</span>).collect(<span class="module-access"><span class="module"><span class="identifier">Collectors</span>.</span></span><span class="keyword">to</span><span class="constructor">List()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(filterStudent);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>而使用 Java 7 实现筛选未及格学生名单所需代码相对冗长，如清单 3 所示：</p>
<p>清单 3. Java 7 实现筛选未及格学生名单</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">java7Impl</span>(<span class="params">List&lt;Student&gt; students</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;Student&gt; filterStudent = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (Student student : students) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span> (student.getScore() &lt; <span class="number">60</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          filterStudent.<span class="keyword">add</span>(student);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.<span class="keyword">out</span>.println(filterStudent);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>对比两段代码，我们很容易看出来 Stream 流可以让我操作集合的代码更加简洁，而且可以很清晰地体现出来我们是在做一个筛选的动作，在某些情况下可以让我们的代码更加易读。</p>
<h2 id="流的基础知识"><a href="#流的基础知识" class="headerlink" title="流的基础知识"></a>流的基础知识</h2><p>接下来您将了解 Stream 流的基础知识，这部分的内容将有助于您理解流的相关操作。</p>
<h3 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h3><p><code>Stream</code> 流分为顺序流和并行流，所谓顺序流就是按照顺序对集合中的元素进行处理，而并行流则是使用多线程同时对集合中多个元素进行处理，所以在使用并行流的时候就要注意线程安全的问题了。后文会单独讲解<a href="https://www.ibm.com/developerworks/cn/java/j-experience-stream/index.html#1并行流的使用outline" target="_blank" rel="noopener"><strong>并行流的使用</strong></a>。</p>
<h3 id="终端操作和中间操作"><a href="#终端操作和中间操作" class="headerlink" title="终端操作和中间操作"></a>终端操作和中间操作</h3><p>终端操作会消费 Stream 流，并且会产生一个结果，比如 <code>iterator()</code> 和 <code>spliterator()</code>。如果一个 Stream 流被消费过了，那它就不能被重用的。<br>中间操作会产生另一个流。需要注意的是中间操作不是立即发生的。而是当在中间操作创建的新流上执行完终端操作后，中间操作指定的操作才会发生。流的中间操作还分无状态操作和有状态操作两种。</p>
<ul>
<li>在无状态操作中，在处理流中的元素时，会对当前的元素进行单独处理。比如，过滤操作，因为每个元素都是被单独进行处理的，所有它和流中的其它元素无关。</li>
<li>在有状态操作中，某个元素的处理可能依赖于其他元素。比如查找最小值，最大值，和排序，因为他们都依赖于其他的元素。</li>
</ul>
<h3 id="流接口"><a href="#流接口" class="headerlink" title="流接口"></a>流接口</h3><p>下面是一张 Stream 的 UML (统一建模语言) 类图，后文会讲解其中的一些关键方法。（IDEA 自带一个生成 UML 类图工具，使用方式参照<a href="https://blog.csdn.net/hy_coming/article/details/80741717" target="_blank" rel="noopener">这篇文章</a>。）</p>
<p>图 1. Stream UML 类图</p>
<p><img src="http://image.winrains.cn/2019/08/6e8ad-image001.png" alt="img"></p>
<h3 id="BaseStream-接口"><a href="#BaseStream-接口" class="headerlink" title="BaseStream 接口"></a>BaseStream 接口</h3><p>从上面的 UML 图可以看出来 <code>BaseStream</code> 接口是 Stream 流最基础的接口，它提供了所有流都可以使用的基本功能。<code>BaseStream</code> 是一个泛型接口,它有两个类型参数 <code>T</code> 和 <code>S</code>， 其中 <code>T</code> 指定了流中的元素的类型，<code>S</code> 指定了具体流的类型，由 <code>&gt;</code> 可以知道 <code>S</code> 必须为 <code>BaseStream</code> 或 <code>BaseStream</code> 子类，换句话说,就是 <code>S</code> 必须是扩展自 <code>BaseStream</code> 的。<code>BaseStream</code> 继承了 <code>AutoCloseable</code> 接口，简化了关闭资源的操作，但是像平时我们操作的集合或数组，基本上都不会出现关闭流的情况。下面是 <code>BaseStream</code> 接口下定义的方法的相关解释：</p>
<ul>
<li><code>Iterator iterator()</code>：获取流的迭代器。</li>
<li><code>Spliterator spliterator()</code>：获取流的 <code>spliterator</code>。</li>
<li><code>boolean isParallel()</code>：判断一个流是否是并行流，如果是则返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><code>S sequential()</code>：基于调用流返回一个顺序流，如果调用流本身就是顺序流，则返回其本身。</li>
<li><code>S parallel()</code>：基于调用流，返回一个并行流，如果调用流本身就是并行流，则返回其本身。</li>
<li><code>S unordered()</code>：基于调用流，返回一个无序流。</li>
<li><code>S onClose(Runnable closeHandler)</code>：返回一个新流，<code>closeHandler</code> 指定了该流的关闭处理程序，当关闭该流时，将调用这个处理程序。</li>
<li><code>void close()</code>：从 <code>AutoCloseable</code> 继承来的，调用注册关闭处理程序，关闭调用流(很少会被使用到)。</li>
</ul>
<p>清单 4 列举了由 BaseStream 接口派生出来的流接口，包括了 <code>IntStream</code>，<code>LongStream</code>，<code>Stream</code> 以及 <code>DoubleStream</code>。其中 Stream 接口最为通用，本文的主要讲解对象也是它。</p>
<p>清单 4. 由 <code>BaseStream</code> 接口派生出的流接口</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>IntStream extends BaseStream&lt;、Intege、r, IntStream&gt; &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>LongStream extends BaseStream&lt;Long, LongStream&gt; &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>DoubleStream extends BaseStream&lt;Double, DoubleStream&gt; &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;&#125;</span></pre></td></tr></table></figure>

<h3 id="Stream-接口"><a href="#Stream-接口" class="headerlink" title="Stream 接口"></a>Stream 接口</h3><ul>
<li><code>Stream filter(Predicate predicate)</code>：产生一个新流，其中包含调用流中满足 <code>predicate</code> 指定的谓词元素，即筛选符合条件的元素后重新生成一个新的流。(中间操作)</li>
<li><code>Stream map(Function mapper)</code>，产生一个新流，对调用流中的元素应用 <code>mapper</code>，新 <code>Stream</code> 流中包含这些元素。(中间操作)</li>
<li><code>IntStream mapToInt(ToIntFunction mapper)</code>：对调用流中元素应用 <code>mapper</code>，产生包含这些元素的一个新 <code>IntStream</code> 流。(中间操作)</li>
<li><code>Stream sorted(Comparator comparator)</code>：产生一个自然顺序排序或者指定排序条件的新流。(中间操作)</li>
<li><code>void forEach(Consumer action)</code>：遍历了流中的元素。(终端操作)</li>
<li><code>Optional min(Comparator comparator)</code> 和 <code>Optional max(Comparator comparator)</code>：获得流中最大最小值，比较器可以由自己定义。(终端操作)</li>
<li><code>boolean anyMatch(Predicate predicate)</code>：判断 <code>Stream</code> 流中是否有任何符合要求的元素，如果有则返回 <code>ture</code>,没有返回 <code>false</code>。（终端操作）</li>
<li><code>Stream distinct()</code>，去重操作，将 <code>Stream</code> 流中的元素去重后，返回一个新的流。（中间操作）</li>
</ul>
<h2 id="流的-API-操作"><a href="#流的-API-操作" class="headerlink" title="流的 API 操作"></a>流的 API 操作</h2><h3 id="缩减操作"><a href="#缩减操作" class="headerlink" title="缩减操作"></a>缩减操作</h3><p>什么是缩减操作呢？最终将流缩减为一个值的终端操作，我们称之为缩减操作。在上一节中提到的 <code>min()，max()</code>方法返回的是流中的最小或者最大值，这两个方法属于特例缩减操作。而通用的缩减操作就是指的我们的 <code>reduce()</code>方法了，在 Stream 类中 <code>reduce</code> 方法有三种签名方法，如下所示：</p>
<p>清单 5. <code>reduce()</code> 方法的三种实现</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">Stream</span>&lt;<span class="symbol">T</span>&gt; <span class="symbol">extends</span> <span class="symbol">BaseStream</span>&lt;<span class="symbol">T</span>, <span class="symbol">Stream</span>&lt;<span class="symbol">T</span>&gt;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  …</span></pre></td></tr><tr><td class="code"><pre><span class="line">Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);</span></pre></td></tr><tr><td class="code"><pre><span class="line">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;U&gt; U reduce(U identity,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 BiFunction&lt;U, ? <span class="keyword">super</span> T, U&gt; accumulator,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 BinaryOperator&lt;U&gt; combiner);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  …</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>由上面的代码可以看出，在 Stream API 中 <code>reduce()</code>方法一共存在着三种签名，而这三种签名则分别会适用在不同的场景，我们下面就一起来看一下如何使用。</p>
<h4 id="第一种签名"><a href="#第一种签名" class="headerlink" title="第一种签名"></a>第一种签名</h4><p>在下面的代码中我们将对一个 Integer 类型的集合做求和操作。</p>
<p>清单 6. 第一种签名的 <code>reduce()</code> 的使用</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">public static <span class="literal">void</span> reduceFirstSign() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;Integer&gt; <span class="keyword">list</span> = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ptional&lt;Integer&gt; count = <span class="keyword">list</span>.stream<span class="function"><span class="params">()</span>.<span class="title">reduce</span><span class="params">((a, b) -&gt; (a + b))</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(count.get())</span>; // 21</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">&#125;</span></span></pre></td></tr></table></figure>

<h4 id="第二种签名"><a href="#第二种签名" class="headerlink" title="第二种签名"></a>第二种签名</h4><p>与第一种签名不同的是多接收了一个参数 <code>identity</code>，在首次执行 <code>accumulator</code> 表达式的时候它的第一个参数并不是 Stream 流的第一个元素，而是 <code>identity</code>。比如下面的例子最终输出的结果是 Stream 流中所有元素乘积的 2 倍。</p>
<p>清单 7. 第二种签名的 <code>reduce()</code> 的使用</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> static <span class="built_in">void</span> reduceSecondSign() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Integer count = list.stream().reduce(<span class="number">2</span>, (a, b) -&gt; (a * b));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.<span class="keyword">out</span>.println(count);  <span class="comment">// 1440</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="第三种签名"><a href="#第三种签名" class="headerlink" title="第三种签名"></a>第三种签名</h4><p>前面两种前面的一个缺点在于返回的数据都只能和 Stream 流中元素类型一致，但这在某些情况下是无法满足我们的需求的，比如 Stream 流中元素都是 <code>Integer</code> 类型，但是求和之后数值超过了 <code>Integer</code> 能够表示的范围，需要使用 <code>Long</code> 类型接受，这就用到了我们第三种签名的 <code>reduce()</code> 方法。</p>
<p>清单 8. 第三种签名的 <code>reduce()</code> 的使用</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">public static <span class="literal">void</span> reduceThirdSign() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;Integer&gt; <span class="keyword">list</span> = Arrays.asList(Integer.MAX_VALUE, Integer.MAX_VALUE);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    long count = <span class="keyword">list</span>.stream<span class="function"><span class="params">()</span>.<span class="title">reduce</span><span class="params">(<span class="number">0</span>L, (a, b) -&gt; (a + b), (a,b) -&gt; <span class="number">0</span>L)</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(count)</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">&#125;</span></span></pre></td></tr></table></figure>

<p>总的来说缩减操作有两个特点，一是他只返回一个值，二是它是一个终端操作。在这里顺便给大家留一个缩减操作的题目，统计一个班上所有及格同学的分数总和（学生类可参考<a href="https://www.ibm.com/developerworks/cn/java/j-experience-stream/index.html#2流的简单使用outline" target="_blank" rel="noopener"><strong>流的简单使用</strong></a>章节，答案可以参考<a href="https://www.ibm.com/developerworks/cn/java/j-experience-stream/index.html#1参考答案outline" target="_blank" rel="noopener"><strong>参考答案</strong></a>章节）。</p>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>可能在我们的日常开发过程中经常会遇到将一个集合转换成另外一个对象的集合，那么这种操作放到 Stream 流中就是映射操作。映射操作主要就是将一个 Stream 流转换成另外一个对象的 Stream 流或者将一个 Stream 流中符合条件的元素放到一个新的 Stream 流里面。<br>在 Stream API 库中也提供了丰富的 API 来支持我们的映射操作，清单 9 中的方法都是我们所讲的映射操作。</p>
<p>清单 9. 映射操作相关方法定义</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  …</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</span></pre></td></tr><tr><td class="code"><pre><span class="line">IntStream map<span class="constructor">ToInt(ToIntFunction&lt;? <span class="params">super</span> T&gt; <span class="params">mapper</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">LongStream map<span class="constructor">ToLong(ToLongFunction&lt;? <span class="params">super</span> T&gt; <span class="params">mapper</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">DoubleStream map<span class="constructor">ToDouble(ToDoubleFunction&lt;? <span class="params">super</span> T&gt; <span class="params">mapper</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; flat<span class="constructor">Map(Function&lt;? <span class="params">super</span> T, ? <span class="params">extends</span> Stream&lt;? <span class="params">extends</span> R&gt;&gt;&gt; <span class="params">mapper</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">IntStream flat<span class="constructor">MapToInt(Function&lt;? <span class="params">super</span> T, ? <span class="params">extends</span> IntStream&gt; <span class="params">mapper</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">LongStream flat<span class="constructor">MapToLong(Function&lt;? <span class="params">super</span> T, ? <span class="params">extends</span> LongStream&gt; <span class="params">mapper</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">DoubleStream flat<span class="constructor">MapToDouble(Function&lt;? <span class="params">super</span> T, ? <span class="params">extends</span> DoubleStream&gt; <span class="params">mapper</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  …</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其中最通用的应该就属 <code>mapv</code> 和 <code>flatMap</code> 两个方法了，下面将以不同的例子分别来讲解着两个方法。</p>
<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p><code>map()</code> 方法可以将一个流转换成另外一种对象的流，其中的 <code>T</code> 是原始流中元素的类型，而 <code>R</code> 则是转换之后的流中元素的类型。通过下面的代码我们将一个学生对象的 Stream 流转换成一个 <code>Double</code> 类型（学生的分数）的 Stream 流并求和后输出。</p>
<p>清单 10. <code>map()</code> 方法的使用示例</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">public static <span class="literal">void</span> useMap() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;Student&gt; students = initData();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    double scoreCount = students.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">              .<span class="keyword">map</span>(Student::getScore)</span></pre></td></tr><tr><td class="code"><pre><span class="line">              .reduce<span class="function"><span class="params">(<span class="number">0.0</span>, (a,b) -&gt; (a + b))</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(scoreCount)</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">&#125;</span></span></pre></td></tr></table></figure>

<p>当然上面这种情况用 <code>mapToDouble()</code> 会更加方便，使用 <code>map()</code> 是为了展示一下 <code>map</code> 的使用方式，那么使用 <code>mapToDouble()</code> 方法的代码如下：</p>
<p>清单 11. <code>mapToDouble()</code> 方法的使用示例</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> scoreCount = students.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .mapToDouble(Student::getScore)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .<span class="keyword">sum</span>();</span></pre></td></tr></table></figure>

<h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h4><p><code>flatMap()</code>操作能把原始流中的元素进行一对多的转换，并且将新生成的元素全都合并到它返回的流里面。假如现每个班的学生都学了不同的课程，现在需要统计班里所有学生所学的课程列表，该如何实现呢?</p>
<p>清单 12. <code>flatMap ()</code> 方法的使用示例</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static void use<span class="constructor">FlatMap()</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;Student&gt; students = init<span class="constructor">Data()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;String&gt; course = students.stream<span class="literal">()</span>.flat<span class="constructor">Map(<span class="params">one</span> -&gt; <span class="params">one</span>.<span class="params">getCourse</span>()</span>.stream<span class="literal">()</span>).distinct<span class="literal">()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                  .collect(<span class="module-access"><span class="module"><span class="identifier">Collectors</span>.</span></span><span class="keyword">to</span><span class="constructor">List()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(course);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如上代码中 <code>flatMap()</code> 中返回的是一个一个的 <code>String</code> 类型的 Stream 流，它们会被合并到最终返回的 Stream 流（String 类型）中。而后面的 <code>distinct()</code> 则是一个去重的操作，<code>collect()</code> 是收集操作。</p>
<h3 id="收集操作"><a href="#收集操作" class="headerlink" title="收集操作"></a>收集操作</h3><p>很多时候我们需要从流中收集起一些元素，并以集合的方式返回，我们把这种反向操作称为收集操作。对于收集操作，Stream API 也提供了相应的方法。</p>
<p>清单 13. 收集操作相关 API</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">Stream</span>&lt;<span class="symbol">T</span>&gt; <span class="symbol">extends</span> <span class="symbol">BaseStream</span>&lt;<span class="symbol">T</span>, <span class="symbol">Stream</span>&lt;<span class="symbol">T</span>&gt;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  …</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;R, A&gt; R collect(Collector&lt;? <span class="keyword">super</span> T, A, R&gt; collector);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  …</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其中 <code>R</code> 指定结果的类型，<code>T</code> 指定了调用流的元素类型。内部积累的类型由 <code>A</code> 指定。<code>collector</code> 是一个收集器，指定收集过程如何执行，<code>collect()</code> 方法是一个终端方法。一般情况我们只需要借助 <code>Collectors</code> 中的方法就可以完成收集操作。<br><code>Collectors</code> 类是一个最终类，里面提供了大量的静态的收集器方法，借助他，我们基本可以实现各种复杂的功能了。</p>
<p>清单 14. Collectors</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Collectors</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    …</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, <span class="built_in">List</span>&lt;T&gt;&gt; toList() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        …</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public <span class="keyword">static</span> &lt;T, K, U&gt; Collector&lt;T, ?, <span class="built_in">Map</span>&lt;K,U&gt;&gt; toMap (</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">Function</span>&lt;? <span class="keyword">super</span> T, ? <span class="keyword">extends</span> K&gt; keyMapper,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">Function</span>&lt;? <span class="keyword">super</span> T, ? <span class="keyword">extends</span> U&gt; valueMapper) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        …</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    …</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>Collectors</code> 给我们提供了非常丰富的收集器，这里只列出来了 <code>toList</code> 和 <code>toMap</code> 两种，其他的可以参考 <code>Collectors</code> 类的源码。<code>toList()</code> 相信您在清单 14 中已经见到了，那么下面将展示如何将一个使用收集操作将一个 <code>List</code> 集合转为 <code>Map</code>。</p>
<p>清单 15. 使收集操作将 List 转 Map</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static void list2<span class="constructor">Map()</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;Student&gt; students = init<span class="constructor">Data()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Map&lt;String, Double&gt; collect = students.stream<span class="literal">()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           .collect(<span class="module-access"><span class="module"><span class="identifier">Collectors</span>.</span></span><span class="keyword">to</span><span class="constructor">Map(<span class="params">one</span> -&gt; <span class="params">one</span>.<span class="params">getName</span>()</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">           one -&gt; one.get<span class="constructor">Score()</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(collect);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看到通过 Stream API 可以很方便地将一个 <code>List</code> 转成了 <code>Map</code>，但是这里有一个地方需要注意。那就是在通过 Stream API 将 <code>List</code> 转成 <code>Map</code> 的时候我们需要确保 <code>key</code> 不会重复，否则转换的过程将会直接抛出异常。</p>
<h2 id="并行流的使用"><a href="#并行流的使用" class="headerlink" title="并行流的使用"></a>并行流的使用</h2><p>我们处于一个多核处理器的时代，在日常的开发过程中也经常会接触到多线程。Stream API 也提供了相应的并行流来支持我们并行地操作数组和集合框架，从而高速地执行我们对数组或者集合的一些操作。<br>其实创建一个并行流非常简单，在<strong>创建流</strong>部分已经提到过如何创建一个并行流，我们只需要调用集合的 <code>parallelStream()</code> 方法就可以轻松的得到一个并行流。相信大家也知道多线程编程非常容易出错，所以使用并行流也有一些限制，一般来说，应用到并行流的任何操作都必须符合三个约束条件：无状态、不干预、关联性。因为这三大约束确保在并行流上执行操作的结果和在顺序流上执行的结果是相同的。<br>在<strong>缩减操作</strong>部分我们一共提到了三种签名的 <code>reduce()</code> 方法，其中第三种签名的 <code>reduce()</code> 方法最适合与并行流结合使用。</p>
<p>清单 16. 第三种签名方式的 <code>reduce()</code> 方法与并行流结合使用</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">Stream</span>&lt;<span class="symbol">T</span>&gt; <span class="symbol">extends</span> <span class="symbol">BaseStream</span>&lt;<span class="symbol">T</span>, <span class="symbol">Stream</span>&lt;<span class="symbol">T</span>&gt;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  …</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;U&gt; U reduce(U identity,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 BiFunction&lt;U, ? <span class="keyword">super</span> T, U&gt; accumulator,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 BinaryOperator&lt;U&gt; combiner);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  …</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其中 <code>accumulator</code> 被为累加器，<code>combiner</code> 为合成器。<code>combiner</code> 定义的函数将 <code>accumulator</code> 提到的两个值合并起来，在之前的例子中我们没有为合并器设置具体的表达式，因为在那个场景下我们不会使用到合并器。下面我们来看一个例子，并且分析其执行的步骤：</p>
<p>清单 17. 并行流使用场景</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">public static <span class="literal">void</span> main(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;Integer&gt; <span class="keyword">list</span> = Arrays.asList(<span class="number">2</span>,<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Integer result = <span class="keyword">list</span>.stream<span class="function"><span class="params">()</span>.<span class="title">parallel</span><span class="params">()</span>.<span class="title">reduce</span><span class="params">(<span class="number">2</span>, (a, b) -&gt; (a + b), (a, b) -&gt; (a + b))</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(result)</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">&#125;</span></span></pre></td></tr></table></figure>

<p>上面的代码实际上是先使用累加器把 Stream 流中的两个元素都加 <code>2</code> 后，然后再使用合并器将两部分的结果相加。最终得到的结果也就是 <code>8</code>。并行流的使用场景也不光是在这中缩减操作上，比如我会经常使用并行流处理一些复杂的对象集合转换，或者是一些必须循环调用的网络请求等等，当然在使用的过程中最需要注意的还是线程安全问题。</p>
<h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><p>在<a href="https://www.ibm.com/developerworks/cn/java/j-experience-stream/index.html#3流的API操作outline" target="_blank" rel="noopener"><strong>流的 API 操作</strong></a>章节给大家留了一个统计一个班上所有及格同学的分数总和的题目，此处给出我的实现方式，第一种方式是使用 <code>reduce()</code> 方法实现，也就是我们留题目的地方所讲解的 API 方法：</p>
<p>清单 18. 第一种实现方式</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">public static <span class="literal">void</span> answer() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;Student&gt; students = initData();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Double result = students.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .filter(one<span class="function"> -&gt;</span> one.getScore() &gt;= <span class="number">60</span>).<span class="keyword">map</span>(o<span class="function"> -&gt;</span> o.getScore())</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .reduce<span class="function"><span class="params">(<span class="number">0d</span>, (a,b) -&gt; (a + b))</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(result)</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">&#125;</span></span></pre></td></tr></table></figure>

<p>第二种实现方法是通过 <code>sum()</code> 方法实现，<code>sum()</code> 也是一个终端操作，它可以对一个数字类型的流进行求和操作并返回结果：</p>
<p>清单 19. 第二种实现方式</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static void answer<span class="constructor">SecondImpl()</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;Student&gt; students = init<span class="constructor">Data()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Double result = students.stream<span class="literal">()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            .filter(one -&gt; one.get<span class="constructor">Score()</span> &gt;= <span class="number">60</span>).map<span class="constructor">ToDouble(<span class="params">o</span> -&gt; <span class="params">o</span>.<span class="params">getScore</span>()</span>).sum<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(result);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>以上是我提供的两种解题方式，如果您有更好的解决方法欢迎以评论的方式共享给大家。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>在本教程中，我们主要了解了 Java 8 Stream 流的基础知识及使用，涵盖 Stream 流的分类、接口、相关 API 操作以及并行流的使用。您可以在 GitHub 上找到本教程的<a href="https://github.com/ganchaoyang/java-tutorial/tree/master/stream/src/main/java/cn/itweknow/javatutorial/stream" target="_blank" rel="noopener">完整实现</a>，如果您想对本教程做补充的话欢迎发邮件（<a href="mailto:gancy.programmer@gmail.com" target="_blank" rel="noopener">gancy.programmer@gmail.com</a>）给我或者直接在 Github 上提交 Pull Reqeust。</p>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul>
<li><a href="https://github.com/ganchaoyang/java-tutorial/tree/master/stream" target="_blank" rel="noopener">本文源码地址</a></li>
<li><a href="https://blog.csdn.net/hy_coming/article/details/80741717" target="_blank" rel="noopener">IDEA 生成 UML 图</a></li>
</ul>
<blockquote>
<p>作者：甘朝阳</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-experience-stream/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-experience-stream/index.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>在 Spring Boot 项目中使用 Swagger 文档</title>
    <url>/2019/12/26/%E5%9C%A8-Spring-Boot-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Swagger-%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>Spring Boot 框架是目前非常流行的微服务框架，我们很多情况下使用它来提供 Rest API。而对于 Rest API 来说很重要的一部分内容就是文档，Swagger 为我们提供了一套通过代码和注解自动生成文档的方法，这一点对于保证 API 文档的及时性将有很大的帮助。本文将使用 Swagger 2 规范的 Springfox 实现来了解如何在 Spring Boot 项目中使用 Swagger，主要包含了如何使用 Swagger 自动生成文档、使用 Swagger 文档以及 Swagger 相关的一些高级配置和注解。</p>
<a id="more"></a>

<h2 id="Swagger-简介"><a href="#Swagger-简介" class="headerlink" title="Swagger 简介"></a>Swagger 简介</h2><p>Swagger 是一套基于 OpenAPI 规范构建的开源工具，可以帮助我们设计、构建、记录以及使用 Rest API。Swagger 主要包含了以下三个部分：</p>
<ol>
<li>Swagger Editor：基于浏览器的编辑器，我们可以使用它编写我们 OpenAPI 规范。</li>
<li>Swagger UI：它会将我们编写的 OpenAPI 规范呈现为交互式的 API 文档，后文我将使用浏览器来查看并且操作我们的 Rest API。</li>
<li>Swagger Codegen：它可以通过为 OpenAPI（以前称为 Swagger）规范定义的任何 API 生成服务器存根和客户端 SDK 来简化构建过程。</li>
</ol>
<h3 id="为什么要使用-Swagger"><a href="#为什么要使用-Swagger" class="headerlink" title="为什么要使用 Swagger"></a>为什么要使用 Swagger</h3><p>当下很多公司都采取前后端分离的开发模式，前端和后端的工作由不同的工程师完成。在这种开发模式下，维持一份及时更新且完整的 Rest API 文档将会极大的提高我们的工作效率。传统意义上的文档都是后端开发人员手动编写的，相信大家也都知道这种方式很难保证文档的及时性，这种文档久而久之也就会失去其参考意义，反而还会加大我们的沟通成本。而 Swagger 给我们提供了一个全新的维护 API 文档的方式，下面我们就来了解一下它的优点：</p>
<ol>
<li>代码变，文档变。只需要少量的注解，Swagger 就可以根据代码自动生成 API 文档，很好的保证了文档的时效性。</li>
<li>跨语言性，支持 40 多种语言。</li>
<li>Swagger UI 呈现出来的是一份可交互式的 API 文档，我们可以直接在文档页面尝试 API 的调用，省去了准备复杂的调用参数的过程。</li>
<li>还可以将文档规范导入相关的工具（例如 SoapUI）, 这些工具将会为我们自动地创建自动化测试。</li>
</ol>
<p>以上这些优点足以说明我们为什么要使用 Swagger 了，您是否已经对 Swagger 产生了浓厚的兴趣了呢？下面我们就将一步一步地在 Spring Boot 项目中集成和使用 Swagger，让我们从准备一个 Spring Boot 的 Web 项目开始吧。</p>
<h2 id="准备-Spring-Boot-Web-项目"><a href="#准备-Spring-Boot-Web-项目" class="headerlink" title="准备 Spring Boot Web 项目"></a>准备 Spring Boot Web 项目</h2><p>在这一步我们将准备一个基础的 Spring Boot 的 Web 项目，并且提供后面所需要的所有 API。</p>
<h3 id="创建一个空的-Spring-Boot-项目"><a href="#创建一个空的-Spring-Boot-项目" class="headerlink" title="创建一个空的 Spring Boot 项目"></a>创建一个空的 Spring Boot 项目</h3><p>您可以通过<a href="https://start.spring.io/" target="_blank" rel="noopener"> Spring Initializr 页面</a>生成一个空的 Spring Boot 项目，当然也可以下载<a href="https://github.com/ganchaoyang/spring-tutorial/blob/master/resources/springboot-pom.xml" target="_blank" rel="noopener"> springboot-pom.xml </a>文件，然后使用 Maven 构建一个 Spring Boot 项目。项目创建完成后，为了方便后面代码的编写您可以将其导入到您喜欢的 IDE 中，我这里选择了 Intelli IDEA 打开。</p>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>由于创建的是一个 Web 项目，所以我们需要依赖 Spring Boot 的 Web 组件，只需要在 pom.xml 增加如下内容即可：</p>
<p>清单 1. 添加 Web 依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure>

<h3 id="编写接口"><a href="#编写接口" class="headerlink" title="编写接口"></a>编写接口</h3><ol>
<li>首先我们创建三个包：cn.itweknow.sbswagger.controller、cn.itweknow.sbswagger.testcontroller 以及 cn.itweknow.sbswagger.model。</li>
<li>在 controller 包下新建 UserController.java 类，在 testcontroller 包下新建 TestController.java 类，在 model 包下新建 User.java 类。</li>
<li>UserController 提供用户的增、删、改、查四个接口，TestContrller 提供一个测试接口，这里粘上 UserController.java 的代码，其余代码可以查看<a href="https://github.com/ganchaoyang/spring-tutorial/tree/master/sb-swagger" target="_blank" rel="noopener">源码</a>。</li>
</ol>
<p>清单 2. UserController.java 代码</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@RestController</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@RequestMapping</span>(<span class="string">"/user"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class UserController &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@PostMapping</span>(<span class="string">"/add"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public boolean addUser(<span class="variable">@RequestBody</span> User user) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @<span class="selector-tag">GetMapping</span>(<span class="string">"/find/&#123;id&#125;"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">User</span> <span class="selector-tag">findById</span>(<span class="variable">@PathVariable</span>(<span class="string">"id"</span>) int id) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">User</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @<span class="selector-tag">PutMapping</span>(<span class="string">"/update"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">boolean</span> <span class="selector-tag">update</span>(<span class="variable">@RequestBody</span> User user) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @<span class="selector-tag">DeleteMapping</span>(<span class="string">"/delete/&#123;id&#125;"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">boolean</span> <span class="selector-tag">delete</span>(<span class="variable">@PathVariable</span>(<span class="string">"id"</span>) int id) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="集成-Swagger2"><a href="#集成-Swagger2" class="headerlink" title="集成 Swagger2"></a>集成 Swagger2</h2><p>经过上面的步骤，我们已经拥有了五个接口，分别是:</p>
<ol>
<li>/user/add：新增用户。</li>
<li>/user/find/{id}：根据 id 查询用户。</li>
<li>/user/update：更新用户。</li>
<li>/user/delete/{id}：根据 id 删除用户。</li>
<li>/test/test：测试接口。</li>
</ol>
<p>下面我们将通过集成 Swagger2，然后为这 5 个 Rest API 自动生成接口文档。</p>
<h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>首先要做的自然是添加 Swagger2 所需要的依赖包：</p>
<p>清单 3. 添加 Swagger 依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure>

<h3 id="Java-配置"><a href="#Java-配置" class="headerlink" title="Java 配置"></a>Java 配置</h3><p>Springfox 提供了一个 Docket 对象，让我们可以灵活的配置 Swagger 的各项属性。下面我们新建一个 cn.itweknow.sbswagger.conf.SwaggerConfig.java 类，并增加如下内容:</p>
<p>清单 4. Swagger Java 配置</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@EnableSwagger2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class SwaggerConfig &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Docket api() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">Docket</span>(DocumentationType.SWAGGER_2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="selector-class">.select</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="selector-class">.apis</span>(RequestHandlerSelectors.any())</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="selector-class">.paths</span>(PathSelectors.any())</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="selector-class">.build</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>注意: <code>@Configuration</code> 是告诉 Spring Boot 需要加载这个配置类，<code>@EnableSwagger2</code> 是启用 Swagger2，如果没加的话自然而然也就看不到后面的验证效果了。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>至此，我们已经成功的在 Spring Boot 项目中集成了 Swagger2，启动项目后，我们可以通过在浏览器中访问 <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> v2/api-docs 来验证，您会发现返回的结果是一段 JSON 串，可读性非常差。幸运的是 Swagger2 为我们提供了可视化的交互界面 SwaggerUI，下面我们就一起来试试吧。</p>
<h2 id="集成-Swagger-UI"><a href="#集成-Swagger-UI" class="headerlink" title="集成 Swagger UI"></a>集成 Swagger UI</h2><h3 id="添加依赖-2"><a href="#添加依赖-2" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>和之前一样，集成的第一步就是添加相关依赖，在 pom.xml 中添加如下内容即可：</p>
<p>清单 5. 添加 Swagger UI 依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure>

<h3 id="访问验证"><a href="#访问验证" class="headerlink" title="访问验证"></a>访问验证</h3><p>其实就只需要添加一下依赖就可以了，我们重新启动一下项目，然后在浏览器中访问 <a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a> 就可以看到如下的效果了:</p>
<p>图 1. Swagger UI</p>
<p><img src="http://image.winrains.cn/2019/08/2c088-image001.png" alt="img"></p>
<p>可以看到虽然可读性好了一些，但对接口的表述还不是那么的清楚，接下来我们就通过一些高级配置，让这份文档变的更加的易读。</p>
<h2 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h2><h3 id="文档相关描述配置"><a href="#文档相关描述配置" class="headerlink" title="文档相关描述配置"></a>文档相关描述配置</h3><ol>
<li><p>通过在控制器类上增加</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api</span></span></pre></td></tr></table></figure>

<p> 注解，可以给控制器增加描述和标签信息。</p>
<p>清单 6. 给 Controller 添加描述信息</p>
</li>
</ol>
   <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api(tags = <span class="meta-string">"用户相关接口"</span>, description = <span class="meta-string">"提供用户相关的 Rest API"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span></span></pre></td></tr></table></figure>

<ol start="2">
<li><p>通过在接口方法上增加 </p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span></span></pre></td></tr></table></figure>

<p> 注解来展开对接口的描述，当然这个注解还可以指定很多内容，我们在下面的相关注解说明章节中详细解释。</p>
<p>清单 7. 给接口添加描述信息</p>
</li>
</ol>
   <figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@ApiOperation</span>(<span class="string">"新增用户接口"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@PostMapping</span>(<span class="string">"/add"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public boolean addUser(<span class="variable">@RequestBody</span> User user) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ol start="3">
<li><p>实体描述，我们可以通过</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiModel</span></span></pre></td></tr></table></figure>

<p> 和 </p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiModelProperty</span></span></pre></td></tr></table></figure>

<p> 注解来对我们 API 中所涉及到的对象做描述。</p>
<p>清单 8. 给实体类添加描述信息</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiModel(<span class="meta-string">"用户实体"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@ApiModelProperty(<span class="meta-string">"用户 id"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> int id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
</li>
<li><p>文档信息配置，Swagger 还支持设置一些文档的版本号、联系人邮箱、网站、版权、开源协议等等信息，但与上面几条不同的是这些信息不是通过注解配置，而是通过创建一个 ApiInfo 对象，并且使用 <code>Docket.appInfo()</code> 方法来设置，我们在 SwaggerConfig.java 类中新增如下内容即可。</p>
</li>
</ol>
<p>清单 9. 配置文档信息</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">Docket <span class="title">api</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">.select()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .apis(RequestHandlerSelectors.any())</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .paths(PathSelectors.any())</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .build()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .apiInfo(apiInfo());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function">ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ApiInfo(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">"Spring Boot 项目集成 Swagger 实例文档"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">"我的博客网站：https://itweknow.cn，欢迎大家访问。"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">"API V1.0"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">"Terms of service"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">new</span> Contact(<span class="string">"名字想好没"</span>, <span class="string">"https://itweknow.cn"</span>, <span class="string">"gancy.programmer@gmail.com"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="string">"Apache"</span>, <span class="string">"http://www.apache.org/"</span>, Collections.emptyList());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p>经过上面的步骤，我们的文档将会变成下图的样子，现在看起来就清楚很多了。</p>
<p>图 2. 补全信息后的 Swagger 文档界面</p>
<p><img src="http://image.winrains.cn/2019/08/d61c1-image002.png" alt="img"></p>
<h3 id="接口过滤"><a href="#接口过滤" class="headerlink" title="接口过滤"></a>接口过滤</h3><p>有些时候我们并不是希望所有的 Rest API 都呈现在文档上，这种情况下 Swagger2 提供给我们了两种方式配置，一种是基于 <code>@ApiIgnore</code> 注解，另一种是在 Docket 上增加筛选。</p>
<ol>
<li><pre><code>@ApiIgnore
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"> 注解。如果想在文档中屏蔽掉删除用户的接口（user/<span class="keyword">delete</span>），那么只需要在删除用户的方法上加上 @ApiIgnore 即可。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">清单 <span class="number">10.</span> @ApiIgnore 使用实例</span></pre></td></tr></table></figure>
@ApiIgnore
public boolean delete(@PathVariable(&quot;id&quot;) int id)
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span>. 在 Docket 上增加筛选。Docket 类提供了 `apis()` 和 `paths()`两 个方法来帮助我们在不同级别上过滤接口：</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- `apis()`：这种方式我们可以通过指定包名的方式，让 Swagger 只去某些包下面扫描。</span></pre></td></tr><tr><td class="code"><pre><span class="line">- `paths()`：这种方式可以通过筛选 API 的 url 来进行过滤。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">在集成 Swagger2 的章节中我们这两个方法指定的都是扫描所有，没有指定任何过滤条件。如果我们在我们修改之前定义的 Docket 对象的 `apis()` 方法和 `paths()` 方法为下面的内容，那么接口文档将只会展示 /user/add 和 /user/find/&#123;id&#125; 两个接口。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">清单 <span class="number">11</span>. 使用 Docket 配置接口筛选</span></pre></td></tr></table></figure>
.apis(RequestHandlerSelectors.basePackage(&quot;cn.itweknow.sbswagger.controller&quot;))
.paths(Predicates.or(PathSelectors.ant(&quot;/user/add&quot;),
     PathSelectors.ant(&quot;/user/find/*&quot;)))
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">图 3. 经过筛选过后的 Swagger 文档界面</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">![<span class="string">img</span>](<span class="link">http://image.winrains.cn/2019/08/7d83a-image003.png</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="section">### 自定义响应消息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Swagger 允许我们通过 Docket 的 <span class="code">`globalResponseMessage()`</span> 方法全局覆盖 HTTP 方法的响应消息，但是首先我们得通过 Docket 的 <span class="code">`useDefaultResponseMessages`</span> 方法告诉 Swagger 不使用默认的 HTTP 响应消息，假设我们现在需要覆盖所有 GET 方法的 500 和 403 错误的响应消息，我们只需要在 SwaggerConfig.java 类中的 Docket Bean 下添加如下内容：</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">清单 12. 自定义响应消息</span></pre></td></tr></table></figure>
.useDefaultResponseMessages(false)
.globalResponseMessage(RequestMethod.GET, newArrayList(
new ResponseMessageBuilder()
           .code(500)
           .message(&quot;服务器发生异常&quot;)
           .responseModel(new ModelRef(&quot;Error&quot;))
           .build(),
    new ResponseMessageBuilder()
           .code(403)
           .message(&quot;资源不可用&quot;)
           .build()
));
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">添加如上面的代码后，如下图所示，您会发现在 SwaggerUI 页面展示的所有 GET 类型请求的 403 以及 500 错误的响应消息都变成了我们自定义的内容。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">图 4. 自定义响应消息</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">![<span class="string">img</span>](<span class="link">http://image.winrains.cn/2019/08/a9eb6-image004.png</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="section">## Swagger UI 的使用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="section">### 接口查看</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">SwaggerUI 会以列表的方式展示所有扫描到的接口，初始状态是收缩的，我们只需要点击展开就好，而且会在左边标识接口的请求方式（GET、POST、PUT、DELETE 等等）。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">图 5. Swagger 接口列表界面</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">![<span class="string">img</span>](<span class="link">http://image.winrains.cn/2019/08/4484f-image005.png</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="section">### 接口调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">如下图所示，点击接口展开后页面右上角的 <span class="strong">**Try it out**</span> 按钮后，页面会变成如图所示：</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">图 6. 接口详情界面</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">![<span class="string">img</span>](<span class="link">http://image.winrains.cn/2019/08/ac16a-image006.png</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">SwaggerUI 会给我们自动填充请求参数的数据结构，我们需要做的只是点击 <span class="strong">**Execute**</span> 即可发起调用</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">图 7. 接口调用界面</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">![<span class="string">img</span>](<span class="link">http://image.winrains.cn/2019/08/783ab-image007.png</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="section">### Model</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">如下图所示，SwaggerUI 会通过我们在实体上使用的 <span class="code">`@ApiModel`</span> 注解以及<span class="code">`@ApiModelProperty`</span> 注解来自动补充实体以及其属性的描述和备注。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">图 8. 实体界面</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">![<span class="string">img</span>](<span class="link">http://image.winrains.cn/2019/08/6497b-image008.png</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="section">## 相关注解说明</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">在本章节中我将给出一些 Swagger 中常用的注解以及其常用的属性，并对其一一解释，方便您查看。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="section">### Controller 相关注解</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="code">`@Api`</span>: 可设置对控制器的描述。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">表 1. @Api 主要属性</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">| <span class="strong">**注解属性**</span> | <span class="strong">**类型**</span> | <span class="strong">**描述**</span>                           |</span></pre></td></tr><tr><td class="code"><pre><span class="line">| ------------ | -------- | ---------------------------------- |</span></pre></td></tr><tr><td class="code"><pre><span class="line">| tags         | String[] | 控制器标签。                       |</span></pre></td></tr><tr><td class="code"><pre><span class="line">| description  | String   | 控制器描述（该字段被申明为过期）。 |</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="section">### 接口相关注解</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">1.</span></pre></td></tr></table></figure>
@ApiOperation
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   : 可设置对接口的描述。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   表 2. <span class="meta">@ApiOperation</span> 主要属性</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   |<span class="string"> **注解属性** </span>|<span class="string"> **类型** </span>|<span class="string"> **描述**       </span>|</span></pre></td></tr><tr><td class="code"><pre><span class="line">   |<span class="string"> ------------ </span>|<span class="string"> -------- </span>|<span class="string"> -------------- </span>|</span></pre></td></tr><tr><td class="code"><pre><span class="line">   |<span class="string"> value        </span>|<span class="string"> String   </span>|<span class="string"> 接口说明。     </span>|</span></pre></td></tr><tr><td class="code"><pre><span class="line">   |<span class="string"> notes        </span>|<span class="string"> String   </span>|<span class="string"> 接口发布说明。 </span>|</span></pre></td></tr><tr><td class="code"><pre><span class="line">   |<span class="string"> tags         </span>|<span class="string"> Stirng[] </span>|<span class="string"> 标签。         </span>|</span></pre></td></tr><tr><td class="code"><pre><span class="line">   |<span class="string"> response     </span>|<span class="string"> Class&lt;?&gt; </span>|<span class="string"> 接口返回类型。 </span>|</span></pre></td></tr><tr><td class="code"><pre><span class="line">   |<span class="string"> httpMethod   </span>|<span class="string"> String   </span>|<span class="string"> 接口请求方式。 </span>|</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">2. `<span class="meta">@ApiIgnore`:</span> Swagger 文档不会显示拥有该注解的接口。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">3. `<span class="meta">@ApiImplicitParams`:</span> 用于描述接口的非对象参数集。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">4.</span></pre></td></tr></table></figure>
@ApiImplicitParam
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">: 用于描述接口的非对象参数，一般与</span></pre></td></tr></table></figure>
@ApiImplicitParams
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    组合使用。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   表 3. <span class="meta">@ApiImplicitParam</span> 主要属性</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   |<span class="string"> **注解属性** </span>|<span class="string"> **描述**                                                     </span>|</span></pre></td></tr><tr><td class="code"><pre><span class="line">   |<span class="string"> ------------ </span>|<span class="string"> ------------------------------------------------------------ </span>|</span></pre></td></tr><tr><td class="code"><pre><span class="line">   |<span class="string"> paramType    </span>|<span class="string"> 查询参数类型，实际上就是参数放在那里。取值：path：以地址的形式提交数据，根据 id 查询用户的接口就是这种形式传参。query：Query string 的方式传参。header：以流的形式提交。form：以 Form 表单的形式提交。 </span>|</span></pre></td></tr><tr><td class="code"><pre><span class="line">   |<span class="string"> dataType     </span>|<span class="string"> 参数的数据类型。取值：LongString                             </span>|</span></pre></td></tr><tr><td class="code"><pre><span class="line">   |<span class="string"> name         </span>|<span class="string"> 参数名字。                                                   </span>|</span></pre></td></tr><tr><td class="code"><pre><span class="line">   |<span class="string"> value        </span>|<span class="string"> 参数意义的描述。                                             </span>|</span></pre></td></tr><tr><td class="code"><pre><span class="line">   |<span class="string"> required     </span>|<span class="string"> 是否必填。取值：true：必填参数。false：非必填参数。          </span>|</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">### Model 相关注解</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">1. `<span class="meta">@ApiModel`:</span> 可设置接口相关实体的描述。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">2.</span></pre></td></tr></table></figure>
@ApiModelProperty</code></pre><p>: 可设置实体属性的相关描述。</p>
<p>表 4. @ApiModelProperty 主要属性</p>
<table>
<thead>
<tr>
<th><strong>注解属性</strong></th>
<th><strong>类型</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>String</td>
<td>字段说明。</td>
</tr>
<tr>
<td>name</td>
<td>String</td>
<td>重写字段名称。</td>
</tr>
<tr>
<td>dataType</td>
<td>Stirng</td>
<td>重写字段类型。</td>
</tr>
<tr>
<td>required</td>
<td>boolean</td>
<td>是否必填。</td>
</tr>
<tr>
<td>example</td>
<td>Stirng</td>
<td>举例说明。</td>
</tr>
<tr>
<td>hidden</td>
<td>boolean</td>
<td>是否在文档中隐藏该字段。</td>
</tr>
<tr>
<td>allowEmptyValue</td>
<td>boolean</td>
<td>是否允许为空。</td>
</tr>
<tr>
<td>allowableValues</td>
<td>String</td>
<td>该字段允许的值，当我们 API 的某个参数为枚举类型时，使用这个属性就可以清楚地告诉 API 使用者该参数所能允许传入的值。</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>在本教程中，我们学会了如何使用 Swagger 2 来生成 Spring Boot REST API 的文档。我们还研究了如何过滤 API、自定义 HTTP 响应消息以及如何使用 SwaggerUI 直接调用我们的 API。您可以在 Github 上找到本教程的<a href="https://github.com/ganchaoyang/spring-tutorial/tree/master/sb-swagger" target="_blank" rel="noopener">完整实现</a>，这是一个基于 IntelliJ IDEA 的项目，因此它应该很容易导入和运行，当然如果您想对本教程做补充的话欢迎发邮件给我 (<a href="mailto:gancy.programmer@gmail.com" target="_blank" rel="noopener">gancy.programmer@gmail.com</a>) 或者直接在 GitHub 上提交 Pull Request。</p>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul>
<li><a href="https://spring.io/guides" target="_blank" rel="noopener">Spring 指南</a></li>
<li><a href="https://spring.io/" target="_blank" rel="noopener">Spring 主页</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/" target="_blank" rel="noopener">Spring Boot 参考指南</a></li>
<li><a href="https://swagger.io/" target="_blank" rel="noopener">Swagger 主页</a></li>
<li><a href="https://github.com/ganchaoyang/spring-tutorial/tree/master/sb-swagger" target="_blank" rel="noopener">本文源码地址</a></li>
</ul>
<blockquote>
<p>作者：甘朝阳</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-using-swagger-in-a-spring-boot-project/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-using-swagger-in-a-spring-boot-project/index.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>透彻的掌握 Spring 中@transactional 的使用</title>
    <url>/2019/12/26/%E9%80%8F%E5%BD%BB%E7%9A%84%E6%8E%8C%E6%8F%A1-Spring-%E4%B8%AD-transactional-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>x事务管理是应用系统开发中必不可少的一部分。Spring 为事务管理提供了丰富的功能支持。Spring 事务管理分为编码式和声明式的两种方式。编程式事务指的是通过编码方式实现事务；声明式事务基于 AOP,将具体业务逻辑与事务处理解耦。声明式事务管理使业务代码逻辑不受污染, 因此在实际使用中声明式事务用的比较多。声明式事务有两种方式，一种是在配置文件（xml）中做相关的事务规则声明，另一种是基于<code>@Transactional</code> 注解的方式。注释配置是目前流行的使用方式，因此本文将着重介绍基于<code>@Transactional</code> 注解的事务管理。</p>
<a id="more"></a>

<h2 id="Transactional-注解管理事务的实现步骤"><a href="#Transactional-注解管理事务的实现步骤" class="headerlink" title="@Transactional 注解管理事务的实现步骤"></a>@Transactional 注解管理事务的实现步骤</h2><p>使用<code>@Transactional</code> 注解管理事务的实现步骤分为两步。第一步，在 xml 配置文件中添加如清单 1 的事务配置信息。除了用配置文件的方式，<code>@EnableTransactionManagement</code> 注解也可以启用事务管理功能。这里以简单的 <code>DataSourceTransactionManager</code> 为例。</p>
<p>清单 1. 在 xml 配置中的事务配置信息</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;tx:annotation-driven /&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">"transactionManager"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"dataSource"</span> <span class="keyword">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;/bean&gt;</span></pre></td></tr></table></figure>

<p>第二步，将<code>@Transactional</code> 注解添加到合适的方法上，并设置合适的属性信息。<code>@Transactional</code> 注解的属性信息如表 1 展示。</p>
<p>表 1. @Transactional 注解的属性信息</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。</td>
</tr>
<tr>
<td>propagation</td>
<td>事务的传播行为，默认值为 REQUIRED。</td>
</tr>
<tr>
<td>isolation</td>
<td>事务的隔离度，默认值采用 DEFAULT。</td>
</tr>
<tr>
<td>timeout</td>
<td>事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</td>
</tr>
<tr>
<td>read-only</td>
<td>指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</td>
</tr>
<tr>
<td>rollback-for</td>
<td>用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。</td>
</tr>
<tr>
<td>no-rollback- for</td>
<td>抛出 no-rollback-for 指定的异常类型，不回滚事务。</td>
</tr>
</tbody></table>
<p>除此以外，<code>@Transactional</code> 注解也可以添加到类级别上。当把<code>@Transactional</code> 注解放在类级别时，表示所有该类的公共方法都配置相同的事务属性信息。见清单 2，<code>EmployeeService</code> 的所有方法都支持事务并且是只读。当类级别配置了<code>@Transactional</code>，方法级别也配置了<code>@Transactional</code>，应用程序会以方法级别的事务属性信息来管理事务，换言之，方法级别的事务属性信息会覆盖类级别的相关配置信息。</p>
<p>清单 2. @Transactional 注解的类级别支持</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Transactional</span>(propagation= Propagation.SUPPORTS,readOnly=true)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Service</span>(value =<span class="string">"employeeService"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class EmployeeService</span></pre></td></tr></table></figure>

<p>到此，您会发觉使用<code>@Transactional</code> 注解管理事务的实现步骤很简单。但是如果对 Spring 中的 <code>@transaction</code> 注解的事务管理理解的不够透彻，就很容易出现错误，比如事务应该回滚（rollback）而没有回滚事务的问题。接下来，将首先分析 Spring 的注解方式的事务实现机制，然后列出相关的注意事项，以最终达到帮助开发人员准确而熟练的使用 Spring 的事务的目的。</p>
<h2 id="Spring-的注解方式的事务实现机制"><a href="#Spring-的注解方式的事务实现机制" class="headerlink" title="Spring 的注解方式的事务实现机制"></a>Spring 的注解方式的事务实现机制</h2><p>在应用系统调用声明<code>@Transactional</code> 的目标方法时，Spring Framework 默认使用 AOP 代理，在代码运行时生成一个代理对象，根据<code>@Transactional</code> 的属性配置信息，这个代理对象决定该声明<code>@Transactional</code> 的目标方法是否由拦截器 <code>TransactionInterceptor</code> 来使用拦截，在 <code>TransactionInterceptor</code> 拦截时，会在在目标方法开始执行之前创建并加入事务，并执行目标方法的逻辑, 最后根据执行情况是否出现异常，利用抽象事务管理器(图 2 有相关介绍)<code>AbstractPlatformTransactionManager</code> 操作数据源 <code>DataSource</code> 提交或回滚事务, 如图 1 所示。</p>
<p>图 1. Spring 事务实现机制</p>
<p><img src="http://image.winrains.cn/2019/08/a39a6-image001.jpg" alt="img"><br>Spring AOP 代理有 CglibAopProxy 和 JdkDynamicAopProxy 两种，图 1 是以 <code>CglibAopProxy</code> 为例，对于 <code>CglibAopProxy</code>，需要调用其内部类的 <code>DynamicAdvisedInterceptor</code> 的 <code>intercept</code> 方法。对于 <code>JdkDynamicAopProxy</code>，需要调用其 <code>invoke</code> 方法。<br>正如上文提到的，事务管理的框架是由抽象事务管理器 <code>AbstractPlatformTransactionManager</code> 来提供的，而具体的底层事务处理实现，由 <code>PlatformTransactionManager</code> 的具体实现类来实现，如事务管理器 <code>DataSourceTransactionManager</code>。不同的事务管理器管理不同的数据资源 <code>DataSource</code>，比如 <code>DataSourceTransactionManager</code> 管理 JDBC 的 Connection。<br><code>PlatformTransactionManager</code>，<code>AbstractPlatformTransactionManager</code> 及具体实现类关系如图 2 所示。</p>
<p>图 2. TransactionManager 类结构</p>
<p><img src="http://image.winrains.cn/2019/08/28a66-image002.jpg" alt="img"></p>
<h2 id="注解方式的事务使用注意事项"><a href="#注解方式的事务使用注意事项" class="headerlink" title="注解方式的事务使用注意事项"></a>注解方式的事务使用注意事项</h2><p>当您对 Spring 的基于注解方式的实现步骤和事务内在实现机制有较好的理解之后，就会更好的使用注解方式的事务管理，避免当系统抛出异常，数据不能回滚的问题。</p>
<h3 id="正确的设置-Transactional-的-propagation-属性"><a href="#正确的设置-Transactional-的-propagation-属性" class="headerlink" title="正确的设置@Transactional 的 propagation 属性"></a>正确的设置@Transactional 的 propagation 属性</h3><p>需要注意下面三种 propagation 可以不启动事务。本来期望目标方法进行事务管理，但若是错误的配置这三种 propagation，事务将不会发生回滚。</p>
<ol>
<li>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ol>
<h3 id="正确的设置-Transactional-的-rollbackFor-属性"><a href="#正确的设置-Transactional-的-rollbackFor-属性" class="headerlink" title="正确的设置@Transactional 的 rollbackFor 属性"></a>正确的设置@Transactional 的 rollbackFor 属性</h3><p>默认情况下，如果在事务中抛出了未检查异常（继承自 <code>RuntimeException</code> 的异常）或者 Error，则 Spring 将回滚事务；除此之外，Spring 不会回滚事务。<br>如果在事务中抛出其他类型的异常，并期望 Spring 能够回滚事务，可以指定 rollbackFor。例：<br><code>@Transactional(propagation= Propagation.REQUIRED,rollbackFor= MyException.class)</code><br>通过分析 Spring 源码可以知道，若在目标方法中抛出的异常是 <code>rollbackFor</code> 指定的异常的子类，事务同样会回滚。</p>
<p>清单 3. RollbackRuleAttribute 的 getDepth 方法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> get<span class="constructor">Depth(Class&lt;?&gt; <span class="params">exceptionClass</span>, <span class="params">int</span> <span class="params">depth</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (exceptionClass.get<span class="constructor">Name()</span>.contains(this.exceptionName)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Found it!</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        return depth;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// If we've gone as far as we can go and haven't found it...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (exceptionClass<span class="operator"> == </span><span class="module-access"><span class="module"><span class="identifier">Throwable</span>.</span></span><span class="keyword">class</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return -<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return get<span class="constructor">Depth(<span class="params">exceptionClass</span>.<span class="params">getSuperclass</span>()</span>, depth + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="Transactional-只能应用到-public-方法才有效"><a href="#Transactional-只能应用到-public-方法才有效" class="headerlink" title="@Transactional 只能应用到 public 方法才有效"></a>@Transactional 只能应用到 public 方法才有效</h3><p>只有<code>@Transactional</code> 注解应用到 public 方法，才能进行事务管理。这是因为在使用 Spring AOP 代理时，Spring 在调用在图 1 中的 <code>TransactionInterceptor</code> 在目标方法执行前后进行拦截之前，<code>DynamicAdvisedInterceptor</code>（CglibAopProxy 的内部类）的的 intercept 方法或 <code>JdkDynamicAopProxy</code> 的 invoke 方法会间接调用 <code>AbstractFallbackTransactionAttributeSource</code>（Spring 通过这个类获取表 1. <code>@Transactional</code> 注解的事务属性配置属性信息）的 <code>computeTransactionAttribute</code> 方法。</p>
<p>清单 4. AbstractFallbackTransactionAttributeSource</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> TransactionAttribute computeTransactionAttribute(<span class="function"><span class="keyword">Method</span> <span class="title">method</span>, <span class="title">Class</span>&lt;?&gt; <span class="title">targetClass</span>) <span class="comment">&#123;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="comment">    // Don't allow no-public methods as required.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="comment">    if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="comment">        return null;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="comment">    &#125;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">&#125;</span></span></pre></td></tr></table></figure>

<p>这个方法会检查目标方法的修饰符是不是 public，若不是 public，就不会获取<code>@Transactional</code> 的属性配置信息，最终会造成不会用 <code>TransactionInterceptor</code> 来拦截该目标方法进行事务管理。</p>
<h3 id="避免-Spring-的-AOP-的自调用问题"><a href="#避免-Spring-的-AOP-的自调用问题" class="headerlink" title="避免 Spring 的 AOP 的自调用问题"></a>避免 Spring 的 AOP 的自调用问题</h3><p>在 Spring 的 AOP 代理下，只有目标方法由外部调用，目标方法才由 Spring 生成的代理对象来管理，这会造成自调用问题。若同一类中的其他没有<code>@Transactional</code> 注解的方法内部调用有<code>@Transactional</code> 注解的方法，有<code>@Transactional</code> 注解的方法的事务被忽略，不会发生回滚。见清单 5 举例代码展示。</p>
<p>清单 5.自调用问题举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">--&gt;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">insertOrder();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertOrder</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//insert log info</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//insertOrder</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//updateAccount</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>insertOrder</code> 尽管有<code>@Transactional</code> 注解，但它被内部方法 insert 调用，事务被忽略，出现异常事务不会发生回滚。<br>上面的两个问题<code>@Transactional</code> 注解只应用到 public 方法和自调用问题，是由于使用 Spring AOP 代理造成的。为解决这两个问题，使用 AspectJ 取代 Spring AOP 代理。<br>需要将下面的 AspectJ 信息添加到 xml 配置信息中。</p>
<p>清单 6. AspectJ 的 xml 配置信息</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;tx:annotation-driven mode=<span class="string">"aspectj"</span> /&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">"transactionManager"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"dataSource"</span> <span class="keyword">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;/bean&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;/bean</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">class</span>=<span class="string">"org.springframework.transaction.aspectj.AnnotationTransactionAspect"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">factory-method=<span class="string">"aspectOf"</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"transactionManager"</span> <span class="keyword">ref</span>=<span class="string">"transactionManager"</span> /&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;/bean&gt;</span></pre></td></tr></table></figure>

<p>同时在 Maven 的 pom 文件中加入 spring-aspects 和 aspectjrt 的 dependency 以及 aspectj-maven-plugin。</p>
<p>清单 7. AspectJ 的 pom 配置信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectj-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">showWeaveInfo</span>&gt;</span>true<span class="tag">&lt;/<span class="name">showWeaveInfo</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aspectLibraries</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aspectLibrary</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">aspectLibrary</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">aspectLibraries</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">executions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">execution</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">goals</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">goal</span>&gt;</span>test-compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的介绍，相信读者能够清楚的了解基于<code>@Transactional</code> 注解的实现步骤，能够透彻的理解的 Spring 的内部实现机制，并有效的掌握相关使用注意事项，从而能够正确而熟练的使用基于<code>@Transactional</code> 注解的事务管理方式。</p>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul>
<li><a href="https://www.manning.com/books/spring-in-action-fourth-edition" target="_blank" rel="noopener">Spring in Action 英文第四版</a>：深入的介绍了 Spring 背后的原理,引领读者全面的理解 Spring 的框架。</li>
<li>您可以通过 developerWorks 社区与<a href="https://www.ibm.com/developerworks/mydeveloperworks/profiles/user/fisher_liu" target="_blank" rel="noopener">刘万振</a>进行交流。</li>
</ul>
<blockquote>
<p>作者：刘万振</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Spring Boot 编写应用程序</title>
    <url>/2019/12/26/%E4%BD%BF%E7%94%A8-Spring-Boot-%E7%BC%96%E5%86%99%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>Spring Boot 是一个轻量级框架，可以完成基于 Spring 的应用程序的大部分配置工作。在本教程中，将学习如何使用 Spring Boot 的 starter、特性和可执行 JAR 文件结构，快速创建能直接运行的基于 Spring 的应用程序。<br>简单介绍 Spring Boot 后，我将引导您设置并运行两个 Spring Boot 应用程序：一个简单的 “Hello, World” 应用程序和一个稍微复杂一点的 Spring MVC RESTful Web 服务应用程序。请注意，我在应用程序示例中使用的是 Spring Boot V1.5.2。推荐您使用 V1.5.2 或更高版本，但这些示例应适用于任何高于 1.5 的版本。</p>
<a id="more"></a>

<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>要充分掌握教程内容，您应该能熟练使用 Java™ Development Kit V8 (JDK 8)。还需要熟悉 Eclipse IDE、Maven 和 Git。<br>要顺利学习本教程，请确保安装了以下软件：</p>
<ul>
<li><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">JDK 8 for Windows, Mac, and Linux。</a></li>
<li><a href="http://www.eclipse.org/downloads/eclipse-packages/" target="_blank" rel="noopener">Eclipse IDE for Windows, Mac, and Linux。</a></li>
<li><a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">Apache Maven for Windows, Mac, and Linux。</a></li>
<li><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git for Windows, Mac, and Linux。</a></li>
</ul>
<p>深入介绍教程之前，我想简单介绍一下 Spring Boot。</p>
<h2 id="Spring-Boot-是什么？"><a href="#Spring-Boot-是什么？" class="headerlink" title="Spring Boot 是什么？"></a>Spring Boot 是什么？</h2><p>Spring Boot 的目的是提供一组工具，以便快速构建容易配置的 Spring 应用程序。</p>
<h3 id="问题：Spring-很难配置！"><a href="#问题：Spring-很难配置！" class="headerlink" title="问题：Spring 很难配置！"></a>问题：Spring 很难配置！</h3><p>如果您编写过基于 Spring 的应用程序，就会知道只是完成 “Hello, World” 就需要大量配置工作。这不是一件坏事：Spring 是一个优雅的框架集合，需要小心协调配置才能正确工作。但这种优雅的代价是配置变得很复杂（别跟我提 XML）。</p>
<h3 id="解决方案：Spring-Boot"><a href="#解决方案：Spring-Boot" class="headerlink" title="解决方案：Spring Boot"></a>解决方案：Spring Boot</h3><p>开始介绍 Spring Boot。<a href="https://projects.spring.io/spring-boot/" target="_blank" rel="noopener">Spring Boot 网站</a> 对它的介绍比我的简介更为简洁：</p>
<blockquote>
<p><em>“ Spring Boot 使您能轻松地创建独立的、生产级的、基于 Spring 且能直接运行的应用程序。我们对 Spring 平台和第三方库有自己的看法，所以您从一开始只会遇到极少的麻烦。”</em></p>
</blockquote>
<p>基本上讲，这意味着您只需极少的配置，就可以快速获得一个正常运行的 Spring 应用程序。这些极少的配置采用了注释的形式，所以没有 XML。<br>这一切听起来很不错，对吧？但 Spring Boot 到底是怎么工作的？</p>
<h3 id="首先，它很有主见"><a href="#首先，它很有主见" class="headerlink" title="首先，它很有主见"></a>首先，它很有主见</h3><p>Spring Boot 拥有<em>观点</em>。换句话说，Spring Boot 拥有<em>合理的默认值</em>，所以您可以使用这些常用值快速构建应用程序。<br>例如，Tomcat 是一个非常流行的 Web 容器。默认情况下，Spring Boot Web 应用程序使用了一个嵌入式 Tomcat 容器。</p>
<h3 id="其次，它可以自定义"><a href="#其次，它可以自定义" class="headerlink" title="其次，它可以自定义"></a>其次，它可以自定义</h3><p>如果无法改变其想法，具有主见的框架就不是很好的框架。您可以根据自己的喜好轻松地自定义 Spring Boot 应用程序，无论是在进行初始配置时还是在开发周期的后期阶段。<br>例如，如果喜欢 Maven，可以轻松地在 POM 文件中更改 <dependency> 来替换 Spring Boot 默认值。教程后面会这么做。</p>
<h2 id="开始使用-Spring-Boot"><a href="#开始使用-Spring-Boot" class="headerlink" title="开始使用 Spring Boot"></a>开始使用 Spring Boot</h2><h3 id="Starter"><a href="#Starter" class="headerlink" title="Starter"></a>Starter</h3><p>starter 是 Spring Boot 的一个重要组成部分，用于限制您需要执行的手动配置依赖项数量。要想有效地使用 Spring Boot，您应该了解 starter。<br><em>starter</em> 实际上是一组依赖项（比如 Maven POM），这些依赖项是 starter 所表示的应用程序类型所独有的。<br>所有 starter 都使用以下命名约定：<code>spring-boot-starter-XYZ</code>，其中 XYZ 是想要构建的应用程序类型。以下是一些流行的 Spring Boot starter：</p>
<ul>
<li><code>spring-boot-starter-</code><strong>web</strong> 用于构建 RESTful Web 服务，它使用 Spring MVC 和 Tomcat 作为嵌入式应用程序容器。</li>
<li><code>spring-boot-starter-</code><strong>jersey</strong> 是 <code>spring-boot-starter-web</code> 的一个替代，它使用 Apache Jersey 而不是 Spring MVC。</li>
<li><code>spring-boot-starter-</code><strong>jdbc</strong> 用于建立 JDBC 连接池。它基于 Tomcat 的 JDBC 连接池实现。</li>
</ul>
<p><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter" target="_blank" rel="noopener">Spring Boot starter 参考页面</a> 还列出了其他<strong>许多</strong> starter。您可以访问该页面来了解每个 starter 的 POM 和依赖项。</p>
<h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><p>如果您允许的话，Spring Boot 会使用其 <code>@EnableAutoConfiguration</code> 注释自动配置您的应用程序。自动配置基于类路径中的 JAR 和定义 bean 的方式：</p>
<p><strong>查看配置</strong>：使用 <code>--debug</code> 选项启动您的 Spring Boot 应用程序，然后将向控制台生成一个自动配置报告。</p>
<ul>
<li>Spring Boot 使用您在 <code>CLASSPATH</code> 中指定的 JAR，形成一个有关如何配置某个自动行为的观点。例如，如果类路径中有 H2 数据库 JAR，而且您没有配置任何其他 <code>DataSource</code> bean，您的应用程序会自动配置一个内存型数据库。</li>
<li>Spring Boot 使用您定义 bean 的方式来确定如何自动配置自身。例如，如果您为 JPA bean 添加了 <code>@Entity</code> 注释，Spring Boot 会自动配置 JPA，这样您就不需要 <code>persistence.xml</code> 文件。</li>
</ul>
<h3 id="Spring-Boot-uber-jar"><a href="#Spring-Boot-uber-jar" class="headerlink" title="Spring Boot über jar"></a>Spring Boot über jar</h3><p>Spring Boot 旨在帮助开发人员创建能直接运行的应用程序。为实现该目的，它将应用程序及其依赖项包装在一个可执行 JAR 中。要运行您的应用程序，可以像这样启动 Java：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>java -jar PATH_TO_EXECUTABLE_JAR/executableJar.jar</span></pre></td></tr></table></figure>

<p>Spring Boot über JAR 不是一个新概念。因为 Java 没有提供加载嵌套式 JAR 的标准方式，所以开发人员多年来一直使用 <a href="https://maven.apache.org/plugins/maven-shade-plugin/" target="_blank" rel="noopener">Apache Maven Shade 插件</a> 等工具来构建 “shaded” JAR。shaded JAR 仅包含来自应用程序的所有依赖 JAR 的 <code>.class</code> 文件。但随着应用程序复杂性的增加和依赖项的增多，shaded JAR 可能遇到两个问题：</p>
<ol>
<li>名称冲突，不同 JAR 中的两个类采用了相同名称。</li>
<li>依赖项版本问题，两个 JAR 使用同一个依赖项的不同版本。</li>
</ol>
<p>Spring Boot 解决这些问题的方法是定义一种 <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#executable-jar" target="_blank" rel="noopener">特殊的 JAR 文件布局</a>，其中的 JAR 本身嵌套在 über JAR 中。Spring 支持工具（例如 <code>spring-boot-maven</code> 插件）随后会构建这个可执行的 über JAR，使其符合该布局（不只是像shaded JAR 一样解包和重新打包 <code>.class</code> 文件）。运行这个可执行 JAR 时，Spring Boot 使用了一个特殊的类加载器来处理嵌套式 JAR 中的类。</p>
<h2 id="编写-Hello-World"><a href="#编写-Hello-World" class="headerlink" title="编写 Hello, World!"></a>编写 Hello, World!</h2><p>现在您已准备好开始直接使用 Spring Boot 了。本节中的示例基于一个名为 HelloSpringBoot 的简单应用程序。您可以和我一起练习这个应用程序开发示例，但是，如果想立即开始使用应用程序代码，可以从 Github <a href="https://github.com/makotogo/HelloSpringBoot" target="_blank" rel="noopener">下载</a>它。<br>让我们行动起来，创建一个新的 Maven 项目！</p>
<h3 id="1、创建-Maven-项目"><a href="#1、创建-Maven-项目" class="headerlink" title="1、创建 Maven 项目"></a><strong>1、创建 Maven 项目</strong></h3><p>在 Eclipse 中，转到 <strong>File &gt; New Project</strong> 并选择 <strong>Maven &gt; Maven Project</strong>，如图 1 所示。</p>
<p>图 1. 选择一个 Maven 项目</p>
<p><img src="http://image.winrains.cn/2019/08/31d67-eb709-Figure-1.png" alt="http://image.winrains.cn/2019/08/31d67-eb709-Figure-1.png"><br>单击 Next，在随后的对话框中（未给出）再次单击 Next。<br>您会被要求选择新 Maven 项目的架构类型。选择 <strong>maven-archetype-quickstart</strong>，如图 2 所示。</p>
<p>图 2. 选择 Maven quickstart 架构类型</p>
<p><img src="http://image.winrains.cn/2019/08/6ba64-c75b6-Figure-2.png" alt="http://image.winrains.cn/2019/08/6ba64-c75b6-Figure-2.png"><br>单击 Next。<br>最后，输入工件设置，如图 3 所示。</p>
<p>图 3. 选择 Maven 工件设置</p>
<p><img src="http://image.winrains.cn/2019/08/2b0ce-e5879-Figure-3.png" alt="http://image.winrains.cn/2019/08/2b0ce-e5879-Figure-3.png"><br>我为 HelloSpringBoot 应用程序使用了以下设置：</p>
<ul>
<li>Group Id：<code>com.makotojava.learn</code></li>
<li>Artifact Id：<code>HelloSpringBoot</code></li>
<li>Version：<code>1.0-SNAPSHOT</code></li>
<li>Package：<code>com.makotojava.learn.hellospringboot</code></li>
</ul>
<p>单击 Finish 创建该项目。</p>
<h3 id="2、创建-POM"><a href="#2、创建-POM" class="headerlink" title="2、创建 POM"></a><strong>2、创建 POM</strong></h3><p>修改 New Project 向导创建的 POM，使其类似于清单 1。</p>
<p>清单 1. HelloSpringBoot 的 POM 文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.makotojava.learn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HelloSpringBoot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>HelloSpringBoot<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>请注意清单 1 中突出显示的行：<br><strong>第 10 至 14 行</strong>显示了 <code>元素，它指定了 Spring Boot 父 POM，并包含常见组件的定义。您不需要手动配置这些组件。
**第 16 至 19 行**显示了 `spring-boot-starter-web` Spring Boot starter 上的</code>。它们告诉 Spring Boot，该应用程序是 Web 应用程序。Spring Boot 会相应地形成自己的观点。<br><strong>第 25 至 30 行</strong> 告诉 Maven 使用 <code>spring-boot-maven-plugin</code> 插件生成该 Spring Boot 应用程序。<br>配置不是太多，对吧？请注意，这里没有 XML。我们使用 Java 注释完成剩余配置。</p>
<h4 id="进一步了解-Spring-Boot-的观点"><a href="#进一步了解-Spring-Boot-的观点" class="headerlink" title="进一步了解 Spring Boot 的观点"></a>进一步了解 Spring Boot 的观点</h4><p>在进一步介绍之前，我想再讲讲 Spring Boot 的<em>观点</em>。换句话说，我认为有必要解释一下 Spring Boot 如何使用 <code>spring-boot-starter-web</code> 等 starter 来形成自己的配置观点。<br>示例应用程序 HelloSpringBoot 使用了 Spring Boot 的 Web 应用程序 starter <code>spring-boot-starter-web</code>。基于这个 starter，Spring Boot 形成了该应用程序的以下观点：</p>
<ul>
<li>使用 Tomcat 作为嵌入式 Web 服务器容器</li>
<li>使用 Hibernate 进行对象-关系映射 (ORM)</li>
<li>使用 Apache Jackson 绑定 JSON</li>
<li>使用 Spring MVC 作为 REST 框架</li>
</ul>
<p>我们来讲讲主见！据 Spring Boot 辩解，这些是最流行的 Web 应用程序默认设置 — 至少我一直在使用它们。<br>但是还记得我说过 Spring Boot 可以自定义吗？如果您想使用不同的技术组合，可以轻松地覆盖 Spring Boot 的默认设置。<br>我们接下来将演示一种简单的自定义。</p>
<p>丢失 ``</p>
<p>如果您的 POM 中已有一个 `` 元素，或者如果不想使用它，该怎么办？Spring Boot 是否仍会正常运行？<br>是的，它会正常运行，但您需要做两件事：</p>
<ol>
<li><p>手动添加依赖项（包括版本）</p>
</li>
<li><p>向 </p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">spring-<span class="keyword">boot</span>-maven-<span class="keyword">plugin</span></span></pre></td></tr></table></figure>

<p> 添加一个配置代码段，如清单 2 所示：</p>
<p>清单 2. 在不使用 <parent> POM 元素时，指定 <code>repackage</code> 目标</p>
</li>
</ol>
   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></pre></td></tr></table></figure>

<p><strong>检查依赖项</strong>：如果您需要查看使用的 Spring Boot starter 拉入了哪些依赖项，请访问 <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter" target="_blank" rel="noopener">Spring Boot starter 参考页面</a>。</p>
<p>一定要注意，Maven 的许多优秀功能都是在 <parent> 元素中实现的，所以如果您有合理的理由不使用它，继续操作时务必小心。确保向 <code>spring-boot-maven-plugin</code> 添加了一条 repackage 目标执行语句，<a href="http://docs.spring.io/spring-boot/docs/current/maven-plugin/usage.html" target="_blank" rel="noopener">这里提供了解释</a>。<br>该项目已配置和自定义。现在是时候构建可执行程序了。</p>
<h3 id="3、构建可执行-JAR"><a href="#3、构建可执行-JAR" class="headerlink" title="3、构建可执行 JAR"></a><strong>3、构建可执行 JAR</strong></h3><p>要使用 Maven 构建可执行 JAR，有两种选择：</p>
<ol>
<li>在 Eclipse 中运行 Maven 构建</li>
<li>从命令行运行 Maven 构建</li>
</ol>
<p>我将介绍如何实现这两种方法。</p>
<h4 id="在-Eclipse-中构建"><a href="#在-Eclipse-中构建" class="headerlink" title="在 Eclipse 中构建"></a>在 Eclipse 中构建</h4><p>要在 Eclipse 中运行 Maven 构建，请右键单击 POM 文件并选择 <strong>Run As &gt; Maven Build</strong>。在 Goals 文本字段中，输入 <code>clean</code> 和 <code>package</code>，然后单击 Run 按钮。</p>
<p>图 4. 在 Eclipse 中构建可执行 JAR</p>
<p><img src="http://image.winrains.cn/2019/08/a563a-e536b-Figure-4.png" alt="http://image.winrains.cn/2019/08/a563a-e536b-Figure-4.png"><br>您会在控制台视图中看到一条消息，表明成功实现了构建：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] BUILD SUCCESS</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Total time: 2.440 s</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Finished at: 2017-04-16T10:17:21-05:00</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Final Memory: 30M/331M</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ------------------------------------------------------------------------</span></pre></td></tr></table></figure>

<h4 id="从命令行构建"><a href="#从命令行构建" class="headerlink" title="从命令行构建"></a>从命令行构建</h4><p>要从命令行运行 Maven 构建，请打开 Mac 终端窗口或 Windows 命令提示，导航到 <code>HelloSpringBoot</code> 项目目录，然后执行以下命令：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">mvn clean <span class="class"><span class="keyword">package</span></span></span></pre></td></tr></table></figure>

<p>您会在终端窗口或命令提示中看到一条消息，表明成功实现了构建。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ cd HelloSpringBoot</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ pwd</span></pre></td></tr><tr><td class="code"><pre><span class="line">/Users/sperry/home/HelloSpringBoot</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ mvn clean package</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] BUILD SUCCESS</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Total time: 2.440 s</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Finished at: 2017-04-16T10:17:21-05:00</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Final Memory: 30M/331M</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">$</span></pre></td></tr></table></figure>

<p>现在您已准备好运行这个可执行 JAR 了。</p>
<h3 id="4、运行可执行-JAR"><a href="#4、运行可执行-JAR" class="headerlink" title="4、运行可执行 JAR"></a><strong>4、运行可执行 JAR</strong></h3><p>要运行刚创建的可执行 JAR，请打开 Mac 终端窗口或 Windows 命令提示，导航到 <code>HelloSpringBoot</code> 项目文件夹，然后执行：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">java -jar target/HelloSpringBoot-<span class="number">1.0</span>-<span class="module-access"><span class="module"><span class="identifier">SNAPSHOT</span>.</span></span>jar</span></pre></td></tr></table></figure>

<p>其中 <code>target</code> 是构建的默认输出目录。如果为它配置了不同的目录，请在上面的命令中进行相应的替换。<br>Spring Boot 的输出包含一个文本式 “启动屏幕”（第 2 至 7 行），以及其他输出，类似于下面的清单。我仅展示了部分行，以便让您了解在运行该应用程序时应看到的内容：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$ java -jar target/HelloSpringBoot-<span class="number">1.0</span>-SNAPSHOT.jar</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .   ____          <span class="symbol">_</span>            <span class="symbol">__</span> <span class="symbol">_</span> <span class="symbol">_</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> /\\ / ___'<span class="symbol">_</span> <span class="symbol">__</span> <span class="symbol">_</span> <span class="symbol">_</span>(<span class="symbol">_</span>)<span class="symbol">_</span> <span class="symbol">__</span>  <span class="symbol">__</span> <span class="symbol">_</span> \ \ \ \</span></pre></td></tr><tr><td class="code"><pre><span class="line">( ( )\___ | '<span class="symbol">_</span> | '<span class="symbol">_</span>| | '<span class="symbol">_</span> \/ <span class="symbol">_</span>` | \ \ \ \</span></pre></td></tr><tr><td class="code"><pre><span class="line"> \\/  ___)| |<span class="symbol">_</span>)| | | | | || (<span class="symbol">_</span>| |  ) ) ) )</span></pre></td></tr><tr><td class="code"><pre><span class="line">  '  |____| .<span class="symbol">__</span>|<span class="symbol">_</span>| |<span class="symbol">_</span>|<span class="symbol">_</span>| |<span class="symbol">_</span>\<span class="symbol">__</span>, | / / / /</span></pre></td></tr><tr><td class="code"><pre><span class="line"> =========|<span class="symbol">_</span>|==============|___/=/<span class="symbol">_</span>/<span class="symbol">_</span>/<span class="symbol">_</span>/</span></pre></td></tr><tr><td class="code"><pre><span class="line"> :: Spring Boot ::        (v1<span class="number">.5</span><span class="number">.2</span>.RELEASE)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2017</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">17</span>:<span class="number">46</span>:<span class="number">12.919</span>  INFO <span class="number">20096</span> --- [           main] c.makotojava.learn.hellospringboot.App   : Starting App v1<span class="number">.0</span>-SNAPSHOT on Ix.<span class="built_in">local</span> with PID <span class="number">20096</span> (/Users/sperry/home/projects/learn/HelloSpringBoot/target/HelloSpringBoot-<span class="number">1.0</span>-SNAPSHOT.jar started by sperry <span class="keyword">in</span> /Users/sperry/home/projects/learn/HelloSpringBoot)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2017</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">17</span>:<span class="number">46</span>:<span class="number">12.924</span> DEBUG <span class="number">20096</span> --- [           main] c.makotojava.learn.hellospringboot.App   : Running with Spring Boot v1<span class="number">.5</span><span class="number">.2</span>.RELEASE, Spring v4<span class="number">.3</span><span class="number">.7</span>.RELEASE</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2017</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">17</span>:<span class="number">46</span>:<span class="number">15.221</span>  INFO <span class="number">20096</span> --- [           main] c.makotojava.learn.hellospringboot.App   : Started App <span class="keyword">in</span> <span class="number">17.677</span> seconds (JVM running <span class="keyword">for</span> <span class="number">18.555</span>)</span></pre></td></tr></table></figure>

<p>如果应用程序成功启动，Spring Boot 输出的最后一行会包含文字 “Started App”（第 13 行）。现在您已准备好体验自己的应用程序了，我们接下来就会来体验它。</p>
<h3 id="5、体验该应用程序"><a href="#5、体验该应用程序" class="headerlink" title="5、体验该应用程序"></a><strong>5、体验该应用程序</strong></h3><p>可以打开浏览器并访问以下 URL，以便执行 HelloSpringBoot 的单一 REST 方法：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//localhost:8080/hello</span></span></pre></td></tr></table></figure>

<p>图 5. 开始使用 Spring Boot！</p>
<p><img src="http://image.winrains.cn/2019/08/1b7e4-4f95a-Figure-5.png" alt="http://image.winrains.cn/2019/08/1b7e4-4f95a-Figure-5.png"><br>如果看到文本 “Hello, All your base are belong to us”（视频游戏 <a href="https://en.wikipedia.org/wiki/All_your_base_are_belong_to_us" target="_blank" rel="noopener">Zero Wing</a> 的主页），就会知道该应用程序在正常运行！</p>
<h3 id="更改-Spring-Boot-的观点"><a href="#更改-Spring-Boot-的观点" class="headerlink" title="更改 Spring Boot 的观点"></a>更改 Spring Boot 的观点</h3><p>Spring Boot 的观点基于 POM 的内容，包括您在初步配置应用程序时指定的 Spring Boot starter。形成有关想要构建的应用程序类型的观点后，Spring Boot 会提供一组 Maven 依赖项。图 6 展示了 Spring Boot 在 Eclipse 中设置的一些 Maven 依赖项，它们基于 POM 内容以及为 HelloSpringBoot 应用程序指定的 starter：</p>
<p>图 6. HelloSpringBoot 的初始依赖项</p>
<p><img src="http://image.winrains.cn/2019/08/d6836-9d623-Figure-6.png" alt="http://image.winrains.cn/2019/08/d6836-9d623-Figure-6.png"><br>请注意，Tomcat 是默认的嵌入式 Web 服务器容器。现在我们假设您不想使用 Tomcat，而是想使用 Jetty。只需更改 POM 中的 `` 节（将清单 3 中第 5 至 15 行粘贴到 [清单 1](<a href="https://www.ibm.com/developerworks/cn/java/j-spring-boot-basics-perry/index.html#清单" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-spring-boot-basics-perry/index.html#清单</a> 1) 中的第 19 行之前）：</p>
<p>清单 3. 更改 POM 来使用 Jetty 代替 Tomcat</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr></table></figure>

<p>在下面可以注意到，Maven 的 Tomcat 依赖项消失了（得益于清单 3 中的第 5 至 10 行），取而代之的是 Jetty 依赖项（第 12 至 15 行）。</p>
<p>图 7. 自定义的 HelloSpringBoot 依赖项</p>
<p><img src="http://image.winrains.cn/2019/08/b4637-79dfc-Figure-7.png" alt="http://image.winrains.cn/2019/08/b4637-79dfc-Figure-7.png"><br>实际上，一张屏幕截图无法显示所有 Jetty 依赖项，但它们都包含在这里，而且 Tomcat 依赖项消失了。您可以自行尝试并查看结果！</p>
<h2 id="创建复杂的应用程序"><a href="#创建复杂的应用程序" class="headerlink" title="创建复杂的应用程序"></a>创建复杂的应用程序</h2><p>简单的示例虽然也能很好地展示 Spring Boot，但它能做的事情要多得多！在本节中，我将通过一个 Spring MVC RESTful Web 应用程序，介绍如何让 Spring Boot 充分发挥作用。要做的第一件事是设置新示例应用程序 SpringBootDemo。</p>
<h3 id="SpringBootDemo"><a href="#SpringBootDemo" class="headerlink" title="SpringBootDemo"></a>SpringBootDemo</h3><p>SpringBootDemo 是一个 Spring Boot 包装器，它包装了一个名为 oDoT 的基于 Spring 的简单 POJO 应用程序。（ToDo 中的反向排列……明白了吗？）它的目的是练习开发比简单 Hello, World 更复杂的应用程序的过程。您还会了解如何使用 Spring Boot 包装一个现有的应用程序。<br>要设置和运行 SpringBootDemo，需要做 3 件事：</p>
<ol>
<li>从 GitHub 获取代码。</li>
<li>构建并运行可执行 JAR。</li>
<li>通过 SoapUI 访问该应用程序。</li>
</ol>
<p>我创建了一个视频来帮助引导您完成此过程的每一步。现在可以启动该视频了。</p>
<p><a href="http://v.youku.com/v_show/id_XMjg1MzgwNjQ2MA==.html" target="_blank" rel="noopener">点击查看视频演示</a><a href="http://www.ibm.com/developerworks/cn/java/j-spring-boot-basics-perry/spring-boot-basics-perry-transcript.txt" target="_blank" rel="noopener">查看抄本</a></p>
<h4 id="1、获取代码"><a href="#1、获取代码" class="headerlink" title="1、获取代码"></a><strong>1、获取代码</strong></h4><p>首先，您需要从相应的 GitHub 存储库克隆两个项目。第一个项目名为 odotCore，包含应用程序的业务逻辑，该项目编写为一个基于 Spring 的 POJO 应用程序。另一个项目名为 SpringBootDemo，是一个围绕 odotCore 的 Spring Boot 应用程序包装器。<br>要克隆 odotCore 存储库，请打开一个 Mac 终端窗口或 Windows 命令提示，导航到您想放入该代码的根目录，然后执行以下命令：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/makotogo/odotCore</span></pre></td></tr></table></figure>

<p>要克隆 SpringBootDemo 存储库，可执行以下命令：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/makotogo/SpringBootDemo</span></pre></td></tr></table></figure>

<p>请注意，两个项目被直接放在应用程序的根目录下。接下来将代码导入工作区中。</p>
<h4 id="2、将代码导入-Eclipse-中"><a href="#2、将代码导入-Eclipse-中" class="headerlink" title="2、将代码导入 Eclipse 中"></a><strong>2、将代码导入 Eclipse 中</strong></h4><p>转到 <strong>File &gt; Import…</strong> 并选择 <strong>Maven &gt; Existing Maven Projects</strong>。<br>在下一个对话框中，使用 Browse 按钮导航到根目录。上一步中克隆的两个项目都应出现在对话框中，如下图所示：</p>
<p>图 8. 导入 Maven 项目</p>
<p><img src="http://image.winrains.cn/2019/08/8ed65-9b041-Figure-8.png" alt="http://image.winrains.cn/2019/08/8ed65-9b041-Figure-8.png"><br>单击 Finish 将这些项目导入 Eclipse 工作区中。接下来将构建可执行 JAR。</p>
<h4 id="3、构建可执行-JAR-1"><a href="#3、构建可执行-JAR-1" class="headerlink" title="3、构建可执行 JAR"></a><strong>3、构建可执行 JAR</strong></h4><p>要构建 SpringBootDemo，还需要构建 odotCore 和 SpringBootDemo 项目。可以从命令行构建这些项目，就像在 HelloSpringBoot 应用程序中所操作的那样。在本例中，我将指导您使用 Eclipse。<br>在 Eclipse 中，右键单击 odotCore 项目。选择 <strong>Run As &gt; Maven Build</strong>，指定 <code>clean</code> 和 <code>install</code> 目标。<code>install</code> 目标会将 <code>odotCore-1.0-SNAPSHOT.jar</code> JAR 文件安装到本地 Maven 存储库中。在运行 SpringBootDemo Maven 构建时，可从这里以依赖项形式拉入它。<br><code>odotCore</code> Maven 构建成功运行后，右键单击 SpringBootDemo 项目，选择 <strong>Run As &gt; Maven Build</strong>，然后指定 <code>clean</code> 和 <code>package</code> 目标。</p>
<p><strong>备注</strong>：odotCore 项目包含多个单元测试。尽管我从不建议跳过单元测试，但您可以设置在 Eclipse 中构建 odotCore 项目的运行配置，让其跳过这些测试（Run Configuration 对话框上有一个对应的复选框）。</p>
<p>成功构建 SpringBootDemo 后，可以从命令行运行 SpringBootDemo über JAR。</p>
<h4 id="4、运行可执行-JAR-1"><a href="#4、运行可执行-JAR-1" class="headerlink" title="4、运行可执行 JAR"></a><strong>4、运行可执行 JAR</strong></h4><p>从 Mac 终端窗口或 Windows 命令提示中导航到 SpringBootDemo 目录。假设构建输出目录名为 <code>target</code>（这是默认设置），执行以下命令：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">java -jar target/SpringBootDemo-<span class="number">1.0</span>-<span class="module-access"><span class="module"><span class="identifier">SNAPSHOT</span>.</span></span>jar</span></pre></td></tr></table></figure>

<p>现在静候 Spring Boot 运行该应用程序。当看到文本 “App Started” 时，就可以体验该应用程序了。</p>
<h4 id="5、体验该应用程序-1"><a href="#5、体验该应用程序-1" class="headerlink" title="5、体验该应用程序"></a><strong>5、体验该应用程序</strong></h4><p>作为一次快速冒烟测试，为了确保您的应用程序正常运行，可打开一个浏览器窗口并输入以下 URL：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//</span>localhost:<span class="number">8080</span><span class="regexp">/CategoryRestService/</span>FindAll</span></pre></td></tr></table></figure>

<p>这会访问 <code>CategoryRestService</code> 的 <code>FindAll</code> 方法，以 JSON 格式返回数据库中的所有 <code>Category</code> 对象。</p>
<p>图 9. 通过浏览器访问 SpringBootDemo</p>
<p><img src="http://image.winrains.cn/2019/08/bf9da-3b28b-Figure-9.png" alt="http://image.winrains.cn/2019/08/bf9da-3b28b-Figure-9.png"><br>也可以通过 SoapUI 体验该应用程序。我不会演示该如何做，但本教程的视频中介绍了该过程。<br>表 1 给出了 SpringBootDemo 的每个服务中的服务和方法。</p>
<p>表 1. oDoT (SpringBootDemo) 服务和方法</p>
<table>
<thead>
<tr>
<th>服务</th>
<th>方法</th>
<th>HTTP 方法</th>
<th>示例 URL @ <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>类别</td>
<td>FindAll</td>
<td>GET</td>
<td>/CategoryRestService/FindAll</td>
<td>查找数据库中的所有 Category 对象。</td>
</tr>
<tr>
<td>类别</td>
<td>FindById</td>
<td>GET</td>
<td>/CategoryRestService/FindbyId/1</td>
<td>查找 ID 值为 1 的类别。</td>
</tr>
<tr>
<td>类别</td>
<td>FindById</td>
<td>GET</td>
<td>/CategoryRestService/FindbyName/MY_CATEGORY</td>
<td>查找名称值为 “MY_CATEGORY” 的类别。</td>
</tr>
<tr>
<td>类别</td>
<td>Add</td>
<td>PUT</td>
<td>/CategoryRestService/Add</td>
<td>将指定的类别（作为请求主体中的 JSON 有效负载）添加到数据库中。返回：添加的 Category 对象（作为响应主体中的 JSON）。</td>
</tr>
<tr>
<td>类别</td>
<td>更新</td>
<td>POST</td>
<td>/CategoryRestService/Update</td>
<td>更新数据库中的指定类别（作为请求主体中的 JSON 有效负载）。返回：表示更新状态的字符串消息。</td>
</tr>
<tr>
<td>类别</td>
<td>删除</td>
<td>DELETE</td>
<td>/CategoryRestService/Delete</td>
<td>删除数据库中的指定类别（作为请求主题中的 JSON 有效负载）。返回：表示删除状态的字符串消息。</td>
</tr>
<tr>
<td>项</td>
<td>FindAll</td>
<td>GET</td>
<td>/ItemRestService/FindAll</td>
<td>查找数据库中的所有 Category 对象。</td>
</tr>
<tr>
<td>项</td>
<td>FindById</td>
<td>GET</td>
<td>/ItemRestService/FindbyId/1</td>
<td>查找 ID 值为 1 的类别。</td>
</tr>
<tr>
<td>项</td>
<td>FindById</td>
<td>GET</td>
<td>/ItemRestService/FindbyName/TODO_ITEM_1</td>
<td>查找名称值为 “TODO_ITEM_1” 的项。</td>
</tr>
<tr>
<td>项</td>
<td>Add</td>
<td>PUT</td>
<td>/ItemRestService/Add</td>
<td>将指定项（作为请求主体中的 JSON 有效负载）添加到数据库中。返回：添加的 Item 对象（作为响应主体中的 JSON）。</td>
</tr>
<tr>
<td>项</td>
<td>Update</td>
<td>POST</td>
<td>/ItemRestService/Update</td>
<td>更新数据库中的指定项（作为请求主体中的 JSON 有效负载）。返回：表示更新状态的字符串消息。</td>
</tr>
<tr>
<td>项</td>
<td>Delete</td>
<td>DELETE</td>
<td>/ItemRestService/Delete</td>
<td>删除数据库中的指定项（作为请求主体中的 JSON 有效负载）。返回：表示删除状态的字符串消息。</td>
</tr>
</tbody></table>
<p>建议研究该代码，试用它，以便更深入地了解 Spring Boot 的工作原理。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本教程介绍了 Spring Boot 解决的问题，并简要介绍了它的工作原理。然后我演练了设置和运行一个简单的 Spring Boot 应用程序 HelloSpringBoot 的过程。最后展示了如何使用 Spring Boot 构建和体验 Spring MVC RESTful Web 服务应用程序。<br>那么您接下来会怎么做？</p>
<h2 id="相关主题"><a href="#相关主题" class="headerlink" title="相关主题"></a>相关主题</h2><ul>
<li><a href="https://projects.spring.io/spring-boot/" target="_blank" rel="noopener">Spring Boot 是什么？</a></li>
<li><a href="http://www.adeveloperdiary.com/java/spring-boot/deploy-spring-boot-application-ibm-liberty-8-5/" target="_blank" rel="noopener">如何将 Spring Boot 应用程序部署到 IBM Liberty 和 WAS 8.5 中</a></li>
<li><a href="https://www.ibm.com/developerworks/community/blogs/3302cc3b-074e-44da-90b1-5055f1dc0d9c/entry/spring-boot?lang=zh" target="_blank" rel="noopener">Spring Boot：构建 Spring 应用程序的现代方式 </a></li>
</ul>
<blockquote>
<p>作者：J Steven Perry</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-spring-boot-basics-perry/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-spring-boot-basics-perry/index.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring Boot</category>
      </categories>
  </entry>
  <entry>
    <title>Servlet 工作原理解析</title>
    <url>/2019/12/26/Servlet-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="从-Servlet-容器说起"><a href="#从-Servlet-容器说起" class="headerlink" title="从 Servlet 容器说起"></a>从 Servlet 容器说起</h2><p>要介绍 Servlet 必须要先把 Servlet 容器说清楚，Servlet 与 Servlet 容器的关系有点像枪和子弹的关系，枪是为子弹而生，而子弹又让枪有了杀伤力。虽然它们是彼此依存的，但是又相互独立发展，这一切都是为了适应工业化生产的结果。从技术角度来说是为了解耦，通过标准化接口来相互协作。既然接口是连接 Servlet 与 Servlet 容器的关键，那我们就从它们的接口说起。<br>前面说了 Servlet 容器作为一个独立发展的标准化产品，目前它的种类很多，但是它们都有自己的市场定位，很难说谁优谁劣，各有特点。例如现在比较流行的 Jetty，在定制化和移动领域有不错的发展，我们这里还是以大家最为熟悉 Tomcat 为例来介绍 Servlet 容器如何管理 Servlet。Tomcat 本身也很复杂，我们只从 Servlet 与 Servlet 容器的接口部分开始介绍，关于 Tomcat 的详细介绍可以参考我的另外一篇文章《 Tomcat 系统架构与模式设计分析》。</p>
<a id="more"></a>

<p>Tomcat 的容器等级中，Context 容器是直接管理 Servlet 在容器中的包装类 Wrapper，所以 Context 容器如何运行将直接影响 Servlet 的工作方式。</p>
<p>图 1 . Tomcat 容器模型</p>
<p><img src="http://image.winrains.cn/2019/08/27e30-image002.jpg" alt="图 1 . Tomcat 容器模型"><br>从上图可以看出 Tomcat 的容器分为四个等级，真正管理 Servlet 的容器是 Context 容器，一个 Context 对应一个 Web 工程，在 Tomcat 的配置文件中可以很容易发现这一点，如下：</p>
<p>清单 1 Context 配置参数</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;Context <span class="attribute">path</span>=<span class="string">"/projectOne "</span> <span class="attribute">docBase</span>=<span class="string">"D:\projects\projectOne"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attribute">reloadable</span>=<span class="string">"true"</span> /&gt;</span></pre></td></tr></table></figure>

<p>下面详细介绍一下 Tomcat 解析 Context 容器的过程，包括如何构建 Servlet 的过程。</p>
<h3 id="Servlet-容器的启动过程"><a href="#Servlet-容器的启动过程" class="headerlink" title="Servlet 容器的启动过程"></a>Servlet 容器的启动过程</h3><p>Tomcat7 也开始支持嵌入式功能，增加了一个启动类 org.apache.catalina.startup.Tomcat。创建一个实例对象并调用 start 方法就可以很容易启动 Tomcat，我们还可以通过这个对象来增加和修改 Tomcat 的配置参数，如可以动态增加 Context、Servlet 等。下面我们就利用这个 Tomcat 类来管理新增的一个 Context 容器，我们就选择 Tomcat7 自带的 examples Web 工程，并看看它是如何加到这个 Context 容器中的。</p>
<p>清单 2 . 给 Tomcat 增加一个 Web 工程</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Tomcat tomcat = get<span class="constructor">TomcatInstance()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">File appDir = <span class="keyword">new</span> <span class="constructor">File(<span class="params">getBuildDirectory</span>()</span>, <span class="string">"webapps/examples"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">tomcat.add<span class="constructor">Webapp(<span class="params">null</span>, <span class="string">"/examples"</span>, <span class="params">appDir</span>.<span class="params">getAbsolutePath</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">tomcat.start<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">ByteChunk res = get<span class="constructor">Url(<span class="string">"http://localhost:"</span> + <span class="params">getPort</span>()</span> +</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="string">"/examples/servlets/servlet/HelloWorldExample"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span><span class="constructor">True(<span class="params">res</span>.<span class="params">toString</span>()</span>.index<span class="constructor">Of(<span class="string">"&lt;h1&gt;Hello World!&lt;/h1&gt;"</span>)</span> &gt; <span class="number">0</span>);</span></pre></td></tr></table></figure>

<p>清单 1 的代码是创建一个 Tomcat 实例并新增一个 Web 应用，然后启动 Tomcat 并调用其中的一个 HelloWorldExample Servlet，看有没有正确返回预期的数据。<br>Tomcat 的 addWebapp 方法的代码如下：</p>
<p>清单 3 .Tomcat.addWebapp</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public Context add<span class="constructor">Webapp(Host <span class="params">host</span>, String <span class="params">url</span>, String <span class="params">path</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    silence(url);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Context ctx = <span class="keyword">new</span> <span class="constructor">StandardContext()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ctx.set<span class="constructor">Path(<span class="params">url</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ctx.set<span class="constructor">DocBase(<span class="params">path</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (defaultRealm<span class="operator"> == </span>null) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        init<span class="constructor">SimpleAuth()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ctx.set<span class="constructor">Realm(<span class="params">defaultRealm</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ctx.add<span class="constructor">LifecycleListener(<span class="params">new</span> DefaultWebXmlListener()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ContextConfig ctxCfg = <span class="keyword">new</span> <span class="constructor">ContextConfig()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ctx.add<span class="constructor">LifecycleListener(<span class="params">ctxCfg</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ctxCfg.set<span class="constructor">DefaultWebXml(<span class="string">"org/apache/catalin/startup/NO_DEFAULT_XML"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (host<span class="operator"> == </span>null) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        get<span class="constructor">Host()</span>.add<span class="constructor">Child(<span class="params">ctx</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        host.add<span class="constructor">Child(<span class="params">ctx</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return ctx;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>前面已经介绍了一个 Web 应用对应一个 Context 容器，也就是 Servlet 运行时的 Servlet 容器，添加一个 Web 应用时将会创建一个 StandardContext 容器，并且给这个 Context 容器设置必要的参数，url 和 path 分别代表这个应用在 Tomcat 中的访问路径和这个应用实际的物理路径，这个两个参数与清单 1 中的两个参数是一致的。其中最重要的一个配置是 ContextConfig，这个类将会负责整个 Web 应用配置的解析工作，后面将会详细介绍。最后将这个 Context 容器加到父容器 Host 中。<br>接下去将会调用 Tomcat 的 start 方法启动 Tomcat，如果你清楚 Tomcat 的系统架构，你会容易理解 Tomcat 的启动逻辑，Tomcat 的启动逻辑是基于观察者模式设计的，所有的容器都会继承 Lifecycle 接口，它管理者容器的整个生命周期，所有容器的的修改和状态的改变都会由它去通知已经注册的观察者（Listener），关于这个设计模式可以参考《 Tomcat 的系统架构与设计模式，第二部分：设计模式》。Tomcat 启动的时序图可以用图 2 表示。</p>
<p>图 2. Tomcat 主要类的启动时序图</p>
<p><img src="http://image.winrains.cn/2019/08/cbfee-image003.jpg" alt="http://image.winrains.cn/2019/08/cbfee-image003.jpg"><br>上图描述了 Tomcat 启动过程中，主要类之间的时序关系，下面我们将会重点关注添加 examples 应用所对应的 StandardContext 容器的启动过程。<br>当 Context 容器初始化状态设为 init 时，添加在 Contex 容器的 Listener 将会被调用。ContextConfig 继承了 LifecycleListener 接口，它是在调用清单 3 时被加入到 StandardContext 容器中。ContextConfig 类会负责整个 Web 应用的配置文件的解析工作。<br>ContextConfig 的 init 方法将会主要完成以下工作：</p>
<ol>
<li>创建用于解析 xml 配置文件的 contextDigester 对象</li>
<li>读取默认 context.xml 配置文件，如果存在解析它</li>
<li>读取默认 Host 配置文件，如果存在解析它</li>
<li>读取默认 Context 自身的配置文件，如果存在解析它</li>
<li>设置 Context 的 DocBase</li>
</ol>
<p>ContextConfig 的 init 方法完成后，Context 容器的会执行 startInternal 方法，这个方法启动逻辑比较复杂，主要包括如下几个部分：</p>
<ol>
<li>创建读取资源文件的对象</li>
<li>创建 ClassLoader 对象</li>
<li>设置应用的工作目录</li>
<li>启动相关的辅助类如：logger、realm、resources 等</li>
<li>修改启动状态，通知感兴趣的观察者（Web 应用的配置）</li>
<li>子容器的初始化</li>
<li>获取 ServletContext 并设置必要的参数</li>
<li>初始化“load on startup”的 Servlet</li>
</ol>
<h3 id="Web-应用的初始化工作"><a href="#Web-应用的初始化工作" class="headerlink" title="Web 应用的初始化工作"></a>Web 应用的初始化工作</h3><p>Web 应用的初始化工作是在 ContextConfig 的 configureStart 方法中实现的，应用的初始化主要是要解析 web.xml 文件，这个文件描述了一个 Web 应用的关键信息，也是一个 Web 应用的入口。<br>Tomcat 首先会找 globalWebXml 这个文件的搜索路径是在 engine 的工作目录下寻找以下两个文件中的任一个 org/apache/catalin/startup/NO_DEFAULT_XML 或 conf/web.xml。接着会找 hostWebXml 这个文件可能会在 System.getProperty(“catalina.base”)/conf/${EngineName}/${HostName}/web.xml.default，接着寻找应用的配置文件 examples/WEB-INF/web.xml。web.xml 文件中的各个配置项将会被解析成相应的属性保存在 WebXml 对象中。如果当前应用支持 Servlet3.0，解析还将完成额外 9 项工作，这个额外的 9 项工作主要是为 Servlet3.0 新增的特性，包括 jar 包中的 META-INF/web-fragment.xml 的解析以及对 annotations 的支持。<br>接下去将会将 WebXml 对象中的属性设置到 Context 容器中，这里包括创建 Servlet 对象、filter、listener 等等。这段代码在 WebXml 的 configureContext 方法中。下面是解析 Servlet 的代码片段：</p>
<p>清单 4. 创建 Wrapper 实例</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (ServletDef servlet : servlets.<span class="keyword">values</span>()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">Wrapper</span> <span class="keyword">wrapper</span> = context.createWrapper();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    String jspFile = servlet.getJspFile();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (jspFile != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">wrapper</span>.setJspFile(jspFile);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (servlet.getLoadOnStartup() != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">wrapper</span>.setLoadOnStartup(servlet.getLoadOnStartup().intValue());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (servlet.getEnabled() != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">wrapper</span>.setEnabled(servlet.getEnabled().booleanValue());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">wrapper</span>.setName(servlet.getServletName());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Map&lt;String, String&gt; params = servlet.getParameterMap();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : params.entrySet()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">wrapper</span>.addInitParameter(entry.getKey(), entry.getValue());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">wrapper</span>.setRunAs(servlet.getRunAs());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">Set</span>&lt;SecurityRoleRef&gt; roleRefs = servlet.getSecurityRoleRefs();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (SecurityRoleRef roleRef : roleRefs) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">wrapper</span>.addSecurityReference(roleRef.getName(), roleRef.getLink());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">wrapper</span>.setServletClass(servlet.getServletClass());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MultipartDef multipartdef = servlet.getMultipartDef();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (multipartdef != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (multipartdef.getMaxFileSize() != <span class="keyword">null</span> &amp;&amp; multipartdef.getMaxRequestSize() != <span class="keyword">null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                &amp;&amp; multipartdef.getFileSizeThreshold() != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">wrapper</span>.setMultipartConfigElement(<span class="built_in">new</span> MultipartConfigElement(multipartdef.getLocation(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    Long.parseLong(multipartdef.getMaxFileSize()),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    Long.parseLong(multipartdef.getMaxRequestSize()),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="type">Integer</span>.parseInt(multipartdef.getFileSizeThreshold())));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">wrapper</span>.setMultipartConfigElement(<span class="built_in">new</span> MultipartConfigElement(multipartdef.getLocation()));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (servlet.getAsyncSupported() != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">wrapper</span>.setAsyncSupported(servlet.getAsyncSupported().booleanValue());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    context.addChild(<span class="keyword">wrapper</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这段代码清楚的描述了如何将 Servlet 包装成 Context 容器中的 StandardWrapper，这里有个疑问，为什么要将 Servlet 包装成 StandardWrapper 而不直接是 Servlet 对象。这里 StandardWrapper 是 Tomcat 容器中的一部分，它具有容器的特征，而 Servlet 为了一个独立的 web 开发标准，不应该强耦合在 Tomcat 中。<br>除了将 Servlet 包装成 StandardWrapper 并作为子容器添加到 Context 中，其它的所有 web.xml 属性都被解析到 Context 中，所以说 Context 容器才是真正运行 Servlet 的 Servlet 容器。一个 Web 应用对应一个 Context 容器，容器的配置属性由应用的 web.xml 指定，这样我们就能理解 web.xml 到底起到什么作用了。</p>
<h2 id="创建-Servlet-实例"><a href="#创建-Servlet-实例" class="headerlink" title="创建 Servlet 实例"></a>创建 Servlet 实例</h2><p>前面已经完成了 Servlet 的解析工作，并且被包装成 StandardWrapper 添加在 Context 容器中，但是它仍然不能为我们工作，它还没有被实例化。下面我们将介绍 Servlet 对象是如何创建的，以及如何被初始化的。</p>
<h3 id="创建-Servlet-对象"><a href="#创建-Servlet-对象" class="headerlink" title="创建 Servlet 对象"></a>创建 Servlet 对象</h3><p>如果 Servlet 的 load-on-startup 配置项大于 0，那么在 Context 容器启动的时候就会被实例化，前面提到在解析配置文件时会读取默认的 globalWebXml，在 conf 下的 web.xml 文件中定义了一些默认的配置项，其定义了两个 Servlet，分别是：org.apache.catalina.servlets.DefaultServlet 和 org.apache.jasper.servlet.JspServlet 它们的 load-on-startup 分别是 1 和 3，也就是当 Tomcat 启动时这两个 Servlet 就会被启动。<br>创建 Servlet 实例的方法是从 Wrapper. loadServlet 开始的。loadServlet 方法要完成的就是获取 servletClass 然后把它交给 InstanceManager 去创建一个基于 servletClass.class 的对象。如果这个 Servlet 配置了 jsp-file，那么这个 servletClass 就是 conf/web.xml 中定义的 org.apache.jasper.servlet.JspServlet 了。<br>创建 Servlet 对象的相关类结构图如下：</p>
<p>图 3. 创建 Servlet 对象的相关类结构</p>
<p><img src="http://image.winrains.cn/2019/08/af86c-image006.jpg" alt="图 3. 创建 Servlet 对象的相关类结构"></p>
<h3 id="初始化-Servlet"><a href="#初始化-Servlet" class="headerlink" title="初始化 Servlet"></a>初始化 Servlet</h3><p>初始化 Servlet 在 StandardWrapper 的 initServlet 方法中，这个方法很简单就是调用 Servlet 的 init 的方法，同时把包装了 StandardWrapper 对象的 StandardWrapperFacade 作为 ServletConfig 传给 Servlet。Tomcat 容器为何要传 StandardWrapperFacade 给 Servlet 对象将在后面做详细解析。<br>如果该 Servlet 关联的是一个 jsp 文件，那么前面初始化的就是 JspServlet，接下去会模拟一次简单请求，请求调用这个 jsp 文件，以便编译这个 jsp 文件为 class，并初始化这个 class。<br>这样 Servlet 对象就初始化完成了，事实上 Servlet 从被 web.xml 中解析到完成初始化，这个过程非常复杂，中间有很多过程，包括各种容器状态的转化引起的监听事件的触发、各种访问权限的控制和一些不可预料的错误发生的判断行为等等。我们这里只抓了一些关键环节进行阐述，试图让大家有个总体脉络。<br>下面是这个过程的一个完整的时序图，其中也省略了一些细节。</p>
<p>图 4. 初始化 Servlet 的时序图</p>
<p><img src="http://image.winrains.cn/2019/08/c1fb6-image007.jpg" alt="http://image.winrains.cn/2019/08/c1fb6-image007.jpg"></p>
<h2 id="Servlet-体系结构"><a href="#Servlet-体系结构" class="headerlink" title="Servlet 体系结构"></a>Servlet 体系结构</h2><p>我们知道 Java Web 应用是基于 Servlet 规范运转的，那么 Servlet 本身又是如何运转的呢？为何要设计这样的体系结构。</p>
<p>图 5.Servlet 顶层类关联图</p>
<p><img src="http://image.winrains.cn/2019/08/482e2-image010.jpg" alt="图 5.Servlet 顶层类关联图"><br>从上图可以看出 Servlet 规范就是基于这几个类运转的，与 Servlet 主动关联的是三个类，分别是 ServletConfig、ServletRequest 和 ServletResponse。这三个类都是通过容器传递给 Servlet 的，其中 ServletConfig 是在 Servlet 初始化时就传给 Servlet 了，而后两个是在请求达到时调用 Servlet 时传递过来的。我们很清楚 ServletRequest 和 ServletResponse 在 Servlet 运行的意义，但是 ServletConfig 和 ServletContext 对 Servlet 有何价值？仔细查看 ServletConfig 接口中声明的方法发现，这些方法都是为了获取这个 Servlet 的一些配置属性，而这些配置属性可能在 Servlet 运行时被用到。而 ServletContext 又是干什么的呢？ Servlet 的运行模式是一个典型的“握手型的交互式”运行模式。所谓“握手型的交互式”就是两个模块为了交换数据通常都会准备一个交易场景，这个场景一直跟随个这个交易过程直到这个交易完成为止。这个交易场景的初始化是根据这次交易对象指定的参数来定制的，这些指定参数通常就会是一个配置类。所以对号入座，交易场景就由 ServletContext 来描述，而定制的参数集合就由 ServletConfig 来描述。而 ServletRequest 和 ServletResponse 就是要交互的具体对象了，它们通常都是作为运输工具来传递交互结果。<br>ServletConfig 是在 Servlet init 时由容器传过来的，那么 ServletConfig 到底是个什么对象呢？<br>下图是 ServletConfig 和 ServletContext 在 Tomcat 容器中的类关系图。</p>
<p>图 6. ServletConfig 在容器中的类关联图</p>
<p><img src="http://image.winrains.cn/2019/08/de44b-image012.jpg" alt="图 6. ServletConfig 在容器中的类关联图"><br>上图可以看出 StandardWrapper 和 StandardWrapperFacade 都实现了 ServletConfig 接口，而 StandardWrapperFacade 是 StandardWrapper 门面类。所以传给 Servlet 的是 StandardWrapperFacade 对象，这个类能够保证从 StandardWrapper 中拿到 ServletConfig 所规定的数据，而又不把 ServletConfig 不关心的数据暴露给 Servlet。<br>同样 ServletContext 也与 ServletConfig 有类似的结构，Servlet 中能拿到的 ServletContext 的实际对象也是 ApplicationContextFacade 对象。ApplicationContextFacade 同样保证 ServletContex 只能从容器中拿到它该拿的数据，它们都起到对数据的封装作用，它们使用的都是门面设计模式。<br>通过 ServletContext 可以拿到 Context 容器中一些必要信息，比如应用的工作路径，容器支持的 Servlet 最小版本等。<br>Servlet 中定义的两个 ServletRequest 和 ServletResponse 它们实际的对象又是什么呢？，我们在创建自己的 Servlet 类时通常使用的都是 HttpServletRequest 和 HttpServletResponse，它们继承了 ServletRequest 和 ServletResponse。为何 Context 容器传过来的 ServletRequest、ServletResponse 可以被转化为 HttpServletRequest 和 HttpServletResponse 呢？</p>
<p>图 7.Request 相关类结构图</p>
<p><img src="http://image.winrains.cn/2019/08/ba240-image014.jpg" alt="图 7.Request 相关类结构图"><br>上图是 Tomcat 创建的 Request 和 Response 的类结构图。Tomcat 一接受到请求首先将会创建 org.apache.coyote.Request 和 org.apache.coyote.Response，这两个类是 Tomcat 内部使用的描述一次请求和相应的信息类它们是一个轻量级的类，它们作用就是在服务器接收到请求后，经过简单解析将这个请求快速的分配给后续线程去处理，所以它们的对象很小，很容易被 JVM 回收。接下去当交给一个用户线程去处理这个请求时又创建 org.apache.catalina.connector. Request 和 org.apache.catalina.connector. Response 对象。这两个对象一直穿越整个 Servlet 容器直到要传给 Servlet，传给 Servlet 的是 Request 和 Response 的门面类 RequestFacade 和 RequestFacade，这里使用门面模式与前面一样都是基于同样的目的——封装容器中的数据。一次请求对应的 Request 和 Response 的类转化如下图所示：</p>
<p>图 8.Request 和 Response 的转变过程</p>
<p><img src="http://image.winrains.cn/2019/08/34747-image016.jpg" alt="图 8.Request 和 Response 的转变过程"></p>
<h2 id="Servlet-如何工作"><a href="#Servlet-如何工作" class="headerlink" title="Servlet 如何工作"></a>Servlet 如何工作</h2><p>我们已经清楚了 Servlet 是如何被加载的、Servlet 是如何被初始化的，以及 Servlet 的体系结构，现在的问题就是它是如何被调用的。<br>当用户从浏览器向服务器发起一个请求，通常会包含如下信息：<a href="http://hostname" target="_blank" rel="noopener">http://hostname</a>: port /contextpath/servletpath，hostname 和 port 是用来与服务器建立 TCP 连接，而后面的 URL 才是用来选择服务器中那个子容器服务用户的请求。那服务器是如何根据这个 URL 来达到正确的 Servlet 容器中的呢？<br>Tomcat7.0 中这件事很容易解决，因为这种映射工作有专门一个类来完成的，这个就是 org.apache.tomcat.util.http.mapper，这个类保存了 Tomcat 的 Container 容器中的所有子容器的信息，当 org.apache.catalina.connector. Request 类在进入 Container 容器之前，mapper 将会根据这次请求的 hostnane 和 contextpath 将 host 和 context 容器设置到 Request 的 mappingData 属性中。所以当 Request 进入 Container 容器之前，它要访问那个子容器这时就已经确定了。</p>
<p>图 9.Request 的 Mapper 类关系图</p>
<p><img src="http://image.winrains.cn/2019/08/c6faf-image018.jpg" alt="图 9.Request 的 Mapper 类关系图"><br>可能你有疑问，mapper 中怎么会有容器的完整关系，这要回到图 2 中 19 步 MapperListener 类的初始化过程，下面是 MapperListener 的 init 方法代码 :</p>
<p>清单 5. MapperListener.init</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void init<span class="literal">()</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    find<span class="constructor">DefaultHost()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Engine engine = (Engine) connector.get<span class="constructor">Service()</span>.get<span class="constructor">Container()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    engine.add<span class="constructor">ContainerListener(<span class="params">this</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Container<span class="literal">[]</span> conHosts = engine.find<span class="constructor">Children()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (Container conHost : conHosts) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Host host = (Host) conHost;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!<span class="module-access"><span class="module"><span class="identifier">LifecycleState</span>.</span><span class="module"><span class="identifier">NEW</span>.</span></span>equals(host.get<span class="constructor">State()</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            host.add<span class="constructor">LifecycleListener(<span class="params">this</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            register<span class="constructor">Host(<span class="params">host</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这段代码的作用就是将 MapperListener 类作为一个监听者加到整个 Container 容器中的每个子容器中，这样只要任何一个容器发生变化，MapperListener 都将会被通知，相应的保存容器关系的 MapperListener 的 mapper 属性也会修改。for 循环中就是将 host 及下面的子容器注册到 mapper 中。</p>
<p>图 10.Request 在容器中的路由图</p>
<p><img src="http://image.winrains.cn/2019/08/9efb7-image020.jpg" alt="图 10.Request 在容器中的路由图"><br>上图描述了一次 Request 请求是如何达到最终的 Wrapper 容器的，我们现正知道了请求是如何达到正确的 Wrapper 容器，但是请求到达最终的 Servlet 还要完成一些步骤，必须要执行 Filter 链，以及要通知你在 web.xml 中定义的 listener。<br>接下去就要执行 Servlet 的 service 方法了，通常情况下，我们自己定义的 servlet 并不是直接去实现 javax.servlet.servlet 接口，而是去继承更简单的 HttpServlet 类或者 GenericServlet 类，我们可以有选择的覆盖相应方法去实现我们要完成的工作。<br>Servlet 的确已经能够帮我们完成所有的工作了，但是现在的 web 应用很少有直接将交互全部页面都用 servlet 来实现，而是采用更加高效的 MVC 框架来实现。这些 MVC 框架基本的原理都是将所有的请求都映射到一个 Servlet，然后去实现 service 方法，这个方法也就是 MVC 框架的入口。<br>当 Servlet 从 Servlet 容器中移除时，也就表明该 Servlet 的生命周期结束了，这时 Servlet 的 destroy 方法将被调用，做一些扫尾工作。</p>
<h2 id="Session-与-Cookie"><a href="#Session-与-Cookie" class="headerlink" title="Session 与 Cookie"></a>Session 与 Cookie</h2><p>前面我们已经说明了 Servlet 如何被调用，我们基于 Servlet 来构建应用程序，那么我们能从 Servlet 获得哪些数据信息呢？<br>Servlet 能够给我们提供两部分数据，一个是在 Servlet 初始化时调用 init 方法时设置的 ServletConfig，这个类基本上含有了 Servlet 本身和 Servlet 所运行的 Servlet 容器中的基本信息。根据前面的介绍 ServletConfig 的实际对象是 StandardWrapperFacade，到底能获得哪些容器信息可以看看这类提供了哪些接口。还有一部分数据是由 ServletRequest 类提供，它的实际对象是 RequestFacade，从提供的方法中发现主要是描述这次请求的 HTTP 协议的信息。所以要掌握 Servlet 的工作方式必须要很清楚 HTTP 协议，如果你还不清楚赶紧去找一些参考资料。关于这一块还有一个让很多人迷惑的 Session 与 Cookie。<br>Session 与 Cookie 不管是对 Java Web 的熟练使用者还是初学者来说都是一个令人头疼的东西。Session 与 Cookie 的作用都是为了保持访问用户与后端服务器的交互状态。它们有各自的优点也有各自的缺陷。然而具有讽刺意味的是它们优点和它们的使用场景又是矛盾的，例如使用 Cookie 来传递信息时，随着 Cookie 个数的增多和访问量的增加，它占用的网络带宽也很大，试想假如 Cookie 占用 200 个字节，如果一天的 PV 有几亿的时候，它要占用多少带宽。所以大访问量的时候希望用 Session，但是 Session 的致命弱点是不容易在多台服务器之间共享，所以这也限制了 Session 的使用。<br>不管 Session 和 Cookie 有什么不足，我们还是要用它们。下面详细讲一下，Session 如何基于 Cookie 来工作。实际上有三种方式能可以让 Session 正常工作：</p>
<ol>
<li>基于 URL Path Parameter，默认就支持</li>
<li>基于 Cookie，如果你没有修改 Context 容器个 cookies 标识的话，默认也是支持的</li>
<li>基于 SSL，默认不支持，只有 connector.getAttribute(“SSLEnabled”) 为 TRUE 时才支持</li>
</ol>
<p>第一种情况下，当浏览器不支持 Cookie 功能时，浏览器会将用户的 SessionCookieName 重写到用户请求的 URL 参数中，它的传递格式如 /path/Servlet;name=value;name2=value2? Name3=value3，其中“Servlet；”后面的 K-V 对就是要传递的 Path Parameters，服务器会从这个 Path Parameters 中拿到用户配置的 SessionCookieName。关于这个 SessionCookieName，如果你在 web.xml 中配置 session-config 配置项的话，其 cookie-config 下的 name 属性就是这个 SessionCookieName 值，如果你没有配置 session-config 配置项，默认的 SessionCookieName 就是大家熟悉的“JSESSIONID”。接着 Request 根据这个 SessionCookieName 到 Parameters 拿到 Session ID 并设置到 request.setRequestedSessionId 中。<br>请注意如果客户端也支持 Cookie 的话，Tomcat 仍然会解析 Cookie 中的 Session ID，并会覆盖 URL 中的 Session ID。<br>如果是第三种情况的话将会根据 javax.servlet.request.ssl_session 属性值设置 Session ID。<br>有了 Session ID 服务器端就可以创建 HttpSession 对象了，第一次触发是通过 request. getSession() 方法，如果当前的 Session ID 还没有对应的 HttpSession 对象那么就创建一个新的，并将这个对象加到 org.apache.catalina. Manager 的 sessions 容器中保存，Manager 类将管理所有 Session 的生命周期，Session 过期将被回收，服务器关闭，Session 将被序列化到磁盘等。只要这个 HttpSession 对象存在，用户就可以根据 Session ID 来获取到这个对象，也就达到了状态的保持。</p>
<p>图 11.Session 相关类图</p>
<p><img src="http://image.winrains.cn/2019/08/d82c0-image022.jpg" alt="图 11.Session 相关类图"><br>上从图中可以看出从 request.getSession 中获取的 HttpSession 对象实际上是 StandardSession 对象的门面对象，这与前面的 Request 和 Servlet 是一样的原理。下图是 Session 工作的时序图：</p>
<p>图 12.Session 工作的时序图</p>
<p><img src="http://image.winrains.cn/2019/08/48f57-image023.jpg" alt="http://image.winrains.cn/2019/08/48f57-image023.jpg"><br>还有一点与 Session 关联的 Cookie 与其它 Cookie 没有什么不同，这个配置的配置可以通过 web.xml 中的 session-config 配置项来指定。</p>
<h2 id="Servlet-中的-Listener"><a href="#Servlet-中的-Listener" class="headerlink" title="Servlet 中的 Listener"></a>Servlet 中的 Listener</h2><p>整个 Tomcat 服务器中 Listener 使用的非常广泛，它是基于观察者模式设计的，Listener 的设计对开发 Servlet 应用程序提供了一种快捷的手段，能够方便的从另一个纵向维度控制程序和数据。目前 Servlet 中提供了 5 种两类事件的观察者接口，它们分别是：4 个 EventListeners 类型的，ServletContextAttributeListener、ServletRequestAttributeListener、ServletRequestListener、HttpSessionAttributeListener 和 2 个 LifecycleListeners 类型的，ServletContextListener、HttpSessionListener。如下图所示：</p>
<p>图 13.Servlet 中的 Listener</p>
<p><img src="http://image.winrains.cn/2019/08/7a324-image025.png" alt="http://image.winrains.cn/2019/08/7a324-image025.png"><br>它们基本上涵盖了整个 Servlet 生命周期中，你感兴趣的每种事件。这些 Listener 的实现类可以配置在 web.xml 中的 <listener> 标签中。当然也可以在应用程序中动态添加 Listener，需要注意的是 ServletContextListener 在容器启动之后就不能再添加新的，因为它所监听的事件已经不会再出现。掌握这些 Listener 的使用，能够让我们的程序设计的更加灵活。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文涉及到内容有点多，要把每个细节都说清楚，似乎不可能，本文试着从 Servlet 容器的启动到 Servlet 的初始化，以及 Servlet 的体系结构等这些环节中找出一些重点来讲述，目的是能读者有一个总体的完整的结构图，同时也详细分析了其中的一些难点问题，希望对大家有所帮助。</p>
<h3 id="相关主题"><a href="#相关主题" class="headerlink" title="相关主题"></a>相关主题</h3><ul>
<li>查看文章 <a href="http://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/index.html" target="_blank" rel="noopener"> Tomcat 系统架构与设计模式</a>：了解 Tomcat 中容器的体系结构，基本的工作原理，以及 Tomcat 中使用的经典的设计模式介绍。</li>
<li><a href="http://www.ibm.com/developerworks/cn/education/java/j-intserv/index.html" target="_blank" rel="noopener">Java Servlet 技术简介</a>介绍并解释 servlet 是什么，它们是如何工作的，如何使用它们来创建您能够想像到的任意复杂度的 Web 应用程序，以及作为一名专业编程人员，您如何才能最有效地使用 servlet。</li>
<li>参考 <a href="http://tomcat.apache.org/tomcat-7.0-doc/index.html" target="_blank" rel="noopener">Apache Tomcat</a>官网，了解 Tomcat 最新动态，以及开发人员参考手册。</li>
<li><a href="http://www.oracle.com/technetwork/java/download-139443.html" target="_blank" rel="noopener">Servlet 最新规范</a>，本文是基于 Servlet3.0 规范讲解的，这里有最新的 Servlet 规范，以及 API 的介绍。</li>
<li><a href="http://www.w3.org/Protocols/" target="_blank" rel="noopener">HTTP 协议</a>，W3C 关于 HTTP 协议的详细描述。</li>
<li><a href="http://www.ibm.com/developerworks/cn/web/" target="_blank" rel="noopener">IBM Developer（原 developerWorks）中国 Web development 专区</a>：通过专门关于 Web 技术的文章和教程，扩展您在网站开发方面的技能。</li>
</ul>
<blockquote>
<p>作者：许令波</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-servlet/index.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA、Hibernate、Spring data JPA之间的关系</title>
    <url>/2019/12/26/JPA%E3%80%81Hibernate%E3%80%81Spring-data-JPA%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="什么是JPA？"><a href="#什么是JPA？" class="headerlink" title="什么是JPA？"></a>什么是JPA？</h1><p>全称Java Persistence API，可以通过注解或者XML描述【对象-关系表】之间的映射关系，并将实体对象持久化到数据库中。<br>为我们提供了：<br>1）ORM映射元数据：JPA支持XML和注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中；<br>如：@Entity、@Table、@Column、@Transient等注解。<br>2）JPA 的API：用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发者从繁琐的JDBC和SQL代码中解脱出来。<br>如：entityManager.merge(T t)；<br>3）JPQL查询语言：通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。<br>如：from Student s where s.name = ?<br>但是：<br>JPA仅仅是一种规范，也就是说JPA仅仅定义了一些接口，而接口是需要实现才能工作的。所以底层需要某种实现，而Hibernate就是实现了JPA接口的ORM框架。</p>
<a id="more"></a>

<p>也就是说：<br>JPA是一套ORM规范，Hibernate实现了JPA规范！如图：</p>
<p><img src="http://image.winrains.cn/2019/08/a3eb3-1331009-20180222125641033-1636968052.png" alt="img"></p>
<h1 id="什么是Hibernate框架？"><a href="#什么是Hibernate框架？" class="headerlink" title="什么是Hibernate框架？"></a>什么是Hibernate框架？</h1><p>Hibernate是Java环境的对象关系映射解决方案。对象关系映射或ORM是将应用程序域模型对象映射到关系数据库表的编程技术。Hibernate是一个基于Java的ORM工具，它提供了一个框架，用于将应用程序域对象映射到关系数据库表，反之亦然。<br>Hibernate提供了Java Persistence API的参考实现，使其成为具有松散耦合优势的ORM工具的绝佳选择。请注意，JPA是一个规范，Hibernate是一个JPA提供者或实现。</p>
<h1 id="什么是Spring-Data-JPA？"><a href="#什么是Spring-Data-JPA？" class="headerlink" title="什么是Spring Data JPA？"></a>什么是Spring Data JPA？</h1><p>Spring Data是Spring Framework的一部分。Spring Data存储库抽象的目标是显著减少为各种持久性存储实现数据访问层所需的代码量。<br>Spring Data JPA不是JPA提供者。它是一个库/框架，它在我们的JPA提供程序（如Hibernate）的顶部添加了一个额外的抽象层。<br>现在，您熟悉JPA、Hibernate和Spring Data JPA的定义。现在，让我们讨论Hibernate和Spring Data JPA之间的区别。<br>spirng data jpa是spring提供的一套简化JPA开发的框架，按照约定好的【方法命名规则】写dao层接口，就可以在不写接口实现的情况下，实现对数据库的访问和操作。同时提供了很多除了CRUD之外的功能，如分页、排序、复杂查询等等。<br>Spring Data JPA 可以理解为 JPA 规范的再次封装抽象，底层还是使用了 Hibernate 的 JPA 技术实现。如图：</p>
<p><img src="http://image.winrains.cn/2019/08/213e9-1331009-20180222125651264-1858696834.png" alt="img"></p>
<h1 id="Hibernate和Spring-Data-JPA有什么区别？"><a href="#Hibernate和Spring-Data-JPA有什么区别？" class="headerlink" title="Hibernate和Spring Data JPA有什么区别？"></a>Hibernate和Spring Data JPA有什么区别？</h1><p>Hibernate是一个JPA实现，而Spring Data JPA是一个JPA数据访问抽象。Spring Data提供了GenericDao自定义实现的解决方案，它还可以通过方法名称约定代表您生成JPA查询。<br>通过Spring Data，您可以使用Hibernate、Eclipse Link或任何其他JPA提供程序。一个非常有趣的好处是您可以使用@Transactional注释以声明方式控制事务边界。<br>Spring Data JPA不是一个实现或JPA提供者，它只是一个抽象，用于显著减少为各种持久性存储实现数据访问层所需的代码量。Hibernate提供了Java Persistence API的参考实现，使其成为具有松散耦合优势的ORM工具的绝佳选择。<br>请记住，Spring Data JPA始终需要JPA提供程序，如Hibernate或Eclipse Link。</p>
<blockquote>
<p>作者：离开了编程我会死</p>
<p>参考：<br><a href="https://baijiahao.baidu.com/s?id=1621557449784917999" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1621557449784917999</a><br><a href="https://baijiahao.baidu.com/s?id=1602675844799153392" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1602675844799153392</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring Data JPA</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Spring Data JPA 简化 JPA 开发</title>
    <url>/2019/12/26/%E4%BD%BF%E7%94%A8-Spring-Data-JPA-%E7%AE%80%E5%8C%96-JPA-%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="从一个简单的-JPA-示例开始"><a href="#从一个简单的-JPA-示例开始" class="headerlink" title="从一个简单的 JPA 示例开始"></a>从一个简单的 JPA 示例开始</h2><p>本文主要讲述 Spring Data JPA，但是为了不至于给 JPA 和 Spring 的初学者造成较大的学习曲线，我们首先从 JPA 开始，简单介绍一个 JPA 示例；接着重构该示例，并引入 Spring 框架，这两部分不会涉及过多的篇幅，如果希望能够深入学习 Spring 和 JPA，可以根据本文最后提供的参考资料进一步学习。<br>自 JPA 伴随 Java EE 5 发布以来，受到了各大厂商及开源社区的追捧，各种商用的和开源的 JPA 框架如雨后春笋般出现，为开发者提供了丰富的选择。它一改之前 EJB 2.x 中实体 Bean 笨重且难以使用的形象，充分吸收了在开源社区已经相对成熟的 ORM 思想。另外，它并不依赖于 EJB 容器，可以作为一个独立的持久层技术而存在。目前比较成熟的 JPA 框架主要包括 Jboss 的 Hibernate EntityManager、Oracle 捐献给 Eclipse 社区的 EclipseLink、Apache 的 OpenJPA 等。</p>
<a id="more"></a>

<p>本文的示例代码基于 Hibernate EntityManager 开发，但是读者几乎不用修改任何代码，便可以非常容易地切换到其他 JPA 框架，因为代码中使用到的都是 JPA 规范提供的接口 / 类，并没有使用到框架本身的私有特性。示例主要涉及七个文件，但是很清晰：业务层包含一个接口和一个实现；持久层包含一个接口、一个实现、一个实体类；另外加上一个 JPA 配置文件和一个测试类。相关类 / 接口代码如下：</p>
<p>清单 1. 实体类 AccountInfo.java</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Table</span>(name = <span class="string">"t_accountinfo"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class AccountInfo implements Serializable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">Long</span> <span class="selector-tag">accountId</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">Integer</span> <span class="selector-tag">balance</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 此处省略 getter 和 setter 方法。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>清单 2. 业务层接口 UserService.java</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>UserService &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public AccountInfo createNewAccount(String user, String pwd, Integer init);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>清单 3. 业务层的实现类 UserServiceImpl.java</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> UserServiceImpl implements UserService &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> <span class="constructor">UserDaoImpl()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public AccountInfo create<span class="constructor">NewAccount(String <span class="params">user</span>, String <span class="params">pwd</span>, Integer <span class="params">init</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 封装域对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        AccountInfo accountInfo = <span class="keyword">new</span> <span class="constructor">AccountInfo()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        UserInfo userInfo = <span class="keyword">new</span> <span class="constructor">UserInfo()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        userInfo.set<span class="constructor">Username(<span class="params">username</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        userInfo.set<span class="constructor">Password(<span class="params">password</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        accountInfo.set<span class="constructor">Balance(<span class="params">initBalance</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        accountInfo.set<span class="constructor">UserInfo(<span class="params">userInfo</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 调用持久层，完成数据的保存</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        return userDao.save(accountInfo);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>清单 4. 持久层接口</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>UserDao &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public AccountInfo save(AccountInfo accountInfo);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>清单 5. 持久层的实现类</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="title">implements</span> <span class="title">UserDao</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> AccountInfo <span class="title">save</span><span class="params">(AccountInfo accountInfo)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        EntityManagerFactory emf = Persistence.createEntityManagerFactory(<span class="string">"SimplePU"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        EntityManager em = emf.createEntityManager();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        em.getTransaction().<span class="built_in">begin</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        em.persist(accountInfo);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        em.getTransaction().commit();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        emf.<span class="built_in">close</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> accountInfo;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>清单 6. JPA 标准配置文件 persistence.xml</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&lt;?<span class="type">xml</span> version="1.0" encoding="UTF-8"?&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence" version="2.0"&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;persistence-unit <span class="type">name</span>="SimplePU" <span class="keyword">transaction</span>-<span class="keyword">type</span>="RESOURCE_LOCAL"&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span>&gt;footmark.springdata.jpa.<span class="keyword">domain</span>.UserInfo&lt;/<span class="keyword">class</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span>&gt;footmark.springdata.jpa.<span class="keyword">domain</span>.AccountInfo&lt;/<span class="keyword">class</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;property <span class="type">name</span>="hibernate.connection.driver_class"</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">value</span>="com.mysql.jdbc.Driver"/&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;property <span class="type">name</span>="hibernate.connection.url"</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">value</span>="jdbc:mysql://10.40.74.197:3306/zhangjp"/&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;property <span class="type">name</span>="hibernate.connection.username" <span class="keyword">value</span>="root"/&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;property <span class="type">name</span>="hibernate.connection.password" <span class="keyword">value</span>="root"/&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;property <span class="type">name</span>="hibernate.dialect"</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">value</span>="org.hibernate.dialect.MySQL5Dialect"/&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;property <span class="type">name</span>="hibernate.show_sql" <span class="keyword">value</span>="true"/&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;property <span class="type">name</span>="hibernate.format_sql" <span class="keyword">value</span>="true"/&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;property <span class="type">name</span>="hibernate.use_sql_comments" <span class="keyword">value</span>="false"/&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;property <span class="type">name</span>="hibernate.hbm2ddl.auto" <span class="keyword">value</span>="update"/&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;/properties&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;/persistence-unit&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;/persistence&gt;</span></pre></td></tr></table></figure>

<p>清单 7. 本文使用如下的 main 方法进行开发者测试</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSpringJpaDemo</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">new</span> UserServiceImpl().createNewAccount(<span class="string">"ZhangJianPing"</span>, <span class="string">"123456"</span>, <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="简述-Spring-框架对-JPA-的支持"><a href="#简述-Spring-框架对-JPA-的支持" class="headerlink" title="简述 Spring 框架对 JPA 的支持"></a>简述 Spring 框架对 JPA 的支持</h2><p>接下来我们引入 Spring，以展示 Spring 框架对 JPA 的支持。业务层接口 UserService 保持不变，UserServiceImpl 中增加了三个注解，以让 Spring 完成依赖注入，因此不再需要使用 new 操作符创建 UserDaoImpl 对象了。同时我们还使用了 Spring 的声明式事务：</p>
<p>清单 8. 配置为 Spring Bean 的业务层实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"userService"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> UserDao userDao;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Transactional</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> AccountInfo <span class="title">createNewAccount</span><span class="params">(String name, String pwd, Integer init)</span> </span>&#123; …… &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>对于持久层，UserDao 接口也不需要修改，只需修改 UserDaoImpl 实现，修改后的代码如下：</p>
<p>清单 9. 配置为 Spring Bean 的持久层实现</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span>(<span class="string">"userDao"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@PersistenceContext</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> EntityManager em;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Transactional</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="function">Long <span class="title">save</span><span class="params">(AccountInfo accountInfo)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        em.persist(accountInfo);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">return</span> accountInfo.<span class="title">getAccountId</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>清单 10. Spring 配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">beans...</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"footmark.springdata.jpa"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"> <span class="attr">class</span>=<span class="string">"org.springframework.orm.jpa.JpaTransactionManager"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"entityManagerFactory"</span> <span class="attr">ref</span>=<span class="string">"entityManagerFactory"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"entityManagerFactory"</span> <span class="attr">class</span>=</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">"<span class="attr">org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean</span>"&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<p>清单 11. 改造后的基于 Spring 的开发者测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSpringJpaDemo</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ClassPathXmlApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring-demo-cfg.xml"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        UserDao userDao = ctx.getBean(<span class="string">"userDao"</span>, UserDao<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        userDao.createNewAccount(<span class="string">"ZhangJianPing"</span>, <span class="string">"123456"</span>, <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过对比重构前后的代码，可以发现 Spring 对 JPA 的简化已经非常出色了，我们可以大致总结一下 Spring 框架对 JPA 提供的支持主要体现在如下几个方面：</p>
<ul>
<li><p>首先，它使得 JPA 配置变得更加灵活。JPA 规范要求，配置文件必须命名为 persistence.xml，并存在于类路径下的 META-INF 目录中。该文件通常包含了初始化 JPA 引擎所需的全部信息。Spring 提供的 LocalContainerEntityManagerFactoryBean 提供了非常灵活的配置，persistence.xml 中的信息都可以在此以属性注入的方式提供。</p>
</li>
<li><p>其次，Spring 实现了部分在 EJB 容器环境下才具有的功能，比如对 @PersistenceContext、@PersistenceUnit 的容器注入支持。</p>
</li>
<li><p>第三，也是最具意义的，Spring 将 EntityManager 的创建与销毁、事务管理等代码抽取出来，并由其统一管理，开发者不需要关心这些，如前面的代码所示，业务方法中只剩下操作领域对象的代码，事务管理和 EntityManager 创建、销毁的代码都不再需要开发者关心了。</p>
</li>
</ul>
<h2 id="更进一步：Spring-Data-JPA-让一切近乎完美"><a href="#更进一步：Spring-Data-JPA-让一切近乎完美" class="headerlink" title="更进一步：Spring Data JPA 让一切近乎完美"></a>更进一步：Spring Data JPA 让一切近乎完美</h2><p>通过前面的分析可以看出，Spring 对 JPA 的支持已经非常强大，开发者只需关心核心业务逻辑的实现代码，无需过多关注 EntityManager 的创建、事务处理等 JPA 相关的处理，这基本上也是作为一个开发框架而言所能做到的极限了。然而，Spring 开发小组并没有止步，他们再接再厉，于最近推出了 Spring Data JPA 框架，主要针对的就是 Spring 唯一没有简化到的业务逻辑代码，至此，开发者连仅剩的实现持久层业务逻辑的工作都省了，唯一要做的，就只是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！<br>至此，读者可能会存在一个疑问，框架怎么可能代替开发者实现业务逻辑呢？毕竟，每一个应用的持久层业务甚至领域对象都不尽相同，框架是怎么做到的呢？其实这背后的思想并不复杂，比如，当你看到 UserDao.findUserById() 这样一个方法声明，大致应该能判断出这是根据给定条件的 ID 查询出满足条件的 User 对象。Spring Data JPA 做的便是规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。<br>接下来我们针对前面的例子进行改造，让 Spring Data JPA 来帮助我们完成业务逻辑。在着手写代码之前，开发者需要先 <a href="http://s3.amazonaws.com/dist.springframework.org/release/DATAJPA/spring-data-jpa-1.0.1.RELEASE.zip" target="_blank" rel="noopener">下载</a>Spring Data JPA 的发布包（需要同时下载 Spring Data Commons 和 Spring Data JPA 两个发布包，Commons 是 Spring Data 的公共基础包），并把相关的依赖 JAR 文件加入到 CLASSPATH 中。<br>首先，让持久层接口 UserDao 继承 Repository 接口。该接口使用了泛型，需要为其提供两个类型：第一个为该接口处理的域对象类型，第二个为该域对象的主键类型。修改后的 UserDao 如下：</p>
<p>清单 12. Spring Data JPA 风格的持久层接口</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>UserDao extends Repository&lt;AccountInfo, Long&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   public AccountInfo save(AccountInfo accountInfo);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后删除 UserDaoImpl 类，因为我们前面说过，框架会为我们完成业务逻辑。最后，我们需要在 Spring 配置文件中增加如下配置，以使 Spring 识别出需要为其实现的持久层接口：</p>
<p>清单 13. 在 Spring 配置文件中启用扫描并自动创建代理的功能</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="comment">-- 需要在 &lt;beans&gt; 标签中增加对 jpa 命名空间的引用 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;jpa:repositories base-package=<span class="string">"footmark.springdata.jpa.dao"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     entity-manager-factory-<span class="keyword">ref</span>=<span class="string">"entityManagerFactory"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">transaction</span>-manager-<span class="keyword">ref</span>=<span class="string">"transactionManager"</span>/&gt;</span></pre></td></tr></table></figure>

<p>至此便大功告成了！执行一下测试代码，然后看一下数据库，新的数据已经如我们预期的添加到表中了。如果要再增加新的持久层业务，比如希望查询出给 ID 的 AccountInfo 对象，该怎么办呢？很简单，在 UserDao 接口中增加一行代码即可：</p>
<p>清单 14. 修改后的持久层接口，增加一个方法声明</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">UserDao</span> <span class="symbol">extends</span> <span class="symbol">Repository</span>&lt;<span class="symbol">AccountInfo</span>, <span class="symbol">Long</span>&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> AccountInfo save(AccountInfo accountInfo);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 你需要做的，仅仅是新增如下一行方法声明</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> AccountInfo findByAccountId(Long accountId);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>下面总结一下使用 Spring Data JPA 进行持久层开发大致需要的三个步骤：</p>
<ol>
<li>声明持久层的接口，该接口继承 Repository，Repository 是一个标记型接口，它不包含任何方法，当然如果有需要，Spring Data 也提供了若干 Repository 子接口，其中定义了一些常用的增删改查，以及分页相关的方法。</li>
<li>在接口中声明需要的业务方法。Spring Data 将根据给定的策略（具体策略稍后讲解）来为其生成实现代码。</li>
<li>在 Spring 配置文件中增加一行声明，让 Spring 为声明的接口创建代理对象。配置了 <a href="jpa:repositories" target="_blank" rel="noopener">jpa:repositories</a> 后，Spring 初始化容器时将会扫描 base-package 指定的包目录及其子目录，为继承 Repository 或其子接口的接口创建代理对象，并将代理对象注册为 Spring Bean，业务层便可以通过 Spring 自动封装的特性来直接使用该对象。</li>
</ol>
<p>此外，<a href="jpa:repository" target="_blank" rel="noopener">jpa:repository</a> 还提供了一些属性和子标签，便于做更细粒度的控制。可以在 <a href="jpa:repository" target="_blank" rel="noopener">jpa:repository</a> 内部使用 <a href="context:include-filter" target="_blank" rel="noopener">context:include-filter</a>、<a href="context:exclude-filter" target="_blank" rel="noopener">context:exclude-filter</a> 来过滤掉一些不希望被扫描到的接口。具体的使用方法见 <a href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-classpath-scanning" target="_blank" rel="noopener">Spring</a><a href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-classpath-scanning" target="_blank" rel="noopener">参考文档</a>。</p>
<h3 id="应该继承哪个接口？"><a href="#应该继承哪个接口？" class="headerlink" title="应该继承哪个接口？"></a>应该继承哪个接口？</h3><p>前面提到，持久层接口继承 Repository 并不是唯一选择。Repository 接口是 Spring Data 的一个核心接口，它不提供任何方法，开发者需要在自己定义的接口中声明需要的方法。与继承 Repository 等价的一种方式，就是在持久层接口上使用 @RepositoryDefinition 注解，并为其指定 domainClass 和 idClass 属性。如下两种方式是完全等价的：</p>
<p>清单 15. 两种等价的继承接口方式示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">AccountInfo</span>, <span class="title">Long</span>&gt; </span>&#123; …… &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@RepositoryDefinition</span>(domainClass = AccountInfo<span class="class">.<span class="keyword">class</span>, <span class="title">idClass</span> </span>= Long<span class="class">.<span class="keyword">class</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">UserDao</span> </span>&#123; …… &#125;</span></pre></td></tr></table></figure>

<p>如果持久层接口较多，且每一个接口都需要声明相似的增删改查方法，直接继承 Repository 就显得有些啰嗦，这时可以继承 CrudRepository，它会自动为域对象创建增删改查方法，供业务层直接使用。开发者只是多写了 “Crud” 四个字母，即刻便为域对象提供了开箱即用的十个增删改查方法。<br>但是，使用 CrudRepository 也有副作用，它可能暴露了你不希望暴露给业务层的方法。比如某些接口你只希望提供增加的操作而不希望提供删除的方法。针对这种情况，开发者只能退回到 Repository 接口，然后到 CrudRepository 中把希望保留的方法声明复制到自定义的接口中即可。<br>分页查询和排序是持久层常用的功能，Spring Data 为此提供了 PagingAndSortingRepository 接口，它继承自 CrudRepository 接口，在 CrudRepository 基础上新增了两个与分页有关的方法。但是，我们很少会将自定义的持久层接口直接继承自 PagingAndSortingRepository，而是在继承 Repository 或 CrudRepository 的基础上，在自己声明的方法参数列表最后增加一个 Pageable 或 Sort 类型的参数，用于指定分页或排序信息即可，这比直接使用 PagingAndSortingRepository 提供了更大的灵活性。<br>JpaRepository 是继承自 PagingAndSortingRepository 的针对 JPA 技术提供的接口，它在父接口的基础上，提供了其他一些方法，比如 flush()，saveAndFlush()，deleteInBatch() 等。如果有这样的需求，则可以继承该接口。<br>上述四个接口，开发者到底该如何选择？其实依据很简单，根据具体的业务需求，选择其中之一。笔者建议在通常情况下优先选择 Repository 接口。因为 Repository 接口已经能满足日常需求，其他接口能做到的在 Repository 中也能做到，彼此之间并不存在功能强弱的问题。只是 Repository 需要显示声明需要的方法，而其他则可能已经提供了相关的方法，不需要再显式声明，但如果对 Spring Data JPA 不熟悉，别人在检视代码或者接手相关代码时会有疑惑，他们不明白为什么明明在持久层接口中声明了三个方法，而在业务层使用该接口时，却发现有七八个方法可用，从这个角度而言，应该优先考虑使用 Repository 接口。<br>前面提到，Spring Data JPA 在后台为持久层接口创建代理对象时，会解析方法名字，并实现相应的功能。除了通过方法名字以外，它还可以通过如下两种方式指定查询语句：</p>
<ol>
<li>Spring Data JPA 可以访问 JPA 命名查询语句。开发者只需要在定义命名查询语句时，为其指定一个符合给定格式的名字，Spring Data JPA 便会在创建代理对象时，使用该命名查询语句来实现其功能。</li>
<li>开发者还可以直接在声明的方法上面使用 @Query 注解，并提供一个查询语句作为参数，Spring Data JPA 在创建代理对象时，便以提供的查询语句来实现其功能。</li>
</ol>
<p>下面我们分别讲述三种创建查询的方式。</p>
<h3 id="通过解析方法名创建查询"><a href="#通过解析方法名创建查询" class="headerlink" title="通过解析方法名创建查询"></a>通过解析方法名创建查询</h3><p>通过前面的例子，读者基本上对解析方法名创建查询的方式有了一个大致的了解，这也是 Spring Data JPA 吸引开发者的一个很重要的因素。该功能其实并非 Spring Data JPA 首创，而是源自一个开源的 JPA 框架 Hades，该框架的作者 Oliver Gierke 本身又是 Spring Data JPA 项目的 Leader，所以把 Hades 的优势引入到 Spring Data JPA 也就是顺理成章的了。<br>框架在进行方法名解析时，会先把方法名多余的前缀截取掉，比如 find、findBy、read、readBy、get、getBy，然后对剩下部分进行解析。并且如果方法的最后一个参数是 Sort 或者 Pageable 类型，也会提取相关的信息，以便按规则进行排序或者分页查询。<br>在创建查询时，我们通过在方法名中使用属性名称来表达，比如 findByUserAddressZip ()。框架在解析该方法时，首先剔除 findBy，然后对剩下的属性进行解析，详细规则如下（此处假设该方法针对的域对象为 AccountInfo 类型）：</p>
<ul>
<li>先判断 userAddressZip （根据 POJO 规范，首字母变为小写，下同）是否为 AccountInfo 的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，继续第二步；</li>
<li>从右往左截取第一个大写字母开头的字符串（此处为 Zip），然后检查剩下的字符串是否为 AccountInfo 的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，则重复第二步，继续从右往左截取；最后假设 user 为 AccountInfo 的一个属性；</li>
<li>接着处理剩下部分（ AddressZip ），先判断 user 所对应的类型是否有 addressZip 属性，如果有，则表示该方法最终是根据 “AccountInfo.user.addressZip” 的取值进行查询；否则继续按照步骤 2 的规则从右往左截取，最终表示根据 “AccountInfo.user.address.zip” 的值进行查询。</li>
</ul>
<p>可能会存在一种特殊情况，比如 AccountInfo 包含一个 user 的属性，也有一个 userAddress 属性，此时会存在混淆。读者可以明确在属性之间加上 “_” 以显式表达意图，比如 “findByUser_AddressZip()” 或者 “findByUserAddress_Zip()”。<br>在查询时，通常需要同时根据多个属性进行查询，且查询的条件也格式各样（大于某个值、在某个范围等等），Spring Data JPA 为此提供了一些表达条件查询的关键字，大致如下：</p>
<ul>
<li>And — 等价于 SQL 中的 and 关键字，比如 findByUsernameAndPassword(String user, Striang pwd)；</li>
<li>Or — 等价于 SQL 中的 or 关键字，比如 findByUsernameOrAddress(String user, String addr)；</li>
<li>Between — 等价于 SQL 中的 between 关键字，比如 findBySalaryBetween(int max, int min)；</li>
<li>LessThan — 等价于 SQL 中的 “&lt;”，比如 findBySalaryLessThan(int max)；</li>
<li>GreaterThan — 等价于 SQL 中的”&gt;”，比如 findBySalaryGreaterThan(int min)；</li>
<li>IsNull — 等价于 SQL 中的 “is null”，比如 findByUsernameIsNull()；</li>
<li>IsNotNull — 等价于 SQL 中的 “is not null”，比如 findByUsernameIsNotNull()；</li>
<li>NotNull — 与 IsNotNull 等价；</li>
<li>Like — 等价于 SQL 中的 “like”，比如 findByUsernameLike(String user)；</li>
<li>NotLike — 等价于 SQL 中的 “not like”，比如 findByUsernameNotLike(String user)；</li>
<li>OrderBy — 等价于 SQL 中的 “order by”，比如 findByUsernameOrderBySalaryAsc(String user)；</li>
<li>Not — 等价于 SQL 中的 “！ =”，比如 findByUsernameNot(String user)；</li>
<li>In — 等价于 SQL 中的 “in”，比如 findByUsernameIn(Collection<String> userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数；</li>
<li>NotIn — 等价于 SQL 中的 “not in”，比如 findByUsernameNotIn(Collection<String> userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数；</li>
</ul>
<h3 id="使用-Query-创建查询"><a href="#使用-Query-创建查询" class="headerlink" title="使用 @Query 创建查询"></a>使用 @Query 创建查询</h3><p>@Query 注解的使用非常简单，只需在声明的方法上面标注该注解，同时提供一个 JP QL 查询语句即可，如下所示：</p>
<p>清单 16. 使用 @Query 提供自定义查询语句示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">AccountInfo</span>, <span class="title">Long</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Query</span>(<span class="string">"select a from AccountInfo a where a.accountId = ?1"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> AccountInfo <span class="title">findByAccountId</span><span class="params">(Long accountId)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Query</span>(<span class="string">"select a from AccountInfo a where a.balance &gt; ?1"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Page&lt;AccountInfo&gt; <span class="title">findByBalanceGreaterThan</span><span class="params">(Integer balance, Pageable pageable)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>很多开发者在创建 JP QL 时喜欢使用命名参数来代替位置编号，@Query 也对此提供了支持。JP QL 语句中通过”: 变量”的格式来指定参数，同时在方法的参数前面使用 @Param 将方法参数与 JP QL 中的命名参数对应，示例如下：</p>
<p>清单 17. @Query 支持命名参数示例</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="title">extends</span> <span class="title">Repository</span>&lt;<span class="type">AccountInfo, Long</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> AccountInfo save(AccountInfo accountInfo);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Query(<span class="meta-string">"from AccountInfo a where a.accountId = :id"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> AccountInfo findByAccountId(<span class="meta">@Param(<span class="meta-string">"id"</span>)</span> <span class="built_in">Long</span> accountId);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Query(<span class="meta-string">"from AccountInfo a where a.balance &gt; :balance"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> Page&lt;AccountInfo&gt; findByBalanceGreaterThan(<span class="meta">@Param(<span class="meta-string">"balance"</span>)</span> Integer balance, Pageable pageable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>此外，开发者也可以通过使用 @Query 来执行一个更新操作，为此，我们需要在使用 @Query 的同时，用 @Modifying 来将该操作标识为修改查询，这样框架最终会生成一个更新的操作，而非查询。如下所示：</p>
<p>清单 18. 使用 @Modifying 将查询标识为修改查询</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Modifying</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Query</span>(<span class="string">"update AccountInfo a set a.salary = ?1 where a.salary &lt; ?2"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public int increaseSalary(int after, int before);</span></pre></td></tr></table></figure>

<h3 id="通过调用-JPA-命名查询语句创建查询"><a href="#通过调用-JPA-命名查询语句创建查询" class="headerlink" title="通过调用 JPA 命名查询语句创建查询"></a>通过调用 JPA 命名查询语句创建查询</h3><p>命名查询是 JPA 提供的一种将查询语句从方法体中独立出来，以供多个方法共用的功能。Spring Data JPA 对命名查询也提供了很好的支持。用户只需要按照 JPA 规范在 orm.xml 文件或者在代码中使用 @NamedQuery（或 @NamedNativeQuery）定义好查询语句，唯一要做的就是为该语句命名时，需要满足”DomainClass.methodName()”的命名规则。假设定义了如下接口：</p>
<p>清单 19. 使用 JPA 命名查询时，声明接口及方法时不需要什么特殊处理</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>UserDao extends Repository&lt;AccountInfo, Long&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public List&lt;AccountInfo&gt; findTop5();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如果希望为 findTop5() 创建命名查询，并与之关联，我们只需要在适当的位置定义命名查询语句，并将其命名为 “AccountInfo.findTop5”，框架在创建代理类的过程中，解析到该方法时，优先查找名为 “AccountInfo.findTop5” 的命名查询定义，如果没有找到，则尝试解析方法名，根据方法名字创建查询。</p>
<h3 id="创建查询的顺序"><a href="#创建查询的顺序" class="headerlink" title="创建查询的顺序"></a>创建查询的顺序</h3><p>Spring Data JPA 在为接口创建代理对象时，如果发现同时存在多种上述情况可用，它该优先采用哪种策略呢？为此，<a href="jpa:repositories" target="_blank" rel="noopener">jpa:repositories</a> 提供了 query-lookup-strategy 属性，用以指定查找的顺序。它有如下三个取值：</p>
<ul>
<li>create — 通过解析方法名字来创建查询。即使有符合的命名查询，或者方法通过 @Query 指定的查询语句，都将会被忽略。</li>
<li>create-if-not-found — 如果方法通过 @Query 指定了查询语句，则使用该语句实现查询；如果没有，则查找是否定义了符合条件的命名查询，如果找到，则使用该命名查询；如果两者都没有找到，则通过解析方法名字来创建查询。这是 query-lookup-strategy 属性的默认值。</li>
<li>use-declared-query — 如果方法通过 @Query 指定了查询语句，则使用该语句实现查询；如果没有，则查找是否定义了符合条件的命名查询，如果找到，则使用该命名查询；如果两者都没有找到，则抛出异常。</li>
</ul>
<h3 id="Spring-Data-JPA-对事务的支持"><a href="#Spring-Data-JPA-对事务的支持" class="headerlink" title="Spring Data JPA 对事务的支持"></a>Spring Data JPA 对事务的支持</h3><p>默认情况下，Spring Data JPA 实现的方法都是使用事务的。针对查询类型的方法，其等价于 @Transactional(readOnly=true)；增删改类型的方法，等价于 @Transactional。可以看出，除了将查询的方法设为只读事务外，其他事务属性均采用默认值。<br>如果用户觉得有必要，可以在接口方法上使用 @Transactional 显式指定事务属性，该值覆盖 Spring Data JPA 提供的默认值。同时，开发者也可以在业务层方法上使用 @Transactional 指定事务属性，这主要针对一个业务层方法多次调用持久层方法的情况。持久层的事务会根据设置的事务传播行为来决定是挂起业务层事务还是加入业务层的事务。具体 @Transactional 的使用，请参考 <a href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/transaction.html#transaction-declarative-annotations" target="_blank" rel="noopener">Spring</a><a href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/transaction.html#transaction-declarative-annotations" target="_blank" rel="noopener">的参考文档</a>。</p>
<h3 id="为接口中的部分方法提供自定义实现"><a href="#为接口中的部分方法提供自定义实现" class="headerlink" title="为接口中的部分方法提供自定义实现"></a>为接口中的部分方法提供自定义实现</h3><p>有些时候，开发者可能需要在某些方法中做一些特殊的处理，此时自动生成的代理对象不能完全满足要求。为了享受 Spring Data JPA 带给我们的便利，同时又能够为部分方法提供自定义实现，我们可以采用如下的方法：</p>
<ul>
<li>将需要开发者手动实现的方法从持久层接口（假设为 AccountDao ）中抽取出来，独立成一个新的接口（假设为 AccountDaoPlus ），并让 AccountDao 继承 AccountDaoPlus；</li>
<li>为 AccountDaoPlus 提供自定义实现（假设为 AccountDaoPlusImpl ）；</li>
<li>将 AccountDaoPlusImpl 配置为 Spring Bean；</li>
<li>在 <a href="jpa:repositories" target="_blank" rel="noopener">jpa:repositories</a> 中按清单 19 的方式进行配置。</li>
</ul>
<p>清单 20. 指定自定义实现类</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;jpa:repositories base-package=<span class="string">"footmark.springdata.jpa.dao"</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;jpa:repository <span class="built_in">id</span>=<span class="string">"accountDao"</span> repository-impl-<span class="keyword">ref</span>=<span class="string">" accountDaoPlus "</span> /&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;/jpa:repositories&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">"accountDaoPlus"</span> <span class="built_in">class</span>=<span class="string">"......."</span>/&gt;</span></pre></td></tr></table></figure>

<p>此外，&lt;jpa:repositories &gt; 提供了一个 repository-impl-postfix 属性，用以指定实现类的后缀。假设做了如下配置：</p>
<p>清单 21. 设置自动查找时默认的自定义实现类命名规则</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;jpa:repositories <span class="attribute">base-package</span>=<span class="string">"footmark.springdata.jpa.dao"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attribute">repository-impl-postfix</span>=<span class="string">"Impl"</span>/&gt;</span></pre></td></tr></table></figure>

<p>则在框架扫描到 AccountDao 接口时，它将尝试在相同的包目录下查找 AccountDaoImpl.java，如果找到，便将其中的实现方法作为最终生成的代理类中相应方法的实现。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文主要介绍了 Spring Data JPA 的使用，以及它与 Spring 框架的无缝集成。Spring Data JPA 其实并不依赖于 Spring 框架，有兴趣的读者可以参考本文最后的”参考资源”进一步学习。</p>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul>
<li>访问 <a href="https://spring.io/projects/spring-data" target="_blank" rel="noopener">Spring Data 主页</a>，了解 Spring Data 框架及其针对不同的持久化技术提供的支持，这里也提供了丰富的学习文档，并且可以下载最新的 Spring Data JPA 发布版。</li>
<li>参与 <a href="https://spring.io/blog/2019/02/06/legacy-forums-will-be-shutdown-february-28" target="_blank" rel="noopener">Spring Data 论坛</a>，在这里，你可以与世界各地的开发者交流，你提出的问题也会在第一时间得到解答。</li>
<li>Spring Data JPA 的项目负责人写的 <a href="http://blog.springsource.com/2011/02/10/getting-started-with-spring-data-jpa/" target="_blank" rel="noopener">一篇指导开发者入门的文章</a>。可以把它作为学习 Spring Data JPA 框架的一个起点。</li>
<li>下载 <a href="http://www.springsource.com/products/eclipse-downloads" target="_blank" rel="noopener">SpringSource Tool Suite</a>，这是 SpringSource 提供的一款基于 Eclipse 的免费 IDE，为开发 Spring 应用提供了强大的支持。</li>
</ul>
<h2 id="下载资源"><a href="#下载资源" class="headerlink" title="下载资源"></a>下载资源</h2><ul>
<li><a href="http://www.ibm.com/developerworks/apps/download/index.jsp?contentid=799597&filename=sample-code.rar&method=http&locale=zh_CN" target="_blank" rel="noopener">样例代码</a> (sample-code.rar | 5KB)</li>
</ul>
<blockquote>
<p>作者：张建平</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-spring-jpa/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-cn-spring-jpa/index.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring Data JPA</category>
      </categories>
  </entry>
  <entry>
    <title>常见乱码问题分析和总结</title>
    <url>/2019/12/26/%E5%B8%B8%E8%A7%81%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%92%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>在我们的日常工作生活中一定碰到过下面的情况：<br><strong>场**</strong>景 1**： 安装完某个软件后，看到的安装程序变成类似这样的一组字符” µç×ÓË°Îñ¾ÖÖ¤ÊéÇý¶¯¼°·þÎñÆ½Ì¨”图 1 所示的样子；</p>
<p>图 1. 安装程序中的乱码</p>
<p><img src="http://image.winrains.cn/2019/08/583d4-image001.png" alt="img"></p>
<a id="more"></a>

<p>场<strong>**景 2</strong>：打开一个文档发现里面的内容全面是问号？？？？？？如图 2 所示；</p>
<p>图 2. 带有问号的乱码</p>
<p><img src="http://image.winrains.cn/2019/08/c7285-image002.png" alt="img"><br><strong>场**</strong>景 3<strong>**：</strong>打开某个网页，却显示成：如”бЇЯАзЪСЯ”、”�????????”？等等；<br><strong>场**</strong>景 4<strong>**：</strong>打开某个文档后，出现§ § § §<strong>。</strong><br>上面例子中看到的就是困扰着我们的乱码。这篇文章基于项目实践，分别从普通用户和编程角度总结了常见的乱码种类，产生原因以及如何解决这些乱码问题。在分析乱码原因和解决办法之前，首先阐述一下和乱码相关的术语。</p>
<h2 id="编码解码概述"><a href="#编码解码概述" class="headerlink" title="编码解码概述"></a>编码解码概述</h2><p>我们都知道计算机不能直接存储字母，数字，图片，符号等，计算机能处理和工作的唯一单位是”比特位（bit）”，一个比特位通常只有 0 和 1，是（yes）和否（no），真（true）或者假（false）等等我们喜欢的称呼。利用比特位序列来代表字母，数字，图片，符号等，我们就需要一个存储规则，不同的比特序列代表不同的字符，这就是所谓的”编码”。反之，将存储在计算机中的比特位序列（或者叫二进制序列）解析显示出来成对应的字母，数字，图片和符号，称为”解码”，如同密码学中的加密和解密，下面将详细解释编码解码过程中涉及到的一些术语：<br><strong>字符集合（</strong>Character set<strong>）：</strong>是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等，简单理解就是一个字库，与计算机以及编码无关。<br><strong>字符编码集（</strong>Coded character set<strong>）：</strong>是一组字符对应的编码（即数字），为字符集合中的每一个字符给予一个数字，如 Unicode 为每一个字符分配一个唯一的码点与之一一对应。<br><strong>字符编码（</strong>Character Encoding<strong>）</strong>：简单理解就是一个映射关系，将字符集对应的码点映射为一个个二进制序列，从而使得计算机可以存储和处理。常见的编码方式有 ASCII 编码、ISO-8859-1(不支持中文)、GBK、GB2312（中国编码，支持中文）、UTF-8 等等,详情见表 1。<br><strong>字符集（C</strong>harset<strong>）：</strong>包括编码字符集和字符编码，如 ASCII 字符集、ISO-8859-X、GB2312 字符集（简中）、BIG5 字符集（繁中）、GB18030 字符集、Shift-JIS 等，即下文中提到的字符集。</p>
<p>表 1. 常见字符集和对应编码方式</p>
<table>
<thead>
<tr>
<th><strong>字符集</strong></th>
<th><strong>编码</strong></th>
<th><strong>详解</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>ASCII</td>
<td>ASCII 编码</td>
<td><strong>ASCII字符集：</strong>主要包括控制字符（回车键、退格、换行键等）；可显示字符（英文大小写字符、阿拉伯数字和西文符号。  <strong>ASCII 编码：</strong>用一个字节的低 7 位表示，0<del>31 是控制字符如换行回车删除等；32</del>126 是打印字符；ASCII的最大缺点是只能解决了部份西欧语言的显示问题，但对更多其他语言依然无能为力。</td>
<td></td>
</tr>
<tr>
<td>I 字 ISO-8859-X （常用的 ISO-8859-1）</td>
<td>ISO-8859-1 编码 ISO-8859-2 编码 … ISO-8859-15 编码</td>
<td><strong>ISO-8859-X 字符集</strong>：扩展的 ASCII 字符集，包括 ISO-8859-1 ~ ISO-8859-15，涵盖了大多数西欧语言字符和希腊语。 <strong>ISO-8859-1 编码</strong>：用 8 位表示一个字符，总共能表示 256 个字符，但还是单字节编码，不能对双字节如中日韩等进行编码。</td>
<td></td>
</tr>
<tr>
<td>GBXXXX</td>
<td>GB2312 编码</td>
<td><strong>GB2312 编码</strong> ：它的全称是《信息交换用汉字编码字符集 基本集》，它是双字节编码，每个汉字及符号以两个字节来表示。第一个字节称为”高位字节”（也称”区字节）”，第二个字节称为”低位字节”（也称”位字节”）。 总的编码范围是 A1-F7，其中从 A1-A9 是符号区，总共包含 682 个符号，从 B0-F7 是汉字区，它所收录的汉字已经覆盖中国大陆 99.75%的使用频率。对于<a href="http://zh.wikipedia.org/wiki/人名" target="_blank" rel="noopener">人名</a>、<a href="http://zh.wikipedia.org/wiki/古汉语" target="_blank" rel="noopener">古汉语</a>等方面出现的<a href="http://zh.wikipedia.org/wiki/罕用字" target="_blank" rel="noopener">罕用字</a>，GB2312 不能处理，这导致了后来<a href="http://zh.wikipedia.org/wiki/GBK" target="_blank" rel="noopener">GBK</a>及<a href="http://zh.wikipedia.org/wiki/GB_18030" target="_blank" rel="noopener">GB 18030</a>汉字字符集的出现。</td>
<td></td>
</tr>
<tr>
<td></td>
<td>GBK 编码</td>
<td><strong>GBK 编码</strong>： 全称叫《汉字内码扩展规范》，是在 GB2312-80 标准基础上的内码扩展规范，使用了双字节编码方案，其编码范围从 8140 至 FEFE（剔除 xx7F），共 23940 个码位，共收录了 21003 个汉字，完全兼容 GB2312-80 标准，支持国际标准 ISO/IEC10646-1 和国家标准 GB13000-1 中的全部中日韩汉字，并包含了 BIG5 编码中的所有汉字。</td>
<td></td>
</tr>
<tr>
<td></td>
<td>GB18030 编码</td>
<td><strong>GB18030-2005</strong>《信息技术中文编码字符集》是我国自主研制的以汉字为主并包含多种我国少数民族文字（如藏、蒙古、傣、彝、朝鲜、维吾尔文等）的超大型中文编码字符集强制性标准，其中收入汉字 70000 余个，解决了中文、日文、朝鲜语等的编码，兼容 GBK。 采用变长字节表示即单<a href="https://baike.baidu.com/item/字节" target="_blank" rel="noopener">字节</a>、双字节和四字节三种方式对<a href="https://baike.baidu.com/item/字符编码" target="_blank" rel="noopener">字符编码</a>。可表示27484个文字</td>
<td></td>
</tr>
<tr>
<td>Big5</td>
<td>Big5 编码</td>
<td><strong>Big5 编码</strong>： 适用于台湾、香港地区的一个繁体字编码方案。 使用了双八码存储方法，以两个字节来安放一个字，第一个字节称为”高位字节”，第二个字节称为”低位字节。</td>
<td></td>
</tr>
<tr>
<td>Unicode</td>
<td>UTF-8</td>
<td><strong>UTF-8</strong>：采用变长字节 (1 ASCII, 2 希腊字母, 3 汉字, 4 平面符号) 表示，在网络传输中即使错了一个字节，不影响其他字节；存储效率比较高，适用于拉丁字符较多的场合以节省空间，UTF-8 没有字节顺序问题，所以 UTF-8 适合传输和通信。</td>
<td></td>
</tr>
<tr>
<td></td>
<td>UTF-16</td>
<td><strong>UTF-16</strong>：从先前的固定宽度的 16 位编码（UCS-2）发展而来的，能够对 Unicode 的所有 1,112,064 个有效 code point 进行编码。 其编码方式是可变长度的，因为 code point 是用一个或两个 16 位代码单元编码的。在 UTF-16 文件的开头，会放置一个 U+FEFF 字符作为 Byte Order Mark（BOM）：UTF-16LE（小端序）以 FF FE 代表，UTF-16BE（大端序）以 FE FF 代表，以显示这个文字档案是以 UTF-16 编码。 UTF-16 比起 UTF-8，好处在于大部分字符都以固定长度的字节 (2 字节) 储存，但 UTF-16 却无法兼容于 ASCII 编码，实际使用也比较少。</td>
<td></td>
</tr>
<tr>
<td></td>
<td>UTF-32</td>
<td><strong>UTF-32 (或 UCS-4)</strong>：对每一个 Unicode 码点使用 4 字节进行编码，其它的 Unicode 编码方式则使用不定长度编码。就空间而言，UTF-32 是非常没有效率的。尤其非基本多文种平面的字符在大部分文件中通常很罕见，以致于它们通常被认为不存在占用空间大小的讨论，使得 UTF-32 通常会是其它编码的二到四倍。虽然每一个码位使用固定长定的字节看似方便，它并不如其它 Unicode 编码使用得广泛。</td>
<td></td>
</tr>
</tbody></table>
<p><strong>表**</strong>1 的<strong>**几点说明：</strong></p>
<ul>
<li>GB2312、GBK、UTF-8、UTF-16 这几种格式都可以用来对双字节汉字进行编码，在实际应用中具体选择哪种编码方式，需要根据实际应用场景，当前的应用场景是编码效率重要还是减少存储空间重要。</li>
<li>UTF-16 与 UCS-2 的关系：UTF-16 可看成是 UCS-2 的父集。在没有辅助平面字符（surrogate code points）前，UTF-16 与 UCS-2 所指的是同一的意思。但当引入辅助平面字符后，就称为 UTF-16 了。现在若有软件声称自己支持 UCS-2 编码，那其实是暗指它不能支持在 UTF-16 中超过 2 位元组的字集。对于小于 0x10000 的 UCS 码，UTF-16 编码就等于 UCS 码。</li>
<li>为什么中文默认使用 GB1832 而不使用 UTF-8？因为 GB1832 对绝大多数中文采用双字节编码，而 UTF-8 要用三字节，GB11832 大大节省了存储空间。</li>
</ul>
<p>ANSI 编<strong>码</strong>：各个国家和地区独立制定的既兼容 ASCII 编码又彼此之间不兼容的字符编码，微软统称为 ANSI 编码。在 Windows 系统中，ANSI 编码一般代表系统默认的编码方式，并且不是确定的某一种特定编码方式，比如在英文 Windows 操作系统中，ANSI 指的是 ISO-8859-1；简体中文操作系统中 ANSI 编码默认指的是 GB 系列编码(GB2312、GBK、GB18030)等；在繁体中文操作系统中 ANSI 编码默认指的是 BIG5；在日文操作系统中 ANSI 编码默认指的是 Shift JIS 等等，并且默认的 ANSI 编码可以通过设置系统 Locale 更改。<br><strong>字符解码（C</strong>haracter Decoding<strong>）:</strong> 根据一定规则，将二进制序列映射成对应的正确字符串，即二进制序列–&gt;字符串，个人将其理解为”翻译”。<br>UCS<strong>（</strong>Universal Character Set<strong>）：</strong>称作通用字符集，是由 ISO 制定的 ISO 10646（或称 ISO/IEC 10646）标准所定义的标准字符集。包括了其他所有字符集。它保证了与其他字符集的双向兼容，即，如果你将任何文本字符串翻译到 UCS 格式，然后再翻译回原编码，你不会丢失任何信息。<br>UTF<strong>（</strong>UCS Transformation Format/Unicode transformation format<strong>）</strong>: UCS 转换格式/Unicode 转换格式。<br>BOM<strong>（</strong>Byte Order Mark<strong>）：</strong>字节顺序标记，出现在文本文件头部，Unicode 编码标准中用于标识文件是采用哪种格式的编码，其 Unicode 码点为 U+FEFF。</p>
<ul>
<li>UTF-8 不需要 BOM 来表明字节顺序，但可以用 BOM 来表明编码方式。字符 “零宽无间断间隔” 的 UTF-8 编码是 EF BB BF，如果接收者收到以 EF BB BF 开头的字节流，就知道这是 UTF-8 编码了。</li>
<li>Big-Endian（BE）即大端序，UTF-16(BE)以 FEFF 作为开头字节，UTF-32(BE)以 00 00 FE FF 作为开头字节；</li>
<li>Little-Endian (LE)即小端序，UTF-16(LE)以 FFFE 作为开头字节，UTF-32(LE)以 FF FE 00 00 作为开头字节。</li>
</ul>
<p>BMP<strong>（</strong>Basic Multilingual Plane<strong>）：</strong>称作 Unicode 的基本平面或基本多文种平面。也就是每个字符占用 2 个字节，这样理论上一共最多可以表示 216（即 65536）个字符。<br>Code Point<strong>：</strong>称作码点或码位，是组成编码空间（或代码页）的数值。例如，ASCII 码包含 128 个码点，范围是 0 到 7F（16 进制）；ISO-8859-1 包含 256 个码点，范围是 0 到 FF；而 Unicode 包含 1,114,112 个码点，范围是 0 到 10FFFF。Unicode 码空间划分为 17 个 Unicode 字符平面（基本多文种平面，16 个辅助平面），每个平面有 65,536（= 216）个码点。因此 Unicode 码空间总计是 17 x 65,536 = 1,114,112。<br>Code Page<strong>：</strong>代码页或者内码表，是 IBM 早期称呼计算机的 BIOS 所支持的字符集编码（也称作 OEM 代码页）。Windows 系统在没有使用 UTF-16 之前，为了解决由于不同国家和地区采用的字符集不一致，很可能出现无法正常显示所有字符的问题，使用了代码页（Codepage）转换表的技术来过渡性的部分解决这一问题，即定义了一系列支持不同国家和地区所制定的字符集，被称为 Windows 代码页或 ANSI 代码页，然而代码页一般与其所对应的字符集之间并非完全相同，有时候会对字符集有所扩展，可以理解为一张字符-字节序列映射表，通过查表实现编码解码功能。操作系统中不同 Locale 设置默认使用不同的代码页。<br>Locale<strong>：</strong>是指特定于某个国家或地区的一组设定，包括代码页，以及数字、货币、时间和日期的格式等。在 Windows 内部，有两个 Locale 设置：系统 Locale 和用户 Locale。系统 Locale 决定代码页，用户 Locale 决定数字、货币、时间和日期的格式。</p>
<h2 id="乱码产生原因概述"><a href="#乱码产生原因概述" class="headerlink" title="乱码产生原因概述"></a>乱码产生原因概述</h2><p>乱码产生的根源一般情况下可以归结为三方面即：编码引起的乱码、解码引起的乱码以及缺少某种字体库引起的乱码（这种情况需要用户安装对应的字体库），其中大部分乱码问题是由不合适的解码方式造成的，如图 3 所示的鱼骨图。</p>
<p>图 3. 乱码产生原因</p>
<p><img src="http://image.winrains.cn/2019/08/a0ddd-image003.jpg" alt="img"><br>下面通过几个常见例子，从普通用户角度分别阐述这几种原因导致的乱码表象和解决办法。<br><strong>编码引起的乱码表象分析</strong><br>在英文版 windows 系统（实验使用的是 win7 64 位专业版），新建一个 txt 文件，写上”你好”保存。然后再双击打开，将会看到保存的内容变成了”？？”，如图 4 所示</p>
<p>图 4. 不合适的编码方式引起的乱码</p>
<p><img src="http://image.winrains.cn/2019/08/96dcb-image004.png" alt="img"><br><strong>原因分析：</strong>Windows 默认选用 ANSI 编码，英文版 Windows7 默认的系统 Locale 是 English（United States），对应的 codepage 为 437 即编码方式为 ISO-8859-1。我们用十六进制查看器可以看到”你好”对应的的十六进制数为”3F3F”，这是因为中文和中文符号经过不支持中文的 ISO-8859-1 编码时，将不在字符集范围内的字符统一用 3F 表示，3F 对应的字符为问号”？”，如图 5 所示。<br><strong>解决办法：</strong>这种情况下形成的乱码是不可逆的，也就是说无论用什么解码方式都不能正确显示字符。我们在保存双字节字符的文档时，选择正确的编码方式，比如简中可以选择 GB2312 或者 UTF-8；繁中字符可以选择 BIG5 或者 UTF-8 等；如果安装的是英文操作系统，对于中文用户，可以将系统 Locale 更改为 Chinese(Simplified, PRC)。</p>
<p>图 5. 编码方式引起的乱码剖析</p>
<p><img src="http://image.winrains.cn/2019/08/f1379-image005.jpg" alt="img"><br><strong>解码引起的乱码表象分析</strong><br>在中文版 Windows 系统创建一个 txt 文件，写上”你好，中国”然后保存，再将这个 txt 文件复制到英文版 Windows 系统，双击打开，将会看到保存的内容变成”ÄãºÃ£¬ÖÐ¹ú”。<br><strong>原因分析：</strong>中文版 Windows 系统创建的 txt 文件以默认的 ANSI 编码即 GB2312，当复制到英文版 Windows 系统时，Notepad 默认的解码方式为 ISO-8859-1，如图 6 所示的表象分析。这种情况下产生的乱码是可逆的，只要使用正确的解码方式，就可以正确显示文件中的字符。<br><strong>解决办法：</strong>遇到类似解码问题引起的乱码，可以换一个编辑器打开，同时选择正确的解码方式。</p>
<p>图 6. 不正确的解码方式引起的乱码</p>
<p><img src="http://image.winrains.cn/2019/08/b0b4f-image006.png" alt="img"><br>下面的例子是在英文版 Windows 系统上打开中文版 uedit32.exe 后菜单项全为乱码的现象，如图 7 所示。<br><strong>原因分析：</strong>对于支持 Unicode 的应用程序，Windows 会默认使用 Unicode 编码。对于不支持 Unicode 的应用程序 Windows 会采用 ANSI 编码 （也就是各个国家自己制定的标准编码方式，如对于西欧文字有 ISO/IEC 8859 编码，对于简体中文有 GB2312，对于繁体中文有 BIG-5 等。Uedit32 是不支持 Unicode 的，然后当前实验使用的英文版 Windows 7 默认的 locale 为英语（美国），其默认字符集是 ISO-8859-1，而中文版 uedit32 程序使用的是中文编码方式，使用 ISO-8859-1 解码时肯定出现乱码情况。这个例子的乱码根本原因也是不正确的解码方式造成的。<br><strong>解决办法</strong>：进入系统的控制面板，找到 Regional and Language Options 语言设置项，打开进入对应的页面，将标准与格式中的语言设置为简体中文；同时在 Advanced 标签页中将系统支持的非 Unicode 语言也设置为简体中文，从而在解码的时候就会使用中文自己的 ANSI 编码（实验环境为 GB1832）。</p>
<p>图 7. 解码导致的乱码</p>
<p><img src="http://image.winrains.cn/2019/08/e5474-image007.jpg" alt="img"><br><strong>缺少字体引起的乱码表象分析</strong><br>在英文 Windows 系统打开一个文件发现里面的内容有些显示为方框，如图 8 所示。</p>
<p>图 8. 带有中括号的乱码</p>
<p><img src="http://image.winrains.cn/2019/08/4c4e5-image008.png" alt="img"><br><strong>原因分析：</strong>这个例子中显示为方框的都是中文字符。我们看到屏幕上的字符实际上经历了三种不同形态，从<strong>二进制字节序列</strong>转换成对应字符集中的<strong>码点</strong>，然后码点通过查找字体库找到对应的<strong>字符</strong>，最后通过点阵的方式显示在屏幕上。这里的方框是因为所查找的字体库缺少该码点对应的字符，或者根本没有安装该字体库，从而字符库中找不到的字符都以方框代替。<br><strong>解决办法：</strong>安装对应的字体库，比如 Windows 系统在 C:\Windows\Fonts 目录下会有安装好的字体库列表。安装字体库比较简单，下载后解压，然后复制到对应系统的 Fonts 目录下。这里有个问题就是如何知道缺少何种字体？有些阅读器比如 Adobe 在打开文档时会提示缺少什么字体，但是很多编辑器或者阅读器是不提示的，这个时候可能需要根据经验来判断。</p>
<h2 id="从编程角度分析出现乱码的场景和解决办法"><a href="#从编程角度分析出现乱码的场景和解决办法" class="headerlink" title="从编程角度分析出现乱码的场景和解决办法"></a>从编程角度分析出现乱码的场景和解决办法</h2><p>从编程角度来看，出现乱码的场景主要是有文本处理的时候，比如文件的新建和读取、复制和粘贴，导入和导出，打开和保存，数据存储和检索，显示，打印，分词处理，字符转换，规范化，搜索，整理和发送数据等，文本数据的示例包括平面文件，流文件，数据区域，目录名称，资源名称，用户标识等。图 9 是出现乱码的一个常见场景分类。</p>
<p>图 9. 出现乱码的场景</p>
<p><img src="http://image.winrains.cn/2019/08/d6879-image009.jpg" alt="img"></p>
<h3 id="I-O-操-作中出现乱码情况"><a href="#I-O-操-作中出现乱码情况" class="headerlink" title="I/**O 操**作中出现乱码情况"></a><strong>I/**</strong>O 操<strong>**作中出现乱码情况</strong></h3><p>I/O 操作包括读（输入）写（输出）两方面，而所谓的输入和输出是以程序为中心的，数据流向程序即输入流，数据从程序中流出即输出流。读数据比如将文件中的内容显示出来，即字节–&gt;字符的转换，也就是解码；写数据比如创建一个新文件，即字符–&gt;字节转换，也就是编码；在分析 I/O 操作中出现乱码原因之前，先简要概述一下 Java I/O 操作接口。如图 10 所示：</p>
<p>图 10. Java I/O 接口</p>
<p><img src="http://image.winrains.cn/2019/08/af1b6-image010.png" alt="img"><br>当我们想创建一个文件并且将对应的字符写入文件时将用到字节流 FileOutputStream和字符流 Writer，其流程为图 11 所示：</p>
<p>图 11. 写入文件的 I/O 流</p>
<p><img src="http://image.winrains.cn/2019/08/196e5-image011.jpg" alt="img"><br>Java 中与 I/O 操作相关的 API 一般都有是否指定字符集的重载形式，选择不指定字符集形式的函数时将使用默认字符集。如 String.getBytes()就有两种形式：String.getBytes() 和 String.getBytes(String charsetName)。下面是 String.getBytes()方法的详解。<br>String.getBytes(): Encodes this String into a sequence of bytes using the platform’s default charset, storing the result into a new byte array.<br>这个是 Java 帮助文档提供的解释，这里需要强调一下”The platform’s default charset”即 Charset.defaultCharset()，defaultCharset 由系统属性 file.encoding 决定，如果用户没有设置 JVM 的这个属性，其值依赖于启动该 JVM 的环境编码：比如是由操作系统命令行启动 JVM，则有操作系统的运行时的区域语言设置决定的编码；比如是在 Eclipse 里面启动 JVM，可以设置 JVM 的这个属性，默认情况下 file.encoding 属性由通用设置页面的编码决定。<br>在实际项目中，我们可能直接使用 String.getBytes()进行字符和字节的转换。在笔者的项目中就碰到一个这样的乱码问题，如清单 1 所示，在写入错误日志信息的时候使用了 String.getBytes(),这里没有指定字符集，将使用默认字符集，其值依赖于启动 JVM 的平台环境，结果显示出来的都是问号，结合前文显示问号通常是使用不正确的编码方式造成的。</p>
<p>清单 1. 使用 String.getBytes()出现乱码</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">String</span> fileName = <span class="string">"c:\\log.txt"</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">String</span> str =<span class="string">"你好，中国"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    writeError(str);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeError</span><span class="params">(<span class="keyword">String</span> a_error)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">File</span> logFile = <span class="keyword">new</span> <span class="built_in">File</span>(fileName);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//创建字节流对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        FileOutputStream outPutStream = <span class="keyword">new</span> FileOutputStream(logFile, <span class="literal">true</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//使用平台的默认字符集将此字符串编码为一系列字节</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        outPutStream.<span class="built_in">write</span>(a_error.getBytes(), <span class="number">0</span>, a_error.length() );</span></pre></td></tr><tr><td class="code"><pre><span class="line">        outPutStream.<span class="built_in">flush</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>对于清单 1 中出现的乱码问题即错误的日志全是问号，只要我们指定正确的字符集就可以解决，如清单 2 所示。</p>
<p>清单 2. 使用 outputStreamWrite 指定字符集</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeErrorWithCharSet</span><span class="params">(<span class="keyword">String</span> a_error)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">File</span> logFile = <span class="keyword">new</span> <span class="built_in">File</span>(FileName);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">String</span> charsetName = <span class="string">"utf-8"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//指定字符字节转换时使用的字符集为 Unicode，编码方式为 utf-8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Writer m_write = <span class="keyword">new</span> BufferedWriter(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> java.io.FileOutputStream(logFile, <span class="literal">true</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;strong&gt;charsetName&lt;/strong&gt;) );</span></pre></td></tr><tr><td class="code"><pre><span class="line">        m_write.<span class="built_in">write</span>(a_error);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        m_write.<span class="built_in">close</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>强调</strong>：为了避免乱码问题出现，在调用 I/O 操作相关的 API 时，最好使用带有指定字符集参数的重载形式。</p>
<h3 id="W-eb-程序中出现的乱码情况"><a href="#W-eb-程序中出现的乱码情况" class="headerlink" title="W**eb 程序中出现的乱码情况**"></a><strong>W**</strong>e<strong><strong>b 程</strong></strong>序中出现的乱码情况**</h3><p>在 web 应用程序中，存在用户输入以及输出显示的地方都有可能存在编码解码，图 12 简要概括了 HTTP web 请求响应环节。</p>
<p>图 12. Web 请求响应环节中的编码解码</p>
<p><img src="http://image.winrains.cn/2019/08/27e99-image012.jpg" alt="img"><br>下面是对图 12 的几点说明：</p>
<ul>
<li>Web 应用程序中出现乱码的可能原因有：浏览器本身没有遵循 URI 编码规范；服务器端没有正确配置编码解码；开发人员对 Web 程序中涉及到的编码解码理解不太深入。</li>
<li>HTTP Get 请<strong>求方式中的编码解码规则</strong>：Get 请求方式中请求参数会被附加到地址栏的 URL 之后，URL 组成：”域名:端口/contextPath/servletPath/pathInfo?queryString”，URL 中 pathInfo 和 queryString 如果含有中文等非 ASCII 字符，则浏览器会对它们进行 URLEncode，编码成为 16 进制，然后从右到左，取 4 位(不足 4 位直接处理)，每 2 位做一位，前面加上%，编码成%XY 格式。然而 URL 中的 PathInfo 和 QueryString 字符串的编码和解码是由浏览器和应用服务器的配置决定，在我们的程序中是不能设定的。即使同一浏览器对 pathInfo 和 queryString 的编码方式有可能不一样，因为浏览器对 URL 的编码格式是可设置的，这就对服务器的解码造成很大的困难。应用服务器端对 Get 请求方式解码中 pathInfo 和 queryString 的设定是不同的。比如 Tomcat 服务器一般在 server.xml 中设定的，pathInfo 部分进行解码的字符集是在 connector 的 <Connector URIEncoding="UTF-8"/> 中定义的；QueryString 的解码字符集一般通过 useBodyEncodingForURI 设定，如果没有设定，Tomcat8 之前的版本默认使用的是 ISO-8859-1，但是 Tomcat 8 默认使用的是 UTF-8。为了避免浏览器采用了我们不希望的编码，在我们的程序中最好不要在 URL 中直接使用非 ASCII 字符，而是对双字节字符进行 URI 编码后在放到 URL 中，<a href="http://lib.csdn.net/base/18" target="_blank" rel="noopener">JavaScript</a>§提供了 encodeURI()函数，它提供的是 UTF-8 的 URI 编码，也可以通过 java.net.URLEncoder.encode(str,”字符集”)进行编码。</li>
<li><strong>HTTP Pos**</strong>t 请<strong>**求方式中的编码解码</strong>：请求表单中的参数值是通过 request 包发送给服务器，此时浏览器会根据网页的 ContentType(“text/html; charset=utf-8”)中指定的编码进行对表单中的数据进行编码，然后发给服务器；JSP 中 contentType 设定&lt;%@ page language=”java” contentType=”text/html; charset=”GB18030” pageEncoding=”UTF-8”%&gt;，JSP 页面命令中的 charset 的作用包括通知浏览器应该用什么编码方式解码显示网页；提交表单时浏览器会按 charset 指定的字符集编码数据（post body）发送给服务器；pageEncoding 属性里指定的编码方式是储存该 jsp 文件时所用的编码，比如 eclipse 的文本编辑器可以根据该属性决定储存该文件时采用的编码方式；服务器端通过 Request.setCharacterEncoding() 设置编码，然后通过 request.getParameter 获得正确的数据。图 13 是 POST 请求中没有设置 ContentType 出现的乱码的例子及解决办法如清单 3 所示。</li>
</ul>
<p>图 13. POST 请求中出现乱码</p>
<p><img src="http://image.winrains.cn/2019/08/c39d6-image013.jpg" alt="img"></p>
<p>清单 3. POST 请求设置 setContentType</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">protected void doPost(HttpServletRequest request, HttpServletResponse</span></pre></td></tr><tr><td class="code"><pre><span class="line">response) throws ServletException, IOException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(!ServletFileUpload.isMultipartContent(request))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw new ServletException(<span class="string">"Content type is not multipart/form-data"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    response.setCharacterEncoding(<span class="string">"UTF-8"</span>);//设置响应编码</span></pre></td></tr><tr><td class="code"><pre><span class="line">    response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    PrintWriter out = response.getWriter();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    out.write(<span class="string">"&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List<span class="xml"><span class="tag">&lt;<span class="name">FileItem</span>&gt;</span> items = (List</span><span class="xml"><span class="tag">&lt;<span class="name">FileItem</span>&gt;</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        uploader.parseRequest(request);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        …</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">//JSP 代码片段，使用 POST 请求方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=utf-8"</span> <span class="attr">pageEncoding</span>=<span class="string">"utf-8"</span>%&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>index<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"pragma"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"cache-control"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"expires"</span> <span class="attr">content</span>=<span class="string">"0"</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"FileUploadServlet"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">选择上传文件：</span><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"fileName"</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传"</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span></pre></td></tr></table></figure>

<ul>
<li><p><strong>浏览器显示</strong>：通常有 JSP 和 HTML 来展示，通过实验发现，对于网页中的静态内容，不同浏览器显示网页所使用的字符集原则是不一样的，Chrome 63 和 IE11 使用 JSP 页面命令中 contentType 和 charset 设置，html 页面中的 charset 设置，然而 firefox 52 却根据自己的 text encoding 方式来显示页面。</p>
</li>
<li><p><strong>对**</strong>于 J<strong>SP</strong>：**通过 JSP 页面命令&lt;%@ page language=”java” contentType=”text/html; charset=utf-8” pageEncoding=”utf-8”%&gt;中的 contentType 属性和 pageEncoding 属性设置。在 JSP 标准的语法中，如果 pageEncoding 属性存在，储存该 jsp 文件时所用的编码由该属性决定，如果没有指定 pageEncoding 属性，那么存储该 jsp 文件的编码就由 contentType 属性中的 charset 决定，如果 charset 也不存在，JSP 页面的字符编码方式就采用默认的 ISO-8859-1；charset 的作用包括通知浏览器应该用什么编码方式解码显示网页，如果没有指定 charset 默认的字符集为”ISO-8859-1”；提交表单时浏览器会按 charset 指定的字符集编码数据（post body）发送给服务器；Post 请求时，浏览器会根据 contentType 中 charset 指定的字符集对表单中的数据进行编码，然后提交给服务器。</p>
</li>
<li><p><strong>对**</strong>于 H**TML: <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">，其中的 charset 左右和 JSP 中的 charset 作用一样。</p>
</li>
<li><p><strong>对于动态页面内容</strong>：览器根据 http 头中的 ContentType(“text/html; charset=utf-8”)指定的字符集来解码服务器发送过来的字节流。在应用服务器端可以调用 HttpServletResponse.setContentType()设置 http 头的 ContentType，即服务器端编码方式。</p>
</li>
</ul>
<p>另外一个乱码的例子就是我们在下载文件名为双字节的文件时，下载后文件名为乱码，如图 15 所示。这是因为 Header 只支持 ASCII 字符集，将不在 ASCII 字符集内中的其他字符全部编码为 3F 即问号？，解决办法就是对中文文件名使用 url 编码后 URLEncoder.encode（filename，charset）再放到 Header 中，如清单 4 所示。</p>
<p>图 14. GET 请求中出现乱码</p>
<p><img src="http://image.winrains.cn/2019/08/8108b-image014.jpg" alt="img"></p>
<p>清单 4. 双字节文件名乱码</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> doGet(HttpServletRequest request, HttpServletResponse response) <span class="keyword">throws</span> ServletException, IOException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">String</span> fileName = getDecodeParameter(request,<span class="string">"fileName"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">String</span> userName = getDecodeParameter(request, <span class="string">"username"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    response.setHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment; filename=\""</span> +</span></pre></td></tr><tr><td class="code"><pre><span class="line">    URLEncoder.encode(fileName,<span class="string">"utf-8"</span>) + <span class="string">"\";userName=\""</span> +</span></pre></td></tr><tr><td class="code"><pre><span class="line">    URLEncoder.encode(userName,<span class="string">"utf-8"</span>) + <span class="string">"\""</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="数据库操作过程中的乱码"><a href="#数据库操作过程中的乱码" class="headerlink" title="数据库操作过程中的乱码"></a><strong>数据库操作过程中的乱码</strong></h3><p>在实际应用中，和数据库操作相关的乱码可能出现在数据的导入和导出操作中，在整个过程中涉及到的字符集有服务器端数据库字符集、客户端操作系统字符集、客户端环境变量 nls_lang(lang_territory.charset)，这三个参数的工作流程如图 15 所示。如果这三个参数设置一样，整个数据库操作中就不会出现乱码问题，但是实际应用中客户端的情况复杂多样，很难保持三者一致，涉及到双字节字符就需要服务器端进行转码操作，而转码的桥梁就是 Unicode 字符集，这就要求数据库本身支持 UTF-8 编码方式。为了编码数据库操作过程中的乱码问题，在创建数据库的时候使用 UTF-8 编码方式，如果仅在某些列中使用多语言数据，则可以使用 SQL NCHAR 数据类型（NCHAR，NVARCHAR2 和 NCLOB）以 UTF-16 或 UTF-8 编码形式存储 Unicode 数据，避免存储空间的浪费。</p>
<p>图 15. Oracle 数据库字符集</p>
<p><img src="http://image.winrains.cn/2019/08/a8cf4-image015.jpg" alt="img"></p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文基于日常碰到的乱码现象和项目实践，详细综述了常用字符集，编码以及使用场景；作为普通用户碰到的乱码表象分析和解决办法，以及从编程角度总结和分析了常见乱码情况。希望能为读者深入理解和解决乱码问题提供帮助。</p>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul>
<li><a href="https://www.ibm.com/developerworks/cn/web/wa-lo-ecoding-response-problem/index.html" target="_blank" rel="noopener">深入分析 web 请求响应中的编码问题</a>：主要介绍 web 请求响应中的编码解码问题。</li>
<li><a href="http://www.faqs.org/rfcs/rfc3986.html" target="_blank" rel="noopener">参考 RFC 官方网站</a>，了解更多有关 RFC 文档的信息。</li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/index.html" target="_blank" rel="noopener">深入分析 Java 中的中文编码问题</a>：详细介绍 Java 程序的编码解码及乱码问题</li>
<li><a href="http://www.unicode.org/charts/" target="_blank" rel="noopener">Unicode 编码规范</a>，详细描述了 Unicode 如何编码。</li>
</ul>
<blockquote>
<p>作者：夏 怀英 和 David Chen</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/analysis-and-summary-of-common-random-code-problems/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/analysis-and-summary-of-common-random-code-problems/index.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>解读阿里巴巴 Java 代码规范之命名风格</title>
    <url>/2019/12/26/%E8%A7%A3%E8%AF%BB%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4-Java-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%B9%8B%E5%91%BD%E5%90%8D%E9%A3%8E%E6%A0%BC/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2017 年阿里云栖大会，阿里发布了针对 Java 程序员的《阿里巴巴 Java 开发手册（终极版）》，这篇文档作为阿里数千位 Java 程序员的经验积累呈现给公众，并随之发布了适用于 Eclipse 和 Intellim 的代码检查插件。为了能够深入了解 Java 程序员编码规范，也为了深入理解为什么阿里这样规定，是否规定有误，本文以阿里发布的这篇文档作为分析起源，扩大范围至业界其他公司的规范，例如谷歌、FaceBook、微软、百度、华为，并搜索网络上技术大牛发表的技术文章，深入理解每一条规范的设计背景和目标。<br>由于解读文章仅有两篇，所以按照阿里的篇幅权重分为上篇仅针对 Java 语言本身的编码规约，下篇包含日志管理、异常处理、单元测试、MySQL 规范、工程规范等方面内容进行解读。本文是上篇，主要针对编码规约部分进行解读，由于篇幅限制，仅挑选一小部分进行解读，如果需要全篇，请联系本文作者。</p>
<a id="more"></a>

<h2 id="编码规约"><a href="#编码规约" class="headerlink" title="编码规约"></a>编码规约</h2><h3 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h3><h4 id="下划线或美元符号"><a href="#下划线或美元符号" class="headerlink" title="下划线或美元符号"></a>下划线或美元符号</h4><p>阿里强制规定代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。<br>例如以下为错误，如清单 1 所示：</p>
<p>清单 1 错误示例</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">_name<span class="regexp">/__name/</span><span class="variable">$Object</span><span class="regexp">/name_/</span>name$<span class="regexp">/Object$。</span></span></pre></td></tr></table></figure>

<h5 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h5><p>Oracle 官网建议不要使用$或者<em>开始变量命名，并且建议在命名中完全不要使用”$”字符，原文是”The convention,however,is to always begin your variable names with a letter,not ‘$’ or ‘</em>‘“。对于这一条，腾讯的看法是一样的，百度认为虽然类名可以支持使用”$”符号，但只在系统生成中使用（如匿名类、代理类），编码不能使用。<br>这类问题在 StackOverFlow 上有很多人提出，主流意见为人不需要过多关注，只需要关注原先的代码是否存在”<em>“，如果存在就继续保留，如果不存在则尽量避免使用。也有一位提出尽量不适用”</em>“的原因是低分辨率的显示器，肉眼很难区分”<em>“（一个下划线）和”__”（两个下划线）。<br>我个人觉得可能是由于受 C 语言的编码规范所影响。因为在 C 语言里面，系统头文件里将宏名、变量名、内部函数名用_开头，因为当你#include 系统头文件时，这些文件里的名字都有了定义，如果与你用的名字冲突，就可能引起各种奇怪的现象。综合各种信息，建议不要使用”</em>“、”$”、空格作为命名开始，以免不利于阅读或者产生奇怪的问题。</p>
<h4 id="类命名"><a href="#类命名" class="headerlink" title="类命名"></a>类命名</h4><p>阿里强制规定类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：DO/BO/DTO/VO/AO。</p>
<h4 id="清单-2-类命名例子"><a href="#清单-2-类命名例子" class="headerlink" title="清单 2 类命名例子"></a>清单 2 类命名例子</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">正例：MarcoPolo<span class="regexp">/UserDO/</span>XmlService<span class="regexp">/TcpUdpDeal/</span>TarPromotion</span></pre></td></tr><tr><td class="code"><pre><span class="line">反例：macroPolo<span class="regexp">/UserDo/</span>XMLService<span class="regexp">/TCPUDPD/</span>TAPromotion</span></pre></td></tr></table></figure>

<h5 id="我的理解-1"><a href="#我的理解-1" class="headerlink" title="我的理解"></a>我的理解</h5><p>百度除了支持阿里的规范以外，规定虽然类型支持”$”符号，但只在系统生成中使用（如匿名类、代理类），编码中不能使用。<br>对于类名，俄罗斯 Java 专家 Yegor Bugayenko 给出的建议是尽量采用现实生活中实体的抽象，如果类的名字以”-er”结尾，这是不建议的命名方式。他指出针对这一条有一个例外，那就是工具类，例如 StringUtils、FileUtils、IOUtils。对于接口名称，不要使用 IRecord、IfaceEmployee、RedcordInterface，而是使用现实世界的实体命名。如清单 3 所示。</p>
<p>清单 3 示例</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">SimpleUser</span> <span class="symbol">implements</span> <span class="symbol">User</span>&#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">DefaultRecord</span> <span class="symbol">implements</span> <span class="symbol">Record</span>&#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Suffixed</span> <span class="symbol">implements</span> <span class="symbol">Name</span>&#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Validated</span> <span class="symbol">implements</span> <span class="symbol">Content</span>&#123;&#125;;</span></pre></td></tr></table></figure>

<h4 id="抽象类的命名"><a href="#抽象类的命名" class="headerlink" title="抽象类的命名"></a>抽象类的命名</h4><p>阿里强制规定抽象类命名使用 Abstratc 或 Base 开头。</p>
<h5 id="我的理解-2"><a href="#我的理解-2" class="headerlink" title="我的理解"></a>我的理解</h5><p>Oracle 的抽象类和方法规范并没有要求必须采用 Abstract 或者 Base 开头命名，事实上官网上的示例没有这种命名规范要求，如清单 4 所示。</p>
<h4 id="清单-4-示例"><a href="#清单-4-示例" class="headerlink" title="清单 4 示例"></a>清单 4 示例</h4><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">GraphicObject</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//declare fields</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//declare nonabstract methods</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span>(<span class="params"></span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我也查了一下 JDK，确实源码里很多类都是以这样的方式命名的，例如抽象类 java.util.AbstractList。<br>Stackoverflow 上对于这个问题的解释是，由于这些类不会被使用，一定会由其他的类继承并实现内部细节，所以需要明白地告诉读者这是一个抽象类，那以 Abstract 开头比较合适。<br>Joshua Bloch的理解是支持以 Abstract 开头。我的理解是不要以 Base 开头命名，因为实际的基类也以 Base 开头居多，这样意义有多样性，不够直观。</p>
<h3 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h3><h4 id="避免魔法值的使用"><a href="#避免魔法值的使用" class="headerlink" title="避免魔法值的使用"></a>避免魔法值的使用</h4><p>阿里强制规定不允许任何魔法值（未经定义的常量）直接出现在代码中，反例如清单 5 所示。</p>
<p>清单 5 反例</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">String <span class="built_in">key</span> = <span class="string">"Id#taobao_"</span> + tradeId；</span></pre></td></tr><tr><td class="code"><pre><span class="line">cache.<span class="built_in">put</span>(<span class="built_in">key</span>,value);</span></pre></td></tr></table></figure>

<h5 id="我的理解-3"><a href="#我的理解-3" class="headerlink" title="我的理解"></a>我的理解</h5><p>魔法值确实让你很疑惑，比如你看下面这个例子：<br>int priceTable[] = new int[16];//这样定义错误；这个 16 究竟代表什么？<br>正确的定义方式是这样的：<br>static final int PRICE_TABLE_MAX = 16; //这样定义正确，通过使用完整英语单词的常量名明确定义<br>int price Table[] = new int[PRICE_TABLE_MAX];<br>魔法值会让代码的可读性大大降低，而且如果同样的数值多次出现时，容易出现不清楚这些数值是否代表同样的含义。另一方面，如果本来应该使用相同的数值，一旦用错，也难以发现。因此可以采用以下两点，极力避免使用魔法数值。<br>\1. 不适用魔法数值，使用带名字的 Static final 或者 enum 值；<br>\2. 原则上 0 不用于魔法值，这是因为 0 经常被用作数组的最小下标或者变量初始化的缺省值。</p>
<h4 id="变量值范围"><a href="#变量值范围" class="headerlink" title="变量值范围"></a>变量值范围</h4><p>阿里推荐如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。下面这个正例中的数字就是延伸信息，表示星期几。正例如清单 6 所示。</p>
<p>清单 6 正例</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Enum &#123;MONDAY(<span class="number">1</span>),TUESDAY(<span class="number">2</span>),WEDNESDAY(<span class="number">3</span>),THURSDAY(<span class="number">4</span>),FRIDAY(<span class="number">5</span>),SATURDAY(<span class="number">6</span>),SUNDAY(<span class="number">7</span>);&#125;</span></pre></td></tr></table></figure>

<h5 id="我的理解-4"><a href="#我的理解-4" class="headerlink" title="我的理解"></a>我的理解</h5><p>对于固定并且编译时对象，如 Status、Type 等，应该采用 enum 而非自定义常量实现，enum 的好处是类型更清楚，不会再编译时混淆。这是一个建议性的试用推荐，枚举可以让开发者在 IDE 下使用更方便，也更安全。另外就是枚举类型是一种具有特殊约束的类类型，这些约束的存在使得枚举类本身更加简洁、安全、便捷。</p>
<h3 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h3><h4 id="大括号的使用约定"><a href="#大括号的使用约定" class="headerlink" title="大括号的使用约定"></a>大括号的使用约定</h4><p>阿里强制规定如果是大括号为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则：<br>\1. 左大括号前不换行<br>\2. 左大括号后换行<br>\3. 右大括号前换行<br>\4. 右大括号后还有 else 等代码则不换行表示终止的右大括号后必须换行</p>
<h5 id="我的理解-5"><a href="#我的理解-5" class="headerlink" title="我的理解"></a>我的理解</h5><p>阿里的这条规定应该是参照了 SUN 公司 1997 年发布的代码规范（SUN 公司是 JAVA 的创始者），Google 也有类似的规定，大家都是遵循 K&amp;R 风格（Kernighan 和 Ritchie），Kernighan 和 Ritchie 在《The C Programming Language》一书中推荐这种风格，JAVA 语言的大括号风格就是受到了 C 语言的编码风格影响。<br>注意，SUN 公司认为方法名和大括号之间不应该有空格。</p>
<h4 id="单行字符数限制"><a href="#单行字符数限制" class="headerlink" title="单行字符数限制"></a>单行字符数限制</h4><p>阿里强制规定单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：<br>\1. 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。<br>\2. 运算符与下文一起换行。<br>\3. 方法调用的点符号与下文一起换行。<br>\4. 方法调用时，多个参数，需要换行时，在逗号后进行。<br>\5. 在括号前不要换行，见反例。<br>如清单 7 所示。</p>
<p>清单 7 示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = <span class="built_in">new</span> StringBuffer();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//超过 120 个字符的情况下，换行缩进 4 个空格，点号和方法名称一起换行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sb.<span class="built_in">append</span>(<span class="string">"zi"</span>).<span class="built_in">append</span>(<span class="string">"xin"</span>)…</span></pre></td></tr><tr><td class="code"><pre><span class="line">.<span class="built_in">append</span>(<span class="string">"huang"</span>)…</span></pre></td></tr><tr><td class="code"><pre><span class="line">.<span class="built_in">append</span>(<span class="string">"huang"</span>)…</span></pre></td></tr><tr><td class="code"><pre><span class="line">.<span class="built_in">append</span>(<span class="string">"huang"</span>)…</span></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = <span class="built_in">new</span> StringBuffer();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//超过 120 个字符的情况下，不要在括号前换行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sb.<span class="built_in">append</span>(<span class="string">"zi"</span>).<span class="built_in">append</span>(<span class="string">"xin"</span>).<span class="built_in">append</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">(<span class="string">"huang"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//参数很多的方法调用可能超过 120 个字符，不要在逗号前换行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">method(args1,args2,args3,….,argsX);</span></pre></td></tr></table></figure>

<h5 id="我的理解-6"><a href="#我的理解-6" class="headerlink" title="我的理解"></a>我的理解</h5><p>SUN 公司 1997 年的规范中指出单行不要超过 80 个字符，对于文档里面的代码行，规定不要超过 70 个字符单行。当表达式不能在一行内显示的时候，genuine 以下原则进行切分：<br>\1. 在逗号后换行；<br>\2. 在操作符号前换行；<br>\3. 倾向于高级别的分割；<br>\4. 尽量以描述完整作为换行标准；<br>\5. 如果以下标准造成代码阅读困难，直接采用 8 个空格方式对第二行代码留出空白。<br>示例代码如清单 8 所示。</p>
<p>清单 8 示例</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">function(<span class="name">longExpression1</span>, longExpression2, longExpression3,</span></pre></td></tr><tr><td class="code"><pre><span class="line">longExpression4, longExpression5)<span class="comment">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">var = function(<span class="name">longExpression1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">function2(<span class="name">longExpression2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">longExpression3))<span class="comment">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">longName1 = longName2 * (<span class="name">longName3</span> + longName4 – longName5)</span></pre></td></tr><tr><td class="code"><pre><span class="line">+ <span class="number">4</span> * longName6<span class="comment">;//做法正确</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">longName1 = longName2 * (<span class="name">longName3</span> + longName4</span></pre></td></tr><tr><td class="code"><pre><span class="line">– longName5) + <span class="number">4</span> * longName6<span class="comment">;//做法错误</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">if ((<span class="name">condition1</span> <span class="symbol">&amp;&amp;</span> condition2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">   || (<span class="name">condition3</span> <span class="symbol">&amp;&amp;</span> condition4)</span></pre></td></tr><tr><td class="code"><pre><span class="line">   || !(<span class="name">condition5</span> <span class="symbol">&amp;&amp;</span> condition6) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">doSomethingAboutIt()<span class="comment">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;//这种做法错误</span></pre></td></tr><tr><td class="code"><pre><span class="line">if ((<span class="name">condition1</span> <span class="symbol">&amp;&amp;</span> condition2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">|| (<span class="name">condition3</span> <span class="symbol">&amp;&amp;</span> condition4)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        || !(<span class="name">condition5</span> <span class="symbol">&amp;&amp;</span> condition6) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    doSomethingAboutIt()<span class="comment">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;//这种做法正确</span></pre></td></tr><tr><td class="code"><pre><span class="line">if ((<span class="name">condition1</span> <span class="symbol">&amp;&amp;</span> condition2) || (<span class="name">condition3</span> <span class="symbol">&amp;&amp;</span> condition4)</span></pre></td></tr><tr><td class="code"><pre><span class="line">|| !(<span class="name">condition5</span> <span class="symbol">&amp;&amp;</span> condition6) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    doSomethingAboutIt()<span class="comment">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;//这种做法正确</span></pre></td></tr></table></figure>

<h3 id="OOP-规约"><a href="#OOP-规约" class="headerlink" title="OOP 规约"></a>OOP 规约</h3><h4 id="静态变量及方法调用"><a href="#静态变量及方法调用" class="headerlink" title="静态变量及方法调用"></a>静态变量及方法调用</h4><p>阿里强制规定代码中避免通过一个类的对象引用访问此类的静态变量或静态方法，暂时无谓增加编译器解析成本，直接用类名来访问即可。</p>
<h5 id="我的理解-7"><a href="#我的理解-7" class="headerlink" title="我的理解"></a>我的理解</h5><p>谷歌公司在代码规范中指出必须直接使用类名对静态成员进行引用，并同时举例说明，如清单 9 所示。</p>
<p>清单 9 示例</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Foo aFoo = …;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Foo</span>.</span></span>a<span class="constructor">StaticMethod()</span>;<span class="comment">//good</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">aFoo.a<span class="constructor">StaticMethod()</span>;<span class="comment">//bad</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">something<span class="constructor">ThatYieldsAFoo()</span>.a<span class="constructor">StaticMethod()</span>;<span class="comment">//very bad</span></span></pre></td></tr></table></figure>

<p>SUN 公司 1997 年发布的代码规范也做了类似的要求。<br>为什么需要这样做呢？因为被 static 修饰过的变量或者方法都是随着类的初始化产生的，在堆内存中有一块专门的区域用来存放，后续直接用类名访问即可，避免编译成本的增加和实例对象存放空间的浪费。<br>StackOverflow 上也有人提出了相同的疑问，网友较为精辟的回复是”这是由于生命周期决定的，静态方法或者静态变量不是以实例为基准的，而是以类为基准，所以直接用类访问，否则违背了设计初衷”。那为什么还保留了实例的访问方式呢？可能是因为允许应用方无污染修改吧。</p>
<h4 id="可变参数编程"><a href="#可变参数编程" class="headerlink" title="可变参数编程"></a>可变参数编程</h4><p>阿里强制规定相同参数类型、相同业务类型，才可以使用 Java 的可变参数，避免使用 Object，并且要求可变参数必须放置在参数列表的最后（提倡同学们尽量不用可变参数编程）。</p>
<h5 id="我的理解-8"><a href="#我的理解-8" class="headerlink" title="我的理解"></a>我的理解</h5><p>我们先来了解可变参数的使用方式：<br>\1. 在方法中定义可变参数后，我们可以像操作数组一样操作该参数。<br>\2. 如果该方法除了可变参数还有其他的参数，可变参数必须放到最后。<br>\3. 拥有可变参数的方法可以被重载，在被调用时，如果能匹配到参数定长的方法则优先调用参数定长的方法。<br>\4. 可变参数可以兼容数组参数，但数组参数暂时无法兼容可变参数。<br>至于为什么可变参数需要被放在最后一个，这是因为参数个数不定，所以当其后还有相同类型参数时，编译器无法区分传入的参数属于前一个可变参数还是后边的参数，所以只能让可变参数位于最后一项。<br>可变参数编程有一些好处，例如反射、过程建设、格式化等。对于阿里同学提出的尽量不使用可变参数编程，我猜测的原因是不太可控，比如 Java8 推出 Lambda 表达式之后，可变参数编程遇到了实际的实现困难。<br>我们来看一个例子。假设我们想要实现以下功能，如清单 10 所示。</p>
<p>清单 10 实现功能</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">test<span class="function"><span class="params">((arg0,arg1) -&gt; me.call(arg0,arg1))</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">&gt;<span class="title">test</span><span class="params">((arg0,arg1,arg2)-&gt;me.call(arg0,arg1,arg2))</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">…</span></span></pre></td></tr></table></figure>

<p>对应的实现定义接口的继承关系，并且使用默认方法避免失败，如清单 11 所示。</p>
<p>清单 11 实现方式代码段 1</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> VarArgsRunnable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">default</span> <span class="built_in">void</span> run(<span class="built_in">Object</span>…<span class="built_in">arguments</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"not possible"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">default</span> int getNumberOfArguments() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"unknown"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Interface VarArgsRunnable4 <span class="keyword">extends</span> VarArgsRnnable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">default</span> <span class="built_in">void</span> run(<span class="built_in">Object</span>…<span class="built_in">arguments</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        assert(<span class="built_in">arguments</span>.length == <span class="number">4</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        run(<span class="built_in">arguments</span>[<span class="number">0</span>], <span class="built_in">arguments</span>[<span class="number">1</span>], <span class="built_in">arguments</span>[<span class="number">2</span>], <span class="built_in">arguments</span>[<span class="number">3</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">void</span> run(<span class="built_in">Object</span> arg0, <span class="built_in">Object</span> arg1, <span class="built_in">Object</span> arg2, <span class="built_in">Object</span> arg3, <span class="built_in">Object</span> arg4);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">default</span> int getNumberOfArguments()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这样我们就可以定义 11 个接口，从 VarArgsRnnable0 到 VarArgsRnnable10，并且覆盖方法，调用方式如清单 12 所示。</p>
<p>清单 12 实现方式代码段 2</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> myMethod(VarArgsRnnable runnable,<span class="built_in">Object</span>…<span class="built_in">arguments</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    runnable.run(<span class="built_in">arguments</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>针对上述需求，我们也可以编写代码如清单 13 所示。</p>
<p>清单 13 实现方式 2 代码段</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Java8VariableArgumentsDemo &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    interface <span class="keyword">Invoker</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="type">void</span> invoke(<span class="keyword">Object</span>…args);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> invokeInvoker(<span class="keyword">Invoker</span> <span class="keyword">invoker</span>,<span class="keyword">Object</span>…args)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">invoker</span>.invoke(args);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> applyWithStillAndPrinting(<span class="keyword">Invoker</span> <span class="keyword">invoker</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">invoker</span>.invoke("Still", "Printing");</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">Public</span> static <span class="type">void</span> main(String[] args)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">Invoker</span> printer = <span class="built_in">new</span> <span class="keyword">Invoker</span>()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">Public</span> <span class="type">void</span> invoke(<span class="keyword">Object</span>…args)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span>(<span class="keyword">Object</span> arg:args)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">System</span>.<span class="keyword">out</span>.println(arg);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        printer.invoke("I","am","printing");</span></pre></td></tr><tr><td class="code"><pre><span class="line">        invokeInvoker(printer, "Also","printing");</span></pre></td></tr><tr><td class="code"><pre><span class="line">        applyWithStillAndPrinting(printer);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        applyWithStillAndPrinting((<span class="keyword">Object</span>…args)-&gt;<span class="keyword">System</span>.<span class="keyword">out</span>.println("Not done"));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        applyWithStillAndPrinting(printer::invoke);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>运行后输出如清单 14 所示。</p>
<p>清单 14 实现方式 2 代码段运行结果</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">I</span></pre></td></tr><tr><td class="code"><pre><span class="line">am</span></pre></td></tr><tr><td class="code"><pre><span class="line">printing</span></pre></td></tr><tr><td class="code"><pre><span class="line">Also</span></pre></td></tr><tr><td class="code"><pre><span class="line">printing</span></pre></td></tr><tr><td class="code"><pre><span class="line">Still</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Printing</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Not done</span></pre></td></tr><tr><td class="code"><pre><span class="line">Still</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Printing</span></span></pre></td></tr></table></figure>

<h3 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h3><h4 id="单例模式需要保证线程安全"><a href="#单例模式需要保证线程安全" class="headerlink" title="单例模式需要保证线程安全"></a>单例模式需要保证线程安全</h4><p>阿里强制要求获取单例对象需要保证线程安全，其中的方法也要保证线程安全，并进一步说明资源驱动类、工具类、单例工厂类都需要注意。</p>
<h5 id="我的理解-9"><a href="#我的理解-9" class="headerlink" title="我的理解"></a>我的理解</h5><p>对于这一条规范是通识化规定，我这里进一步讲讲如何做好针对单例对象的线程安全，主要有以下几种方式：<br>\1. 方法中申明 synchronized 关键字<br>出现非线程安全问题，是由于多个线程可以同时进入 getInstance()方法，那么只需要对该方法进行 synchronized 锁同步即可，如清单 15 所示。</p>
<p>清单 15 synchronized 关键字方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySingleton</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MySingleton instance = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MySingleton</span><span class="params">()</span></span>&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> MySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(instance != <span class="keyword">null</span>)&#123;<span class="comment">//懒汉式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//创建实例之前可能会有一些准备性的耗时工作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            Thread.sleep(<span class="number">500</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Instance = <span class="keyword">new</span> MySingleton();</span></pre></td></tr><tr><td class="code"><pre><span class="line">         &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> instance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>执行结果如清单 16 所示。</p>
<p>清单 16 synchronized 关键字方式运行结果</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">174342932</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">174342932</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">174342932</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">174342932</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">174342932</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">174342932</span></span></pre></td></tr></table></figure>

<p>从执行结果上来看，多线程访问的问题已经解决了，返回的是一个实例。但是这种实现方式的运行效率很低。我们接下来采用同步方法块实现。<br>\2. 同步方法块实现</p>
<p>清单 17 同步方法块方式</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">public class MySingleton &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> MySingleton<span class="built_in"> instance </span>= null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword"> private</span> MySingleton()&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    //public synchronized<span class="keyword"> static</span> MySingleton getInstance() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> MySingleton getInstance() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        try &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            synchronized (MySingleton.class) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    if(instance != null)&#123;//懒汉式</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;else&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    //创建实例之前可能会有一些准备性的耗时工作</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Thread.sleep(300);</span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="built_in"> instance </span>=<span class="built_in"> new </span>MySingleton();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; catch (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in"> return </span>instance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里的实现能够保证多线程并发下的线程安全性，但是这样的实现将全部的代码都被锁上了，同样的效率很低下。<br>\3. 针对某些重要的代码来进行单独的同步<br>针对某些重要的代码进行单独的同步，而不是全部进行同步，可以极大的提高执行效率，代码如清单 18 所示。</p>
<p>清单 18 单独同步方式</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">public class MySingleton &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> MySingleton<span class="built_in"> instance </span>= null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword"> private</span> MySingleton()&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> MySingleton getInstance() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        try &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            if(instance != null)&#123;//懒汉式</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;else&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                //创建实例之前可能会有一些准备性的耗时工作</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Thread.sleep(300);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            synchronized (MySingleton.class) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="built_in"> instance </span>=<span class="built_in"> new </span>MySingleton();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;catch (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="built_in"> return </span>instance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>从运行结果来看，这样的方法进行代码块同步，代码的运行效率是能够得到提升，但是却没能保住线程的安全性。看来还得进一步考虑如何解决此问题。<br>4.双检查锁机制（Double Check Locking）<br>为了达到线程安全，又能提高代码执行效率，我们这里可以采用 DCL 的双检查锁机制来完成，代码实现如清单 19 所示。</p>
<p>清单 19 双检查锁机制</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">public class MySingleton &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    // 使用 volatile 关键字保其可见性</span></pre></td></tr><tr><td class="code"><pre><span class="line">    volatile<span class="keyword"> private</span><span class="keyword"> static</span> MySingleton<span class="built_in"> instance </span>= null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword"> private</span> MySingleton() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> MySingleton getInstance() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        try &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="built_in"> if </span>(instance != null) &#123;// 懒汉式</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                // 创建实例之前可能会有一些准备性的耗时工作</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Thread.sleep(300);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                synchronized (MySingleton.class) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   <span class="built_in"> if </span>(instance == null) &#123;// 二次检查</span></pre></td></tr><tr><td class="code"><pre><span class="line">                       <span class="built_in"> instance </span>=<span class="built_in"> new </span>MySingleton();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; catch (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="built_in"> return </span>instance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里在声明变量时使用了 volatile 关键字来保证其线程间的可见性；在同步代码块中使用二次检查，以保证其不被重复实例化。集合其二者，这种实现方式既保证了其高效性，也保证了其线程安全性。<br>\5. 静态内置类方式<br>DCL 解决了多线程并发下的线程安全问题，其实使用其他方式也可以达到同样的效果，代码实现如清单 20 所示。</p>
<p>清单 20 静态内置类方式</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">public class MySingleton &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    //内部类</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> class MySingletonHandler&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword"> private</span><span class="keyword"> static</span> MySingleton<span class="built_in"> instance </span>=<span class="built_in"> new </span>MySingleton();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword"> private</span> MySingleton()&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> MySingleton getInstance() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="built_in"> return </span>MySingletonHandler.instance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>\6. 序列化与反序列化方式<br>静态内部类虽然保证了单例在多线程并发下的线程安全性，但是在遇到序列化对象时，默认的方式运行得到的结果就是多例的。</p>
<p>清单 21 序列化与反序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//内部类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MySingletonHandler</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> MySingleton instance = <span class="keyword">new</span> MySingleton();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MySingleton</span><span class="params">()</span></span>&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> MySingletonHandler.instance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>\7. 使用枚举数据类型方式<br>枚举 enum 和静态代码块的特性相似，在使用枚举时，构造方法会被自动调用，利用这一特性也可以实现单例。</p>
<p>清单 22 枚举数据方式 1</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">EnumFactory</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    singletonFactory;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> MySingleton instance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> EnumFactory()&#123;<span class="regexp">//</span>枚举类的构造方法在类加载是被实例化</span></pre></td></tr><tr><td class="code"><pre><span class="line">        instance = new MySingleton();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public MySingleton getInstance()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> instance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MySingleton</span>&#123;//需要获实现单例的类，比如数据库连接 <span class="title">Connection</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public MySingleton()&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这样写枚举类被完全暴露了，据说违反了”职责单一原则”，我们可以按照下面的代码改造。</p>
<p>清单 23 枚举数据方式 2</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassFactory</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> MyEnumSingleton&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        singletonFactory;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">private</span> MySingleton instance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">MyEnumSingleton</span><span class="params">()</span></span>&#123;<span class="comment">//枚举类的构造方法在类加载是被实例化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            instance = <span class="keyword">new</span> MySingleton();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> MySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> instance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> MyEnumSingleton.singletonFactory.getInstance();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySingleton</span> &#123;</span><span class="comment">//需要获实现单例的类，比如数据库连接 Connection</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySingleton</span><span class="params">()</span></span>&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><h4 id="Switch-语句的使用"><a href="#Switch-语句的使用" class="headerlink" title="Switch 语句的使用"></a>Switch 语句的使用</h4><p>阿里强制规定在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。</p>
<h5 id="我的理解-10"><a href="#我的理解-10" class="headerlink" title="我的理解"></a>我的理解</h5><p>首先理解前半部分，”每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止”。因为这样可以比较清楚地表达程序员的意图，有效防止无故遗漏的 break 语句。我们来看一个示例，如清单 24 所示。</p>
<p>清单 24 synchronized 关键字方式运行结果</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(condition) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">ABC:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    statements;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/*程序继续执行直到 DEF 分支*/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">DEF:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    statements;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">XYZ:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    statements;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">default:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    statements;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上述示例中，每当一个 case 顺着往下执行时（因为没有 break 语句），通常应在 break 语句的位置添加注释。上面的示例代码中就包含了注释”/<em>程序继续执行直到 DEF 分支</em>/“（这一条也是 SUN 公司 1997 年代码规范的要求）。<br>语法上来说，default 语句中的 break 是多余的，但是如果后续添加额外的 case，可以避免找不到匹配 case 项的错误。</p>
<h3 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h3><h4 id="集合转数组处理"><a href="#集合转数组处理" class="headerlink" title="集合转数组处理"></a>集合转数组处理</h4><p>阿里强制规定使用集合转数组的方法，必须使用集合的 toArray(T[] arrays)，传入的是类型完全一样的数组，大小就是 list.size()。使用 toArray 带参方法，入参分配的数组空间不够大时，toArray 方法内部将重新分配内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[list.size()]的数组元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。正例如清单 25 所示。</p>
<p>清单 25 正例</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list =<span class="built_in"> new </span>ArrayList&lt;String&gt;(2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">list.add(<span class="string">"guan"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">list.add(<span class="string">"bao"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">String[]<span class="built_in"> array </span>=<span class="built_in"> new </span>String[list.size()];</span></pre></td></tr><tr><td class="code"><pre><span class="line">array = list.toArray(array);</span></pre></td></tr></table></figure>

<p>反例：直接使用 toArray 暂时无参方法存在问题，此方法返回值只能是 Object[]类，若强转其他类型数组将出现 ClassCastException 错误。</p>
<h5 id="我的理解-11"><a href="#我的理解-11" class="headerlink" title="我的理解"></a>我的理解</h5><p>ArrayList 类的 toArray()源码如清单所示，toArray()方法暂时无需传入参数，可以直接将集合转成 Object 数组进行返回，而且也只能返回 Object 类型。</p>
<p>清单 26 toArray()源码</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">Public <span class="keyword">Object</span>[] toArray()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">Object</span> aobj[] = <span class="keyword">new</span> <span class="keyword">Object</span>[<span class="built_in">size</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.arraycopy(((<span class="keyword">Object</span>)(elementData)),<span class="number">0</span>,((<span class="keyword">Object</span>)(aobj)),<span class="number">0</span>,<span class="built_in">size</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> aobj;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(a.length &lt; <span class="built_in">size</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// Make a new array of a's runtime type, but my contents:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData,<span class="built_in">size</span>, a.getClass());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.arraycopy(elementData,<span class="number">0</span>,a,<span class="number">0</span>,<span class="built_in">size</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(a.length&gt; a[<span class="built_in">size</span>] = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>由源码可知，不带参数的 toArray()构造一个 Object 数组，然后进行数据拷贝，此时进行转型就会产生 ClassCastException。原因是不能将 Object[]转化为 Strng[]。Java 中的强制类型转换只是针对单个对象，想要将一种类型数组转化为另一种类型数组是不可行的。<br>针对传入参数的数组大小，测试大于 list、等于 list 和小于 list 三种情况，测试代码如清单 27 所示。</p>
<p>清单 27 toArray()测试</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static void main(String<span class="literal">[]</span> args)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;String&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;String&gt;<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">list</span>.add(<span class="string">"test"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    long start = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>current<span class="constructor">TimeMills()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000000</span>;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String<span class="literal">[]</span> <span class="built_in">array</span> = <span class="keyword">new</span> String<span class="literal">[<span class="identifier">list</span>.<span class="identifier">size</span>()]</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Array = <span class="built_in">list</span>.<span class="keyword">to</span><span class="constructor">Array(<span class="params">array</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"数组长度等于 list 耗时："</span>+(<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>current<span class="constructor">TimeMills()</span>-start)+<span class="string">"ms"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    start = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>current<span class="constructor">TimeMills()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000000</span>;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String<span class="literal">[]</span> <span class="built_in">array</span> = <span class="keyword">new</span> String<span class="literal">[<span class="identifier">list</span>.<span class="identifier">size</span>()<span class="operator">*</span><span class="number">2</span>]</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Array = <span class="built_in">list</span>.<span class="keyword">to</span><span class="constructor">Array(<span class="params">array</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"数组长度等于 list 耗时："</span>+(<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>current<span class="constructor">TimeMills()</span>-start)+<span class="string">"ms"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">     start = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>current<span class="constructor">TimeMills()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000000</span>;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String<span class="literal">[]</span> <span class="built_in">array</span> = <span class="keyword">new</span> String<span class="literal">[<span class="number">0</span>]</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Array = <span class="built_in">list</span>.<span class="keyword">to</span><span class="constructor">Array(<span class="params">array</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"数组长度等于 list 耗时："</span>+(<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>current<span class="constructor">TimeMills()</span>-start)+<span class="string">"ms"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>清单运行后输出结果如清单 28 所示。</p>
<p>清单 28 清单运行输出</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">数组长度等于 <span class="type">list</span> 耗时：<span class="number">431</span>ms</span></pre></td></tr><tr><td class="code"><pre><span class="line">数组长度等于 <span class="type">list</span> 耗时：<span class="number">509</span>ms</span></pre></td></tr><tr><td class="code"><pre><span class="line">数组长度等于 <span class="type">list</span> 耗时：<span class="number">1943</span>ms</span></pre></td></tr></table></figure>

<p>通过测试可知无论数据大小如何，数组转换都可以成功，只是耗时不同，数组长度等于 list 时性能最优，因此强制方法入参数组大小与集合元素个数一致。</p>
<h3 id="注释规约"><a href="#注释规约" class="headerlink" title="注释规约"></a>注释规约</h3><h4 id="方法注释要求"><a href="#方法注释要求" class="headerlink" title="方法注释要求"></a>方法注释要求</h4><p>阿里强制要求方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/**/注释，注意与代码对照。</p>
<h5 id="我的理解-12"><a href="#我的理解-12" class="headerlink" title="我的理解"></a>我的理解</h5><p>百度规定方法注释采用标准的 Javadoc 注释规范，注释中必须提供方法说明、参数说明及返回值和异常说明。腾讯规定采用 JavaDoc 文档注释，在方法定义之前应该对其进行注释，包括方法的描述、输入、输出以及返回值说明、抛出异常说明、参考链接等。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="数据结构初始化大小"><a href="#数据结构初始化大小" class="headerlink" title="数据结构初始化大小"></a>数据结构初始化大小</h4><p>阿里推荐任何数据结构的构造或初始化，都应指定大小，避免数据结构暂时无限增长吃光内存。</p>
<h5 id="我的理解-13"><a href="#我的理解-13" class="headerlink" title="我的理解"></a>我的理解</h5><p>首先明确一点，阿里这里指的大小具体是指数据结构的最大长度。大部分 Java 集合类在构造时指定的大小都是初始尺寸（initial Capacity），而不是尺寸上限（Capacity），只有几种队列除外，例如 ArrayBlockingQueue、LinkedBlockingQueue，它们在构造时可以指定队列的最大长度。阿里推荐的目的是为了合理规划内存，避免出现 OOM（Out of Memory）异常。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文主要介绍了阿里巴巴针对命名风格、常量定义、代码格式、OOP 规约、并发处理、控制语句、集合处理、注释规约、其他这些关于编码规约的要求。本文仅覆盖了阿里代码规范的少数内容，更多内容请咨询本文作者。</p>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><p>参考文档《阿里巴巴 Java 开发手册（又名阿里巴巴 Java 代码规约）》。<br>参考 developerWorks 上的 Java 文章，了解更多 Java 知识。<br>参考书籍 《Effective Java Second Edition》Joshua Bloch。</p>
<blockquote>
<p>作者：周明耀</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/deconding-code-specification-part-1/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/deconding-code-specification-part-1/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title>解读阿里巴巴 Java 代码规范之代码处理</title>
    <url>/2019/12/26/%E8%A7%A3%E8%AF%BB%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4-Java-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%B9%8B%E4%BB%A3%E7%A0%81%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2017 年阿里云栖大会，阿里发布了针对 Java 程序员的《阿里巴巴 Java 开发手册（终极版）》，这篇文档作为阿里数千位 Java 程序员的经验积累呈现给公众，并随之发布了适用于 Eclipse 和 Intellim 的代码检查插件。为了能够深入了解 Java 程序员编码规范，也为了深入理解为什么阿里这样规定，是否规定有误，本文以阿里发布的这篇文档作为分析起源，扩大范围至业界其他公司的规范，例如谷歌、FaceBook、微软、百度、华为，并搜索网络上技术大牛发表的技术文章，深入理解每一条规范的设计背景和目标。<br>由于解读文章仅有两篇，所以按照阿里的篇幅权重分为上篇仅针对 Java 语言本身的编码规约，下篇包含日志管理、异常处理、单元测试、MySQL 规范、工程规范等方面内容进行解读。本文是下篇，主要针对编码规约部分进行解读，注意，本文所附代码限于篇幅可能并不完整，也可能由于机器不同，存在运行结果不完全一致的情况，请读者见谅。</p>
<a id="more"></a>

<h2 id="异常日志"><a href="#异常日志" class="headerlink" title="异常日志"></a>异常日志</h2><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="不要捕获-RuntimeException"><a href="#不要捕获-RuntimeException" class="headerlink" title="不要捕获 RuntimeException"></a>不要捕获 RuntimeException</h4><p>阿里强制规定 Java 类库中的 RuntimeException 可以通过预先检查进行规避，而不应该通过 catch 来处理，例如 IndexOutOfBoundsException、NullPointerException 等。</p>
<h5 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h5><p>RuntimeException，也被称为运行时异常，通常是由于代码中的 bug 引起的，正确的处理方式是去检查代码，通过添加数据长度判断，判断对象是否为空等方法区规避，而不是靠捕获来规避这种异常。</p>
<h4 id="事务中的异常需要回滚"><a href="#事务中的异常需要回滚" class="headerlink" title="事务中的异常需要回滚"></a>事务中的异常需要回滚</h4><p>阿里强制规定有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。</p>
<h5 id="我的理解-1"><a href="#我的理解-1" class="headerlink" title="我的理解"></a>我的理解</h5><p>try catch 代码块中对异常的处理，可能会遗漏事务的一致性，当事务控制不使用其他框架管理时，事务需要手动回滚。实际使用如果引入第三方的框架对事务进行管理，比如 Spring，则根据第三方框架的实际实现情况，确定是否有必要手动回滚。当第三方事务管理框架本身就会对于异常进行抛出时需要做事务回滚。例如 Spring 在@Transactional 的 annotation 注解下，会默认开启运行时异常事务回滚。</p>
<h4 id="不能在-finally-块中使用-return"><a href="#不能在-finally-块中使用-return" class="headerlink" title="不能在 finally 块中使用 return"></a>不能在 finally 块中使用 return</h4><p>阿里强制要求 finally 块中不使用 return，因为执行完该 return 后方法结束执行，不会再执行 try 块中的 return 语句。</p>
<h5 id="我的理解-2"><a href="#我的理解-2" class="headerlink" title="我的理解"></a>我的理解</h5><p>我们来看一个示例，代码如清单 1 所示。</p>
<p>清单 1 示例代码</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(m_1());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">m_1</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"start"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> i += <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"error:"</span> + e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; finally &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">10</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                System.out.<span class="built_in">println</span>(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"finally"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="number">50</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出如下清单 2 所示。</p>
<p>清单 2 清单 1 程序运行输出</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">start</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">finally</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">50</span></span></pre></td></tr></table></figure>

<p>对此现象可以通过反编译 class 文件很容易找到原因，如清单 3 所示。</p>
<p>清单 3 反编译文件</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(m_1());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">m_1</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"start"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"error:"</span> + e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; finally &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">10</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                System.out.<span class="built_in">println</span>(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"finally"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            i = <span class="number">50</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>首先 i+=10;被分离为单独的一条语句，其次 return 50;被加在 try 和 catch 块的结尾，”覆盖”了 try 块中原有的返回值。如果我们在 finally 块中没有 return，则 finally 块中的赋值语句不会改变最后的返回结果，代码如清单 4 所示。</p>
<p>清单 4 finally 块示例代码</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(m_1());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">m_1</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"start"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> i += <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"error:"</span> + e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; finally &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">10</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                System.out.<span class="built_in">println</span>(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"finally"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            i = <span class="number">50</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如清单 5 所示。</p>
<p>清单 5 清单 4 程序运行输出</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="built_in">start</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">finally</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">10</span></span></pre></td></tr></table></figure>

<h3 id="日志规约"><a href="#日志规约" class="headerlink" title="日志规约"></a>日志规约</h3><h4 id="不可直接使用日志系统"><a href="#不可直接使用日志系统" class="headerlink" title="不可直接使用日志系统"></a>不可直接使用日志系统</h4><p>阿里强制规定应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p>
<h5 id="我的理解-3"><a href="#我的理解-3" class="headerlink" title="我的理解"></a>我的理解</h5><p>SLF4J 即简单日志门面模式，不是具体的日志解决方案，它只服务于各种各样的日志系统。在使用 SLF4J 时不需要指定哪个具体的日志系统，只需要将使用到的具体日志系统的配置文件放到类路径下去。<br>正例如清单 6 所示。</p>
<p>清单 6 正例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HelloWorld<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        logger.info(<span class="string">"please use SLF4J,rather than logback or log4j"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>反例如清单 7 所示。</p>
<p>清单 7 反例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger =</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LoggerFactory.getLogger(HelloWorld<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        logger.info(<span class="string">"please use SLF4J,rather than logback or log4j"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="日志文件保留时间"><a href="#日志文件保留时间" class="headerlink" title="日志文件保留时间"></a>日志文件保留时间</h4><p>阿里强制规定日志文件至少保存 15 天，因为有些异常具备以”周”为频次发生的特点。</p>
<h5 id="我的理解-4"><a href="#我的理解-4" class="headerlink" title="我的理解"></a>我的理解</h5><p>日志保留时间推荐 15 天以上，但是保留时间也不宜过长，一般不超过 21 天，否则造成硬盘空间的浪费。对于一些长周期性执行的逻辑，可以根据实际情况调整该保存时间，同时也需要保证日志能够监控到关键的应用。<br>对于长周期执行的逻辑，可以使用特定的 appender，并使用不同的日志清理规则，如时间、大小等。如一月执行一次的定时任务，可以将日志输出到新的日志文件，然后通过大小限定的规则进行清理，并不一定要使用时间清理的逻辑。</p>
<h3 id="安全规约"><a href="#安全规约" class="headerlink" title="安全规约"></a>安全规约</h3><h4 id="权限控制校验"><a href="#权限控制校验" class="headerlink" title="权限控制校验"></a>权限控制校验</h4><p>阿里强制要求对于隶属于用户个人的页面或者功能必须进行权限控制校验。</p>
<h5 id="我的理解-5"><a href="#我的理解-5" class="headerlink" title="我的理解"></a>我的理解</h5><p>涉及到对于数据的增删改查，必须有权限的控制和校验，要有一个黑白名单的控制，不能依赖于前台页面的简单控制，后台要有对于完整的权限控制的实现。这样就能尽可能地防治数据的错误修改。</p>
<h4 id="用户传入参数校验"><a href="#用户传入参数校验" class="headerlink" title="用户传入参数校验"></a>用户传入参数校验</h4><p>阿里强制要求用户请求传入的任何参数必须做有效校验。</p>
<h5 id="我的理解-6"><a href="#我的理解-6" class="headerlink" title="我的理解"></a>我的理解</h5><p>对于用户输入的任何参数，前端页面上都必须要做一定的有效性校验，并且在数据发送至服务器的时候在页面上给出验证结果提示，那么在用户请求传入的任务参数，后台同样也要对其有效性进行验证，防止前端页面未能过滤或者暂时无法验证的错误参数。忽略参数的验证会导致的问题很多，page size 过大会导致内存溢出、SQL 溢出等，只有验证才能尽可能地减少这些问题的出现，进而减少错误的排查几率。</p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><h4 id="单元测试应该自动执行"><a href="#单元测试应该自动执行" class="headerlink" title="单元测试应该自动执行"></a>单元测试应该自动执行</h4><p>阿里强制单元测试应该是全自动执行的，并且非交互式的。测试框架通常是定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个号的单元测试。单元测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。</p>
<h5 id="我的理解-7"><a href="#我的理解-7" class="headerlink" title="我的理解"></a>我的理解</h5><p>这条原则比较容易理解。单元测试是整个系统的最小测试单元，针对的是一个类中一个方法的测试，如果这些测试的结果需要人工校验是否正确，那么对于验证人来说是一项痛苦而且耗时的工作。另外，单元测试作为系统最基本的保障，需要在修改代码、编译、打包过程中都会运行测试用例，保障基本功能，自动化的测试是必要条件。其实自动化测试不仅是单元测试特有的，包括集成测试、系统测试等，都在慢慢地转向自动化测试，以降低测试的人力成本。</p>
<h4 id="单元测试应该是独立的"><a href="#单元测试应该是独立的" class="headerlink" title="单元测试应该是独立的"></a>单元测试应该是独立的</h4><p>阿里强制保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。反例：method2 需要依赖 method1 的执行，将执行结果作为 method2 的输入。</p>
<h5 id="我的理解-8"><a href="#我的理解-8" class="headerlink" title="我的理解"></a>我的理解</h5><p>单元测试作为系统的最小测试单元，主要目的是尽可能早地测试编写的代码，降低后续集成测试期间的测试成本，以及在运行测试用例的时候能够快速地定位到对应的代码段并解决相关问题。<br>我们假设这么一个场景，method1 方法被 10 个其他 method 方法调用，如果 10 个 method 方法的测试用例都需要依赖 method1，那么当 methdo1 被修改导致运行出错的情况下，会导致 method1 以及依赖它的 10 个 method 的所有测试用例报错，这样就需要排查这 11 个方法到底哪里出了问题，这与单元测试的初衷不符，也会大大的增加排查工作量，所以单元测试必须是独立的，不会因为受到外部修改（这里的修改包括了依赖方法的修改以及外部环境的修改），编写单元测试时遇到的这类依赖可以使用 mock 来模拟输入和期望的返回，这样所以来的方法内部逻辑的变更就不会影响到外部的实现。</p>
<h4 id="BCDE-原则"><a href="#BCDE-原则" class="headerlink" title="BCDE 原则"></a>BCDE 原则</h4><p>阿里推荐编写单元测试代码遵守 BCDE 原则，以保证被测试模块的交付质量。</p>
<h5 id="我的理解-9"><a href="#我的理解-9" class="headerlink" title="我的理解"></a>我的理解</h5><p>BCDE 原则逐一解释如下：<br>B（Border）：确保参数边界值均被覆盖。<br>例如：对于数字，测试负数、0、正数、最小值、最大值、NaN（非数字）、无穷大值等。对于字符串，测试空字符串、单字符、非 ASCII 字符串、多字节字符串等。对于集合类型，测试空、第一个元素、最后一个元素等。对于日期，测试 1 月 1 日、2 月 29 日、12 月 31 日等。被测试的类本身也会暗示一些特定情况下的边界值。对于边界情况的测试一定要详尽。<br>C（Connect）：确保输入和输出的正确关联性。<br>例如，测试某个时间判断的方法 boolean inTimeZone(Long timeStamp)，该方法根据输入的时间戳判断该事件是否存在于某个时间段内，返回 boolean 类型。如果测试输入的测试数据为 Long 类型的时间戳，对于输出的判断应该是对于 boolean 类型的处理。如果测试输入的测试数据为非 Long 类型数据，对于输出的判断应该是报错信息是否正确。<br>D（Design）：任务程序的开发包括单元测试都应该遵循设计文档。<br>E（Error）：单元测试包括对各种方法的异常测试，测试程序对异常的响应能力。<br>除了这些解释之外，《单元测试之道（Java 版）》这本书里面提到了关于边界测试的 CORRECT 原则：<br>一致性（Conformance）：值是否符合预期格式（正常的数据），列出所有可能不一致的数据，进行验证。<br>有序性（Ordering）：传入的参数的顺序不同的结果是否正确，对排序算法会产生影响，或者是对类的属性赋值顺序不同会不会产生错误。<br>区间性（Range）：参数的取值范围是否在某个合理的区间范围内。<br>引用/耦合性（Reference）：程序依赖外部的一些条件是否已满足。前置条件：系统必须处于什么状态下，该方法才能运行。后置条件，你的方法将会保证哪些状态发生改变。<br>存在性（Existence）：参数是否真的存在，引用为 Null，String 为空，数值为 0 或者物理介质不存在时，程序是否能正常运行。<br>基数性（Cardinality）：考虑以”0-1-N 原则”，当数值分别为 0、1、N 时，可能出现的结果，其中 N 为最大值。<br>时间性（Time）：相对时间指的是函数执行的依赖顺序，绝对时间指的是超时问题、并发问题。</p>
<h4 id="建表的是与否规则"><a href="#建表的是与否规则" class="headerlink" title="建表的是与否规则"></a>建表的是与否规则</h4><p>阿里强制要求如果遇到需要表达是与否的概念时，必须使用 is_xxx 的方法命令，数据类型是 unsigned tinyint，1 表示是，0 表示否。<br>说明：任务字段如果为非负数，必须是 unsigned。<br>正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。</p>
<h5 id="我的理解-10"><a href="#我的理解-10" class="headerlink" title="我的理解"></a>我的理解</h5><p>命名使用 is_xxx 第一个好处是比较清晰的，第二个好处是使用者根据命名就可以知道这个字段的取值范围，也方便做参数验证。<br>类型使用 unsigned 的好处是如果只存整数，unsigned 类型有更大的取值范围，可以节约磁盘和内存使用。<br>对于表的名字，MySQL 社区有自己推荐的命名规范：</p>
<ol>
<li>表包含多个英文单词时，需要用下划线进行单词分割，这一点类似于 Java 类名的命名规范，例如 master_schedule、security_user_permission；</li>
<li>由于 InnoDB 存储引擎本身是针对操作系统的可插拔设计的，所以原则上所有的表名组成全部由小写字母组成；</li>
<li>不允许出现空格，需要分割一律采用下划线；</li>
<li>名字不允许出现数字，仅包含英文字母；</li>
<li>名字需要总长度少于 64 个字符。</li>
</ol>
<h4 id="数据类型精度考量"><a href="#数据类型精度考量" class="headerlink" title="数据类型精度考量"></a>数据类型精度考量</h4><p>阿里强制要求存放小数时使用 decimal，禁止使用 float 和 double。<br>说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。</p>
<h5 id="我的理解-11"><a href="#我的理解-11" class="headerlink" title="我的理解"></a>我的理解</h5><p>我们先来看看各个精度的范围。<br>Float：浮点型，4 字节数 32 位，表示数据范围-3.4E38<del>3.4E38<br>Double：双精度型，8 字节数 64 位，表示数据范围-1.7E308</del>1.7E308<br>Decimal：数字型，16 字节数 128 位，不存在精度损失，常用于银行账目计算<br>在精确计算中使用浮点数是非常危险的，在对精度要求高的情况下，比如银行账目就需要使用 Decimal 存储数据。<br>实际上，所有涉及到数据存储的类型定义，都会涉及数据精度损失问题。Java 的数据类型也存在 float 和 double 精度损失情况，阿里没有指出这条规约，就全文来说，这是一个比较严重的规约缺失。<br>Joshua Bloch（著名的 Effective Java 书作者）认为，float 和 double 这两个原生的数据类型本身是为了科学和工程计算设计的，它们本质上都采用单精度算法，也就是说在较宽的范围内快速获得精准数据值。但是，需要注意的是，这两个原生类型都不保证也不会提供很精确的值。单精度和双精度类型特别不适用于货币计算，因为不可能准确地表示 0.1（或者任何其他十的负幂）。<br>举个例子，如清单 8 所示。</p>
<p>清单 8 示例代码</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">float</span> calnUM1;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">double</span> calNum2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">calNum1 = (<span class="built_in">float</span>)(<span class="number">1.03</span><span class="number">-.42</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">calNum2 = <span class="number">1.03</span><span class="number">-.42</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"calNum1="</span>+ calNum1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"calNum2="</span>+ calNum2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.<span class="keyword">out</span>.println(<span class="number">1.03</span><span class="number">-.42</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">calNum1 = (<span class="built_in">float</span>)(<span class="number">1.00</span><span class="number">-9</span>*<span class="number">.10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">calNum2 = <span class="number">1.00</span><span class="number">-9</span>*<span class="number">.10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"calNum1="</span>+ calNum1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"calNum2="</span>+ calNum2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.<span class="keyword">out</span>.println(<span class="number">1.00</span><span class="number">-9</span>*<span class="number">.10</span>);</span></pre></td></tr></table></figure>

<p>输出结果如清单 9 所示。</p>
<p>清单 9 清单 8 示例代码运行输出结果</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">calNum1=0.61</span></pre></td></tr><tr><td class="code"><pre><span class="line">calNum2=0.6100000000000001</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.6100000000000001</span></pre></td></tr><tr><td class="code"><pre><span class="line">calNum1=0.1</span></pre></td></tr><tr><td class="code"><pre><span class="line">calNum2=0.09999999999999998</span></pre></td></tr><tr><td class="code"><pre><span class="line">0. 09999999999999998</span></pre></td></tr></table></figure>

<p>从上面的输出结果来看，如果寄希望于打印时自动进行四舍五入，这是不切实际的。<br>我们再来看一个实际的例子。假设你有 1 块钱，现在每次购买蛋糕的价格都会递增 0.10 元，为我们一共可以买几块蛋糕。口算一下，应该是 4 块（因为 0.1+0.2+0.3+0.4=1.0），我们写个程序验证看看，如清单 10 所示。</p>
<p>清单 10 示例代码</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">//错误的方式</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="type">double</span> funds1 = <span class="number">1.00</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="type">int</span> itemsBought = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">double</span> price = <span class="number">.10</span>;funds&gt;=price;price+=<span class="number">.10</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    funds1 -=price;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    itemsBought++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(itemsBought+" items boughts.");</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println("Changes:"+funds1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">//正确的方式</span></pre></td></tr><tr><td class="code"><pre><span class="line">final BigDecimal TEN_CENTS = <span class="built_in">new</span> BigDecimal(".10");</span></pre></td></tr><tr><td class="code"><pre><span class="line">itemsBought = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">BigDecimal funds2 = <span class="built_in">new</span> BigDecimal("1.00");</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(BigDecimal price = TEN_CENTS;funds2.compareTo(price)&gt;<span class="number">0</span>;price = price.<span class="keyword">add</span>(TEN_CENTS)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    fund2 = fund2.substract(price);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    itemsBought++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(itemsBought+" items boughts.");</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println("Changes:"+funds2);</span></pre></td></tr></table></figure>

<p>运行输出如清单 11 所示。</p>
<p>清单 11 清单 10 示例代码运行输出结果</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> items boughts.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes:<span class="number">0.3999999999999999</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span> items boughts.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes:<span class="number">0.00</span></span></pre></td></tr></table></figure>

<p>这里我们可以看到使用了 BigDecimal 解决了问题，实际上 int、long 也可以解决这类问题。采用 BigDecimal 有一个缺点，就是使用过程中没有原始数据这么方便，效率也不高。如果采用 int 方式，最好不要在有小数点的场景下使用，可以在 100、10 这样业务场景下选择使用。</p>
<h4 id="使用-Char"><a href="#使用-Char" class="headerlink" title="使用 Char"></a>使用 Char</h4><p>阿里强制要求如果存储的字符串长度几乎相等，使用 Char 定长字符串类型。</p>
<h5 id="我的理解-12"><a href="#我的理解-12" class="headerlink" title="我的理解"></a>我的理解</h5><p>我这里不讨论 MySQL，而是聊聊另一种主流关系型数据库-PostgreSQL。在 PostgreSQL 中建议使用 varchar 或者 text，而不是 char，这是因为它们之间没有性能区别，但是 varchar、text 能支持动态的长度调整，存储空间也更节省。<br>在 PostgreSQL 官方文档中记录了这两种类型的比较，如下所示：<br>SQL 定义了两种基本的字符类型：character varying(n)和 character(n)，这里的 n 是一个正整数。两种类型都可以存储最多 n 个字符的字符串（没有字节）。试图存储更长的字符串到这些类型的字段里会产生一个错误，除非超出长度的字符都是空白，这种情况下该字符串将被截断为最大长度。如果要存储的字符串比申明的长度短，类型为 character 的数值将会用空白填满，而类型为 character varying 的数值就不会填满。<br>如果我们明确地把一个数值转换成 character varying(n)或 character(n)，那么超长的数值将被截断成 n 个字符，且不会抛出错误。这也是 SQL 标准的要求。<br>varchar(n)和 char(n)分别是 character varying(n)和 character(n)的别名，没有申明长度的 character 等于 character(1)；如果不带长度说明可以使用 character varying，那么该类型接受任何长度的字符串。<br>另外，PostgreSQL 提供 text 类型，它可以存储任何长度的字符串。尽管类型 text 不是 SQL 标准，但是许多其他 SQL 数据库系统也有它。<br>Character 类型的数值物理上都用空白填充到指定的长度 n，并且以这种方式存储。不过，填充的空白是暂时无语义的。在比较两个 character 值的时候，填充的空白都不会被关注，在转换成其他字符串类型的时候，character 值里面的空白会被删除。请注意，在 character varying 和 text 数值的，结尾的空白是有语义的，并且当使用模式匹配时，如 LIKE，使用正则表达式。<br>一个简短的字符串（最多 126 个字节）的存储要求是 1 个字节加上实际的字符串，其中包括空格填充的 character。更长的字符串有 4 个字节的开销，而不是 1。长的字符串将会自动被系统压缩，因此在磁盘上的物理需求可能会更少些。更长的数值也会存储在数据表里面，这样它们就不会干扰对短字段值的快速访问。不管怎样，允许存储的最长字符串大概是 1GB。允许在数据类型声明中出现的 n 的最大值比这个还小。修改该行也没有什么意义，因为在多字节编码下字符和字节的数目可能差别很大。如果你想存储没有特定上限的长字符串，那么使用 text 或没有长度声明的 character varying，而不要选择一个任意长度限制。<br>从性能上分析，character(n)通常是最慢的，在大多数情况下，应该使用 text 或者 character varying。</p>
<h3 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h3><h4 id="应用分层"><a href="#应用分层" class="headerlink" title="应用分层"></a>应用分层</h4><h5 id="服务间依赖关系"><a href="#服务间依赖关系" class="headerlink" title="服务间依赖关系"></a>服务间依赖关系</h5><p>阿里推荐默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于 Web 层，也可以直接依赖于 Service 层。</p>
<h5 id="我的理解-13"><a href="#我的理解-13" class="headerlink" title="我的理解"></a>我的理解</h5><p>《软件架构模式》一书中介绍了分层架构思想：<br>分层架构是一种很常见的架构模式，它也被叫做 N 层架构。这种架构是大多数 Java EE 应用的实际标准。许多传统 IT 公司的组织架构和分层模式十分的相似，所以它很自然地成为大多数应用的架构模式。<br>分层架构模式里的组件被分成几个平行的层次，每一层都代表了应用的一个功能（展示逻辑或者业务逻辑）。尽管分层架构没有规定自身要分成几层几种，大多数的结构都分成四个层次，即展示层、业务层、持久层和数据库层。业务层和持久层有时候可以合并成单独的一个业务层，尤其是持久层的逻辑绑定在业务层的组件当中。因此，有一些小的应用可能只有三层，一些有着更复杂的业务的大应用可能有五层甚至更多的层。<br>分层架构中的每一层都有着特定的角色和职能。举个例子，展示层负责所有的界面展示以及交互逻辑，业务层负责处理请求对应的业务。架构里的层次是具体工作的高度抽象，它们都是为了实现某种特定的业务请求。比如说展示层并不关心如何得到用户数据，它只需在屏幕上以特定的格式展示信息。业务层并不关心要展示在屏幕上的用户数据格式，也不关心这些用户数据从哪里来，它只需要从持久层得到数据，执行与数据有关的相应业务逻辑，然后把这些信息传递给展示层。<br>分层架构的一个突出特性地组件间关注点分离。一个层中的组件只会处理本层的逻辑。比如说，展示层的组件只会处理展示逻辑，业务层中的组件只会去处理业务逻辑。因为有了组件分离设计方式，让我们更容易构造有效的角色和强力的模型，这样应用变得更好开发、测试、管理和维护。</p>
<h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><h5 id="高并发服务器-time-wait"><a href="#高并发服务器-time-wait" class="headerlink" title="高并发服务器 time_wait"></a>高并发服务器 time_wait</h5><p>阿里推荐高并发服务器建议调小 TCP 协议的 time_wait 超时时间。<br>说明：操作系统默认 240 秒后才会关闭处于 time_wait 状态的连接，在高并发访问下，服务器端会因为处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。<br>正例：在 Linux 服务器上通过变更/etc/sysctl.conf 文件去修改该缺省值（秒）：net.ipv4.tcp_fin_timeout=30</p>
<h5 id="我的理解-14"><a href="#我的理解-14" class="headerlink" title="我的理解"></a>我的理解</h5><p>服务器在处理完客户端的连接后，主动关闭，就会有 time_wait 状态。TCP 连接是双向的，所以在关闭连接的时候，两个方向各自都需要关闭。先发 FIN 包的一方执行的是主动关闭，后发 FIN 包的一方执行的是被动关闭。主动关闭的一方会进入 time_wait 状态，并且在此状态停留两倍的 MSL 时长。<br>主动关闭的一方收到被动关闭的一方发出的 FIN 包后，回应 ACK 包，同时进入 time_wait 状态，但是因为网络原因，主动关闭的一方发送的这个 ACK 包很可能延迟，从而触发被动连接一方重传 FIN 包。极端情况下，这一去一回就是两倍的 MSL 时长。如果主动关闭的一方跳过 time_wait 直接进入 closed，或者在 time_wait 停留的时长不足两倍的 MSL，那么当被动关闭的一方早于先发出的延迟包达到后，就可能出现类似下面的问题：<br>\1. 旧的 TCP 连接已经不存在了，系统此时只能返回 RST 包<br>\2. 新的 TCP 连接被建立起来了，延迟包可能干扰新的连接<br>不管是哪种情况都会让 TCP 不再可靠，所以 time_wait 状态有存在的必要性。<br>修改 net.ipv4.tcp_fin_timeout 也就是修改了 MSL 参数。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文主要介绍了异常日志、安全规约、单元测试、MySQL 数据库、工程结构等五部分关于编码规约的要求。由于篇幅有限，本专题仅提供上、下两篇文章，因此本文（专题下篇）仅覆盖了阿里代码规范的少数内容，更多内容请咨询本文作者。</p>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><p>参考文档《阿里巴巴 Java 开发手册（又名阿里巴巴 Java 代码规约）》。<br>参考书籍 《Effective Java Second Edition》Joshua Bloch。</p>
<blockquote>
<p>作者：周明耀</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/deconding-code-specification-part-2/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/deconding-code-specification-part-2/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 9 新特性概述</title>
    <url>/2019/12/26/Java-9-%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>Java 9 正式发布于 2017 年 9 月 21 日 。作为 Java8 之后 3 年半才发布的新版本，Java 9 带 来了很多重大的变化。其中最重要的改动是 Java 平台模块系统的引入。除此之外，还有一些新的特性。 本文对 Java9 中包含的新特性做了概括性的介绍，可以帮助你快速了解 Java 9。</p>
<a id="more"></a>

<h2 id="Java平台模块系统"><a href="#Java平台模块系统" class="headerlink" title="Java平台模块系统"></a>Java平台模块系统</h2><p>Java 平台模块系统，也就是 Project Jigsaw，把模块化开发实践引入到了 Java 平台中。在引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 jlink 工具，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。这对于目前流行的不可变基础设施的实践来说，镜像的大小的减少可以节省很多存储空间和带宽资源 。<br>模块化开发的实践在软件开发领域并不是一个新的概念。Java 开发社区已经使用这样的模块化实践有相当长的一段时间。主流的构建工具，包括 Apache Maven 和 Gradle 都支持把一个大的项目划分成若干个子项目。子项目之间通过不同的依赖关系组织在一起。每个子项目在构建之后都会产生对应的 JAR 文件。 在 Java9 中 ，已有的这些项目可以很容易的升级转换为 Java 9 模块 ，并保持原有的组织结构不变。<br>Java 9 模块的重要特征是在其工件（artifact）的根目录中包含了一个描述模块的 module-info.class 文 件。 工件的格式可以是传统的 JAR 文件或是 Java 9 新增的 JMOD 文件。这个文件由根目录中的源代码文件 module-info.java 编译而来。该模块声明文件可以描述模块的不同特征。模块声明文件中可以包含的内容如下：</p>
<ul>
<li>模块导出的包：使用 exports 可以声明模块对其他模块所导出的包。包中的 public 和 protected 类型，以及这些类型的 public 和 protected 成员可以被其他模块所访问。没有声明为导出的包相当于模块中的私有成员，不能被其他模块使用。</li>
<li>模块的依赖关系：使用 requires 可以声明模块对其他模块的依赖关系。使用 requires transitive 可 以把一个模块依赖声明为传递的。传递的模块依赖可以被依赖当前模块的其他模块所读取。 如果一个模块所导出的类型的型构中包含了来自它所依赖的模块的类型，那么对该模块的依赖应该声明为传递的。</li>
<li>服务的提供和使用：如果一个模块中包含了可以被 ServiceLocator 发现的服务接口的实现 ，需要使用 provides with 语句来声明具体的实现类 ；如果一个模块需要使用服务接口，可以使用 uses 语句来声明。</li>
</ul>
<p>代码清单 1 中给出了一个模块声明文件的示例。在该声明文件中，模块 com.mycompany.sample 导出了 Java 包 com.mycompany.sample。该模块依赖于模块 c om.mycompany.sample 。该模块也提供了服务接口 com.mycompany.common.DemoService 的实现类 c om.mycompany.sample.DemoServiceImpl 。</p>
<p>清单 1. 模块声明示例</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">module <span class="keyword">com</span>.mycompany.sample &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    exports <span class="keyword">com</span>.mycompany.sample<span class="comment">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    requires <span class="keyword">com</span>.mycompany.common<span class="comment">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    provides <span class="keyword">com</span>.mycompany.common.DemoService with</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">com</span>.mycompany.sample.DemoServiceImpl<span class="comment">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>模块系统中增加了模块路径的概念。模块系统在解析模块时，会从模块路径中进行查找。为了保持与之前 Java 版本的兼容性，CLASSPATH 依然被保留。所有的类型在运行时都属于某个特定的模块。对于从 CLASSPATH 中加载的类型，它们属于加载它们的类加载器对应的未命名模块。可以通过 Class 的 getModule()方法来获取到表示其所在模块的 Module 对象。<br>在 JVM 启动时，会从应用的根模块开始，根据依赖关系递归的进行解析，直到得到一个表示依赖关系的图。如果解析过程中出现找不到模块的情况，或是在模块路径的同一个地方找到了名称相同的模块，模块解析过程会终止，JVM 也会退出。Java 也提供了相应的 API 与模块系统进行交互。</p>
<h2 id="Jshell"><a href="#Jshell" class="headerlink" title="Jshell"></a>Jshell</h2><p>jshell 是 Java 9 新增的一个实用工具。jshell 为 Java 增加了类似 NodeJS 和 Python 中的读取-求值-打印循环（ Read-Evaluation-Print Loop ） 。 在 jshell 中 可以直接 输入表达式并查看其执行结果。当需要测试一个方法的运行效果，或是快速的对表达式进行求值时，jshell 都非常实用。只需要通过 jshell 命令启动 jshell，然后直接输入表达式即可。每个表达式的结果会被自动保存下来 ，以数字编号作为引用，类似 $1 和$2 这样的名称 。可以在后续的表达式中引用之前语句的运行结果。 在 jshell 中 ，除了表达式之外，还可以创建 Java 类和方法。jshell 也有基本的代码完成功能。<br>在代码清单 2 中，我们直接创建了一个方法 add。</p>
<p>清单 2. 在 jshell 中添加方法</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">jshell&gt; int <span class="keyword">add</span>(int x, int y) <span class="comment">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    ...&gt; return x + y;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    ...&gt; &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> | created <span class="function"><span class="keyword">method</span> <span class="title">add</span><span class="params">(int,int)</span></span></span></pre></td></tr></table></figure>

<p>接着就可以在 jshell 中直接使用这个方法，如 代码清单 3 所示。</p>
<p>清单 3. 在 jshell 中使用创建的方法</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">jshell&gt; add(<span class="number">1</span>, <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">$<span class="number">19</span> ==&gt; <span class="number">3</span></span></pre></td></tr></table></figure>

<h2 id="集合、Stream-和-Optional"><a href="#集合、Stream-和-Optional" class="headerlink" title="集合、Stream 和 Optional"></a>集合、Stream 和 Optional</h2><p>在集合上，Java 9 增加 了 List.of()、Set.of()、Map.of() 和 M ap.ofEntries()等工厂方法来创建不可变集合 ，如 代码清单 4 所示。</p>
<p>清单 4 . 创建不可变集合</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">List</span>.</span></span><span class="keyword">of</span><span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">List</span>.</span></span><span class="keyword">of</span>(<span class="string">"Hello"</span>, <span class="string">"World"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">List</span>.</span></span><span class="keyword">of</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Set</span>.</span></span><span class="keyword">of</span><span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Set</span>.</span></span><span class="keyword">of</span>(<span class="string">"Hello"</span>, <span class="string">"World"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Set</span>.</span></span><span class="keyword">of</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Map</span>.</span></span><span class="keyword">of</span><span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Map</span>.</span></span><span class="keyword">of</span>(<span class="string">"Hello"</span>, <span class="number">1</span>, <span class="string">"World"</span>, <span class="number">2</span>);</span></pre></td></tr></table></figure>

<p>Stream 中增加了新的方法 ofNullable、dropWhile、takeWhile 和 iterate。在 代码清单 5 中，流中包含了从 1 到 5 的 元素。断言检查元素是否为奇数。第一个元素 1 被删除，结果流中包含 4 个元素。</p>
<p>清单 5 . Stream 中的 dropWhile 方法示例</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">@Test</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> testDropWhile() throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">final</span> long count = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .dropWhile(i -&gt; i % <span class="number">2</span> != <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .count();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    assertEquals(<span class="number">4</span>, count);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Collectors 中增加了新的方法 filtering 和 flatMapping。在 代码清单 6 中，对于输入的 String 流 ，先通过 flatMapping 把 String 映射成 Integer 流 ，再把所有的 Integer 收集到一个集合中。</p>
<p>清单 6 . Collectors 的 flatMapping 方法示例</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Test</span></pre></td></tr><tr><td class="code"><pre><span class="line">public void test<span class="constructor">FlatMapping()</span> throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    final Set&lt;Integer&gt; result = <span class="module-access"><span class="module"><span class="identifier">Stream</span>.</span></span><span class="keyword">of</span>(<span class="string">"a"</span>, <span class="string">"ab"</span>, <span class="string">"abc"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .collect(<span class="module-access"><span class="module"><span class="identifier">Collectors</span>.</span></span>flat<span class="constructor">Mapping(<span class="params">v</span> -&gt; <span class="params">v</span>.<span class="params">chars</span>()</span>.boxed<span class="literal">()</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="module-access"><span class="module"><span class="identifier">Collectors</span>.</span></span><span class="keyword">to</span><span class="constructor">Set()</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span><span class="constructor">Equals(3, <span class="params">result</span>.<span class="params">size</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Optiona l 类中新增了 ifPresentOrElse、or 和 stream 等方法。在 代码清单 7 中，Optiona l 流中包含 3 个 元素，其中只有 2 个有值。在使用 flatMap 之后，结果流中包含了 2 个值。</p>
<p>清单 7 . Optional 的 stream 方法示例</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Test</span></pre></td></tr><tr><td class="code"><pre><span class="line">public void test<span class="constructor">Stream()</span> throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    final long count = <span class="module-access"><span class="module"><span class="identifier">Stream</span>.</span></span><span class="keyword">of</span>(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Optional</span>.</span></span><span class="keyword">of</span>(<span class="number">1</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Optional</span>.</span></span>empty<span class="literal">()</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Optional</span>.</span></span><span class="keyword">of</span>(<span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ).flat<span class="constructor">Map(Optional::<span class="params">stream</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        .count<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span><span class="constructor">Equals(2, <span class="params">count</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="进程-API"><a href="#进程-API" class="headerlink" title="进程 API"></a>进程 API</h2><p>Java 9 增加了 ProcessHandle 接口，可以对原生进程进行管理，尤其适合于管理长时间运行的进程。在使用 P rocessBuilder 来启动一个进程之后，可以通过 Process.toHandle()方法来得到一个 ProcessHandl e 对象的实例。通过 ProcessHandle 可以获取到由 ProcessHandle.Info 表 示的进程的基本信息，如命令行参数、可执行文件路径和启动时间等。ProcessHandle 的 onExit()方法返回一个 C ompletableFuture<ProcessHandle>对象，可以在进程结束时执行自定义的动作。 代码清单 8 中给出了进程 API 的使用示例。</p>
<p>清单 8 . 进程API 示例</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">final ProcessBuilder processBuilder = <span class="keyword">new</span> <span class="constructor">ProcessBuilder(<span class="string">"top"</span>)</span>.<span class="keyword">inherit</span><span class="constructor">IO()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">final ProcessHandle processHandle = processBuilder.start<span class="literal">()</span>.<span class="keyword">to</span><span class="constructor">Handle()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">processHandle.on<span class="constructor">Exit()</span>.<span class="keyword">when</span><span class="constructor">CompleteAsync((<span class="params">handle</span>, <span class="params">throwable</span>)</span> -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (throwable<span class="operator"> == </span>null) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(handle.pid<span class="literal">()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throwable.print<span class="constructor">StackTrace()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<h2 id="平台日志-API-和-服务"><a href="#平台日志-API-和-服务" class="headerlink" title="平台日志 API 和 服务"></a>平台日志 API 和 服务</h2><p>Java 9 允许为 JDK 和应用配置同样的日志实现。新增的 System.LoggerFinder 用来管理 JDK 使 用的日志记录器实现。JVM 在运行时只有一个系统范围的 LoggerFinder 实例。LoggerFinder 通 过服务查找机制来加载日志记录器实现。默认情况下，JDK 使用 java.logging 模块中的 java.util.logging 实现。通过 LoggerFinder 的 getLogger()方法就可以获取到表示日志记录器的 System.Logger 实现。应用同样可以使用 System.Logger 来记录日志。这样就保证了 JDK 和应用使用同样的日志实现。我们也可以通过添加自己的 System.LoggerFinder 实现来让 JDK 和应用使用 SLF4J 等其他日志记录框架。 代码清单 9 中给出了平台日志 API 的使用示例。</p>
<p>清单 9.使用平台日志 API</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final System.Logger LOGGER = System.getLogger(<span class="string">"Main"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(final <span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        LOGGER.<span class="built_in">log</span>(Level.INFO, <span class="string">"Run!"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="反应式流-（-Reactive-Streams-）"><a href="#反应式流-（-Reactive-Streams-）" class="headerlink" title="反应式流 （ Reactive Streams ）"></a>反应式流 （ Reactive Streams ）</h2><p>反应式编程的思想最近得到了广泛的流行。 在 Java 平台上有流行的反应式 库 RxJava 和 R eactor。反应式流规范的出发点是提供一个带非阻塞负压（ non-blocking backpressure ） 的异步流处理规范。反应式流规范的核心接口已经添加到了 Java9 中的 java.util.concurrent.Flow 类中。<br>Flow 中包含了 Flow.Publisher、Flow.Subscriber、Flow.Subscription 和 F low.Processor 等 4 个核心接口。Java 9 还提供了 SubmissionPublisher 作为 Flow.Publisher 的一个实现。RxJava 2 和 Reactor 都可以很方便的 与 Flow 类的核心接口进行互操作。</p>
<h2 id="变量句柄"><a href="#变量句柄" class="headerlink" title="变量句柄"></a>变量句柄</h2><p>变量句柄是一个变量或一组变量的引用，包括静态域，非静态域，数组元素和堆外数据结构中的组成部分等。变量句柄的含义类似于已有的方法句柄。变量句柄由 J ava 类 java.lang.invoke.VarHandle 来表示。可以使用类 j ava.lang.invoke.MethodHandles.Looku p 中的静态工厂方法来创建 VarHandle 对 象。通过变量句柄，可以在变量上进行各种操作。这些操作称为访问模式。不同的访问模式尤其在内存排序上的不同语义。目前一共有 31 种 访问模式，而每种访问模式都 在 VarHandle 中 有对应的方法。这些方法可以对变量进行读取、写入、原子更新、数值原子更新和比特位原子操作等。VarHandle 还 可以用来访问数组中的单个元素，以及把 byte[]数组 和 ByteBuffer 当成是不同原始类型的数组来访问。<br>在 代码清单 10 中，我们创建了访问 HandleTarget 类中的域 count 的变量句柄，并在其上进行读取操作。</p>
<p>清单 10. 变量句柄使用示例</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> HandleTarget &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public <span class="built_in">int</span> count = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> VarHandleTest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> HandleTarget handleTarget = <span class="keyword">new</span> <span class="constructor">HandleTarget()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> VarHandle varHandle;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Before</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void set<span class="constructor">Up()</span> throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.handleTarget = <span class="keyword">new</span> <span class="constructor">HandleTarget()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.varHandle = MethodHandles</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .lookup<span class="literal">()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            .find<span class="constructor">VarHandle(HandleTarget.<span class="params">class</span>, <span class="string">"count"</span>, <span class="params">int</span>.<span class="params">class</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Test</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void test<span class="constructor">Get()</span> throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">assert</span><span class="constructor">Equals(1, <span class="params">this</span>.<span class="params">varHandle</span>.<span class="params">get</span>(<span class="params">this</span>.<span class="params">handleTarget</span>)</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">assert</span><span class="constructor">Equals(1, <span class="params">this</span>.<span class="params">varHandle</span>.<span class="params">getVolatile</span>(<span class="params">this</span>.<span class="params">handleTarget</span>)</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">assert</span><span class="constructor">Equals(1, <span class="params">this</span>.<span class="params">varHandle</span>.<span class="params">getOpaque</span>(<span class="params">this</span>.<span class="params">handleTarget</span>)</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">assert</span><span class="constructor">Equals(1, <span class="params">this</span>.<span class="params">varHandle</span>.<span class="params">getAcquire</span>(<span class="params">this</span>.<span class="params">handleTarget</span>)</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="改进方法句柄（Method-Handle）"><a href="#改进方法句柄（Method-Handle）" class="headerlink" title="改进方法句柄（Method Handle）"></a>改进方法句柄（Method Handle）</h2><p>类 java.lang.invoke.MethodHandles 增加了更多的静态方法来创建不同类型的方法句柄。</p>
<ul>
<li>arrayConstructor：创建指定类型的数组。</li>
<li>arrayLength：获取指定类型的数组的大小。</li>
<li>varHandleInvoker 和 varHandleExactInvoker：调用 VarHandle 中的访问模式方法。</li>
<li>zero：返回一个类型的默认值。</li>
<li>empty：返 回 MethodType 的返回值类型的默认值。</li>
<li>loop、countedLoop、iteratedLoop、whileLoop 和 doWhileLoop：创建不同类型的循环，包括 for 循环、while 循环 和 do-while 循环。</li>
<li>tryFinally：把对方法句柄的调用封装在 try-finally 语句中。</li>
</ul>
<p>在 代码清单 11 中，我们使用 iteratedLoop 来创建一个遍历 S tring 类型迭代器的方法句柄，并计算所有字符串的长度的总和。</p>
<p>清单 11. 循环方法句柄使用示例</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> IteratedLoopTest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">body</span>(<span class="keyword">final</span> <span class="keyword">int</span> sum, <span class="keyword">final</span> String value) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> sum + value.length();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">@Test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> testIteratedLoop() throws Throwable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">final</span> MethodHandle iterator = MethodHandles.constant(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Iterator.<span class="keyword">class</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            List.of(<span class="string">"a"</span>, <span class="string">"bc"</span>, <span class="string">"def"</span>).iterator());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">final</span> MethodHandle init = MethodHandles.zero(<span class="keyword">int</span>.<span class="keyword">class</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">final</span> MethodHandle <span class="keyword">body</span> = MethodHandles</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .lookup()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .findStatic(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                IteratedLoopTest.<span class="keyword">class</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="string">"body"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                MethodType.methodType(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">int</span>.<span class="keyword">class</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">int</span>.<span class="keyword">class</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    String.<span class="keyword">class</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">final</span> MethodHandle iteratedLoop = MethodHandles</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .iteratedLoop(iterator, init, <span class="keyword">body</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        assertEquals(<span class="number">6</span>, iteratedLoop.invoke());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>在并发方面，类 CompletableFuture 中增加了几个新的方法。completeAsync 使用一个异步任务来获取结果并完成该 CompletableFuture。orTimeout 在 CompletableFuture 没有在给定的超时时间之前完成，使用 TimeoutException 异常来完成 CompletableFuture。completeOnTimeout 与 o rTimeout 类似，只不过它在超时时使用给定的值来完成 CompletableFuture。新的 Thread.onSpinWai t 方法在当前线程需要使用忙循环来等待时，可以提高等待的效率。</p>
<h2 id="Nashorn"><a href="#Nashorn" class="headerlink" title="Nashorn"></a>Nashorn</h2><p>Nashorn 是 Java 8 中引入的新的 JavaScript 引擎。Java 9 中的 Nashorn 已经实现了一些 ECMAScript 6 规范中的新特性，包括模板字符串、二进制和八进制字面量、迭代器 和 for..of 循环和箭头函数等。Nashorn 还提供了 API 把 ECMAScript 源代码解析成抽象语法树（ Abstract Syntax Tree，AST ） ，可以用来对 ECMAScript 源代码进行分析。</p>
<h2 id="I-O-流新特性"><a href="#I-O-流新特性" class="headerlink" title="I/O 流新特性"></a>I/O 流新特性</h2><p>类 java.io.InputStream 中增加了新的方法来读取和复制 InputStream 中包含的数据。</p>
<ul>
<li>readAllBytes：读取 InputStream 中的所有剩余字节。</li>
<li>readNBytes： 从 InputStream 中读取指定数量的字节到数组中。</li>
<li>transferTo：读取 InputStream 中的全部字节并写入到指定的 OutputStream 中 。</li>
</ul>
<p>代码清单 12 中给出了这些新方法的使用示例。</p>
<p>清单 12. InputStream 中的新方法使用示例</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class TestInputStream &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> InputStream inputStream;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> CONTENT = <span class="string">"Hello World"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Before</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setUp() <span class="keyword">throws</span> Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.inputStream =</span></pre></td></tr><tr><td class="code"><pre><span class="line">            TestInputStream.class.getResourceAsStream(<span class="string">"/input.txt"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Test</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> testReadAllBytes() <span class="keyword">throws</span> Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">final</span> <span class="keyword">String</span> content = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="keyword">this</span>.inputStream.readAllBytes());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        assertEquals(CONTENT, content);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Test</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> testReadNBytes() <span class="keyword">throws</span> Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">final</span> <span class="built_in">byte</span>[] data = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">5</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.inputStream.readNBytes(data, <span class="number">0</span>, <span class="number">5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        assertEquals(<span class="string">"Hello"</span>, <span class="keyword">new</span> <span class="keyword">String</span>(data));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Test</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> testTransferTo() <span class="keyword">throws</span> Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">final</span> ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.inputStream.transferTo(outputStream);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        assertEquals(CONTENT, outputStream.toString());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>ObjectInputFilter 可以对 ObjectInputStream 中 包含的内容进行检查，来确保其中包含的数据是合法的。可以使用 ObjectInputStream 的方法 setObjectInputFilter 来设置。ObjectInputFilter 在 进行检查时，可以检查如对象图的最大深度、对象引用的最大数量、输入流中的最大字节数和数组的最大长度等限制，也可以对包含的类的名称进行限制。</p>
<h2 id="改进应用安全性能"><a href="#改进应用安全性能" class="headerlink" title="改进应用安全性能"></a>改进应用安全性能</h2><p>Java 9 新增了 4 个 SHA- 3 哈希算法，SHA3-224、SHA3-256、SHA3-384 和 S HA3-512。另外也增加了通过 java.security.SecureRandom 生成使用 DRBG 算法的强随机数。 代码清单 13 中给出了 SHA-3 哈希算法的使用示例。</p>
<p>清单 13. SHA-3 哈希算法使用示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Hex;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SHA3</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">final</span> MessageDigest instance = MessageDigest.getInstance(<span class="string">"SHA3-224"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] digest = instance.digest(<span class="string">""</span>.getBytes());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(Hex.encodeHexString(digest));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h2><p>类 java.awt.Desktop 增加了新的与桌面进行互动的能力。可以使用 addAppEventListener 方法来添加不同应用事件的监听器，包括应用变为前台应用、应用隐藏或显示、屏幕和系统进入休眠与唤醒、以及 用户会话的开始和终止等。还可以在显示关于窗口和配置窗口时，添加自定义的逻辑。在用户要求退出应用时，可以通过自定义处理器来接受或拒绝退出请求。在 A WT 图像支持方面，可以在应用中使用多分辨率图像。</p>
<h2 id="统一-JVM-日志"><a href="#统一-JVM-日志" class="headerlink" title="统一 JVM 日志"></a>统一 JVM 日志</h2><p>Java 9 中 ，JVM 有了统一的日志记录系统，可以使用新的命令行选项-Xlog 来控制 JVM 上 所有组件的日志记录。该日志记录系统可以设置输出的日志消息的标签、级别、修饰符和输出目标等。Java 9 移除了在 Java 8 中 被废弃的垃圾回收器配置组合，同时 把 G1 设为默认的垃圾回收器实现。另外，CMS 垃圾回收器已经被声明为废弃。Java 9 也增加了很多可以通过 jcmd 调用的诊断命令。</p>
<h2 id="其他改动方面"><a href="#其他改动方面" class="headerlink" title="其他改动方面"></a>其他改动方面</h2><p>在 Java 语言本身，Java 9 允许在接口中使用私有方法。 在 try-with-resources 语句中可以使用 e ffectively-final 变量。 类 java.lang.StackWalker 可 以对线程的堆栈进行遍历，并且支持过滤和延迟访问。Java 9 把对 Unicode 的支持升级到了 8.0。ResourceBundle 加载属性文件的默认编码从 ISO-8859-1 改成了 UTF-8，不再需要使用 native2ascii 命 令来对属性文件进行额外处理。注解@Deprecated 也得到了增强，增加了 since 和 forRemoval 两 个属性，可以分别指定一个程序元素被废弃的版本，以及是否会在今后的版本中被删除。<br>在 代码清单 14 中，buildMessage 是接口 SayHi 中的私有方法，在默认方法 sayHi 中被使用。</p>
<p>清单 14. 接口中私有方法的示例</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>SayHi &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String buildMessage() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return <span class="string">"Hello"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void sayHi(final String message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="built_in"> default </span>void sayHi() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sayHi(buildMessage());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>作为 Java 平台最新的一个重大更新，Java 9 中的很多新特性，尤其模块系统，对于 Java 应用的开发会产生深远的影响。本文对 Java 9 中的新特性做了概括的介绍，可以作为了解 Java 9 的基础。这些新特性的相信内容，可以通过官方文档来进一步的了解。</p>
<h2 id="参考资源-resources"><a href="#参考资源-resources" class="headerlink" title="参考资源 (resources )"></a>参考资源 (resources )</h2><ul>
<li>参考 <a href="https://docs.oracle.com/javase/9/" target="_blank" rel="noopener"> Java 9 官方文档 </a> ，了解 Java 9 的更多内容 。</li>
<li>参考 <a href="https://docs.oracle.com/javase/9/docs/api/overview-summary.html" target="_blank" rel="noopener"> Java 9 官方 Java 文档 </a> ，了解 Java API 的细节。</li>
<li>了解 <a href="http://www.reactive-streams.org/" target="_blank" rel="noopener"> 反应式流规范 </a> 的更多内容 。</li>
</ul>
<blockquote>
<p>作者：成富</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-9/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-9/index.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>JUnit 5 简介：Jupiter API</title>
    <url>/2019/12/26/JUnit-5-%E7%AE%80%E4%BB%8B%EF%BC%9AJupiter-API/</url>
    <content><![CDATA[<p>本教程介绍 JUnit 5。我们首先介绍如何在您的计算机上安装并设置 JUnit 5。我将简要介绍 JUnit 5 的架构和组件，然后展示如何使用 JUnit Jupiter API 中的新注解、断言和前置条件。<br>在<a href="http://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part2-vintage-jupiter-extension-model/index.html" target="_blank" rel="noopener">第 2 部分</a>中，我们将更深入地介绍 JUnit 5，包括新的 JUnit Jupiter 扩展模型、参数注入、动态测试等。<br>在本教程中，我使用了 <a href="http://junit.org/junit5/docs/current/user-guide/#release-notes-5.0.2" target="_blank" rel="noopener">JUnit 5, Version 5.0.2</a>。</p>
<a id="more"></a>

<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>出于本教程的目的，我假设您熟悉以下软件的使用：</p>
<ul>
<li>Eclipse IDE</li>
<li>Maven</li>
<li>Gradle（可选）</li>
<li>Git</li>
</ul>
<p>要跟随示例进行操作，您应在计算机上安装 JDK 8、Eclipse、Maven、Gradle（可选）和 Git。如果缺少其中的任何工具，可使用下面的链接下载和安装它们：</p>
<ul>
<li><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">JDK 8 for Windows, Mac, and Linux。</a></li>
<li><a href="http://www.eclipse.org/downloads/eclipse-packages/" target="_blank" rel="noopener">Eclipse IDE for Windows, Mac, and Linux。</a></li>
<li><a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">Apache Maven for Windows, Mac, and Linux。</a></li>
<li><a href="https://gradle.org/install" target="_blank" rel="noopener">Gradle for Windows, Mac, and Linux。</a></li>
<li><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git for Windows, Mac, and Linux。</a></li>
</ul>
<p><a href="https://github.com/makotogo/HelloJUnit5" target="_blank" rel="noopener">从 GitHub 克隆示例应用程序</a></p>
<h3 id="JUnit-with-Gradle"><a href="#JUnit-with-Gradle" class="headerlink" title="JUnit with Gradle"></a>JUnit with Gradle</h3><p>在本教程中，我将展示如何使用 Gradle 运行 JUnit Jupiter 测试。并非必须观看该演示内容，但您可以通过它学习 Gradle。这是一个很好的构建系统，而且越来越流行。很快它就会进入您身旁的某个项目中 — 我敢保证！</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>人们倾向于将术语 <em>JUnit 5</em> 和 <em>JUnit Jupiter</em> 当作同义词使用。在大部分情况下，这种互换使用没有什么问题。但是，一定要认识到这两个术语是不同的。<em>JUnit Jupiter</em> 是使用 JUnit 5 编写测试内容的 API。<em>JUnit 5</em> 是一个项目名称（和版本），其 3 个主要模块关注不同的方面：JUnit Jupiter、JUnit Platform 和 JUnit Vintage。<br>当我提及 JUnit Jupiter 时，指的是编写单元测试的 API；提及 JUnit 5 时，指的是整个项目。</p>
<h2 id="JUnit-5-概述"><a href="#JUnit-5-概述" class="headerlink" title="JUnit 5 概述"></a>JUnit 5 概述</h2><p>以前的 JUnit 版本都是整体式的。除了在 4.4 版中包含 Hamcrest JAR，JUnit 基本来讲就是一个很大的 JAR 文件。测试内容编写者 — 像您我这样的开发人员 — 和工具供应商都使用它的 API，但后者使用很多内部 JUnit API。<br>大量使用内部 API 给 JUnit 的维护者造成了一些麻烦，并且留给他们推动该技术发展的选择余地不多。来自 <a href="http://junit.org/junit5/docs/current/user-guide/#api-evolution" target="_blank" rel="noopener"><em>JUnit 5 用户指南</em></a>：</p>
<blockquote>
<p><em>“在 JUnit 4 中，只有外部扩展编写者和工具构建者才使用最初作为内部结构而添加的许多功能。这让更改 JUnit 4 变得特别困难，有时甚至根本不可能。”</em></p>
</blockquote>
<p>JUnit Lambda（现在称为 JUnit 5）团队决定将 JUnit 重新设计为两个明确且不同的关注区域：</p>
<ul>
<li>一个是编写测试内容的 API。</li>
<li>一个是发现和运行这些测试的 API。</li>
</ul>
<p>这些关注区域现在已整合到 JUnit 5 的架构中，并且它们是明确分离的。图 1 演示了新架构（图像来自 <a href="https://blog.codefx.org/design/architecture/junit-5-architecture/" target="_blank" rel="noopener">Nicolai Parlog</a>）：</p>
<p>图 1. JUnit 5 的架构</p>
<p><img src="http://image.winrains.cn/2019/08/cf134-Figure-1.png" alt="JUnit 5 架构示意图。"><br>如果仔细查看图 1，就会发现 JUnit 5 的架构有多么强大。好了，让我们<em>仔细</em>看看这个架构。右上角的方框表明，对 JUnit 5 而言，JUnit Jupiter API 只是<em>另一个 API</em>！因为 JUnit Jupiter 的组件遵循新的架构，所以它们可应用 JUnit 5，但您可以轻松定义不同的测试框架。只要一个框架实现了 <code>TestEngine</code> 接口，就可以将它插入任何支持 <code>junit-platform-engine</code> 和 <code>junit-platform-launcher</code> API 的工具中！<br>我仍然认为 JUnit Jupiter 非常特殊（毕竟我即将用一整篇教程来介绍它），但 JUnit 5 团队完成的工作确实具有开创性。我只是想指出这一点。我们继续看看图 1，直到我们完全达成一致。</p>
<h3 id="使用-JUnit-Jupiter-编写测试内容"><a href="#使用-JUnit-Jupiter-编写测试内容" class="headerlink" title="使用 JUnit Jupiter 编写测试内容"></a>使用 JUnit Jupiter 编写测试内容</h3><p>就测试编写者而言，任何符合 JUnit 规范的测试框架（包括 JUnit Jupiter）都包含两个组件：</p>
<ul>
<li>我们为其编写测试的 API。</li>
<li>理解这个特定 API 的 JUnit <code>TestEngine</code> 实现。</li>
</ul>
<p>对于本教程，前者是 JUnit Jupiter API，后者是 JUnit Jupiter Test Engine。我将介绍这二者。</p>
<h4 id="JUnit-Jupiter-API"><a href="#JUnit-Jupiter-API" class="headerlink" title="JUnit Jupiter API"></a>JUnit Jupiter API</h4><p>作为开发人员，您将使用 JUnit Jupiter API 创建单元测试来测试您的应用程序代码。使用该 API 的基本特性 — 注解、断言等 — 是本部分教程的主要关注点。<br>JUnit Jupiter API 的设计让您可通过插入各种生命周期回调来扩展它的功能。您将在第 2 部分中了解如何使用这些回调完成有趣的工作，比如运行参数化测试，将参数传递给测试方法，等等。</p>
<h4 id="JUnit-Jupiter-Test-Engine"><a href="#JUnit-Jupiter-Test-Engine" class="headerlink" title="JUnit Jupiter Test Engine"></a>JUnit Jupiter Test Engine</h4><p>您将使用 JUnit Jupiter Test Engine 发现和执行 JUnit Jupiter 单元测试。该测试引擎实现了 JUnit Platform 中包含的 <code>TestEngine</code> 接口。可将 <code>TestEngine</code> 看作单元测试与用于启动它们的工具（比如 IDE）之间的桥梁。</p>
<h3 id="使用-JUnit-Platform-运行测试"><a href="#使用-JUnit-Platform-运行测试" class="headerlink" title="使用 JUnit Platform 运行测试"></a>使用 JUnit Platform 运行测试</h3><p>在 JUnit 术语中，运行单元测试的过程分为两部分：</p>
<ul>
<li><em>发现</em>测试和创建<em>测试计划</em>。</li>
<li><em>启动</em>测试计划，以 (1) 执行测试和 (2) 向用户报告结果。</li>
</ul>
<h4 id="用于发现测试的-API"><a href="#用于发现测试的-API" class="headerlink" title="用于发现测试的 API"></a>用于发现测试的 API</h4><p>用于发现测试和创建测试计划的 API 包含在 JUnit Platform 中，由一个 <code>TestEngine</code> 实现。该测试框架将测试发现功能封装到其 <code>TestEngine</code> 实现中。JUnit Platform 负责使用 IDE 和构建工具（比如 Gradle 和 Maven）发起测试发现流程。<br>测试发现的目的是创建测试计划，该计划中包含一个<em>测试规范</em>。测试规范包含以下组件：</p>
<ul>
<li><p>选择器</p>
<p>，比如：</p>
<ul>
<li>要扫描哪个包来寻找测试类</li>
<li>特定的类名称</li>
<li>特定的方法</li>
<li>类路径根文件夹</li>
</ul>
</li>
<li><p>过滤器</p>
<p>，比如：</p>
<ul>
<li>类名称模式（比如 “.*Test”）</li>
<li>标签（将在第 2 部分中讨论）</li>
<li>特定的测试引擎（比如 “junit-jupiter”）</li>
</ul>
</li>
</ul>
<p>测试计划是根据测试规范所发现的所有测试类、这些类中的测试方法、测试引擎等的分层视图。测试计划准备就绪后，就可以执行了。</p>
<h4 id="用于执行测试的-API"><a href="#用于执行测试的-API" class="headerlink" title="用于执行测试的 API"></a>用于执行测试的 API</h4><p>用于执行测试的 API 包含在 JUnit Platform 中，由一个或多个 <code>TestEngine</code> 实现。测试框架将测试执行功能封装在它们的 <code>TestEngine</code> 实现中，但 JUnit Platform 负责发起测试执行流程。通过 IDE 和构建工具（比如 Gradle 和 Maven）发起测试执行工作。<br>一个名为 <code>Launcher</code> 的 JUnit Platform 组件负责执行在测试发现期间创建的测试计划。某个流程 — 假设是您的 IDE — 通过 JUnit Platform（具体来讲是 <code>junit-platform-launcher</code> API）发起测试执行流程。这时，JUnit Platform 将测试计划连同 <code>TestExecutionListener</code> 一起传递给 <code>Launcher</code>。<code>TestExecutionListener</code> 将报告测试执行结果，从而在您的 IDE 中显示该结果。<br>测试执行流程的目的是向用户准确报告在测试运行时发生了哪些事件。这包括测试成功和失败报告，以及伴随失败而生成的消息，帮助用户理解所发生的事件。</p>
<h3 id="后向兼容性：JUnit-Vintage"><a href="#后向兼容性：JUnit-Vintage" class="headerlink" title="后向兼容性：JUnit Vintage"></a>后向兼容性：JUnit Vintage</h3><p>许多组织对 JUnit 3 和 4 进行了大力投资，因此无法承担向 JUnit 5 的大规模转换。了解到这一点后，JUnit 5 团队提供了 <code>junit-vintage-engine</code> 和 <code>junit-jupiter-migration-support</code> 组件来帮助企业进行迁移。<br>对 JUnit Platform 而言，JUnit Vintage 只是另一个测试框架，包含自己的 <code>TestEngine</code> 和 API（具体来讲是 JUnit 4 API）。<br>图 2 显示了各种 JUnit 5 包之间的依赖关系。</p>
<p>图 2. JUnit 5 包关系图</p>
<p><img src="http://image.winrains.cn/2019/08/f35e2-Figure-2.png" alt="JUnit 5 包示意图。"></p>
<h3 id="opentest4j-的用途"><a href="#opentest4j-的用途" class="headerlink" title="opentest4j 的用途"></a>opentest4j 的用途</h3><p>支持 JUnit 的测试框架在如何处理测试执行期间抛出的异常方面有所不同。JVM 上的测试没有统一标准，这是 JUnit 团队一直要面对的问题。除了 <code>java.lang.AssertionError</code>，测试框架还必须定义自己的异常分层结构，或者将自身与 JUnit 支持的异常结合起来（或者在某些情况下同时采取两种方法）。</p>
<p><strong>支持 opentest4j</strong>：要加入 Open Test Alliance for the JVM，或者提供反馈来帮助该联盟推进工作，请访问 <a href="https://github.com/ota4j-team/opentest4j" target="_blank" rel="noopener">opentest4j</a> Github 存储库并单击 <em>CONTRIBUTING.md</em> 链接。</p>
<p>为了解决一致性问题，JUnit 团队提议建立一个开源项目，该项目目前称为 Open Test Alliance for the JVM（JVM 开放测试联盟）。该联盟在此阶段仅是一个提案，它仅定义了初步的异常分层结构。但是，JUnit 5 使用 <code>opentest4j</code> 异常。（可在图 2 中看到这一点；请注意从 <code>junit-jupiter-api</code> 和 <code>junit-platform-engine</code> 包到 <code>opentest4j</code> 包的依赖线。）<br>现在您已基本了解各种 JUnit 5 组件如何结合在一起，是时候使用 JUnit Jupiter API 编写一些测试了！</p>
<h2 id="使用-JUnit-Jupiter-编写测试"><a href="#使用-JUnit-Jupiter-编写测试" class="headerlink" title="使用 JUnit Jupiter 编写测试"></a>使用 JUnit Jupiter 编写测试</h2><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>从 JUnit 4 开始，注解 (annotation) 就成为测试框架的核心特性，这一趋势在 JUnit 5 中得以延续。我无法介绍 JUnit 5 的所有注解，本节仅简要介绍最常用的注解。<br>首先，我将比较 JUnit 4 中与 JUnit 5 中的注解。JUnit 5 团队更改了一些注解的名称，让它们更直观，同时保持功能不变。如果您正在使用 JUnit 4，下表将帮助您适应这些更改。</p>
<p>表 1. JUnit 4 与 JUnit 5 中的注解比较</p>
<table>
<thead>
<tr>
<th>JUnit 5</th>
<th>JUnit 4</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Test</td>
<td>@Test</td>
<td>被注解的方法是一个测试方法。与 JUnit 4 相同。</td>
</tr>
<tr>
<td>@BeforeAll</td>
<td>@BeforeClass</td>
<td>被注解的（静态）方法将在当前类中的所有 @Test 方法前执行一次。</td>
</tr>
<tr>
<td>@BeforeEach</td>
<td>@Before</td>
<td>被注解的方法将在当前类中的每个 @Test 方法前执行。</td>
</tr>
<tr>
<td>@AfterEach</td>
<td>@After</td>
<td>被注解的方法将在当前类中的每个 @Test 方法后执行。</td>
</tr>
<tr>
<td>@AfterAll</td>
<td>@AfterClass</td>
<td>被注解的（静态）方法将在当前类中的所有 @Test 方法后执行一次。</td>
</tr>
<tr>
<td>@Disabled</td>
<td>@Ignore</td>
<td>被注解的方法不会执行（将被跳过），但会报告为已执行。</td>
</tr>
</tbody></table>
<h4 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h4><p>接下来看看一些使用这些注解的示例。尽管一些注解已在 JUnit 5 中重命名，但如果您使用过 JUnit 4，应熟悉它们的功能。清单 1 中的代码来自 <code>JUnit5AppTest.java</code>，可在 <a href="https://github.com/makotogo/HelloJUnit5" target="_blank" rel="noopener">HelloJUnit5</a> 示例应用程序中找到。</p>
<p>清单 1. 基本注解</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@RunWith</span>(JUnitPlatform.<span class="keyword">class</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@DisplayName</span>(<span class="string">"Testing using JUnit 5"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> JUnit5AppTest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(JUnit5AppTest.<span class="keyword">class</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> App classUnderTest;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">@BeforeAll</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> init() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Do something before ANY test is run in this class</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">@AfterAll</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> done() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Do something after ALL tests in this class are run</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">@BeforeEach</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setUp() throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        classUnderTest = <span class="keyword">new</span> App();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">@AfterEach</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> tearDown() throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        classUnderTest = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">@Test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">@DisplayName</span>(<span class="string">"Dummy test"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">void</span> aTest() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        log.info(<span class="string">"As written, this test will always pass!"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        assertEquals(<span class="number">4</span>, (<span class="number">2</span> + <span class="number">2</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">@Test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">@Disabled</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">@DisplayName</span>(<span class="string">"A disabled test"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> testNotRun() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    log.info(<span class="string">"This test will not run (it is disabled, silly)."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>看看上面突出显示行中的注解：</p>
<ul>
<li>第 1 行：<code>@RunWith</code> 连同它的参数 <code>JUnitPlatform.class</code>（一个基于 JUnit 4 且理解 JUnit Platform 的 <code>Runner</code>）让您可以在 Eclipse 内运行 JUnit Jupiter 单元测试。Eclipse 尚未原生支持 JUnit 5。未来，Eclipse 将提供原生的 JUnit 5 支持，那时我们不再需要此注解。</li>
<li>第 2 行：<code>@DisplayName</code> 告诉 JUnit 在报告测试结果时显示 <code>String</code> “Testing using JUnit 5”，而不是测试类的名称。</li>
<li>第 9 行：<code>@BeforeAll</code> 告诉 JUnit 在运行这个类中的所有 <code>@Test</code> 方法<em>之前</em>运行 <code>init()</code> 方法<strong>一次</strong>。</li>
<li>第 14 行：<code>@AfterAll</code> 告诉 JUnit 在运行这个类中的所有 <code>@Test</code> 方法<em>之后</em>运行 <code>done()</code> 方法<strong>一次</strong>。</li>
<li>第 19 行：<code>@BeforeEach</code> 告诉 JUnit 在此类中的<strong>每个</strong><code>@Test</code> 方法<em>之前</em>运行 <code>setUp()</code> 方法。</li>
<li>第 24 行：<code>@AfterEach</code> 告诉 JUnit 在此类中的<strong>每个</strong><code>@Test</code> 方法<em>之后</em>运行 <code>tearDown()</code> 方法。</li>
<li>第 29 行：<code>@Test</code> 告诉 JUnit，<code>aTest()</code> 方法是一个 JUnit Jupiter 测试方法。</li>
<li>第 37 行：<code>@Disabled</code> 告诉 JUnit 不运行此 <code>@Test</code> 方法，因为它已被禁用。</li>
</ul>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p><em>断言 (assertion)</em> 是 <code>org.junit.jupiter.api.Assertions</code> 类上的众多静态方法之一。断言用于测试一个条件，该条件必须计算为 <code>true</code>，测试才能继续执行。<br>如果断言失败，测试会在断言所在的代码行上停止，并生成断言失败报告。如果断言成功，测试会继续执行下一行代码。<br>表 2 中列出的所有 JUnit Jupiter 断言方法都接受一个可选的 <code>message</code> 参数（作为最后一个参数），以显示断言是否失败，而不是显示标准的缺省消息。</p>
<p>表 2. JUnit Jupiter 中的断言</p>
<table>
<thead>
<tr>
<th>断言方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>assertEquals(expected, actual)</code></td>
<td>如果 <em>expected</em> 不等于 <em>actual</em>，则断言失败。</td>
</tr>
<tr>
<td><code>assertFalse(booleanExpression)</code></td>
<td>如果 <em>booleanExpression</em> 不是 <code>false</code>，则断言失败。</td>
</tr>
<tr>
<td><code>assertNull(actual)</code></td>
<td>如果 <em>actual</em> 不是 <code>null</code>，则断言失败。</td>
</tr>
<tr>
<td><code>assertNotNull(actual)</code></td>
<td>如果 <em>actual</em> 是 <code>null</code>，则断言失败。</td>
</tr>
<tr>
<td><code>assertTrue(booleanExpression)</code></td>
<td>如果 <em>booleanExpression</em> 不是 <code>true</code>，则断言失败。</td>
</tr>
</tbody></table>
<p>清单 2 给出了一个使用这些断言的示例，该示例来自 HelloJUnit5 示例应用程序。</p>
<p>清单 2. 示例应用程序中的 JUnit Jupiter 断言</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">import static org.junit.jupiter.api.<span class="module-access"><span class="module"><span class="identifier">Assertions</span>.</span></span>assertEquals;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import static org.junit.jupiter.api.<span class="module-access"><span class="module"><span class="identifier">Assertions</span>.</span></span>assertFalse;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import static org.junit.jupiter.api.<span class="module-access"><span class="module"><span class="identifier">Assertions</span>.</span></span>assertNotNull;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import static org.junit.jupiter.api.<span class="module-access"><span class="module"><span class="identifier">Assertions</span>.</span></span>assertNull;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import static org.junit.jupiter.api.<span class="module-access"><span class="module"><span class="identifier">Assertions</span>.</span></span>assertTrue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">  @Test</span></pre></td></tr><tr><td class="code"><pre><span class="line">  @<span class="constructor">DisplayName(<span class="string">"Dummy test"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  void dummy<span class="constructor">Test()</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">int</span> expected = <span class="number">4</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">int</span> actual = <span class="number">2</span> + <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span><span class="constructor">Equals(<span class="params">expected</span>, <span class="params">actual</span>, <span class="string">"INCONCEIVABLE!"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Object nullValue = null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span><span class="constructor">False(<span class="params">nullValue</span> != <span class="params">null</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span><span class="constructor">Null(<span class="params">nullValue</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span><span class="constructor">NotNull(<span class="string">"A String"</span>, <span class="string">"INCONCEIVABLE!"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span><span class="constructor">True(<span class="params">nullValue</span> <span class="operator">==</span> <span class="params">null</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr></table></figure>

<p>看看上面突出显示行中的断言：</p>
<ul>
<li>第 13 行：<code>assertEquals</code>：如果第一个参数值 (4) 不等于第二个参数值 (2+2)，则断言失败。在报告断言失败时使用用户提供的消息（该方法的第 3 个参数）。</li>
<li>第 16 行：<code>assertFalse</code>：表达式 <code>nullValue != null</code> 必须为 <code>false</code>，否则断言失败。</li>
<li>第 17 行：<code>assertNull</code>：<code>nullValue</code> 参数必须为 <code>null</code>，否则断言失败。</li>
<li>第 18 行：<code>assertNotNull</code>：<code>String</code> 文字值 “A String” 不得为 <code>null</code>，否则断言失败并报告消息 “INCONCEIVABLE!”（而不是缺省的 “Assertion failed” 消息）。</li>
<li>第 19 行：<code>assertTrue</code>：如果表达式 <code>nullValue == null</code> 不等于 <code>true</code>，则断言失败。</li>
</ul>
<p>除了支持这些标准断言，JUnit Jupiter AP 还提供了多个新断言。下面介绍其中的两个。</p>
<h4 id="方法-assertAll"><a href="#方法-assertAll" class="headerlink" title="方法 @assertAll()"></a>方法 @assertAll()</h4><p>清单 3 中的 <code>@assertAll()</code> 方法给出了清单 2 中看到的相同断言，但包装在一个新的断言方法中：</p>
<p>清单 3. assertAll()</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> static org.junit.jupiter.api.Assertions.assertAll;</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Test</span></pre></td></tr><tr><td class="code"><pre><span class="line">@DisplayName(<span class="string">"Dummy test"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="literal">void</span> dummyTest() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  int expected = <span class="number">4</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  int actual = <span class="number">2</span> + <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Object nullValue = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .</span></pre></td></tr><tr><td class="code"><pre><span class="line">  assertAll(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">"Assert All of these"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function"><span class="params">()</span> -&gt;</span> assertEquals(expected, actual, <span class="string">"INCONCEIVABLE!"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function"><span class="params">()</span> -&gt;</span> assertFalse(nullValue != <span class="literal">null</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function"><span class="params">()</span> -&gt;</span> assertNull(nullValue),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function"><span class="params">()</span> -&gt;</span> assertNotNull(<span class="string">"A String"</span>, <span class="string">"INCONCEIVABLE!"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function"><span class="params">()</span> -&gt;</span> assertTrue(nullValue == <span class="literal">null</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p><code>assertAll()</code> 的有趣之处在于，它包含的<em>所有</em>断言都会执行，即使一个或多个断言失败也是如此。与此相反，在清单 2 中的代码中，如果<em>任何</em>断言失败，测试就会在该位置失败，意味着不会执行任何其他断言。</p>
<h4 id="方法-assertThrows"><a href="#方法-assertThrows" class="headerlink" title="方法 @assertThrows()"></a>方法 @assertThrows()</h4><p>在某些条件下，接受测试的类应抛出异常。JUnit 4 通过 <code>expected =</code> 方法参数或一个 <code>@Rule</code> 提供此能力。与此相反，JUnit Jupiter 通过 <code>Assertions</code> 类提供此能力，使它与其他断言更加一致。<br>我们将所预期的异常视为可以进行断言的另一个条件，因此 <code>Assertions</code> 包含处理此条件的方法。清单 4 引入了新的 <code>assertThrows()</code> 断言方法。</p>
<p>清单 4. assertThrows()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.assertThrows;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.assertEquals;</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"Empty argument"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd_ZeroOperands_EmptyArgument</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">long</span>[] numbersToSum = &#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    assertThrows(IllegalArgumentException<span class="class">.<span class="keyword">class</span>, () -&gt; <span class="title">classUnderTest</span>.<span class="title">add</span>(<span class="title">numbersToSum</span>))</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>请注意第 9 行：如果对 <code>classUnderTest.add()</code> 的调用没有抛出 <code>IllegalArgumentException</code>，则断言失败。</p>
<h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><p>前置条件 (Assumption) 与断言类似，但前置条件必须为 true，否则测试将<em>中止</em>。与此相反，当断言失败时，则将测试视为已<em>失败</em>。测试方法只应在某些条件 —<em>前置条件</em>下执行时，前置条件很有用。<br><em>前置条件</em>是 <code>org.junit.jupiter.api.Assumptions</code> 类的静态方法。要理解前置条件的价值，只需一个简单的示例。<br>假如您只想在星期五运行一个特定的单元测试（我假设您有自己的理由）：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Test</span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">DisplayName(<span class="string">"This test is only run on Fridays"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public void test<span class="constructor">Add_OnlyOnFriday()</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LocalDateTime ldt = <span class="module-access"><span class="module"><span class="identifier">LocalDateTime</span>.</span></span>now<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    assume<span class="constructor">True(<span class="params">ldt</span>.<span class="params">getDayOfWeek</span>()</span>.get<span class="constructor">Value()</span><span class="operator"> == </span><span class="number">5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Remainder of test (only executed if assumption holds)...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在此情况下，如果条件不成立（第 5 行），就不会执行 lambda 表达式的内容。</p>
<p>使用断言还是前置条件<br>二者的区别可能很细微，所以可使用这条经验法则：使用断言<em>检查一个测试方法的结果</em>。使用前置条件<em>确定是否运行测试方法</em>。不会将已中止的测试报告为失败，意味着这种失败不会中断构建工作。</p>
<p>请注意第 5 行：如果该条件不成立，则跳过该测试。在此情况下，该测试不是在星期五 (5) 运行的。这不会影响项目的 “绿色” 部分，而且不会导致构建失败；会跳过 <code>assumeTrue()</code> 后的测试方法中的所有代码。<br>如果在前置条件成立时仅应执行测试方法的一<em>部分</em>，可以使用 <code>assumingThat()</code> 方法编写上述条件，该方法使用 lambda 语法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Test</span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">DisplayName(<span class="string">"This test is only run on Fridays (with lambda)"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public void test<span class="constructor">Add_OnlyOnFriday_WithLambda()</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LocalDateTime ldt = <span class="module-access"><span class="module"><span class="identifier">LocalDateTime</span>.</span></span>now<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    assuming<span class="constructor">That(<span class="params">ldt</span>.<span class="params">getDayOfWeek</span>()</span>.get<span class="constructor">Value()</span><span class="operator"> == </span><span class="number">5</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="literal">()</span> -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="comment">// Execute this if assumption holds...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Execute this regardless</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>注意，无论 <code>assumingThat()</code> 中的前置条件成立与否，都会执行 lambda 表达式后的所有代码。</p>
<h3 id="嵌套单元测试，实现清晰的结构"><a href="#嵌套单元测试，实现清晰的结构" class="headerlink" title="嵌套单元测试，实现清晰的结构"></a>嵌套单元测试，实现清晰的结构</h3><p>在继续介绍下节内容之前，我想介绍在 JUnit 5 中编写单元测试的最后一个特性。<br>JUnit Jupiter API 允许您创建嵌套的类，以保持测试代码更清晰，这有助于让测试结果更易读。通过在主类中创建嵌套的测试类，可以创建更多的名称空间，这提供了两个主要优势：</p>
<ul>
<li>每个单元测试可以拥有自己的测试前和测试后生命周期。这让您能使用特殊条件创建要测试的类，从而测试极端情况。</li>
<li>单元测试方法的名称变得更简单。在 JUnit 4 中，所有测试方法都以对等形式存在，不允许重复的方法名（所以您最终会得到类似 <code>testMethodButOnlyUnderThisOrThatCondition_2()</code> 的方法名）。从 JUnit Jupiter 开始，只有嵌套类中的方法必须具有唯一的名称。清单 6 展示了这一优势。</li>
</ul>
<p>清单 5. 传递一个空或 null 数组引用</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@RunWith</span>(JUnitPlatform.class)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@DisplayName</span>(<span class="string">"Testing JUnit 5"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class JUnit5AppTest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">  @<span class="selector-tag">Nested</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  @<span class="selector-tag">DisplayName</span>(<span class="string">"When zero operands"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="selector-tag">class</span> <span class="selector-tag">JUnit5AppZeroOperandsTest</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// @Test methods go here...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>请注意第 6 行，其中的 <code>JUnit5AppZeroOperandsTest</code> 类可以拥有测试方法。任何测试的结果都会在父类 <code>JUnit5AppTest</code> 中以嵌套的形式显示。</p>
<h2 id="使用-JUnit-Platform-运行测试-1"><a href="#使用-JUnit-Platform-运行测试-1" class="headerlink" title="使用 JUnit Platform 运行测试"></a>使用 JUnit Platform 运行测试</h2><p>能编写单元测试很不错，但如果不能运行它们，就没有什么意义了。本节展示如何在 Eclipse 中运行 JUnit 测试，首先使用 Maven，然后从命令行使用 Gradle。<br>下面的视频展示了如何从 GitHub 克隆示例应用程序代码，并在 Eclipse 中运行测试。在该视频中，我还展示了如何从命令行以及 Eclipse 内使用 Maven 和 Gradle 运行单元测试。Eclipse 对 Maven 和 Gradle 都提供了很好的支持。<br><strong>应用 3 种工具运行单元测试</strong></p>
<p><a href="http://v.youku.com/v_show/id_XMjk1NTYzMTQ3Ng==.html" target="_blank" rel="noopener">点击查看视频演示</a></p>
<p>下面将提供一些简要的说明，但该视频提供了更多细节。观看该视频，了解如何：</p>
<ul>
<li>从 GitHub 克隆 HelloJUnit5 示例应用程序。</li>
<li>将应用程序导入 Eclipse 中。</li>
<li>从 Eclipse 内的 HelloJUnit5 应用程序运行一个 JUnit 测试。</li>
<li>使用 Maven 从命令行运行 HelloJUnit5 单元测试。</li>
<li>使用 Gradle 从命令行运行 HelloJUnit5 单元测试。</li>
</ul>
<h3 id="克隆-HelloJUnit5-示例应用程序"><a href="#克隆-HelloJUnit5-示例应用程序" class="headerlink" title="克隆 HelloJUnit5 示例应用程序"></a>克隆 HelloJUnit5 示例应用程序</h3><p>要理解教程的剩余部分，您需要从 GitHub 克隆示例应用程序。为此，可打开一个终端窗口 (Mac) 或命令提示 (Windows)，导航到您希望放入代码的目录，然后输入以下命令：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/makotogo/HelloJUnit5</span></pre></td></tr></table></figure>

<p>现在您的机器上已拥有该代码，可以在 Eclipse IDE 内运行 JUnit 测试了。接下来介绍如何运行测试。</p>
<h3 id="在-Eclipse-IDE-中运行单元测试"><a href="#在-Eclipse-IDE-中运行单元测试" class="headerlink" title="在 Eclipse IDE 中运行单元测试"></a>在 Eclipse IDE 中运行单元测试</h3><p>如果您已跟随该视频进行操作，应该已将代码导入 Eclipse 中。现在，在 Eclipse 中打开 <strong>Project Explorer</strong> 视图，展开 HelloJUnit5 项目，直至看到 <code>src/test/java</code> 路径下的 <code>JUnit5AppTest</code> 类。<br>打开 <code>JUnit5AppTest.java</code> 并验证 <code>class</code> 定义前的下面这个注解（以下代码的第 3 行）：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">@RunWith(JUnitPlatform.<span class="keyword">class</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">public</span> <span class="symbol">class</span> <span class="symbol">JUnit5AppTest</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>现在右键单击 <code>JUnit5AppTest</code> 并选择 <strong>Run As &gt; JUnit Test</strong>。单元测试运行时，JUnit 视图将会出现。您现在已准备好完成本教程的练习。</p>
<h3 id="使用-Maven-运行单元测试"><a href="#使用-Maven-运行单元测试" class="headerlink" title="使用 Maven 运行单元测试"></a>使用 Maven 运行单元测试</h3><p>打开一个终端窗口 (Mac) 或命令提示 (Windows)，导航到您将 HelloJUnit5 应用程序克隆到的目录，然后输入以下命令：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mvn </span>test</span></pre></td></tr></table></figure>

<p>这会启动 Maven 构建并运行单元测试。您的输出应类似于：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ mvn clean test</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Scanning <span class="keyword">for</span> projects<span class="built_in">..</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Building HelloJUnit5 1.0.2</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] --- maven-clean-plugin:2.5:clean (default-clean) @ HelloJUnit5 ---</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Deleting /Users/sperry/home/development/projects/learn/HelloJUnit5/target</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] --- maven-resources-plugin:2.6:resources (default-resources) @ HelloJUnit5 ---</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Using <span class="string">'UTF-8'</span> encoding <span class="keyword">to</span> copy filtered resources.</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] skip non existing resourceDirectory /Users/sperry/home/development/projects/learn/HelloJUnit5/src/main/resources</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] --- maven-compiler-plugin:3.6.1:compile (default-compile) @ HelloJUnit5 ---</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Changes detected - recompiling the module!</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Compiling 2 source files <span class="keyword">to</span> /Users/sperry/home/development/projects/learn/HelloJUnit5/target/classes</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] --- maven-resources-plugin:2.6:testResources (default-testResources) @ HelloJUnit5 ---</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Using <span class="string">'UTF-8'</span> encoding <span class="keyword">to</span> copy filtered resources.</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] skip non existing resourceDirectory /Users/sperry/home/development/projects/learn/HelloJUnit5/src/test/resources</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] --- maven-compiler-plugin:3.6.1:testCompile (default-testCompile) @ HelloJUnit5 ---</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Changes detected - recompiling the module!</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Compiling 2 source files <span class="keyword">to</span> /Users/sperry/home/development/projects/learn/HelloJUnit5/target/test-classes</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] --- maven-surefire-plugin:2.19:test (default-test) @ HelloJUnit5 ---</span></pre></td></tr><tr><td class="code"><pre><span class="line">-------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line"> T E S T S</span></pre></td></tr><tr><td class="code"><pre><span class="line">-------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">Nov 28, 2017 6:04:49 PM org.junit.vintage.engine.discovery.DefensiveAllDefaultPossibilitiesBuilder<span class="variable">$DefensiveAnnotatedBuilder</span> buildRunner</span></pre></td></tr><tr><td class="code"><pre><span class="line">WARNING: Ignoring test class using JUnitPlatform runner: com.makotojava.learn.hellojunit5.solution.JUnit5AppTest</span></pre></td></tr><tr><td class="code"><pre><span class="line">Running com.makotojava.learn.hellojunit5.solution.JUnit5AppTest</span></pre></td></tr><tr><td class="code"><pre><span class="line">Nov 28, 2017 6:04:49 PM org.junit.vintage.engine.discovery.DefensiveAllDefaultPossibilitiesBuilder<span class="variable">$DefensiveAnnotatedBuilder</span> buildRunner</span></pre></td></tr><tr><td class="code"><pre><span class="line">WARNING: Ignoring test class using JUnitPlatform runner: com.makotojava.learn.hellojunit5.solution.JUnit5AppTest</span></pre></td></tr><tr><td class="code"><pre><span class="line">Tests run: 1, Failures: 0, Errors: 0, Skipped: 1, Time elapsed: 0.038 sec - <span class="keyword">in</span> com.makotojava.learn.hellojunit5.solution.JUnit5AppTest</span></pre></td></tr><tr><td class="code"><pre><span class="line">Results :</span></pre></td></tr><tr><td class="code"><pre><span class="line">Tests run: 1, Failures: 0, Errors: 0, Skipped: 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] BUILD SUCCESS</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Total time: 3.741 s</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Finished at: 2017-11-28T18:04:50-06:00</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Final Memory: 21M/255M</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ------------------------------------------------------------------------</span></pre></td></tr></table></figure>

<h3 id="Running-unit-tests-with-Gradle"><a href="#Running-unit-tests-with-Gradle" class="headerlink" title="Running unit tests with Gradle"></a>Running unit tests with Gradle</h3><p>Open a terminal window (Mac) or command prompt (Windows), navigate to the directory where you cloned the HelloJUnit5 application, and enter this command:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gradle clean <span class="built_in">test</span></span></pre></td></tr></table></figure>

<p>The output should look like this:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ gradle clean test</span></pre></td></tr><tr><td class="code"><pre><span class="line">Starting a Gradle Daemon (subsequent builds will be faster)</span></pre></td></tr><tr><td class="code"><pre><span class="line">:clean</span></pre></td></tr><tr><td class="code"><pre><span class="line">:compileJava</span></pre></td></tr><tr><td class="code"><pre><span class="line">:processResources NO-SOURCE</span></pre></td></tr><tr><td class="code"><pre><span class="line">:classes</span></pre></td></tr><tr><td class="code"><pre><span class="line">:compileTestJava</span></pre></td></tr><tr><td class="code"><pre><span class="line">:processTestResources NO-SOURCE</span></pre></td></tr><tr><td class="code"><pre><span class="line">:testClasses</span></pre></td></tr><tr><td class="code"><pre><span class="line">:junitPlatformTest</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="builtin-name">ERROR</span> StatusLogger <span class="literal">No</span> log4j2 configuration file found. Using<span class="built_in"> default </span>configuration:<span class="built_in"> logging </span>only errors <span class="keyword">to</span> the console.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Test <span class="builtin-name">run</span> finished after 10097 ms</span></pre></td></tr><tr><td class="code"><pre><span class="line">[         7 containers found      ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[         5 containers skipped    ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[         2 containers started    ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[         0 containers aborted    ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[         2 containers successful ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[         0 containers failed     ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[        10 tests found           ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[        10 tests skipped         ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[         0 tests started         ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[         0 tests aborted         ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[         0 tests successful      ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[         0 tests failed          ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">:test SKIPPED</span></pre></td></tr><tr><td class="code"><pre><span class="line">BUILD SUCCESSFUL</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total time: 21.014 secs</span></pre></td></tr></table></figure>

<h2 id="测试练习"><a href="#测试练习" class="headerlink" title="测试练习"></a>测试练习</h2><p>现在您已了解 JUnit Jupiter，查看了代码示例，并观看了视频（希望您已跟随视频进行操作）。非常棒，但没有什么比动手编写代码更有用了！在第 1 部分的最后一节，您将完成以下任务：</p>
<ul>
<li>编写 JUnit Jupiter API 单元测试。</li>
<li>运行单元测试。</li>
<li>实现 <code>App</code> 类，让您的单元测试通过检查。</li>
</ul>
<p>采用真正的测试驱动开发 (TDD) 方式，首先编写单元测试，运行它们，并会观察到它们全部失败了。然后编写实现，直到单元测试通过，这时您就大功告成了。<br>注意，<code>JUnit5AppTest</code> 类仅提供了两个现成的测试方法。首次运行该类时，二者都是 “绿色” 的。要完成这些练习，您需要添加剩余的代码，包括用于告诉 JUnit 运行哪些测试方法的注解。记住，如果没有正确配备一个类或方法，JUnit 将跳过它。<br>如果遇到困难，请查阅 <code>com.makotojava.learn.hellojunit5.solution</code> 包来寻找解决方案。</p>
<h3 id="1、编写-JUnit-Jupiter-单元测试"><a href="#1、编写-JUnit-Jupiter-单元测试" class="headerlink" title="1、编写 JUnit Jupiter 单元测试"></a><strong>1、编写 JUnit Jupiter 单元测试</strong></h3><p>首先从 <code>JUnit5AppTest.java</code> 开始。打开此文件并按照 Javadoc 注解中的指示操作。<br><strong>提示</strong>：使用 Eclipse 中的 Javadoc 视图读取测试指令。要打开 Javadoc 视图，可以转到 <strong>Window &gt; Show View &gt; Javadoc</strong>。您应该看到 Javadoc 视图。根据您设置工作区的方式，该窗口可能出现在任意多个位置。在我的工作区中，该窗口与图 3 中的屏幕截图类似，出现在 IDE 右侧的编辑器窗口下方：</p>
<p>图 3. Javadoc 视图</p>
<p><img src="http://image.winrains.cn/2019/08/95f8f-Figure-3.png" alt="Javadoc 视图的屏幕截图。"><br>编辑器窗口中显示了具有原始 HTML 标记的 Javadoc 注解，但在 Javadoc 窗口中，已将其格式化，因此更易于阅读。</p>
<h3 id="2、在-Eclipse-中运行单元测试"><a href="#2、在-Eclipse-中运行单元测试" class="headerlink" title="2、在 Eclipse 中运行单元测试"></a><strong>2、在 Eclipse 中运行单元测试</strong></h3><p>如果您像我一样，您会使用 IDE 执行以下工作：</p>
<ul>
<li>编写单元测试。</li>
<li>编写单元测试所测试的实现内容。</li>
<li>运行初始测试（使用 IDE 的原生 JUnit 支持）。</li>
</ul>
<p>JUnit 5 提供了一个名为 <code>JUnitPlatform</code> 的类，它允许您在 Eclipse 中运行 JUnit 5 测试。</p>
<p><strong>Eclipse 中的 JUnit 5</strong>：Eclipse 目前能理解 JUnit 4，但尚未提供对 JUnit 5 的原生支持。幸运的是，这对大部分单元测试而言都不是什么大问题！除非您需要使用 JUnit 4 一些更复杂的特性，否则要编写单元测试来全面检查您的应用程序代码，<code>JUnitPlatform</code> 类就足够了。</p>
<p>要在 Eclipse 中运行测试，需要确保您的计算机上拥有示例应用程序。为此，最轻松的方法是从 GitHub 克隆 HelloJUnit5 应用程序，然后将它导入 Eclipse 中。（因为本教程的视频展示了如何这么做，所以这里将跳过细节，仅提供操作步骤。）<br>确保您克隆了 GitHub 存储库，然后将代码导入 Eclipse 中作为新的 Maven 项目。<br>将该项目导入 Eclipse 中后，打开 <strong>Project Explorer</strong> 视图并展开 <code>src/main/test</code> 节点，直至看到 <code>JUnit5AppTest</code>。要以 JUnit 测试的形式运行它，可以右键单击它，选择 <strong>Run As &gt; JUnit Test</strong>。</p>
<h3 id="3、实现-App-类，直到单元测试通过检查"><a href="#3、实现-App-类，直到单元测试通过检查" class="headerlink" title="3、实现 App 类，直到单元测试通过检查"></a><strong>3、实现 App 类，直到单元测试通过检查</strong></h3><p><code>App</code> 的单一 <code>add()</code> 方法提供的功能很容易理解，而且在设计上非常简单。我不希望复杂应用程序的业务逻辑阻碍您对 JUnit Jupiter 的学习。<br>单元测试通过后，您就大功告成了！记住，如果遇到困难，可以在 <code>com.makotojava.learn.hellojunit5.solution</code> 包中查找解决方案。</p>
<h2 id="第-1-部分小结"><a href="#第-1-部分小结" class="headerlink" title="第 1 部分小结"></a>第 1 部分小结</h2><p>在 JUnit 5 教程的前半部分中，我介绍了 JUnit 5 的架构和组件，并详细介绍了 JUnit Jupiter API。我们逐个介绍了 JUnit 5 中最常用的注解、断言和前置条件，而且通过一个快速练习演示了如何在 Eclipse、Maven 和 Gradle 中运行测试。<br>在<a href="http://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part2-vintage-jupiter-extension-model/index.html" target="_blank" rel="noopener">第 2 部分</a>中，您将了解 JUnit 5 的一些高级特性：</p>
<ul>
<li>JUnit Jupiter 扩展模型</li>
<li>方法参数注入</li>
<li>参数化测试</li>
</ul>
<blockquote>
<p>作者：J Steven Perry</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/index.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>JUnit</tag>
      </tags>
  </entry>
  <entry>
    <title>JUnit 5 简介：Vintage 和 JUnit Jupiter 扩展模型</title>
    <url>/2019/12/26/JUnit-5-%E7%AE%80%E4%BB%8B%EF%BC%9AVintage-%E5%92%8C-JUnit-Jupiter-%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>在本教程的<a href="https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/index.html" target="_blank" rel="noopener">第 1 部分</a>中，我介绍了 JUnit 5 的设置说明，以及 JUnit 5 的架构和组件。还介绍了如何使用 JUnit Jupiter API 中的新特性，包括注解、断言和前置条件。<br>在本部分中，您将熟悉组成全新 JUnit 5 的另外两个模块：JUnit Vintage 和 JUnit Jupiter 扩展模型。我将介绍如何使用这些组件实现参数注入、参数化测试、动态测试和自定义注解等。<br>与第 1 部分中一样，我将介绍如何使用 Maven 和 Gradle 运行测试。<br>请注意，本教程的示例基于 <a href="http://junit.org/junit5/docs/current/user-guide/#release-notes-5.0.2" target="_blank" rel="noopener">JUnit 5,Version 5.0.2</a>。</p>
<a id="more"></a>

<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>假设您熟悉以下软件的使用：</p>
<ul>
<li>Eclipse IDE</li>
<li>Maven</li>
<li>Gradle（可选）</li>
<li>Git</li>
</ul>
<p>要跟随示例进行操作，您应在计算机上安装 JDK 8、Eclipse、Maven、Gradle（可选）和 Git。如果缺少其中的任何工具，可使用下面的链接下载和安装它们：</p>
<ul>
<li><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">JDK 8 for Windows, Mac, and Linux。</a></li>
<li><a href="http://www.eclipse.org/downloads/eclipse-packages/" target="_blank" rel="noopener">Eclipse IDE for Windows, Mac, and Linux。</a></li>
<li><a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">Apache Maven for Windows, Mac, and Linux。</a></li>
<li><a href="https://gradle.org/install" target="_blank" rel="noopener">Gradle for Windows, Mac, and Linux。</a></li>
<li><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git for Windows, Mac, and Linux。</a></li>
</ul>
<p><a href="https://github.com/makotogo/HelloJUnit5Part2" target="_blank" rel="noopener">从 GitHub 克隆示例应用程序</a></p>
<h2 id="JUnit-Vintage"><a href="#JUnit-Vintage" class="headerlink" title="JUnit Vintage"></a>JUnit Vintage</h2><p>升级到新的重要软件版本始终存在风险，但是在这里，升级不仅是个好主意，而且还很安全。<br>因为许多组织对 JUnit 4 （甚至对 JUnit 3）进行了大力投资，所以 JUnit 5 的开发团队创建了 JUnit Vintage 包，其中包含 JUnit Vintage 测试引擎。JUnit Vintage 可确保现有 JUnit 测试能与使用 JUnit Jupiter 创建的新测试一同运行。<br>JUnit 5 的架构还支持同时运行多个测试引擎：可以一同运行 JUnit Vintage 测试引擎和任何其他兼容 JUnit 5 的测试引擎。<br>现在您已了解 JUnit Vintage，可能想知道它的工作原理。图 1 给出了来自第 1 部分的 JUnit 5 依赖关系图，展示了 JUnit 5 中各种包之间的关系。</p>
<p>图 1. JUnit 5 依赖关系图</p>
<p><img src="http://image.winrains.cn/2019/08/c0740-Figure-1.png" alt="JUnit 5 依赖关系示意图。"><br>图 1 中间行中所示的 JUnit Vintage 旨在提供一条通往 JUnit Jupiter 的 “平稳升级路径”。两个 JUnit 5 模块依赖于 JUnit Vintage：</p>
<ul>
<li><strong>junit-platform-runner</strong> 提供一个 <code>Runner</code>，允许在 JUnit 4 环境（比如 Eclipse）中执行测试。</li>
<li><strong>junit-jupiter-migration-support</strong> 提供了后向兼容性，允许您选择 JUnit 4 <code>Rule</code>。</li>
</ul>
<p>JUnit Vintage 本身由两个模块组成：</p>
<ul>
<li><strong>junit:junit</strong> 是用于 JUnit 3 和 JUnit 4 的 API。</li>
<li><strong>junit-vintage-engine</strong> 是在 JUnit Platform 上运行 JUnit 3 和 JUnit 4 测试的测试引擎。</li>
</ul>
<p>因为 JUnit Platform 允许多个测试引擎同时运行，所以可让您的 JUnit 3 和 JUnit 4 测试与使用 JUnit Jupiter 编写的测试并列运行。教程后面将介绍如何执行该操作。<br>在 Eclipse、Maven 和 Gradle 中运行测试之前，我们花点时间复习一下基本单元测试的概念。我们将分析在 JUnit 3 和 JUnit 4 中编写的测试。</p>
<h3 id="JUnit-3-中的测试"><a href="#JUnit-3-中的测试" class="headerlink" title="JUnit 3 中的测试"></a>JUnit 3 中的测试</h3><p>使用 JUnit 3 编写的测试将按原样在 JUnit Platform 上运行。只需将 <code>junit-vintage</code> 依赖项包含在构建版本中，其他部分就能直接运行。<br>在示例应用程序中，您将看到已包含在示例应用程序中的 Maven POM (<code>pom.xml</code>) 和 Gradle 构建文件 (<code>build.gradle</code>)，所以您可立即运行这些测试。<br>清单 1 给出了示例应用程序的一个 JUnit 3 测试的<em>部分</em>内容。它位于 <code>com.makotojava.learn.junit3</code> 包中的 <code>src/test/java</code> 树中。</p>
<p>清单 1. HelloJunit5Part2 示例应用程序的 JUnit 3 测试用例</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> PersonDaoBeanTest extends TestCase &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> ApplicationContext ctx;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> PersonDaoBean classUnderTest;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    protected void set<span class="constructor">Up()</span> throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ctx = <span class="keyword">new</span> <span class="constructor">AnnotationConfigApplicationContext(TestSpringConfiguration.<span class="params">class</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        classUnderTest = ctx.get<span class="constructor">Bean(PersonDaoBean.<span class="params">class</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    protected void tear<span class="constructor">Down()</span> throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        DataSource dataSource = (DataSource) ctx.get<span class="constructor">Bean(<span class="string">"dataSource"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (dataSource instanceof EmbeddedDatabase) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ((EmbeddedDatabase) dataSource).shutdown<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void test<span class="constructor">FindAll()</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">classUnderTest</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;Person&gt; people = classUnderTest.find<span class="constructor">All()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">people</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">assert</span><span class="constructor">False(<span class="params">people</span>.<span class="params">isEmpty</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">assert</span><span class="constructor">Equals(5, <span class="params">people</span>.<span class="params">size</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>JUnit 3 测试用例扩展了 JUnit 3 API 类 <code>TestCase</code>（第 3 行），每个测试方法必须以单词 <code>test</code> 开头（第 23 行）。<br>要在 Eclipse 中运行此测试，可右键单击 Package Explorer 视图中的测试类，选择 <strong>Run As &gt; Junit Test</strong>。<br>教程后面将介绍如何使用 Maven 和 Gradle 运行此测试。</p>
<h3 id="JUnit-4-中的测试"><a href="#JUnit-4-中的测试" class="headerlink" title="JUnit 4 中的测试"></a>JUnit 4 中的测试</h3><p>您的 JUnit 4 测试按原样在 JUnit Platform 上运行。只需将 <code>junit-vintage</code> 依赖项包含在构建版本中，就能直接运行它。<br>示例应用程序中包含的 Maven POM 和 Gradle 构建文件 (<code>build.gradle</code>) 中已包含该依赖项，所以您可立即运行这些测试。<br>清单 2 给出了示例应用程序的一个 JUnit 4 测试的<em>部分</em>内容。它位于 <code>com.makotojava.learn.junit4</code> 包中的 <code>src/test/java</code> 树中。</p>
<p>清单 2. HelloJunit5Part2 示例应用程序的 JUnit 4 测试用例</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> PersonDaoBeanTest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> ApplicationContext ctx;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> PersonDaoBean classUnderTest;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Before</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void set<span class="constructor">Up()</span> throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ctx = <span class="keyword">new</span> <span class="constructor">AnnotationConfigApplicationContext(TestSpringConfiguration.<span class="params">class</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        classUnderTest = ctx.get<span class="constructor">Bean(PersonDaoBean.<span class="params">class</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @After</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void tear<span class="constructor">Down()</span> throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        DataSource dataSource = (DataSource) ctx.get<span class="constructor">Bean(<span class="string">"dataSource"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (dataSource instanceof EmbeddedDatabase) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ((EmbeddedDatabase) dataSource).shutdown<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Test</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void find<span class="constructor">All()</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">classUnderTest</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;Person&gt; people = classUnderTest.find<span class="constructor">All()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">people</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">assert</span><span class="constructor">False(<span class="params">people</span>.<span class="params">isEmpty</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">assert</span><span class="constructor">Equals(5, <span class="params">people</span>.<span class="params">size</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>JUnit 4 测试用例以单词 <code>Test</code> 结尾（第 3 行），每个测试方法使用 <code>@Test</code> 注解（第 23 行）。<br>要在 Eclipse 中运行此测试，可右键单击 Package Explorer 视图中的测试类，选择 <strong>Run As &gt; Junit Test</strong>。<br>教程后面将介绍如何使用 Maven 和 Gradle 运行此测试。</p>
<h3 id="对迁移到-JUnit-Jupiter-的支持"><a href="#对迁移到-JUnit-Jupiter-的支持" class="headerlink" title="对迁移到 JUnit Jupiter 的支持"></a>对迁移到 JUnit Jupiter 的支持</h3><p>从 JUnit 4 迁移<br>打算从 JUnit4 迁移？一定要通读<a href="http://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4" target="_blank" rel="noopener">文档</a>。</p>
<p><code>junit-jupiter-migration-support</code> 包中包含了用于后向兼容性的一些选定 <code>Rule</code>，所以如果您对 JUnit 4 规则进行了大力投资也不用担心。在 JUnit 5 中，您将使用 JUnit Jupiter 扩展模型实现 JUnit 4 中的各种规则提供的相同行为。下一节将介绍如何完成该工作。</p>
<h2 id="JUnit-Jupiter-扩展模型"><a href="#JUnit-Jupiter-扩展模型" class="headerlink" title="JUnit Jupiter 扩展模型"></a>JUnit Jupiter 扩展模型</h2><p>通过使用 JUnit 扩展模型，现在任何开发人员或工具供应商都能扩展 JUnit 的核心功能。<br>要想真正认识到 JUnit Jupiter 扩展模型的开创性，需要理解它<em>如何</em>扩展 JUnit 4 的核心功能。如果您已理解这一点，可跳过下一节。</p>
<h3 id="扩展-JUnit-4-的核心功能"><a href="#扩展-JUnit-4-的核心功能" class="headerlink" title="扩展 JUnit 4 的核心功能"></a>扩展 JUnit 4 的核心功能</h3><p>过去，希望扩展 JUnit 4 核心功能的开发人员或工具供应商会使用 <code>Runner</code> 和 <code>@Rule</code>。<br><em>Runner</em> 通常是 <code>BlockJUnit4ClassRunner</code> 的子类，用于提供 JUnit 中没有直接提供的某种行为。目前有许多第三方 <code>Runner</code>，比如用于运行基于 Spring 的单元测试的 <code>SpringJUnit4ClassRunner</code>，以及用于处理单元测试中 Mockito 对象的 <code>MockitoJUnitRunner</code>。<br>必须在测试类级别上使用 <code>@RunWith</code> 注解来声明 <code>Runner</code>。<code>@RunWith</code> 接受一个参数：<code>Runner</code> 的实现类。因为每个测试类最多只能拥有一个 <code>Runner</code>，所以每个测试类最多也只能拥有一个扩展点。<br>为了解决 <code>Runner</code> 概念的这一内置限制，JUnit 4.7 引入了 <code>@Rule</code>。一个测试类可声明多个 <code>@Rule</code>，这些规则可在测试方法级别和类级别上运行（而 <code>Runner</code> 只能在类级别上运行）。<br>鉴于 JUnit 4.7 的 <code>@Rule</code> 解决方法很好地处理了大部分情况，您可能想知道为什么我们还需要新的 JUnit Jupiter 扩展模型。下节将解释其中的原因。</p>
<h3 id="特性与扩展"><a href="#特性与扩展" class="headerlink" title="特性与扩展"></a>特性与扩展</h3><p>选择 JUnit 5 还是 JUnit Jupiter？<br>JUnit 5 和 JUnit Jupiter 之间的区别可能很容易让人混淆。提及 JUnit 5 时，我谈论的是 JUnit 的最新版本，其中包含一种新的 JUnit 方法和架构。而提及 JUnit Jupiter 时，我指的是用于编写测试的 API。</p>
<p>JUnit 5 的一个核心原则是[扩展点优于特性](<a href="https://github.com/junit-team/junit5/wiki/Core-Principles#prefer-" target="_blank" rel="noopener">https://github.com/junit-team/junit5/wiki/Core-Principles#prefer-</a> extension-points-over-features)。<br>这意味着尽管 JUnit <em>能</em>为工具供应商和开发人员提供各种特性，但 JUnit 5 团队更喜欢在架构中提供扩展点。这样第三方（无论是工具供应商、测试编写者还是其他任何人）就能在这些点上编写各种<em>扩展</em>。根据 JUnit Wiki 的解释，优先选择扩展点有 3 个原因：</p>
<ul>
<li>JUnit 不是，也不会尝试成为一个无所不包的实用程序。</li>
<li>第三方开发人员知道他们的需求，并且编写代码来满足自己需求的速度比 JUnit 团队响应某个特性请求的速度更快。</li>
<li>API 一旦发布，就<em>很难更改</em>。</li>
</ul>
<p>接下来我将解释如何扩展 JUnit Jupiter API，首先从扩展点开始。</p>
<h3 id="扩展点和测试生命周期"><a href="#扩展点和测试生命周期" class="headerlink" title="扩展点和测试生命周期"></a>扩展点和测试生命周期</h3><p>一个扩展点对应于 JUnit test 生命周期中一个预定义的点。从 Java™ 语言的角度讲，<em>扩展点</em>是您实现并向 JUnit 注册（激活）的回调接口。因此，<em>扩展点</em>是回调接口，<em>扩展</em>是该接口的实现。<br>在本教程中，我将把已实现的扩展点回调接口称为<em>扩展</em>。<br>一旦注册您的扩展，就会将其激活。在测试生命周期中合适的点上，JUnit 将使用回调接口调用它。<br>表 1 总结了 JUnit Jupiter 扩展模型中的扩展点。</p>
<p>表 1. 扩展点</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AfterAllCallback</td>
<td>定义 API 扩展，希望在调用所有测试后让测试容器执行额外的行为。</td>
</tr>
<tr>
<td>AfterEachCallback</td>
<td>定义 API 扩展，希望在调用每个测试方法后让测试执行额外的行为。</td>
</tr>
<tr>
<td>AfterTestExecutionCallback</td>
<td>定义 API 扩展，希望在执行每个测试后让测试立即执行额外的行为。</td>
</tr>
<tr>
<td>BeforeAllCallback</td>
<td>定义 API 扩展，希望在调用所有测试前让测试容器执行额外的行为。</td>
</tr>
<tr>
<td>BeforeEachCallback</td>
<td>定义 API 扩展，希望在调用每个测试前让测试执行额外的行为。</td>
</tr>
<tr>
<td>BeforeTestExecutionCallback</td>
<td>定义 API 扩展，希望在执行每个测试前让测试立即执行额外的行为。</td>
</tr>
<tr>
<td>ParameterResolver</td>
<td>定义 API 扩展，希望在运行时动态解析参数。</td>
</tr>
<tr>
<td>TestExecutionExceptionHandler</td>
<td>定义 API 扩展，希望处理在测试执行期间抛出的异常。</td>
</tr>
</tbody></table>
<p>表 1 中列出的扩展点回调接口已在示例应用程序的 <code>JUnit5ExtensionShowcase</code> 类中实现。可在 <code>com.makotojava.learn.junit5</code> 包中的 <code>test/src</code> 树中找到该类。</p>
<h3 id="创建扩展"><a href="#创建扩展" class="headerlink" title="创建扩展"></a>创建扩展</h3><p>要创建扩展，只需实现该扩展点的回调接口。假设我想创建一个在每个测试方法运行之前就运行的扩展。在此情况下，我只需要实现 <code>BeforeEachCallback</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeforeEachCallbackExtension</span> <span class="keyword">implements</span> <span class="title">BeforeEachCallback</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeEach</span><span class="params">(ExtensionContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Implementation goes here</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>实现扩展点接口后，需要激活它，这样 JUnit 才能在测试生命周期中合适的点调用它。通过注册扩展来激活它。</p>
<h3 id="激活扩展"><a href="#激活扩展" class="headerlink" title="激活扩展"></a>激活扩展</h3><p>要激活上述扩展，只需使用 <code>@ExtendWith</code> 注解注册它：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@ExtendWith</span>(MyBeforeEachCallbackExtension.class)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class MyTestClass &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @<span class="selector-tag">Test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">myTestMethod</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Test code here</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void someOtherTestMethod() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Test code here</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>当 <code>MyTestClass</code> 运行时，在执行每个 <code>@Test</code> 方法前，会调用 <code>MyBeforeEachCallbackExtension</code>。<br>注意，这种注册扩展的风格是<em>声明性的</em>。JUnit 还提供了一种自动注册机制，它使用了 Java 的 <code>ServiceLoader</code> 机制。此处不会详细介绍该机制，但 JUnit 5 用户指南的<a href="http://junit.org/junit5/docs/current/user-guide/#extensions-registration" target="_blank" rel="noopener">扩展模型</a>部分中提供了大量的有用信息。</p>
<h2 id="参数注入"><a href="#参数注入" class="headerlink" title="参数注入"></a>参数注入</h2><p>假设您想将一个参数传递给 <code>@Test</code> 方法。您如何完成该工作？下面我们就学习一下。</p>
<h3 id="ParameterResolver-接口"><a href="#ParameterResolver-接口" class="headerlink" title="ParameterResolver 接口"></a>ParameterResolver 接口</h3><p>如果所编写的测试方法在其签名中包含一个参数，则必须将该参数解析为一个实际对象，然后 JUnit 才能调用该方法。一种<em>乐观的场景</em>如下所示：JUnit (1) 寻找一个实现 <code>ParameterResolver</code> 接口的已注册扩展；(2) 调用它来解析该参数；(3) 然后调用您的测试方法，传入解析后的参数值。<br><code>ParameterResolver</code> 接口包含 2 个方法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">package</span> <span class="selector-tag">org</span><span class="selector-class">.junit</span><span class="selector-class">.jupiter</span><span class="selector-class">.api</span><span class="selector-class">.extension</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">static</span> <span class="selector-tag">org</span><span class="selector-class">.junit</span><span class="selector-class">.platform</span><span class="selector-class">.commons</span><span class="selector-class">.meta</span><span class="selector-class">.API</span><span class="selector-class">.Usage</span><span class="selector-class">.Experimental</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.Parameter</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.junit</span><span class="selector-class">.platform</span><span class="selector-class">.commons</span><span class="selector-class">.meta</span><span class="selector-class">.API</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="keyword">API</span>(<span class="keyword">Experimental</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface ParameterResolver extends Extension &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">boolean</span> <span class="selector-tag">supportsParameter</span>(<span class="selector-tag">ParameterContext</span> <span class="selector-tag">parameterContext</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                              <span class="selector-tag">ExtensionContext</span> <span class="selector-tag">extensionContext</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="selector-tag">throws</span> <span class="selector-tag">ParameterResolutionException</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">Object</span> <span class="selector-tag">resolveParameter</span>(<span class="selector-tag">ParameterContext</span> <span class="selector-tag">parameterContext</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="selector-tag">ExtensionContext</span> <span class="selector-tag">extensionContext</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="selector-tag">throws</span> <span class="selector-tag">ParameterResolutionException</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Jupiter 测试引擎需要解析您的测试类中的一个参数时，它首先会调用 <code>supports()</code> 方法，查看该扩展是否能处理这种参数类型。如果 <code>supports()</code> 返回 <code>true</code>，则 Jupiter 测试引擎调用 <code>resolve()</code> 来获取正确类型的 <code>Object</code>，随后在调用测试方法时会使用该对象。<br>如果未找到能处理该参数类型的扩展，您会看到一条与下面类似的消息：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">org<span class="selector-class">.junit</span><span class="selector-class">.jupiter</span><span class="selector-class">.api</span><span class="selector-class">.extension</span><span class="selector-class">.ParameterResolutionException</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">No ParameterResolver registered <span class="keyword">for</span> parameter [java<span class="selector-class">.lang</span><span class="selector-class">.String</span> arg0] <span class="keyword">in</span> executable</span></pre></td></tr><tr><td class="code"><pre><span class="line">[public void com<span class="selector-class">.makotojava</span><span class="selector-class">.learn</span><span class="selector-class">.junit5</span>.PersonDaoBeanTest<span class="variable">$WhenDatabaseIsPopulated</span>.findAllByLastName(java<span class="selector-class">.lang</span>.String)].</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr></table></figure>

<h3 id="创建-ParameterResolver-实现"><a href="#创建-ParameterResolver-实现" class="headerlink" title="创建 ParameterResolver 实现"></a>创建 ParameterResolver 实现</h3><p>要创建一个 <code>ParameterResolver</code>，您只需实现该接口：</p>
<p>清单 3. Person 对象的 ParameterResolver 扩展点实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.extension.ExtensionContext;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.extension.ParameterContext;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.extension.ParameterResolutionException;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.extension.ParameterResolver;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.makotojava.learn.junit.Person;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.makotojava.learn.junit.PersonGenerator;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratedPersonParameterResolver</span> <span class="keyword">implements</span> <span class="title">ParameterResolver</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(ParameterContext parameterContext, ExtensionContext extensionContext)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">      <span class="keyword">throws</span> ParameterResolutionException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> parameterContext.getParameter().getType() == Person<span class="class">.<span class="keyword">class</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">resolveParameter</span><span class="params">(ParameterContext parameterContext, ExtensionContext extensionContext)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">      <span class="keyword">throws</span> ParameterResolutionException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> PersonGenerator.createPerson();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在这个特定的用例中，如果参数的类型是 <code>Person</code>（第 14 行），则 <code>supports()</code> 返回 <code>true</code>。JUnit 需要将参数解析为 <code>Person</code> 对象时，它调用 <code>resolve()</code>，后者返回一个新生成的 <code>Person</code> 对象（第 20 行）。</p>
<h3 id="使用-ParameterResolver-实现"><a href="#使用-ParameterResolver-实现" class="headerlink" title="使用 ParameterResolver 实现"></a>使用 ParameterResolver 实现</h3><p>要使用 <code>ParameterResolver</code>，必须向 JUnit Jupiter 测试引擎注册它。与前面的演示一样，可使用 <code>@ExtendWith</code> 注解完成注册工作。</p>
<p>清单 4. 使用 ParameterResolver</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@<span class="constructor">DisplayName(<span class="string">"Testing PersonDaoBean"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">ExtendWith(GeneratedPersonParameterResolver.<span class="params">class</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> PersonDaoBeanTest extends AbstractBaseTest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Test</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @<span class="constructor">DisplayName(<span class="string">"Add generated Person should succeed - uses Parameter injection"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void add(Person person) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">classUnderTest</span>, <span class="string">"PersonDaoBean reference cannot be null."</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      Person personAdded = classUnderTest.add(person);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">personAdded</span>, <span class="string">"Add failed but should have succeeded"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">personAdded</span>.<span class="params">getId</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      perform<span class="constructor">PersonAssertions(<span class="params">person</span>.<span class="params">getLastName</span>()</span>, person.get<span class="constructor">FirstName()</span>, person.get<span class="constructor">Age()</span>, person.get<span class="constructor">EyeColor()</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          person.get<span class="constructor">Gender()</span>, personAdded);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>PersonDaoBeanTest</code> 类运行时，它将向 Jupiter 测试引擎注册 <code>GeneratedPersonParameterResolver</code>。每次需要解析一个参数时，就会调用自定义 <code>ParameterResolver</code>。<br>扩展有一个影响范围 - 类级别或方法级别。<br>在这个特定的用例中，我选择在类级别注册扩展（第 2 行）。在类级别注册意味着，接受<em>任何</em>参数的任何测试方法都会导致 JUnit 调用 <code>GeneratedPersonParameterResolver</code> 扩展。如果参数类型为 <code>Person</code>，则返回一个已生成的 <code>Person</code> 对象并将其传递给测试方法（第 8 行）。<br>要将扩展的范围缩小到单个方法，可按如下方式注册扩展：</p>
<p>清单 5. 仅将 ParameterResolver 用于单个方法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Test</span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">DisplayName(<span class="string">"Add generated Person should succeed - uses Parameter injection"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">ExtendWith(GeneratedPersonParameterResolver.<span class="params">class</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public void add(Person person) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">classUnderTest</span>, <span class="string">"PersonDaoBean reference cannot be null."</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person personAdded = classUnderTest.add(person);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">personAdded</span>, <span class="string">"Add failed but should have succeeded"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">personAdded</span>.<span class="params">getId</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    perform<span class="constructor">PersonAssertions(<span class="params">person</span>.<span class="params">getLastName</span>()</span>, person.get<span class="constructor">FirstName()</span>, person.get<span class="constructor">Age()</span>, person.get<span class="constructor">EyeColor()</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        person.get<span class="constructor">Gender()</span>, personAdded);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>现在，系统只会调用该扩展来解析 <code>add()</code> 测试方法的参数。如果类中的任何其他测试方法需要参数解析，它们需要一个不同的 <code>ParameterResolver</code>。<br>注意，任何给定类的特定范围上只能有一个<code>ParameterResolver</code>。举例而言，如果您已经为在类级别上声明的 <code>Person</code> 对象提供了一个 <code>ParameterResolver</code>，并在同一个类中为在方法级别上声明的对象提供了另一个 <code>ParameterResolver</code>，那么 JUnit 就不知道使用哪一个。最终会看到以下消息来表明这种模糊性：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">org<span class="selector-class">.junit</span><span class="selector-class">.jupiter</span><span class="selector-class">.api</span><span class="selector-class">.extension</span><span class="selector-class">.ParameterResolutionException</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">Discovered multiple competing ParameterResolvers <span class="keyword">for</span> parameter</span></pre></td></tr><tr><td class="code"><pre><span class="line">[com<span class="selector-class">.makotojava</span><span class="selector-class">.learn</span><span class="selector-class">.junit</span><span class="selector-class">.Person</span> arg0] <span class="keyword">in</span> executable</span></pre></td></tr><tr><td class="code"><pre><span class="line">[public void com<span class="selector-class">.makotojava</span><span class="selector-class">.learn</span><span class="selector-class">.junit5</span>.PersonDaoBeanTest<span class="variable">$WhenDatabaseIsPopulated</span>.update(com<span class="selector-class">.makotojava</span><span class="selector-class">.learn</span><span class="selector-class">.junit</span>.Person)]: .</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr></table></figure>

<h3 id="准备看个视频来放松一下？"><a href="#准备看个视频来放松一下？" class="headerlink" title="准备看个视频来放松一下？"></a>准备看个视频来放松一下？</h3><p>下节将介绍参数化测试，但首先让我们用少许时间进行一些实践学习。下面的视频演示了如何在 JUnit 5 中使用 <code>ParameterResolver</code> 和 <code>@ParameterizedTest</code> 注解来测试基于 Spring 的应用程序。<br><strong>JUnit5 的高级特性</strong></p>
<p><a href="http://v.youku.com/v_show/id_XMjk1NTY4MTkxNg==.html" target="_blank" rel="noopener">点击查看视频演示</a></p>
<h2 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h2><p><em>参数化测试</em>是指多次调用 <code>@Test</code> 方法，但每次都使用不同的参数值。参数化测试必须使用 <code>@ParameterizedTest</code> 进行注解，而且必须为其参数指定一个<em>来源</em>。<br>JUnit Jupiter 提供了多个来源。每个来源指定一个 <code>@ArgumentsSource</code>，也就是一个 <code>ArgumentsProvider</code> 实现。本节将介绍如何使用 3 个来源：</p>
<ul>
<li><code>@ValueSource</code></li>
<li><code>@EnumSource</code></li>
<li><code>@MethodSource</code></li>
</ul>
<p>每个来源都在所允许的数据类型的易用性与灵活性之间进行了折中。最容易使用但最不灵活（仅限于一个 Java 原语子集）的是 <code>@ValueSource</code>。最灵活的是 <code>@MethodSource</code>，允许您使用所选的任何复杂对象来参数化测试方法。（注意，<code>@MethodSource</code> 也是最难使用的。）</p>
<h3 id="ValueSource"><a href="#ValueSource" class="headerlink" title="@ValueSource"></a>@ValueSource</h3><p>在 <code>@ValueSource</code> 中，您指定单个文字值数组，系统将这些文字值 — 一次一个地 — 提供给您的 <code>@ParameterizedTest</code> 方法。<br>语法类似于：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@ParameterizedTest</span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">ValueSource(<span class="params">longs</span> = &#123; 1L, 2L, 3L, 4L, 5L &#125;)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public void find<span class="constructor">ById(Long <span class="params">id</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">classUnderTest</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person personFound = classUnderTest.find<span class="constructor">ById(<span class="params">id</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">personFound</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span><span class="constructor">Equals(<span class="params">id</span>, <span class="params">personFound</span>.<span class="params">getId</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>首先您告诉 JUnit，<code>findById()</code> 方法是一个 <code>@ParameterizedTest</code>，如上面第 1 行所示。然后使用数组初始化器语法来指定数组，如第 2 行所示。JUnit 将调用 <code>findById()</code> 测试方法，每次将数组中的下一个 <code>long</code> 传递给该方法（第 3 行），直到用完数组。您可像任何 Java 方法参数一样使用该参数（第 5 行）。<br>作为数组名所提供的 <code>@ValueSource</code> 属性名必须全部采用小写，而且必须与其末尾有字母 <em>s</em> 的类型相匹配。例如，<code>ints</code> 与 <code>int</code> 数组匹配，<code>strings</code> 与 <code>String</code> 数组匹配，等等。<br>并不支持所有的原语类型，仅支持以下类型：</p>
<ul>
<li><code>String</code></li>
<li><code>int</code></li>
<li><code>long</code></li>
<li><code>double</code></li>
</ul>
<h3 id="EnumSource"><a href="#EnumSource" class="headerlink" title="@EnumSource"></a>@EnumSource</h3><p>在 <code>@EnumSource</code> 中，您指定一个 <code>enum</code>，JUnit — 一次一个地 — 将其中的值提供给 <code>@ParameterizedTest</code> 方法。<br>语法类似于：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@ParameterizedTest</span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">EnumSource(PersonTestEnum.<span class="params">class</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public void find<span class="constructor">ById(PersonTestEnum <span class="params">testPerson</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">classUnderTest</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person person = testPerson.get<span class="constructor">Person()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person personFound = classUnderTest.find<span class="constructor">ById(<span class="params">person</span>.<span class="params">getId</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">personFound</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    perform<span class="constructor">PersonAssertions(<span class="params">person</span>.<span class="params">getLastName</span>()</span>, person.get<span class="constructor">FirstName()</span>, person.get<span class="constructor">Age()</span>, person.get<span class="constructor">EyeColor()</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        person.get<span class="constructor">Gender()</span>, personFound);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>首先您告诉 JUnit，<code>findById()</code> 方法是一个 <code>@ParameterizedTest</code>，如第 1 行所示。然后指定该 <code>enum</code> 的 Java 类，如第 2 行所示。JUnit 将调用 <code>findById()</code> 测试方法，每次将下一个 <code>enum</code> 值传递给该方法（第 3 行），直到用完该 <code>enum</code>。您可像任何 Java 方法参数一样使用该参数（第 5 行）。<br>注意，<code>PersonTestEnum</code> 类包含在本教程的配套示例应用程序中。它位于 <code>com.makotojava.learn.junit</code> 包中的 <code>src/test/java</code> 树中。</p>
<h3 id="MethodSource"><a href="#MethodSource" class="headerlink" title="@MethodSource"></a>@MethodSource</h3><p>使用注解 <code>@MethodSource</code>，可以指定您喜欢的任何复杂对象作为测试方法的参数类型。语法类似于：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@ParameterizedTest</span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">MethodSource(<span class="params">value</span> = <span class="string">"personProvider"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public void find<span class="constructor">ById(Person <span class="params">paramPerson</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">classUnderTest</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    long id = paramPerson.get<span class="constructor">Id()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person personFound = classUnderTest.find<span class="constructor">ById(<span class="params">id</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">personFound</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    perform<span class="constructor">PersonAssertions(<span class="params">paramPerson</span>.<span class="params">getLastName</span>()</span>, paramPerson.get<span class="constructor">FirstName()</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        paramPerson.get<span class="constructor">Age()</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        paramPerson.get<span class="constructor">EyeColor()</span>, paramPerson.get<span class="constructor">Gender()</span>, personFound);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>@MethodSource</code> 的 <code>names</code> 属性用于指定一个或多个方法名，这些方法为测试方法提供参数。一个方法来源的返回类型必须是 <code>Stream</code>、<code>Iterator</code>、<code>Iterable</code> 或数组。此外，提供者方法必须声明为 <code>static</code>，所以不能将它用在 <code>@Nested</code> 测试类内（至少截至 JUnit 5 Milestone 5 时不能这么做）。<br>在上面的示例中，<code>personProvider</code> 方法（来自示例应用程序）类似于：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static Iterator&lt;Person&gt; person<span class="constructor">Provider()</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    PersonTestEnum<span class="literal">[]</span> testPeople = <span class="module-access"><span class="module"><span class="identifier">PersonTestEnum</span>.</span></span>values<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person<span class="literal">[]</span> people = <span class="keyword">new</span> Person<span class="literal">[<span class="identifier">testPeople</span>.<span class="identifier">length</span>]</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (<span class="built_in">int</span> aa = <span class="number">0</span>; aa &lt; testPeople.length; aa++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      people<span class="literal">[<span class="identifier">aa</span>]</span> = testPeople<span class="literal">[<span class="identifier">aa</span>]</span>.get<span class="constructor">Person()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">as</span><span class="constructor">List(<span class="params">people</span>)</span>.iterator<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>假设您想为测试方法添加一个额外的参数提供者。可以这样声明它：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@ParameterizedTest</span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">MethodSource(<span class="params">value</span> = &#123; <span class="string">"personProvider"</span>, <span class="string">"additionalPersonProvider"</span> &#125;)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public void find<span class="constructor">ById(Person <span class="params">paramPerson</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">classUnderTest</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    long id = paramPerson.get<span class="constructor">Id()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person personFound = classUnderTest.find<span class="constructor">ById(<span class="params">id</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">personFound</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    perform<span class="constructor">PersonAssertions(<span class="params">paramPerson</span>.<span class="params">getLastName</span>()</span>, paramPerson.get<span class="constructor">FirstName()</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        paramPerson.get<span class="constructor">Age()</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        paramPerson.get<span class="constructor">EyeColor()</span>, paramPerson.get<span class="constructor">Gender()</span>, personFound);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们使用数组初始化器语法指定这些方法（第 2 行），而且将按您指定的顺序调用各个方法，最后调用的是 <code>additionalPersonProvider()</code>。</p>
<h3 id="自定义显示名称"><a href="#自定义显示名称" class="headerlink" title="自定义显示名称"></a>自定义显示名称</h3><p>参数化测试的缺省显示名称包含测试索引（一个从 1 开始的迭代编号），以及该参数的 <code>String</code> 表示。如果测试类中有多个测试方法，那么输出容易让人混淆。幸运的是，可以通过向 <code>@ParameterizedTest</code> 注解提供任何以下属性值来自定义输出：</p>
<ul>
<li><em>{index}</em>：从 1 开始的索引（当前测试迭代 ）。</li>
<li><em>{arguments}</em>：完整的参数列表，使用逗号分隔。</li>
<li><em>{0}, {1} …</em>：一个特定的参数（0 是第一个，依此类推）。</li>
</ul>
<p>举例而言，假设提供了一个包含 5 个 <code>long</code> 的数组。在此情况下，可像这样注解 <code>@ParameterizedTest</code></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@<span class="constructor">ParameterizedTest(<span class="params">name</span> = <span class="string">"@ValueSource: FindById(): Test# &#123;index&#125;: Id: &#123;0&#125;"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">ValueSource(<span class="params">longs</span> = &#123; 1L, 2L, 3L, 4L, 5L &#125;)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public void find<span class="constructor">ById(Long <span class="params">id</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">classUnderTest</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person personFound = classUnderTest.find<span class="constructor">ById(<span class="params">id</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">personFound</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span><span class="constructor">Equals(<span class="params">id</span>, <span class="params">personFound</span>.<span class="params">getId</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>将会生成以下输出：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@ValueSource:</span> FindById(): Test# <span class="number">1</span>: <span class="attribute">Id</span>: <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@ValueSource</span>: FindById(): Test# <span class="number">2</span>: <span class="attribute">Id</span>: <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@ValueSource</span>: FindById(): Test# <span class="number">3</span>: <span class="attribute">Id</span>: <span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@ValueSource</span>: FindById(): Test# <span class="number">4</span>: <span class="attribute">Id</span>: <span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@ValueSource</span>: FindById(): Test# <span class="number">5</span>: <span class="attribute">Id</span>: <span class="number">5</span></span></pre></td></tr></table></figure>

<h2 id="动态测试"><a href="#动态测试" class="headerlink" title="动态测试"></a>动态测试</h2><p>目前为止，我们分析的都是<em>静态测试</em>，这意味着测试代码、测试数据和测试的通过/失败条件在编译时都是已知的。<br>JUnit Jupiter 引入了一种称为<em>动态测试</em>的新测试类型，这种测试在运行时由一个称为<em>测试工厂</em>的特殊方法生成。</p>
<h3 id="TestFactory"><a href="#TestFactory" class="headerlink" title="@TestFactory"></a>@TestFactory</h3><p><code>@TestFactory</code> 方法用于生成动态测试。此方法必须返回 <code>DynamicTest</code> 实例的 <code>Stream</code>、<code>Collection</code>、<code>Iterable</code> 或 <code>Iterator</code>。<br>不同于 <code>@Test</code> 方法，<code>DynamicTest</code> 实例没有生命周期回调。所以 <code>@BeforeEach</code>、<code>@AfterEach</code> 和表 1 中的其他生命周期回调都不适用于 <code>DynamicTest</code>。</p>
<h3 id="创建-TestFactory"><a href="#创建-TestFactory" class="headerlink" title="创建 @TestFactory"></a>创建 @TestFactory</h3><p>考虑来自示例应用程序中 <code>PersonDaoBeanTest</code> 类的以下代码（可在 <code>com.makotojava.learn.junit5</code> 包的 <code>src/test/java</code> 树中找到它）：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@TestFactory</span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">DisplayName(<span class="string">"FindById - Dynamic Test Generator"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Stream&lt;DynamicTest&gt; generate<span class="constructor">FindByIdDynamicTests()</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Long<span class="literal">[]</span> ids = &#123; <span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>, <span class="number">4L</span>, <span class="number">5L</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return <span class="module-access"><span class="module"><span class="identifier">Stream</span>.</span></span><span class="keyword">of</span>(ids).map(id -&gt; dynamic<span class="constructor">Test(<span class="string">"DynamicTest: Find by ID "</span> + <span class="params">id</span>, ()</span> -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Person person = classUnderTest.find<span class="constructor">ById(<span class="params">id</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">person</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">int</span> index = id.<span class="built_in">int</span><span class="constructor">Value()</span> - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Person testPerson = <span class="module-access"><span class="module"><span class="identifier">PersonTestEnum</span>.</span></span>values<span class="literal">()</span><span class="literal">[<span class="identifier">index</span>]</span>.get<span class="constructor">Person()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        perform<span class="constructor">PersonAssertions(<span class="params">testPerson</span>.<span class="params">getLastName</span>()</span>, testPerson.get<span class="constructor">FirstName()</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        testPerson.get<span class="constructor">Age()</span>, testPerson.get<span class="constructor">EyeColor()</span>, testPerson.get<span class="constructor">Gender()</span>, person);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>@TestFactory</code> 注解将此方法标记为一个 <code>DynamicTest</code> 工厂（第 1 行），并根据 JUnit Jupiter 的要求返回 <code>DynamicTest</code> 实例的一个 <code>Stream</code>（第 2 行）。该 <code>@TestFactory</code> 所生成的测试不会执行任何花哨的操作；它们仅在 <code>PersonDaoBean</code> Spring bean 上调用 <code>findById</code>（第 6 行），并执行一些断言（第 10 和 11 行）。但它展示了如何创建一个动态测试。</p>
<h2 id="标签和过滤"><a href="#标签和过滤" class="headerlink" title="标签和过滤"></a>标签和过滤</h2><p>标签对过滤测试很有用。在本节中，我将介绍如何创建一个自定义过滤器，然后将它转换为一个组合注解，用于控制哪些测试可运行。</p>
<h3 id="使用-Tags"><a href="#使用-Tags" class="headerlink" title="使用 @Tags"></a>使用 @Tags</h3><p>JUnit Jupiter <em>标签</em>描述 <code>@Tag</code> 注解的用法，该注解创建一个新的标识符（标签），并接受单个 <code>String</code> 参数来唯一地标识该标签。下面给出了一些示例：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Tag</span>(<span class="string">"foo"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Tag</span>(<span class="string">"bar"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Tag</span>(<span class="string">"advanced"</span>)</span></pre></td></tr></table></figure>

<p>您可使用标签来注解方法或类，比如：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@<span class="constructor">Tag(<span class="string">"advanced"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@TestFactory</span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">DisplayName(<span class="string">"FindById - Dynamic Test Generator"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Stream&lt;DynamicTest&gt; generate<span class="constructor">FindByIdDynamicTests()</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Long<span class="literal">[]</span> ids = &#123; <span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>, <span class="number">4L</span>, <span class="number">5L</span>, <span class="number">6L</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return <span class="module-access"><span class="module"><span class="identifier">Stream</span>.</span></span><span class="keyword">of</span>(ids).map(id -&gt; dynamic<span class="constructor">Test(<span class="string">"DynamicTest: Find by ID "</span> + <span class="params">id</span>, ()</span> -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Person person = classUnderTest.find<span class="constructor">ById(<span class="params">id</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">person</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">int</span> index = id.<span class="built_in">int</span><span class="constructor">Value()</span> - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Person testPerson = <span class="module-access"><span class="module"><span class="identifier">PersonTestEnum</span>.</span></span>values<span class="literal">()</span><span class="literal">[<span class="identifier">index</span>]</span>.get<span class="constructor">Person()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        perform<span class="constructor">PersonAssertions(<span class="params">testPerson</span>.<span class="params">getLastName</span>()</span>, testPerson.get<span class="constructor">FirstName()</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        testPerson.get<span class="constructor">Age()</span>, testPerson.get<span class="constructor">EyeColor()</span>, testPerson.get<span class="constructor">Gender()</span>, person);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后可使用 Maven POM 或 Gradle 构建脚本中的过滤器设置来过滤掉此测试。教程后面将介绍如何执行该操作。</p>
<h3 id="创建您自己的组合注解"><a href="#创建您自己的组合注解" class="headerlink" title="创建您自己的组合注解"></a>创建您自己的组合注解</h3><p>与使用 <code>@Tag</code> 和它的唯一名称相比， 使用<code>@Tag</code> 创建新的<em>组合注解</em>更重要。还记得上节中的 <code>@Tag(&quot;advanced&quot;)</code> 吗？我可以创建一个新的组合注解来表示一种高级测试类型，比如：</p>
<p>清单 6. 创建组合注解</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">import static java.lang.<span class="keyword">annotation</span>.<span class="title">ElementType</span>.<span class="title">METHOD</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import static java.lang.<span class="keyword">annotation</span>.<span class="title">ElementType</span>.<span class="title">TYPE</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import static java.lang.<span class="keyword">annotation</span>.<span class="title">RetentionPolicy</span>.<span class="title">RUNTIME</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.lang.<span class="keyword">annotation</span>.<span class="title">Retention</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.lang.<span class="keyword">annotation</span>.<span class="title">Target</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.junit.jupiter.api.Tag;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Retention(RUNTIME)</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Target(&#123; TYPE, METHOD &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Tag(<span class="string">"advanced"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public @interface Advanced &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    /<span class="regexp">/ Nothing to do</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">&#125;</span></span></pre></td></tr></table></figure>

<p>现在，我在所有使用 <code>@Tag(&quot;advanced&quot;)</code> 的地方都使用 <code>@Advanced</code> 来代替，如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Advanced</span></pre></td></tr><tr><td class="code"><pre><span class="line">@TestFactory</span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">DisplayName(<span class="string">"FindById - Dynamic Test Generator"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Stream&lt;DynamicTest&gt; generate<span class="constructor">FindByIdDynamicTests()</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Long<span class="literal">[]</span> ids = &#123; <span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>, <span class="number">4L</span>, <span class="number">5L</span>, <span class="number">6L</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return <span class="module-access"><span class="module"><span class="identifier">Stream</span>.</span></span><span class="keyword">of</span>(ids).map(id -&gt; dynamic<span class="constructor">Test(<span class="string">"DynamicTest: Find by ID "</span> + <span class="params">id</span>, ()</span> -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Person person = classUnderTest.find<span class="constructor">ById(<span class="params">id</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">person</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">int</span> index = id.<span class="built_in">int</span><span class="constructor">Value()</span> - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Person testPerson = <span class="module-access"><span class="module"><span class="identifier">PersonTestEnum</span>.</span></span>values<span class="literal">()</span><span class="literal">[<span class="identifier">index</span>]</span>.get<span class="constructor">Person()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        perform<span class="constructor">PersonAssertions(<span class="params">testPerson</span>.<span class="params">getLastName</span>()</span>, testPerson.get<span class="constructor">FirstName()</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        testPerson.get<span class="constructor">Age()</span>, testPerson.get<span class="constructor">EyeColor()</span>, testPerson.get<span class="constructor">Gender()</span>, person);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如前所述，您可在类级别或方法级别上使用新的组合注解（感谢 <code>@Target</code> 注解；参见清单 6 中的第 11 行）。可以查看示例应用程序中的 <code>PersonDaoBeanRepeatedTest</code> 类，看看这么做的实际效果，我在其中使用 <code>@Advanced</code> 注解了整个类。在 <code>PersonDaoBeanTest</code> 中，我只将生成动态测试的 <code>generateFindByIdDynamicTests()</code> 方法标记为 <code>@Advanced</code>。</p>
<h2 id="使用-Maven-运行"><a href="#使用-Maven-运行" class="headerlink" title="使用 Maven 运行"></a>使用 Maven 运行</h2><p>在第 1 部分中，我展示了如何使用 Maven 和 Gradle 运行 JUnit 测试。本节将展示如何配置 Maven POM，从示例应用程序中过滤掉 <code>@Advanced</code> 测试。<br>JUnit 用户指南包含各种 Maven 配置设置的[更详细参考指南](<a href="http://junit.org/junit5/docs/current/user-guide/#running-tests-" target="_blank" rel="noopener">http://junit.org/junit5/docs/current/user-guide/#running-tests-</a> build)，所以如果需要更多信息，推荐您查阅该指南。<br>要试用它，首先需要运行构建，并注意运行的测试数量（下面第 12 行）。您应看到类似下面这样的信息：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">$ mvn clean test</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">-------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="code"> T E S T S</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">-------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">May 22, 2017 10:04:15 AM org.junit.jupiter.engine.discovery.JavaElementsResolver resolveClass</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Results :</span></pre></td></tr><tr><td class="code"><pre><span class="line">Tests run: 92, Failures: 0, Errors: 0, Skipped: 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">[INFO] ------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[INFO] BUILD SUCCESS</span></pre></td></tr><tr><td class="code"><pre><span class="line">[INFO] ------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[INFO] Total time: 55.276 s</span></pre></td></tr><tr><td class="code"><pre><span class="line">[INFO] Finished at: 2017-05-22T10:05:08-05:00</span></pre></td></tr><tr><td class="code"><pre><span class="line">[INFO] Final Memory: 19M/297M</span></pre></td></tr><tr><td class="code"><pre><span class="line">[INFO] ------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">$</span></pre></td></tr></table></figure>

<p>记住运行了多少个测试（第 12 行），这样才能将该数字与应用过滤器后的值进行比较。<br>在 Eclipse 中打开 POM，找到 Maven surefire 插件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    .</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    .</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></pre></td></tr></table></figure>

<p>现在修改 <code>version</code> 元素（第 7 行）下的 POM，使它类似于：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    .</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="tag">&lt;<span class="name">excludeTags</span>&gt;</span>advanced<span class="tag">&lt;/<span class="name">excludeTags</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    .</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></pre></td></tr></table></figure>

<p>再次运行构建内容，您应该看到运行的测试更少了。输出看起来应类似于：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">$mvn clean test</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">-------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="code"> T E S T S</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">-------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">May 22, 2017 10:09:42 AM org.junit.jupiter.engine.discovery.JavaElementsResolver resolveClass</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Results :</span></pre></td></tr><tr><td class="code"><pre><span class="line">Tests run: 47, Failures: 0, Errors: 0, Skipped: 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">[INFO] ------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[INFO] BUILD SUCCESS</span></pre></td></tr><tr><td class="code"><pre><span class="line">[INFO] ------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[INFO] Total time: 32.023 s</span></pre></td></tr><tr><td class="code"><pre><span class="line">[INFO] Finished at: 2017-05-22T10:10:11-05:00</span></pre></td></tr><tr><td class="code"><pre><span class="line">[INFO] Final Memory: 20M/300M</span></pre></td></tr><tr><td class="code"><pre><span class="line">[INFO] ------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">$</span></pre></td></tr></table></figure>

<p>可以注意到，应用过滤后（第 12 行），运行的测试数量比以前少多了。</p>
<h2 id="使用-Gradle-运行"><a href="#使用-Gradle-运行" class="headerlink" title="使用 Gradle 运行"></a>使用 Gradle 运行</h2><p>接下来，我将展示如何配置 Gradle 构建脚本，从示例应用程序中过滤掉 <code>@Advanced</code> 测试。<br>JUnit 用户指南包含各种 Gradle 配置设置的<a href="http://junit.org/junit5/docs/current/user-guide/#running-tests-build" target="_blank" rel="noopener">更详细参考指南</a>，所以如果需要更多信息，推荐您查阅该指南。<br>要试用它，首先需要运行构建，并注意运行的测试数量（第 19、21 和 23 行）。您应看到类似下面这样的信息：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">gradle</span> <span class="string">clean</span> <span class="string">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">:clean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">:compileJava</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">:processResources</span> <span class="literal">NO</span><span class="string">-SOURCE</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">:classes</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">:compileTestJava</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">:processTestResources</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">:testClasses</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">:junitPlatformTest</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">Test</span> <span class="string">run</span> <span class="string">finished</span> <span class="string">after</span> <span class="number">62083</span> <span class="string">ms</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>        <span class="number">24</span> <span class="string">containers</span> <span class="string">found</span>      <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>         <span class="number">0</span> <span class="string">containers</span> <span class="string">skipped</span>    <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>        <span class="number">24</span> <span class="string">containers</span> <span class="string">started</span>    <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>         <span class="number">0</span> <span class="string">containers</span> <span class="string">aborted</span>    <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>        <span class="number">24</span> <span class="string">containers</span> <span class="string">successful</span> <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>         <span class="number">0</span> <span class="string">containers</span> <span class="string">failed</span>     <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>        <span class="number">92</span> <span class="string">tests</span> <span class="string">found</span>           <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>         <span class="number">0</span> <span class="string">tests</span> <span class="string">skipped</span>         <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>        <span class="number">92</span> <span class="string">tests</span> <span class="string">started</span>         <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>         <span class="number">0</span> <span class="string">tests</span> <span class="string">aborted</span>         <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>        <span class="number">92</span> <span class="string">tests</span> <span class="string">successful</span>      <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>         <span class="number">0</span> <span class="string">tests</span> <span class="string">failed</span>          <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">:test</span> <span class="string">SKIPPED</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">BUILD</span> <span class="string">SUCCESSFUL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">Total time:</span> <span class="number">1</span> <span class="string">mins</span> <span class="number">3.718</span> <span class="string">secs</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">$</span></span></pre></td></tr></table></figure>

<p>记住运行了多少个测试（第 23 行），这样才能将该数字与应用过滤器后的值进行比较。<br>在 Eclipse 中打开构建脚本并找到 <code>junitplatform</code> 节，该节类似于：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">junitPlatform</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="section">filters</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="section">engines</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="section">tags</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">logManager</span> <span class="string">'org.apache.logging.log4j.jul.LogManager'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>现在修改 <code>tags</code> 元素下的 POM，使它类似于：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">junitPlatform</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="section">filters</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="section">engines</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="section">tags</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attribute">exclude</span> <span class="string">'advanced'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  logManager <span class="string">'org.apache.logging.log4j.jul.LogManager'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>再次运行构建内容，您应该看到运行的测试更少了。输出看起来应类似于：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">gradle</span> <span class="string">clean</span> <span class="string">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">:clean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">:compileJava</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">:processResources</span> <span class="literal">NO</span><span class="string">-SOURCE</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">:classes</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">:compileTestJava</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">:processTestResources</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">:testClasses</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">:junitPlatformTest</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">Test</span> <span class="string">run</span> <span class="string">finished</span> <span class="string">after</span> <span class="number">38834</span> <span class="string">ms</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>        <span class="number">13</span> <span class="string">containers</span> <span class="string">found</span>      <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>         <span class="number">0</span> <span class="string">containers</span> <span class="string">skipped</span>    <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>        <span class="number">13</span> <span class="string">containers</span> <span class="string">started</span>    <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>         <span class="number">0</span> <span class="string">containers</span> <span class="string">aborted</span>    <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>        <span class="number">13</span> <span class="string">containers</span> <span class="string">successful</span> <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>         <span class="number">0</span> <span class="string">containers</span> <span class="string">failed</span>     <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>        <span class="number">47</span> <span class="string">tests</span> <span class="string">found</span>           <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>         <span class="number">0</span> <span class="string">tests</span> <span class="string">skipped</span>         <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>        <span class="number">47</span> <span class="string">tests</span> <span class="string">started</span>         <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>         <span class="number">0</span> <span class="string">tests</span> <span class="string">aborted</span>         <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>        <span class="number">47</span> <span class="string">tests</span> <span class="string">successful</span>      <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[</span>         <span class="number">0</span> <span class="string">tests</span> <span class="string">failed</span>          <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">:test</span> <span class="string">SKIPPED</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">BUILD</span> <span class="string">SUCCESSFUL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">Total time:</span> <span class="number">40.487</span> <span class="string">secs</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">$</span></span></pre></td></tr></table></figure>

<p>注意在应用过滤（第 19、21、23）后，运行的测试比以前少了多少。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>JUnit 5 教程的后半部分重点介绍了 JUnit Vintage 和 JUnit Jupiter 扩展模型。JUnit Vintage 提供了与 JUnit 3 和 JUnit 4 的后向兼容性，JUnit Jupiter 扩展模型支持针对第三方工具或自定义测试场景来扩展 JUnit Jupiter API。我总结了 JUnit Jupiter 中提供的新扩展点，然后通过一系列示例重点展示了 JUnit 5 中针对参数注入、参数化测试、动态测试和自定义注解等新的可扩展特性。<br>恭喜您！您已学完 JUnit 5 教程。如果尚未观看本教程的配套<a href="https://www.youtube.com/watch?v=qzrMoCtEOkQ" target="_blank" rel="noopener">视频</a>，可以看一下。该视频详细介绍了您目前学到的有关新 <code>ParameterResolver</code> 和 <code>@ParameterizedTest</code> 特性的知识，还展示了如何运行 HelloJUnit5Part2 源代码中所包含的控制台启动器。</p>
<blockquote>
<p>作者：J Steven Perry</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part2-vintage-jupiter-extension-model/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part2-vintage-jupiter-extension-model/index.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>JUnit</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 习惯用语（10）：使用闭包捕获状态</title>
    <url>/2019/12/26/Java-8-%E4%B9%A0%E6%83%AF%E7%94%A8%E8%AF%AD%EF%BC%8810%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E6%8D%95%E8%8E%B7%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<p>在 Java™ 编程中，我们以不严格地使用术语 <em>lambda 表达式</em>来表示 lambda 表达式和闭包。但在某些情况下，理解它们的区别很重要。lambda 表达式是无状态的，而闭包是带有状态的。将 lambda 表达式替换为闭包，是一种管理函数式程序中的状态的好方法。</p>
<a id="more"></a>

<h2 id="无状态的生活"><a href="#无状态的生活" class="headerlink" title="无状态的生活"></a>无状态的生活</h2><p>我们在本系列中大量介绍了 lambda 表达式，您应该已经对它们有非常透彻的了解。它们是小巧的匿名函数，接受可选的参数，执行某种计算或操作，而且可能返回一个结果。lambda 表达式也是无状态的，这可能会在您的代码中产生重大影响。<br>我们首先看一个使用 lambda 表达式的简单示例。假设我们想将一个数字集合中的偶数乘以二。一种选择是使用 <code>Stream</code> 和 lambda 表达式创建一个函数管道，如下所示：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">numbers.stream<span class="params">()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">.filter</span><span class="params">(e -&gt; e % <span class="attr">2</span> == 0)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">.map</span><span class="params">(e -&gt; e * 2)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">.collect</span><span class="params">(toList()</span>);</span></pre></td></tr></table></figure>

<p>我们传入 <code>filter</code> 中的 lambda 表达式取代了 <code>Predicate</code> 函数接口。它接受一个数字，如果该数字是偶数，则返回 <code>true</code>，否则返回 <code>false</code>。另一方面，我们传递给 <code>map</code> 的 lambda 表达式取代了 <code>Function</code> 函数接口：它接受任何数字并返回该值的两倍。<br>这两个 lambda 表达式都依赖于传入的参数和字面常量。二者都是独立的，这意味着它们没有任何外部依赖项。因为它们依赖于传入的参数，而且可能还依赖于一些常量，所以 lambda 表达式是无状态的。它们很可爱，也很安静，就像熟睡的婴儿一样。</p>
<h2 id="我们为什么需要状态"><a href="#我们为什么需要状态" class="headerlink" title="我们为什么需要状态"></a>我们为什么需要状态</h2><p>现在让我们更仔细地看看传递给 <code>map</code> 方法的 lambda 表达式。如果我们希望计算给定值的三倍或四倍，该怎么办？我们可以将常量 <code>2</code> 转换为一个变量（比如 <code>factor</code>），但 lambda 表达式仍需要一种方式来获取该变量。<br>我们可以推断，lambda 表达式可以采用与接收参数 <code>e</code> 的相同方式来接收 <code>factor</code>，如下所示：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">.<span class="keyword">map</span><span class="function"><span class="params">((e, factor) -&gt; e * factor)</span></span></span></pre></td></tr></table></figure>

<p>还不错，但不幸的是它不起作用。方法 <code>map</code> 要求接受函数接口 <code>Function</code> 的一个实现作为参数。如果我们传入该接口外的任何内容（比如一个 <code>BiFunction</code>），<code>map</code> 不会接受。需要采用另一种方式将 <code>factor</code> 提供给我们的 lambda 表达式。</p>
<h2 id="词法范围"><a href="#词法范围" class="headerlink" title="词法范围"></a>词法范围</h2><p>函数要求变量在限定范围内。因为它们实际上是匿名函数，所以 lambda 表达式也要求引用的变量在限定范围内。一些变量以参数形式被函数或 lambda 表达式接收。一些变量是局部定义的。一些变量来自函数外部，位于所谓的<em>词法范围</em>中。<br>下面是一个词法范围示例。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">String</span> location = <span class="string">"World"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"Hello "</span> + location);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    runnable.<span class="built_in">run</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在 <code>print</code> 方法中，<code>location</code> 是一个局部变量。但是，<code>Runnable</code> 的 <code>run</code> 方法还引用了一个不是 <code>run</code> 方法的局部变量或参数的 <code>location</code>。对 <code>Hello</code> 旁边的 <code>location</code> 的引用被绑定到 <code>print</code> 方法的 <code>location</code> 变量。<br><em>词法范围</em>是函数的定义范围。反过来，它也可能是该定义范围的定义范围，等等。<br>在前面的代码中，方法 <code>run</code> 没有定义 <code>location</code> 或接收它作为参数。<code>run</code> 的定义范围是 <code>Runnable</code> 的匿名内部对象。因为没有将 <code>location</code> 定义为该实例中的字段，所以会继续搜索匿名内部对象的定义范围 — 在本例中为方法 <code>print</code> 的局部范围。<br>如果 <code>location</code> 不在该范围中，编译器会继续在 <code>print</code> 的定义范围内搜索，直到找到该变量或搜索失败。</p>
<h3 id="lambda-表达式中的词法范围"><a href="#lambda-表达式中的词法范围" class="headerlink" title="lambda 表达式中的词法范围"></a>lambda 表达式中的词法范围</h3><p>现在让我们看看，使用 lambda 表达式重写前面的代码后会发生什么：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">String</span> location = <span class="string">"World"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Runnable runnable = () -&gt; System.out.<span class="built_in">println</span>(<span class="string">"Hello "</span> + location);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    runnable.<span class="built_in">run</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>得益于 lambda 表达式，代码变得更简洁，但 <code>location</code> 的范围和绑定没有更改。lambda 表达式中的变量 <code>location</code> 被绑定到 lambda 表达式的词法范围中的变量 <code>location</code>。严格来讲，此代码中的 lambda 表达式是一个<em>闭包</em>。</p>
<h2 id="闭包如何携带状态"><a href="#闭包如何携带状态" class="headerlink" title="闭包如何携带状态"></a>闭包如何携带状态</h2><p>Lambda 表达式不依赖于任何外部实体；它们是依赖于自身参数和常量的内容。另一方面，闭包既依赖于参数和常量，也依赖于它们的词法范围中的变量。<br>从逻辑上讲，闭包被绑定到它们的词法范围中的变量。但是，尽管逻辑上讲是这样，但实际上并不总是这么做。有时甚至无法执行这样的绑定。<br>两个场景可以证明这一点。<br>首先，下面这段代码将一个 lambda 表达式或闭包传递给一个 <code>call</code> 方法：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Runnable runnable)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"calling runnable"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//level 2 of stack</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        runnable.<span class="built_in">run</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> value = <span class="number">4</span>;  <span class="comment">//level 1 of stack</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        call(</span></pre></td></tr><tr><td class="code"><pre><span class="line">           () -&gt; System.out.<span class="built_in">println</span>(value) <span class="comment">//level 3 of stack</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>此代码中的闭包使用了来自它的词法范围的变量 <code>value</code>。如果 <code>main</code> 是在堆栈级别 1 上执行的，那么 <code>call</code> 方法的主体会在堆栈级别 2 上执行。因为 <code>Runnable</code> 的 <code>run</code> 方法是从 <code>call</code> 内调用的，所以该闭包的主体会在级别 3 上运行。如果 <code>call</code> 方法要将该闭包传递给另一个方法（进而推迟调用的位置），则执行的堆栈级别可能高于 3。<br>您现在可能想知道在一个堆栈级别中的执行究竟如何能获取之前的另一个堆栈级别中的变量 — 尤其是未在调用中传递上下文时。简单来讲就是无法获取该变量。<br>现在考虑另一个示例：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runnable <span class="title">create</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> value = <span class="number">4</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Runnable runnable = () -&gt; System.out.<span class="built_in">println</span>(value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"exiting create"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> runnable;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Runnable runnable = create();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"In main"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        runnable.<span class="built_in">run</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在这个示例中，<code>create</code> 方法有一个局部变量 <code>value</code>，该变量的寿命很短：只要我们退出 <code>create</code>，它就会消失。<code>create</code> 内创建的闭包在其词法范围中引用了这个变量。在完成 <code>create</code> 方法后，该方法将闭包返回给 <code>main</code> 中的调用方。在此过程中，它从自己的堆栈中删除变量 <code>value</code>，而且 lambda 表达式将会执行。这是结果输出：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">exiting</span> <span class="string">create</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">In</span> <span class="string">main</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">4</span></span></pre></td></tr></table></figure>

<p>我们知道，在 <code>main</code> 中调用 <code>run</code> 时，<code>create</code> 中的 <code>value</code> 就会终止。尽管我们可以假设 lambda 表达式中的 <code>value</code> 直接被绑定到它的词法范围中的变量，但该假设并不成立。<br>可通过一个类比来揭示其中原委。</p>
<h3 id="闭包午休时间"><a href="#闭包午休时间" class="headerlink" title="闭包午休时间"></a>闭包午休时间</h3><p>假设我的办公室离家约 10 英里（使用改进的测量单位的话为 16 公里），而且我早上 8 点出门上班。中午，我有短暂的时间用午餐，但出于健康考虑，我喜欢吃家里烹饪的饭菜。由于休息时间很短，只有在离家时带上午餐，我才能吃上家里的饭菜。<br>这就是闭包要完成的任务：它们携带自己的午餐（或状态）。<br>为了讲得更清楚一些，让我们再看看 <code>create</code> 中的 lambda 表达式：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">Runnable runnable = <span class="function"><span class="params">()</span> -&gt;</span> System.out.println(value);</span></pre></td></tr></table></figure>

<p>我们编写的 lambda 表达式没有接受任何参数，但需要它的 <code>value</code>。编译类 <code>Sample</code> 并运行 <code>javap -c -p Sample.class</code> 来检查字节码。您会注意到，编译器为该闭包创建了一个方法，该方法接受一个 <code>int</code> 参数：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="built_in">void</span> lambda$create$<span class="number">0</span>(<span class="built_in">int</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Code:</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">3</span>  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">3</span>: iload_0</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">4</span>: invokevirtual #<span class="number">9</span> <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">7</span>: <span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>现在看看为 <code>create</code> 方法生成的字节码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: iconst_4</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span>: istore_0</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span>: iload_0</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3</span>: invokedynamic #<span class="number">2</span>,  <span class="number">0</span>  <span class="comment">// InvokeDynamic #0:run:(I)Ljava/lang/Runnable;</span></span></pre></td></tr></table></figure>

<p>值 <code>4</code> 存储在一个变量中，然后，该变量被加载并传递到为闭包创建的函数。在本例中，闭包保留着 <code>value</code> 的一个副本。<br>这就是闭包携带状态的方式。</p>
<h2 id="使用闭包"><a href="#使用闭包" class="headerlink" title="使用闭包"></a>使用闭包</h2><p>现在，我们回头看看本文开头的示例。除了计算集合中的偶数值的两倍，如果我们想要计算它们的三倍或四倍，该怎么办？为此，我们可以将原始 lambda 表达式转换为一个闭包。<br>这是我们之前看到的无状态代码：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">numbers.stream<span class="params">()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">.filter</span><span class="params">(e -&gt; e % <span class="attr">2</span> == 0)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">.map</span><span class="params">(e -&gt; e * 2)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">.collect</span><span class="params">(toList()</span>);</span></pre></td></tr></table></figure>

<p>使用闭包而不是 lambda 表达式，代码就会变成：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> factor = <span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">numbers.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(e -&gt; e % <span class="number">2</span> == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .map(e -&gt; e * factor)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .collect(toList());</span></pre></td></tr></table></figure>

<p><code>map</code> 方法现在接受一个闭包，而不是一个 lambda 表达式。我们知道，这个闭包接受一个参数 <code>e</code>，但它也捕获并携带 <code>factor</code> 变量的状态。<br>此变量位于该闭包的<em>词法范围</em>中。它可以是定义 lambda 表达式的函数中的局部变量；可以作为该外部函数的一个参数传入；可以位于闭包的定义范围（或该定义范围的定义范围等）中的任何地方。无论如何，该闭包将状态从定义该闭包的代码传递到了需要该变量的执行点。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>闭包不同于 lambda 表达式，因为它们依赖于自己的词法范围来获取一些变量。因此，闭包可以捕获并携带状态。lambda 表达式是无状态的，闭包是有状态的。可以在您的程序中使用闭包，将状态从定义上下文携带到执行点。</p>
<blockquote>
<p>作者：Venkat Subramaniam</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms10/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms10/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 习惯用语（9）：级联 lambda 表达式</title>
    <url>/2019/12/26/Java-8-%E4%B9%A0%E6%83%AF%E7%94%A8%E8%AF%AD%EF%BC%889%EF%BC%89%EF%BC%9A%E7%BA%A7%E8%81%94-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>在函数式编程中，函数既可以接收也可以返回其他函数。函数不再像传统的面向对象编程中一样，只是一个对象的<em>工厂</em>或<em>生成器</em>，它也能够创建和返回另一个函数。返回函数的函数可以变成<em>级联 lambda 表达式</em>，特别值得注意的是代码非常简短。尽管此语法初看起来可能非常陌生，但它有自己的用途。本文将帮助您认识级联 lambda 表达式，理解它们的性质和在代码中的用途。</p>
<a id="more"></a>

<h2 id="神秘的语法"><a href="#神秘的语法" class="headerlink" title="神秘的语法"></a>神秘的语法</h2><p>您是否看到过类似这样的代码段？</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="symbol">x</span> -&gt; <span class="symbol">y</span> -&gt; <span class="symbol">x</span> &gt; <span class="symbol">y</span></span></pre></td></tr></table></figure>

<p>如果您很好奇“这到底是什么意思？”，那么您并不孤单。对于不熟悉使用 lambda 表达式编程的开发人员，此语法可能看起来像货物正从快速行驶的卡车上一件件掉下来一样。<br>幸运的是，我们不会经常看到它们，但理解如何创建级联 lambda 表达式和如何在代码中理解它们会大大减少您的受挫感。</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>在谈论级联 lambda 表达式之前，有必要首先理解如何创建它们。对此，我们需要回顾一下高阶函数（已在<a href="https://www.ibm.com/developerworks/library/j-java8idioms1/index.html" target="_blank" rel="noopener">本系列第 1 篇文章</a>中介绍）和它们在<em>函数分解</em>中的作用，函数分解是一种将复杂流程分解为更小、更简单的部分的方式。<br>首先，考虑区分高阶函数与常规函数的规则：<br>常规函数</p>
<ul>
<li>可以接收对象</li>
<li>可以创建对象</li>
<li>可以返回对象</li>
</ul>
<p>高阶函数</p>
<ul>
<li>可以接收函数</li>
<li>可以创建函数</li>
<li>可以返回函数</li>
</ul>
<p>开发人员将匿名函数或 lambda 表达式传递给高阶函数，以让代码简短且富于表达。让我们看看这些高阶函数的两个示例。</p>
<h3 id="示例-1：一个接收函数的函数"><a href="#示例-1：一个接收函数的函数" class="headerlink" title="示例 1：一个接收函数的函数"></a>示例 1：一个接收函数的函数</h3><p>在 Java™ 中，我们使用函数接口来引用 lambda 表达式和方法引用。下面这个函数接收一个对象和一个函数：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> static <span class="type">int</span> totalSelectedValues(List&lt;<span class="type">Integer</span>&gt; <span class="keyword">values</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Predicate&lt;<span class="type">Integer</span>&gt; selector) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">values</span>.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .<span class="keyword">filter</span>(selector)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .reduce(<span class="number">0</span>, <span class="type">Integer</span>::sum);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>totalSelectedValues</code> 的第一个参数是集合对象，而第二个参数是 <code>Predicate</code> 函数接口。 因为参数类型是函数接口 (<code>Predicate</code>)，所以我们现在可以将一个 lambda 表达式作为第二个参数传递给 <code>totalSelectedValues</code>。例如，如果我们想仅对一个 <code>numbers</code> 列表中的<em>偶数值</em>求和，可以调用 <code>totalSelectedValues</code>，如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">total<span class="constructor">SelectedValues(<span class="params">numbers</span>, <span class="params">e</span> -&gt; <span class="params">e</span> % 2 <span class="operator">==</span> 0)</span>;</span></pre></td></tr></table></figure>

<p>假设我们现在在 <code>Util</code> 类中有一个名为 <code>isEven</code> 的 <code>static</code> 方法。在此情况下，我们可以使用 <code>isEven</code> 作为 <code>totalSelectedValues</code> 的参数，而不传递 lambda 表达式：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">totalSelectedValues(<span class="name">numbers</span>, Util:<span class="symbol">:isEven</span>)<span class="comment">;</span></span></pre></td></tr></table></figure>

<p>作为规则，只要一个函数接口显示为一个函数的参数的<em>类型</em>，您看到的就是一个高阶函数。</p>
<h3 id="示例-2：一个返回函数的函数"><a href="#示例-2：一个返回函数的函数" class="headerlink" title="示例 2：一个返回函数的函数"></a>示例 2：一个返回函数的函数</h3><p>函数可以接收函数、lambda 表达式或方法引用作为参数。同样地，函数也可以返回 lambda 表达式或方法引用。在此情况下，返回类型将是函数接口。<br>让我们首先看一个创建并返回 <code>Predicate</code> 来验证给定值是否为奇数的函数：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">public<span class="keyword"> static</span> Predicate&lt;Integer&gt; createIsOdd() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Predicate&lt;Integer&gt;<span class="built_in"> check </span>= (Integer number) -&gt; number % 2 != 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="built_in"> return </span>check;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>为了返回一个函数，我们必须提供一个函数接口作为返回类型。在本例中，我们的函数接口是 <code>Predicate</code>。尽管上述代码在语法上是正确的，但它可以更加简短。 我们使用类型引用并删除临时变量来改进该代码：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> static Predicate&lt;<span class="keyword">Integer</span>&gt; createIsOdd() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">number</span> -&gt; <span class="keyword">number</span> % <span class="number">2</span> <span class="comment">!= 0;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这是使用的 <code>createIsOdd</code> 方法的一个示例：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Predicate&lt;Integer&gt; isOdd = createIsOdd()<span class="comment">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">isOdd.test(<span class="number">4</span>)<span class="comment">;</span></span></pre></td></tr></table></figure>

<p>请注意，在 <code>isOdd</code> 上调用 <code>test</code> 会返回 <code>false</code>。我们也可以在 <code>isOdd</code> 上使用更多值来调用 <code>test</code>；它并不限于使用一次。</p>
<h2 id="创建可重用的函数"><a href="#创建可重用的函数" class="headerlink" title="创建可重用的函数"></a>创建可重用的函数</h2><p>现在您已大体了解高阶函数和如何在代码中找到它们，我们可以考虑使用它们来让代码更加简短。<br>设想我们有两个列表 <code>numbers1</code> 和 <code>numbers2</code>。假设我们想从第一个列表中仅提取大于 50 的数，然后从第二个列表中提取大于 50 的值并<em>乘以 2</em>。<br>可通过以下代码实现这些目的：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; result1 = numbers1.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="function"><span class="title">filter</span>(e -&gt;</span> e &gt; <span class="number">50</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .collect(toList());</span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; result2 = numbers2.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="function"><span class="title">filter</span>(e -&gt;</span> e &gt; <span class="number">50</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="function"><span class="title">map</span>(e -&gt;</span> e * <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .collect(toList());</span></pre></td></tr></table></figure>

<p>此代码很好，但您注意到它很冗长了吗？我们对检查数字是否大于 50 的 lambda 表达式使用了两次。 我们可以通过创建并重用一个 <code>Predicate</code>，从而删除重复代码，让代码更富于表达：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">Predicate&lt;<span class="built_in">Integer</span>&gt; isGreaterThan50 = number -&gt; number &gt; <span class="number">50</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; result1 = numbers1.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(isGreaterThan50)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .collect(toList());</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; result2 = numbers2.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(isGreaterThan50)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="built_in">map</span>(e -&gt; e * <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .collect(toList());</span></pre></td></tr></table></figure>

<p>通过将 lambda 表达式存储在一个引用中，我们可以重用它，这是我们避免重复 lambda 表达式的方式。如果我们想跨方法重用 lambda 表达式，也可以将该引用放入一个单独的方法中，而不是放在一个局部变量引用中。<br>现在假设我们想从列表 <code>numbers1</code> 中提取大于 25、50 和 75 的值。我们可以首先编写 3 个不同的 lambda 表达式：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; valuesOver25 = numbers1.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(e -&gt; e &gt; <span class="number">25</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="keyword">collect</span>(<span class="keyword">toList</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; valuesOver50 = numbers1.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(e -&gt; e &gt; <span class="number">50</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="keyword">collect</span>(<span class="keyword">toList</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; valuesOver75 = numbers1.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(e -&gt; e &gt; <span class="number">75</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="keyword">collect</span>(<span class="keyword">toList</span>());</span></pre></td></tr></table></figure>

<p>尽管上面每个 lambda 表达式将输入与一个不同的值比较，但它们做的事情完全相同。如何以较少的重复来重写此代码？</p>
<h2 id="创建和重用-lambda-表达式"><a href="#创建和重用-lambda-表达式" class="headerlink" title="创建和重用 lambda 表达式"></a>创建和重用 lambda 表达式</h2><p>尽管上一个示例中的两个 lambda 表达式相同，但上面 3 个表达式稍微不同。创建一个返回 <code>Predicate</code> 的 <code>Function</code> 可以解决此问题。<br>首先，函数接口 <code>Function</code> 将一个 <code>T</code> 类型的输入转换为 <code>U</code> 类型的输出。例如，下面的示例将一个给定值转换为它的平方根：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Function</span></span>&lt;<span class="keyword">Integer</span>, <span class="keyword">Double</span>&gt; <span class="built_in">sqrt</span> = <span class="keyword">value</span> -&gt; Math.<span class="built_in">sqrt</span>(<span class="keyword">value</span>);</span></pre></td></tr></table></figure>

<p>在这里，返回类型 <code>U</code> 可以很简单，比如 <code>Double</code>、<code>String</code> 或 <code>Person</code>。或者它也可以更复杂，比如 <code>Consumer</code> 或 <code>Predicate</code> 等另一个函数接口。<br>在本例中，我们希望一个 <code>Function</code> 创建一个 <code>Predicate</code>。所以代码如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Function</span></span>&lt;<span class="keyword">Integer</span>, Predicate&lt;<span class="keyword">Integer</span>&gt;&gt; isGreaterThan = (<span class="keyword">Integer</span> pivot) -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Predicate&lt;<span class="keyword">Integer</span>&gt; isGreaterThanPivot = (<span class="keyword">Integer</span> candidate) -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> candidate &gt; pivot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> isGreaterThanPivot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>引用 <code>isGreaterThan</code> 引用了一个表示 <code>Function</code>— 或更准确地讲表示 <code>Function&gt;</code> 的 lambda 表达式。输入是一个 <code>Integer</code>，输出是一个 <code>Predicate</code>。<br>在 lambda 表达式的主体中（外部 <code>{}</code> 内），我们创建了另一个引用 <code>isGreaterThanPivot</code>，它包含对另一个 lambda 表达式的引用。这一次，该引用是一个 <code>Predicate</code> 而不是 <code>Function</code>。最后，我们返回该引用。<br><code>isGreaterThan</code> 是一个 lambda 表达式的引用，该表达式在调用时返回<em>另一个</em> lambda 表达式 — 换言之，这里隐藏着一种 lambda 表达式级联关系。<br>现在，我们可以使用新创建的外部 lamba 表达式来解决代码中的重复问题：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; valuesOver25 = numbers1.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(isGreaterThan.apply(<span class="number">25</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="keyword">collect</span>(<span class="keyword">toList</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; valuesOver50 = numbers1.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(isGreaterThan.apply(<span class="number">50</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="keyword">collect</span>(<span class="keyword">toList</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; valuesOver75 = numbers1.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(isGreaterThan.apply(<span class="number">75</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="keyword">collect</span>(<span class="keyword">toList</span>());</span></pre></td></tr></table></figure>

<p>在 <code>isGreaterThan</code> 上调用 <code>apply</code> 会返回一个 <code>Predicate</code>，后者然后作为参数传递给 <code>filter</code> 方法。<br>尽管整个过程非常简单（作为示例），但是能够抽象为一个函数对于谓词更加复杂的场景来说尤其有用。</p>
<h2 id="保持简短的秘诀"><a href="#保持简短的秘诀" class="headerlink" title="保持简短的秘诀"></a>保持简短的秘诀</h2><p>我们已从代码中成功删除了重复的 lambda 表达式，但 <code>isGreaterThan</code> 的定义看起来仍然很杂乱。幸运的是，我们可以组合一些 Java 8 约定来减少杂乱，让代码更简短。<br>我们首先重构以下代码：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Function</span></span>&lt;<span class="keyword">Integer</span>, Predicate&lt;<span class="keyword">Integer</span>&gt;&gt; isGreaterThan = (<span class="keyword">Integer</span> pivot) -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Predicate&lt;<span class="keyword">Integer</span>&gt; isGreaterThanPivot = (<span class="keyword">Integer</span> candidate) -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> candidate &gt; pivot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> isGreaterThanPivot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>可以使用类型引用来从外部和内部 lambda 表达式的参数中删除类型细节：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer, Predicate&lt;Integer&gt;&gt; isGreaterThan = <span class="function"><span class="params">(pivot)</span> -&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Predicate&lt;Integer&gt; isGreaterThanPivot = <span class="function"><span class="params">(candidate)</span> -&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> candidate &gt; pivot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> isGreaterThanPivot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>目前，我们从代码中删除了两个单词，改进不大。<br>接下来，我们删除多余的 <code>()</code>，以及外部 lambda 表达式中不必要的临时引用：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Function</span></span>&lt;<span class="keyword">Integer</span>, Predicate&lt;<span class="keyword">Integer</span>&gt;&gt; isGreaterThan = pivot -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> candidate -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> candidate &gt; pivot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>代码更加简短了，但是仍然看起来有些杂乱。<br>可以看到内部 lambda 表达式的主体只有一行，显然 <code>{}</code> 和 <code>return</code> 是多余的。让我们删除它们：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Function</span></span>&lt;<span class="keyword">Integer</span>, Predicate&lt;<span class="keyword">Integer</span>&gt;&gt; isGreaterThan = pivot -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> candidate -&gt; candidate &gt; pivot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>现在可以看到，外部 lambda 表达式的主体<em>也</em>只有一行，所以 <code>{}</code> 和 <code>return</code> 在这里也是多余的。在这里，我们应用最后一次重构：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Function</span></span>&lt;<span class="keyword">Integer</span>, Predicate&lt;<span class="keyword">Integer</span>&gt;&gt; isGreaterThan =</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pivot -&gt; candidate -&gt; candidate &gt; pivot;</span></pre></td></tr></table></figure>

<p>现在可以看到 — 这是我们的级联 lambda 表达式。</p>
<h2 id="理解级联-lambda-表达式"><a href="#理解级联-lambda-表达式" class="headerlink" title="理解级联 lambda 表达式"></a>理解级联 lambda 表达式</h2><p>我们通过一个适合每个阶段的重构过程，得到了最终的代码 - 级联 lambda 表达式。在本例中，外部 lambda 表达式接收 <code>pivot</code> 作为参数，内部 lambda 表达式接收 <code>candidate</code> 作为参数。内部 lambda 表达式的主体同时使用它收到的参数 (<code>candidate</code>) 和来自外部范围的参数。也就是说，内部 lambda 表达式的主体同时依靠它的参数和它的<em>词法范围</em>或<em>定义范围</em>。<br>级联 lambda 表达式对于编写它的人非常有意义。但是对于读者呢？<br>看到一个只有一个向右箭头 (<code>-&gt;</code>) 的 lambda 表达式时，您应该知道您看到的是一个匿名函数，它接受参数（可能是空的）并执行一个操作或返回一个结果值。<br>看到一个包含两个向右箭头 (<code>-&gt;</code>) 的 lambda 表达式时，您看到的也是一个匿名函数，但它接受参数（可能是空的）并返回另一个 lambda 表达式。返回的 lambda 表达式可以接受它自己的参数或者可能是空的。它可以执行一个操作或返回一个值。它甚至可以返回另一个 lambda 表达式，但这通常有点大材小用，最好避免。<br>大体上讲，当您看到两个向右箭头时，可以将第一个箭头右侧的所有内容视为一个黑盒：一个由外部 lambda 表达式返回的 lambda 表达式。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>级联 lambda 表达式不是很常见，但您应该知道如何在代码中识别和理解它们。当一个 lambda 表达式返回另一个 lambda 表达式，而不是接受一个操作或返回一个值时，您将看到两个箭头。这种代码非常简短，但可能在最初遇到时非常难以理解。但是，一旦您学会识别这种函数式语法，理解和掌握它就会变得容易得多。</p>
<blockquote>
<p>作者：Venkat Subramaniam</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms9/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms9/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 习惯用语（8）：类型推断</title>
    <url>/2019/12/26/Java-8-%E4%B9%A0%E6%83%AF%E7%94%A8%E8%AF%AD%EF%BC%888%EF%BC%89%EF%BC%9A%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD/</url>
    <content><![CDATA[<p>Java™8 是第一个支持类型推断的 Java 版本，而且它仅对 lambda 表达式支持此功能。在 lambda 表达式中使用类型推断具有强大的作用，它将帮助您做好准备以应对未来的 Java 版本，在今后的版本中还会将类型推断用于变量等更多可能。这里的诀窍在于恰当地命名参数，相信 Java 编译器会推断出剩余的信息。<br>大多数时候，编译器完全能够推断类型。在它无法推断出来的时候，就会报错。<br>了解 lambda 表达式中的类型推断的工作原理，至少查看一个无法推断类型的示例。即使如此，也有解决办法。</p>
<a id="more"></a>

<h2 id="显式类型和冗余"><a href="#显式类型和冗余" class="headerlink" title="显式类型和冗余"></a>显式类型和冗余</h2><p>假设您询问某个人“您叫什么名字？”，他会回答“我名叫约翰”。这种情况经常发生，但简单地说“约翰”会更高效。您需要的只是一个名称，所以该句子的剩余部分都是多余的。<br>不幸的是，我们总是在代码中做这类多余的事情。Java 开发人员可以使用 <code>forEach</code> 迭代并输出某个范围内的每个值的双倍值，如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">IntStream</span>.</span></span>range<span class="constructor">Closed(1, 5)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  .for<span class="constructor">Each((<span class="params">int</span> <span class="params">number</span>)</span> -&gt; <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(number<span class="operator"> * </span><span class="number">2</span>));</span></pre></td></tr></table></figure>

<p><code>rangeClosed</code> 方法生成一个从 1 到 5 的 <code>int</code> 值流。lambda 表达式的唯一职责就是接收一个名为 <code>number</code> 的 <code>int</code> 参数，使用 <code>PrintStream</code> 的 <code>println</code> 方法输出该值的双倍值。从语法上讲，该 lambda 表达式没有错，但类型细节有些冗余。</p>
<h2 id="Java-8-中的类型推断"><a href="#Java-8-中的类型推断" class="headerlink" title="Java 8 中的类型推断"></a>Java 8 中的类型推断</h2><p>当您从某个数字范围中提取一个值时，编译器知道该值的类型为 <code>int</code>。不需要在代码中显式声明该值，尽管这是目前为止的约定。<br>在 Java 8 中，我们可以丢弃 lambda 表达式中的类型，如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">IntStream</span>.</span></span>range<span class="constructor">Closed(1, 5)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  .for<span class="constructor">Each((<span class="params">number</span>)</span> -&gt; <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(number<span class="operator"> * </span><span class="number">2</span>));</span></pre></td></tr></table></figure>

<p>由于 Java 是静态类型语言，它需要在编译时知道所有对象和变量的类型。在 lambda 表达式的参数列表中省略类型并不会让 Java 更接近动态类型语言。但是，添加适当的类型推断功能会让 Java 更接近其他静态类型语言，比如 Scala 或 Haskell。</p>
<h2 id="信任编译器"><a href="#信任编译器" class="headerlink" title="信任编译器"></a>信任编译器</h2><p>如果您在 lambda 表达式的一个参数中省略类型，Java 需要通过上下文细节来推断该类型。<br>返回到上一个示例，当我们在 <code>IntStream</code> 上调用 <code>forEach</code> 时，编译器会查找该方法来确定它采用的参数。<code>IntStream</code> 的 <code>forEach</code> 方法期望使用函数接口 <code>IntConsumer</code>，该接口的抽象方法 <code>accept</code> 采用了一个 <code>int</code> 类型的参数并返回 <code>void</code>。<br>如果在参数列表中指定了该类型，编译器将会确认该类型符合预期。<br>如果省略该类型，编译器会推断出预期的类型 —在本例中为 <code>int</code>。<br>无论是您提供类型还是编译器推断出该类型，Java 都会在编译时知道 lambda 表达式参数的类型。要测试这种情况，可以在 lambda 表达式中引入一个错误，同时省略参数的类型：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">IntStream</span>.</span></span>range<span class="constructor">Closed(1, 5)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  .for<span class="constructor">Each((<span class="params">number</span>)</span> -&gt; <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(number.length<span class="literal">()</span><span class="operator"> * </span><span class="number">2</span>));</span></pre></td></tr></table></figure>

<p>编译此代码时，Java 编译器会返回以下错误：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Sample</span>.</span></span>java:<span class="number">7</span>: error: <span class="built_in">int</span> cannot be dereferenced</span></pre></td></tr><tr><td class="code"><pre><span class="line">      .for<span class="constructor">Each((<span class="params">number</span>)</span> -&gt; <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(number.length<span class="literal">()</span><span class="operator"> * </span><span class="number">2</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                    ^</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span> error</span></pre></td></tr></table></figure>

<p>编译器知道名为 <code>number</code> 的参数的类型。它报错是因为它无法使用点运算符解除对某个 <code>int</code> 类型的变量的引用。可以对对象执行此操作，但不能对 <code>int</code> 变量这么做。</p>
<h2 id="类型推断的好处"><a href="#类型推断的好处" class="headerlink" title="类型推断的好处"></a>类型推断的好处</h2><p>在 lambda 表达式中省略类型有两个主要好处：</p>
<ul>
<li>键入的内容更少。无需输入类型信息，因为编译器自己能轻松确定该类型。</li>
<li>代码杂质更少 —<code>(number)</code> 比 <code>(int number)</code> 简单得多。</li>
</ul>
<p>此外，一般来讲，如果我们仅有一个参数，省略类型意味着也可以省略 <code>()</code>，如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">IntStream</span>.</span></span>range<span class="constructor">Closed(1, 5)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  .for<span class="constructor">Each(<span class="params">number</span> -&gt; System.<span class="params">out</span>.<span class="params">println</span>(<span class="params">number</span> <span class="operator">*</span> 2)</span>);</span></pre></td></tr></table></figure>

<p>请注意，您<em>将</em>需要为采用多个参数的 lambda 表达式添加括号。</p>
<h2 id="类型推断和可读性"><a href="#类型推断和可读性" class="headerlink" title="类型推断和可读性"></a>类型推断和可读性</h2><p>lambda 表达式中的类型推断违背了 Java 中的常规做法，在常规做法中，会指定每个变量和参数的类型。尽管一些开发人员辩称 Java 指定类型的约定让代码变得更可读、更容易理解，但我认为这种偏好反映出一种习惯而不是必要性。<br>以一个包含一系列转换的函数管道为例：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; result =</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cars.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="keyword">map</span><span class="function"><span class="params">((Car c) -&gt; c.getRegistration())</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    .<span class="title">map</span><span class="params">((String s) -&gt; DMVRecords.getOwner(s))</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    .<span class="title">map</span><span class="params">((Person o) -&gt; o.getName())</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    .<span class="title">map</span><span class="params">((String s) -&gt; s.toUpperCase())</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    .<span class="title">collect</span><span class="params">(toList())</span>;</span></span></pre></td></tr></table></figure>

<p>在这里，我们首先提供了一组 <code>Car</code> 实例和相关的注册信息。我们获取每辆车的车主和车主姓名，并将该姓名转换为大写。最后，将结果放入一个列表中。<br>这段代码中的每个 lambda 表达式都为其参数指定了一个类型，但我们为参数使用了单字母变量名。这在 Java 中很常见。但这种做法不合适，因为它丢弃了特定于域的上下文。<br>我们可以做得比这更好。让我们看看使用更强大的参数名重写代码后发生的情况：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; result =</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cars.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="keyword">map</span><span class="function"><span class="params">((Car car) -&gt; car.getRegistration())</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    .<span class="title">map</span><span class="params">((String registration) -&gt; DMVRecords.getOwner(registration))</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    .<span class="title">map</span><span class="params">((Person owner) -&gt; owner.getName())</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    .<span class="title">map</span><span class="params">((String name) -&gt; name.toUpperCase())</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    .<span class="title">collect</span><span class="params">(toList())</span>;</span></span></pre></td></tr></table></figure>

<p>这些参数名包含了特定于域的信息。我们没有使用 <code>s</code> 来表示 <code>String</code>，而是指定了特定于域的细节，比如 <code>registration</code> 和 <code>name</code>。类似地，我们没有使用 <code>p</code> 或 <code>o</code>，而是使用 <code>owner</code> 表明 <code>Person</code> 不只是一个人，还是这辆车的车主。<br>这个示例中的每个 lambda 表达式都比它所取代的表达式更好。在读取 lambda 表达式（例如 <code>(Person owner) -&gt; owner.getName()</code>）时，我们知道我们获得了车主的姓名，而不只是随便某个人的姓名。</p>
<h3 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h3><p>Scala 和 TypeScript 等一些语言更加重视参数名而不是类型。在 Scala 中，我们在定义类型之前定义参数，例如通过编写：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getOwner</span><span class="params">(<span class="symbol">registration:</span> String)</span></span></span></pre></td></tr></table></figure>

<p>而不是：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getOwner</span><span class="params">(String registration)</span></span></span></pre></td></tr></table></figure>

<p>类型和参数名都很有用，但在 Scala 中，参数名更重要一些。我们用 Java 编写 lambda 表达式时，也可以考虑这一想法。请注意我们在 Java 中的车辆注册示例中丢弃类型细节和括号时发生的情况：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; result =</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cars.stream<span class="literal">()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    .map(car -&gt; car.get<span class="constructor">Registration()</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .map(registration -&gt; <span class="module-access"><span class="module"><span class="identifier">DMVRecords</span>.</span></span>get<span class="constructor">Owner(<span class="params">registration</span>)</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .map(owner -&gt; owner.get<span class="constructor">Name()</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .map(name -&gt; name.<span class="keyword">to</span><span class="constructor">UpperCase()</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .collect(<span class="keyword">to</span><span class="constructor">List()</span>);</span></pre></td></tr></table></figure>

<p>因为我们添加了描述性的参数名，所以我们没有丢失太多上下文，而且显式类型（现在是冗余内容）已悄然消失。结果是我们获得了更干净、更朴实的代码。</p>
<h2 id="类型推断的局限性"><a href="#类型推断的局限性" class="headerlink" title="类型推断的局限性"></a>类型推断的局限性</h2><p>尽管使用类型推断可以提高效率和可读性，但这种技术并不适用于所有场合。在某些情况下，完全无法使用类型推断。幸运的是，您可以依靠 Java 编译器来获知何时出现这种情况。<br>我们首先看一个测试编译器并获得成功的示例，然后看一个测试失败的示例。最重要的是，在两种情况下，都能够相信编译器会按期望方式工作。</p>
<h3 id="扩展类型推断"><a href="#扩展类型推断" class="headerlink" title="扩展类型推断"></a>扩展类型推断</h3><p>在我们的第一个示例中，假设我们想创建一个 <code>Comparator</code> 来比较 <code>Car</code> 实例。我们首先需要一个 <code>Car</code> 类：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Car</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> String getRegistration() &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>接下来，我们将创建一个 <code>Comparator</code>，以便基于 <code>Car</code> 实例的注册信息对它们进行比较：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">public static Comparator&lt;Car&gt; createComparator() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> comparing<span class="function"><span class="params">((Car car) -&gt; car.getRegistration())</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">&#125;</span></span></pre></td></tr></table></figure>

<p>用作 <code>comparing</code> 方法的参数的 lambda 表达式在其参数列表中包含了类型信息。我们知道 Java 编译器非常擅长类型推断，那么让我们看看在省略参数类型的情况下会发生什么，如下所示：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Car&gt; <span class="title">createComparator</span>(<span class="params"></span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> comparing(car -&gt; car.getRegistration());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>comparing</code> 方法采用了 1 个参数。它期望使用 <code>Function</code> 并返回 <code>Comparator</code>。因为 <code>comparing</code> 是 <code>Comparator</code> 上的一个静态方法，所以编译器目前没有关于 <code>T</code> 或 <code>U</code> 可能是什么的线索。<br>为了解决此问题，编译器稍微扩展了推断范围，将范围扩大到传递给 <code>comparing</code> 方法的参数之外。它观察我们是如何处理调用 <code>comparing</code> 的结果的。根据此信息，编译器确定我们仅返回该结果。接下来，它看到由 <code>comparing</code> 返回的 <code>Comparator</code> 又作为 <code>Comparator</code> 由 <code>createComparator</code> 返回 。<br><em>注意了！</em>编译器现在已明白我们的意图：它推断应该将 <code>T</code> 绑定到 <code>Car</code>。根据此信息，它知道 lambda 表达式中的 <code>car</code> 参数的类型应该为 <code>Car</code>。<br>在这个例子中，编译器必须执行一些额外的工作来推断类型，但它成功了。接下来，让我们看看在提高挑战难度，让编译器达到其能力极限时，会发生什么。</p>
<h3 id="推断的局限性"><a href="#推断的局限性" class="headerlink" title="推断的局限性"></a>推断的局限性</h3><p>首先，我们在前一个 <code>comparing</code> 调用后面添加了一个新调用。在本例中，我们还为 lambda 表达式的参数重新引入显式类型：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">public static Comparator&lt;Car&gt; createComparator() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> comparing<span class="function"><span class="params">((Car car) -&gt; car.getRegistration())</span>.<span class="title">reversed</span><span class="params">()</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">&#125;</span></span></pre></td></tr></table></figure>

<p>借助显式类型，此代码没有编译问题，但现在让我们丢弃类型信息，看看会发生什么：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Car&gt; <span class="title">createComparator</span>(<span class="params"></span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> comparing(car -&gt; car.getRegistration()).reversed();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如您下面所见，进展并不顺利。Java 编译器抛出了错误：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Sample.java:21: error: cannot <span class="builtin-name">find</span> symbol</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return comparing(car -&gt; car.getRegistration()).reversed();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                               ^</span></pre></td></tr><tr><td class="code"><pre><span class="line">  symbol:   method getRegistration()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  location: variable car of<span class="built_in"> type </span>Object</span></pre></td></tr><tr><td class="code"><pre><span class="line">Sample.java:21: error: incompatible types: Comparator&lt;Object&gt; cannot be converted <span class="keyword">to</span> Comparator&lt;Car&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return comparing(car -&gt; car.getRegistration()).reversed();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                           ^</span></pre></td></tr><tr><td class="code"><pre><span class="line">2 errors</span></pre></td></tr></table></figure>

<p>像上一个场景一样，在包含 <code>.reversed()</code> 之前，编译器会询问我们将如何处理调用 <code>comparing(car -&gt; car.getRegistration())</code> 的结果。在上一个示例中，我们以 <code>Comparable</code> 形式返回结果，所以编译器能推断出 <code>T</code> 的类型为 <code>Car</code>。<br>但在修改过后的版本中，我们将传递 <code>comparable</code> 的结果作为调用 <code>reversed()</code> 的目标。<code>comparable</code> 返回 <code>Comparable</code>，<code>reversed()</code> 没有展示任何有关 <code>T</code> 的可能含义的额外信息。根据此信息，编译器推断 <code>T</code> 的类型肯定是 <code>Object</code>。遗憾的是，此信息对于该代码而言并不足够，因为 <code>Object</code> 缺少我们在 lambda 表达式中调用的 <code>getRegistration()</code> 方法。<br>类型推断在这一刻失败了。在这种情况下，编译器实际上需要一些信息。类型推断会分析参数、返回元素或赋值元素来确定类型，但在上下文提供的细节不足时，编译器就会达到其能力极限。</p>
<h3 id="能否采用方法引用作为补救措施？"><a href="#能否采用方法引用作为补救措施？" class="headerlink" title="能否采用方法引用作为补救措施？"></a>能否采用方法引用作为补救措施？</h3><p>在我们放弃这种特殊情况之前，让我们尝试另一种方法：不使用 lambda 表达式，而是尝试使用方法引用：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Car&gt; createComparator() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> comparing(<span class="string">Car:</span>:getRegistration).reversed();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>编译器对此解决方案非常满意。它在方法引用中使用 <code>Car::</code> 来推断类型。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>Java 8 为 lambda 表达式的参数引入了有限的类型推断能力，在未来的 Java 版本中，会将类型推断扩展到局部变量。现在应该学会省略类型细节并信任编译器，这有助于您轻松步入未来的 Java 环境。<br>依靠类型推断和适当命名的参数，编写简明、更富于表达且更少杂质的代码。只要您相信编译器能自行推断出类型，就可以使用类型推断。仅在您确定编译器确实需要您的帮助的情况下提供类型细节。</p>
<blockquote>
<p>作者：Venkat Subramaniam</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms8/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms8/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8 习惯用语（7）：函数接口</title>
    <url>/2019/12/26/Java-8-%E4%B9%A0%E6%83%AF%E7%94%A8%E8%AF%AD%EF%BC%887%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>lambda 表达式的<em>类型</em>是什么？一些语言使用<em>函数值</em>或<em>函数对象</em>来表示 lambda 表达式，但 Java™ 语言没有这么做。Java 使用函数接口来表示 lambda 表达式类型。乍一看似乎有点奇怪，但事实上这是一种确保对 Java 语言旧版本的向后兼容性的有效途径。</p>
<a id="more"></a>

<p>您应该非常熟悉下面这段代码：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="built_in">new</span> Thread(<span class="built_in">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">public</span> <span class="type">void</span> run() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("In another thread");</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">thread.<span class="keyword">start</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println("In main");</span></pre></td></tr></table></figure>

<p><code>Thread</code> 类和它的构造函数是在 Java 1.0 中引入的，距今已有超过 20 年的时间。从那时起，构造函数从未改变过。将 <code>Runnable</code> 的匿名实例传递给构造函数已成为一种传统。但是从 Java 8 开始，可以选择传递 lambda 表达式：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread<span class="function"><span class="params">(() -&gt; System.out.println(<span class="string">"In another thread"</span>))</span>;</span></span></pre></td></tr></table></figure>

<p><strong>关于本系列</strong><br>Java 8 是自 Java 语言诞生以来进行的一次最重大更新—包含了非常丰富的新功能，您可能想知道从何处开始着手了解它。在本系列中，作家兼教师 Venkat Subramaniam 提供了一种惯用的 Java 8 编程方法：这些简短的探索会激发您反思您认为理所当然的 Java 约定，同时逐步将新技术和语法集成到您的程序中。</p>
<p><code>Thread</code> 类的构造函数想要一个实现 <code>Runnable</code> 的实例。在本例中，我们传递了一个 lambda 表达式，而不是传递一个对象。我们可以选择向各种各样的方法和构造函数传递 lambda 表达式，包括在 Java 8 之前创建的一些方法和构造函数。这很有效，因为 lambda 表达式在 Java 中表示为函数接口。<br>函数接口有 3 条重要法则：</p>
<ol>
<li>一个函数接口只有一个抽象方法。</li>
<li>在 <code>Object</code> 类中属于公共方法的抽象方法不会被视为单一抽象方法。</li>
<li>函数接口可以有默认方法和静态方法。</li>
</ol>
<p>任何满足单一抽象方法法则的接口，都会被自动视为函数接口。这包括 <code>Runnable</code> 和 <code>Callable</code> 等传统接口，以及您自己构建的自定义接口。</p>
<h2 id="内置函数接口"><a href="#内置函数接口" class="headerlink" title="内置函数接口"></a>内置函数接口</h2><p>除了已经提到的单一抽象方法之外，JDK 8 还包含多个新函数接口。最常用的接口包括 <code>Function</code>、<code>Predicate</code> 和 <code>Consumer</code>，它们是在 <code>java.util.function</code> 包中定义的。<code>Stream</code> 的 <code>map</code> 方法接受 <code>Function</code> 作为参数。类似地，<code>filter</code> 使用 <code>Predicate</code>，<code>forEach</code> 使用 <code>Consumer</code>。该包还有其他函数接口，比如 <code>Supplier</code>、<code>BiConsumer</code> 和 <code>BiFunction</code>。<br>可以将内置函数接口用作我们自己的方法的参数。例如，假设我们有一个 <code>Device</code> 类，它包含方法 <code>checkout</code> 和 <code>checkin</code> 来指示是否正在使用某个设备。当用户请求一个新设备时，方法 <code>getFromAvailable</code> 从可用设备池中返回一个设备，或在必要时创建一个新设备。<br>我们可以实现一个函数来借用设备，就象这样：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> void borrowDevice(Consumer&lt;Device&gt; <span class="keyword">use</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="title">Device</span> <span class="title">device</span> = <span class="title">getFromAvailable</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    device.checkout();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">use</span>.<span class="title">accept</span>(<span class="title">device</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        device.checkin();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>borrowDevice</code> 方法：</p>
<ul>
<li>接受 <code>Consumer</code> 作为参数。</li>
<li>从池中获取一个设备（我们在这个示例中不关心线程安全问题）。</li>
<li>调用 <code>checkout</code> 方法将设备状态设置为 <em>checked out</em>。</li>
<li>将设备交付给用户。</li>
</ul>
<p>在完成设备调用后返回到 <code>Consumer</code> 的 <code>accept</code> 方法时，通过调用 <code>checkin</code> 方法将设备状态更改为 <em>checked in</em>。<br>下面给出了一种使用 <code>borrowDevice</code> 方法的方式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="constructor">Sample()</span>.borrow<span class="constructor">Device(<span class="params">device</span> -&gt; System.<span class="params">out</span>.<span class="params">println</span>(<span class="string">"using "</span> + <span class="params">device</span>)</span>);</span></pre></td></tr></table></figure>

<p>因为该方法接收一个函数接口作为参数，所以传入一个 lambda 表达式作为参数是可以接受的。</p>
<h2 id="自定义函数接口"><a href="#自定义函数接口" class="headerlink" title="自定义函数接口"></a>自定义函数接口</h2><p>尽管最好尽量使用内置函数接口，但有时需要自定义函数接口。<br>要创建自己的函数接口，需要做两件事：</p>
<ol>
<li>使用 <code>@FunctionalInterface</code> 注释该接口，这是 Java 8 对自定义函数接口的约定。</li>
<li>确保该接口只有一个抽象方法。</li>
</ol>
<p>该约定清楚地表明该接口应接收 lambda 表达式。当编译器看到该注释时，它会验证该接口是否只有一个抽象方法。<br>使用 <code>@FunctionalInterface</code> 注释可以确保，如果在未来更改该接口时意外违反抽象方法数量规则，您会获得错误消息。这很有用，因为您会立即发现问题，而不是留给另一位开发人员在以后处理它。没有人希望在将 lambda 表达式传递给其他人的自定义接口时获得错误消息。</p>
<h3 id="创建自定义函数接口"><a href="#创建自定义函数接口" class="headerlink" title="创建自定义函数接口"></a>创建自定义函数接口</h3><p>作为一个示例，我们将创建一个 <code>Order</code> 类，它有一系列 <code>OrderItem</code> 以及一个转换并输出它们的方法。我们首先创建一个接口。<br>下面的代码将创建一个 <code>Transformer</code> 函数接口。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">Transformer</span>&lt;<span class="symbol">T</span>&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    T transform(T input);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>该接口用 <code>@FunctionalInterface</code> 注释做了标记，表明它是一个函数接口。因为该注释包含在 <code>java.lang</code> 包中，所以没有必要导入。该接口有一个名为 <code>transform</code> 的方法，后者接受一个参数化为 <code>T</code> 类型的对象，并返回一个相同类型的转换后对象。转换的语义将由该接口的实现来决定。<br>这是 <code>OrderItem</code> 类：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderItem</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> final <span class="keyword">int</span> id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> final <span class="keyword">int</span> price;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderItem</span><span class="params">(<span class="keyword">int</span> theId, <span class="keyword">int</span> thePrice)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        id = theId;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        price = thePrice;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> price; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">String</span>.format(<span class="string">"id: %d price: %d"</span>, id, price); &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>OrderItem</code> 是一个简单的类，它有两个属性：<code>id</code> 和 <code>price</code>，以及一个 <code>toString</code> 方法。<br>现在来看看 <code>Order</code> 类。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.<span class="built_in">Stream</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;OrderItem&gt; items;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(List&lt;OrderItem&gt; orderItems)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        items = orderItems;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transformAndPrint</span><span class="params">(Transformer&lt;<span class="built_in">Stream</span>&lt;OrderItem&gt;&gt; transformOrderItems)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        transformOrderItems.transform(items.stream()).forEach(System.out::<span class="built_in">println</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>transformAndPrint</code> 方法接受 <code>Transform</code> 作为参数，调用 <code>transform</code> 方法来转换属于 <code>Order</code> 实例的订单项，然后按转换后的顺序输出这些订单项。<br>这是一个使用该方法的样本：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Comparator.comparing;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.<span class="built_in">Stream</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.*;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Order order = <span class="keyword">new</span> Order(Arrays.asList(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">new</span> OrderItem(<span class="number">1</span>, <span class="number">1225</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">new</span> OrderItem(<span class="number">2</span>, <span class="number">983</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">new</span> OrderItem(<span class="number">3</span>, <span class="number">1554</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        order.transformAndPrint(<span class="keyword">new</span> Transformer&lt;<span class="built_in">Stream</span>&lt;OrderItem&gt;&gt;() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">public</span> <span class="built_in">Stream</span>&lt;OrderItem&gt; transform(<span class="built_in">Stream</span>&lt;OrderItem&gt; orderItems) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> orderItems.sorted(comparing(OrderItem::getPrice));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们传递一个匿名内部类作为 <code>transformAndPrint</code> 方法的参数。在 <code>transform</code> 方法内，调用给定流的 <code>sorted</code> 方法，这会对订单项进行排序。这是我们的代码的输出，其中显示了按价格升序排列的订单项：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">id: <span class="number">2</span> price: <span class="number">983</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">id: <span class="number">1</span> price: <span class="number">1225</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">id: <span class="number">3</span> price: <span class="number">1554</span></span></pre></td></tr></table></figure>

<h3 id="lambda-表达式的强大功能"><a href="#lambda-表达式的强大功能" class="headerlink" title="lambda 表达式的强大功能"></a>lambda 表达式的强大功能</h3><p>在任何需要函数接口的地方，我们都有 3 种选择：</p>
<ol>
<li>传递一个匿名内部类。</li>
<li>传递一个 lambda 表达式。</li>
<li>在某些情况下传递一个方法引用而不是 lambda 表达式。</li>
</ol>
<p>传递匿名内部类的过程很复杂，我们只能传递方法引用来替代直通 lambda 表达式。考虑如果我们重写对 <code>transformAndPrint</code> 函数的调用，以使用 lambda 表达式来代替匿名内部类，将会发生什么：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">order.transform<span class="constructor">AndPrint(<span class="params">orderItems</span> -&gt; <span class="params">orderItems</span>.<span class="params">sorted</span>(<span class="params">comparing</span>(OrderItem::<span class="params">getPrice</span>)</span>));</span></pre></td></tr></table></figure>

<p>与我们最初提供的匿名内部类相比，这简洁得多且更容易阅读。</p>
<h2 id="自定义函数接口与内置函数接口"><a href="#自定义函数接口与内置函数接口" class="headerlink" title="自定义函数接口与内置函数接口"></a>自定义函数接口与内置函数接口</h2><p>我们的自定义函数接口演示了创建自定义接口的优势和不足。首先考虑优势：</p>
<ul>
<li>您可以为自定义接口提供一个描述性名称，帮助其他开发人员修改或重用它。像 <code>Transformer</code>、<code>Validator</code> 和 <code>ApplicationEvaluator</code> 这样的名称是特定于领域的，可以帮助读取接口方法的人推断对参数的预期是什么。</li>
<li>只要您高兴，可以为抽象方法提供任何具有有效语法的名称。只有接口的接收者会获得此优势，而且仅在传递抽象方法时才会体现出来。传递 lambda 表达式或方法引用的调用方不会获得此优势。</li>
<li>您可以在自己的接口中使用参数化的类型，或者让它保持简单并特定于某些类型。在本例中，可以编写 <code>Transformer</code> 接口来使用 <code>OrderItems</code> 而不是参数化类型 <code>T</code>。</li>
<li>您可以编写自定义的默认方法和静态方法，它们可供该接口的其他实现使用。</li>
</ul>
<p>当然，使用自定义函数接口也存在不足之处：</p>
<ul>
<li>想象创建多个接口，所有接口都有具有相同签名的抽象方法，比如接受 <code>String</code> 作为参数并返回 <code>Integer</code>。尽管方法的名称可能有所不同，但它们大部分都是多余的，可替换为一个具有通用名称的接口。</li>
<li>任何想要使用自定义接口的人，都必须投入额外的精力来学习、理解和记住它们。所有 Java 程序员都熟悉 <code>java.lang</code> 包中的 <code>Runnable</code>。我们一次又一次地看到它，所以可以轻松地记住它的用途。但是，如果我使用了一个自定义 <code>Executor</code>，您在使用该接口之前必须仔细了解它。在某些情况下，投入一些精力是值得的，但是如果 <code>Executor</code> 与 <code>Runnable</code> 非常相似，就会浪费精力。</li>
</ul>
<h2 id="哪种接口最好？"><a href="#哪种接口最好？" class="headerlink" title="哪种接口最好？"></a>哪种接口最好？</h2><p>了解自定义函数接口与内置函数接口的优缺点后，如何确定采用哪种接口？我们回顾一下 <code>Transformer</code> 接口来寻找答案。<br>回想一下，<code>Transformer</code> 的存在是为了传达将一个对象转换为另一个对象的语义。这里，我们按名称来引用它：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transformAndPrint</span><span class="params">(Transformer&lt;<span class="built_in">Stream</span>&lt;OrderItem&gt;&gt; transformOrderItems)</span> </span>&#123;</span></pre></td></tr></table></figure>

<p>方法 <code>transformAndPrint</code> 接收一个负责执行转换的参数。该转换可能对 <code>OrderItems</code> 集合中的元素进行重新排序。或者，它可能屏蔽每个订单项的部分细节。或者该转换可以决定什么都不做，仅返回原始集合。将实现工作留给调用方。<br>重要的是，调用方知道它们可以将转换实现作为参数提供给 <code>transformAndPrint</code> 方法。函数接口的名称和它的文档应该提供这些细节。在本例中，从参数名称 (<code>transformOrderItems</code>) 也可以清楚了解这些细节，而且它们应包含在 <code>transformAndPrint</code> 函数的文档中。尽管函数接口的名称很有用，但它不是了解函数接口用途和用法的唯一途径。<br>仔细查看 <code>Transformer</code> 接口，并将它的用途与 JDK 的内置函数接口进行比较，我们看到 <code>Function</code> 可以取代 <code>Transformer</code>。要测试 <code>Transformer</code> 函数接口，可以从代码中删除它并更改 <code>transformAndPrint</code> 函数，就像这样：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transformAndPrint</span><span class="params">(Function&lt;<span class="built_in">Stream</span>&lt;OrderItem&gt;, <span class="built_in">Stream</span>&lt;OrderItem&gt;&gt; transformOrderItems)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    transformOrderItems.apply(items.stream())</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .forEach(System.out::<span class="built_in">println</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>改动很小 —除了将 <code>Transformer&gt;</code> 更改为 <code>Function&gt;</code>、<code>Stream&gt;</code>，我们还将方法调用从 <code>transform()</code> 更改为 <code>apply()</code>。<br>对 <code>transformAndPrint</code> 的调用使用了一个匿名内部类，我们还需要更改这一点。但是，我们已更改该调用来使用 lambda 表达式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">order.transform<span class="constructor">AndPrint(<span class="params">orderItems</span> -&gt; <span class="params">orderItems</span>.<span class="params">sorted</span>(<span class="params">comparing</span>(OrderItem::<span class="params">getPrice</span>)</span>));</span></pre></td></tr></table></figure>

<p>函数接口的名称与 lambda 表达式无关—它仅与编译器相关，编译器将 lambda 表达式参数与方法参数联系起来。方法的名称是 <code>transform</code> 还是 <code>apply</code>，同样与调用方无关。<br>使用内置的函数接口让我们的接口减少了一个，调用该方法也具有同样功效。我们也没有损害代码的可读性。这个练习告诉我们，我们可以轻松地将自定义函数接口替换为内置接口。我们只需提供 <code>transformAndPrint</code> 的文档（未显示）并采用含义更明确的方式命名该参数。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>将 lambda 表达式设置为函数接口类型的设计决策，有助于在 Java 8 与早期 Java 版本之间实现向后兼容性。可以将 lambda 表达式传递给任何通常接收单一抽象方法接口的旧函数。要接收 lambda 表达式，方法的参数类型应为函数接口。<br>在某些情况下，创建自己的函数接口是合情合理的，但在这么做时应该小心谨慎。仅在应用程序需要高度专业化的方法时，或者现有接口无法满足您的需求时，才考虑自定义函数接口。请始终检查一个 JDK 的内置函数接口中是否存在该功能。尽量使用内置函数接口。</p>
<blockquote>
<p>作者：Venkat Subramaniam</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms7/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms7/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8 习惯用语（6）：完美的 lambda 表达式</title>
    <url>/2019/12/26/Java-8-%E4%B9%A0%E6%83%AF%E7%94%A8%E8%AF%AD%EF%BC%886%EF%BC%89%EF%BC%9A%E5%AE%8C%E7%BE%8E%E7%9A%84-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>目前您已在本系列中了解到，函数组合的一个主要好处是它会获得富于表达的代码。编写简短的 lambda 表达式是实现这一表达能力的关键，但通常说起来容易做起来难。本文会加深您目前对创建单行 lambda 表达式的各个方面的了解。通过学习函数组合的结构和好处，您很快就会掌握完美的 lambda 表达式，—一个仅短短一行的表达式。</p>
<a id="more"></a>

<h2 id="编写-lambda-表达式的两种方法"><a href="#编写-lambda-表达式的两种方法" class="headerlink" title="编写 lambda 表达式的两种方法"></a>编写 lambda 表达式的两种方法</h2><p>众所周知，lambda 表达式是匿名函数，它们天生就很简洁。普通的函数或方法通常有 4 个元素：</p>
<ul>
<li>一个名称</li>
<li>返回类型</li>
<li>参数列表</li>
<li>主体</li>
</ul>
<p>在这里可以看到，lambda 表达式只有这 4 元素中的最后两个：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">(parameter <span class="keyword">list</span>)</span> -&gt;</span> body</span></pre></td></tr></table></figure>

<p><code>“-&gt;”</code> 将参数列表与函数主体分离，旨在对给定参数进行处理。函数的主体可能是一个表达式或一条语句。下面给出了一个示例：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">(Integer e)</span> -&gt;</span> e * <span class="number">2</span></span></pre></td></tr></table></figure>

<p>在此代码中，主体只有一行：一个返回给定参数两次的表达式。信噪比很高，没有分号，也不需要 <code>return</code> 关键字。这就是一个理想的 lambda 表达式。</p>
<h3 id="多行-lambda-表达式"><a href="#多行-lambda-表达式" class="headerlink" title="多行 lambda 表达式"></a>多行 lambda 表达式</h3><p>在 Java ™中，lambda 表达式的主体也可能是一个复杂的表达式或声明语句；也就是说，一个 lambda 表达式包含多行。在这种情况下，分号必不可少。如果 lambda 表达式返回一个结果，也会需要 <code>return</code> 关键字。下面给出了一个示例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">Integer</span> e) -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> <span class="built_in">sqrt</span> = Math.<span class="built_in">sqrt</span>(e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> <span class="built_in">log</span> = Math.<span class="built_in">log</span>(e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span> + <span class="built_in">log</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>本示例中的 lambda 表达式返回了 <code>sqrt</code> 和给定参数的 <code>log</code> 的和。因为主体包含多行，所以括号 (<code>{}</code>)、分号 (<code>;</code>) 和 <code>return</code> 关键字都是必需的。<br>如果感觉好像 Java 因为我们编写多行 lambda 表达式而惩罚我们，—或许我们应该接受这样的暗示。</p>
<h2 id="函数组合的强大功能"><a href="#函数组合的强大功能" class="headerlink" title="函数组合的强大功能"></a>函数组合的强大功能</h2><p>函数式编码风格利用了函数组合的表达能力。比较两段代码时，很容易看出富于表达的好处。第一段代码是用命令式风格编写的：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> result = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> e : values) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(e &gt; <span class="number">3</span> &amp;&amp; e % <span class="number">2</span> == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      result = e * <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>现在考虑用函数式风格编写的相同代码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> result = values.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .filter(e -&gt; e &gt; <span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .filter(e -&gt; e % <span class="number">2</span> == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .map(e -&gt; e * <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .findFirst()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .orElse(<span class="number">0</span>);</span></pre></td></tr></table></figure>

<p>两段代码获得了相同的结果。在命令式代码中，我们需要读入 <code>for</code> 循环，按照分支和中断来跟随流程。第二段代码使用了函数组合，更容易阅读一些。因为它是从上往下执行的，所以我们只需要传递该代码一次。<br>本质上，第二段代码读起来像是一个问题陈述：<em>给定一些值，仅选择大于 3 的值。从这些值中，仅选择偶数值，并将它们乘以 2。最后，挑选第一个结果。如果没有任何值存在，则返回 0。</em><br>此代码不仅优雅，而且它的<em>工作量并不比</em>命令式代码多。得益于 <code>Stream</code>的惰性计算能力，这里没有浪费计算资源。<br>函数组合的表达能力很大程度上依赖于每个 lambda 表达式的简洁性。如果您的 lambda 表达式包含多行（甚至<a href="https://twitter.com/venkat_s/status/611119147586600960" target="_blank" rel="noopener">两行可能都太多</a>），您可能没有理解函数式编程的关键点。</p>
<h2 id="充满危险的长-lambda-表达式"><a href="#充满危险的长-lambda-表达式" class="headerlink" title="充满危险的长 lambda 表达式"></a>充满危险的长 lambda 表达式</h2><p>要更好地理解编写简短的 lambda 表达式的好处，可考虑反面情况：一个包含多行代码的杂乱 lambda 表达式：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">System.<span class="keyword">out</span>.println(</span></pre></td></tr><tr><td class="code"><pre><span class="line">values.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .mapToInt(e -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= e; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span>(e % i == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">sum</span> += i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .<span class="built_in">sum</span>());</span></pre></td></tr></table></figure>

<p>尽管此代码是用函数式风格编写的，但它丢失了函数式编程的优点。让我们考虑一下原因何在。</p>
<p>1.难以读懂</p>
<p>好代码应该易于读懂。此代码需要绞尽脑汁才能读懂：很难找到不同部分的开头和结尾。</p>
<p>2.用途不明</p>
<p>好代码读起来应该像一个故事，而不是像一个字谜。像这样冗长的、无特色的代码隐藏了它的具体用途，会耗费读者的时间和精力。将这段代码包装在一个命名函数中可以使其模块化，同时也可以通过相关的名称揭示它的用途。</p>
<p>3.代码质量差</p>
<p>无论您的代码有何用途，您可能都希望在某个时候重用它。这段代码的逻辑已嵌入在 lambda 表达式中，后者又以参数形式传递给另一个函数 <code>mapToInt</code>。如果我们在程序的其他某个地方需要该代码，我们可能忍不住重写它，这会引起代码库中的不一致性。或者，我们也可以复制并粘贴该代码。两种选项都会得到好代码或高品质的软件。</p>
<p>4.难以测试</p>
<p>代码始终依靠键入的内容进行操作，而且不一定是我们打算执行的操作，所以这代表着必须测试任何非平凡代码。如果 lambda 表达式中的代码无法用作一个单元，则无法对它执行单元测试。您可以运行集成测试，但这无法取代单元测试，尤其是在代码执行重要工作时。</p>
<p>5.代码覆盖范围小</p>
<p>一位学习 Java 8 课程的学员最近表示他们讨厌 lambda 表达式。在我问为什么时，他们向我展示了一位同事的作品，其中包含的 lambda 表达式运行了数百行代码。嵌入在参数中的 Lambda 表达式无法轻松地作为单元提取出来，而且许多表达式在覆盖范围报告中显示为红色。由于一无所知，该团队很难假设这些代码在工作正常。</p>
<h2 id="使用-Lambda-作为粘合代码"><a href="#使用-Lambda-作为粘合代码" class="headerlink" title="使用 Lambda 作为粘合代码"></a>使用 Lambda 作为粘合代码</h2><p>解决所有这些问题的方法是让您的 lambda 表达式高度简洁。作为第一个且非常有用的步骤，避免在 lambda 表达式中使用括号。考虑如何使用此技术轻松地重写前面杂乱的 lambda 表达式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(</span></pre></td></tr><tr><td class="code"><pre><span class="line">values.stream<span class="literal">()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  .map<span class="constructor">ToInt(<span class="params">e</span> -&gt; <span class="params">sumOfFactors</span>(<span class="params">e</span>)</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .sum<span class="literal">()</span>);</span></pre></td></tr></table></figure>

<p>此代码很简洁，尽管它不完整。该代码也具有很高的可读性。它的用途是： <em>给定一组值，将该列表转换为每个数的因数之和，然后计算所获得的集合的和。</em> 显式命名以前包含在括号中的代码主体，这会让此代码变得更容易阅读和理解。函数管道现在既整洁又容易理解。<br>不需要解字谜，因为此代码直接表明了它的用途。计算因数之和的代码已模块化为一个名为 <code>sumOfFactors</code>的单独方法，该方法可以重用。因为它是一个单独方法，所以对它的逻辑执行单元测试也很容易。因为此代码如此容易测试，所以您可以确保良好的代码覆盖范围。<br>简言之，曾经杂乱的 lambda 表达式现在成为了 <em>粘合代码</em>— 它没有承担大量责任，只是将命名函数粘合到 <code>mapToInt</code> 函数。</p>
<h3 id="使用方法引用进行调优"><a href="#使用方法引用进行调优" class="headerlink" title="使用方法引用进行调优"></a>使用方法引用进行调优</h3><p>就像在<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms5/index.html" target="_blank" rel="noopener">本系列的其他地方</a>看到的一样，可以通过将 lambda 表达式替换为方法引用，让上述代码更富于表达（其中 <code>sumOfFactors</code> 是一个名为 <code>Sample</code>的类的方法）：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="selector-tag">values</span><span class="selector-class">.stream</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="selector-class">.mapToInt</span>(<span class="selector-tag">Sample</span><span class="selector-pseudo">::sumOfFactors)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="selector-class">.sum</span>());</span></pre></td></tr></table></figure>

<p>这是重写后的 <code>sumOfFactors</code> 方法：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> static <span class="built_in">int</span> sumOfFactors(<span class="built_in">int</span> <span class="keyword">number</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> IntStream.rangeClosed(<span class="number">1</span>, <span class="keyword">number</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(i -&gt; <span class="keyword">number</span> % i == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .<span class="built_in">sum</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>现在它是一个简短的方法。该方法中的 lambda 表达式也很简洁：只有一行，没有过多的繁杂过程或噪音。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>简短的 lambda 表达式能提高代码可读性，这是函数式编程的重要好处之一。包含多行的 lambda 表达式具有相反的效果，会让代码变得杂乱且难以阅读。多行 lambda 表达式还难以测试和重用，这可能导致重复工作和代码质量差。幸运的是，通过将多行 lambda 表达式的主体转移到一个命名函数中，然后从 lambda 表达式内调用该函数，这样很容易避免这些问题。我也推荐尽可能将 lambda 表达式替换为方法引用。<br>简言之，我推荐避免多行 lambda 表达式，除非是为了演示它们为什么不好。</p>
<blockquote>
<p>作者：Venkat Subramaniam</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms6/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms6/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 习惯用语（5）：传递表达式的替代方案</title>
    <url>/2019/12/26/Java-8-%E4%B9%A0%E6%83%AF%E7%94%A8%E8%AF%AD%EF%BC%885%EF%BC%89%EF%BC%9A%E4%BC%A0%E9%80%92%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>Lambda 表达式被广泛用在函数式编程中，但它们很难阅读和理解。在许多情况下，lambda 表达式的存在<em>只是</em>为了传递一个或多个形参，最好将它替换为方法引用。在本文中，您将学习如何识别代码中的传递 lambda 表达式，以及如何将它们替换为相应的方法引用。尽管方法引用的使用需要学习，但长期收益很快会超过您最初的付出。</p>
<a id="more"></a>

<h2 id="传递-lambda-表达式是什么？"><a href="#传递-lambda-表达式是什么？" class="headerlink" title="传递 lambda 表达式是什么？"></a>传递 lambda 表达式是什么？</h2><p>在函数式编程中，常常传递 lambda 表达式作为匿名函数，使用 lambda 作为更高阶函数的实参。例如，在清单 1 中，我们将一个 lambda 表达式传递给 <code>filter</code> 方法：</p>
<p>清单 1. 一个传递 lambda 表达式</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">numbers.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .filter(e -&gt; e % <span class="number">2</span> == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .forEach(e -&gt; System.<span class="keyword">out</span>.println(e));</span></pre></td></tr></table></figure>

<p>请注意，在此代码中，我们还将一个 lambda 表达式传递给了 <code>forEach</code> 方法。尽管这两个 lambda 表达式明显具有不同作用，但它们之间还有另一个重要的细微区别：第一个 lambda 表达式实际执行一些工作，而第二个没有。<br>传递给 <code>forEach</code> 方法的 lambda 表达式就是我们所称的<em>传递 lambda 表达式</em>。表达式 <code>e -&gt; System.out.println(e)</code><em>将它的形参</em>作为实参传递给 <code>PrintStream</code> 类的 <code>println</code> 方法，该方法是 <code>System.out</code> 实例。<br>尽管清单 1 中的第二个 lambda 表达式没有任何错误，但它的语法对于当前这个任务而言过于复杂。为了理解 <code>(parameters) -&gt; body</code> 的用途，我们需要进入 <em>body</em>（在 <code>-&gt;</code> 的右侧）来查看该形参发生了什么。如果该 lambda 表达式没有对该形参执行任何实际操作，则付出的努力就白费了。<br>在此情况下，将传递 lambda 表达式替换为方法引用会比较有益。不同于方法调用，方法引用指的是我们传递形参的方法。使用方法引用也会带来各种各样的形参传递方式。<br>尝试像这样重写前面的代码：</p>
<p>清单 2. 通过方法引用传递形参</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">numbers</span><span class="selector-class">.stream</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="selector-class">.filter</span>(e -&gt; e % <span class="number">2</span> == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="selector-class">.forEach</span>(System.<span class="attribute">out</span>::println);</span></pre></td></tr></table></figure>

<p>使用方法引用会减少理解代码的工作。尽管最初的好处可能看起来较小，但随着我们编写和阅读更多代码，好处会倍增。</p>
<h2 id="传递形参作为实参"><a href="#传递形参作为实参" class="headerlink" title="传递形参作为实参"></a>传递形参作为实参</h2><p>在接下来的几节中，我们将探讨传递 lambda 表达式的变形。我将介绍如何将每种表达式替换为方法引用。</p>
<h3 id="实例方法的实参"><a href="#实例方法的实参" class="headerlink" title="实例方法的实参"></a>实例方法的实参</h3><p>lambda 表达式将其形参作为实参传递给实例方法，这非常常见。您在清单 1 中已看到，形参 <code>e</code> 作为实参传递给 <code>println</code> 方法，该方法本身是 <code>System.out</code> 的一个实例方法。<br>在清单 2 中，我们使用以下格式将此 lambda 表达式替换为方法引用 <code>System.out::println</code>：<em>referenceToInstance::methodName</em>。<br>在图 1 中可以看到这种替换，图中展示了一个 lambda 表达式的结构，形参作为实参传递给一个实例方法：</p>
<p>图 1. 从形参到实例方法的实参</p>
<p><img src="http://image.winrains.cn/2019/08/c02a9-figure1.jpg" alt="一个传递 lambda 表达式的结构图。"><br>如果不熟悉方法引用，查看这样的 lambda 表达式能帮助您理解它的结构和形参传递到何处。要将 lambda 表达式更改为方法引用，只需删除通用的部分（形参和实参），并在方法调用上将点替换为冒号。</p>
<h4 id="this-上的一个方法的实参"><a href="#this-上的一个方法的实参" class="headerlink" title="this 上的一个方法的实参"></a><code>this</code> 上的一个方法的实参</h4><p>前面的传递表达式的一种特殊情况是，在当前方法的 <em>context</em> 实例上调用实例方法。<br>假设我们有一个名为 <code>Example</code> 的类，其中包含一个实例方法 <code>increment</code>：</p>
<p>清单 3. 一个包含实例方法的类</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Example</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> increment(<span class="built_in">int</span> number) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> number + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>现在假设我们有另一个实例方法，我们在其中创建了一个 lambda 表达式并将它传递给 <code>Stream</code> 的 <code>map</code> 方法，如下所示：</p>
<p>清单 4. 一个将形参传递给实例方法的 lambda 表达式</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line">.map(<span class="variable">e</span> -&gt; <span class="function"><span class="title">increment</span>(<span class="variable">e</span>))</span></span></pre></td></tr></table></figure>

<p>可能不那么显而易见，但此代码在结构上非常类似于上一个示例 — 在两种情况下，我们都将形参作为实参传递给实例方法。稍微重写此代码，以让此相似性更加明显：</p>
<p>清单 5. 传递表达式揭秘</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">.<span class="keyword">map</span>(e<span class="function"> -&gt;</span> <span class="keyword">this</span>.increment(e))</span></pre></td></tr></table></figure>

<p>引入冗余的 <code>this</code> 作为对 <code>increment</code> 的调用的目标，以让传递表达式的结构变得清晰。现在我们可以通过方法引用轻松地解决冗余问题：</p>
<p>清单 6. 方法引用解决冗余问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.<span class="built_in">map</span>(<span class="keyword">this</span>::increment)</span></pre></td></tr></table></figure>

<p>与将 <code>e -&gt; System.out.println(e)</code> 替换为 <code>System.out::println</code> 非常相似的是，可以将 lambda 表达式 <code>e -&gt; increment(e)</code>（或更准确地讲 <code>e -&gt; this.increment(e)</code>）替换为 <code>this::increment</code>。在两种情况下，代码都更加清晰。</p>
<h3 id="静态方法的实参"><a href="#静态方法的实参" class="headerlink" title="静态方法的实参"></a>静态方法的实参</h3><p>在前面两个示例中，我们替换的 lambda 表达式将一个形参作为实参传递给实例方法。也可以替换将形参传递给静态方法的 lambda 表达式。</p>
<p>清单 7. 将形参传递给静态方法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">.map(e -&gt; <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>value<span class="constructor">Of(<span class="params">e</span>)</span>)</span></pre></td></tr></table></figure>

<p>这里，lambda 表达式将形参作为实参传递给 <code>Integer</code> 类的 <code>valueOf</code> 方法。该代码的结构与图 1 中所示的结构相同。唯一的区别在于，在这个例子中，被调用的方法是<em>静态方法</em>而不是实例方法。就像前两个示例一样，我们将此 lambda 表达式替换为方法引用。我们未将方法引用放在实例上，而将它放在一个类上，如清单 8 所示。</p>
<p>清单 8. 对静态方法的方法引用</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">.<span class="built_in">map</span>(<span class="built_in">Integer</span><span class="type">::valueOf</span>)</span></pre></td></tr></table></figure>

<p>总结一下：如果 lambda 表达式的目的仅是将一个形参传递给实例方法，那么可以将它替换为实例上的方法引用。如果传递表达式要传递给静态方法，可以将它替换为类上的方法引用。</p>
<h2 id="将形参传递给目标"><a href="#将形参传递给目标" class="headerlink" title="将形参传递给目标"></a>将形参传递给目标</h2><p>您可能在两种不同的场景中使用 <em>ClassName::methodName</em> 格式。您刚才已看到第一种场景，其中的形参作为实参传递给静态方法。现在让我们考虑一种变形：形参是方法调用的目标。</p>
<p>清单 9. 使用形参作为目标</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.map</span>(<span class="selector-tag">e</span> <span class="selector-tag">-</span>&gt; <span class="selector-tag">e</span><span class="selector-class">.doubleValue</span>())</span></pre></td></tr></table></figure>

<p>在这个示例中，形参 <code>e</code>（我们假设其推断类型为 <code>Integer</code>）是对 <code>doubleValue</code> 方法的调用的目标。图 2 中给出了这种传递 lambda 表达式的结构。</p>
<p>图 2. 从形参到目标</p>
<p><img src="http://image.winrains.cn/2019/08/5d54c-figure2.jpg" alt="一个将形参传递给目标的 lambda 表达式的结构图。"><br>尽管前两个 lambda 表达式中的形参以不同方式传递 — 一个作为实参传递给静态方法，另一个作为实例方法调用的目标 — 但方法引用的格式完全相同：<em>ClassName::methodName</em>。</p>
<h4 id="模糊性与方法引用"><a href="#模糊性与方法引用" class="headerlink" title="模糊性与方法引用"></a>模糊性与方法引用</h4><p>查看方法引用，不容易确定形参传递给了静态方法还是用作了目标。要了解区别，我们需要知道方法是静态方法还是实例方法。从代码可读性角度讲，这不那么重要，但知道该区别对成功编译至关重要。<br>如果一个类的一个静态方法和一个兼容的实例方法同名，而且我们使用了方法引用，则编译器将认为该调用模糊不清。所以，举例而言，我们不能将 lambda 表达式 <code>(Integer e) -&gt; e.toString()</code> 替换为方法引用 <code>Integer::toString</code>，因为 <code>Integer</code> 类同时包含静态方法 <code>public static String toString(int i)</code> 和实例方法 <code>public String toString()</code>。<br>您或您的 IDE 可能建议使用 <code>Object::toString</code> 解决这个特定的问题，因为 <code>Object</code> 中没有 <code>static``toString</code> 方法。尽管该解决方案可以编译，但这种小聪明通常没什么帮助。您必须能够确认方法引用正在调用想要的方法。在存在疑问时，最好使用 lambda 表达式，以避免任何混淆或可能的错误。</p>
<h2 id="传递构造函数调用"><a href="#传递构造函数调用" class="headerlink" title="传递构造函数调用"></a>传递构造函数调用</h2><p>除了静态和实例方法，也可以使用方法引用来表示对构造函数的调用。考虑一个从 <code>Supplier</code> 中发出的构造函数调用，Supplier 作为实参提供给 <code>toCollection</code> 方法，如下所示。</p>
<p>清单 10. 一个构造函数调用</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">.collect<span class="function"><span class="params">(toCollection(() -&gt; <span class="keyword">new</span> LinkedList&lt;Double&gt;()))</span>;</span></span></pre></td></tr></table></figure>

<p>清单 10 中代码的目的是获取一个数据 <code>Stream</code> ，将它精减或收集到一个 <code>LinkedList</code> 中。<code>toCollection</code> 方法接受一个 <code>Supplier</code> 作为其实参。Supplier 不接受任何形参，因此 <code>()</code> 为空。它返回一个 <code>Collection</code> 实例，该实例在本例中是 <code>LinkedList</code>。<br>尽管参数列表是空的，但代码的一般结构如下：</p>
<p>图 3. 从形参到构造函数实参</p>
<p><img src="http://image.winrains.cn/2019/08/92ca7-figure3.jpg" alt="一个用于将形参传递给构造函数的 lambda 表达式的结构图。"><br>收到的形参（可能是空的）被作为实参传递给构造函数。在此示例中，我们可以将 lambda 表达式替换为对 <code>new</code> 的方法引用。做法如下：</p>
<p>清单 11. 将构造函数调用替换为方法引用</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">.collect(<span class="keyword">to</span><span class="constructor">Collection(LinkedList::<span class="params">new</span>)</span>);</span></pre></td></tr></table></figure>

<p>包含方法引用的代码比包含 lambda 表达式的原始代码简洁得多，因此更容易阅读和理解。</p>
<h2 id="传递多个实参"><a href="#传递多个实参" class="headerlink" title="传递多个实参"></a>传递多个实参</h2><p>目前您已看到了单一形参和传递空形参的例子。但方法引用不仅限于 0 或 1 个形参，它们也适用于多个实参。考虑下面这个 <code>reduce</code> 运算：</p>
<p>清单 12. 对 lambda 表达式执行 reduce()</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">.reduce<span class="function"><span class="params">(<span class="number">0</span>, (total, e) -&gt; Integer.sum(total, e))</span>);</span></span></pre></td></tr></table></figure>

<p>在 <code>Stream</code> 上调用 <code>reduce</code> 方法，并使用 <code>Integer</code> 的 <code>sum</code> 方法对流中的值求和。这个例子中的 lambda 表达式接受两个形参，它们作为实参（按完全相同的顺序）传递给 <code>sum</code> 方法。图 4 显示了这个 lambda 表达式的结构。</p>
<p>图 4. 传递两个形参作为实参</p>
<p><img src="http://image.winrains.cn/2019/08/7bd79-figure4.jpg" alt="一个用于将两个形参作为实参传递的 lambda 表达式的结构图。"><br>我们可以将这个 lambda 表达式替换为方法引用，如下所示：</p>
<p>清单 13. 替换一个接受两个形参的 lambda 表达式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.reduce</span>(0, <span class="selector-tag">Integer</span><span class="selector-pseudo">::sum))</span>;</span></pre></td></tr></table></figure>

<p>如果 <code>static</code> 方法调用接受提供给 lambda 表达式的形参作为实参（与它们在形参列表中出现的顺序完全相同），则可以将 lambda 表达式替换为指向 <code>static</code> 方法的方法引用。</p>
<h4 id="作为目标和实参传递"><a href="#作为目标和实参传递" class="headerlink" title="作为目标和实参传递"></a>作为目标和实参传递</h4><p>无需将所有形参作为实参传递给 <code>static</code> 方法，lambda 表达式可以使用一个形参作为实例方法调用的目标。如果第一个形参用作目标，则可以将 lambda 表达式替换为方法引用。考虑清单 14。</p>
<p>清单 14. 对使用形参作为目标的 lambda 表达式执行 reduce()</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">.reduce<span class="function"><span class="params">(<span class="string">""</span>, (result, letter) -&gt; result.concat(letter))</span>);</span></span></pre></td></tr></table></figure>

<p>在这个例子中，在 <code>Stream</code> 上调用 <code>reduce</code> 方法。该 lambda 表达式使用 <code>String</code> 的 <code>concat</code> 实例方法串联字符串。这个 lambda 表达式中的传递结构不同于您在上一个 <code>reduce</code> 示例中看到的结构：</p>
<p>图 5. 第一个形参作为调用的目标而传递</p>
<p><img src="http://image.winrains.cn/2019/08/35ea6-figure5.jpg" alt="一个用于传递两个形参中第一个形参的 lambda 表达式的结构图。"><br>lambda 表达式的第一个形参用作实例方法调用的目标。第二个形参用作该方法的实参。根据此顺序，可以将该 lambda 表达式替换为方法引用，如清单 15 所示：</p>
<p>清单 15. 使用第一个形参作为目标的方法引用</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">.reduce(<span class="string">""</span>, <span class="built_in">String</span><span class="type">::concat</span>));</span></pre></td></tr></table></figure>

<p>请注意，尽管该 lambda 表达式调用了一个实例方法，但您再次使用了类名称。换句话说，无论您调用静态方法还是将第一个形参作为目标来调用实例方法，方法引用看起来都是一样的。只要不存在模糊性，就没有问题。</p>
<h2 id="最好使用方法引用"><a href="#最好使用方法引用" class="headerlink" title="最好使用方法引用"></a>最好使用方法引用</h2><p>要掌握传递 lambda 表达式的变形和结构，以及取代它们的方法引用，需要花一定的时间和精力。我花了两周时间才完全理解这些概念和语法。在这之后，就开始感觉使用方法引用取代传递表达式变得更加自然。<br>比 lambda 表达式更好的是，方法引用还使您的代码变得非常简洁和富于表达，这可以大大减少阅读代码的工作。要进一步理解这一点，可以考虑最后一个示例。</p>
<p>清单 16. 使用 lambda 表达式的示例</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; nonNullNamesInUpperCase =</span></pre></td></tr><tr><td class="code"><pre><span class="line">    names.stream<span class="literal">()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      .filter(name -&gt; <span class="module-access"><span class="module"><span class="identifier">Objects</span>.</span></span>non<span class="constructor">Null(<span class="params">name</span>)</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">      .map(name -&gt; name.<span class="keyword">to</span><span class="constructor">UpperCase()</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">      .collect(collecting<span class="constructor">AndThen(<span class="params">toList</span>()</span>, <span class="built_in">list</span> -&gt; <span class="module-access"><span class="module"><span class="identifier">Collections</span>.</span></span>unmodifiable<span class="constructor">List(<span class="params">list</span>)</span>));</span></pre></td></tr></table></figure>

<p>给定一个 <code>List names</code>，上面的代码删除列表中的所有 <code>null</code> 值，将每个名称转换为大写，并将结果收集到一个无法修改的列表中。<br>现在让我们使用方法引用重写上述代码。在本例中，每个 lambda 表达式都是一个传递表达式，无论是传递给静态方法还是实例方法。因此，我们将每个 lambda 表达式替换为一个方法引用：</p>
<p>清单 17. 使用方法引用</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; nonNullNamesInUpperCase =</span></pre></td></tr><tr><td class="code"><pre><span class="line">    names.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">      .filter(Objects<span class="type">::nonNull</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">      .<span class="built_in">map</span>(<span class="built_in">String</span><span class="type">::toUpperCase</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">      .collect(collectingAndThen(toList(), Collections<span class="type">::unmodifiableList</span>));</span></pre></td></tr></table></figure>

<p>比较这两个清单，很容易看到使用方法引用的代码更加流畅且更容易阅读。它的意思很简单：<em>给定名称，过滤非 null 值，映射到大写形式，然后收集到一个不可修改的列表中</em>。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>只要看到一个 lambda 表达式的唯一目的是将形参传递给一个或多个其他函数，就需要考虑将该 lambda 表达式替换为方法引用是否更好。决定因素在于，lambda 表达式内没有完成任何实际工作。在这种情况下，lambda 表达式就是一个<em>传递</em>表达式，而且它的语法对于当前这个任务而言可能过于复杂了。<br>对于大部分开发人员，需要花一些精力才能了解如何使用方法引用。但是，一旦熟悉了，您就会发现与使用 lambda 表达式的代码相比，使用方法引用会让同样的代码更流畅且富于表达。</p>
<blockquote>
<p>作者：Venkat Subramaniam</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms5/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms5/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 习惯用语（4）：提倡使用有帮助的编码</title>
    <url>/2019/12/26/Java-8-%E4%B9%A0%E6%83%AF%E7%94%A8%E8%AF%AD%EF%BC%884%EF%BC%89%EF%BC%9A%E6%8F%90%E5%80%A1%E4%BD%BF%E7%94%A8%E6%9C%89%E5%B8%AE%E5%8A%A9%E7%9A%84%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>表达能力是函数式编程的优势之一，但这对您的代码意味着什么？在本文中，我们将比较命令式和函数式代码的示例，判断这两者的表达能力和简洁性的品质。您将了解这些品质如何帮助确保可读性，还会考虑一个反面示例：对简洁性的过度追求导致代码无用。最后，我将介绍 Java 8 对于函数组合中的垂直对齐点的约定。尽管一些 Java 开发人员可能不熟悉此约定，但可以用一个简单示例来证明其价值。</p>
<p><strong>关于本系列</strong><br>Java 8 是自 Java 语言诞生以来进行的一次最重大更新 — 包含了非常丰富的新功能，您可能想知道从何处开始着手了解它。在本系列中，作家兼教师 Venkat Subramaniam 提供了一种惯用的 Java 8 编程方法：在逐步将新技术和语法集成到您的程序中时，这些简短的探索会激发您对理所当然的 Java 约定的反思。</p>
<a id="more"></a>

<h2 id="令人惊讶的结果"><a href="#令人惊讶的结果" class="headerlink" title="令人惊讶的结果"></a>令人惊讶的结果</h2><p>在 Java 8 发布一年左右，我在自己的网站上宣布进行一次简短且不受约束的调查，并邀请开发人员参与该调查。每个参与者都会看到一段命令式或函数式代码，然后需要确定代码的行为。我计算了每位访问者提供回复所花的时间，并比较来自两个不同代码示例的结果。该调查开放了 48 小时，在此期间有 1,100 多人参与调查。调查结果令人感到有些惊讶。<br>大部分开发人员，包括作者本人，都有丰富的命令式编程经验。尽管函数式编程已存在很长时间，但大部分 Java 程序员都对它并不熟悉。了解到这一点后，82% 的收到命令式代码的调查回复者能确定其正确行为并不令人感到惊讶。与此同时，收到函数式代码的回复者中只有 75% 回答正确。<br>但是，令我惊讶的是回复者理解两个代码示例所用的时间。理解命令式代码所用的平均时间比理解函数式代码所用的平均时间长 30 秒。</p>
<h2 id="在家里尝试这个实验"><a href="#在家里尝试这个实验" class="headerlink" title="在家里尝试这个实验"></a>在家里尝试这个实验</h2><p>函数式代码比命令式代码更富于表达且更简洁 —<em>前提是需要精心编写</em>。一个简单示例可以证明这一点。在查看下面的代码示例之前，请准备一个计时器。像我的调查回复者一样，您的任务是理解代码的细节。您要计算每个示例所需的时间。<br>准备好了吗？启动计时器并阅读下面的代码，然后写下您预计它会产生的行为。</p>
<p>清单 1. 命令式代码示例</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="keyword">String</span>&gt; names = Arrays.asList(<span class="string">"Jack"</span>, <span class="string">"Jill"</span>, <span class="string">"Nate"</span>, <span class="string">"Kara"</span>, <span class="string">"Kim"</span>, <span class="string">"Jullie"</span>, <span class="string">"Paul"</span>, <span class="string">"Peter"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;<span class="keyword">String</span>&gt; subList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">String</span> name : names) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(name.length() == <span class="number">4</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        subList.<span class="built_in">add</span>(name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">StringBuilder namesOfLength4 = <span class="keyword">new</span> StringBuilder();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; subList.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    namesOfLength4.<span class="built_in">append</span>(subList.<span class="built_in">get</span>(i));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    namesOfLength4.<span class="built_in">append</span>(<span class="string">", "</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(subList.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    namesOfLength4.<span class="built_in">append</span>(subList.<span class="built_in">get</span>(subList.<span class="built_in">size</span>() - <span class="number">1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.<span class="built_in">println</span>(namesOfLength4);</span></pre></td></tr></table></figure>

<p>您理解此代码需要多少时间？如果时间比您预计的要长，不要惊讶。与其说这个时间反映了您的能力，不如说它反映了该代码的糟糕品质。<br>现在考虑一个使用 Java 8 支持的函数样式编写的等效示例：</p>
<p>清单 2. 函数式代码示例</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">as</span><span class="constructor">List(<span class="string">"Jack"</span>, <span class="string">"Jill"</span>, <span class="string">"Nate"</span>, <span class="string">"Kara"</span>, <span class="string">"Kim"</span>, <span class="string">"Jullie"</span>, <span class="string">"Paul"</span>, <span class="string">"Peter"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  names.stream<span class="literal">()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(name -&gt; name.length<span class="literal">()</span><span class="operator"> == </span><span class="number">4</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .collect(<span class="module-access"><span class="module"><span class="identifier">Collectors</span>.</span></span>joining(<span class="string">", "</span>)));</span></pre></td></tr></table></figure>

<p>您理解此代码会花用多少时间？显然，您已经确定了清单 1 的用途，所以这不是一次真正的实验。如果想真正比较这些示例，可以要求一些同事来理解一个或另一个代码示例，然后比较他们的回复时间。</p>
<h3 id="函数式编码为什么至关重要"><a href="#函数式编码为什么至关重要" class="headerlink" title="函数式编码为什么至关重要"></a>函数式编码为什么至关重要</h3><p>如果您熟悉 Java 8，可能会顺利理解清单 2 中的代码。即使不熟悉 Java 8，得益于描述性的方法名称，您可能也能理解它。您还能快速理解此代码，因为它比清单 1 简洁得多。<br>基本上讲，该代码的含义是：<em>给定一个名称集合，仅选择长度为 4 的名称，然后通过逗号将它们连接起来。</em><br>这个示例是人为的，但它确实证明了简洁性和表达能力在编码中的价值。我们在函数式代码中看到的这些品质比命令式代码中要多得多。</p>
<h2 id="编写可读的代码"><a href="#编写可读的代码" class="headerlink" title="编写可读的代码"></a>编写可读的代码</h2><p>函数式代码富于表达且简洁，这使程序不但更短，而且更容易阅读。考虑另一个示例：</p>
<p>清单 3. 命令式代码示例</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> result = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> e : numbers) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(e &gt; <span class="number">3</span> &amp;&amp; e % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; e &lt; <span class="number">8</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        result += e * <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.<span class="keyword">out</span>.println(result);</span></pre></td></tr></table></figure>

<p>给定名为 <code>numbers</code> 的列表，此代码将计算大于 3 且小于 8 的偶数并将该数字乘以 2，然后输出结果。该代码包含 7 行，我们可能可以减少一两行。<br>现在考虑 Java 8 中使用函数样式编写的相同代码：</p>
<p>清单 4. 一段替代性的函数式代码</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">System.out.println(</span></pre></td></tr><tr><td class="code"><pre><span class="line">   numbers.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">       .<span class="function"><span class="title">filter</span>(e -&gt;</span> e  &gt; <span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       .<span class="function"><span class="title">filter</span>(e -&gt;</span> e % <span class="number">2</span> == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       .<span class="function"><span class="title">filter</span>(e -&gt;</span> e &lt; <span class="number">8</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       .<span class="function"><span class="title">mapToInt</span>(e -&gt;</span> e * <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       .sum());</span></pre></td></tr></table></figure>

<p>清单 4 也为 7 行，但在这种情况下，进一步减少代码没有帮助。<br>函数式代码并不总是比命令式代码短。更重要的是它富于表达。简洁但难读的代码毫无帮助。</p>
<h2 id="不要犯这个错误"><a href="#不要犯这个错误" class="headerlink" title="不要犯这个错误"></a>不要犯这个错误</h2><p>函数式代码的设计目标是比命令式代码更简洁，但这不能保证它更可读。考虑下面这个示例：</p>
<p>清单 5. 联接选定名称的函数式代码</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(names.stream().<span class="keyword">filter</span>(<span class="type">name</span> -&gt; <span class="type">name</span>.startsWith("J")).<span class="keyword">filter</span>(<span class="type">name</span> -&gt; <span class="type">name</span>.length() &gt; <span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .map(<span class="type">name</span> -&gt; <span class="type">name</span>.toUpperCase()).collect(Collectors.joining(", ")));</span></pre></td></tr></table></figure>

<p>在清单 5 中，<code>filter</code>、<code>map</code> 和其他函数式元素增加了代码的表达能力。但您可能注意到，此代码让人感觉更加生硬，而不是更简洁。<br>尽管它只有两行，但此代码仍需要花大量精力来阅读和理解。您的眼睛需要努力寻找函数调用在何处结束，下一个调用从何处开始。该代码非常简短，但它编写得非常生硬。编写这种毫无帮助的代码只有一个理由：开发人员肯定憎恨与他共事的每个人。</p>
<h3 id="让您的代码简洁而不是生硬"><a href="#让您的代码简洁而不是生硬" class="headerlink" title="让您的代码简洁而不是生硬"></a>让您的代码简洁而不是生硬</h3><p>生硬的代码可能非常简短，但仍然很难读懂。简洁的代码也简短，但读起来让人感觉愉悦且容易理解。<br>在编程过程中，我们很容易忽略表达能力和可读性的价值。Java 8 通过约定来鼓励这些品质，建议我们对齐函数组合的垂直方向上的各点。<br>不幸的是，我观察到不熟悉 Java 8 的程序员常常忽略此约定，甚至在多次提醒后才想起它。经验更丰富的程序员应在代码评审期间执行此约定。优秀的 Java 8 IDE 也可以提供帮助，提供使用这类约定的快捷方式。<br>清单 6 展示了我们使用对齐约定重写清单 5 的代码的结果：</p>
<p>清单 6. Java 8 中的函数组合</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">System.out.println(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    names.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .<span class="function"><span class="title">filter</span>(<span class="keyword">name</span> -&gt;</span> <span class="keyword">name</span>.startsWith(<span class="string">"J"</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .<span class="function"><span class="title">filter</span>(<span class="keyword">name</span> -&gt;</span> <span class="keyword">name</span>.length() &gt; <span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .<span class="function"><span class="title">map</span>(<span class="keyword">name</span> -&gt;</span> <span class="keyword">name</span>.toUpperCase())</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .collect(Collectors.joining(<span class="string">", "</span>)));</span></pre></td></tr></table></figure>

<p>在这里，我们看到了来自清单 5 的同一段生硬的代码，但各个点已在垂直方向上对齐，而且我们抵抗住了将多个条件组合到一个参数中的诱惑。结果，每行都具有凝聚力：范围狭小而专注，仅含一个明确的任务。</p>
<h2 id="一种有帮助的约定"><a href="#一种有帮助的约定" class="headerlink" title="一种有帮助的约定"></a>一种有帮助的约定</h2><p>尽管可能看似可有可无，但遵循 Java 8 的对齐约定肯定非常有益。</p>
<ul>
<li>遵循此约定的代码更容易阅读、理解和解释。我们可以在详细检查每部分之前，快速掌握整个目标。</li>
<li>元素非常明确且容易找到，有助于更快地修改。如果我们想包含另一个条件，或者删除或修改一个现有条件，那么可以相对容易找到该行并执行更改。</li>
<li>该代码更容易维护，这表明我们关心团队的其他开发人员。除了让代码更容易维护之外，编写有帮助的代码还能显著提高团队士气。</li>
</ul>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>保持每行代码都简短紧凑是一种不错的做法，但是走极端可能导致代码变得生硬难读。要提高表达能力，可以问自己代码是否容易理解。要提高可读性，可采用 Java 8 垂直对齐各点的约定。使用这些简单技巧，就能创建出简洁、富于表达且可读的函数式代码。</p>
<blockquote>
<p>作者：Venkat Subramaniam</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms4/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms4/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8 习惯用语（3）：传统 for 循环的函数式替代方案</title>
    <url>/2019/12/26/Java-8-%E4%B9%A0%E6%83%AF%E7%94%A8%E8%AF%AD%EF%BC%883%EF%BC%89%EF%BC%9A%E4%BC%A0%E7%BB%9F-for-%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>尽管 <code>for</code> 循环包含许多可变部分，但许多开发人员仍非常熟悉它，并会不假思索地使用它。从 Java™ 8 开始，我们有多个强大的新方法可帮助简化复杂迭代。在本文中，您将了解如何使用 <code>IntStream</code> 方法 <code>range</code>、<code>iterate</code> 和 <code>limit</code> 来迭代范围和跳过范围中的值。您还将了解新的 <code>takeWhile</code> 和 <code>dropWhile</code> 方法（即将在 Java 9 中引入）。</p>
<p><strong>关于本系列</strong><br>Java 8 是自 Java 语言诞生以来进行的一次最重大更新 — 包含了非常丰富的新功能，您可能想知道从何处开始着手了解它。在本系列中，作家兼教师 Venkat Subramaniam 提供了一种惯用的 Java 8 编程方法：这些简短的探索会激发您反思您认为理所当然的 Java 约定，同时逐步将新技术和语法集成到您的程序中。</p>
<a id="more"></a>

<h2 id="for-循环的麻烦"><a href="#for-循环的麻烦" class="headerlink" title="for 循环的麻烦"></a>for 循环的麻烦</h2><p>在 Java 语言的第 1 个版本中就开始引入了传统的 <code>for</code> 循环，它的更简单的变体 <code>for-each</code> 是在 Java 5 中引入的。大部分开发人员更喜欢使用 <code>for-each</code> 执行日常迭代，但对于迭代一个范围或跳过范围中的值等操作，他们仍会使用 <code>for</code>。<br><code>for</code> 循环非常强大，但它包含太多可变部分。甚至在打印 <code>get set</code> 提示的最简单任务中，也可以看出这一点：</p>
<p>清单 1. 完成一个简单任务的复杂代码</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.print("Get set...");</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.print(i + "...");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在清单 1 中，我们从 1 开始循环处理索引变量 <code>i</code>，将它限制到小于 4 的值。请注意，<code>for</code> 循环需要我们告诉循环是递增的。在本例中，我们还选择了前递增而不是后递增。<br>清单 1 中没有太多代码，但比较繁琐。Java 8 提供了一种更简单、更优雅的替代方法：<code>IntStream</code> 的 <code>range</code> 方法。以下是打印清单 1 中的相同 <code>get set</code> 提示的 <code>range</code>方法：</p>
<p>清单 2. 完成一个简单任务的简单代码</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(<span class="string">"Get set..."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">IntStream</span>.</span></span>range(<span class="number">1</span>, <span class="number">4</span>).for<span class="constructor">Each(<span class="params">i</span> -&gt; System.<span class="params">out</span>.<span class="params">print</span>(<span class="params">i</span> + <span class="string">"..."</span>)</span>);</span></pre></td></tr></table></figure>

<p>在清单 2 中，我们看到并没有显著减少代码量，但降低了它的复杂性。这样做有两个重要原因：</p>
<ol>
<li>不同于 <code>for</code>，<code>range</code> 不会强迫我们初始化某个可变变量。</li>
<li>迭代会自动执行，所以我们不需要像循环索引一样定义增量。</li>
</ol>
<p>在语义上，最初的 <code>for</code> 循环中的变量 <code>i</code> 是一个<em>可变变量</em>。理解 <code>range</code> 和类似方法的价值对理解该设计的结果很有帮助。</p>
<h2 id="可变变量与参数"><a href="#可变变量与参数" class="headerlink" title="可变变量与参数"></a>可变变量与参数</h2><p><code>for</code> 循环中定义的变量 <code>i</code> 是单个变量，它会在每次对循环执行迭代时发生改变。<code>range</code> 示例中的变量 <code>i</code> 是拉姆达表达式的参数，所以它在每次迭代中都是一个全新的变量。这是一个细微区别，但决定了两种方法的不同。以下示例有助于阐明这一点。<br>清单 3 中的 <code>for</code> 循环想在一个内部类中使用索引变量：</p>
<p>清单 3. 在内部类中使用索引变量</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="type">int</span> <span class="keyword">temp</span> = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    executorService.submit(<span class="built_in">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">public</span> <span class="type">void</span> run() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            //<span class="keyword">If</span> uncommented the next <span class="type">line</span> will result <span class="keyword">in</span> an error</span></pre></td></tr><tr><td class="code"><pre><span class="line">            //<span class="keyword">System</span>.<span class="keyword">out</span>.println("Running task " + i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            //<span class="keyword">local</span> variables referenced <span class="keyword">from</span> an <span class="keyword">inner</span> <span class="keyword">class</span> must be final <span class="keyword">or</span> effectively final</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.println("Running task " + <span class="keyword">temp</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">executorService.shutdown();</span></pre></td></tr></table></figure>

<p>我们有一个匿名的内部类实现了 <code>Runnable</code> 接口。我们想在 <code>run</code> 方法中访问索引变量 <code>i</code>，但编译器不允许这么做。<br>作为此限制的解决办法，我们可以创建一个局部临时变量，比如 <code>temp</code>，它是索引变量的一个副本。每次新的迭代都会创建变量 <code>temp</code>。在 Java 8 以前，我们需要将该变量标记为 <code>final</code>。从 Java 8 开始，可以将它视为实际的最终结果，因为我们不会再更改它。无论如何，由于事实上索引变量是一个在迭代中改变的变量，<code>for</code> 循环中就会出现这个额外变量。<br>现在尝试使用 <code>range</code> 函数解决同一个问题。</p>
<p>清单 4. 在内部类中使用拉姆达参数</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">5</span>).<span class="keyword">forEach</span>(i -&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    executorService.submit(<span class="built_in">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">public</span> <span class="type">void</span> run() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.println("Running task " + i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;));</span></pre></td></tr><tr><td class="code"><pre><span class="line">executorService.shutdown();</span></pre></td></tr></table></figure>

<p>在作为一个参数被拉姆达表达式接受后，索引变量 <code>i</code> 的语义与循环索引变量有所不同。与清单 3 中手动创建的 <code>temp</code> 非常相似，这个 <code>i</code> 参数在每次迭代中都表现为一个全新的变量。它是<em>实际最终变量</em>，因为我们不会在任何地方更改它的值。因此，我们可以直接在内部类的上下文中使用它 — 且不会有任何麻烦。<br>因为 <code>Runnable</code> 是一个函数接口，所以我们可以轻松地将匿名的内部类替换为拉姆达表达式，比如：</p>
<p>清单 5. 将内部类替换为拉姆达表达式</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">5</span>).forEach(i<span class="function"> -&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    executorService.submit<span class="function"><span class="params">(() -&gt; System.out.println(<span class="string">"Running task "</span> + i))</span>);</span></span></pre></td></tr></table></figure>

<p>显然，对于相对简单的迭代，使用 <code>range</code> 代替 <code>for</code> 具有一定优势，但 <code>for</code> 的特殊价值体现在于它能处理更复杂的迭代场景。让我们看看 <code>range</code> 和其他 Java 8 方法孰优孰劣。</p>
<h2 id="封闭范围"><a href="#封闭范围" class="headerlink" title="封闭范围"></a>封闭范围</h2><p>创建 <code>for</code> 循环时，可以将索引变量封闭在一个范围内，比如：</p>
<p>清单 6. 一个具有封闭范围的 for 循环</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span></pre></td></tr></table></figure>

<p>索引变量 <code>i</code> 接受值 <code>0</code>、<code>1</code>、……<code>5</code>。无需使用 <code>for</code>，我们可以使用 <code>rangeClosed</code> 方法。在本例中，我们告诉 <code>IntStream</code> 将最后一个值限制在该范围内：</p>
<p>清单 7. rangeClosed 方法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">IntStream</span>.</span></span>range<span class="constructor">Closed(0, 5)</span></span></pre></td></tr></table></figure>

<p>迭代此范围时，我们会获得包含边界值 5 在内的值。</p>
<h2 id="跳过值"><a href="#跳过值" class="headerlink" title="跳过值"></a>跳过值</h2><p>对于基本循环，<code>range</code> 和 <code>rangeClosed</code> 方法是 <code>for</code> 的更简单、更优雅的替代方法，但是如果想跳过一些值该怎么办？在这种情况下，<code>for</code> 对前期工作的需求使该运算变得非常容易。在清单 8 中，<code>for</code> 循环在迭代期间快速跳过两个值：</p>
<p>清单 8. 使用 for 跳过值</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> total = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i = i + <span class="number">3</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    total += i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>清单 8 中的循环在 1 到 100 内对每次读到的第三个值作求和计算 — 这种复杂运算可使用 <code>for</code> 轻松完成。能否也使用 <code>range</code> 解决此问题？<br>首先，可以考虑使用 <code>IntStream</code> 的 <code>range</code> 方法，再结合使用 <code>filter</code> 或 <code>map</code>。但是，所涉及的工作比使用 <code>for</code> 循环要多。一种更可行的解决方案是结合使用 <code>iterate</code> 和 <code>limit</code>：</p>
<p>清单 9. 使用 limit 的迭代</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">IntStream.iterate(<span class="number">1</span>, e -&gt; e + <span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .limit(<span class="number">34</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .sum()</span></pre></td></tr></table></figure>

<p><code>iterate</code> 方法很容易使用；它只需获取一个初始值即可开始迭代。作为第二参数传入的拉姆达表达式决定了迭代中的下一个值。这类似于清单 8，我们将一个表达式传递给 <code>for</code> 循环来递增索引变量的值。但是，在本例中有一个<em>陷阱</em>。不同于 <code>range</code> 和 <code>rangeClosed</code>，没有参数来告诉 <code>iterate</code> 方法何时停止迭代。如果我们没有限制该值，迭代会一直进行下去。<br>如何解决这个问题？<br>我们对 1 到 100 之间的值感兴趣，而且想从 1 开始跳过两个值。稍加运算，即可确定给定范围中有 34 个符合要求的值。所以我们将该数字传递给 <code>limit</code> 方法。<br>此代码很有效，但过程太复杂：提前执行数学运算不那么有趣，而且它限制了我们的代码。如果我们决定跳过 3 个值而不是 2 个值，该怎么办？我们不仅需要更改代码，结果也很容易出错。我们需要有一个更好的方法。</p>
<h2 id="takeWhile-方法"><a href="#takeWhile-方法" class="headerlink" title="takeWhile 方法"></a>takeWhile 方法</h2><p>Java 9 中即将引入的 <code>takeWhile</code> 是一个新方法，它使得执行有限制的迭代变得更容易。使用 <code>takeWhile</code>，可以直接表明<em>只要满足想要的条件</em>，迭代就应该继续执行。以下是使用 <code>takeWhile</code> 实现清单 9 中的迭代的代码。</p>
<p>清单 10. 有条件的迭代</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">IntStream</span>.</span></span>iterate(<span class="number">1</span>, e -&gt; e + <span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">     .take<span class="constructor">While(<span class="params">i</span> -&gt; <span class="params">i</span> &lt;= 100)</span> <span class="comment">//available in Java 9</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     .sum<span class="literal">()</span></span></pre></td></tr></table></figure>

<p>无需将迭代限制到预先计算的次数，我们使用提供给 <code>takeWhile</code> 的条件，动态确定何时终止迭代。与尝试预先计算迭代次数相比，这种方法简单得多，而且更不容易出错。<br>与 <code>takeWhile</code> 方法相反的是 <code>dropWhile</code>，它跳过满足给定条件前的值，这两个方法都是 JDK 中非常需要的补充方法。<code>takeWhile</code> 方法类似于 break，而 <code>dropWhile</code> 则类似于 continue。从 Java 9 开始，它们将可用于任何类型的 <code>Stream</code>。</p>
<h2 id="逆向迭代"><a href="#逆向迭代" class="headerlink" title="逆向迭代"></a>逆向迭代</h2><p>与正向迭代相比，逆向迭代同样非常简单，无论使用传统的 <code>for</code> 循环还是 <code>IntStream</code>。<br>以下是一个逆向的 <code>for</code> 循环迭代：</p>
<p>清单 11. 使用 for 的逆向迭代</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">7</span>; i &gt; <span class="number">0</span>; i--) &#123;</span></pre></td></tr></table></figure>

<p><code>range</code> 或 <code>rangeClosed</code> 中的第一个参数不能大于第二个参数，所以我们无法使用这两种方法来执行逆向迭代。但可以使用 <code>iterate</code> 方法：</p>
<p>清单 12. 使用 iterate 的逆向迭代</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">IntStream.iterate(<span class="number">7</span>, e -&gt; e - <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">     .limit(<span class="number">7</span>)</span></pre></td></tr></table></figure>

<p>将一个拉姆达表达式作为参数传递给 <code>iterate</code> 方法，该方法对给定值进行递减，以便沿相反方向执行迭代。我们使用 <code>limit</code> 函数指定我们希望在逆向迭代期间看到总共多少个值。如有必要，还可以使用 <code>takeWhile</code> 和 <code>dropWhile</code> 方法来动态调整迭代流。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>尽管传统 <code>for</code> 循环非常强大，但它有些过于复杂。Java 8 和 Java 9 中的新方法可帮助简化迭代，甚至是简化复杂的迭代。方法 <code>range</code>、<code>iterate</code> 和 <code>limit</code> 的可变部分较少，这有助于提高代码效率。这些方法还满足了 Java 的一个长期以来的要求，那就是局部变量必须声明为 final，然后才能从内部类访问它。将一个可变索引变量更换为实际的 final 参数只有很小的语义差别，但它减少了大量垃圾变量。最终您会得到更简单、更优雅的代码。</p>
<blockquote>
<p>作者：Venkat Subramaniam</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms3/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms3/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8 习惯用语（2）：函数组合与集合管道模式</title>
    <url>/2019/12/26/Java-8-%E4%B9%A0%E6%83%AF%E7%94%A8%E8%AF%AD%EF%BC%882%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88%E4%B8%8E%E9%9B%86%E5%90%88%E7%AE%A1%E9%81%93%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在开始采用函数式编程风格时，您的程序中会自然而然地出现一些函数设计模式，但您仍需要努力掌握它们。本文将介绍函数组合和集合管道，您可以结合使用这两种函数式模式来迭代代码中的集合。了解这些模式的结构有助于您搭建自己的 Java™ 程序，从而充分利用高阶函数和拉姆达表达式。</p>
<p><strong>关于本系列</strong>Java 8 是自 Java 语言诞生以来进行的一次最重大更新 — 包含了非常丰富的新功能，您可能想知道从何处开始着手了解它。在本系列中，作家兼教师 Venkat Subramaniam 提供了一种惯用的 Java 8 编程方法：这些简短的探索会激发您反思您认为理所当然的 Java 约定，同时逐步将新技术和语法集成到您的程序中。</p>
<a id="more"></a>

<h2 id="语句与表达式"><a href="#语句与表达式" class="headerlink" title="语句与表达式"></a>语句与表达式</h2><p>如果在代码库中快速查找 <code>for</code>，您可能会惊奇地发现，您的代码中对 <code>for</code> 循环的使用非常频繁。我将这种情形称为 <em><code>for</code>重复(hammer)</em>：只要我们需要循环，似乎就会用到 <code>for</code>。<br>在 Java 中，<code>for</code> 和 <code>while</code> 都是语句。<em>语句</em>执行一个操作，但不会生成任何结果。就本质而言，任何执行有用的操作的语句都会导致数据变化。这是语句表达其效果的唯一方式。而<em>表达式</em>则相反：它们可以得出结果而不会导致变化。<br>在代码中使用语句就像是合作处理一部分工作，但无法在团队成员之间直接转交工作结果。分享结果的唯一方法是将它放在桌面上或架子上，让另一位团队成员可以获得它。表达式的工作更像一条链：当某个人完成一项任务时，他将结果转交给链中的下一个人。<br>表达式帮助实现了集合管道模式，Martin Fowler 将该模式描述为<a href="https://martinfowler.com/articles/collection-pipeline" target="_blank" rel="noopener">运算序列</a>，会将从一次运算收集的输出提供给下一次运算。尽管面向对象的编程中使用了集合管道模式（您可能在使用对象构建器的代码中看到过它），但它在函数编程中更常见。<br>函数组合和集合管道模式是两种可协同工作的模式。下一节将使用熟悉的 <code>for</code> 语句解决一个问题。然后将介绍如何使用这两种模式更高效地解决同一个问题。</p>
<h2 id="使用语句进行迭代和排序"><a href="#使用语句进行迭代和排序" class="headerlink" title="使用语句进行迭代和排序"></a>使用语句进行迭代和排序</h2><p>首先创建一个 <code>Car</code> 类，它包含属性 make、model 和 year：</p>
<p>清单 1. 一个 Car 类</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package agiledeveloper;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> make;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> model;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> year;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="keyword">String</span> theMake, <span class="keyword">String</span> theModel, <span class="keyword">int</span> yearOfMake)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        make = theMake;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        model = theModel;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        year = yearOfMake;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getMake</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> make;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> model;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getYear</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> year;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们可以添加一个 <code>Car</code> 实例集合，比如：</p>
<p>清单 2. 一个 Car 实例集合</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> agiledeveloper;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Comparator.comparing;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.toList;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iterating</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Car&gt; createCars() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Arrays.asList(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">new</span> <span class="type">Car</span>(<span class="string">"Jeep"</span>, <span class="string">"Wrangler"</span>, <span class="number">2011</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">new</span> <span class="type">Car</span>(<span class="string">"Jeep"</span>, <span class="string">"Comanche"</span>, <span class="number">1990</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">new</span> <span class="type">Car</span>(<span class="string">"Dodge"</span>, <span class="string">"Avenger"</span>, <span class="number">2010</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">new</span> <span class="type">Car</span>(<span class="string">"Buick"</span>, <span class="string">"Cascada"</span>, <span class="number">2016</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">new</span> <span class="type">Car</span>(<span class="string">"Ford"</span>, <span class="string">"Focus"</span>, <span class="number">2012</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">new</span> <span class="type">Car</span>(<span class="string">"Chevrolet"</span>, <span class="string">"Geo Metro"</span>, <span class="number">1992</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在清单 3 中，我们使用命令式编程来迭代该列表，并获取 2000 年后制造的汽车的名称。然后按年份对这些型号进行升序排序。</p>
<p>清单 3. 使用 ‘for’ 按年份对各种型号进行排序</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static List&lt;String&gt; get<span class="constructor">ModelsAfter2000UsingFor(List&lt;Car&gt; <span class="params">cars</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;Car&gt; carsSortedByYear = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for(Car car : cars) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(car.get<span class="constructor">Year()</span> &gt; <span class="number">2000</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            carsSortedByYear.add(car);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Collections</span>.</span></span>sort(carsSortedByYear, <span class="keyword">new</span> Comparator&lt;Car&gt;<span class="literal">()</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        public <span class="built_in">int</span> compare(Car car1, Car car2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return <span class="keyword">new</span> <span class="constructor">Integer(<span class="params">car1</span>.<span class="params">getYear</span>()</span>).compare<span class="constructor">To(<span class="params">car2</span>.<span class="params">getYear</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;String&gt; models = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for(Car car : carsSortedByYear) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        models.add(car.get<span class="constructor">Model()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return models;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr></table></figure>

<p>如您所见，此代码中有许多循环。首先，<code>getModelsAfter2000UsingFor</code> 方法接受一个汽车列表作为参数。它提取或过滤出 2000 年后制造的汽车，将它们放在一个名为 <code>carsSortedByYear</code> 的新列表中。接下来，按照制造年份对该列表进行升序排序。最后，循环处理列表 <code>carsSortedByYear</code>，以获取型号名称，并在一个列表中返回它们。<br>能否提高这段代码的效率？我们可以通过一次性对所有汽车排序来消除一个 <code>for</code> 循环，但随后需要对一个更大的对象列表进行排序。<br>这是汽车列表示例的输出：</p>
<p>清单 4. getModelsAfter2000UsingFor 的输出</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Avenger,</span> Wrangler, Focus, Cascada</span></pre></td></tr></table></figure>

<p>这个排序示例演示了我所称的<em>语句的效果</em>。尽管函数和方法通常可用作表达式，但 <code>Collections``sort</code> 方法没有返回结果。因为它被用作语句，所以它改变了作为参数提供的列表。两个 <code>for</code> 循环在迭代时都改变了相应的列表。作为语句，这是这些元素的工作方式。因此，该代码包含不必要的垃圾变量，如图 1 所示。</p>
<p>图 1. 语句的效果</p>
<p><img src="http://image.winrains.cn/2019/08/a255b-fig1.png" alt="img"></p>
<h2 id="使用集合管道进行迭代和排序"><a href="#使用集合管道进行迭代和排序" class="headerlink" title="使用集合管道进行迭代和排序"></a>使用集合管道进行迭代和排序</h2><p>在函数编程中，通常会通过一系列更小的模块化函数或运算来对复杂运算进行排序。该系列被称为<em>函数组合</em>（composition of functions, or a function composition）。当一个数据集合流经一个函数组合时，它就变成一个集合管道。函数组合和集合管道是函数式编程中常用的两种设计模式。<br>无需使用一个很大的 <code>for</code> 重复（ hammer ），依据手头的问题，我们能使用多种专业工具。无需像命令式编程中常见的那样对所有运算都使用语句，函数式编程鼓励使用表达式。表达式没有语句所拥有的改变对象的副作用。像 <code>filter</code> 或 <code>map</code> 这样的表达式也返回一个结果，我们可以将它传递给另一个函数，我们就是通过这种方式创建集合管道的。考虑清单 5 中的代码。</p>
<p>清单 5. 集合管道模式中的函数组合</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> static <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; getModelsAfter2000UsingPipeline(</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="built_in">List</span>&lt;Car&gt; cars) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     cars.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">         .filter(car -&gt; car.getYear() &gt; <span class="number">2000</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">         .sorted(Comparator.comparing(Car<span class="type">::getYear</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">         .<span class="built_in">map</span>(Car<span class="type">::getModel</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">         .collect(toList());</span></pre></td></tr><tr><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr></table></figure>

<p>方法 <code>getModelsAfter2000UsingPipeline</code> 生成的结果与 清单 3 中的方法 <code>getModelsAfter2000UsingFor</code> 相同，但要注意代码中的不同之处：</p>
<ul>
<li>函数式代码比命令式代码更简洁。</li>
<li>函数式代码不会表现出明显的易变性，而且使用了更少的垃圾变量。</li>
<li>第二个方法中使用的函数/方法都是有返回值的表达式。将此方法与 清单 3 中的 <code>Collections.sort</code> 方法进行对比。</li>
<li><code>getModelsAfter2000UsingPipeline</code> 使用了集合管道模式，而且非常富于表达。</li>
</ul>
<p>只用了短短几行代码，代码的意图就很明显 — 给定一个汽车集合，过滤或提取仅在 2000 年或以后制造的汽车；然后按年份进行排序，将这些对象映射或转换为它们的型号，最后将结果收集到一个列表中。<br>清单 5 中的代码如此简洁且富于表达，部分原因是使用了方法引用。将一个拉姆达表达式传递给 <code>filter</code> 很有用，因为它可以获取给定对象的 year 属性并将其与 year 2000 进行比较。但是，将拉姆达表达式传递给 <code>map</code> 就没有这么有效。传递给 <code>map</code> 方法的表达式为 <code>car -&gt; car.getModel()</code>，该表达式非常繁琐。该拉姆达表达式仅返回给定对象的某个属性，不执行任何实际计算或运算。我们最好将它替换为一个方法引用。<br>我们将方法引用 <code>Car::getModel</code> 传递给 <code>map</code> 方法，而不传递拉姆达表达式。类似地，我们将方法引用 <code>Car::getYear</code> 传递给 comparing 方法，而不传递拉姆达表达式 <code>car -&gt; car.getYear()</code>。方法引用简短、简洁且富于表达。最好尽可能地使用它们。<br>图 2 给出了清单 5 中的集合管道。</p>
<p>图 2. 集合管道的魅力</p>
<p><img src="http://image.winrains.cn/2019/08/55ced-fig2.png" alt="img"><br>查看图 2，可以看到 <code>getModelsAfter2000UsingPipeline</code> 函数如何执行集合管道，通过一系列函数转换给定输入。随着数据流经各个函数，Java 8 的惰性计算和函数融合功能（参阅 2014 年的 <a href="https://pragprog.com/book/vsjava8/functional-programming-in-java" target="_blank" rel="noopener"><em>Java 中的函数编程</em></a>）可帮助避免在某些情况下创建中间对象。数据在管道中传输时，函数不会使中间对象变得可见或可用。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>在命令式编程中，对于大部分数据处理，通常都会使用 <code>for</code> 和 <code>while</code> 循环。在本文中，您了解了一种在函数式编程中非常流行的替代方法。函数组合是一项简单技术，有助于对模块化函数进行排序，从而创建更复杂的运算。按该序列处理数据时，您就有了一个集合管道。结合使用函数组合和集合管道模式，可以创建复杂的程序，让数据从上游流到下游，并经历一系列转换。</p>
<blockquote>
<p>作者：Venkat Subramaniam</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms2/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms2/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8 习惯用语（1）：函数式编程</title>
    <url>/2019/12/26/Java-8-%E4%B9%A0%E6%83%AF%E7%94%A8%E8%AF%AD%EF%BC%881%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>Java 开发人员早已习惯了命令式编程和面向对象的编程，因为 Java 语言从第一个版本开始就支持这些格式。在 Java 8 中，我们获得了一组强大的新的函数特性和语法。函数式编程已有数十年的历史，而且与面向对象的编程相比，函数式编程通常更简洁、更具表达力、更不容易出错，而且更容易并行化。所以在 Java 程序中引入函数特性是有充分理由的。尽管如此，函数式的编程需要对代码的设计方式进行一些改变。</p>
<p><strong>关于本系列</strong>Java 8 是自 Java 语言诞生以来进行的一次最重大更新 — 包含了非常丰富的新功能，您可能想知道从何处开始着手了解它。在本系列中，作者兼教师 Venkat Subramaniam 提供了一种惯用的 Java 8 编程方法：这些简短的探索会激发您反思您认为理所当然的 Java 约定，同时逐步将新方法和语法集成到您的程序中。</p>
<a id="more"></a>

<p>我发现声明式思考（而不是命令式思考）可以简化向更加函数化编程的过渡。在新的 <a href="https://www.ibm.com/developerworks/cn/views/global/libraryview.jsp?sort_by=&show_abstract=true&show_all=&search_flag=&contentarea_by=Jamp;ava+technology&search_by=Java+8++习惯用语&topic_by=-1&type_by=所有类别&ibm-search=搜索" target="_blank" rel="noopener"><em>Java 8 习惯用语</em> 系列</a> 的第一篇文章中，我将解释命令式、声明式和函数式编程之间的区别和共性。然后，将展示如何使用声明式思考方式逐步将函数方法集成到 Java 程序中。</p>
<h2 id="命令式格式"><a href="#命令式格式" class="headerlink" title="命令式格式"></a>命令式格式</h2><p>经过针对命令式编程培训的开发人员已经习惯了告诉程序做什么和该如何做。这是一个简单示例：</p>
<p>清单 1. findNemo in the imperative style</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindNemo</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;<span class="keyword">String</span>&gt; names = Arrays.asList(<span class="string">"Dory"</span>, <span class="string">"Gill"</span>, <span class="string">"Bruce"</span>, <span class="string">"Nemo"</span>, <span class="string">"Darla"</span>, <span class="string">"Marlin"</span>, <span class="string">"Jacques"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        findNemo(names);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findNemo</span><span class="params">(List&lt;<span class="keyword">String</span>&gt; names)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">boolean</span> found = <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">String</span> name : names) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (name.equals(<span class="string">"Nemo"</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                found = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (found)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"Found Nemo"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"Sorry, Nemo not found"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>findNemo()</code> 方法首先初始化一个可变的<em>flag</em> 变量，也称为<em>垃圾（garbage）变量</em>。开发人员通常会随便给这些变量命名，比如 <code>f</code>、<code>t</code> 或 <code>temp</code>，这些名称表明了我们对这些变量不应存在的一般态度。在本例中，该变量名为 <code>found</code>。<br>接下来，该程序会在给定的 <code>names</code> 列表中循环，一次处理一个元素。它检查获得的名称是否与它寻找的值（在本例中为 <code>Nemo</code>）相等。如果值匹配，那么它会将 flag 变量设置为 <code>true</code>，并通知控制流“跳出”循环。<br>因为这是一个命令式编程的程序 — 许多 Java 开发人员最熟悉的格式 — 所以您需要定义程序的每一步：告诉它迭代每个元素，比较值，设置 flag 变量，然后跳出循环。命令式格式为您提供了完全的控制权，这有时是件好事。而另一方面，您需要执行所有工作。在许多情况下，可以减少工作量来提高效率。</p>
<h2 id="声明式格式"><a href="#声明式格式" class="headerlink" title="声明式格式"></a>声明式格式</h2><p>声明式编程意味着，您仍会告诉程序要做什么，但将实现细节留给底层的函数库。让我们看看用声明式格式重新编写来自 [清单 1](<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单</a> 1) 的 <code>findNemo</code> 方法时，会发生什么：</p>
<p>清单 2. findNemo in the declarative style</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findNemo</span><span class="params">(List&lt;<span class="keyword">String</span>&gt; names)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(names.contains(<span class="string">"Nemo"</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Found Nemo"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Sorry, Nemo not found"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>首先请注意，这个版本中没有任何垃圾变量。您也没有将精力浪费在对集合的循环处理上，而是使用内置的 <code>contains()</code> 方法来完成工作。您仍然需要告诉程序要做什么 — 检查集合是否包含我们寻找的值 — 但将细节留给底层的方法。<br>在命令式示例中，您控制着迭代，而且程序完全按照要求来操作。在声明式版本中，您无需关心工作如何完成，只要它完成即可。<code>contains()</code> 的实现可能不同，但只要结果符合预期，您可能就会很开心。花更少的精力获得同样的结果。<br>训练自己以声明式编程思考，这将大大简化向 Java 中的函数式编程的过渡。为什么呢？因为函数式编程是以声明式为基础而建立的。声明式思考试图逐步从命令式编程过渡到函数式编程。</p>
<h2 id="函数式格式"><a href="#函数式格式" class="headerlink" title="函数式格式"></a>函数式格式</h2><p>尽管函数式格式的编程始终是声明式的，但简单地使用声明式编程并不等于函数式编程。这是因为函数式编程合并了声明式方法与高阶函数。图 1 直观地展示了命令式、声明式和函数式编程之间的关系。</p>
<p>图 1. 命令式、声明式和函数式编程的联系</p>
<p><img src="http://image.winrains.cn/2019/08/78336-fig1.jpg" alt="命令式、声明式和函数式编程风格之间的区别和重叠的逻辑图。"></p>
<h3 id="Java-中的高阶函数"><a href="#Java-中的高阶函数" class="headerlink" title="Java 中的高阶函数"></a>Java 中的高阶函数</h3><p>在 Java 中，要将对象传递给方法，在方法内创建对象，并从方法中返回对象。可以对函数执行同样的操作。也就是说，可以将函数传递给方法，在方法内创建函数，并从方法返回函数。<br>在此上下文中，<em>方法</em> 是类的一部分 — 静态或实例 — 但函数对于方法而言是本地函数，不能特意与类或实例关联。可以接收、创建或返回函数的函数或方法被视为<em>高阶函数</em>。</p>
<h2 id="函数式编程示例"><a href="#函数式编程示例" class="headerlink" title="函数式编程示例"></a>函数式编程示例</h2><p>采用新编程的格式需要改变您思考程序的方式。可以通过简单的示例来实践这一过程，并逐步建立更复杂的程序。</p>
<p>清单 3. A Map in the imperative style</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseMap</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Map&lt;<span class="keyword">String</span>, Integer&gt; pageVisits = <span class="keyword">new</span> HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">String</span> page = <span class="string">"https://agiledeveloper.com"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        incrementPageVisit(pageVisits, page);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        incrementPageVisit(pageVisits, page);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(pageVisits.<span class="built_in">get</span>(page));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">incrementPageVisit</span><span class="params">(Map&lt;<span class="keyword">String</span>, Integer&gt; pageVisits, <span class="keyword">String</span> page)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!pageVisits.containsKey(page)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pageVisits.<span class="built_in">put</span>(page, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pageVisits.<span class="built_in">put</span>(page, pageVisits.<span class="built_in">get</span>(page) + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在 [清单 3](<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单</a> 3) 中，<code>main()</code> 函数创建了一个 <code>HashMap</code>，其中包含一个网站的页面访问次数。同时，每次访问给定页面，<code>incrementPageVisit()</code> 方法都会增加计数。我们将重点查看此方法。<br><code>incrementPageVisit()</code> 方法是使用命令式格式编写的：它的职责是递增给定页面的计数，将该计数存储在 <code>Map</code> 中。该方法不知道给定页面是否有计数，所以它首先会检查是否存在计数。如果不存在，那么它会插入一个 “0” 作为该页面的计数。然后获得该计数，递增它，并将新值存储在 <code>Map</code> 中。<br>声明式思考要求您将此方法的设计思路从 “如何做” 转变为 “做什么”。当调用方法 <code>incrementPageVisit()</code> 时，您希望将给定页面的计数初始化为 1 或将运行值递增 1。这就是<em>做什么<em>。<br>因为您在执行声明式编程，所以下一步是扫描 JDK 库，查找 <code>Map</code> 接口中可以完成您的目标的方法 — 也就是说，寻找一个知道</em>如何</em> 完成给定任务的内置方法。<br>事实证明，<code>merge()</code> 方法能完美实现您的目标。清单 4 使用新的声明式方法修改来自 [清单 3](<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单</a> 3) 的 <code>incrementPageVisit()</code> 方法。但是，在本例中，并不仅仅通过选择更智能的方法采用更加声明式的格式编程；因为 <code>merge()</code> 是一个高阶函数，所以新代码实际上是一个不错的函数式编程示例：</p>
<p>清单 4. A Map in the functional style</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">incrementPageVisit</span><span class="params">(Map&lt;<span class="keyword">String</span>, Integer&gt; pageVisits, <span class="keyword">String</span> page)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pageVisits.merge(page, <span class="number">1</span>, (oldValue, value) -&gt; oldValue + value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在清单 4 中，<code>page</code> 作为第一个参数传递给 <code>merge()</code>：该键的值应该更新。第二个参数是给该键分配的初始值，<em>如果</em><code>Map</code> 中不存在该键（在本例中，该值为 “1”）。第三个参数（一个拉姆达表达式）接收 map 中该键对应的值作为其参数，并且将该值作为变量传递给 merge 方法中的第二个参数。 这个拉姆达表达式返回的是它的参数的和，实际上就是递增计数。<br>比较[清单 4](<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单</a> 4) 中的 <code>incrementPageVisit()</code> 方法中的一行代码与 [清单 3](<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单</a> 3) 中的多行代码。[清单 4](<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-#清单</a> 4) 中的程序是一个函数式编程示例，由此可见声明式考虑问题有助于我们的跳跃性思维。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>在 Java 程序中采用函数式方法和语法有许多好处：代码简洁，更富于表达，不易出错，更容易并行化，而且通常比面向对象的代码更容易理解。我们面临的挑战在于将思维方式从命令式编程 — 绝大多数开发人员都熟悉它 — 转变为声明式思考。<br>尽管函数式编程不那么容易或直观，但您可以通过学习关注您想要程序实现的<em>目的</em> 而不是关注您希望它执行的<em>方式</em>，从而实现思维上的巨大飞跃。通过允许底层函数库管理执行代码，您将逐步直观地了解高阶函数，它们是函数式编程的构建基块。</p>
<blockquote>
<p>作者：Venkat Subramaniam</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms1/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8 习惯用语（0）：函数纯度</title>
    <url>/2019/12/26/Java-8-%E4%B9%A0%E6%83%AF%E7%94%A8%E8%AF%AD%EF%BC%880%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0%E7%BA%AF%E5%BA%A6/</url>
    <content><![CDATA[<p>在本系列前面的部分中，我介绍了<a href="https://www.ibm.com/developerworks/library/j-java8idioms2/index.html" target="_blank" rel="noopener">函数组合和集合管道模式</a>。在本文中，我们将再次介绍函数管道的好处和构建块。您将进一步了解如何使用 <code>java.util.stream</code> 构建函数管道，以及为什么在管道中保持函数纯度是有益的。</p>
<a id="more"></a>

<h2 id="函数管道和-Stream-API"><a href="#函数管道和-Stream-API" class="headerlink" title="函数管道和 Stream API"></a>函数管道和 Stream API</h2><p>我们使用 <code>Stream</code> 在 Java™ 中构建函数管道。在函数式代码中使用 <code>Stream</code> 有 3 个好处：</p>
<ul>
<li><code>Stream</code> 简洁、富于表达、非常优雅，而且代码读起来就像是问题陈述。</li>
<li>Stream 采用了惰性计算，这使得它在您的程序中非常高效。</li>
<li>它可以并行使用。</li>
</ul>
<p>在本系列中，您已详细了解了优雅和简洁的代码的好处。在本文中，我们将重点介绍其他两个好处。效率是您在使用函数管道时寻求的主要好处之一，所以我们首先从这里开始介绍。</p>
<h2 id="惰性计算"><a href="#惰性计算" class="headerlink" title="惰性计算"></a>惰性计算</h2><p>下面的命令式代码非常高效：它仅执行绝对必要的工作。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">23</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">Integer result = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> e : numbers) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(e &gt; <span class="number">10</span> &amp;&amp; e % <span class="number">2</span> == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        result = e * <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(result != <span class="literal">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"The value is "</span> + result);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"No value found"</span>);</span></pre></td></tr></table></figure>

<p>该代码迭代 <code>numbers</code> 集合中的元素，但仅迭代至找到满足它的两个要求（大于 10 且是偶数）的元素。找到第一个数字后，就不会再处理其他值。<br>现在让我们使用函数管道重写上述代码：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">23</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.println(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  numbers.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(e -&gt; e &gt; <span class="number">10</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(e -&gt; e % <span class="number">2</span> == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .map(e -&gt; e * <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .findFirst()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .map(e -&gt; <span class="string">"The value is "</span> + e)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .orElse(<span class="string">"No value found"</span>));</span></pre></td></tr></table></figure>

<p>这个函数式版本生成的结果与命令式版本相同。在给出的示例中，命令式版本不会处理任何超过 12 的值，函数版本也是如此。不同之处在于代码处理给定变量的方式。</p>
<h3 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h3><p>Java <code>Stream</code> 基本上是惰性的，就像我十几岁的孩子一样。下面是我家里的一个场景，可能有助于您理解流的行为。<br>我的妻子对儿子说：“关掉电视”。<br>跟没说一样。<br>妻子说：“把垃圾倒掉”。<br>没有任何动作。<br>她再说：“做你的家庭作业”。<br>铅笔没被拿起过。<br>妻子说：“我要叫你爸爸了。”<br>孩子马上行动起来，按下电视遥控器上的关闭按钮……<br>像十几岁的孩子一样，<code>Stream</code> 只有两种方法：中间和最终。根据家中每位家长扮演的角色，后一个方法等效于 <code>callDaddy()</code> 或 <code>callMommy()</code> 方法。<br><code>Stream</code> 累积并<em>组合</em>或<em>融合</em>中间操作，然后执行它们。但是像十几岁的孩子一样，它仅执行满足最终操作所必需的工作。因为中间操作被融合，所以流对管道中数据的处理方式存在一个重要区别：<code>Stream</code> 不会像命令式代码一样执行数据集合上的每个函数，而是执行每个元素上的函数的融合集合，但仅在需要时执行。<br>为了验证此行为，我们可以稍微更改一下最初的函数式代码：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">23</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.println(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  numbers.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .peek(e -&gt; System.out.println(<span class="string">"processing "</span> + e))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(e -&gt; e &gt; <span class="number">10</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .filter(e -&gt; e % <span class="number">2</span> == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .map(e -&gt; e * <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .findFirst()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .map(e -&gt; <span class="string">"The value is "</span> + e)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .orElse(<span class="string">"No value found"</span>));</span></pre></td></tr></table></figure>

<p>在这里，我们在函数管道中的第一个 <code>filter</code> 的前面添加了对 <code>peek</code> 的调用。<code>peek</code> 方法对调试很有用，使我们能在执行期间<em>留意到</em><code>Stream</code>。这是新代码的输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">processing <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">processing <span class="number">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">processing <span class="number">8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">processing <span class="number">15</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">processing <span class="number">12</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">The value <span class="keyword">is</span> <span class="number">24</span></span></pre></td></tr></table></figure>

<p>该代码处理了直到 12（包含 12）的所有值，但它没有触及超过目标值的任何值。这是因为最终操作 <code>findFirst</code> 会触发流处理的终止。此外，两个 <code>filter</code> 和 <code>map</code> 调用中的操作融合在一起，然后在序列中的每个元素上执行计算。超过 <code>findFirst</code> 中的内部终止信号后，就不会再计算元素。<br>在本例中，惰性显然提高了效率，因为函数管道只执行必要的工作。它是效率与优雅结合的典范。</p>
<h2 id="并行化"><a href="#并行化" class="headerlink" title="并行化"></a>并行化</h2><p>在您有一个大型集合或者需要执行消耗大量时间的任务的情况下，并行化可能非常有用。下面的代码将模拟一个耗时的操作。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Sample</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> static <span class="built_in">int</span> simulateTimeConsumingComputation(<span class="built_in">int</span> number) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Thread.sleep(<span class="number">1000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> number * <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        numbers.stream().map(Sample::simulateTimeConsumingComputation).forEachOrdered(System.<span class="keyword">out</span>::println);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如果正常运行此代码，您会发现所用时间约为 10 秒。这太长了。 我们可以使用一个并行流来提高速度，如下所示：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">numbers</span><span class="selector-class">.stream</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="selector-class">.parallel</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="selector-class">.map</span>(<span class="selector-tag">Sample</span><span class="selector-pseudo">::simulateTimeConsumingComputation)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr></table></figure>

<p>并行流使执行速度变得快得多。新代码在 16 核处理器上运行所用的时间约为 1 秒，在 8 核处理器上所用时间约为 2 秒。这是因为在默认情况下，并行流使用了与系统上的核心数一样多的线程。<br>您还会注意到，并行化此代码只需相对较少的工作。按顺序执行的函数管道的结构与并行运行的函数管道没什么不同，这使得函数管道非常容易并行化。</p>
<h2 id="函数纯度的规则"><a href="#函数纯度的规则" class="headerlink" title="函数纯度的规则"></a>函数纯度的规则</h2><p>目前您可能很喜欢这些技术给您的印象：惰性能提高效率，并行化的编写与顺序处理一样容易 — 使用它们吧！但是有一个陷阱：这些技术的成功取决于代码的<em>纯度</em>。您的函数管道中的所有 lambda 表达式和闭包都必须是纯的。<br>在继续后面的学习之前，您应该了解纯函数的一些知识。首先，纯函数是<em>幂等的</em>— 这意味着对纯函数的调用次数没有限制。其次，无论调用纯函数多少次，只要给定相同的输入，它都会产生相同的结果。第三，纯函数没有副作用：无论您使用它做什么，纯函数都不会更改您的程序中的其他任何元素。<br>如果您想编写纯函数，请记住，最后这个特征最为重要。实质上，函数纯度有两个规则：</p>
<ul>
<li>函数不会更改任何元素。</li>
<li>函数不依赖于任何可能更改的元素。</li>
</ul>
<p>纯函数绝不会在执行期间引起更改或发生更改。</p>
<h2 id="为什么函数纯度至关重要"><a href="#为什么函数纯度至关重要" class="headerlink" title="为什么函数纯度至关重要"></a>为什么函数纯度至关重要</h2><p><em>惰性计算</em>意味着一个函数可以在现在或以后计算，或者可以完全跳过计算。无论采用何种方式，只要得到想要的结果就行。但是，如果函数有副作用，惰性计算就不会生效。下一个示例将展示在函数管道包含不纯函数时会发生什么。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] factor = new <span class="built_in">int</span>[] &#123; <span class="number">2</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = numbers.stream()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .map(e -&gt; e * factor[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">factor[<span class="number">0</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">stream.forEach(System.<span class="keyword">out</span>::println);</span></pre></td></tr></table></figure>

<p>Java 假设提供给操作的 lambda 表达式和闭包是纯的。如果您的代码不满足这一要求，您将承担相应的后果。<br>为了增添乐趣，可以询问一些同事他们预计此代码的输出是什么。您不可能获得一致的回答。更可能的情况是，您会看到许多人感到困惑和不确定。<br>在这个示例中，传递给 <code>map</code> 的闭包是不纯的。它违背了纯度的第二个规则，因为该闭包依赖的变量可能发生改变（而且事实上它确实发生了改变）。由于惰性计算，作为参数传递给 <code>map</code> 的闭包只在调用 <code>forEach</code> 后才会计算。<br>因为 <code>factor[0]</code> 是可变的，从创建闭包到最终计算它的过程中，该值可以是任何值。这个可变变量让代码变得很难理解。很难理解的代码也就很难维护，而且这通常是出现错误的一个原因。<br>并行流也是如此：如果传递给操作的状态不纯，结果将是不可预测的。</p>
<h2 id="避免共享可变性"><a href="#避免共享可变性" class="headerlink" title="避免共享可变性"></a>避免共享可变性</h2><p>传递给操作的 lambda 表达式和闭包应该是纯的。它们不应修改任何外部状态，也不应依赖于任何可变的外部状态。<br>开发人员常常询问他们是否应完全避免可变性。答案很简单：不要使用可变性。相反，应<strong>避免共享可变性</strong>。在中间和最终操作中，如果修改了一个共享可变变量，代码会变得难以推断。共享可变性还使得通过并行和/或惰性计算无法获得正确的结果。您可以选择不使用并行化，但您无法控制惰性计算，因为它是流的一种隐式行为。<br>尽管共享可变性会花费一些成本，但您可以通过小心地改变隔离变量来获得不错的结果，隔离变量是严格禁止被多个线程共享的变量。在处理的数据量非常大时，改变隔离变量可以提高性能。在一个处理包含数百万个对象的集合的最新项目中，我的团队使用了隔离可变性将性能提高到对数据负载合理的水平。这样做能够奏效是因为我们仔细验证了该项目中不存在共享可变性。我们还验证了我们的结果不仅快，而且正确。<br>对于小型或中等规模的集合，或者您无需可变性就能实现合理性能的情况，最明智的做法是避免 lambda 表达式和闭包中的可变性。如果您在其中一个元素中采用了可变性，请确保您正在改变一个隔离变量，而且永远不要改变共享变量。从函数管道的开始到结束，闭包所依赖的状态绝不应被多个线程修改。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>惰性计算和轻松的并行执行是使用函数管道的两个重要好处。两个特性都取决于<em>函数纯度</em>，这意味着 lambda 表达式和闭包不得在您的程序中产生任何副作用。在本文中，您了解了这个规则和它存在的原因，还探索了可以安全改变隔离变量的一个例外情况。<br>理解函数纯度很重要，因为如果您违背了 lambda 表达式和闭包中的纯度要求，Java 不会产生错误，甚至不会生成警告。所以您需要验证您的 lambda 表达式不依赖于共享可变状态，而且执行的结果既高效又正确。</p>
<blockquote>
<p>作者：Venkat Subramaniam</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-java8idioms11/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-java8idioms11/index.html?ca=drs-</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>Lambda表达式介绍</title>
    <url>/2019/12/26/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1、什么是Lambda表达式"><a href="#1、什么是Lambda表达式" class="headerlink" title="1、什么是Lambda表达式"></a>1、什么是Lambda表达式</h3><p>Lambda 表达式是一种匿名函数，简单地说，它是没有声明的方法，也即没有访问修饰符、返回值声明和名字。<br>它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使 Java 语言的表达能力得到了提升。</p>
<a id="more"></a>

<h3 id="2、Lambda表达式的语法"><a href="#2、Lambda表达式的语法" class="headerlink" title="2、Lambda表达式的语法"></a>2、<strong>Lambda表达式的语法</strong></h3><p>基本语法: (parameters) -&gt; expression<br>或者：(parameters) -&gt;{ statements;<br>举例说明：</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 不需要参数,返回值为 5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">() -&gt; <span class="number">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">x</span> -&gt; <span class="number">2</span> * <span class="symbol">x</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 3. 接受2个参数(数字),并返回他们的差值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">(<span class="symbol">x</span>, <span class="symbol">y</span>) -&gt; <span class="symbol">x</span> – <span class="symbol">y</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 4. 接收2个int型整数,返回他们的和</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">(int <span class="symbol">x</span>, int <span class="symbol">y</span>) -&gt; <span class="symbol">x</span> + <span class="symbol">y</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">(String s) -&gt; System.out.print(s)</span></pre></td></tr></table></figure>

<h3 id="3、什么是函数式接口"><a href="#3、什么是函数式接口" class="headerlink" title="3、什么是函数式接口"></a>3、什么是函数式接口</h3><p>再对上面进行举例说明之前，必须先来理解下函数式接口，因为Lambda是建立在函数式接口的基础上的。<br> <strong>记住！</strong><br>（1）只包含一个抽象方法的接口，称为函数式接口。<br>（2）你可以通过 Lambda 表达式来创建该接口的对象。<br>（3）我们可以在任意函数式接口上使用 <code>@FunctionalInterface</code> 注解，这样做可以检测它是否是一个函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。<br>在实际开发者🈶️两个比较常见的函数式接口：<strong>Runnable接口，Comparator接口</strong><br>先举例<strong>Runnable接口相关</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 1.1使用匿名内部类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">"Hello world !"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 1.2使用 lambda 获得Runnable接口对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">new</span> Thread(() -&gt; System.out.<span class="built_in">println</span>(<span class="string">"Hello world !"</span>)).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//=============================================================================</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 2.1使用匿名内部类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Runnable race1 = <span class="keyword">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">"Hello world !"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 2.2使用 lambda直接获得接口对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Runnable race2 = () -&gt; System.out.<span class="built_in">println</span>(<span class="string">"Hello world !"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 直接调用 run 方法(没开新线程哦!)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        race1.<span class="built_in">run</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        race2.<span class="built_in">run</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/*输出结果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Hello world !</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Hello world !</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Hello world !</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Hello world !</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *／</span></span></pre></td></tr></table></figure>

<p>通过上面案例可以看出：通过Lambda表达式看去舒服清爽多了，2而通过匿名内部类代码总是不够整洁。<br>再举一个例子：<strong>使用Lambda对数组排序</strong></p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class TestArray &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">String</span>[] players = &#123;<span class="string">"zhansgan"</span>, <span class="string">"lisi"</span>, <span class="string">"wangwu"</span>, <span class="string">"zhaoliu"</span>,  <span class="string">"wangmazi"</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 1.1 使用匿名内部类根据 surname 排序 players</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Arrays.<span class="built_in">sort</span>(players, <span class="keyword">new</span> Comparator&lt;<span class="keyword">String</span>&gt;() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">public</span> <span class="built_in">int</span> compare(<span class="keyword">String</span> s1, <span class="keyword">String</span> s2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> (s1.compareTo(s2));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 1.2 使用 lambda 排序,根据 surname</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Arrays.<span class="built_in">sort</span>(players, (<span class="keyword">String</span> s1, <span class="keyword">String</span> s2) -&gt;  s1.compareTo(s2));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//================================================================================================</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 2.1 使用匿名内部类根据 name lenght 排序 players</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Arrays.<span class="built_in">sort</span>(players, <span class="keyword">new</span> Comparator&lt;<span class="keyword">String</span>&gt;() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">public</span> <span class="built_in">int</span> compare(<span class="keyword">String</span> s1, <span class="keyword">String</span> s2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> (s1.length() - s2.length());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 2.2使用Lambda,根据name length</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Arrays.<span class="built_in">sort</span>(players, (<span class="keyword">String</span> s1, <span class="keyword">String</span> s2) -&gt; (s1.length() - s2.length()));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//==================================================================================================</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 3.1 使用匿名内部类排序 players, 根据最后一个字母</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Arrays.<span class="built_in">sort</span>(players, <span class="keyword">new</span> Comparator&lt;<span class="keyword">String</span>&gt;() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">public</span> <span class="built_in">int</span> compare(<span class="keyword">String</span> s1, <span class="keyword">String</span> s2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> (s1.charAt(s1.length() - <span class="number">1</span>) - s2.charAt(s2.length() - <span class="number">1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 3.2 使用Lambda,根据最后一个字母</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Arrays.<span class="built_in">sort</span>(players, (<span class="keyword">String</span> s1, <span class="keyword">String</span> s2) -&gt; (s1.charAt(s1.length() - <span class="number">1</span>) - s2.charAt(s2.length() - <span class="number">1</span>)));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过上面例子我们再来思考为什么Lambda表达式需要函数式接口？其实很简单目的就是为来保证唯一。<br><strong>你的</strong>Runnable接口只要一个抽象方法，那么我用<code>() -&gt; System.out.println(&quot;Hello world !&quot;)</code>，就只能代表run方法，如果你下面还有一个抽象方法，那我使用Lambda表达式，那鬼才知道要调用哪个抽象方法呢。</p>
<h2 id="二、方法引用"><a href="#二、方法引用" class="headerlink" title="二、方法引用"></a><strong>二、方法引用</strong></h2><h3 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a><strong>1、基本介绍</strong></h3><p><strong>首先注意：</strong>方法引用，不是方法调用！方法引用，不是方法调用！方法引用，不是方法调用！<br>函数式接口的实例可以通过 lambda 表达式、 方法引用、构造方法引用来创建。方法引用是 lambda 表达式的语法糖，任何用方法引用的地方都可由lambda表达式替换，但是并不是所有的lambda表达式都可以用方法引用来替换。<br>举例<br>这就是一个打印集合所有元素的例子，<code>value -&gt; System.out.println(value)</code> 是一个Consumer函数式接口， 这个函数式接口可以通过方法引用来替换。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArray</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         List&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span> = Arrays.asList(<span class="string">"xuxiaoxiao"</span>, <span class="string">"xudada"</span>, <span class="string">"xuzhongzhong"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="built_in">list</span>.forEach(value -&gt; System.out.<span class="built_in">println</span>(value));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/* 输出：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * xuxiaoxiao</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * xudada</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * xuzhongzhong</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用方法引用的方式，和上面的输出是一样的，方法引用使用的是双冒号（::）</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>.for<span class="constructor">Each(System.<span class="params">out</span>::<span class="params">println</span>)</span>;</span></pre></td></tr></table></figure>

<h3 id="2、分类"><a href="#2、分类" class="headerlink" title="2、分类"></a>2、分类</h3><table>
<thead>
<tr>
<th>类别</th>
<th>使用形式</th>
</tr>
</thead>
<tbody><tr>
<td>静态方法引用</td>
<td>类名 :: 静态方法名</td>
</tr>
<tr>
<td>实例方法引用</td>
<td>对象名(引用名) :: 实例方法名</td>
</tr>
<tr>
<td>类方法引用</td>
<td>类名 :: 实例方法名</td>
</tr>
<tr>
<td>构造方法引用</td>
<td>类名 :: new</td>
</tr>
</tbody></table>
<p><strong>（1）静态方法引用</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(<span class="keyword">String</span> name, <span class="keyword">String</span> color, <span class="keyword">double</span> weight)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.color = color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.weight = weight;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareByWeight</span><span class="params">(Apple a1, Apple a2)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">double</span> diff = a1.getWeight() - a2.getWeight();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Double(diff).intValue();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//还有getter setter toString</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>有一个苹果的List，现在需要根据苹果的重量进行排序。List 的 sort 函数接收一个 Comparator 类型的参数，Comparator 是一个函数式接口，接收两个参数，返回一个int值。<br>Apple的静态方法compareByWeight正好符合Comparator函数式接口，所以可以使用：<br><code>Apple::compareByWeight</code> 静态方法引用来替代lambda表达式</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> LambdaTest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple1 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"红富士"</span>, <span class="string">"Red"</span>, 280)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple2 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"冯心"</span>, <span class="string">"Yello"</span>, 470)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple3 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"大牛"</span>, <span class="string">"Red"</span>, 320)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple4 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"小小"</span>, <span class="string">"Green"</span>, 300)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;Apple&gt; appleList = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">as</span><span class="constructor">List(<span class="params">apple1</span>, <span class="params">apple2</span>, <span class="params">apple3</span>, <span class="params">apple4</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//lambda 表达式形式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//appleList.sort((Apple a1, Apple a2) -&gt; &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//    return new Double(a1.getWeight() - a2.getWeight()).intValue();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//&#125;);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//静态方法引用形式（可以看出引用方法比上面的更加简单</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        appleList.sort(Apple::compareByWeight);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appleList.for<span class="constructor">Each(<span class="params">apple</span> -&gt; System.<span class="params">out</span>.<span class="params">println</span>(<span class="params">apple</span>)</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'红富士'</span>, <span class="attribute">color</span>=<span class="string">'Red'</span>, <span class="attribute">weight</span>=280.0&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'小小'</span>, <span class="attribute">color</span>=<span class="string">'Green'</span>, <span class="attribute">weight</span>=300.0&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'大牛'</span>, <span class="attribute">color</span>=<span class="string">'Red'</span>, <span class="attribute">weight</span>=320.0&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'冯心'</span>, <span class="attribute">color</span>=<span class="string">'Yello'</span>, <span class="attribute">weight</span>=470.0&#125;</span></pre></td></tr></table></figure>

<p><strong>注意：</strong><code>Apple.compareByWeight</code>是方法的调用，而<code>Apple::compareByWeight</code>方法引用，这两者完全不是一回事。<br><strong>（2）实例方法引用</strong><br>这个compareByWeight是一个实例方法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> AppleComparator &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public <span class="built_in">int</span> compare<span class="constructor">ByWeight(Apple <span class="params">a1</span>, Apple <span class="params">a2</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        double diff = a1.get<span class="constructor">Weight()</span> - a2.get<span class="constructor">Weight()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return <span class="keyword">new</span> <span class="constructor">Double(<span class="params">diff</span>)</span>.<span class="built_in">int</span><span class="constructor">Value()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>下面的例子通过实例对象的方法引用 <code>comparator::compareByWeight</code> 来代替lambda表达式</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> LambdaTest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple1 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"红富士"</span>, <span class="string">"Red"</span>, 280)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple2 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"冯心"</span>, <span class="string">"Yello"</span>, 470)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple3 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"哈哈"</span>, <span class="string">"Red"</span>, 320)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple4 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"小小"</span>, <span class="string">"Green"</span>, 300)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;Apple&gt; appleList = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">as</span><span class="constructor">List(<span class="params">apple1</span>, <span class="params">apple2</span>, <span class="params">apple3</span>, <span class="params">apple4</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//lambda 表达式形式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//appleList.sort((Apple a1, Apple a2) -&gt; &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//    return new Double(a1.getWeight() - a2.getWeight()).intValue();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//&#125;);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//实例方法引用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        AppleComparator comparator = <span class="keyword">new</span> <span class="constructor">AppleComparator()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appleList.sort(comparator::compareByWeight);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appleList.for<span class="constructor">Each(<span class="params">apple</span> -&gt; System.<span class="params">out</span>.<span class="params">println</span>(<span class="params">apple</span>)</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'红富士'</span>, <span class="attribute">color</span>=<span class="string">'Red'</span>, <span class="attribute">weight</span>=280.0&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'小小'</span>, <span class="attribute">color</span>=<span class="string">'Green'</span>, <span class="attribute">weight</span>=300.0&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'哈哈'</span>, <span class="attribute">color</span>=<span class="string">'Red'</span>, <span class="attribute">weight</span>=320.0&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'冯心'</span>, <span class="attribute">color</span>=<span class="string">'Yello'</span>, <span class="attribute">weight</span>=470.0&#125;</span></pre></td></tr></table></figure>

<p>通过上面两个例子可以看到，静态方法引用和实例方法引用都是比较好理解的。<br>（3）类方法引用<br>一般来说，同类型对象的比较，应该当前调用方法的对象与另外一个对象进行比较，好的设计应该像下面：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> category;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(<span class="keyword">String</span> category, <span class="keyword">String</span> color, <span class="keyword">double</span> weight)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.category = category;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.color = color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.weight = weight;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//这里和上面静态方式唯一区别就是这个参数就一个，需要实例对象调这个方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareByWeight</span><span class="params">(Apple other)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">double</span> diff = <span class="keyword">this</span>.getWeight() - other.getWeight();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Double(diff).intValue();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//getter setter toString</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>还是之前List排序的例子，看看使用类方法引用如何写：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> LambdaTest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple1 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"红富士"</span>, <span class="string">"Red"</span>, 280)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple2 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"黄元帅"</span>, <span class="string">"Yello"</span>, 470)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple3 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"红将军"</span>, <span class="string">"Red"</span>, 320)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Apple apple4 = <span class="keyword">new</span> <span class="constructor">Apple(<span class="string">"国光"</span>, <span class="string">"Green"</span>, 300)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;Apple&gt; appleList = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">as</span><span class="constructor">List(<span class="params">apple1</span>, <span class="params">apple2</span>, <span class="params">apple3</span>, <span class="params">apple4</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//lambda 表达式形式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//appleList.sort((Apple a1, Apple a2) -&gt; &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//    return new Double(a1.getWeight() - a2.getWeight()).intValue();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//&#125;);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//这里是类方法引用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        appleList.sort(Apple::compareByWeight);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appleList.for<span class="constructor">Each(<span class="params">apple</span> -&gt; System.<span class="params">out</span>.<span class="params">println</span>(<span class="params">apple</span>)</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'红富士'</span>, <span class="attribute">color</span>=<span class="string">'Red'</span>, <span class="attribute">weight</span>=280.0&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'国光'</span>, <span class="attribute">color</span>=<span class="string">'Green'</span>, <span class="attribute">weight</span>=300.0&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'红将军'</span>, <span class="attribute">color</span>=<span class="string">'Red'</span>, <span class="attribute">weight</span>=320.0&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Apple&#123;<span class="attribute">category</span>=<span class="string">'黄元帅'</span>, <span class="attribute">color</span>=<span class="string">'Yello'</span>, <span class="attribute">weight</span>=470.0&#125;</span></pre></td></tr></table></figure>

<p>这里使用的是：类名::实例方法名。首先要说明的是，方法引用不是方法调用。compareByWeight一定是某个实例调用的，就是lambda表达式的第一个参数，然后lambda表达式剩下的参数作为<br>compareByWeight的参数，这样compareByWeight正好符合lambda表达式的定义。<br>或者也可以这样理解：<br><code>(Apple a1, Apple a2) -&gt; { return new Double(a1.getWeight() - a2.getWeight()).intValue(); }</code><br><code>int compareByWeight(Apple other)</code> 需要当前对象调用，然后与另外一个对象比较，并且返回一个int值。可以理解为lambda表达式的第一个参数 a1 赋值给当前对象， 然后 a2 赋值给 other对象，然后返回int值。<br><strong>（4）构造方法引用</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructionMethodTest</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getString</span><span class="params">(Supplier&lt;<span class="keyword">String</span>&gt; supplier)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> supplier.<span class="built_in">get</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ConstructionMethodTest test = <span class="keyword">new</span> ConstructionMethodTest();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//lambda表达式形式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(test.getString(() -&gt; &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">String</span>();&#125;));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//构造方法引用形式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(test.getString(<span class="keyword">String</span>::<span class="keyword">new</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>getString 方法接收一个Supplier类型的参数，Supplier 不接收参数，返回一个String。lambda表达式应该这样写：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">()</span> -&gt;</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> String();&#125;</span></pre></td></tr></table></figure>

<p>替换成方法引用的形式如下： 实际上调用的是String 无参构造方法。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span>::<span class="keyword">new</span></span></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1、<a href="https://www.cnblogs.com/franson-2016/p/5593080.html" target="_blank" rel="noopener">Java中Lambda表达式的使用</a><br>2、<a href="https://blog.csdn.net/yitian_66/article/details/80652656" target="_blank" rel="noopener">java8特性概要以及demo分析</a><br>3<a href="https://blog.csdn.net/yitian_66/article/details/80652656" target="_blank" rel="noopener">、</a><a href="https://blog.csdn.net/yitian_66/article/details/80652656" target="_blank" rel="noopener">java8 笔记 - 方法引用（四）</a></p>
<blockquote>
<p>作者：雨点的名字</p>
<p>来源：<a href="https://www.cnblogs.com/qdhxhz/p/9393724.html" target="_blank" rel="noopener">https://www.cnblogs.com/qdhxhz/p/9393724.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>Java深浅拷贝</title>
    <url>/2019/12/26/Java%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>我觉得主要跟JVM内存分配有关,对于基本数据类型,只存在栈内存,所以它的拷贝不存在深浅拷贝这个概念。而对于对象而言,一个对象的创建会在内存中分配两块空间,一个在栈内存存对象的引用指针,一个在堆内存存放对象。这个时候会有一个问题，你拷贝的只是这个引用指针还是拷贝两块内存一起拷贝,这个时候就会有深浅拷贝一说。<br>还有之前我认为Arrays.copyOf()是深度拷贝,亲测后发现原来它也是浅拷贝。下面进行具体说明。</p>
<a id="more"></a>

<h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><p>数据分为<code>基本数据</code>类型(int, boolean, double, byte, char等)和<code>对象数据</code>类型。<br>基本数据类型的特点：<code>直接存储在栈(stack)中的数据</code>.<br>引用数据类型的特点：<code>在栈内存存储对象引用，真实的数据存放在堆内存里</code><br>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。<br><img src="http://image.winrains.cn/2019/08/b47af-1090617-20190313235427505-245278508.jpg" alt="img"></p>
<h2 id="三、什么是浅拷贝和深拷贝"><a href="#三、什么是浅拷贝和深拷贝" class="headerlink" title="三、什么是浅拷贝和深拷贝"></a>三、什么是浅拷贝和深拷贝</h2><p>首先需要明白，<code>深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的</code>。那先来看看浅拷贝和深拷贝的概念。<br>在 Java 中，除了基本数据类型（元类型）之外，还存在 类的实例对象 这个引用数据类型。而一般使用 <code>=</code>号做赋值操作的时候。对于基本数据类型，实际上是拷贝的它的值，但是对于对象而言，其实赋值的只是这个对象的引用，将原对象的引用传递过去，他们实际上还是指向的同一个对象。<br><code>浅拷贝</code>：如果在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行了引用的传递，而没有真实的创建一个新的对象。<br><code>深拷贝</code>：在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量。<br>深拷贝和浅拷贝的示意图大致如下：<br><img src="http://image.winrains.cn/2019/08/8e501-1090617-20190313235500918-1556393479.jpg" alt="img"><br><img src="http://image.winrains.cn/2019/08/8dcb2-1090617-20190313235507983-512560464.jpg" alt="img"><br>具体接下来代码演示。</p>
<h2 id="四、代码演示"><a href="#四、代码演示" class="headerlink" title="四、代码演示"></a>四、代码演示</h2><h3 id="1、浅拷贝"><a href="#1、浅拷贝" class="headerlink" title="1、浅拷贝"></a>1、浅拷贝</h3><p><strong>Person</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> Integer age;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> sex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 提供get和set方法和全参构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>Test</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static void main(String<span class="literal">[]</span> args) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person person = <span class="keyword">new</span> <span class="constructor">Person(<span class="string">"小小"</span>, 3, <span class="string">"女"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 将person值赋值给person1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person person1 = person;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(person);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(person1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    person1.set<span class="constructor">Name(<span class="string">"小小她爸"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"person 中 name为："</span> + person.get<span class="constructor">Name()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"person1 中 name为："</span> + person.get<span class="constructor">Name()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>查看运行结果<br><img src="http://image.winrains.cn/2019/08/4cbf5-1090617-20190313235604444-1064708140.jpg" alt="img"><br>从图片中我们可以很明显看出,它们指向的内存地址是一致的,同样我改变person1的属性值时发现person的属性值也改变了。<br><code>说明</code>：对于对象用<code>&quot;=&quot;</code> 赋值 其实只是引用指针的复制,这两个引用还是指向同一个对象。</p>
<h3 id="2、深拷贝"><a href="#2、深拷贝" class="headerlink" title="2、深拷贝"></a>2、深拷贝</h3><p>如果要实现深拷贝就会比较复杂点<br><strong>Student</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 如果对象要实现深拷贝 那么实体需要做两步</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 1、实体实现Cloneable接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 2、重写 clone()方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Student <span class="keyword">implements</span> Cloneable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> Integer age;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> sex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//这也是个实体</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> Address address;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 提供get和set方法和全参构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> <span class="built_in">Object</span> clone() throws CloneNotSupportedException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>Test</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static void main(String<span class="literal">[]</span> args) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Student student = <span class="keyword">new</span> <span class="constructor">Student(<span class="string">"小小"</span>, 3, <span class="string">"女"</span>, <span class="params">null</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 将person值赋值给person1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Student student1 = (Student) student.clone<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(student);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(student1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    student1.set<span class="constructor">Name(<span class="string">"小小她爸"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"person 中 name为："</span> + student.get<span class="constructor">Name()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"person1 中 name为："</span> + student1.get<span class="constructor">Name()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><img src="http://image.winrains.cn/2019/08/60ea8-1090617-20190313235621488-1930654079.jpg" alt="img"><br>这里可以已经是两个不同的对象了。但是这里需要注意的是,如果对象中含有对象,这个对象还是浅拷贝。<br><strong>Address</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Address</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> String city;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> phone;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 提供get和set方法和全参构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>Test</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static void main(String<span class="literal">[]</span> args) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Address address = <span class="keyword">new</span> <span class="constructor">Address(<span class="string">"杭州"</span>, 1888888888)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Student student2 = <span class="keyword">new</span> <span class="constructor">Student(<span class="string">"小小"</span>, 3, <span class="string">"女"</span>, <span class="params">address</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 将person值赋值给person1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Student student3 = (Student) student2.clone<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    address.set<span class="constructor">City(<span class="string">"北京天安门"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"person2 中 city为："</span> + student2.get<span class="constructor">Address()</span>.get<span class="constructor">City()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"person3 中 city为："</span> + student3.get<span class="constructor">Address()</span>.get<span class="constructor">City()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><img src="http://image.winrains.cn/2019/08/b6122-1090617-20190313235642049-1971336257.jpg" alt="img"><br>我们发现虽然Student是实现了深拷贝，但Address却还是浅拷贝,那如何让Adress也实现深拷贝呢。<br><strong>Address修改</strong></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> String  city;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> phone;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 提供get和set方法和全参构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> <span class="function">Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">clone</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>Student修改</strong></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改clone方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function">Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Student s = (Student) <span class="keyword">super</span>.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    s.address = (Address) address.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><img src="http://image.winrains.cn/2019/08/65f79-1090617-20190313235631951-1609979398.jpg" alt="img"><br><code>弊端</code>: 这里我们Person 类只有一个 Address 引用类型，而 Address 类没有，所以我们只用重写 Address 类的clone 方法，但是如果 Address 类也存在一个引用类型，<br>那么我们也要重写其clone 方法，这样下去，有多少个引用类型，我们就要重写多少次，如果存在很多引用类型，那么代码量显然会很大，所以这种方法不太合适。<br>所以还有另一种实现深拷贝方法。<br><strong>序列化实现深拷贝</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序列化实现深拷贝</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public Object deep<span class="constructor">Clone()</span> throws Exception&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 序列化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ByteArrayOutputStream bos = <span class="keyword">new</span> <span class="constructor">ByteArrayOutputStream()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ObjectOutputStream oos = <span class="keyword">new</span> <span class="constructor">ObjectOutputStream(<span class="params">bos</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    oos.write<span class="constructor">Object(<span class="params">this</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 反序列化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ByteArrayInputStream bis = <span class="keyword">new</span> <span class="constructor">ByteArrayInputStream(<span class="params">bos</span>.<span class="params">toByteArray</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> <span class="constructor">ObjectInputStream(<span class="params">bis</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return ois.read<span class="constructor">Object()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">　<span class="comment">//因为序列化产生的是两个完全独立的对象，所有无论嵌套多少个引用类型，序列化都是能实现深拷贝的。</span></span></pre></td></tr></table></figure>

<h2 id="五、Arrays-copyOf"><a href="#五、Arrays-copyOf" class="headerlink" title="五、Arrays.copyOf()"></a>五、Arrays.copyOf()</h2><p>之前我误以为Arrays.copyOf()为深拷贝,那只是因为我用的是基本数据类型作为数组,而基本数据类型上面已经说过它没有深浅拷贝这个概念，可以把他理解成只有深拷贝。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static void main(String<span class="literal">[]</span> args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 1、基本数据类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">int</span><span class="literal">[]</span> a = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Arrays.copyOf拷贝</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">int</span><span class="literal">[]</span> copy = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>copy<span class="constructor">Of(<span class="params">a</span>, <span class="params">a</span>.<span class="params">length</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    a<span class="literal">[<span class="number">0</span>]</span> = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">copy</span>)</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">a</span>)</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 2、对象数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Student<span class="literal">[]</span> stuArr = &#123; <span class="keyword">new</span> <span class="constructor">Student(<span class="string">"小小"</span>, 3, <span class="string">"女"</span>)</span>, <span class="keyword">new</span> <span class="constructor">Student(<span class="string">"小小爸"</span>, 29, <span class="string">"男"</span>)</span>, <span class="keyword">new</span> <span class="constructor">Student(<span class="string">"小小妈"</span>, 27, <span class="string">"女"</span>)</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Arrays.copyOf拷贝</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Student<span class="literal">[]</span> copyStuArr = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>copy<span class="constructor">Of(<span class="params">stuArr</span>, <span class="params">stuArr</span>.<span class="params">length</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    copyStuArr<span class="literal">[<span class="number">0</span>]</span>.set<span class="constructor">Name(<span class="string">"小小爷爷"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">stuArr</span>)</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">copyStuArr</span>)</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>运行结果：<br><img src="http://image.winrains.cn/2019/08/72add-1090617-20190313235732499-1673590724.jpg" alt="img"><br>可以明显看出,对于基本数据类型只有深拷贝,而对于数组对象而言,明显存在深浅拷贝,而且可以看出<code>Arrays.copyOf()为浅拷贝</code>。</p>
<blockquote>
<p>作者：雨点的名字</p>
<p>来源：<a href="https://www.cnblogs.com/qdhxhz/p/10527245.html" target="_blank" rel="noopener">https://www.cnblogs.com/qdhxhz/p/10527245.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 泛型全解</title>
    <url>/2019/12/26/Java-%E6%B3%9B%E5%9E%8B%E5%85%A8%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>对于java的泛型我一直属于一知半解的，平常真心用的不多。直到阅读《Effect Java》,看到很多平常不了解的用法，才下定决心，需要系统的学习，并且记录下来。</p>
<a id="more"></a>

<hr>
<h2 id="1、泛型的概述："><a href="#1、泛型的概述：" class="headerlink" title="1、泛型的概述："></a>1、泛型的概述：</h2><h3 id="1-1-泛型的由来"><a href="#1-1-泛型的由来" class="headerlink" title="1.1 泛型的由来"></a>1.1 泛型的由来</h3><p>根据《Java编程思想》中的描述，泛型出现的动机：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有很多原因促成了泛型的出现，而最引人注意的一个原因，就是为了创建容器类。</span></pre></td></tr></table></figure>

<p>泛型的思想很早就存在，如C++中的模板（Templates）。模板的精神：<strong>参数化类型</strong></p>
<h3 id="1-2-基本概述"><a href="#1-2-基本概述" class="headerlink" title="1.2 基本概述"></a>1.2 基本概述</h3><ul>
<li>泛型的本质就是”参数化类型”。一提到参数，最熟悉的就是定义方法的时候需要形参，调用方法的时候，需要传递实参。那”参数化类型”就是将原来具体的类型参数化</li>
<li>泛型的出现避免了强转的操作，在编译器完成类型转化，也就避免了运行的错误。</li>
</ul>
<h3 id="1-3-泛型的目的"><a href="#1-3-泛型的目的" class="headerlink" title="1.3 泛型的目的"></a>1.3 泛型的目的</h3><ul>
<li>Java泛型也是一种语法糖，在编译阶段完成类型的转换的工作，避免在运行时强制类型转换而出现ClassCastException,类型转化异常。</li>
</ul>
<h3 id="1-4-实例"><a href="#1-4-实例" class="headerlink" title="1.4 实例"></a>1.4 实例</h3><p>JDK 1.5时增加了泛型，在很大的程度上方便在集合上的使用。</p>
<ul>
<li>不使用泛型：</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">list</span>.add(<span class="number">11</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">list</span>.add(<span class="string">"ssss"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.<span class="built_in">size</span>(); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>((<span class="keyword">String</span>) <span class="built_in">list</span>.<span class="built_in">get</span>(i));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>因为list类型是Object。所以int,String类型的数据都是可以放入的，也是都可以取出的。但是上述的代码，运行的时候就会抛出类型转化异常，这个相信大家都能明白。</p>
<ul>
<li>使用泛型：</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">list</span>.add(<span class="string">"hahah"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">list</span>.add(<span class="string">"ssss"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.<span class="built_in">size</span>(); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>((<span class="keyword">String</span>)<span class="built_in">list</span>.<span class="built_in">get</span>(i));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在上述的实例中，我们只能添加String类型的数据，否则编译器会报错。</p>
<hr>
<h2 id="2、泛型的使用"><a href="#2、泛型的使用" class="headerlink" title="2、泛型的使用"></a>2、泛型的使用</h2><p>泛型的三种使用方式：<strong>泛型类</strong>，<strong>泛型方法</strong>，<strong>泛型接口</strong></p>
<h3 id="2-1-泛型类"><a href="#2-1-泛型类" class="headerlink" title="2.1 泛型类"></a>2.1 泛型类</h3><ul>
<li>泛型类概述：把泛型定义在类上</li>
<li>定义格式：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名 &lt;泛型类型1,...&gt; &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li>注意事项：泛型类型必须是引用类型（非基本数据类型）</li>
</ul>
<h3 id="2-2-泛型方法"><a href="#2-2-泛型方法" class="headerlink" title="2.2 泛型方法"></a>2.2 泛型方法</h3><ul>
<li>泛型方法概述：把泛型定义在方法上</li>
<li>定义格式：</li>
</ul>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml">public <span class="tag">&lt;<span class="name">泛型类型</span>&gt;</span> 返回类型 方法名（泛型类型 变量名） </span><span class="template-variable">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="template-variable">&#125;</span></span></pre></td></tr></table></figure>

<ul>
<li>注意要点：<ul>
<li>方法声明中定义的形参只能在该方法里使用，而接口、类声明中定义的类型形参则可以在整个接口、类中使用。当调用fun()方法时，根据传入的实际对象，编译器就会判断出类型形参T所代表的实际类型。</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="function"><span class="title">fun</span><span class="params">(T t)</span></span> &#123;   <span class="comment">// 可以接收任意类型的数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> t ;     <span class="comment">// 直接把参数返回</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo26</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> static void main(String args[])&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Demo d = new Demo() ; <span class="comment">// 实例化Demo对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        String str = d<span class="function">.<span class="title">fun</span><span class="params">(<span class="string">"汤姆"</span>)</span></span> ; <span class="comment">// 传递字符串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        int i = d<span class="function">.<span class="title">fun</span><span class="params">(<span class="number">30</span>)</span></span> ;  <span class="comment">// 传递数字，自动装箱</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(str) ; <span class="comment">// 输出内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(i) ;  <span class="comment">// 输出内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="2-3-泛型接口"><a href="#2-3-泛型接口" class="headerlink" title="2.3 泛型接口"></a>2.3 泛型接口</h3><ul>
<li>泛型接口概述：把泛型定义在接口</li>
<li>定义格式：</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>接口名&lt;泛型类型&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li>实例：</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 泛型接口的定义格式:        修饰符  interface 接口名&lt;数据类型&gt; &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">Inter</span>&lt;<span class="symbol">T</span>&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">void</span> show(T t) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 子类是泛型类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">InterImpl</span>&lt;<span class="symbol">E</span>&gt; <span class="symbol">implements</span> <span class="symbol">Inter</span>&lt;<span class="symbol">E</span>&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> show(E t) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Inter&lt;String&gt; <span class="built_in">int</span>er = new InterImpl&lt;String&gt;() ;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>er.show(<span class="string">"hello"</span>) ;</span></pre></td></tr></table></figure>

<h3 id="2-4-源码中泛型的使用，下面是List接口和ArrayList类的代码片段。"><a href="#2-4-源码中泛型的使用，下面是List接口和ArrayList类的代码片段。" class="headerlink" title="2.4 源码中泛型的使用，下面是List接口和ArrayList类的代码片段。"></a>2.4 源码中泛型的使用，下面是List接口和ArrayList类的代码片段。</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义接口时指定了一个类型形参，该形参名为E</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">List</span>&lt;<span class="symbol">E</span>&gt; <span class="symbol">extends</span> <span class="symbol">Collection</span>&lt;<span class="symbol">E</span>&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">//在该接口里，E可以作为类型使用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> E <span class="keyword">get</span>(<span class="built_in">int</span> index) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="built_in">void</span> add(E e) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//定义类时指定了一个类型形参，该形参名为E</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ArrayList</span>&lt;<span class="symbol">E</span>&gt; <span class="symbol">extends</span> <span class="symbol">AbstractList</span>&lt;<span class="symbol">E</span>&gt; <span class="symbol">implements</span> <span class="symbol">List</span>&lt;<span class="symbol">E</span>&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">//在该类里，E可以作为类型使用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="built_in">void</span> <span class="keyword">set</span>(E e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   .......................</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="2-5-泛型类派生子类"><a href="#2-5-泛型类派生子类" class="headerlink" title="2.5 泛型类派生子类"></a>2.5 泛型类派生子类</h3><p><strong>父类派生子类的时候不能在包含类型形参，需要传入具体的类型</strong></p>
<ul>
<li>错误的方式：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Container&lt;K</span>, <span class="title">V&gt;</span> </span>&#123;&#125;</span></pre></td></tr></table></figure>

<ul>
<li>正确的方式：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Container&lt;Integer</span>, <span class="title">String&gt;</span> </span>&#123;&#125;</span></pre></td></tr></table></figure>

<ul>
<li>也可以不指定具体的类型，系统就会把K,V形参当成Object类型处理</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Container</span> </span>&#123;&#125;</span></pre></td></tr></table></figure>

<h3 id="2-6-泛型构造器"><a href="#2-6-泛型构造器" class="headerlink" title="2.6 泛型构造器"></a>2.6 泛型构造器</h3><ul>
<li>构造器也是一种方法，所以也就产生了所谓的泛型构造器。</li>
<li>和使用普通方法一样没有区别，一种是显示指定泛型参数，另一种是隐式推断</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Person</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> &lt;T&gt; Person(T t) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">new</span> Person(<span class="number">22</span>);<span class="comment">// 隐式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">new</span> &lt;<span class="keyword">String</span>&gt; Person(<span class="string">"hello"</span>);<span class="comment">//显示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li><p>特殊说明：</p>
<ul>
<li>如果构造器是泛型构造器，同时该类也是一个泛型类的情况下应该如何使用泛型构造器：因为泛型构造器可以显式指定自己的类型参数（需要用到菱形，放在构造器之前），而泛型类自己的类型实参也需要指定（菱形放在构造器之后），这就同时出现了两个菱形了，这就会有一些小问题，具体用法再这里总结一下。 以下面这个例子为代表</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Person</span>&lt;<span class="symbol">E</span>&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> &lt;T&gt; Person(T t) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>正确用法：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person&lt;<span class="keyword">String</span>&gt; person = <span class="keyword">new</span> Person(<span class="string">"sss"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>PS：编译器会提醒你怎么做的</p>
</li>
</ul>
<h3 id="2-7-高级通配符"><a href="#2-7-高级通配符" class="headerlink" title="2.7 高级通配符"></a>2.7 高级通配符</h3><h4 id="2-7-1背景："><a href="#2-7-1背景：" class="headerlink" title="2.7.1背景："></a>2.7.1背景：</h4><h4 id="2-7-2-lt-extends-T-gt-上界通配符"><a href="#2-7-2-lt-extends-T-gt-上界通配符" class="headerlink" title="2.7.2 &lt;? extends T&gt; 上界通配符"></a>2.7.2 &lt;? extends T&gt; 上界通配符</h4><ul>
<li><ul>
<li>正因为无法确定具体的类型是什么，add方法受限（可以添加null，因为null表示任何类型），但可以从列表中获取元素后赋值给父类型。如上图中的第一个例子，第三个add()操作会受限，原因在于List和List是List&lt;? extends Animal&gt;的子类型。上界通配符顾名思义，&lt;? extends T&gt;表示的是类型的上界【包含自身】，因此通配的参数化类型可能是T或T的子类。</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//它表示集合中的所有元素都是Animal类型或者其子类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;? <span class="keyword">extends</span> Animal&gt;</span></pre></td></tr></table></figure>

<ul>
<li>例如：</li>
<li>这样就确定集合中元素的类型，虽然不确定具体的类型，但最起码知道其父类。然后进行其他操作。这就是所谓的上限通配符，使用关键字extends来实现，实例化时，指定类型实参只能是extends后类型的子类或其本身。</li>
</ul>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Cat是其子类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">List</span><span class="meta">&lt;?</span> extends Animal&gt; <span class="keyword">list</span> = <span class="keyword">new</span> ArrayList&lt;Cat&gt;();</span></pre></td></tr></table></figure>

<h4 id="2-7-3-lt-super-T-gt-下界通配符"><a href="#2-7-3-lt-super-T-gt-下界通配符" class="headerlink" title="2.7.3 &lt;? super T&gt; 下界通配符"></a>2.7.3 &lt;? super T&gt; 下界通配符</h4><ul>
<li><p>下界通配符&lt;? super T&gt;表示的是参数化类型是T的超类型（包含自身），层层至上，直至Object</p>
<ul>
<li>编译器无从判断get()返回的对象的类型是什么，因此get()方法受限。但是可以进行add()方法，add()方法可以添加T类型和T类型的子类型，如第二个例子中首先添加了一个Cat类型对象，然后添加了两个Cat子类类型的对象，这种方法是可行的，但是如果添加一个Animal类型的对象，显然将继承的关系弄反了，是不可行的。</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//它表示集合中的所有元素都是Cat类型或者其父类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">List</span> &lt;? <span class="keyword">super</span> Cat&gt;</span></pre></td></tr></table></figure>

<ul>
<li>例如这就是所谓的下限通配符，使用关键字super来实现，实例化时，指定类型实参只能是extends后类型的子类或其本身</li>
</ul>
</li>
<li><pre><code>//Animal是其父类
List&lt;? super Cat&gt; list = new ArrayList&lt;Animal&gt;();
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">#### <span class="number">2.7</span><span class="number">.4</span> &lt;?&gt; 无界通配符</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- 任意类型，如果没有明确，那么就是Object以及任意的Java类了</span></pre></td></tr><tr><td class="code"><pre><span class="line">- 无界通配符用&lt;?&gt;表示，?代表了任何的一种类型，能代表任何一种类型的只有null（Object本身也算是一种类型，但却不能代表任何一种类型，所以List和List的含义是不同的，前者类型是Object，也就是继承树的最上层，而后者的类型完全是未知的）</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">------</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">## <span class="number">3</span>、泛型擦除</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">### <span class="number">3.1</span> 概念</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">编译器编译带类型说明的集合时会去掉类型信息</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">### <span class="number">3.2</span> 验证实例：</span></pre></td></tr></table></figure>
public class GenericTest {
  public static void main(String[] args) {
      new GenericTest().testType();
  }
  public void testType(){
      ArrayList&lt;Integer&gt; collection1 = new ArrayList&lt;Integer&gt;();
      ArrayList&lt;String&gt; collection2= new ArrayList&lt;String&gt;();
      System.out.println(collection1.getClass()==collection2.getClass());
      //两者class类型一样,即字节码一致
      System.out.println(collection2.getClass().getName());
      //class均为java.util.ArrayList,并无实际类型参数信息
  }
}
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>输出结果：</span></pre></td></tr></table></figure>
true
java.util.ArrayList
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- 分析：</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - 这是因为不管为泛型的类型形参传入哪一种类型实参，对于Java来说，它们依然被当成同一类处理，在内存中也只占用一块内存空间。从Java泛型这一概念提出的目的来看，其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的<span class="keyword">class</span>文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - **在静态方法、静态初始化块或者静态变量的声明和初始化中不允许使用类型形参。由于系统中并不会真正生成泛型类，所以instanceof运算符后不能使用泛型类**</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">------</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">## <span class="number">4</span>、泛型与反射</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- 把泛型变量当成方法的参数，利用<span class="function"><span class="keyword">Method</span>类的<span class="title">getGenericParameterTypes</span>方法来获取泛型的实际类型参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">- 例子：</span></span></pre></td></tr></table></figure>
public class GenericTest {
  public static void main(String[] args) throws Exception {
      getParamType();
  }
   /*利用反射获取方法参数的实际参数类型*/
  public static void getParamType() throws NoSuchMethodException{
      Method method = GenericTest.class.getMethod(&quot;applyMap&quot;,Map.class);
      //获取方法的泛型参数的类型
      Type[] types = method.getGenericParameterTypes();
      System.out.println(types[0]);
      //参数化的类型
      ParameterizedType pType  = (ParameterizedType)types[0];
      //原始类型
      System.out.println(pType.getRawType());
      //实际类型参数
      System.out.println(pType.getActualTypeArguments()[0]);
      System.out.println(pType.getActualTypeArguments()[1]);
  }
  /*供测试参数类型的方法*/
  public static void applyMap(Map&lt;Integer,String&gt; map){
  }
}
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>输出结果：</span></pre></td></tr></table></figure>
java.util.Map&lt;java.lang.Integer, java.lang.String&gt;
interface java.util.Map
class java.lang.Integer
class java.lang.String
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>通过反射绕开编译器对泛型的类型限制</span></pre></td></tr></table></figure>
public static void main(String[] args) throws Exception {
  //定义一个包含int的链表
  ArrayList&lt;Integer&gt; al = new ArrayList&lt;Integer&gt;();
  al.add(1);
  al.add(2);
  //获取链表的add方法，注意这里是Object.class，如果写int.class会抛出NoSuchMethodException异常
  Method m = al.getClass().getMethod(&quot;add&quot;, Object.class);
  //调用反射中的add方法加入一个string类型的元素，因为add方法的实际参数是Object
  m.invoke(al, &quot;hello&quot;);
  System.out.println(al.get(2));
}
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">------</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">## <span class="number">5</span> 泛型的限制</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">### <span class="number">5.1</span> 模糊性错误</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- 对于泛型类User&lt;K,V&gt;而言，声明了两个泛型类参数。在类中根据不同的类型参数重载show方法。</span></pre></td></tr></table></figure>
public class User&lt;K, V&gt; {
  public void show(K k) { // 报错信息：&apos;show(K)&apos; clashes with &apos;show(V)&apos;; both methods have same erasure
  }
  public void show(V t) {
  }
}
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">由于泛型擦除，二者本质上都是Obejct类型。方法是一样的，所以编译器会报错。</span></pre></td></tr><tr><td class="code"><pre><span class="line">换一个方式：</span></pre></td></tr></table></figure>
public class User&lt;K, V&gt; {
  public void show(String k) {
  }
  public void show(V t) {
  }
}
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">使用结果：</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">![<span class="string">img</span>](<span class="link">http://image.winrains.cn/2019/08/20190828170342-95a82.png</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">可以正常的使用</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="section">### 5.2 不能实例化类型参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">编译器也不知道该创建那种类型的对象</span></pre></td></tr></table></figure>
public class User&lt;K, V&gt; {
  private K key = new K(); // 报错：Type parameter &apos;K&apos; cannot be instantiated directly
}
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">### <span class="number">5.3</span> 对静态成员的限制</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">静态方法无法访问类上定义的泛型；如果静态方法操作的类型不确定，必须要将泛型定义在方法上。</span></pre></td></tr><tr><td class="code"><pre><span class="line">**如果静态方法要使用泛型的话，必须将静态方法定义成泛型方法**。</span></pre></td></tr></table></figure>
public class User&lt;T&gt; {
  //错误
  private static T t;
  //错误
  public static T getT() {
      return t;
  }
  //正确
  public static &lt;K&gt; void test(K k) {
  }
}
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">### <span class="number">5.4</span> 对泛型数组的限制</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- 不能实例化元素类型为类型参数的数组，但是可以将数组指向类型兼容的数组的引用</span></pre></td></tr></table></figure>
public class User&lt;T&gt; {
  private T[] values;
  public User(T[] values) {
      //错误，不能实例化元素类型为类型参数的数组
      this.values = new T[5];
      //正确，可以将values 指向类型兼容的数组的引用
      this.values = values;
  }
}</code></pre></li>
</ul>
<h3 id="5-5-对泛型异常的限制"><a href="#5-5-对泛型异常的限制" class="headerlink" title="5.5 对泛型异常的限制"></a>5.5 对泛型异常的限制</h3><p>泛型类不能扩展 Throwable，意味着不能创建泛型异常类 <a href="https://link.juejin.im?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F501277%2Fwhy-doesnt-java-allow-generic-subclasses-of-throwable">答案链接</a></p>
<blockquote>
<p>作者：风吹过wu</p>
<p>来源：<a href="https://juejin.im/post/5d64d0f8f265da03a653264e" target="_blank" rel="noopener">https://juejin.im/post/5d64d0f8f265da03a653264e</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring data jpa 的使用与详解（二）：复杂动态查询及分页，排序</title>
    <url>/2019/12/26/Spring-data-jpa-%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%A4%8D%E6%9D%82%E5%8A%A8%E6%80%81%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%88%86%E9%A1%B5%EF%BC%8C%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>上一篇介绍了spring data jpa在spring boot中的基本搭建和整合，以及较为简单的查询，这一篇来说spring data jpa中如何实现较为复杂的查询及分页，排序。</p>
<a id="more"></a>

<h3 id="1-使用Specification实现复杂查询"><a href="#1-使用Specification实现复杂查询" class="headerlink" title="1 使用Specification实现复杂查询"></a>1 使用Specification实现复杂查询</h3><h4 id="1-1-什么是Specification"><a href="#1-1-什么是Specification" class="headerlink" title="1.1 什么是Specification"></a>1.1 什么是Specification</h4><p>Specification是springDateJpa中的一个接口，他是用于当jpa的一些基本CRUD操作的扩展，可以把他理解成一个spring jpa的复杂查询接口。其次我们需要了解Criteria 查询，这是是一种类型安全和更面向对象的查询。而Spring Data JPA支持JPA2.0的Criteria查询，相应的接口是JpaSpecificationExecutor。<br>而JpaSpecificationExecutor这个接口基本是围绕着Specification接口来定义的， Specification接口中只定义了如下一个方法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Predicate <span class="keyword">to</span><span class="constructor">Predicate(Root&lt;T&gt; <span class="params">root</span>, CriteriaQuery&lt;?&gt; <span class="params">query</span>, CriteriaBuilder <span class="params">cb</span>)</span>;</span></pre></td></tr></table></figure>

<p><strong>Criteria查询基本概念</strong><br>Criteria 查询是以元模型的概念为基础的，元模型是为具体持久化单元的受管实体定义的，这些实体可以是实体类，嵌入类或者映射的父类。<br><strong>CriteriaQuery接口</strong><br>代表一个specific的顶层查询对象，它包含着查询的各个部分，比如：select 、from、where、group by、order by等注意：CriteriaQuery对象只对实体类型或嵌入式类型的Criteria查询起作用。<br><strong>Root:</strong><br>代表Criteria查询的根对象，Criteria查询的查询根定义了实体类型，能为将来导航获得想要的结果，它与SQL查询中的FROM子句类似。 Root实例是类型化的，且定义了查询的FROM子句中能够出现的类型。root代表查询的实体类,query可以从中得到root对象,告诉jpa查询哪一个实体类,还可以添加查询条件,还可以结合EntityManager对象 得到最终查询的 TypedQuery对象。 <strong>CriteriaBuilder接口</strong><br>用来构建CritiaQuery的构建器对象Predicate：一个简单或复杂的谓词类型，其实就相当于条件或者是条件组合。 可通过 EntityManager.getCriteriaBuilder 而得。</p>
<h3 id="2-使用Specification进行复杂的动态查询"><a href="#2-使用Specification进行复杂的动态查询" class="headerlink" title="2 使用Specification进行复杂的动态查询"></a>2 使用Specification进行复杂的动态查询</h3><p>maven的依赖继续使用上一章的就可以，这里修改一下实体类和controller层。<br>请求实体类:</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">Data</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class AccountRequest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//从第几页开始</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="built_in">Integer</span> page;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//每一页查询多少</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="built_in">Integer</span> limit;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> pwd;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> email;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="built_in">Integer</span><span class="meta">[</span><span class="meta">]</span> types;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>实体类：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Table</span>(name = <span class="string">"account"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@ToString</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@EntityListeners</span>(AuditingEntityListener.class)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class Account &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Id</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@GenericGenerator</span>(name = <span class="string">"idGenerator"</span>, strategy = <span class="string">"uuid"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@GeneratedValue</span>(generator = <span class="string">"idGenerator"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(name = <span class="string">"username"</span>, unique = true, nullable = false, length = <span class="number">64</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String username;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(name = <span class="string">"password"</span>, nullable = false, length = <span class="number">64</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String password;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(name = <span class="string">"email"</span>, length = <span class="number">64</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String email;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(name = <span class="string">"type"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Short type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@CreatedDate</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(name = <span class="string">"create_time"</span>, nullable = false)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private LocalDateTime createTime;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Repository层：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">AccountRepository</span> <span class="symbol">extends</span> <span class="symbol">JpaRepository</span>&lt;<span class="symbol">Account</span>,<span class="symbol">String</span>&gt;, <span class="symbol">JpaSpecificationExecutor</span>&lt;<span class="symbol">Account</span>&gt; &#123;&#125;</span></pre></td></tr></table></figure>

<p>controller层（还是直接略过service层）</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">private AccountRepository repository;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@PostMapping("/get")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> List&lt;Account&gt; <span class="keyword">get</span>(@RequestBody AccountRequest request) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Specification&lt;Account&gt; specification = <span class="built_in">new</span> Specification&lt;Account&gt;() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">public</span> Predicate toPredicate(Root&lt;Account&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder builder) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            // 所有的断言 及条件</span></pre></td></tr><tr><td class="code"><pre><span class="line">            List&lt;Predicate&gt; predicates = <span class="built_in">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            // 精确匹配id pwd</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (request.getId() != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                predicates.<span class="keyword">add</span>(builder.equal(root.<span class="keyword">get</span>("id"), request.getId()));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (request.getPwd() != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                predicates.<span class="keyword">add</span>(builder.equal(root.<span class="keyword">get</span>("password"), request.getPwd()));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            // 模糊搜索 <span class="type">name</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (request.getName() != <span class="keyword">null</span> &amp;&amp; !request.getName().equals("")) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                predicates.<span class="keyword">add</span>(builder.<span class="keyword">like</span>(root.<span class="keyword">get</span>("username"), "%" + request.getName() + "%"));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (request.getEmail() != <span class="keyword">null</span> &amp;&amp; !request.getEmail().equals("")) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                predicates.<span class="keyword">add</span>(builder.<span class="keyword">like</span>(root.<span class="keyword">get</span>("email"), "%" + request.getEmail() + "%"));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            // <span class="keyword">in</span>范围查询</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (request.getTypes() != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                CriteriaBuilder.<span class="keyword">In</span>&lt;<span class="keyword">Object</span>&gt; <span class="keyword">types</span> = builder.<span class="keyword">in</span>(root.<span class="keyword">get</span>("type"));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> (<span class="type">Integer</span> <span class="keyword">type</span> : request.getTypes()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">types</span> = <span class="keyword">types</span>.<span class="keyword">value</span>(<span class="keyword">type</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                predicates.<span class="keyword">add</span>(<span class="keyword">types</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> builder.<span class="keyword">and</span>(predicates.toArray(<span class="built_in">new</span> Predicate[predicates.size()]));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;Account&gt; accounts = repository.findAll(specification);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> accounts;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过重写Specification的toPredicate的方法，这样一个复杂的动态sql查询就完成了，通过post请求直接就可以调用了。</p>
<h3 id="3-分页及排序"><a href="#3-分页及排序" class="headerlink" title="3 分页及排序"></a>3 分页及排序</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/page"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Account&gt; getPage(<span class="meta">@RequestBody</span> AccountRequest request) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Specification&lt;Account&gt; specification = <span class="keyword">new</span> Specification&lt;Account&gt;() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">public</span> Predicate toPredicate(Root&lt;Account&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                CriteriaBuilder criteriaBuilder) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            List&lt;Predicate&gt; predicates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// do anything</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> criteriaBuilder.and(predicates.toArray(<span class="keyword">new</span> Predicate[predicates.size()]));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 表示通过createTime进行 ASC排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    PageRequest page = <span class="keyword">new</span> PageRequest(request.getPage() - <span class="number">1</span>, request.getLimit(), Sort.Direction.ASC, <span class="string">"createTime"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Page&lt;Account&gt; pageInfo = repository.findAll(specification, page);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">return</span> pageInfo.<span class="title">getContent</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面的代码是在经过复杂查询并进行分页与排序，通过<code>PageRequest</code>来构建分页排序的规则。传入起始页及每页的数量，还有排序的规则及以哪个属性排序。<strong>jpa中是以第0页开始的，所以传参的时候需要注意！</strong><br>当然，如果你不需要进行复杂的查询也可以对数据进行分页及排序查询。<br>修改repository，使其继承<code>PagingAndSortingRepository</code>。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">@Repository</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">AccountRepository</span> <span class="symbol">extends</span> <span class="symbol">JpaRepository</span>&lt;<span class="symbol">Account</span>,<span class="symbol">String</span>&gt;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="symbol">JpaSpecificationExecutor</span>&lt;<span class="symbol">Account</span>&gt; , <span class="symbol">PagingAndSortingRepository</span>&lt;<span class="symbol">Account</span>,<span class="symbol">String</span>&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Page&lt;Account&gt; findByAge(<span class="built_in">int</span> age, Pageable pageable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用时先创建<code>pageable</code>参数，然后传进去就可以了。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示第1页每页显示3条</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">PageRequest pr = <span class="keyword">new</span> <span class="constructor">PageRequest(1,3)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//根据年龄进行查询</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Page&lt;Account&gt; stus = accountPageRepository.find<span class="constructor">ByAge(22,<span class="params">pr</span>)</span>;</span></pre></td></tr></table></figure>

<p>排序也是一样的，在repository中创建方法</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">List</span>&lt;Account&gt; findByPwd(String <span class="keyword">pwd</span>, <span class="keyword">Sort</span> <span class="keyword">sort</span>);</span></pre></td></tr></table></figure>

<p>调用的时候传入sort对象</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置排序方式为username降序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;Account&gt; accs = accountPageRepository.findByAge(<span class="string">"123456"</span>,<span class="keyword">new</span> <span class="keyword">Sort</span>(<span class="keyword">Sort</span>.Direction.DESC,<span class="string">"username"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//设置排序以username和type进行升序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">acc = accountPageRepository.findByAge(<span class="string">"123456"</span>,<span class="keyword">new</span> <span class="keyword">Sort</span>(<span class="keyword">Sort</span>.Direction.ASC,<span class="string">"username"</span>,<span class="string">"type"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//设置排序方式以name升序，以address降序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Sort</span> <span class="keyword">sort</span> = <span class="keyword">new</span> <span class="keyword">Sort</span>(<span class="keyword">new</span> <span class="keyword">Sort</span>.Order(<span class="keyword">Sort</span>.Direction.ASC,<span class="string">"name"</span>),<span class="keyword">new</span> <span class="keyword">Sort</span>.Order(<span class="keyword">Sort</span>.Direction.DESC,<span class="string">"type"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">accs = accountPageRepository.findByAge(<span class="string">"123456"</span>,<span class="keyword">sort</span>);</span></pre></td></tr></table></figure>

<blockquote>
<p>作者：爱西考的王同学</p>
<p>来源：<a href="https://juejin.im/post/5d64f70fe51d4561fa2ec09c" target="_blank" rel="noopener">https://juejin.im/post/5d64f70fe51d4561fa2ec09c</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
      </categories>
      <tags>
        <tag>Spring Data JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring data jpa 的使用与详解（一）：框架整合及基本使用</title>
    <url>/2019/12/26/Spring-data-jpa-%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%8F%8A%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1-什么是JPA"><a href="#1-什么是JPA" class="headerlink" title="1 什么是JPA"></a>1 什么是JPA</h3><p>JPA全称Java Persistence API，可以通过注解或者XML描述【对象-关系表】之间的映射关系，并将实体对象持久化到数据库中。JPA的出现主要是为了简化持久层开发以及整合ORM技术，结束Hibernate、TopLink、JDO等ORM框架各自为营的局面。<br>JAP为我们提供了<strong>ORM映射元数据</strong>,<strong>JPA的API</strong>,<strong>JPQL查询语言</strong>等,但JPA仅仅是一种规范，<strong>也就是说JPA仅仅定义了一些接口</strong>，而接口是需要实现才能工作的。所以底层需要某种实现，而Hibernate就是实现了JPA接口的ORM框架。</p>
<a id="more"></a>

<h3 id="2-什么是Hibernate框架"><a href="#2-什么是Hibernate框架" class="headerlink" title="2 什么是Hibernate框架"></a>2 <strong>什么是Hibernate框架</strong></h3><p>Hibernate是Java中的对象关系映射解决方案。对象关系映射或ORM是将应用程序域模型对象映射到关系数据库表的编程技术。Hibernate是一个基于Java的ORM工具，它提供了一个框架，用于将应用程序域对象映射到关系数据库表。<br>Hibernate提供了Java Persistence API的参考实现，使其成为具有松散耦合优势的ORM工具的绝佳选择。</p>
<h3 id="3-什么是Spring-Data-JPA"><a href="#3-什么是Spring-Data-JPA" class="headerlink" title="3 什么是Spring Data JPA"></a>3 什么是Spring Data JPA</h3><p>Spring Data是Spring Framework的一部分。Spring Data存储库抽象的目标是显著减少为各种持久性存储实现数据访问层所需的代码量。<br>Spring Data JPA不是JPA提供者。它是一个库/框架，它在我们的JPA提供程序（如Hibernate）的顶部添加了一个额外的抽象层。</p>
<h3 id="4-Hibernate和Spring-Data-JPA的关系"><a href="#4-Hibernate和Spring-Data-JPA的关系" class="headerlink" title="4 Hibernate和Spring Data JPA的关系"></a>4 Hibernate和Spring Data JPA的关系</h3><p>Hibernate是一个JPA实现，而Spring Data JPA是一个JPA数据访问抽象。Spring Data提供了GenericDao自定义实现的解决方案，它还可以通过方法名称约定代表您生成JPA查询。<br>Spring Data JPA不是一个实现或JPA提供者，它只是一个抽象，用于显著减少为各种持久性存储实现数据访问层所需的代码量。Spring Data JPA始终需要JPA提供程序，如Hibernate。</p>
<p><img src="http://image.winrains.cn/2019/08/20190828172848-a1ae9.png" alt="img"></p>
<h3 id="5-Spring-data-jpa概述"><a href="#5-Spring-data-jpa概述" class="headerlink" title="5 Spring data jpa概述"></a>5 Spring data jpa概述</h3><p>JPA Spring Data：致力于减少数据访问层（DAO）的开发量，开发者唯一要做的，就只是声明持久层的接口，其他都交给Spring Data JPA来完成。<br>框架怎么可能代替开发者实现业务逻辑呢？比如：当有一个 UserDao.findUserById() 这样一个方法声明，大致应该能判断出这是根据给定条件的 ID 查询出满足条件的 User 对象。Spring Data JPA 做的便是规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</p>
<h3 id="5-Spring-data-JPA使用"><a href="#5-Spring-data-JPA使用" class="headerlink" title="5 Spring data JPA使用"></a>5 Spring data JPA使用</h3><h4 id="5-1-jar包引入"><a href="#5-1-jar包引入" class="headerlink" title="5.1 jar包引入"></a>5.1 jar包引入</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure>

<h4 id="5-2-Spring-data-jpa配置"><a href="#5-2-Spring-data-jpa配置" class="headerlink" title="5.2 Spring data jpa配置"></a>5.2 Spring data jpa配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 借助spring data实现自动化的jpa repository，只需编写接口无需编写实现类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于xml配置的&lt;jpa:repositories base-package="com.example.repository" /&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// repositoryImplementationPostfix默认就是Impl</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// entityManagerFactoryRef默认就是entityManagerFactory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// transactionManagerRef默认就是transactionManager</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@EnableJpaRepositories</span>(basePackages = &#123;<span class="string">"com.wtj.repository"</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        repositoryImplementationPostfix = <span class="string">"Impl"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        entityManagerFactoryRef = <span class="string">"entityManagerFactory"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        transactionManagerRef = <span class="string">"transactionManager"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 启用事务管理器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//审计功能 用来自动填充@CreateDate等</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@EnableJpaAuditing</span>(dateTimeProviderRef = <span class="string">"dateTimeProvider"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDataJpaConfig</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> DateTimeProvider <span class="title">dateTimeProvider</span><span class="params">(DateTimeService dateTimeService)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> dateTimeService::getNow;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> JpaVendorAdapter <span class="title">jpaVendorAdapter</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        HibernateJpaVendorAdapter jpaVendorAdapter = <span class="keyword">new</span> HibernateJpaVendorAdapter();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 设置数据库类型（可使用org.springframework.orm.jpa.vendor包下的Database枚举类）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        jpaVendorAdapter.setDatabase(Database.MYSQL);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 设置打印sql语句</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        jpaVendorAdapter.setShowSql(<span class="keyword">true</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 设置不生成ddl语句</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        jpaVendorAdapter.setGenerateDdl(<span class="keyword">false</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 设置hibernate方言</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        jpaVendorAdapter.setDatabasePlatform(<span class="string">"org.hibernate.dialect.MySQL5Dialect"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> jpaVendorAdapter;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 配置实体管理器工厂</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactory</span><span class="params">(</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">            DataSource dataSource, JpaVendorAdapter jpaVendorAdapter)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        LocalContainerEntityManagerFactoryBean emfb = <span class="keyword">new</span> LocalContainerEntityManagerFactoryBean();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 注入数据源</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        emfb.setDataSource(dataSource);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 注入jpa厂商适配器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        emfb.setJpaVendorAdapter(jpaVendorAdapter);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 设置扫描基本包</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        emfb.setPackagesToScan(<span class="string">"com.wtj.entity"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> emfb;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 配置jpa事务管理器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">(EntityManagerFactory emf)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        JpaTransactionManager transactionManager = <span class="keyword">new</span> JpaTransactionManager();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 配置实体管理器工厂</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        transactionManager.setEntityManagerFactory(emf);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> transactionManager;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>启用web支持还需要在Spring MVC配置类上添加<code>@EnableSpringDataWebSupport</code>注解</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@ComponentScan</span>(basePackages = &#123;<span class="string">"com.wtj.controller"</span>&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@EnableWebMvc</span>   <span class="comment">// 启用spring mvc</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@EnableSpringDataWebSupport</span>     <span class="comment">// 启用springmvc对spring data的支持</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class WebMvcConfig extends WebMvcConfigurerAdapter &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">server</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">port</span>: <span class="number">20000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">servlet</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">context-path</span>: /</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attribute">spring</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">datasource</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">url</span>: <span class="attribute">jdbc</span>:<span class="attribute">mysql</span>:<span class="comment">//localhost:3306/mytest1?useUnicode=true&amp;serverTimezone=UTC&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;allowMultiQueries=true&amp;useSSL=false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">username</span>: root</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">password</span>: root</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">jpa</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">database</span>: MySQL</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">database-platform</span>: org.hibernate.dialect.MySQL5InnoDBDialect</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">show-sql</span>: true</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">hibernate</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attribute">ddl-auto</span>: update</span></pre></td></tr></table></figure>

<blockquote>
<p>ddl-auto 解释：</p>
</blockquote>
<ul>
<li>create : 每次运行程序时，都会重新创建表，故而数据会丢失。</li>
<li>create-drop：每次运行程序时会先创建表结构，然后待程序结束时清空表。</li>
<li>upadte：每次运行程序，没有表时会创建表，如果对象发生改变会更新表结构，原有数据不会清空，只会更新（推荐使用）。</li>
<li>validate：运行程序会校验数据与数据库的字段类型是否相同，字段不同会报错。</li>
<li>none: 禁用DDL处理。</li>
</ul>
<h4 id="5-3-简单的Spring-dat-jpa例子"><a href="#5-3-简单的Spring-dat-jpa例子" class="headerlink" title="5.3 简单的Spring dat jpa例子"></a>5.3 简单的Spring dat jpa例子</h4><p>例子简单就不写service层了，直接在controller中调用。<br><strong>创建实体类</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Table</span>(name = <span class="string">"account"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@ToString</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class Account &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Id</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@GenericGenerator</span>(name = <span class="string">"idGenerator"</span>, strategy = <span class="string">"uuid"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@GeneratedValue</span>(generator = <span class="string">"idGenerator"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(name = <span class="string">"username"</span>, unique = true, nullable = false, length = <span class="number">64</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String username;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(name = <span class="string">"password"</span>, nullable = false, length = <span class="number">64</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String password;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(name = <span class="string">"email"</span>, length = <span class="number">64</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String email;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>主键采用UUID策略 <code>@GenericGenerator</code>是Hibernate提供的主键生成策略注解，注意下面的<code>@GeneratedValue</code>（JPA注解）使用generator = “idGenerator”引用了上面的name = “idGenerator”主键生成策略。</p>
</blockquote>
<blockquote>
<p><strong>JPA自带的几种主键生成策略</strong><br>TABLE： 使用一个特定的数据库表格来保存主键。<br>SEQUENCE： 根据底层数据库的序列来生成主键，条件是数据库支持序列。这个值要与generator一起使用，generator 指定生成主键使用的生成器（可能是orcale中自己编写的序列）。<br>IDENTITY： 主键由数据库自动生成（主要是支持自动增长的数据库，如mysql）。<br>AUTO： 主键由程序控制，也是GenerationType的默认值。</p>
</blockquote>
<p><strong>dao层</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">@Repository</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">AccountRepository</span> <span class="symbol">extends</span> <span class="symbol">JpaRepository</span>&lt;<span class="symbol">Account</span>,<span class="symbol">String</span>&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>controller层</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = <span class="meta-string">"/role"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> AccountRepository repository;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@PostMapping()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> Account save(<span class="meta">@RequestBody</span> Account account) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> repository.save(account);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@DeleteMapping(<span class="meta-string">"/&#123;id&#125;"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> void delete(<span class="meta">@PathVariable(<span class="meta-string">"id"</span>)</span> String accountId) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        repository.deleteById(accountId);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@PutMapping(<span class="meta-string">"/&#123;id&#125;"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> Account update(<span class="meta">@PathVariable(<span class="meta-string">"id"</span>)</span> String accountId, <span class="meta">@RequestBody</span> Account account) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        account.setId(accountId);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> repository.saveAndFlush(account);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@GetMapping(<span class="meta-string">"/&#123;id&#125;"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> Account getAccountInfo(<span class="meta">@PathVariable(<span class="meta-string">"id"</span>)</span> String accountId) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Optional&lt;Account&gt; optional = repository.findById(accountId);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> optional.orElseGet(Account::new);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>最后在数据库中造几条假数据进行crud就可以了。</p>
<h4 id="5-4-Repository接口"><a href="#5-4-Repository接口" class="headerlink" title="5.4 Repository接口"></a>5.4 Repository接口</h4><p><strong>Repository 接口概述:</strong></p>
<ol>
<li>Repository 接口是 Spring Data 的一个核心接口，它不提供任何方法，是一个空接口，即是一个标记接口。开发者需要在自己定义的接口中声明需要的方法 。</li>
</ol>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Repository&lt;T, ID extends Serializable&gt; &#123; &#125;</span></pre></td></tr></table></figure>

<ol>
<li>Spring Data可以让我们只定义接口，只要遵循Spring Data的规范，就无需写实现类。</li>
<li>若我们定义的接口继承了Repository，则该接口会被IOC容器识别为一个Repository Bean，纳入到IOC容器中，进而可以在该接口中定义满足一定规范的方法。实际上在IOC容器中放的是该接口的实现类，只不过spring帮我们实现了，实际上它是一个代理。</li>
<li>与继承 Repository 等价的一种方式，就是在持久层接口上使用 @RepositoryDefinition 注解，并为其指定 domainClass 和 idClass 属性，指定对象和主键类型。</li>
</ol>
<p><strong>Repository 的子接口:</strong><br>基础的 Repository提供了最基本的数据访问功能，其几个子接口则扩展了一些功能。它们的继承关系如下：</p>
<ul>
<li>Repository：仅仅是一个标识，表明任何继承它的均为仓库接口类.</li>
<li>CrudRepository：继承Repository，实现了一组CRUD相关的方法.</li>
<li>PagingAndSortingRepository： 继承 CrudRepository，实现了一组分页排序相关的方法.</li>
<li>JpaRepository：继承PagingAndSortingRepository，实现一组JPA规范相关的方法.</li>
<li>自定义的 XxxxRepository 需要继承 JpaRepository，这样的XxxxRepository接口就具备了通用的数据访问控制层的能力.</li>
<li>JpaSpecificationExecutor：不属于Repository体系，实现一组JPACriteria 查询相关的方法.</li>
</ul>
<h4 id="5-5-自定义条件查询语句"><a href="#5-5-自定义条件查询语句" class="headerlink" title="5.5 自定义条件查询语句"></a>5.5 自定义条件查询语句</h4><p>按照 Spring Data的规范，查询方法以<code>find | read | get</code> 开头，涉及条件查询时，条件的属性用条件关键字连接，要注意的是：条件属性以首字母大写。 比如说现在要按照account的名称进行查询：<br>在AccountRepository接口中新增方法</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">@Repository</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">AccountRepository</span> <span class="symbol">extends</span> <span class="symbol">JpaRepository</span>&lt;<span class="symbol">Account</span>,<span class="symbol">String</span>&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Account findAccountByUsername(String username);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>controller中新增方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(<span class="meta-string">"/name/&#123;username&#125;"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Account getAccountByName(<span class="meta">@PathVariable(<span class="meta-string">"username"</span>)</span> String userName) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Account account = repository.findAccountByUsername(userName);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> account;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这样就可以根据名称进行查询了，当然你也可以使用这种方法进行复杂查询，spring data jpa中支持的关键字如下：</p>
<p><img src="http://image.winrains.cn/2019/08/20190828172850-cb242.png" alt="img"></p>
<p><img src="http://image.winrains.cn/2019/08/20190828172850-a36d8.png" alt="img"></p>
<h4 id="5-6-自定义sql语句"><a href="#5-6-自定义sql语句" class="headerlink" title="5.6 自定义sql语句"></a>5.6 自定义sql语句</h4><p>有些时候spring data jpa提供的查询条件满足不了业务需求的时候，可以使用自定义的sql来进行查询。<br>想要使用自定义sql需要使用<code>@Query</code>注解，@Query注解使用起来很简单，默认的属性是value，就是当前写的SQL语句，有时会用到nativeQuery属性，这个属性是用来标记当前的SQL是本地SQL，还是符合JPA语法规范的SQL。这里需要解释一下本地SQL和JPA语法规范的SQL区别。</p>
<ul>
<li>本地SQL，是根据实际使用的数据库类型写的SQL，这种SQL中使用到的一些语法格式不能被JPA解析以及可能不兼容其他数据库，这种SQL称为本地SQL，此时需要将nativeQuery属性设置为true，否则会报错。</li>
<li>JPA语法规范的SQL，往往这种SQL本身是不适用于任何数据库的，需要JPA将这种SQL转换成真正当前数据库所需要的SQL语法格式。</li>
</ul>
<blockquote>
<p>JPA很好的一个特性就是用JPA语法规范写的SQL，会根据当前系统使用的数据库类型改变生成的SQL语法，兼容数据库类型的切换，如之前使用的是MySQL，现在换成Oracle，由于不同类型的数据库，SQL语法会有区别，如果使用的是mybatis，就需要手动去改SQL兼容Oracle，而JPA就不用啦，无缝对接。<br>很大的时候使用JPA感觉都是为了兼容后期可能会有数据库切换的问题，所以在使用JPA的时候，不要去使用本地SQL，这就违背了使用JPA的初衷，让nativeQuery属性保持默认值就可以啦！</p>
</blockquote>
<p>AccountRepository中新增方法</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Query</span>(<span class="string">"select a from Account a where a.username = :username"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Account findAccountByName(<span class="variable">@Param</span>(<span class="string">"username"</span>)String name);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Query</span>(<span class="string">"select a from Account a where a.email = ?1"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Account findAccountByEmail(String email);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Query</span>(value = <span class="string">"select * from account where username = ?1"</span>,nativeQuery = true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Account getAccount(String username);</span></pre></td></tr></table></figure>

<ul>
<li>在SQL上使用占位符的两种方式，第一种是使用”:”后加变量的名称，第二种是使用”?”后加方法参数的位置。如果使用”:”的话，需要使用@Param注解来指定变量名；如果使用”?”就需要注意参数的位置。</li>
<li>使用JPA语句中SQL语句中直接用实体类代表表名，因为在实体类中使用了@Table注解，将该实体类和表进行了关联。 controller中新增方法（方法名还有url起的都比较随意。。。。。）</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(<span class="meta-string">"/sql/&#123;username&#125;"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Account findAccountByName(<span class="meta">@PathVariable(<span class="meta-string">"username"</span>)</span> String userName)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Account account = repository.findAccountByName(userName);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> account;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(<span class="meta-string">"/email/&#123;email&#125;"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Account findAccountByEmail(<span class="meta">@PathVariable(<span class="meta-string">"email"</span>)</span> String email)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Account account = repository.findAccountByEmail(email);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> account;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(<span class="meta-string">"/username/&#123;username&#125;"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Account getAccount(<span class="meta">@PathVariable(<span class="meta-string">"username"</span>)</span> String username)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Account account = repository.getAccount(username);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> account;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>最后通过请求就可以获得数据并且在控制台可以看到打印出的响应的sql。<br>当自定义sql涉及到删除，修改，插入的操作的时候需要加上<code>@Modifying</code>注解。注明当前方法是修改操作。</p>
<blockquote>
<p>作者：爱西考的王同学</p>
<p>来源：<a href="https://juejin.im/post/5d5ba7bae51d453b1e478ac5" target="_blank" rel="noopener">https://juejin.im/post/5d5ba7bae51d453b1e478ac5</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring Data JPA</category>
      </categories>
  </entry>
  <entry>
    <title>业务架构、应用架构与云基础架构</title>
    <url>/2019/12/26/%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84%E3%80%81%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E4%B8%8E%E4%BA%91%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<blockquote>
<p>本部分节选自《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-se.gitbook.io%2Fi%2F%3Fq%3D%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84">软件架构设计</a>》</p>
</blockquote>
<p>软件开发就是把一个复杂的问题分解为一系列简单的问题，再把一系列简单的解决方案组合成一个复杂的解决方案。而软件开发中最大的挑战，就是即能够快速高效地针对需求、环境的变化做出改变，也能够持续提供稳定、高可用的服务。而软件架构，就是软件系统的骨骼与框架。<br>所谓架构，见仁见智，很难有一个明确或标准的定义；但架构并非镜花水月或阳春白雪，有系统的地方就需要架构，大到航空飞机，小到一个电商系统里面的一个功能组件，都需要设计和架构。抽象而言，架构就是对系统中的实体以及实体之间的关系所进行的抽象描述，是对物/信息的功能与形式元素之间的对应情况所做的分配，是对元素之间的关系以及元素同周边环境之间的关系所做的定义。架构能将目标系统按某个原则进行切分，切分的原则，是要便于不同的角色进行并行工作，结构良好的创造活动要优于毫无结构的创造活动。</p>
<a id="more"></a>

<p><strong>软件架构的核心价值，即是控制系统的复杂性，将核心业务逻辑和技术细节的分离与解耦</strong>。软件架构是系统的草图，它描述的对象是直接构成系统的抽象组件；各个组件之间的连接则明确和相对细致地描述组件之间的通信。在实现阶段，这些抽象组件被细化为实际的组件，比如具体某个类或者对象。在面向对象领域中，组件之间的连接通常用接口来实现。架构师的职责是努力训练自己的思维，用它去理解复杂的系统，通过合理的分解和抽象，理解并解析需求，创建有用的模型，确认、细化并扩展模型，管理架构；能够进行系统分解形成整体架构，能够正确的技术选型，能够制定技术规格说明并有效推动实施落地。</p>
<h1 id="软件架构分类"><a href="#软件架构分类" class="headerlink" title="软件架构分类"></a>软件架构分类</h1><p>在笔者的知识体系中，实际上将架构分为业务架构、应用架构、云基础架构这几大类，业务架构主要着眼于控制业务的复杂性，基础架构着眼于解决分布式系统中存在的一系列问题。无论何种架构，都希望能实现系统的可变的同时保障业务的高可用。另一个层面，根据企业中职责的划分，我们往往可以将软件架构，及关联的架构师划分为以下几类：</p>
<ul>
<li>业务架构/解决方案架构：核心是解决业务带来的系统复杂性，了解客户/业务方的痛点，项目定义，现有环境；梳理高阶需求和非功能性需求，进行问题域划分与领域建模等工作；沟通，方案建议，多次迭代，交付总体架构。</li>
<li>应用架构：根据业务场景的需要，设计应用的层次结构，制定应用规范、定义接口和数据交互协议等。并尽量将应用的复杂度控制在一个可以接受的水平，从而在快速的支撑业务发展的同时，在保证系统的可用性和可维护性的同时，确保应用满足非功能属性要求（性能、安全、稳定性等）。</li>
<li>数据架构：专注于构建数据中台，统一数据定义规范，标准化数据表达，形成有效易维护的数据资产。打造统一的大数据处理平台，包括数据可视化运营平台、数据共享平台、数据权限管理平台等。</li>
<li>中间件架构：专注于中间件系统的构建，需要解决服务器负载，分布式服务的注册和发现，消息系统，缓存系统，分布式数据库等问题，同时架构师要在 CAP 之间进行权衡。</li>
<li>运维架构：负责运维系统的规划、选型、部署上线，建立规范化的运维体系。</li>
<li>物理架构：物理架构关注软件元件是如何放到硬件上的，专注于基础设施，某种软硬件体系，甚至云平台，包括机房搭建、网络拓扑结构，网络分流器、代理服务器、Web 服务器、应用服务器、报表服务器、整合服务器、存储服务器和主机等。</li>
</ul>
<h2 id="架构模式与架构风格"><a href="#架构模式与架构风格" class="headerlink" title="架构模式与架构风格"></a>架构模式与架构风格</h2><p>软件架构设计的一个核心问题是能否使用重复的架构模式，即能否达到架构级的软件重用。也就是说，能否在不同的软件系统中，使用同一架构。当我们讨论软件架构时，常常会提及软件架构模式（Architectural Pattern）与软件架构风格（Architectural Style）。<br>软件架构模式往往会用于具体地解决某个具体的重复的架构问题，而架构风格则是对于某个具体的架构设计方案的命名。软件架构风格是描述某一特定应用领域中系统组织方式的惯用模式；架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效组织成一个完整的系统。<br>在笔者的系列文章中，CRUD、分层架构、六边形架构、洋葱架构、REST 以及 DDD，都算是架构风格；而 CQRS、EDA、UDLA、微服务等则被划分到架构模式中。</p>
<h2 id="系统复杂性的来源与应对"><a href="#系统复杂性的来源与应对" class="headerlink" title="系统复杂性的来源与应对"></a>系统复杂性的来源与应对</h2><p>在软件开发中，程序员往往能够脱离现实规律的束缚，创造出天马行空的世界，其也是最具有创造力的活动之一。编程唯一需要的是创造力思维和思维组织能力，这意味着在软件开发过程中最大限制是理解我们正在创建的对象。随着软件的演进，加入更多的功能点，系统变得越来越复杂：各个模块（Module）间存在着各种微妙的依赖关系。系统的复杂性随着时间积累，对于程序员来说，修改系统时考虑周全所有的的相关因素变得越来越困难。这就会使软件开放进度变缓慢，并且引入 Bug，而导致会进一步延缓开发进度，增加开发成本。在任何一个系统的生命周期中，复杂性不可避免会增加；系统越大，需要更多的人开发，管理系统复杂性的工作就越困难。<br>Eric Evans 在 Domain‐Driven Design 一书中吐槽了所谓的意大利面式架构，即代码确实做了有用的事，但很难解释它是如何去执行的；他认为造成这种窘境的主要原因是，将领域问题的复杂度与技术细节的复杂度混合在了一起，最终导致整体复杂度的指数级增长。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084125-e6d37.png" alt="img"></p>
<p>复杂性不是凭空而来，很多时候也不是刻意为之，这也就意味着复杂性的增加往往不会以我们的主观意志为转移。就像房间里的大象，我们无法逃避，也不能视而不见。复杂性的来源可能是：</p>
<ul>
<li>吸积与持续迭代：增量式设计意味着软件设计永不结束，设计在系统的生命周期中持续发生，程序员要时刻考虑设计问题。增量开发也意味着持续重构。一个系统的初始设计几乎从来都不是最好的方案。随着经验的增加，必然会发现更好的设计方案。</li>
<li>交互且无扩展性设计：当吸积效应导致的大规模系统，结合了交互这个特性，会使技术系统更加复杂。一个技术系统除了作用于自身，还会与其它大量系统产生交互。比如下单购买一件商品，那么订单系统，商品系统，支付系统，物流系统，卡券系统就会交互协作。这样吸积的复杂性，由于交互特性的出现，会呈现几何级数上升。</li>
<li>不合理的业务封装：不合理的业务封装是一个相对宽泛的概念，其具体的表现譬如面向过程而不是对象、分层不合理等。</li>
<li>缺乏统一语言：典型的敏捷开发的结构，流水线上的各个角色往往会专注于自己负责的环节，精细化的分工也限制了每个角色的全局视角；虽然我们经常提倡所谓的主人翁意识，但是在落地时又很难去推进。</li>
<li>缺乏约束与规范：在团队协作开发的背景下，缺少规范和约束会严重损害架构的一致性（Consistency），代码的可维护性将急剧下降。可能规范在实现层面就是命名、分包等不影响代码运行的小问题，但是千里之堤，溃于蚁穴，正是这些微末的不注意导致了整体复杂性的雪崩。</li>
</ul>
<p>复杂性的应对永远不会是一劳永逸，我们需要不断地推陈出新，是动态、渐进的重塑自己对软件系统的认识，不断认识问题和寻找更优解的持续迭代。第一个控制复杂性的途径是代码简单，意图清晰（Obvious）。例如: 减少特殊场景的处理，或变量命名一致性都能降低系统复杂性。另一种方式就是对复杂问题的抽象然后分而治之。</p>
<h2 id="领域驱动设计"><a href="#领域驱动设计" class="headerlink" title="领域驱动设计"></a>领域驱动设计</h2><p><img src="http://image.winrains.cn/2019/08/20190829084126-4077f.png" alt="领域驱动设计"></p>
<blockquote>
<p>本部分节选自《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-se.gitbook.io%2Fi%2F%3Fq%3D%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1">领域驱动设计</a>》</p>
</blockquote>
<p>DDD 领域驱动设计，起源于 2004 年著名建模专家 Eric Evans 发表的他最具影响力的著名书籍：《Domain-Driven Design – Tackling Complexity in the Heart of Software》，Eric Evans 在该书中只是提供了一套原始理论，并没有提供一套方法论，因此多年来对于 DDD 也是见仁见智。更早些时候 MartinFowler 曾经提出贫血模型与充血模型的概念，他认为我们大多数系统以 POJO 作为模型，只有普通的 getter、setter 方法，没有真正的行为，好像缺少血液的人，在 Evans 看来，DDD 中模型都是以充血形式存在，也就是说在 DDD 中，我们设计的模型不仅包含描述业务属性，还要包含能够描述动作的方法，不同的是，领域中一些概念不能用在模型对象，如仓储、工厂、服务等，如强加于模型中，将破坏模型的定义。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084126-3a049.png" alt="领域驱动设计架构"></p>
<p>领域驱动设计的战略核心即是将问题域与应用架构相剥离，将业务语义显现化，把原先晦涩难懂的业务算法逻辑，通过领域对象（Domain Object），统一语言（Ubiquitous Language）转化为领域概念清晰的显性化表达出来。</p>
<ul>
<li>统一语言，软件的开发人员/使用人员都使用同一套语言，即对某个概念，名词的认知是统一的，建立清晰的业务模型，形成统一的业务语义。将模型作为语言的支柱。确保团队在内部的所有交流中，代码中，画图，写东西，特别是讲话的时候都要使用这种语言。例如账号，转账，透支策略，这些都是非常重要的领域概念，如果这些命名都和我们日常讨论以及 PRD 中的描述保持一致，将会极大提升代码的可读性，减少认知成本。。比如不再会有人在会议中对“工单”、“审核单”、“表单”而反复确认含义了，DDD 的模型建立不会被 DB 所绑架。</li>
<li>面向领域，业务语义显性化，以领域去思考问题，而不是模块。将隐式的业务逻辑从一推 if-else 里面抽取出来，用通用语言去命名、去写代码、去扩展，让其变成显示概念；很多重要的业务概念，按照事务脚本的写法，其含义完全淹没在代码逻辑中没有突显出来。</li>
<li>职责划分，根据实际业务合理划分模型，模型之间依赖结构和边界更加清晰，避免了混乱的依赖关系，进而增加可读性、可维护性；单一职责，模型只关注自身的本职工作，避免“越权”而导致混乱的调用关系。通过建模，更好的表达现实世界中的复杂业务，随着时间的发展，不断增加系统对实际业务的沉淀，也将更好的通过清晰的代码描述业务逻辑，模型的内聚增加了系统的高度模块化，提升代码的可重用性，对比传统三层模式中，很有可能大量重复的功能散落在各个 Service 内部。</li>
</ul>
<h1 id="微服务与云原生架构"><a href="#微服务与云原生架构" class="headerlink" title="微服务与云原生架构"></a>微服务与云原生架构</h1><blockquote>
<p>本部分节选自《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-be.gitbook.io%2Fi%2F%3Fq%3D%E5%BE%AE%E6%9C%8D%E5%8A%A1">微服务与云原生</a>》</p>
</blockquote>
<p><img src="http://image.winrains.cn/2019/08/20190829084127-4ff85.png" alt="服务衍化"></p>
<h2 id="单体分层架构"><a href="#单体分层架构" class="headerlink" title="单体分层架构"></a>单体分层架构</h2><p>在 Web 应用程序发展的早期，大部分工程是将所有的服务端功能模块打包到单个巨石型（Monolith）应用中，譬如很多企业的 Java 应用程序打包为 war 包，最终会形成如下的架构：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084128-a1f71.png" alt="img"></p>
<p>巨石型应用易于搭建开发环境、易于测试、易于部署；其缺陷也非常明显，无法进行局部改动与部署，编译时间过长，回归测试周期过长，开发效率降低等。集中式架构分为标准的三层：数据访问层、服务层和 Web 层。<br>在 Web2.0 时代刚刚流行的时候，互联网应用与企业级应用并没有本质的区别，集中式架构分为标准的三层：数据访问层、服务层和 Web 层。</p>
<ul>
<li>数据访问层用于定义数据访问接口，实现对真实数据库的访问；</li>
<li>服务层用于对应用业务逻辑进行处理；</li>
<li>Web 层用于处理异常、逻辑跳转控制、页面渲染模板等。</li>
</ul>
<h2 id="SOA-面向服务架构"><a href="#SOA-面向服务架构" class="headerlink" title="SOA 面向服务架构"></a>SOA 面向服务架构</h2><p>SOA（Service-Oriented Architecture） 面向服务架构，是在互联网应用规模迅速增长，集中式架构已无法做到无限制地提升系统的吞吐量的背景下，产生的涉及模块化开发、分布式扩展部署等相对宽泛的概念。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084128-ec735.png" alt="img"></p>
<p>SOA 是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。SOA 中的接口独立于实现服务的硬件平台、操作系统和编程语言，采用中立的方式进行定义。这使得构建在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。面向服务架构，它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用。服务层是 SOA 的基础，可以直接被应用调用，从而有效控制系统中与软件代理交互的人为依赖性。<br>实施 SOA 的关键目标是实现企业 IT 资产的最大化作用。要实现这一目标，就要在实施 SOA 的过程中牢记以下特征：可从企业外部访问、随时可用、粗粒度的服务接口分级、松散耦合、可重用的服务、服务接口设计管理、标准化的服务接口、支持各种消息模式、精确定义的服务契约。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084129-6d44b.png" alt="img"></p>
<p>服务消费者（Service Consumer）可以通过发送消息来调用服务，这些消息由一个服务总线（Service Bus）转换后发送给适当的服务实现。这种服务架构可以提供一个业务规则引（Business Rules Engine），该引擎容许业务规则被合并在一个服务里或多个服务里。这种架构也提供了一个服务管理基础（Service Management Infrastructure），用来管理服务，类似审核，列表（billing），日志等功能。此外，该架构给企业提供了灵活的业务流程，更好地处理控制请求（Regulatory Requirement），例如 Sarbanes Oxley（SOX），并且可以在不影响其他服务的情况下更改某项服务。<br>由于分布式系统十分复杂，因此产生了大量的用于简化分布式系统开发的分布式中间件和分布式数据库，服务化的架构设计理念也被越来越多的公司所认同。如下是 Dubbo 官方文档公布了一张有关 SOA 系统演化过程的图片：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084130-c028a.jpeg" alt="img"></p>
<h2 id="MSA-微服务架构"><a href="#MSA-微服务架构" class="headerlink" title="MSA 微服务架构"></a>MSA 微服务架构</h2><p>微服务（Microservices Architecture Pattern）由 Martin Fowler 在 2014 年提出的，是希望将某个单一的单体应用，转化为多个可以独立运行、独立开发、独立部署、独立维护的服务或者应用的聚合，从而满足业务快速变化及分布式多团队并行开发的需求。如康威定律（Conway’s Law）所言，任何组织在设计一套系统（广义概念）时，所交付的设计方案在结构上都与该组织的通信结构保持一致，微服务与微前端不仅仅是技术架构的变化，还包含了组织方式、沟通方式的变化。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084131-24bd9.png" alt="img"></p>
<p>对于微服务，不同背景的人也有不同的见解，对于熟悉 SOA 的开发者，微服务也可以认为是去除了 ESB 的 SOA 的一种实现方案；ESB 是 SOA 架构中的中心总线，设计图形应该是星形的，而微服务是去中心化的分布式软件架构。SOA 更多强调重用，而微服务偏向于重写。SOA 偏向水平服务，微服务偏向垂直服务；SOA 偏向自上而下的设计，微服务偏向自下而上的设计。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084132-c149e.png" alt="img"></p>
<p>微服务与微前端原理和软件工程，面向对象设计中的原理同样相通，都是遵循单一职责(Single Responsibility)、关注分离(Separation of Concerns)、模块化(Modularity)与分而治之(Divide &amp; Conquer)等基本的原则。从巨石型应用到微服务的衍化也并非一蹴而就，如下图也演示了简单的渐进式替代过程：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084133-bd151.png" alt="img"></p>
<p><img src="http://image.winrains.cn/2019/08/20190829084134-1dc20.png" alt="img"></p>
<h2 id="Cloud-Native-云原生架构"><a href="#Cloud-Native-云原生架构" class="headerlink" title="Cloud Native 云原生架构"></a>Cloud Native 云原生架构</h2><blockquote>
<p>云原生是通过构建团队、文化和技术，利用自动化和架构来管理系统的复杂性和解放生产力。 — Joe Beda，Heotio CTO，联合创始人</p>
</blockquote>
<p><img src="http://image.winrains.cn/2019/08/20190829084136-e1caf.png" alt="img"></p>
<p>Pivotal 是云原生应用的提出者，并推出了 Pivotal Cloud Foundry 云原生应用平台和 Spring 开源 Java 开发框架，成为云原生应用架构中先驱者和探路者。早在 2015 年 Pivotal 公司的 Matt Stine 写了一本叫做迁移到云原生应用架构的小册子，其中探讨了云原生应用架构的几个主要特征：符合 12 Factors 应用、面向微服务架构、自服务敏捷架构、基于 API 的协作以及抗脆弱性。2015 年 Google 主导成立了云原生计算基金会（CNCF），起初 CNCF 对云原生（Cloud Native）的定义包含以下三个方面：应用容器化、面向微服务架构、应用支持容器的编排调度。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084137-d09a8.png" alt="img"></p>
<p>云原生应用程序简单地定义为从头开始为云计算架构而构建应用程序；这意味着，如果我们将应用程序设计为预期将部署在分布式、可扩展的基础架构上，我们的应用程序就是云原生的。随着公共云将承载越来越多的算力，未来云计算将是主流的 IT 能力交付方式，CNCF 也对云原生进行了重新定义：云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用；云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API。</p>
<ul>
<li>Codeless 对应的是服务开发，实现了源代码托管，你只需要关注你的代码实现，而不需要关心你的代码在哪，因为在整个开发过程中你都不会感受到代码库和代码分支的存在。</li>
<li>Applicationless 对应的是服务发布，在服务化框架下，你的服务发布不再需要申请应用，也不需要关注你的应用在哪。</li>
<li>Serverless 对应的则是服务运维，有了 Serverless 化能力，你不再需要关注你的机器资源，Servlerless 会帮你搞定机器资源的弹性扩缩容</li>
</ul>
<p>这些技术组合搭配，能够构建容错性好、易于管理和便于观察的松耦合系统；再结合可靠的自动化手段，云原生技术能够使工程师轻松地对系统作出频繁和可预测的重大变更。由此可见，云原生是保障系统能力灵动性地有效抓手；云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。微服务架构非常适合云原生应用程序；但是，云原生同样存在着一定的限制，如果你的云原生应用程序部署在 AWS 等公有云上，则云原生 API 不是跨云平台的。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084138-a47dc.png" alt="img"></p>
<p>云原生应用的关键属性包括了：使用轻量级的容器打包、使用最合适的语言和框架开发、以松耦合的微服务方式设计、以 API 为中心的交互和协作、无状态和有状态服务在架构上界限清晰、不依赖于底层操作系统和服务器、部署在自服务、弹性的云基础设施上、通过敏捷的 DevOps 流程管理、自动化能力、通过定义和策略驱动的资源分配。云原生是分布式应用当下重要的发展路径，其终态应当是 Distributionless，所有与分布式相关的问题由云平台解，分布式应用的开发会跟传统应用的开发一样方便，甚至更加便捷。</p>
<h1 id="云基础架构"><a href="#云基础架构" class="headerlink" title="云基础架构"></a>云基础架构</h1><blockquote>
<p>本部分节选自《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-infras.gitbook.io%2Fi%2F">分布式基础架构之虚拟化与编排</a>》</p>
</blockquote>
<p><img src="http://image.winrains.cn/2019/08/20190829084140-51d5f.png" alt="应用基础架构变迁"></p>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>虚拟机由某些特定的硬件和内核虚拟化组成，运行客户操作系统。称为管理程序的软件创建虚拟化硬件，其可以包括虚拟磁盘，虚拟网络接口，虚拟 CPU 等。虚拟机还包括可以与此虚拟硬件通信的宾客内核。管理程序可以托管，这意味着它是一些在主机操作系统（MacOS）上运行的软件，如示例中所示。它也可以是裸机，直接在机器硬件上运行（替换你的操作系统）。无论哪种方式，管理程序方法都被认为是重量级的，因为它需要虚拟化多个部分（如果不是全部硬件和内核）。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084141-249d1.png" alt="img"></p>
<p>VM 需要硬件虚拟化才能实现机器级隔离，而容器则只需要在同一操作系统内进行隔离操作。 随着隔离空间数量的增加，开销差异变得非常明显。</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>在过去几年里，云平台发展迅速，但其中困扰运维工程师最多的，是需要为各种迥异的开发语言安装相应的运行时环境。虽然自动化运维工具可以降低环境搭建的复杂度，但仍然不能从根本上解决环境的问题。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084142-766b5.png" alt="img"></p>
<p>Docker 的出现成为了软件开发行业新的分水岭，容器技术的成熟也标志着技术新纪元的开启。Docker 提供了让开发工程师可以将应用和依赖封装到一个可移植的容器中的能力，这项举措使得 Docker 大有席卷整个软件行业并且进而改变行业游戏规则的趋势，这像极了当年智能手机刚出现时的场景——改变了整个手机行业的游戏规则。Docker 通过集装箱式的封装方式，让开发工程师和运维工程师都能够以 Docker 所提供的镜像分发的标准化方式发布应用，使得异构语言不再是捆绑团队的枷锁。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084143-4d164.png" alt="img"></p>
<p>容器是包含应用程序代码，配置和依赖关系的软件包，可提供运营效率和生产力。容器为我们提供了可预测的，可重复的和不可变的运行预期，容器的兴起是 DevOps 即服务的一个巨大推动因素，可以克服当今面临的最大安全障碍。容器化通过在操作系统级别进行虚拟化来使应用程序可移植，从而创建基于内核的隔离的封装系统。容器化的应用程序可以放在任何地方，无需依赖项运行或需要整个 VM，从而消除了依赖关系。<br>作为独立的单元，容器能够在任何主机操作系统，CentOS，Ubuntu，MacOS，甚至是像 Windows 这样的非 UNIX 系统中运行。容器还充当标准化的工作或计算单元。一个常见的范例是每个容器运行单个 Web 服务器，数据库的单个分片或单个 Spark 工作程序等，只需要扩展容器的数量就能够便捷地扩展应用。每个容器都有一个固定的资源配置（CPU，RAM，线程数等），并且扩展应用程序需要只扩展容器的数量而不是单个资源原语。当应用程序需要按比例放大或缩小时，这为工程师提供了更容易的抽象。容器也是实现微服务架构的一个很好的工具，每个微服务只是一组协作容器。例如，可以使用单个主容器和多个从容器来实现 Redis 微服务。</p>
<h2 id="Kubernetes-与编排"><a href="#Kubernetes-与编排" class="headerlink" title="Kubernetes 与编排"></a>Kubernetes 与编排</h2><p>随着虚拟化技术的成熟和分布式架构的普及，用来部署、管理和运行应用的云平台被越来越多地提及。IaaS、PaaS 和 SaaS 是云计算的三种基本服务类型，分别表示关注硬件基础设施的基础设施即服务、关注软件和中间件平台的平台即服务，以及关注业务应用的软件即服务。容器的出现，使原有的基于虚拟机的云主机应用，彻底转变为更加灵活和轻量的容器与编排调度的云平台应用。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084144-5aac4.png" alt="img"></p>
<p>然而容器单元越来越散落使得管理成本逐渐上升，大家对容器编排工具的需求前所未有的强烈，Kubernetes、Mesos、Swarm 等为云原生应用提供了强有力的编排和调度能力，它们是云平台上的分布式操作系统。容器编排是通常可以部署多个容器以通过自动化实现应用程序的过程。像 Kubernetes 和 Docker Swarm 这样的容器管理和容器编排引擎，使用户能够指导容器部署并自动执行更新，运行状况监视和故障转移过程。<br>Kubernetes 是目前世界范围内关注度最高的开源项目，它是一个出色的容器编排系统，用于提供一站式服务。Kubernetes 出身于互联网行业巨头 Google，它借鉴了由上百位工程师花费十多年时间打造的 Borg 系统的理念，安装极其简易，网络层对接方式十分灵活。Kubernetes 和 Mesos 的出色表现给行业中各类工程师的工作模式带来了颠覆性的改变。他们再也不用关注每一台服务器，当服务器出现问题时，只要将其换掉即可。业务开发工程师不必再过分关注非功能需求，只需专注自己的业务领域即可。而中间件开发工程师则需要开发出健壮的云原生中间件，用来连接业务应用与云平台。<br>Kubernetes、Service Mesh 和 Serverless 三者共同演绎不同层次的封装和向上屏蔽下面的细节。Kubernetes 引入了不同的设计模式，实现对各种云资源全新、有效和优雅的抽象和管理模式，让集群的管理和应用发布变成了件相当轻松且不易出错的事。被广泛采用的微服务软件架构将分布式应用的各种复杂度迁移到了服务之间，如何通过全局一致、体系化、规范化和无侵入的手段进行治理就变成了微服务软件架构下至关重要的内容。Kubernetes 细化的应用程序的分解粒度，同时将服务发现、配置管理、负载均衡和健康检查等作为基础设施的功能，简化了应用程序的开发。而 Kubernetes 这种声明式配置尤其适合 CI/CD 流程，况且现在还有如 Helm、Draft、Spinnaker、Skaffold 等开源工具可以帮助我们发布 Kuberentes 应用。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829084145-f0e6e.png" alt="img"></p>
<p>Service Mesh 通过将各服务所共用和与环境相关的内容剥离到部署于每个服务边上的 Sidecar 进程而轻松地做到了。这一剥离动作使得服务与平台能充分解耦而方便各自演进与发展，也使得服务变轻而有助于改善服务启停的及时性。Service Mesh 因为将那些服务治理相关的逻辑剥离到了 Sidecar 中且作为独立进程，所以 Sidecar 所实现的功能天然地支持多语言，为上面的服务采用多语言开发创造了更为有利的条件。通过 Service Mesh 对整个网络的服务流量进行技术收口，让异地多活这样涉及流量调度的系统工程实现起来更加优雅、简洁与有效，也能更加方便地实现服务版本升级时的灰度、回滚而改善安全生产质量。由于技术收口，给服务流量的治理和演进、排错、日志采集的经济性等疑难问题创造了新的发展空间。</p>
<h1 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h1><p><img src="http://image.winrains.cn/2019/08/20190829084146-b3ca1.png" alt="img"></p>
<p>您可以通过以下导航来在 Gitbook 中阅读笔者的系列文章，涵盖了技术资料归纳、编程语言与理论、Web 与大前端、服务端开发与基础架构、云计算与大数据、数据科学与人工智能、产品设计等多个领域：</p>
<ul>
<li><p>知识体系：《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-al.gitbook.io%2Fi%2F">Awesome Lists | CS 资料集锦</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-ac.gitbook.io%2Fi%2F">Awesome CheatSheets | 速学速查手册</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwx-chevalier%2FAwesome-Interviews">Awesome Interviews | 求职面试必备</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwx-chevalier%2FAwesome-RoadMaps">Awesome RoadMaps | 程序员进阶指南</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwx-chevalier%2FAwesome-MindMaps">Awesome MindMaps | 知识脉络思维脑图</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwx-chevalier%2FAwesome-CS-Books">Awesome-CS-Books | 开源书籍（.pdf）汇总</a>》</p>
</li>
<li><p>编程语言：《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-pl.gitbook.io%2Fi%2F">编程语言理论</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-pl.gitbook.io%2Fi%2Fjava%2Fjava">Java 实战</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-pl.gitbook.io%2Fi%2Fjavascript%2Fjavascript">JavaScript 实战</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-pl.gitbook.io%2Fi%2Fgo%2Fgo">Go 实战</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-pl.gitbook.io%2Fi%2Fpython%2Fpython">Python 实战</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-pl.gitbook.io%2Fi%2Frust%2Frust">Rust 实战</a>》</p>
</li>
<li><p>软件工程、模式与架构：《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-se.gitbook.io%2Fi%2F">编程范式与设计模式</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-se.gitbook.io%2Fi%2F">数据结构与算法</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-se.gitbook.io%2Fi%2F">软件架构设计</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-se.gitbook.io%2Fi%2F">整洁与重构</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-se.gitbook.io%2Fi%2F">研发方式与工具</a>》</p>
</li>
<li><p>Web 与大前端：《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-web.gitbook.io%2Fi%2F">现代 Web 开发基础与工程实践</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-fe.gitbook.io%2Fi%2F">数据可视化</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-fe.gitbook.io%2Fi%2F">iOS</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-fe.gitbook.io%2Fi%2F">Android</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-fe.gitbook.io%2Fi%2F">混合开发与跨端应用</a>》</p>
</li>
<li><p>服务端开发实践与工程架构：《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-be.gitbook.io%2Fi%2F">服务端基础</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-be.gitbook.io%2Fi%2F">微服务与云原生</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-be.gitbook.io%2Fi%2F">测试与高可用保障</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-be.gitbook.io%2Fi%2F">DevOps</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-be.gitbook.io%2Fi%2F">Node</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-be.gitbook.io%2Fi%2F">Spring</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-be.gitbook.io%2Fi%2F">信息安全与渗透测试</a>》</p>
</li>
<li><p>分布式基础架构：《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-infras.gitbook.io%2Fi%2F">分布式系统</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-infras.gitbook.io%2Fi%2F">分布式计算</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-infras.gitbook.io%2Fi%2F">数据库</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-infras.gitbook.io%2Fi%2F">网络</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-infras.gitbook.io%2Fi%2F">虚拟化与编排</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-infras.gitbook.io%2Fi%2F">云计算与大数据</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-infras.gitbook.io%2Fi%2F">Linux 与操作系统</a>》</p>
</li>
<li><p>数据科学，人工智能与深度学习：《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-aidl.gitbook.io%2Fi%2F">数理统计</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-aidl.gitbook.io%2Fi%2F">数据分析</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-aidl.gitbook.io%2Fi%2F">机器学习</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-aidl.gitbook.io%2Fi%2F">深度学习</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-aidl.gitbook.io%2Fi%2F">自然语言处理</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-aidl.gitbook.io%2Fi%2F">工具与工程化</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-aidl.gitbook.io%2Fi%2F">行业应用</a>》</p>
</li>
<li><p>产品设计与用户体验：《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-pd.gitbook.io%2Fi%2F">产品设计</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-pd.gitbook.io%2Fi%2F">交互体验</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fngte-pd.gitbook.io%2Fi%2F">项目管理</a>》</p>
</li>
<li><p>行业应用：《<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwx-chevalier%2FBusiness-Series">行业迷思</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwx-chevalier%2FBusiness-Series">功能域</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwx-chevalier%2FBusiness-Series">电子商务</a>》、《<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwx-chevalier%2FBusiness-Series">智能制造</a>》</p>
</li>
</ul>
<p>此外，你还可前往 <a href="https://link.juejin.im?target=https%3A%2F%2Fwx-chevalier.github.io%2Fhome%2F%23%2Fsearch">xCompass</a> 交互式地检索、查找需要的文章/链接/书籍/课程；或者在 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwx-chevalier%2FDeveloper-Zero-To-Mastery">MATRIX 文章与代码索引矩阵</a>中查看文章与项目源代码等更详细的目录导航信息。最后，你也可以关注微信公众号：『<strong>某熊的技术之路</strong>』以获取最新资讯。</p>
<blockquote>
<p>作者：王下邀月熊</p>
<p>来源：<a href="https://juejin.im/post/5d66a4875188250d9432a973" target="_blank" rel="noopener">https://juejin.im/post/5d66a4875188250d9432a973</a></p>
</blockquote>
]]></content>
      <categories>
        <category>系统架构</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL规范</title>
    <url>/2019/12/26/MySQL%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="一、数据库命令规范"><a href="#一、数据库命令规范" class="headerlink" title="一、数据库命令规范"></a>一、数据库命令规范</h2><p>· 所有数据库对象名称必须使用小写字母并用下划线分割<br>· 所有数据库对象名称禁止使用mysql保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）<br>· 数据库对象的命名要能做到见名识意，并且最后不要超过32个字符<br>· 临时库表必须以tmp_为前缀并以日期为后缀，备份表必须以bak_为前缀并以日期(时间戳)为后缀<br>· 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索 引失效，导致查询效率降低）</p>
<a id="more"></a>

<h2 id="二、数据库基本设计规范"><a href="#二、数据库基本设计规范" class="headerlink" title="二、数据库基本设计规范"></a>二、数据库基本设计规范</h2><h3 id="1、所有表必须使用Innodb存储引擎"><a href="#1、所有表必须使用Innodb存储引擎" class="headerlink" title="1、所有表必须使用Innodb存储引擎"></a>1、所有表必须使用Innodb存储引擎</h3><p>没有特殊要求（即Innodb无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用Innodb存储引擎（mysql5.5之前默认使用Myisam，5.6以后默认的为Innodb）Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好</p>
<h3 id="2、数据库和表的字符集统一使用UTF8"><a href="#2、数据库和表的字符集统一使用UTF8" class="headerlink" title="2、数据库和表的字符集统一使用UTF8"></a>2、数据库和表的字符集统一使用UTF8</h3><p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效</p>
<h3 id="3、所有表和字段都需要添加注释"><a href="#3、所有表和字段都需要添加注释" class="headerlink" title="3、所有表和字段都需要添加注释"></a>3、所有表和字段都需要添加注释</h3><p>使用comment从句添加表和列的备注 从一开始就进行数据字典的维护</p>
<h3 id="4、尽量控制单表数据量的大小，建议控制在500万以内"><a href="#4、尽量控制单表数据量的大小，建议控制在500万以内" class="headerlink" title="4、尽量控制单表数据量的大小，建议控制在500万以内"></a>4、尽量控制单表数据量的大小，建议控制在500万以内</h3><p>500万并不是MySQL数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题<br>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p>
<h3 id="5、谨慎使用MySQL分区表"><a href="#5、谨慎使用MySQL分区表" class="headerlink" title="5、谨慎使用MySQL分区表"></a><strong>5、谨慎使用MySQL分区表</strong></h3><p>分区表在物理上表现为多个文件，在逻辑上表现为一个表 谨慎选择分区键，跨分区查询效率可能更低 建议采用物理分表的方式管理大数据</p>
<h3 id="6、尽量做到冷热数据分离，减小表的宽度"><a href="#6、尽量做到冷热数据分离，减小表的宽度" class="headerlink" title="6、尽量做到冷热数据分离，减小表的宽度"></a>6、尽量做到冷热数据分离，减小表的宽度</h3><p>MySQL限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节 减少磁盘IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的IO） 更有效的利用缓存，避免读入无用的冷数据 经常一起使用的列放到一个表中（避免更多的关联操作）</p>
<h3 id="7、禁止在表中建立预留字段"><a href="#7、禁止在表中建立预留字段" class="headerlink" title="7、禁止在表中建立预留字段"></a>7、禁止在表中建立预留字段</h3><p>预留字段的命名很难做到见名识义 预留字段无法确认存储的数据类型，所以无法选择合适的类型 对预留字段类型的修改，会对表进行锁定</p>
<h3 id="8、禁止在数据库中存储图片，文件等大的二进制数据"><a href="#8、禁止在数据库中存储图片，文件等大的二进制数据" class="headerlink" title="8、禁止在数据库中存储图片，文件等大的二进制数据"></a>8、禁止在数据库中存储图片，文件等大的二进制数据</h3><p>通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时 通常存储于文件服务器，数据库只存储文件地址信息</p>
<h3 id="9、禁止在线上做数据库压力测试"><a href="#9、禁止在线上做数据库压力测试" class="headerlink" title="9、禁止在线上做数据库压力测试"></a>9、禁止在线上做数据库压力测试</h3><h3 id="10、禁止从开发环境，测试环境直接连接生成环境数据库"><a href="#10、禁止从开发环境，测试环境直接连接生成环境数据库" class="headerlink" title="10、禁止从开发环境，测试环境直接连接生成环境数据库"></a>10、禁止从开发环境，测试环境直接连接生成环境数据库</h3><h2 id="三、数据库字段设计规范"><a href="#三、数据库字段设计规范" class="headerlink" title="三、数据库字段设计规范"></a>三、数据库字段设计规范</h2><h3 id="1、优先选择符合存储需要的最小的数据类型"><a href="#1、优先选择符合存储需要的最小的数据类型" class="headerlink" title="1、优先选择符合存储需要的最小的数据类型"></a>1、优先选择符合存储需要的最小的数据类型</h3><p>· 原因<br>列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的IO次数也就越多， 索引的性能也就越差<br>· 方法<br>1）将字符串转换成数字类型存储，如：将IP地址转换成整形数据。<br>mysql提供了两个方法来处理ip地址：<br><img src="http://image.winrains.cn/2019/08/20190829084907-d831b.jpeg" alt="img"><br>插入数据前，先用inet_aton把ip地址转为整型，可以节省空间。显示数据时，使用inet_ntoa把整型的ip地址转为地址显示即可。<br>2）对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符号整型来存储<br>因为：无符号相对于有符号可以多出一倍的存储空间<br><img src="http://image.winrains.cn/2019/08/20190829084907-68f48.jpeg" alt="img"><br>VARCHAR(N)中的N代表的是字符数，而不是字节数<br>使用UTF8存储255个汉字 Varchar(255)=765个字节。过大的长度会消耗更多的内存</p>
<h3 id="2、避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据"><a href="#2、避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据" class="headerlink" title="2、避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据"></a>2、避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据</h3><p>· 建议把BLOB或是TEXT列分离到单独的扩展表中<br>Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。<br>而且对于这种数据，Mysql还是要进行二次查询，会使sql性能变得很差，但是不是说一定不能使用这样的数据类型。<br>如果一定要使用，建议把BLOB或是TEXT列分离到单独的扩展表中，查询时一定不要使用select * 而只需要取出必要的列，不需要TEXT列的数据时不要对该列进行查询。<br>· TEXT或BLOB类型只能使用前缀索引<br>因为MySQL对索引字段长度是有限制的，所以TEXT类型只能使用前缀索引，并且TEXT列上是不能有默认值的。</p>
<h3 id="3、避免使用ENUM类型"><a href="#3、避免使用ENUM类型" class="headerlink" title="3、避免使用ENUM类型"></a>3、避免使用ENUM类型</h3><p>· 修改ENUM值需要使用ALTER语句<br>· ENUM类型的ORDER BY操作效率低，需要额外操作<br>· 禁止使用数值作为ENUM的枚举值</p>
<h3 id="4、尽可能把所有列定义为NOT-NULL"><a href="#4、尽可能把所有列定义为NOT-NULL" class="headerlink" title="4、尽可能把所有列定义为NOT NULL"></a>4、尽可能把所有列定义为NOT NULL</h3><p>原因：<br>· 索引NULL列需要额外的空间来保存，所以要占用更多的空间；<br>· 进行比较和计算时要对NULL值做特别的处理</p>
<h3 id="5、使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间"><a href="#5、使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间" class="headerlink" title="5、使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间"></a>5、使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间</h3><p>TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07。<br>TIMESTAMP 占用4字节和INT相同，但比INT可读性高<br>超出TIMESTAMP取值范围的使用DATETIME类型存储。<br>经常会有人用字符串存储日期型的数据（不正确的做法）：<br>· 缺点1：无法用日期函数进行计算和比较<br>· 缺点2：用字符串存储日期要占用更多的空间</p>
<h3 id="6、同财务相关的金额类数据必须使用decimal类型"><a href="#6、同财务相关的金额类数据必须使用decimal类型" class="headerlink" title="6、同财务相关的金额类数据必须使用decimal类型"></a>6、同财务相关的金额类数据必须使用decimal类型</h3><p>· 非精准浮点：float,double<br>· 精准浮点：decimal<br>Decimal类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节。可用于存储比bigint更大的整型数据。</p>
<h2 id="四、索引设计规范"><a href="#四、索引设计规范" class="headerlink" title="四、索引设计规范"></a>四、索引设计规范</h2><h3 id="1、限制每张表上的索引数量，建议单张表索引不超过5个"><a href="#1、限制每张表上的索引数量，建议单张表索引不超过5个" class="headerlink" title="1、限制每张表上的索引数量，建议单张表索引不超过5个"></a>1、限制每张表上的索引数量，建议单张表索引不超过5个</h3><p>索引并不是越多越好！索引可以提高效率同样可以降低效率。<br>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。<br>因为mysql优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加mysql优化器生成执行计划的时间，同样会降低查询性能。</p>
<h3 id="2、禁止给表中的每一列都建立单独的索引"><a href="#2、禁止给表中的每一列都建立单独的索引" class="headerlink" title="2、禁止给表中的每一列都建立单独的索引"></a>2、禁止给表中的每一列都建立单独的索引</h3><p>5.6版本之前，一个sql只能使用到一个表中的一个索引，5.6以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好</p>
<h3 id="3、每个Innodb表必须有个主键"><a href="#3、每个Innodb表必须有个主键" class="headerlink" title="3、每个Innodb表必须有个主键"></a>3、每个Innodb表必须有个主键</h3><p>Innodb是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。<br>每个表都可以有多个索引，但是表的存储顺序只能有一种 Innodb是按照主键索引的顺序来组织表的。<br>不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引） 不要使用UUID、MD5、HASH、字符串列作为主键（无法保证数据的顺序增长）。<br>主键建议使用自增ID值。</p>
<h2 id="五、常见索引列建议"><a href="#五、常见索引列建议" class="headerlink" title="五、常见索引列建议"></a>五、常见索引列建议</h2><p>· 出现在SELECT、UPDATE、DELETE语句的WHERE从句中的列<br>· 包含在ORDER BY、GROUP BY、DISTINCT中的字段<br>并不要将符合1和2中的字段的列都建立一个索引，通常将1、2中的字段建立联合索引效果更好<br>· 多表join的关联列</p>
<h2 id="六、如何选择索引列的顺序"><a href="#六、如何选择索引列的顺序" class="headerlink" title="六、如何选择索引列的顺序"></a>六、如何选择索引列的顺序</h2><p>建立索引的目的是：希望通过索引进行数据查找，减少随机IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。<br>· 区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）；<br>· 尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好）；<br>· 使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）。</p>
<h2 id="七、避免建立冗余索引和重复索引"><a href="#七、避免建立冗余索引和重复索引" class="headerlink" title="七、避免建立冗余索引和重复索引"></a>七、避免建立冗余索引和重复索引</h2><p>因为这样会增加查询优化器生成执行计划的时间。<br>· 重复索引示例：primary key(id)、index(id)、unique index(id)<br>· 冗余索引示例：index(a,b,c)、index(a,b)、index(a)</p>
<h2 id="八、优先考虑覆盖索引"><a href="#八、优先考虑覆盖索引" class="headerlink" title="八、优先考虑覆盖索引"></a>八、优先考虑覆盖索引</h2><p>对于频繁的查询优先考虑使用覆盖索引。<br>覆盖索引：就是包含了所有查询字段(where,select,ordery by,group by包含的字段)的索引<br>覆盖索引的好处：<br>· 避免Innodb表进行索引的二次查询<br>Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息，<br>如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了IO操作，提升了查询效率。<br>· 可以把随机IO变成顺序IO加快查询效率<br>由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO。</p>
<h2 id="九、索引SET规范"><a href="#九、索引SET规范" class="headerlink" title="九、索引SET规范"></a>九、索引SET规范</h2><p>尽量避免使用外键约束<br>· 不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引；<br>· 外键可用于保证数据的参照完整性，但建议在业务端实现；<br>· 外键会影响父表和子表的写操作从而降低性能。</p>
<h2 id="十、数据库SQL开发规范"><a href="#十、数据库SQL开发规范" class="headerlink" title="十、数据库SQL开发规范"></a>十、数据库SQL开发规范</h2><h3 id="1、建议使用预编译语句进行数据库操作"><a href="#1、建议使用预编译语句进行数据库操作" class="headerlink" title="1、建议使用预编译语句进行数据库操作"></a>1、建议使用预编译语句进行数据库操作</h3><p>预编译语句可以重复使用这些计划，减少SQL编译所需要的时间，还可以解决动态SQL所带来的SQL注入的问题 只传参数，比传递SQL语句更高效 相同语句可以一次解析，多次使用，提高处理效率。</p>
<h3 id="2、避免数据类型的隐式转换"><a href="#2、避免数据类型的隐式转换" class="headerlink" title="2、避免数据类型的隐式转换"></a>2、避免数据类型的隐式转换</h3><p>隐式转换会导致索引失效。如：select name,phone from customer where id = ‘111’;</p>
<h3 id="3、充分利用表上已经存在的索引"><a href="#3、充分利用表上已经存在的索引" class="headerlink" title="3、充分利用表上已经存在的索引"></a>3、充分利用表上已经存在的索引</h3><p>· 避免使用双%号的查询条件。<br>如a like ‘%123%’，（如果无前置%,只有后置%，是可以用到列上的索引的）<br>· 一个SQL只能利用到复合索引中的一列进行范围查询<br>如：有 a,b,c列的联合索引，在查询条件中有a列的范围查询，则在b,c列上的索引将不会被用到，在定义联合索引时，如果a列要用到范围查找的话，就要把a列放到联合索引的右侧。<br>使用left join或 not exists来优化not in操作<br>因为not in 也通常会使用索引失效。</p>
<h3 id="4、数据库设计时，应该要对以后扩展进行考虑"><a href="#4、数据库设计时，应该要对以后扩展进行考虑" class="headerlink" title="4、数据库设计时，应该要对以后扩展进行考虑"></a>4、数据库设计时，应该要对以后扩展进行考虑</h3><h3 id="5、程序连接不同的数据库使用不同的账号，进制跨库查询"><a href="#5、程序连接不同的数据库使用不同的账号，进制跨库查询" class="headerlink" title="5、程序连接不同的数据库使用不同的账号，进制跨库查询"></a>5、程序连接不同的数据库使用不同的账号，进制跨库查询</h3><p>· 为数据库迁移和分库分表留出余地<br>· 降低业务耦合度<br>· 避免权限过大而产生的安全风险</p>
<h3 id="6、禁止使用SELECT-必须使用SELECT-lt-字段列表-gt-查询"><a href="#6、禁止使用SELECT-必须使用SELECT-lt-字段列表-gt-查询" class="headerlink" title="6、禁止使用SELECT * 必须使用SELECT &lt;字段列表&gt; 查询"></a>6、禁止使用SELECT * 必须使用SELECT &lt;字段列表&gt; 查询</h3><p>原因：<br>· 消耗更多的CPU和IO以网络带宽资源<br>· 无法使用覆盖索引<br>· 可减少表结构变更带来的影响</p>
<h3 id="7、禁止使用不含字段列表的INSERT语句"><a href="#7、禁止使用不含字段列表的INSERT语句" class="headerlink" title="7、禁止使用不含字段列表的INSERT语句"></a>7、禁止使用不含字段列表的INSERT语句</h3><p>如：insert into values (‘a’,’b’,’c’);<br>应使用insert into t(c1,c2,c3) values (‘a’,’b’,’c’);</p>
<h3 id="8、避免使用子查询，可以把子查询优化为join操作"><a href="#8、避免使用子查询，可以把子查询优化为join操作" class="headerlink" title="8、避免使用子查询，可以把子查询优化为join操作"></a>8、避免使用子查询，可以把子查询优化为join操作</h3><p>通常子查询在in子句中，且子查询中为简单SQL(不包含union、group by、order by、limit从句)时，才可以把子查询转化为关联查询进行优化。<br>子查询性能差的原因：<br>· 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能 会受到一定的影响；<br>· 特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大；<br>· 由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询。</p>
<h3 id="9、避免使用JOIN关联太多的表"><a href="#9、避免使用JOIN关联太多的表" class="headerlink" title="9、避免使用JOIN关联太多的表"></a>9、避免使用JOIN关联太多的表</h3><p>对于Mysql来说，是存在关联缓存的，缓存的大小可以由join_buffer_size参数进行设置。<br>在Mysql中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，所占用的内存也就越大。<br>如果程序中大量的使用了多表关联的操作，同时join_buffer_size设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。<br>同时对于关联操作来说，会产生临时表操作，影响查询效率Mysql最多允许关联61个表，建议不超过5个。</p>
<h3 id="10、减少同数据库的交互次数"><a href="#10、减少同数据库的交互次数" class="headerlink" title="10、减少同数据库的交互次数"></a>10、减少同数据库的交互次数</h3><p>数据库更适合处理批量操作 合并多个相同的操作到一起，可以提高处理效率</p>
<h3 id="11、对应同一列进行or判断时，使用in代替or"><a href="#11、对应同一列进行or判断时，使用in代替or" class="headerlink" title="11、对应同一列进行or判断时，使用in代替or"></a>11、对应同一列进行or判断时，使用in代替or</h3><p>in的值不要超过500个in操作可以更有效的利用索引，or大多数情况下很少能利用到索引。</p>
<h3 id="12、禁止使用order-by-rand-进行随机排序"><a href="#12、禁止使用order-by-rand-进行随机排序" class="headerlink" title="12、禁止使用order by rand() 进行随机排序"></a>12、禁止使用order by rand() 进行随机排序</h3><p>会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的CPU和IO及内存资源。<br>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式</p>
<h3 id="13、WHERE从句中禁止对列进行函数转换和计算"><a href="#13、WHERE从句中禁止对列进行函数转换和计算" class="headerlink" title="13、WHERE从句中禁止对列进行函数转换和计算"></a>13、WHERE从句中禁止对列进行函数转换和计算</h3><p>对列进行函数转换或计算时会导致无法使用索引。<br>· 不推荐：<br><img src="http://image.winrains.cn/2019/08/20190829084907-5b451.jpeg" alt="img"><br>· 推荐：<br><img src="http://image.winrains.cn/2019/08/20190829084907-218f3.jpeg" alt="img"></p>
<h3 id="14、在明显不会有重复值时使用UNION-ALL而不是UNION"><a href="#14、在明显不会有重复值时使用UNION-ALL而不是UNION" class="headerlink" title="14、在明显不会有重复值时使用UNION ALL而不是UNION"></a>14、在明显不会有重复值时使用UNION ALL而不是UNION</h3><p>· UNION会把两个结果集的所有数据放到临时表中后再进行去重操作<br>· UNION ALL不会再对结果集进行去重操作</p>
<h3 id="15、拆分复杂的大SQL为多个小SQL"><a href="#15、拆分复杂的大SQL为多个小SQL" class="headerlink" title="15、拆分复杂的大SQL为多个小SQL"></a>15、拆分复杂的大SQL为多个小SQL</h3><p>· 大SQL：逻辑上比较复杂，需要占用大量CPU进行计算的SQL<br>· MySQL：一个SQL只能使用一个CPU进行计算<br>· SQL拆分后可以通过并行执行来提高处理效率</p>
<h2 id="十一、数据库操作行为规范"><a href="#十一、数据库操作行为规范" class="headerlink" title="十一、数据库操作行为规范"></a>十一、数据库操作行为规范</h2><h3 id="1、超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作"><a href="#1、超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作" class="headerlink" title="1、超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作"></a>1、超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作</h3><p>· 大批量操作可能会造成严重的主从延迟<br>主从环境中，大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况<br>· binlog日志为row格式时会产生大量的日志<br>大批量写操作会产生大量日志，特别是对于row格式二进制数据而言，由于在row格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因。<br>· 避免产生大事务操作<br>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对MySQL的性能产生非常大的影响。<br>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批。</p>
<h3 id="2、对于大表使用pt-online-schema-change修改表结构"><a href="#2、对于大表使用pt-online-schema-change修改表结构" class="headerlink" title="2、对于大表使用pt-online-schema-change修改表结构"></a>2、对于大表使用pt-online-schema-change修改表结构</h3><p>· 避免大表修改产生的主从延迟<br>· 避免在对表字段进行修改时进行锁表<br>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。<br>pt-online-schema-change它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。<br>把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。<br>把原来一个DDL操作，分解成多个小的批次进行。</p>
<h3 id="3、禁止为程序使用的账号赋予super权限"><a href="#3、禁止为程序使用的账号赋予super权限" class="headerlink" title="3、禁止为程序使用的账号赋予super权限"></a>3、禁止为程序使用的账号赋予super权限</h3><p>当达到最大连接数限制时，还运行1个有super权限的用户连接super权限只能留给DBA处理问题的账号使用。</p>
<h3 id="4、对于程序连接数据库账号，遵循权限最小原则"><a href="#4、对于程序连接数据库账号，遵循权限最小原则" class="headerlink" title="4、对于程序连接数据库账号，遵循权限最小原则"></a>4、对于程序连接数据库账号，遵循权限最小原则</h3><p>程序使用数据库账号只能在一个DB下使用，不准跨库 程序使用的账号原则上不准有drop权限。</p>
<blockquote>
<p>作者：程序员追风</p>
<p>来源：<a href="https://juejin.im/post/5d663c6de51d453b8b5fa605" target="_blank" rel="noopener">https://juejin.im/post/5d663c6de51d453b8b5fa605</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Maven介绍</title>
    <url>/2019/12/26/Maven%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="什么是Maven"><a href="#什么是Maven" class="headerlink" title="什么是Maven"></a>什么是Maven</h1><p>乍一看，Maven似乎包含很多内容，但简而言之，Maven试图将模式应用于项目的构建基础设施，以便通过提供使用最佳实践的清晰路径来促进理解和生产力。Maven本质上是一个项目管理和理解工具，因此提供了一种帮助管理的方法:</p>
<ul>
<li>Builds</li>
<li>Documentation</li>
<li>Reporting</li>
<li>Dependencies</li>
<li>SCMs</li>
<li>Releases</li>
<li>Distribution</li>
</ul>
<a id="more"></a>

<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>Maven最初设计，是以简化Jakarta Turbine项目的建设。在几个项目，每个项目包含了不同的Ant构建文件。 JAR检查到CVS。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>1）为了使项目管理更加简单。<br>2）提供统一的构建系统。<br>3）提供优质项目的资讯。<br>4）为最佳实践开发提供指导。<br>5）允许透明地迁移到新特性。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate <span class="attribute">-DgroupId</span>=com.mycompany.app <span class="attribute">-DartifactId</span>=my-app <span class="attribute">-DarchetypeArtifactId</span>=maven-archetype-quickstart <span class="attribute">-DarchetypeVersion</span>=1.4 <span class="attribute">-DinteractiveMode</span>=<span class="literal">false</span></span></pre></td></tr></table></figure>

<p>生成的文件目录：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">my</span>-app</span></pre></td></tr><tr><td class="code"><pre><span class="line">|<span class="comment">-- pom.xml</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">`<span class="comment">-- src</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |<span class="comment">-- main</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |   `<span class="comment">-- java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |       `<span class="comment">-- com</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |           `<span class="comment">-- mycompany</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |               `<span class="comment">-- app</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |                   `<span class="comment">-- App.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    `<span class="comment">-- test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        `<span class="comment">-- java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            `<span class="comment">-- com</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                `<span class="comment">-- mycompany</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    `<span class="comment">-- app</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                        `<span class="comment">-- AppTest.java</span></span></pre></td></tr></table></figure>

<h3 id="创建一个工程"><a href="#创建一个工程" class="headerlink" title="创建一个工程"></a>创建一个工程</h3><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">mvn <span class="class"><span class="keyword">package</span></span></span></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">..</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] BUILD SUCCESSFUL</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Total time: 2 seconds</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Finished at: Thu Jul 07 21:34:52 CEST 2011</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Final Memory: 3M/6M</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ------------------------------------------------------------------------</span></pre></td></tr></table></figure>

<p>与执行的第一个命令（architetype:generate）不同，您可能会注意到第二个命令只是一个单词package。这不是一个目标，而是一个阶段。阶段是构建生命周期中的一个步骤，它是一个有序的阶段序列。当一个阶段被给定时，Maven将执行序列中的每个阶段，直到并包括定义的阶段。例如，如果我们执行编译阶段，实际执行的阶段是：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">validate</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">generate</span>-sources</span></pre></td></tr><tr><td class="code"><pre><span class="line">process-sources</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">generate</span>-resources</span></pre></td></tr><tr><td class="code"><pre><span class="line">process-resources</span></pre></td></tr><tr><td class="code"><pre><span class="line">compile</span></pre></td></tr></table></figure>

<h3 id="编译jar包"><a href="#编译jar包" class="headerlink" title="编译jar包"></a>编译jar包</h3><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">java -cp target/my-<span class="keyword">app</span>-1.0-SNAPSHOT.jar com.mycompany.<span class="keyword">app</span>.<span class="keyword">App</span></span></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line">Hello World!</span></pre></td></tr></table></figure>

<h3 id="Java9或者之后的版本"><a href="#Java9或者之后的版本" class="headerlink" title="Java9或者之后的版本"></a>Java9或者之后的版本</h3><p>默认情况下，Maven版本可能使用Maven -compiler-plugin的旧版本，与Java 9或更高版本不兼容。要针对Java 9或更高版本，您至少应该使用maven-compiler-plugin的3.6.0版本，并将maven.compiler.release属性设置为您要针对的Java版本(例如9、10、11、12等)。 在下面的例子中，我们将Maven项目配置为使用Maven -compiler-plugin的3.8.1版本和目标Java 11:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.release</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.release</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></pre></td></tr></table></figure>

<h2 id="Maven阶段"><a href="#Maven阶段" class="headerlink" title="Maven阶段"></a>Maven阶段</h2><ul>
<li><strong>validate</strong>: 验证项目是正确的，并且所有必要的信息都是可用的。</li>
<li><strong>compile</strong>: 编译项目的源代码。</li>
<li><strong>test</strong>:使用合适的单元测试框架测试编译后的源代码。这些测试不应该要求打包或部署代码。</li>
<li><strong>package</strong>:将编译后的代码打包成可分发的格式，比如JAR。</li>
<li><strong>integration-test</strong>: 如果需要，将包处理并部署到可以运行集成测试的环境中。</li>
<li><strong>verify</strong>: 运行任何检查来验证包是否有效并满足质量标准。</li>
<li><strong>install</strong>: 将包安装到本地存储库中，以便在本地的其他项目中作为依赖项使用。</li>
<li><strong>deploy</strong>: 在集成或发布环境中完成，将最终的包复制到远程存储库，以便与其他开发人员和项目共享。</li>
</ul>
<p>在上面的缺省列表之外，还有两个Maven生命周期值得注意。他们是：</p>
<ul>
<li><strong>clean</strong>: 清理先前构建创建的工件。</li>
<li><strong>site</strong>: 为这个项目生成站点文档。</li>
</ul>
<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>使用命令：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mvn -B archetype:generate \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">-DarchetypeGroupId</span>=org.apache.maven.archetypes \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">-DgroupId</span>=com.mycompany.app \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">-DartifactId</span>=my-app</span></pre></td></tr></table></figure>

<p>执行此命令后，您将注意到发生了一些事情。首先，您将注意到为新项目创建了一个名为my-app的目录，该目录包含一个名为pom.xml的文件，如下所示:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Quick Start Archetype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p><strong>pom.xml</strong>包含该项目的项目对象模型(POM)。POM是Maven中的基本工作单元。记住这一点很重要，因为Maven本质上是以项目为中心的，因为一切都围绕着项目的概念。简而言之，POM包含关于项目的所有重要信息，本质上是一站式搜索，查找与项目相关的任何内容。理解POM非常重要，我们鼓励新用户参考对POM的介绍。 这是一个非常简单的POM，但仍然显示每个POM包含的关键元素 ,所以让我们逐一介绍一下，让您熟悉POM的要点:</p>
<ul>
<li><strong>project</strong> 这是所有Maven pom.xml文件中的顶级元素。</li>
<li><strong>modelVersion</strong> 此元素指示此POM使用的对象模型的版本。模型本身的版本更改非常不频繁，但如果Maven开发人员认为有必要更改模型，则必须更改模型，以确保使用的稳定性。</li>
<li><strong>groupId</strong> 此元素指示创建项目的组织或组的唯一标识符。groupId是项目的关键标识符之一，通常基于组织的完全限定域名。例如org.apache.maven。插件是所有Maven插件的指定groupId。</li>
<li><strong>artifactId</strong> 此元素指示此项目生成的主要构件的唯一基名称。项目的主要构件通常是一个JAR文件。像源包这样的次要构件也使用artifactId作为它们最终名称的一部分。Maven生成的典型工件的形式是-.&lt;扩展名&gt;(例如，myapp-1.0.jar)。</li>
<li><strong>packaging</strong> 此元素指示此构件(例如JAR、WAR、EAR等)要使用的包类型。这不仅意味着如果生成的工件是JAR、WAR或EAR，还可以指示作为构建过程一部分使用的特定生命周期。(生命周期是我们将在指南中进一步讨论的主题。现在，请记住，项目的指定打包可以在定制构建生命周期中发挥一定的作用。打包元素的默认值是JAR，因此您不必为大多数项目指定此值。</li>
<li><strong>version</strong> 此元素指示由项目生成的工件的版本。Maven在帮助您进行版本管理方面走了很长的路，您经常会在版本中看到快照设计器，这表明项目处于开发状态。我们将在本指南中进一步讨论快照的使用及其工作原理。</li>
<li><strong>name</strong> 此元素指示用于项目的显示名称。这通常在Maven生成的文档中使用。</li>
<li><strong>url</strong> 此元素指示可以在何处找到项目的站点。这通常在Maven生成的文档中使用。</li>
<li><strong>description</strong> 此元素提供项目的基本描述。这通常在Maven生成的文档中使用。</li>
</ul>
<h2 id="编译Maven"><a href="#编译Maven" class="headerlink" title="编译Maven"></a>编译Maven</h2><p>切换到原型创建pom.xml的目录:生成并执行以下命令编译应用程序源代码:</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mvn </span>compile</span></pre></td></tr></table></figure>

<p>执行此命令后，您将看到如下输出:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Building Maven Quick Start Archetype</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>]    task-segment: [compile]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] artifact org.apache.maven.plugins:maven-resources-plugin: \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  checking <span class="keyword">for</span> updates <span class="keyword">from</span> central</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">..</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] artifact org.apache.maven.plugins:maven-compiler-plugin: \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  checking <span class="keyword">for</span> updates <span class="keyword">from</span> central</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">..</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [resources:resources]</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">..</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [compiler:compile]</span></pre></td></tr><tr><td class="code"><pre><span class="line">Compiling 1 source file <span class="keyword">to</span> &lt;dir&gt;/my-app/target/classes</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] BUILD SUCCESSFUL</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Total time: 3 minutes 54 seconds</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Finished at: Fri Sep 23 15:48:34 GMT-05:00 2005</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Final Memory: 2M/6M</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr></table></figure>

<p>第一次执行这个(或任何其他)命令时，Maven将需要下载完成该命令所需的所有插件和相关依赖项。从Maven的干净安装来看，这可能需要相当长的时间(在上面的输出中，它花费了近4分钟)。如果您再次执行该命令，Maven现在将拥有它所需要的东西，因此它不需要下载任何新内容，并且能够更快地执行该命令。<br>从输出中可以看到，编译后的类放在${basedir}/target/classes中，这是Maven使用的另一种标准约定。因此，如果您是一个敏锐的观察者，您会注意到，通过使用标准约定，上面的POM非常小，您不必显式地告诉Maven您的任何源文件在哪里，或者输出应该放在哪里。通过遵循标准Maven约定，您可以用很少的努力完成很多工作!作为一个随意的比较，让我们来看看您在Ant中为了完成同样的事情可能必须做些什么。<br>现在，只需编译一个应用程序源代码树，所示Ant脚本的大小与上面所示POM的大小基本相同。但是，我们将看到我们可以用这个简单的POM做更多的事情!</p>
<h2 id="我如何编译我的测试源并运行我的单元测试"><a href="#我如何编译我的测试源并运行我的单元测试" class="headerlink" title="我如何编译我的测试源并运行我的单元测试?"></a>我如何编译我的测试源并运行我的单元测试?</h2><p>现在，您已经成功地编译了应用程序的源代码，并且已经有了一些需要编译和执行的单元测试(因为每个程序员总是编写和执行他们的单元测试<em>nudge nudge wink</em>)。<br>执行以下命令:</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mvn </span>test</span></pre></td></tr></table></figure>

<p>执行此命令后，您将看到如下输出:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Building Maven Quick Start Archetype</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>]    task-segment: [test]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] artifact org.apache.maven.plugins:maven-surefire-plugin: \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  checking <span class="keyword">for</span> updates <span class="keyword">from</span> central</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">..</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [resources:resources]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [compiler:compile]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] <span class="literal">Nothing</span> <span class="keyword">to</span> compile - all classes are up <span class="keyword">to</span> date</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [resources:testResources]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [compiler:testCompile]</span></pre></td></tr><tr><td class="code"><pre><span class="line">Compiling 1 source file <span class="keyword">to</span> C:\Test\Maven2\test\my-app\target\test-classes</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">..</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [surefire:test]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Setting reports dir: C:\Test\Maven2\test\my-app\target/surefire-reports</span></pre></td></tr><tr><td class="code"><pre><span class="line">-------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line"> T E S T S</span></pre></td></tr><tr><td class="code"><pre><span class="line">-------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[surefire] Running com.mycompany.app.AppTest</span></pre></td></tr><tr><td class="code"><pre><span class="line">[surefire] Tests run: 1, Failures: 0, Errors: 0, Time elapsed: 0 sec</span></pre></td></tr><tr><td class="code"><pre><span class="line">Results :</span></pre></td></tr><tr><td class="code"><pre><span class="line">[surefire] Tests run: 1, Failures: 0, Errors: 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] BUILD SUCCESSFUL</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Total time: 15 seconds</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Finished at: Thu Oct 06 08:12:17 MDT 2005</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Final Memory: 2M/8M</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr></table></figure>

<p>关于输出需要注意的一些事情:<br>Maven这次下载了更多的依赖项。这些是执行测试所需的依赖项和插件(它已经拥有编译所需的依赖项，不会再下载它们)。<br>在编译和执行测试之前，Maven编译主代码(所有这些类都是最新的，因为自上次编译以来，我们没有更改任何东西)。<br>如果你只是想编译你的测试源(而不是执行测试)，你可以执行以下步骤:</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mvn </span>test-compile</span></pre></td></tr></table></figure>

<h2 id="如何创建一个JAR并将其安装到本地存储库中"><a href="#如何创建一个JAR并将其安装到本地存储库中" class="headerlink" title="如何创建一个JAR并将其安装到本地存储库中?"></a>如何创建一个JAR并将其安装到本地存储库中?</h2><p>制作JAR文件非常简单，可以通过执行以下命令来完成:</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">mvn <span class="class"><span class="keyword">package</span></span></span></pre></td></tr></table></figure>

<p>如果您查看项目的POM，您会注意到打包元素被设置为jar。Maven就是这样知道如何从上面的命令生成JAR文件的(稍后我们将对此进行更多讨论)。现在可以查看{basedir}/target目录，您将看到生成的JAR文件。 现在，您将希望将生成的工件(JAR文件)安装到本地存储库{user.home}中。m2/repository是默认位置)。有关存储库的更多信息，您可以参考我们对存储库的介绍，但是让我们继续安装我们的工件!执行以下命令:</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mvn </span>install</span></pre></td></tr></table></figure>

<p>执行此命令后，应该会看到以下输出:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Building Maven Quick Start Archetype</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>]    task-segment: [install]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [resources:resources]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [compiler:compile]</span></pre></td></tr><tr><td class="code"><pre><span class="line">Compiling 1 source file <span class="keyword">to</span> &lt;dir&gt;/my-app/target/classes</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [resources:testResources]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [compiler:testCompile]</span></pre></td></tr><tr><td class="code"><pre><span class="line">Compiling 1 source file <span class="keyword">to</span> &lt;dir&gt;/my-app/target/test-classes</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [surefire:test]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Setting reports dir: &lt;dir&gt;/my-app/target/surefire-reports</span></pre></td></tr><tr><td class="code"><pre><span class="line">-------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line"> T E S T S</span></pre></td></tr><tr><td class="code"><pre><span class="line">-------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[surefire] Running com.mycompany.app.AppTest</span></pre></td></tr><tr><td class="code"><pre><span class="line">[surefire] Tests run: 1, Failures: 0, Errors: 0, Time elapsed: 0.001 sec</span></pre></td></tr><tr><td class="code"><pre><span class="line">Results :</span></pre></td></tr><tr><td class="code"><pre><span class="line">[surefire] Tests run: 1, Failures: 0, Errors: 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [jar:jar]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Building jar: &lt;dir&gt;/my-app/target/my-app-1.0-SNAPSHOT.jar</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] [install:install]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Installing &lt;dir&gt;/my-app/target/my-app-1.0-SNAPSHOT.jar <span class="keyword">to</span> \</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &lt;local-repository&gt;/com/mycompany/app/my-app/1.0-SNAPSHOT/my-app-1.0-SNAPSHOT.jar</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] BUILD SUCCESSFUL</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Total time: 5 seconds</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Finished at: Tue Oct 04 13:20:32 GMT-05:00 2005</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] Final Memory: 3M/8M</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="builtin-name">INFO</span>] ----------------------------------------------------------------------------</span></pre></td></tr></table></figure>

<p>请注意surefire插件(执行测试)寻找包含在具有特定命名约定的文件中的测试。默认情况下，测试包括:</p>
<ul>
<li><code>**/*Test.java</code></li>
<li><code>**/Test*.java</code></li>
<li><code>**/*TestCase.java</code></li>
</ul>
<p>默认不包括:</p>
<ul>
<li><code>**/Abstract*Test.java</code></li>
<li><code>**/Abstract*TestCase.java</code></li>
</ul>
<p>您已经完成了设置、构建、测试、打包和安装典型Maven项目的过程。这可能是绝大多数项目将使用Maven做的事情，如果您已经注意到，到目前为止您所能做的一切都是由一个18行文件驱动的，即项目的模型或POM。如果您查看一个典型的Ant构建文件，该文件提供了与我们到目前为止已经实现的功能相同的功能，您将注意到它已经是POM的两倍大，而我们才刚刚开始!Maven提供了更多的功能，而不需要像现在这样对POM进行任何添加。要从示例Ant构建文件中获得更多功能，必须不断添加容易出错的内容。<br>那么你还能免费得到什么呢?有很多Maven插件可以用上面所述的简单POM开箱即用。我们将在这里特别提到一个，因为它是Maven非常宝贵的特性之一:不需要您做任何工作，这个POM就有足够的信息为您的项目生成一个web站点!您很可能想自定义Maven站点，但如果时间紧迫，您只需执行以下命令即可提供关于项目的基本信息:</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mvn </span>site</span></pre></td></tr></table></figure>

<p>还有很多其他独立的目标也可以执行，例如:</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mvn </span>clean</span></pre></td></tr></table></figure>

<h2 id="什么是快照版本"><a href="#什么是快照版本" class="headerlink" title="什么是快照版本?"></a>什么是快照版本?</h2><p>注意，下面显示的pom.xml文件中的version标记的值有后缀:<code>-SNAPSHOT</code>。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;groupId&gt;<span class="string">...</span>&lt;<span class="string">/groupId</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;artifactId&gt;my-app&lt;<span class="string">/artifactId</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;<span class="keyword">version</span>&gt;1.0-SNAPSHOT&lt;<span class="string">/version</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;name&gt;Maven Quick Start Archetype&lt;<span class="string">/name</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">...</span></span></pre></td></tr></table></figure>

<p>快照值指的是沿着开发分支的“最新”代码，不能保证代码是稳定的或不变的。相反，“release”版本(任何没有后缀SNAPSHOT的版本值)中的代码是不变的。<br>换句话说，快照版本是最终“发布”版本之前的“开发”版本。快照比它的发布“更老”。<br>在发布过程中，x的一个版本。y-SNAPSHOT更改为x.y.发布过程也将开发版本增加到x.(y+1)-SNAPSHOT。例如，版本1.0- snapshot作为版本1.0发布，而新的开发版本是版本1.1-SNAPSHOT。</p>
<h2 id="我如何使用插件"><a href="#我如何使用插件" class="headerlink" title="我如何使用插件?"></a>我如何使用插件?</h2><p>无论何时您想为Maven项目定制构建，都可以通过添加或重新配置插件来完成。<br>Maven 1.0用户注意:在Maven 1.0中，您将向Maven .xml添加一些preGoal，并向project.properties添加一些条目。在这里，情况有点不同。<br>对于本例，我们将配置Java编译器以允许JDK 5.0源代码。这是简单的添加到您的POM:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr></table></figure>

<p>您将注意到Maven中的所有插件看起来都很像依赖项——在某些方面确实如此。这个插件将自动下载和使用-包括一个特定的版本，如果你要求它(默认是使用最新可用的)。<br>configuration元素将给定的参数应用于编译器插件中的每个目标。在上面的例子中，编译器插件已经被用作构建过程的一部分，这只是改变了配置。还可以向流程添加新目标，并配置特定的目标。有关这方面的信息，请参阅构建生命周期的介绍。<br>要了解插件的可用配置，可以查看插件列表，并导航到正在使用的插件和目标。有关如何配置插件的可用参数的一般信息，请参阅配置插件的指南。</p>
<h2 id="如何向JAR添加资源"><a href="#如何向JAR添加资源" class="headerlink" title="如何向JAR添加资源?"></a>如何向JAR添加资源?</h2><p>另一个可以满足的常见用例是将资源打包到JAR文件中，它不需要修改上面的POM。对于这个常见的任务，Maven再次依赖于标准目录布局，这意味着通过使用标准Maven约定，您只需将这些资源放在标准目录结构中，就可以将资源打包到jar中。<br>您可以在下面的示例中看到，我们添加了<code>{basedir}/src/main/resources</code>目录中放置的任何目录或文件都打包在JAR中，从JAR的底部开始使用完全相同的结构。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">my</span>-app</span></pre></td></tr><tr><td class="code"><pre><span class="line">|<span class="comment">-- pom.xml</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">`<span class="comment">-- src</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |<span class="comment">-- main</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |   |<span class="comment">-- java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |   |   `<span class="comment">-- com</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |   |       `<span class="comment">-- mycompany</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |   |           `<span class="comment">-- app</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |   |               `<span class="comment">-- App.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |   `<span class="comment">-- resources</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |       `<span class="comment">-- META-INF</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    |           `<span class="comment">-- application.properties</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    `<span class="comment">-- test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        `<span class="comment">-- java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            `<span class="comment">-- com</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                `<span class="comment">-- mycompany</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    `<span class="comment">-- app</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                        `<span class="comment">-- AppTest.java</span></span></pre></td></tr></table></figure>

<p>在我们的例子中，我们有一个META-INF目录和一个应用程序。该目录中的属性文件。如果您打开Maven为您创建的JAR并查看它，您将看到以下内容:</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">|<span class="comment">-- META-INF</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|   |<span class="comment">-- MANIFEST.MF</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|   |<span class="comment">-- application.properties</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|   `<span class="comment">-- maven</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|       `<span class="comment">-- com.mycompany.app</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|           `<span class="comment">-- my-app</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|               |<span class="comment">-- pom.properties</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|               `<span class="comment">-- pom.xml</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">`<span class="comment">-- com</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    `<span class="comment">-- mycompany</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        `<span class="comment">-- app</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            `<span class="comment">-- App.class</span></span></pre></td></tr></table></figure>

<p>可以看到，<code>${basedir}/src/main/resources</code>的内容可以从JAR和我们的应用程序的底部开始找到。<code>application.properties</code>文件在<code>META-INF</code>目录中。您还会注意到其他一些文件，比如<code>META-INF/MANIFEST.MF</code>,以及<code>pom.xml</code> 和 <code>pom.properties</code>文件。这些都是Maven中生成JAR的标准配置。如果您选择，您可以创建自己的清单，但是Maven将在缺省情况下生成清单。(您还可以修改默认清单中的条目。这个我们以后再谈。)<code>pom.xml</code> 和<code>pom.properties</code>。属性文件打包在JAR中，因此Maven生成的每个构件都是自描述的，并且如果需要，还允许您在自己的应用程序中使用元数据。一个简单的用途可能是检索应用程序的版本。在POM文件上操作需要使用一些Maven实用程序，但是可以使用标准Java API使用这些属性，如下所示:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#Generated by Maven</span></pre></td></tr><tr><td class="code"><pre><span class="line">#Tue Oct <span class="number">04</span> <span class="number">15</span>:<span class="number">43</span>:<span class="number">21</span> GMT<span class="number">-05</span>:<span class="number">00</span> <span class="number">2005</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">version=<span class="number">1.0</span>-SNAPSHOT</span></pre></td></tr><tr><td class="code"><pre><span class="line">groupId=com.mycompany.app</span></pre></td></tr><tr><td class="code"><pre><span class="line">artifactId=my-app</span></pre></td></tr></table></figure>

<p>要将资源添加到单元测试的类路径中，除了将资源放入的目录为<code>${basedir}/src/test/resources</code>之外，遵循与向JAR添加资源相同的模式。此时，您将拥有一个项目目录结构，如下所示:</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">my-app</span></pre></td></tr><tr><td class="code"><pre><span class="line">|<span class="string">-- pom.xml</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">`-- src</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    </span>|<span class="string">-- main</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">   `-- com</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">       `-- mycompany</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">           `-- app</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">               `-- App.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    </span>|<span class="string">   `-- resources</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    </span>|<span class="string">       `-- META-INF</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    </span>|<span class="string">           </span>|<span class="string">-- application.properties</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    `-- test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">        </span>|<span class="string">-- java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">        </span>|<span class="string">   `-- com</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">        </span>|<span class="string">       `-- mycompany</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">        </span>|<span class="string">           `-- app</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">        </span>|<span class="string">               `-- AppTest.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">        `-- resources</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">            `-- test.properties</span></span></pre></td></tr></table></figure>

<p>在单元测试中，您可以使用如下简单的代码片段来访问测试所需的资源:</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="params">...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Retrieve resource</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">InputStream is = getClass().getResourceAsStream( <span class="string">"/test.properties"</span> );</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Do something with the resource</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="params">...</span></span></pre></td></tr></table></figure>

<h2 id="如何过滤资源文件"><a href="#如何过滤资源文件" class="headerlink" title="如何过滤资源文件?"></a>如何过滤资源文件?</h2><p>有时，资源文件需要包含一个只能在构建时提供的值。要在Maven中实现这一点，可以使用${}语法将包含值的属性引用放到资源文件中。属性可以是pom中定义的值之一。xml，用户设置中定义的值。xml，在外部属性文件或系统属性中定义的属性。<br>要让Maven在复制时过滤资源，只需将pom.xml中的资源目录的<code>filtering</code>设置为true:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Quick Start Archetype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>您将注意到，我们必须添加以前没有的 <code>build</code>, <code>resources</code> 和 <code>resource</code>元素。此外，我们必须显式地声明资源位于src/main/resources目录中。所有这些信息都是以前作为默认值提供的，但是因为用于<code>filtering</code>的默认值是false，所以我们必须将其添加到pom.xml中，以便覆盖该默认值并将<code>filtering</code>设置为true。<br>引用pom中定义的属性。属性名使用定义值的xml元素的名称，允许“pom”作为项目(根)元素的别名。因此<code>${project.name}</code>引用项目的名称，<code>${project.version}</code>引用项目的版本，<code>${project.build.finalName}</code>是指在打包构建的项目时创建的文件的最终名称，等等。请注意，POM的一些元素有默认值，因此不需要在<code>pom.xml</code>中显式地定义这些值。类似地，可以使用以“settings”开头的属性名引用用户<code>settings.xml</code>中的值(例如<code>${settings.localRepository}</code>引用用户的本地存储库的路径)。<br>为了继续我们的示例，让我们向<code>application.properties</code>添加几个属性(我们把它放在src/main/resources目录中)，当资源被过滤时，它的值将被提供:</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">application</span>.<span class="built_in">name</span>=$&#123;project.<span class="built_in">name</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">application</span>.<span class="built_in">version</span>=$&#123;project.<span class="built_in">version</span>&#125;</span></pre></td></tr></table></figure>

<p>有了它，您可以执行以下命令(process-resources是复制和过滤资源的构建生命周期阶段):</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">mvn <span class="built_in">process</span>-resources</span></pre></td></tr></table></figure>

<p>和<code>target/classes</code>下的<code>application.properties</code>(最终会进入jar)看起来是这样的:</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">application</span>.<span class="built_in">name</span>=Maven Quick Start Archetype</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">application</span>.<span class="built_in">version</span>=<span class="number">1.0</span>-SNAPSHOT</span></pre></td></tr></table></figure>

<p>要引用外部文件中定义的属性，只需在pom.xml中添加对该外部文件的引用。首先，让我们创建外部属性文件并调用它:</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">src/main/filters/<span class="built_in">filter</span>.properties:<span class="comment"># filter.properties</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">my.<span class="built_in">filter</span>.<span class="built_in">value</span>=hello!</span></pre></td></tr></table></figure>

<p>接下来，我们将在pom.xml中添加对这个新文件的引用:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Quick Start Archetype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">filter</span>&gt;</span>src/main/filters/filter.properties<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>然后，如果我们在应用程序中添加对该属性的引用。属性文件:</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">application.name</span>=<span class="variable">$&#123;project.name&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">application.version</span>=<span class="variable">$&#123;project.version&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">message</span>=<span class="variable">$&#123;my.filter.value&#125;</span></span></pre></td></tr></table></figure>

<p><code>mvn process-resources</code>命令的下一个执行将把我们的新属性值放入<code>application.properties</code>。作为定义my.filter.value 的替代方法。在外部文件中，您也可以在pom.xml的properties部分中定义value属性，您将得到相同的效果(注意，我不需要对<code>src/main/filters/filter.properties</code>的引用):</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Quick Start Archetype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">my.filter.value</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">my.filter.value</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>过滤资源还可以从系统属性中获取值;要么是内置到Java中的系统属性(比如<code>java.version</code> 或者<code>user.home</code>)。或在命令行上使用标准Java -D参数定义的属性。为了继续这个示例，让我们更改我们的应用程序。属性文件看起来像这样:</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"># application.properties</span></pre></td></tr><tr><td class="code"><pre><span class="line">java.<span class="keyword">version</span>=<span class="variable">$&#123;java</span>.<span class="keyword">version</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">command.<span class="keyword">line</span>.<span class="keyword">prop</span>=<span class="variable">$&#123;command</span>.<span class="keyword">line</span>.<span class="keyword">prop</span>&#125;</span></pre></td></tr></table></figure>

<p>现在，当您执行以下命令时(注意command.line.prop的定义)，<code>application.properties</code>将包含来自系统属性的值。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">mvn <span class="built_in">process</span>-resources <span class="string">"-Dcommand.line.prop=hello again"</span></span></pre></td></tr></table></figure>

<h2 id="我如何使用外部依赖"><a href="#我如何使用外部依赖" class="headerlink" title="我如何使用外部依赖?"></a>我如何使用外部依赖?</h2><p>您可能已经注意到我们作为示例使用的POM中有一个<code>dependencies</code>元素。实际上，您一直在使用外部依赖项，但在这里我们将更详细地讨论它是如何工作的。有关更详细的介绍，请参阅我们对依赖机制的介绍。<br>pom.xml的<code>dependencies</code>部分列出了我们的项目为了构建而需要的所有外部依赖项(无论是在编译时、测试时、运行时还是其他时候)。现在，我们的项目只依赖于JUnit(为了清晰起见，我去掉了所有的资源过滤):</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Quick Start Archetype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>对于每个外部依赖项，至少需要定义4个东西:groupId、artifactId、version和scope。groupId、artifactId和版本与构建该依赖项的项目的<code>pom.xml</code>中给出的版本相同。scope元素指示项目如何使用该依赖项，可以是<code>compile</code>、<code>test</code>和<code>runtime</code>等值。有关可以为依赖项指定的所有内容的更多信息，请参见项目描述符引用(<a href="https://link.juejin.im?target=https%3A%2F%2Fmaven.apache.org%2Fref%2F3.6.1%2Fmaven-model%2Fmaven.html">maven.apache.org/ref/3.6.1/m…</a>)。<br>有了这些关于依赖项的信息，Maven将能够在构建项目时引用依赖项。Maven从哪里引用依赖项?Maven查看本地存储库(<code>${user.home}/.m2/repository</code>是默认位置)来查找所有依赖项。在前一节中，我们将项目中的构件(my-app-1.0- snap .jar)安装到本地存储库中。一旦它安装在那里，另一个项目就可以将该jar引用为依赖项，只需将依赖项信息添加到它的pom.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-other-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>那么在其他地方构建的依赖关系呢?它们如何进入我的本地存储库?当项目引用本地存储库中不可用的依赖项时，Maven将从远程存储库下载该依赖项到本地存储库。您可能注意到Maven在构建第一个项目时下载了很多东西(这些下载是用于构建项目的各种插件的依赖项)。默认情况下，可以通过<a href="http://repo.maven.apache.org/maven2/找到(并浏览)Maven使用的远程存储库。您还可以设置自己的远程存储库(可能是您公司的一个中央存储库)来代替或附加使用默认的远程存储库。有关存储库的更多信息，请参阅存储库介绍。" target="_blank" rel="noopener">http://repo.maven.apache.org/maven2/找到(并浏览)Maven使用的远程存储库。您还可以设置自己的远程存储库(可能是您公司的一个中央存储库)来代替或附加使用默认的远程存储库。有关存储库的更多信息，请参阅存储库介绍。</a><br>让我们为项目添加另一个依赖项。假设我们在代码中添加了一些日志记录，并且需要添加log4j作为依赖项。首先，我们需要知道log4j的groupId、artifactId和版本。Maven中心上的适当目录称为/maven2/log4j/log4j。在该目录中有一个名为maven-metada .xml的文件。log4j的maven-metada .xml是这样的:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">metadata</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">versioning</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">versions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">versions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">versioning</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">metadata</span>&gt;</span></span></pre></td></tr></table></figure>

<p>从这个文件中，我们可以看到我们想要的groupId是“log4j”，而artifactId是“log4j”。我们看到有很多不同的版本值可供选择;现在，我们只使用最新版本1.2.12(一些maven-metada .xml文件也可能指定哪个版本是当前版本)。在maven-metada .xml文件旁边，我们可以看到与log4j库的每个版本对应的目录。在这些文件中，我们将找到实际的<strong>jar文件</strong>(例如log4j-1.2.12.jar)、<strong>pom文件</strong>(这是依赖项的pom.xml，表示它可能具有的任何进一步依赖项和其他信息)和另一个<strong>maven-metada .xml文件</strong>。还有一个<strong>md5文件</strong>对应于每个文件，其中包含这些文件的md5散列。您可以使用它对库进行身份验证，或者确定您可能已经在使用某个特定库的哪个版本。<br>现在我们知道了需要的信息，可以将依赖项添加到pom.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Quick Start Archetype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><p>Maven通过自动包含传递依赖项，避免了发现和指定您自己的依赖项所需的库。<br>通过从指定的远程存储库中读取依赖项的项目文件，可以简化此功能。通常，这些项目的所有依赖项都将在您的项目中使用，就像项目从父项目继承的依赖项或从依赖项继承的依赖项一样。<br>可以收集依赖项的级别数量没有限制。只有在发现循环依赖项时才会出现问题。<br>使用传递依赖关系，所包含的库的图可以快速增长得相当大。由于这个原因，有一些额外的功能限制哪些依赖关系包括在内:<br><strong>依赖项中介</strong>——当遇到多个版本作为依赖项时，它决定将选择工件的哪个版本。Maven选择“<strong>最近的定义</strong>”。也就是说，它使用依赖树中与项目最接近的依赖项的版本。您总是可以通过在项目的POM中显式声明一个版本来保证该版本。请注意，如果依赖项树中的两个依赖项版本具有相同的深度，则第一个声明将获胜。</p>
<blockquote>
<p>“最接近的定义”意味着所使用的版本将是依赖关系树中最接近您的项目的版本。例如，如果A、B和C的依赖关系定义为A -&gt; B -&gt; C -&gt; D 2.0和A -&gt; E -&gt; D 1.0，那么在构建A时将使用D 1.0，因为从A到D到E的路径更短。您可以在a中显式地向d2.0添加依赖项，以强制使用d2.0。</p>
</blockquote>
<p><strong>依赖关系管理</strong>——这允许项目作者直接指定工件的版本，当它们遇到传递依赖项或没有指定版本的依赖项时使用。在前面的示例中部分依赖直接添加到即使它是不能直接使用的a .相反,可以包括D作为依赖dependencyManagement部分和直接控制哪个版本的D时使用,或者是引用。<br><strong>依赖关系范围</strong>——这允许您只包含适合当前构建阶段的依赖关系。下面将对此进行更详细的描述。<br><strong>排除依赖关系</strong>——如果项目X依赖于项目Y，而项目Y依赖于项目Z，那么项目X的所有者可以使用“”exclusion”元素显式地排除项目Z作为依赖关系。<br><strong>可选依赖项</strong>——如果项目Y依赖于项目Z，项目Y的所有者可以使用“optional”元素将项目Z标记为可选依赖项。当项目X依赖于项目Y时，X将只依赖于Y，而不依赖于Y的可选依赖项Z。(将可选依赖项视为“默认排除”可能会有所帮助。)<br>虽然传递依赖项可以隐式地包含所需的依赖项，但显式地指定直接在源代码中使用的依赖项是一个很好的实践。这一最佳实践证明了它的价值，特别是当项目的依赖项更改其依赖项时。<br>例如,假设您的项目指定一个依赖另一个项目B, B和项目指定依赖项目C .如果你直接使用组件项目C,和你不指定项目C在您的项目中,它可能会导致构建失败当项目B突然更新/删除项目C的依赖。<br>直接指定依赖关系的另一个原因是，它为您的项目提供了更好的文档:只需阅读项目中的POM文件就可以了解更多信息。<br>Maven还提供了依赖关系:分析插件目标来分析依赖关系:它有助于使这一最佳实践更容易实现。</p>
<h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>依赖项的范围——<code>compile</code>, <code>runtime</code>, <code>test</code>, <code>system</code>和 <code>provided</code>。用于计算用于编译、测试等的各种类路径。它还帮助确定在这个项目的发行版中包含哪些工件。有关更多信息，请参见依赖机制。默认范围是compile。<br>依赖关系管理是Maven的一个核心特性。管理单个项目的依赖关系很容易。管理由数百个模块组成的多模块项目和应用程序的依赖关系是可能的。Maven在使用定义良好的类路径和库版本定义、创建和维护可重复构建方面帮助很大。<br>依赖范围用于限制依赖项的传递性，还用于影响用于各种构建任务的类路径。<br>有6种适用范围:<br><strong>compile</strong><br>这是默认范围，如果没有指定则使用。编译依赖项在项目的所有类路径中都可用。此外，这些依赖项将传播到依赖的项目。<br><strong>provided</strong><br>这很像<code>compile</code>，但表明您希望JDK或容器在运行时提供依赖项。例如，当为Java Enterprise Edition构建web应用程序时，您将对Servlet API和相关Java EE API的依赖scope设置为<code>provided</code>，因为web容器提供了这些类。此范围仅在编译和测试类路径上可用，且不可传递。<br><strong>runtime</strong><br>此范围指示此依赖项不是编译所需的，而是执行所需的。它位于运行时和测试类路径中，但不在编译类路径中。<br><strong>test</strong><br>此范围表明，应用程序的正常使用不需要依赖项，仅在测试编译和执行阶段可用。这个范围不是可传递的。<br><strong>system</strong><br>除了必须显式地提供包含它的JAR之外，此范围与<code>provided</code>的类似。工件总是可用的，并且不会在存储库中查找。<br><strong>import</strong><br>此范围仅在<code>部分的`pom`类型依赖项上受支持。它指示要用指定POM的</code>节中的有效依赖项列表替换依赖项。由于替换了依赖项，具有导入范围的依赖项实际上并不参与限制依赖项的传递性。<br>每个范围(import除外)都以不同的方式影响传递依赖关系，如下表所示。如果将依赖项设置为左列中的作用域，则该依赖项与第一行中的作用域的传递依赖项将导致主项目中的依赖项，其作用域列在交集处。如果没有列出范围，则意味着将省略依赖项。</p>
<table>
<thead>
<tr>
<th></th>
<th>compile</th>
<th>provided</th>
<th>runtime</th>
<th>test</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>compile(*)</td>
<td>-</td>
<td>runtime</td>
<td>-</td>
</tr>
<tr>
<td>provided</td>
<td>provided</td>
<td>-</td>
<td>provided</td>
<td>-</td>
</tr>
<tr>
<td>runtime</td>
<td>runtime</td>
<td>-</td>
<td>runtime</td>
<td>-</td>
</tr>
<tr>
<td>test</td>
<td>test</td>
<td>-</td>
<td>test</td>
<td>-</td>
</tr>
</tbody></table>
<p>(*)注意:这应该是运行时范围，以便所有编译依赖项必须显式列出。但是，如果您所依赖的库从另一个库扩展了一个类，那么这两个库必须在编译时可用。因此，即使编译时依赖项是传递的，它们仍然作为编译范围。</p>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>依赖项管理部分是集中化依赖项信息的机制。当您有一组继承公共父类的项目时，可以将所有关于依赖关系的信息放在公共POM中，并对子POMs中的构件有更简单的引用。通过一些例子可以很好地说明这种机制。给定这两个延伸相同父节点的POMs:<br>Project A::</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-a<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-c<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>excluded-artifact<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-a<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>Project B:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-c<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>war<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-a<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>这两个示例POMs共享一个公共依赖项，并且每个POMs都有一个重要的依赖项。这些信息可以像这样放在父POM中:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-a<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-c<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>excluded-artifact<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-c<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>war<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-a<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>然后两个孩子的poms变得简单多了:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-a<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-a<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">&lt;!-- This is not a jar dependency, so we must specify type. --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-c<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">&lt;!-- This is not a jar dependency, so we must specify type. --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>war<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-a<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">&lt;!-- This is not a jar dependency, so we must specify type. --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>注意:在这两个依赖项引用中，我们必须指定``元素。这是因为，针对dependencyManagement部分匹配依赖项引用的最小信息集实际上是{groupId、artifactId、type、classifier}。在许多情况下，这些依赖关系将引用没有分类器的jar构件。这允许我们将标识简写为{groupId, artifactId}，因为类型字段的缺省值是jar，缺省分类器是null。<br>依赖项管理部分的第二个非常重要的用途是控制传递依赖项中使用的工件的版本。例如，考虑以下项目:<br>Project A:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>A<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>A<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>d<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>Project B:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>A<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>B<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>d<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>当maven在项目B上运行时，工件a、b、c和d的1.0版本将被使用，而不考虑它们的pom中指定的版本。<br>a和c都声明为项目的依赖项，因此由于依赖项中介使用1.0版本。两者都有运行时范围，因为它是直接指定的。<br>b在b的父依赖项管理部分中定义，由于依赖项管理对于传递依赖项优先于依赖项中介，所以如果在a或c的pom中引用1.0版本，则选择1.0版本。b也有编译范围。<br>最后，由于d是在B的依赖项管理部分中指定的，如果d是a或c的依赖项(或传递依赖项)，那么将选择1.0版本——同样，因为依赖项管理优先于依赖项中介，而且当前pom的声明优先于其父声明。<br>有关依赖项管理标记的引用信息可从项目描述符引用获得。</p>
<h3 id="引入依赖项"><a href="#引入依赖项" class="headerlink" title="引入依赖项"></a>引入依赖项</h3><p>上一节中的示例描述了如何通过继承指定托管依赖项。然而，在较大的项目中，这可能是不可能完成的，因为项目只能从单个父级继承。为了适应这一点，项目可以从其他项目导入托管依赖项。这是通过将pom工件声明为具有“import”范围的依赖项来实现的。<br>Project B:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>B<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>A<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>d<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>假设A是前面示例中定义的pom，那么最终结果将是相同的。除了d之外，A的所有托管依赖项都将被合并到B中，因为d是在这个pom中定义的。<br>Project X:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>X<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>X<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>Project Y:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Y<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>Y<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>Project Z:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Z<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Z<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>X<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Y<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>在上面的例子中，Z从X和Y中导入托管依赖项。然而，X和Y都包含依赖项a。<br>这个过程是递归的。例如，如果X导入另一个pom Q，当Z被处理时，它将简单地显示Q的所有托管依赖项都在X中定义。<br>当用于定义相关工件的“库”时，导入是最有效的，这些工件通常是多项目构建的一部分。一个项目使用这些库中的一个或多个构件是相当常见的。然而，有时很难使用构件将项目中的版本与库中分发的版本保持同步。下面的模式说明了如何创建“物料清单”(BOM)供其他项目使用。<br>项目的根是BOM pom。它定义了将在库中创建的所有构件的版本。希望使用该库的其他项目应该将此pom导入其pom的dependencyManagement部分。</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">project1Version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">project1Version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">project2Version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">project2Version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;project1Version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;project2Version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></span></pre></td></tr></table></figure>

<p>父子项目以BOM pom作为父项目。这是一个普通的多项目pom。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>project1<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>project2<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>接下来是实际的项目poms:</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;project1Version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;project2Version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></span></pre></td></tr></table></figure>

<p>下面的项目展示了如何在另一个项目中使用库，而不必指定依赖项目的版本。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>use<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<h3 id="系统依赖"><a href="#系统依赖" class="headerlink" title="系统依赖"></a>系统依赖</h3><p><code>重要提示:这是不推荐的。</code><br>与范围系统的依赖关系总是可用的，并且不会在存储库中查找。它们通常用于告诉Maven JDK或VM提供的依赖关系。因此，系统依赖关系对于解决对工件的依赖关系特别有用，这些工件现在由JDK提供，但是在以前可以单独下载。典型的例子是JDBC标准扩展或Java身份验证和授权服务(JAAS)。<br>一个简单的例子是:</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="params">&lt;project&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="params">&lt;dependencies&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="params">&lt;dependency&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="params">&lt;groupId&gt;</span>javax.sql<span class="params">&lt;/groupId&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="params">&lt;artifactId&gt;</span>jdbc-stdext<span class="params">&lt;/artifactId&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="params">&lt;version&gt;</span><span class="number">2.0</span><span class="params">&lt;/version&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="params">&lt;scope&gt;</span>system<span class="params">&lt;/scope&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="params">&lt;systemPath&gt;</span>$&#123;java.home&#125;<span class="meta-keyword">/lib/</span>rt.jar<span class="params">&lt;/systemPath&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="params">&lt;/dependency&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="params">&lt;/dependencies&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="params">&lt;/project&gt;</span></span></pre></td></tr></table></figure>

<p>如果您的工件是由JDK的<code>tools.jar</code>提供的，系统路径定义如下:</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="params">&lt;project&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="params">&lt;dependencies&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="params">&lt;dependency&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="params">&lt;groupId&gt;</span>sun.jdk<span class="params">&lt;/groupId&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="params">&lt;artifactId&gt;</span>tools<span class="params">&lt;/artifactId&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="params">&lt;version&gt;</span><span class="number">1.5</span><span class="number">.0</span><span class="params">&lt;/version&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="params">&lt;scope&gt;</span>system<span class="params">&lt;/scope&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="params">&lt;systemPath&gt;</span>$&#123;java.home&#125;/..<span class="meta-keyword">/lib/</span>tools.jar<span class="params">&lt;/systemPath&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="params">&lt;/dependency&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="params">&lt;/dependencies&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="params">&lt;/project&gt;</span></span></pre></td></tr></table></figure>

<h2 id="Optional-amp-Exclusion"><a href="#Optional-amp-Exclusion" class="headerlink" title="Optional &amp; Exclusion"></a>Optional &amp; Exclusion</h2><p>本节讨论可选的依赖项和依赖项排除。这将帮助用户了解它们是什么、何时以及如何使用它们。它还解释了为什么排除是在每个依赖项的基础上而不是在POM级别进行的。</p>
<h3 id="可选依赖关系"><a href="#可选依赖关系" class="headerlink" title="可选依赖关系"></a>可选依赖关系</h3><p>当不可能(无论出于什么原因)将项目分割为子模块时，将使用可选依赖项。其思想是，一些依赖关系仅用于项目中的某些特性，如果不使用该特性，就不需要这些依赖关系。理想情况下，这样的特性将被划分为依赖于核心功能项目的子模块。这个新的子项目将只有非可选的依赖项，因为如果您决定使用子项目的功能，就需要所有这些依赖项。<br>然而，由于项目不能被分割(无论出于什么原因)，这些依赖项声明为可选的。如果用户希望使用与可选依赖项相关的功能，则必须在自己的项目中重新声明该可选依赖项。这不是处理这种情况的最清楚的方法，但是可选依赖项和依赖项排除都是权宜之计。</p>
<h4 id="为什么使用可选依赖项"><a href="#为什么使用可选依赖项" class="headerlink" title="为什么使用可选依赖项?"></a>为什么使用可选依赖项?</h4><p>可选依赖项节省空间和内存。它们防止有问题的jar(违反许可协议或导致类路径问题)被绑定到WAR、EAR、fat jar或类似的jar中。</p>
<h4 id="如何使用optional标签"><a href="#如何使用optional标签" class="headerlink" title="如何使用optional标签"></a>如何使用optional标签</h4><p>通过在依赖项声明中将``元素设置为true，可以将依赖项声明为可选:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- declare the dependency to be set as optional --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectA<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Project-A<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span> <span class="comment">&lt;!-- value will be true or false only --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<h4 id="可选依赖项如何工作"><a href="#可选依赖项如何工作" class="headerlink" title="可选依赖项如何工作?"></a>可选依赖项如何工作?</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Project</span>-A -&gt; <span class="keyword">Project</span>-B</span></pre></td></tr></table></figure>

<p>上面的图表说明项目a依赖于项目b。当A在其POM中将B声明为可选依赖项时，此关系保持不变。它就像一个普通的构建，其中Project-B将被添加到Project-A的类路径中。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Project</span>-X -&gt; <span class="keyword">Project</span>-A</span></pre></td></tr></table></figure>

<p>当另一个项目(project - x)在其POM中将project - a声明为依赖项时，依赖项的可选属性将生效。Project-B不包含在Project-X的类路径中。您需要在项目X的POM中直接声明它，以便将B包含在X的类路径中。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>假设有一个名为X2的项目，它具有与Hibernate类似的功能。它支持许多数据库，如MySQL、PostgreSQL和Oracle的几个版本。每个受支持的数据库都需要额外依赖于驱动程序jar。所有这些依赖项都需要在编译时构建X2。但是，您的项目只使用一个特定的数据库，其他数据库不需要驱动程序。X2可以将这些依赖项声明为可选的，这样当您的项目在其POM中将X2声明为直接依赖项时，X2支持的所有驱动程序不会自动包含在项目的类路径中。您的项目必须包含对它所使用的数据库的特定驱动程序的显式依赖。</p>
<h3 id="Dependency-Exclusions"><a href="#Dependency-Exclusions" class="headerlink" title="Dependency Exclusions"></a>Dependency Exclusions</h3><p>由于Maven临时解析依赖项，所以项目的类路径中可能包含不需要的依赖项。例如，某个较老的jar可能存在安全问题，或者与您正在使用的Java版本不兼容。为了解决这个问题，Maven允许您排除特定的依赖项。排除是针对POM中的特定依赖项设置的，并且针对特定的groupId和artifactId。当您构建项目时，该构件将不会通过声明排除的依赖项添加到项目的类路径中。</p>
<h4 id="如何使用dependency-exclusions"><a href="#如何使用dependency-exclusions" class="headerlink" title="如何使用dependency exclusions"></a>如何使用dependency exclusions</h4><p>在包含有问题jar的<code>元素中添加一个</code>元素。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectA<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Project-A<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span>  <span class="comment">&lt;!-- declare the exclusion here --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectB<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Project-B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<h4 id="依赖性排除是如何工作的，以及什么时候使用它-作为最后的手段"><a href="#依赖性排除是如何工作的，以及什么时候使用它-作为最后的手段" class="headerlink" title="依赖性排除是如何工作的，以及什么时候使用它(作为最后的手段!)"></a>依赖性排除是如何工作的，以及什么时候使用它(作为最后的手段!)</h4><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="type">Project</span>-<span class="type">A</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   -&gt; <span class="type">Project</span>-<span class="type">B</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        -&gt; <span class="type">Project</span>-<span class="type">D</span> &lt;! <span class="comment">-- This dependency should be excluded --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">              -&gt; <span class="type">Project</span>-<span class="type">E</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">              -&gt; <span class="type">Project</span>-<span class="type">F</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   -&gt; <span class="type">Project</span> <span class="type">C</span></span></pre></td></tr></table></figure>

<p>从图中可以看出，Project-A依赖于Project-B, Project-B依赖于Project-D。Project- D依赖于Project- E和F.默认情况下，Project A的类路径包括:</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">B, </span>C, D, E, F</span></pre></td></tr></table></figure>

<p>假设您不希望将项目D及其依赖项添加到项目A的类路径中，因为存储库中缺少了项目D的一些依赖项，而且您不需要项目b中依赖于项目D的功能。项目b的开发人员可以将依赖关系标记为项目d <code>true</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectD<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ProjectD<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure>

<p>不幸的是,他们没有。最后，您可以将其排除在您自己的POM中，用于项目a，如下所示:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectA<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Project-A<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectB<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Project-B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectD<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> <span class="comment">&lt;!-- Exclude Project-D from Project-B --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Project-D<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>如果您将Project-A部署到存储库中，并且Project-X声明了对Project-A的正常依赖关系，Project-D还会被排除在类路径之外吗?</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Project</span>-X -&gt; <span class="keyword">Project</span>-A</span></pre></td></tr></table></figure>

<p>答案是肯定的。Project-A已经声明它不需要Project-D来运行，所以它不会作为Project-A的传递依赖项引入。 现在，考虑项目x依赖于项目y，如下图所示:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Project</span>-X -&gt; <span class="keyword">Project</span>-Y</span></pre></td></tr><tr><td class="code"><pre><span class="line">               -&gt; <span class="keyword">Project</span>-B</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    -&gt; <span class="keyword">Project</span>-D</span></pre></td></tr><tr><td class="code"><pre><span class="line">                       ...</span></pre></td></tr></table></figure>

<p>Project-Y也依赖于Project-B，它确实需要Project-D所支持的特性。因此，它不会在依赖项列表中的Project-D上放置排斥。它还可能提供一个额外的存储库，从这个存储库可以解析Project-E。在这种情况下，重要的是不要在全局中排除Project-D，因为它是Project-Y的合法依赖项。<br>作为另一个场景，假设您不想要的依赖项是Project-E而不是Project-D。你如何排除它?见下图:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Project-A</span></pre></td></tr><tr><td class="code"><pre><span class="line">   -&gt; Project-B</span></pre></td></tr><tr><td class="code"><pre><span class="line">        -&gt; Project-D</span></pre></td></tr><tr><td class="code"><pre><span class="line">              -&gt; Project-E <span class="comment">&lt;!-- Exclude this dependency --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">              -&gt; Project-F</span></pre></td></tr><tr><td class="code"><pre><span class="line">   -&gt; Project C</span></pre></td></tr></table></figure>

<p>排除作用作用于声明它们的点以下的整个依赖关系图。如果您想排除Project-E而不是Project-D，只需将排除更改为指向Project-E，但不将排除移动到Project-D。您不能更改Project-D的POM。如果可以，您可以使用可选的依赖项而不是排除项，或者将Project-D分割为多个子项目，每个子项目只有正常的依赖项。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectA<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Project-A<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectB<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Project-B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectE<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> <span class="comment">&lt;!-- Exclude Project-E from Project-B --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Project-E<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<h4 id="为什么要在每个依赖项的基础上而不是在POM级别上进行排除"><a href="#为什么要在每个依赖项的基础上而不是在POM级别上进行排除" class="headerlink" title="为什么要在每个依赖项的基础上而不是在POM级别上进行排除"></a>为什么要在每个依赖项的基础上而不是在POM级别上进行排除</h4><p>这主要是为了确保依赖关系图是可预测的，并防止继承影响排除不应该排除的依赖关系。如果您使用了最后一种方法，并且不得不进行排除，那么您应该绝对确定哪些依赖项引入了不需要的传递依赖项。<br>如果您确实希望确保某个特定依赖项不会出现在类路径中，无论路径是什么，都可以将<a href="https://link.juejin.im?target=https%3A%2F%2Fmaven.apache.org%2Fenforcer%2Fenforcer-rules%2FbannedDependencies.html">禁止依赖项规则</a>配置为在发现有问题的依赖项时构建失败。当构建失败时，您需要在强制程序找到的每个路径上添加特定的排除。</p>
<h2 id="如何在远程存储库中部署jar"><a href="#如何在远程存储库中部署jar" class="headerlink" title="如何在远程存储库中部署jar ?"></a>如何在远程存储库中部署jar ?</h2><p>要将jar部署到外部存储库，您必须在pom.xml中配置存储库url，并在settings.xml中配置连接到存储库的身份验证信息。<br>下面是一个使用scp和用户名/密码身份验证的例子:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Quick Start Archetype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.codehaus.plexus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>plexus-utils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">filter</span>&gt;</span>src/main/filters/filters.properties<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">&lt;!--</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">   |</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">   |</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">   |</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">   --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>mycompany-repository<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>MyCompany Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>scp://repository.mycompany.com/repository/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>mycompany-repository<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">username</span>&gt;</span>jvanzyl<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">&lt;!-- Default value is ~/.ssh/id_dsa --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">privateKey</span>&gt;</span>/path/to/identity<span class="tag">&lt;/<span class="name">privateKey</span>&gt;</span> (default is ~/.ssh/id_dsa)</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">passphrase</span>&gt;</span>my_key_passphrase<span class="tag">&lt;/<span class="name">passphrase</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span></pre></td></tr></table></figure>

<p>注意,如果您正在连接到一个openssh ssh服务器的参数“PasswordAuthentication”设置sshd_confing为”no”,你必须输入你的密码每次用户名/密码身份验证(尽管您可以使用另一个ssh客户机登录输入用户名和密码)。在本例中，您可能希望切换到公钥身份验证。 如果在settings.xml中使用密码，应该小心。有关更多信息，请参见密码加密。（<a href="https://link.juejin.im?target=https%3A%2F%2Fmaven.apache.org%2Fguides%2Fmini%2Fguide-encryption.html%EF%BC%89">maven.apache.org/guides/mini…</a></p>
<h2 id="如何创建文档"><a href="#如何创建文档" class="headerlink" title="如何创建文档?"></a>如何创建文档?</h2><p>要开始使用Maven的文档系统，可以使用原型机制使用以下命令为现有项目生成站点:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">-DarchetypeGroupId</span>=org.apache.maven.archetypes \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">-DarchetypeArtifactId</span>=maven-archetype-site \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">-DgroupId</span>=com.mycompany.app \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attribute">-DartifactId</span>=my-app-site</span></pre></td></tr></table></figure>

<h2 id="我如何构建其他类型的项目"><a href="#我如何构建其他类型的项目" class="headerlink" title="我如何构建其他类型的项目?"></a>我如何构建其他类型的项目?</h2><p>注意，生命周期适用于任何项目类型。例如，回到基本目录，我们可以创建一个简单的web应用程序:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">-DarchetypeGroupId</span>=org.apache.maven.archetypes \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">-DarchetypeArtifactId</span>=maven-archetype-webapp \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">-DgroupId</span>=com.mycompany.app \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">-DartifactId</span>=my-webapp</span></pre></td></tr></table></figure>

<p>注意，这些必须都在一行上。这将创建一个名为my-webapp的目录，其中包含以下项目描述符:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-webapp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>my-webapp<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>注意``元素——这告诉Maven将构建为一个WAR。切换到webapp项目的目录，并尝试:</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">mvn <span class="class"><span class="keyword">package</span></span></span></pre></td></tr></table></figure>

<p>你会看到<code>target/my-webapp.war</code>被构建了，所有正常的步骤都被执行了。</p>
<h2 id="如何同时构建多个项目"><a href="#如何同时构建多个项目" class="headerlink" title="如何同时构建多个项目?"></a>如何同时构建多个项目?</h2><p>Maven内置了处理多个模块的概念。在本节中，我们将展示如何构建上面的WAR，并在一个步骤中包含前面的JAR。 首先，我们需要在前面两个目录中添加一个父pom.xml文件，所以它应该是这样的:</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">+- pom.xml</span></pre></td></tr><tr><td class="code"><pre><span class="line">+- my-app</span></pre></td></tr><tr><td class="code"><pre><span class="line">| +- pom.xml</span></pre></td></tr><tr><td class="code"><pre><span class="line">| +- src</span></pre></td></tr><tr><td class="code"><pre><span class="line">|   +- main</span></pre></td></tr><tr><td class="code"><pre><span class="line">|     +- java</span></pre></td></tr><tr><td class="code"><pre><span class="line">+- my-webapp</span></pre></td></tr><tr><td class="code"><pre><span class="line">| +- pom.xml</span></pre></td></tr><tr><td class="code"><pre><span class="line">| +- src</span></pre></td></tr><tr><td class="code"><pre><span class="line">|   +- main</span></pre></td></tr><tr><td class="code"><pre><span class="line">|     +- webapp</span></pre></td></tr></table></figure>

<p>您将创建的POM文件应该包含以下内容:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-webapp<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure>

<p>我们需要一个从webapp依赖于JAR，所以添加到<code>my-webapp/pom.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr></table></figure>

<p>最后，将以下``元素添加到子目录中的其他pom.xml文件中:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr></table></figure>

<p>现在,试试…从顶层目录运行:</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mvn </span>verify</span></pre></td></tr></table></figure>

<p>WAR现在已经在<code>my-webapp/target/my-webapp.war</code>中创建。JAR包括:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ jar tvf my-webapp/target/my-webapp<span class="number">-1.0</span>-SNAPSHOT.war</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">0</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">56</span> EST <span class="number">2005</span> META-INF/</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">222</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">54</span> EST <span class="number">2005</span> META-INF/MANIFEST.MF</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">0</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">56</span> EST <span class="number">2005</span> META-INF/maven/</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">0</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">56</span> EST <span class="number">2005</span> META-INF/maven/com.mycompany.app/</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">0</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">56</span> EST <span class="number">2005</span> META-INF/maven/com.mycompany.app/my-webapp/</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3239</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">56</span> EST <span class="number">2005</span> META-INF/maven/com.mycompany.app/my-webapp/pom.xml</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">0</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">56</span> EST <span class="number">2005</span> WEB-INF/</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">215</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">56</span> EST <span class="number">2005</span> WEB-INF/web.xml</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">123</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">56</span> EST <span class="number">2005</span> META-INF/maven/com.mycompany.app/my-webapp/pom.properties</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">52</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">56</span> EST <span class="number">2005</span> index.jsp</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">0</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">56</span> EST <span class="number">2005</span> WEB-INF/lib/</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2713</span> Fri Jun <span class="number">24</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">56</span> EST <span class="number">2005</span> WEB-INF/lib/my-app<span class="number">-1.0</span>-SNAPSHOT.jar</span></pre></td></tr></table></figure>

<p>这是怎么回事?首先，创建的父POM(称为<code>app</code>)有一个<code>pom</code>打包和定义的模块列表。这告诉Maven在一组项目上运行所有操作，而不是只运行当前的一个(要覆盖此行为，可以使用<code>--non-recursive</code>命令行选项)。<br>接下来，我们告诉WAR它需要<code>my-app</code> JAR。这做了一些事情:它使WAR中的任何代码在类路径上都可用(在本例中没有)，它确保JAR总是在WAR之前构建的，并指示WAR插件将JAR包含在其库目录中。<br>您可能已经注意到<code>junit-4.11.jar</code>是一个依赖项，但最终没有进入WAR。原因是<code>test</code>元素-它只用于测试，因此不像编译时依赖my-app那样包含在web应用程序中。<br>最后一步是包含父定义。这与Maven 1.0中您可能熟悉的扩展元素不同:这确保了即使项目是通过在存储库中查找而与父项目单独分布的，也始终能够找到POM。</p>
<h1 id="构建生命周期介绍"><a href="#构建生命周期介绍" class="headerlink" title="构建生命周期介绍"></a>构建生命周期介绍</h1><h2 id="构建生命周期基础知识"><a href="#构建生命周期基础知识" class="headerlink" title="构建生命周期基础知识"></a>构建生命周期基础知识</h2><p>Maven基于构建生命周期的核心概念。这意味着构建和分发特定工件(项目)的过程被清晰地定义了。<br>对于构建项目的人员来说，这意味着只需要学习一小组命令就可以构建任何Maven项目，POM将确保他们得到他们想要的结果。<br>有三个内置的构建生命周期:default、clean和site。<code>default</code>生命周期处理项目部署，<code>clean</code>生命周期处理项目清理，而<code>site</code>生命周期处理项目站点文档的创建。</p>
<h2 id="构建生命周期阶段组成"><a href="#构建生命周期阶段组成" class="headerlink" title="构建生命周期阶段组成"></a>构建生命周期阶段组成</h2><p>每个构建生命周期都由不同的构建阶段列表定义，其中一个构建阶段表示生命周期中的一个阶段。 例如，默认的生命周期包括以下几个阶段(完整的生命周期阶段列表，请参考生命周期参考):</p>
<ul>
<li><code>validate</code> -验证项目是正确的，并且所有必要的信息都是可用的</li>
<li><code>compile</code> - 编译项目的源代码</li>
<li><code>test</code> - 使用合适的单元测试框架测试编译后的源代码。这些测试不应该要求打包或部署代码</li>
<li><code>package</code> - 将编译后的代码以其可分发格式打包，例如JAR。</li>
<li><code>verify</code> - 对集成测试的结果进行任何检查，以确保满足质量标准</li>
<li><code>install</code> - 将包安装到本地存储库中，以便在本地的其他项目中作为依赖项使用</li>
<li><code>deploy</code> - 在构建环境中完成后，将最终的包复制到远程存储库，以便与其他开发人员和项目共享。</li>
</ul>
<p>这些生命周期阶段(加上这里没有显示的其他生命周期阶段)按顺序执行，以完成默认的生命周期。鉴于上面的生命周期阶段,这意味着当默认使用生命周期,Maven将首先验证项目,然后将试图编译源代码,运行这些测试,包二进制文件(如jar),运行集成测试方案,验证了集成测试,验证包安装到本地存储库,然后将安装包部署到远程存储库。</p>
<h3 id="常用命令行调用"><a href="#常用命令行调用" class="headerlink" title="常用命令行调用"></a>常用命令行调用</h3><p>在开发环境中，使用以下调用将构件构建并安装到本地存储库中。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mvn </span>install</span></pre></td></tr></table></figure>

<p>在执行安装之前，此命令按顺序执行每个默认的生命周期阶段(<code>validate</code>, <code>compile</code>, <code>package</code>等)。您只需要调用要执行的最后一个构建阶段，在这种情况下，<code>instal</code>l: 在构建环境中，使用以下调用干净地构建并将构件部署到共享存储库中。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mvn </span>clean deploy</span></pre></td></tr></table></figure>

<p>同一个命令可以在多模块场景中使用(例如，具有一个或多个子项目的项目)。Maven遍历每个子项目并执行clean，然后执行deploy(包括所有先前的构建阶段步骤)。</p>
<h3 id="构建阶段由插件目标组成"><a href="#构建阶段由插件目标组成" class="headerlink" title="构建阶段由插件目标组成"></a>构建阶段由插件目标组成</h3><p>然而，即使构建阶段负责构建生命周期中的特定步骤，它执行这些职责的方式也可能不同。这是通过声明绑定到那些构建阶段的插件目标来实现的。<br>插件目标表示一个特定的任务(比构建阶段更精细)，它有助于构建和管理项目。它可能被绑定到零个或多个构建阶段。不绑定到任何构建阶段的目标可以通过直接调用在构建生命周期之外执行。执行的顺序取决于调用目标和构建阶段的顺序。例如，考虑下面的命令。clean和package参数是构建阶段，而<code>dependency:copy-dependencies</code>是(插件的)目标。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">mvn clean dependency:<span class="keyword">copy</span>-<span class="keyword">dependencies</span> <span class="keyword">package</span></span></pre></td></tr></table></figure>

<p>如果这是执行,<code>clean</code> 阶段将首先执行(这意味着它将运行所有干净的前阶段生命周期,加上<code>clean</code>阶段本身),然后以<code>dependency:copy-dependencies</code>为目标,最后执行方案阶段(及其构建阶段之前的缺省生命周期)。<br>此外，如果一个目标被绑定到一个或多个构建阶段，那么该目标将在所有这些阶段中被调用。 此外，构建阶段还可以有零个或多个目标。如果构建阶段没有绑定目标，那么该构建阶段将不会执行。但如果它有一个或多个目标，它将执行所有这些目标。</p>
<h2 id="设置您的项目以使用构建生命周期"><a href="#设置您的项目以使用构建生命周期" class="headerlink" title="设置您的项目以使用构建生命周期"></a>设置您的项目以使用构建生命周期</h2><p>构建生命周期非常简单，可以使用，但是当您为项目构建Maven构建时，如何为每个构建阶段分配任务呢?</p>
<h3 id="Packaging"><a href="#Packaging" class="headerlink" title="Packaging"></a>Packaging</h3><p>第一种也是最常见的方法是通过同样命名的POM元素``设置项目的打包。一些有效的打包值是jar、war、ear和pom。如果没有指定打包值，则默认为jar。<br>每个包都包含一个要绑定到特定阶段的目标列表。例如，jar打包将绑定以下目标来构建默认生命周期的各个阶段。</p>
<table>
<thead>
<tr>
<th>Phase</th>
<th>plugin:goal</th>
</tr>
</thead>
<tbody><tr>
<td><code>process-resources</code></td>
<td><code>resources:resources</code></td>
</tr>
<tr>
<td><code>compile</code></td>
<td><code>compiler:compile</code></td>
</tr>
<tr>
<td><code>process-test-resources</code></td>
<td><code>resources:testResources</code></td>
</tr>
<tr>
<td><code>test-compile</code></td>
<td><code>compiler:testCompile</code></td>
</tr>
<tr>
<td><code>test</code></td>
<td><code>surefire:test</code></td>
</tr>
<tr>
<td><code>package</code></td>
<td><code>jar:jar</code></td>
</tr>
<tr>
<td><code>install</code></td>
<td><code>install:install</code></td>
</tr>
<tr>
<td><code>deploy</code></td>
<td><code>deploy:deploy</code></td>
</tr>
</tbody></table>
<p>这几乎是一组标准的绑定;然而，有些包装对它们的处理不同。例如，一个纯元数据的项目(打包值是pom)只将目标绑定到安装和部署阶段(对于一些打包类型的目标到构建阶段的完整列表，请参考生命周期引用)。<br>注意，对于某些可用的打包类型，您可能还需要在POM的``部分中包含一个特定的插件，并为该插件指定<code>true</code>。丛应用程序和丛服务打包提供了丛应用程序和丛服务打包。</p>
<h1 id="POM文件介绍"><a href="#POM文件介绍" class="headerlink" title="POM文件介绍"></a>POM文件介绍</h1><h2 id="什么是POM"><a href="#什么是POM" class="headerlink" title="什么是POM"></a>什么是POM</h2><p>项目对象模型或POM是Maven中的基本工作单元。它是一个XML文件，包含Maven用于构建项目的有关项目和配置细节的信息。它包含大多数项目的默认值。例如build目录，它是目标;源目录，即src/main/java;测试源目录，即src/test/java;等等。在执行任务或目标时，Maven在当前目录中查找POM。它读取POM，获取所需的配置信息，然后执行目标。<br>POM中可以指定的一些配置包括项目依赖项、可以执行的插件或目标、构建概要文件等等。还可以指定项目版本、描述、开发人员、邮件列表等其他信息。</p>
<h2 id="Super-POM"><a href="#Super-POM" class="headerlink" title="Super POM"></a>Super POM</h2><p>Super POM是Maven的默认POM。除非显式设置，否则所有POMs都会继承Super POM，这意味着在Super POM中指定的配置将由为项目创建的POMs继承。下面的代码片段是Maven 3.5.4的Super POM。</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Central Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Central Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>never<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$</span><span class="template-variable">&#123;project.basedir&#125;</span><span class="xml">/target<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$</span><span class="template-variable">&#123;project.build.directory&#125;</span><span class="xml">/classes<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$</span><span class="template-variable">&#123;project.artifactId&#125;</span><span class="xml">-$</span><span class="template-variable">&#123;project.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">testOutputDirectory</span>&gt;</span>$</span><span class="template-variable">&#123;project.build.directory&#125;</span><span class="xml">/test-classes<span class="tag">&lt;/<span class="name">testOutputDirectory</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>$</span><span class="template-variable">&#123;project.basedir&#125;</span><span class="xml">/src/main/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">scriptSourceDirectory</span>&gt;</span>$</span><span class="template-variable">&#123;project.basedir&#125;</span><span class="xml">/src/main/scripts<span class="tag">&lt;/<span class="name">scriptSourceDirectory</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>$</span><span class="template-variable">&#123;project.basedir&#125;</span><span class="xml">/src/test/java<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$</span><span class="template-variable">&#123;project.basedir&#125;</span><span class="xml">/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$</span><span class="template-variable">&#123;project.basedir&#125;</span><span class="xml">/src/test/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="comment">&lt;!-- <span class="doctag">NOTE:</span> These plugins will be removed from future versions of the super POM --&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="comment">&lt;!-- They are kept for the moment as they are very unlikely to conflict with lifecycle mappings (MNG-4453) --&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-antrun-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2-beta-5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-release-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$</span><span class="template-variable">&#123;project.build.directory&#125;</span><span class="xml">/site<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="comment">&lt;!-- <span class="doctag">NOTE:</span> The release profile will be removed from future versions of the super POM --&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>release-profile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>performRelease<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">build</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-sources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">                  <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar-no-fork<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">              <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-javadocs<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">                  <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">              <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">updateReleaseInfo</span>&gt;</span>true<span class="tag">&lt;/<span class="name">updateReleaseInfo</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></span></pre></td></tr></table></figure>

<blockquote>
<p>作者：lamar酱</p>
<p>来源：<a href="https://juejin.im/post/5d66477ae51d4561af16dd46" target="_blank" rel="noopener">https://juejin.im/post/5d66477ae51d4561af16dd46</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title>Java后端目前最常用的工具和框架</title>
    <url>/2019/12/26/Java%E5%90%8E%E7%AB%AF%E7%9B%AE%E5%89%8D%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E5%92%8C%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>本篇内容涵盖14个方面，涉及上百个框架和工具。会有你喜欢的，大概也会有你所讨厌的家伙。这是我平常工作中打交道最多的工具，大小公司都适用。如果你有更好的，欢迎留言补充。</p>
<a id="more"></a>

<h2 id="一、消息队列"><a href="#一、消息队列" class="headerlink" title="一、消息队列"></a>一、消息队列</h2><p><img src="http://image.winrains.cn/2019/08/20190829093426-ca111.png" alt="img"></p>
<p><strong>一个大型的分布式系统，通常都会异步化，走消息总线。</strong> 消息队列作为最主要的基础组件，在整个体系架构中，有着及其重要的作用。kafka是目前最常用的消息队列，尤其是在大数据方面，有着极高的吞吐量。而rocketmq和rabbitmq，都是电信级别的消息队列，在业务上用的比较多。2019年了，不要再盯着JMS不放了（说的就是臃肿的ActiveMQ）。<br>pulsar是为了解决一些kafka上的问题而诞生的消息系统，比较年轻，工具链有限。有些激进的团队经过试用，反响不错。<br>mqtt具体来说是一种协议，主要用在物联网方面，能够双向通信，属于消息队列范畴。</p>
<h2 id="二、缓存"><a href="#二、缓存" class="headerlink" title="二、缓存"></a>二、缓存</h2><p><img src="http://image.winrains.cn/2019/08/20190829093427-21d77.png" alt="img"></p>
<p>数据缓存是减少数据库压力的有效途径，有单机java内缓存，和分布式缓存之分。<br>对于单机来说，guava的cache和ehcache都是些熟面孔。<br>对于分布式缓存来说，优先选择的就是<code>redis</code>，别犹豫。由于redis是单线程的，并不适合高耗时操作。所以对于一些数据量比较大的缓存，比如图片、视频等，使用老牌的memcached效果会好的多。<br>JetCache是一个基于Java的缓存系统封装，提供统一的api和注解来简化缓存的使用。类似SpringCache，支持本地缓存和分布式缓存，是简化开发的利器。</p>
<h2 id="三、分库分表"><a href="#三、分库分表" class="headerlink" title="三、分库分表"></a>三、分库分表</h2><p><img src="http://image.winrains.cn/2019/08/20190829093428-37063.png" alt="img"></p>
<p>分库分表，几乎每一个上点规模的公司，都会有自己的方案。目前，推荐使用驱动层的<code>sharding-jdbc</code>，或者代理层的<code>mycat</code>。如果你没有额外的运维团队，又不想花钱买其他机器，那么就选前者。<br>如果分库分表涉及的项目不多，spring的动态数据源是一个非常好的选择。它直接编码在代码里，直观但不易扩展。<br>如果只需要<strong>读写分离</strong> ，那么mysql官方驱动里的replication协议，是更加轻量级的选择。<br><strong>上面的分库分表组件，都是大浪淘沙，最终的优胜品。这些组件不同于其他组件选型，方案一旦确定，几乎无法回退，所以要慎之又慎。</strong><br>分库分表是小case，准备分库分表的阶段，才是重点：也就是数据同步。</p>
<h2 id="四、数据同步"><a href="#四、数据同步" class="headerlink" title="四、数据同步"></a>四、数据同步</h2><p><img src="http://image.winrains.cn/2019/08/20190829093428-33f78.png" alt="img"></p>
<p>国内使用mysql的公司居多，但postgresql凭借其优异的性能，使用率逐渐攀升。<br><strong>不管什么数据库，实时数据同步工具，都是把自己模拟成一个从库，进行数据拉取和解析。</strong> 具体来说，mysql是通过binlog进行同步；postgresql使用wal日志进行同步。<br>对mysql来说，canal是国内用的最多的方案；类似的databus也是比较好用的工具。<br>现在，canal、maxwell等工具，都支持将要同步的数据写入到mq中，进行后续处理，方便了很多。<br>对于ETL（抽取、清洗、转换）来说，基本上都是source、task、sink路线，与前面的功能对应。gobblin、datax、logstash、sqoop等，都是这样的工具。<br>它们的主要工作，就是怎么方便的定义配置文件，编写各种各样的数据源适配接口等。这些ETL工具，也可以作为数据同步（尤其是全量同步）的工具，通常是根据<code>ID</code>，或者<strong>最后更新时间</strong> 等，进行处理。<br>binlog是实时增量工具，ETL工具做辅助。通常一个数据同步功能，需要多个组件的参与，他们共同组成一个整体。</p>
<h2 id="五、通讯"><a href="#五、通讯" class="headerlink" title="五、通讯"></a>五、通讯</h2><p><img src="http://image.winrains.cn/2019/08/20190829093430-2a85d.png" alt="img"></p>
<p>Java 中，netty已经成为当之无愧的网络开发框架，包括其上的socketio（不要再和我提mina了）。对于http协议，有common-httpclient，以及更加轻量级的工具okhttp来支持。<br>对于一个rpc来说，要约定一个通讯方式和序列化方式。json是最常用的序列化方式，但是传输和解析成本大，xml等文本协议与其类似，都有很多冗余的信息；avro和kryo是二进制的序列化工具，没有这些缺点，但调试不便。<br><strong>rpc是远程过程调用的意思</strong> ，其中，thrift、dubbo、gRPC默认都是二进制序列化方式的socket通讯框架；feign、hessian都是onhttp的远程调用框架。<br>对了，gRPC的序列化工具是protobuf，一个压缩比很高的二进制序列化工具。<br><strong>通常，服务的响应时间主要耗费在业务逻辑以及数据库上，通讯层耗时在其中的占比很小。可以根据自己公司的研发水平和业务规模来选择。</strong></p>
<h2 id="六、微服务"><a href="#六、微服务" class="headerlink" title="六、微服务"></a>六、微服务</h2><p><img src="http://image.winrains.cn/2019/08/20190829093431-82a4c.png" alt="img"></p>
<p>我们不止一次说到微服务，这一次我们从围绕它的一堆支持框架，来窥探一下这个体系。是的，这里依然是在说spring cloud。<br>默认的注册中心eureka不再维护，consul已经成为首选。nacos、zookeeper等，都可以作为备选方案。其中nacos带有后台，比较适合国人使用习惯。<br>熔断组件，官方的hystrix也已经不维护了。推荐使用resilience4j，最近阿里的sentinel也表现强劲。<br>对于调用链来说，由于OpenTracing的兴起，有了很多新的面孔。推荐使用jaeger或者skywalking。spring cloud集成的sleuth+zipkin功能稍弱，甚至不如传统侵入式的cat。<br>配置中心是管理多环境配置文件的利器，尤其在你不想重启服务器的情况下进行配置更新。目前，开源中做的最好的要数apollo，并提供了对spring boot的支持。disconf使用也较为广泛。相对来说，spring cloud config功能就局限了些，用的很少。</p>
<hr>
<p>网关方面，使用最多的就是nginx，在nginx之上，有基于lua脚本的openrestry。由于openresty的使用非常繁杂，所以有了kong这种封装级别更高的网关。<br>对于spring cloud来说，zuul系列推荐使用zuul2，zuul1是多线程阻塞的，有硬伤。spring-cloud-gateway是spring cloud亲生的，但目前用的不是很广泛。</p>
<h2 id="七、分布式工具"><a href="#七、分布式工具" class="headerlink" title="七、分布式工具"></a>七、分布式工具</h2><p><img src="http://image.winrains.cn/2019/08/20190829093432-cb97f.png" alt="img"></p>
<p>大家都知道分布式系统zookeeper能用在很多场景，与其类似的还有基于raft协议的etcd和consul。<br>由于它们能够保证极高的一致性，所以用作协调工具是再好不过了。<strong>用途集中在：配置中心、分布式锁、命名服务、分布式协调、master选举等场所。</strong><br>对于分布式事务方面，则有阿里的fescar工具进行支持。但如非特别的必要，还是使用<code>柔性事务</code>，追寻<code>最终一致性</code>，比较好。</p>
<h2 id="八、监控系统"><a href="#八、监控系统" class="headerlink" title="八、监控系统"></a>八、监控系统</h2><p><img src="http://image.winrains.cn/2019/08/20190829093433-c7b1d.png" alt="img"></p>
<p>监控系统组件种类繁多，目前，最流行的大概就是上面四类。<br>zabbix在主机数量不多的情况下，是非常好的选择。<br>prometheus来势凶猛，大有一统天下的架势。它也可以使用更加漂亮的grafana进行前端展示。<br>influxdata的influxdb和telegraf组件，都比较好用，主要是功能很全。<br>使用es存储的elkb工具链，也是一个较好的选择。我所知道的很多公司，都在用。</p>
<h2 id="九、调度"><a href="#九、调度" class="headerlink" title="九、调度"></a>九、调度</h2><p><img src="http://image.winrains.cn/2019/08/20190829093433-4bf36.png" alt="img"></p>
<p>大家可能都用过cron表达式。这个表达式，最初就是来自linux的crontab工具。<br>quartz是java中比较古老的调度方案，分布式调度采用数据库锁的方式，管理界面需要自行开发。<br>elastic-job-cloud应用比较广泛，但系统运维复杂，学习成本较高。相对来说，xxl-job就更加轻量级一些。中国人开发的系统，后台都比较漂亮。</p>
<h2 id="十、入口工具"><a href="#十、入口工具" class="headerlink" title="十、入口工具"></a>十、入口工具</h2><p><img src="http://image.winrains.cn/2019/08/20190829093434-2acc5.png" alt="img"></p>
<p>为了统一用户的访问路口，一般会使用一些入口工具进行支持。<br>其中，haproxy、lvs、keepalived等，使用非常广泛。<br>服务器一般采用稳定性较好的centos，并配备ansible工具进行支持，那叫一个爽。</p>
<h2 id="十一、OLT（A）P"><a href="#十一、OLT（A）P" class="headerlink" title="十一、OLT（A）P"></a>十一、OLT（A）P</h2><p><img src="http://image.winrains.cn/2019/08/20190829093435-9d501.png" alt="img"></p>
<p><strong>现在的企业，数据量都非常大，数据仓库是必须的。</strong><br>搜索方面，solr和elasticsearch比较流行，它们都是基于lucene的。solr比较成熟，稳定性更好一些，但实时搜索方面不如es。<br>列式存储方面，基于Hadoop 的hbase，使用最是广泛；基于LSM的leveldb写入性能优越，但目前主要是作为嵌入式引擎使用多一些。<br>tidb是国产新贵，兼容mysql协议，公司通过培训向外输出dba，未来可期。<br>时序数据库方面，opentsdb用在超大型监控系统多一些。druid和kudu，在处理多维度数据实时聚合方面，更胜一筹。<br>cassandra在刚出现时火了一段时间，虽然有facebook弃用的新闻，但生态已经形成，常年霸占数据库引擎前15名。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829093436-96406.png" alt="img"></p>
<h2 id="十二、CI-CD"><a href="#十二、CI-CD" class="headerlink" title="十二、CI/CD"></a>十二、CI/CD</h2><p><img src="http://image.winrains.cn/2019/08/20190829093436-f0047.png" alt="img"></p>
<p>为了支持持续集成和虚拟化，除了耳熟能详的docker，我们还有其他工具。<br>jenkins是打包发布的首选，毕竟这么多年了，一直是老大哥。当然，写Idea的那家公司，还出了一个叫TeamCity的工具，操作界面非常流畅。<br>sonar（注意图上的错误）不得不说是一个神器，用了它之后，小伙伴们的代码一片飘红，我都快被吐沫星子给淹没了。<br>对于公司内部来说，一般使用gitlab搭建git服务器。其实，它里面的gitlab CI，也是非常好用的。</p>
<h2 id="十三、问题排查"><a href="#十三、问题排查" class="headerlink" title="十三、问题排查"></a>十三、问题排查</h2><p><img src="http://image.winrains.cn/2019/08/20190829093437-f4198.png" alt="img"></p>
<p>java经常发生内存溢出问题。使用jmap导出堆栈后，我一般使用mat进行深入分析。<br>如果在线上实时分析，有arthas和perf两款工具。<br>当然，有大批量的linux工具进行支持。比如下面这些：<br><a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F9RbTGQ4k4s92mrSf2xJ5TQ">《Linux上，最常用的一批命令解析（10年精选）》</a></p>
<h2 id="十四、本地工具"><a href="#十四、本地工具" class="headerlink" title="十四、本地工具"></a>十四、本地工具</h2><p><img src="http://image.winrains.cn/2019/08/20190829093437-e085f.png" alt="img"></p>
<p>本地使用的jar包和工具，那就多了去了。下面仅仅提一下最最常用的几个。<br>数据库连接池方面，国内使用druid最多。目前，有号称速度最快的hikari数据库连接池，以及老掉牙的dbcp和c3p0。<br>json方面，国内使用fastjson最多，三天两头冒出个漏洞；国外则使用jackson多一些。它们的api都类似，jackson特性多一些，但fastjson更加容易使用。<br>工具包方面，虽然有各种commons包，guava首选。</p>
<blockquote>
<p>作者：小姐姐味道</p>
<p>来源：<a href="https://juejin.im/post/5d5375baf265da03b2152f3d" target="_blank" rel="noopener">https://juejin.im/post/5d5375baf265da03b2152f3d</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>Linux常用命令：vim技巧</title>
    <url>/2019/12/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%9Avim%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>研发线上使用最多的编辑器，就是<code>vi</code>。无论是最快查看某个文件内容，还是快速编辑某个文件，<code>vi</code>都能帮上忙。<br>软件世界貌似有一些非常长寿的东西，<code>vi</code>算是一个。本篇文章聚焦的是研发线上最常用的一些功能。至于安装插件，写一些脚本，那一般是在开发机上玩的，生产环境没有条件、也没有时间忍受你做这些增强。希望看完本文，能够对这款神器有一个大体印象。当然，熟练的使用还需要日常有意识的培养。</p>
<blockquote>
<p><code>vim</code>是<code>vi</code>的增强版，一般现代<code>linux</code>都不缺那几兆空间，所以预装的都是增强版，本文默认使用<code>vim</code>。</p>
</blockquote>
<a id="more"></a>

<h1 id="养成习惯"><a href="#养成习惯" class="headerlink" title="养成习惯"></a>养成习惯</h1><p><code>vim</code>最大的贡献就是它的<strong>按键系统</strong>。这也是为什么<strong>chrome</strong>、<strong>idea</strong>、<strong>atom</strong>等编辑器都会提供一个<code>vim mode</code>。<strong>笔者见过很多资深的程序员，包括架构师，习惯使用方向键去控制光标的移动**</strong>。<strong>这不能说不对，但这也抛弃了<code>vim</code>最大的精华所在，效率上低了一大截。坚持使用<code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>，你会感谢你今天的纠正。大脑和手指真的是有记忆，当你用的足够多，这也就成了你约定俗成的设定。<br><code>vim</code>另外一个特点就是</strong>带模式的**。一共四种模式，我们不需要记忆，只需要使用例子去理解即可。</p>
<h1 id="不要添乱"><a href="#不要添乱" class="headerlink" title="不要添乱"></a>不要添乱</h1><p>不要使用<code>vim</code>打开大文件，<code>vim</code>会一次性读取所有内容到内存，容易造成宿主机内存溢出。<br>打开文件前，可以使用<code>du -h</code>命令查看文件大小。一般，<code>100MB</code>以下为宜。</p>
<h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><p>以下操作在普通模式下执行，连续按键</p>
<h2 id="漫游"><a href="#漫游" class="headerlink" title="漫游"></a>漫游</h2><blockquote>
<p><strong>j</strong> 向下<br><strong>30j</strong> 向下移动30行<br><strong>k</strong> 向上<br><strong>h</strong> 向左<br><strong>l</strong> 向右<br><strong>0</strong> 到行首<br><strong>^</strong> 到行首第一个字符，如果前面有空格的话<br><strong>$</strong> 到行尾<br><strong>gg</strong> 快速到文件头<br><strong>G</strong> 快速到文件尾<br><strong>100G</strong> 跳转到第100行</p>
</blockquote>
<p><em>不建议在插入模式下进行光标移动，这很低效</em></p>
<h2 id="复制：y"><a href="#复制：y" class="headerlink" title="复制：y"></a>复制：y</h2><blockquote>
<p><strong>yy</strong> 复制一行<br><strong>10yy</strong> 向下复制10行<br><strong>yw</strong> 复制光标开始的一个单词<br><strong>y$</strong> 复制光标到行尾<br><strong>yfB</strong> 复制光标到第一个大写B中间的内容<br><strong>y2fB</strong> 复制光标到第二个大写B中间的内容</p>
</blockquote>
<h2 id="剪切-x"><a href="#剪切-x" class="headerlink" title="剪切: x"></a>剪切: x</h2><blockquote>
<p><strong>x</strong> 向剪切一个一个字符，如果是在行尾，则为向前剪切<br><strong>3x</strong> 剪切三个<br><strong>xp</strong> 非行尾交换两个字符，如从<code>bs</code>变成<code>sb</code></p>
</blockquote>
<h2 id="删除：d"><a href="#删除：d" class="headerlink" title="删除：d"></a>删除：d</h2><p><em>删除的内容会放到剪贴板，按<code>p</code>即可粘贴到其他地方</em></p>
<blockquote>
<p><strong>dd</strong> 删除一行<br><strong>200dd</strong> 删除200行<br><strong>dw</strong> 删除一个单词 （最喜欢啦）<br><strong>df”</strong> 删除到出现的第一个双引号</p>
</blockquote>
<h2 id="粘贴-p"><a href="#粘贴-p" class="headerlink" title="粘贴: p"></a>粘贴: p</h2><blockquote>
<p><strong>p</strong> 粘贴复制或剪切的内容<br><strong>3p</strong> 将复制或剪切的内容粘贴三次</p>
</blockquote>
<h1 id="可视化模式"><a href="#可视化模式" class="headerlink" title="可视化模式"></a>可视化模式</h1><h3 id="v-行模式，选择一些内容"><a href="#v-行模式，选择一些内容" class="headerlink" title="v 行模式，选择一些内容"></a><code>v</code> 行模式，选择一些内容</h3><p>可视化模式是非常有用的一种模式，在普通模式下按<strong>v</strong>即可进入。<br>使用<code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>进行漫游，选中相应的内容。<br>例子，选中一部分想要的内容，并删除。<br><img src="http://image.winrains.cn/2019/08/20190829093954-8c6f5.gif" alt="img"></p>
<h3 id="ctrl-v-块模式"><a href="#ctrl-v-块模式" class="headerlink" title="ctrl+v 块模式"></a><code>ctrl+v</code> 块模式</h3><blockquote>
<p>演示：将文件中的每一行添加到<code>ArrayList</code>中：</p>
</blockquote>
<p><img src="http://image.winrains.cn/2019/08/20190829093955-c3509.gif" alt="img"><br><strong>1)</strong> 在命令模式下，执行<code>%s/$/&quot;);/g</code>，在行尾追加数据<br><strong>2)</strong> 按<code>ESC</code>进入普通模式，并使用<code>gg</code>回到行首<br><strong>3)</strong> 按<code>ctrl+v</code>进入可视化模式，然后按<code>G</code>到文件尾<br><strong>4)</strong> 不要理会编辑器反应，按<code>I</code>进入插入模式，输入<code>list.add(&quot;</code><br><strong>5)</strong> 按<code>ESC</code>回到普通模式，可以发现以上输入已经在每一行生效了<br>块模式还可以完成列互换，貌似在<code>UE</code>里见过此神技。<br><img src="http://image.winrains.cn/2019/08/20190829093955-cd913.gif" alt="img"></p>
<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>上面的例子里已经展示了命令模式的进入模式。<strong>在普通模式下，输入<code>:</code>即可进入</strong>。</p>
<blockquote>
<p><strong>%s/$/sth/</strong> 在行尾追加sth<br><strong>%s/^M//g</strong> 替换掉dos换行符，<code>\^M</code>使用<code>ctrl+v  + Enter</code>即可输入<br><strong>:g/^\s*$/d</strong> 删除空行以及只有空格的行<br><strong>%s/#.*//g</strong> 删除<code>#</code>之后的字符</p>
</blockquote>
<p><em>没错，命令模式用的是正则，这些经验是通用的</em><br>你已经发现了，这大概就是针对编辑器窗口的<code>sed</code>命令。</p>
<h1 id="查找字符串"><a href="#查找字符串" class="headerlink" title="查找字符串"></a>查找字符串</h1><p><em>同样的，正则的知识也可以应用*</em><br>在普通模式下，按下<code>/</code>直接进入查找，输入相应的字符串按确定即可。</p>
<blockquote>
<p><strong>n</strong> 查找下一个匹配<br><strong>N</strong> 查找上一个匹配<br><strong>2n</strong> 查找下面第二个匹配</p>
</blockquote>
<p>如果觉得跳来跳去晕头转向，可以在命令模式下输入<code>set nu</code>开启行号。</p>
<h1 id="宏录制"><a href="#宏录制" class="headerlink" title="宏录制"></a>宏录制</h1><p>这可以说是<code>vim</code>的一个杀手锏了。拿上面的例子来说。<br>将文件中的每一行添加到<code>ArrayList</code>中。<br><img src="http://image.winrains.cn/2019/08/20190829093955-45b8b.gif" alt="img"><br><strong>1)</strong> 按下<code>gg</code>到行首<br><strong>2)</strong> 按下<code>qa</code>进行宏录制，<code>a</code>是我们起的一个标记名称<br><strong>3)</strong> 按<code>I</code>进入插入模式，输入<code>list.add(&quot;</code><br><strong>4)</strong> 按<code>ESC</code>进入普通模式，然后按<code>$</code>跳到行尾<br><strong>5)</strong> 按<code>j</code>进入下一行，然后按<code>^</code>回到行首<br><strong>6)</strong> 再次按下<code>q</code>结束宏录制<br><strong>7)</strong> 输入<code>@a</code>触发宏测试一下录制效果<br><strong>8)</strong> 输入<code>100@a</code>重复宏100次，也就是影响下面的100行<br><em>可以录制不同的多个宏，方便的进行批量操作</em></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>另外用的一些比较少的主要功能有</p>
<blockquote>
<p><strong>r</strong> 替换字符<br><strong>ggVG</strong> 全选<br><strong>u</strong> 恢复更改<br><strong>J</strong> 合并下一行<br><strong>gU</strong> 光标处转大写<br><strong>ggguG</strong> 整篇文章大写转化为小写<br><strong>%</strong> 跳转到下一个匹配,如在<code>上按`%`，则跳转到相应的</code><br><strong>:e /tmp/a</strong> 在同一个编辑器内打开<code>/tmp/a</code>文件。同一个编辑器的缓冲区是剪贴板是共享的，可以方便在多个文件中复制<br><strong>bp</strong> 跳转到上一个缓冲区<br><strong>bn</strong> 跳转到下一个缓冲区</p>
</blockquote>
<h1 id="退出编辑器"><a href="#退出编辑器" class="headerlink" title="退出编辑器"></a>退出编辑器</h1><blockquote>
<p><strong>wq</strong> 保存当前文件并退出<br><strong>wqa</strong> 保存所有文件并退出<br><strong>q!</strong> 不保存，直接退出<br><strong>qa!</strong> 有多个文件被打开，同时退出</p>
</blockquote>
<p>本篇文章只聚焦常用功能，帮助读者快速处理线上文本。至于更多的，也装不下，只有你自己去探索喽。<br><code>vim</code>的入门门槛比较高，幸运的是，用多了，你就无法释手了。</p>
<blockquote>
<p>作者：小姐姐养的狗</p>
<p>来源：<a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650518612&amp;idx=1&amp;sn=125c2cb9ee6d76a6817fb0ebc5a3c5e4&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650518612&amp;idx=1&amp;sn=125c2cb9ee6d76a6817fb0ebc5a3c5e4&amp;scene=21#wechat_redirect</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux技术</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令：sed技巧</title>
    <url>/2019/12/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%9Ased%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p><code>sed</code>命令应用广泛，使用简单，是快速文本处理的利器。它其实没多少技巧，背诵、使用是最合适的学习渠道，属于硬技能。但它又很复杂，因为高级功能太多。本篇不去关注sed的高级功能，仅对常用的一些操作，进行说明。<br>随着使用，你会发现它和<code>vim</code>的一些理念是想通的，正则表达式的语法也基本上一样，并没有多少学习成本。从个人视野和工作效率上来看，sed命令都是程序员必须掌握的一个重要工具。</p>
<blockquote>
<p>那些说可以现场google用法的，大多习惯将文本拷贝到excel里，慢慢磨洋工，遇到大批量文件更是手忙脚乱。不是一家人不进一家门，本文不是为你写的。</p>
</blockquote>
<a id="more"></a>

<h1 id="一个简单的入门"><a href="#一个简单的入门" class="headerlink" title="一个简单的入门"></a>一个简单的入门</h1><p><img src="http://image.winrains.cn/2019/08/20190829094951-ce583.jpeg" alt="http://image.winrains.cn/2019/08/20190829094951-ce583.jpeg"><br>如图，一个简单的sed命令包含三个主要部分：<code>参数</code>、<code>范围</code>、<code>操作</code>。要操作的文件，可以直接挂在命令行的最后。除了命令行，sed也可以通过-f参数指定一个sed脚本，这个属于高级用法，不做过多描述。<br>有些示例命令我会重复多次，聪明如你一定能发现其中规律，有时连解释都用不着。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p><strong>-n</strong> 这个参数是<code>--quiet</code>或者<code>--silent</code>的意思。表明忽略执行过程的输出，只输出我们的结果即可。<br>我们常用的还有另外一个参数 ：<code>-i</code>。</p>
<blockquote>
<p>使用此参数后，所有改动将在原文件上执行。你的输出将覆盖原文件。<strong>非常危险</strong>，一定要注意。</p>
</blockquote>
<h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p><strong>1,4</strong> 表示找到文件中1,2,3,4行的内容。<br>这个范围的指定很有灵性，请看以下示例（请自行替换图中的范围部分）。</p>
<blockquote>
<p><strong>5</strong> 选择第5行。<br><strong>2,5</strong> 选择2到5行，共4行。<br><strong>1~2</strong> 选择奇数行。<br><strong>2~2</strong> 选择偶数行。<br><strong>2,+3</strong> 和<code>2,5</code>的效果是一样的，共4行。<br><strong>2,$</strong> 从第二行到文件结尾。</p>
</blockquote>
<p>范围的选择还可以使用正则匹配。请看下面示例。</p>
<blockquote>
<p><strong>/sys/,+3</strong> 选择出现sys字样的行，以及后面的三行。<br><strong>/^sys/,/mem/</strong> 选择以sys开头的行，和出现mem字样行之间的数据。</p>
</blockquote>
<p>为了直观，下面的命令一一对应上面的介绍，范围和操作之间是可以有空格的。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">'5p'</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed -n <span class="string">'2,5 p'</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed -n <span class="string">'1~2 p'</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed -n <span class="string">'2~2 p'</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed -n <span class="string">'2,+3p'</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed -n <span class="string">'2,$ p'</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed -n <span class="string">'/sys/,+3 p'</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed -n <span class="string">'/^sys/,/mem/p'</span> <span class="keyword">file</span></span></pre></td></tr></table></figure>

<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>最常用的操作就是<code>p</code>，意思就是打印。比如，以下两个命令就是等同的：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cat</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed -n <span class="string">'p'</span> <span class="keyword">file</span></span></pre></td></tr></table></figure>

<p>除了打印，还有以下操作，我们来说常用的。</p>
<blockquote>
<p><strong>p</strong> 对匹配内容进行打印。<br><strong>d</strong> 对匹配内容进行删除。这个时候就要去掉<code>-n</code>参数了，想想为什么。<br><strong>w</strong> 将匹配内容写入到其他地方。</p>
</blockquote>
<p><code>a</code>,<code>i</code>,<code>c</code>等操作虽基本但使用少，不做介绍。我们依然拿一些命令来说明。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">'2,5 p'</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed    <span class="string">'2,5 d'</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed -n <span class="string">'2,5 w output.txt'</span> <span class="keyword">file</span></span></pre></td></tr></table></figure>

<p>我们来看一下sed命令都能干些啥，上点命令体验一下。<br>删除所有#开头的行和空行。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">sed -e <span class="string">'s/#.*//'</span> -e <span class="string">'/^$/ d'</span> <span class="keyword">file</span></span></pre></td></tr></table></figure>

<p>最常用的，比如下面这个。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">'2p'</span> <span class="regexp">/etc/g</span>roup</span></pre></td></tr></table></figure>

<p>表示打印group文件中的第二行。</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、参数部分 比如 -n</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span>、模式部分 比如'<span class="number">2</span>p'</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3</span>、文件，比如/etc/group</span></pre></td></tr></table></figure>

<p>那么我想一次执行多个命令，还不想写sed脚本文件怎么办？那就需要加-e参数。<br>sed的操作单元是<code>行</code>。</p>
<h1 id="替换模式"><a href="#替换模式" class="headerlink" title="替换模式"></a>替换模式</h1><p>以上是<code>sed</code>命令的常用匹配模式，但它还有一个强大的替换模式，意思就是查找替换其中的某些值，并输出结果。使用替换模式很少使用<code>-n</code>参数。<br><img src="http://image.winrains.cn/2019/08/20190829094952-73bc4.jpeg" alt="http://image.winrains.cn/2019/08/20190829094952-73bc4.jpeg"><br>替换模式的参数有点多，但第一部分和第五部分都是可以省略的。替换后会将<strong>整个文本</strong>输出出来。<br>前半部分用来匹配一些范围，而后半部分执行替换的动作。</p>
<h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>这个范围和上面的范围语法类似。看下面的例子。</p>
<blockquote>
<p><strong>/sys/,+3</strong> 选择出现sys字样的行，以及后面的三行。<br><strong>/^sys/,/mem/</strong> 选择以sys开头的行，和出现mem字样行之间的数据。</p>
</blockquote>
<p>具体命令为：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'/sys/,+3 s/a/b/g'</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed <span class="string">'/^sys/,/mem/s/a/b/g'</span> <span class="keyword">file</span></span></pre></td></tr></table></figure>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>这里的命令是指s。也就是substitute的意思。</p>
<h2 id="查找匹配"><a href="#查找匹配" class="headerlink" title="查找匹配"></a>查找匹配</h2><p>查找部分会找到要被替换的字符串。这部分可以接受纯粹的字符串，也可以接受正则表达式。看下面的例子。</p>
<blockquote>
<p><strong>a</strong> 查找范围行中的字符串<code>a</code>。<br><strong>[a,b,c]</strong> 从范围行里查找字符串a或者b或者c。</p>
</blockquote>
<p>命令类似：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'s/a/b/g'</span> <span class="built_in">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed <span class="string">'s/[a,b,c]/&lt;&amp;&gt;/g'</span> <span class="built_in">file</span><span class="comment">#这个命令我们下面解释</span></span></pre></td></tr></table></figure>

<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>是时候把找出的字符串给替换掉了。本部分的内容将替换查找匹配部分找到的内容。<br>可惜的是，这部分不能使用正则。常用的就是精确替换。比如把a替换成b。<br>但也有高级功能。和java或者python的正则api类似，sed的替换同样有<code>Matched Pattern</code>的含义，同样可以得到Group，不深究。常用的替位符，就是<code>&amp;</code>。<br><strong><code>&amp;</code></strong>号，再重复一遍。当它用在替换字符串中的时候，代表的是原始的查找匹配数据。</p>
<blockquote>
<p><strong>[&amp;]</strong> 表明将查找到的数据使用[]包围起来。<br><strong>“&amp;”</strong> 表明将查找的数据使用””包围起来。</p>
</blockquote>
<p>下面这条命令，将会把文件中的每一行，使用引号包围起来。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">sed <span class="symbol">'s</span>/.*/<span class="string">"&amp;"</span>/' <span class="keyword">file</span></span></pre></td></tr></table></figure>

<h2 id="flag-参数"><a href="#flag-参数" class="headerlink" title="flag 参数"></a>flag 参数</h2><p>这些参数可以单个使用，也可以使用多个，仅介绍最常用的。</p>
<blockquote>
<p><strong>g</strong> 默认只匹配行中第一次出现的内容，加上g，就可以全文替换了。常用。<br><strong>p</strong> 当使用了<code>-n</code>参数，<code>p</code>将仅输出匹配行内容。<br><strong>w</strong> 和上面的w模式类似，但是它仅仅输出有变换的行。<br><strong>i</strong> 这个参数比较重要，表示忽略大小写。<br><strong>e</strong> 表示将输出的每一行，执行一个命令。不建议使用，可以使用xargs配合完成这种功能。</p>
</blockquote>
<p>看两个命令的语法：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">'s/a/b/gipw output.txt'</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sed <span class="string">'s/^/ls -la/e'</span> <span class="keyword">file</span></span></pre></td></tr></table></figure>

<h2 id="好玩"><a href="#好玩" class="headerlink" title="好玩"></a>好玩</h2><p>由于正则的关系，很多字符需要转义。你会在脚本里做些很多<code>\\</code>，<code>\*</code>之类的处理。你可以使用<code>|^@!</code>四个字符来替换<code>\</code>。<br>比如，下面五个命令是一样的。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">sed '<span class="string">/aaa/s/</span>\<span class="string">/etc/</span>\<span class="string">/usr/g</span>' file</span></pre></td></tr><tr><td class="code"><pre><span class="line">sed '<span class="string">/aaa/s</span>@<span class="string">/etc</span>@<span class="string">/usr</span>@g' file</span></pre></td></tr><tr><td class="code"><pre><span class="line">sed '<span class="string">/aaa/s</span>^<span class="string">/etc</span>^<span class="string">/usr</span>^g' file</span></pre></td></tr><tr><td class="code"><pre><span class="line">sed '<span class="string">/aaa/s</span>|<span class="string">/etc</span>|<span class="string">/usr</span>|g' file</span></pre></td></tr><tr><td class="code"><pre><span class="line">sed '<span class="string">/aaa/s</span>!<span class="string">/etc</span>!<span class="string">/usr</span>!g' file</span></pre></td></tr></table></figure>

<p>注意：前半部分的范围是不能使用这种方式的。我习惯使用符号<code>@</code>。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>可以看到，正则表达式在命令行中无处不在。以下，紧做简要说明。</p>
<blockquote>
<p><strong>^</strong> 行首<br><strong>$</strong> 行尾<br><strong>.</strong> 单个字符<br><strong>*** 0个或者多个匹配<br>**+</strong> 1个或者多个匹配<br><strong>?</strong> 0个或者1个匹配<br><strong>{m}</strong> 前面的匹配重复m次<br><strong>{m,n}</strong> 前面的匹配重复m到n次<br><strong>\</strong> 转义字符<br><strong>[0-9]</strong> 匹配括号中的任何一个字符,or的作用<br>| or，或者<br><strong>\b</strong> 匹配一个单词。比如<code>\blucky\b</code> 只匹配单词lucky</p>
</blockquote>
<h2 id="参数i"><a href="#参数i" class="headerlink" title="参数i"></a>参数i</h2><p>上面已经简单介绍了参数i，它的作用是让操作在原文件执行。无论你执行了啥，原始文件都将会被覆盖。这是非常危险的。<br>通过加入一个参数，可以将原文件做个备份。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">sed -<span class="selector-tag">i</span><span class="selector-class">.bak</span> <span class="string">'s/a/b/'</span> file</span></pre></td></tr></table></figure>

<p>以上命令会对原file文件生效，并生成一个file.bak文件。强烈建议使用i参数同时指定bak文件。</p>
<h2 id="表演一下"><a href="#表演一下" class="headerlink" title="表演一下"></a>表演一下</h2><p>我们通过两个命令，来稍微看下sed和其他命令组合起来的威力。<br><strong>输出长度不小于50个字符的行</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sed</span> -n <span class="string">'/^.&#123;50&#125;/p'</span></span></pre></td></tr></table></figure>

<p><strong>统计文件中有每个单词出现了多少次</strong></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'s/ /\n/g'</span> <span class="keyword">file</span> | <span class="keyword">sort</span> | uniq -c</span></pre></td></tr></table></figure>

<p><strong>查找目录中的py文件，删掉所有行级注释</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span> ./ -name <span class="string">"*.py"</span> | xargs sed  -<span class="built_in">i</span>.bak <span class="string">'/^[ ]*#/d'</span></span></pre></td></tr></table></figure>

<p><strong>查看第5-7行和10-13行</strong></p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">sed -n -e '<span class="number">5</span>,<span class="number">7</span>p' -e '<span class="number">10</span>,<span class="number">13</span>p' file</span></pre></td></tr></table></figure>

<p><strong>仅输出ip地址</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">ip<span class="built_in"> route </span>show | sed -n <span class="string">'/src/p'</span> | sed -e <span class="string">'s/  */ /g'</span> | cut -d<span class="string">' '</span> -f9</span></pre></td></tr></table></figure>

<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>本文配合<a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&mid=2650518612&idx=1&sn=125c2cb9ee6d76a6817fb0ebc5a3c5e4&scene=21#wechat_redirect" target="_blank" rel="noopener">《Linux生产环境上，最常用的一套“vim“技巧》</a><br>一文，查看更佳，你会发现很多相似的东西，这和<code>KISS</code>原则是密不可分的。<br>sed还有一个精华就是<code>x</code>(Exchange)命令，但也属于高级功能。有些你可能在很多Makefile里见过了。sed甚至还可以写推箱子游戏，虽然代码很酷，但，脑回路完全不够用啊。</p>
<blockquote>
<p>作者：小姐姐养的狗</p>
<p>来源：<a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650519751&amp;idx=1&amp;sn=adef39cb108277731608069960692c77&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650519751&amp;idx=1&amp;sn=adef39cb108277731608069960692c77&amp;scene=21#wechat_redirect</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux技术</category>
      </categories>
      <tags>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令：awk技巧</title>
    <url>/2019/12/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%9Aawk%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>敢用自己的名字做软件名字的，都有非常强大的自信。比如，垠语言什么的。<br><code>awk</code>的命名得自于它的三个创始人姓别的首字母，都是<code>80来岁</code>的老爷爷了。当然也有四个人的组合：流行的GoF设计模式。但对于我这游戏爱好者来说，想到的竟然是三位一体，果然是不争气啊。<br>它长的很像C，为什么这么有名，除了它强大的功能，我们姑且认为<code>a</code>这个字母比较靠前吧。<code>awk</code>比<code>sed</code>简单，它更像一门编程语言。</p>
<a id="more"></a>

<h1 id="打印某一列"><a href="#打印某一列" class="headerlink" title="打印某一列"></a>打印某一列</h1><p>下面，这几行代码的效果基本是相同的：打印文件中的第一列。</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta">#Java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.println(aStr.split(<span class="string">" "</span>)[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#Python</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(aString.split(<span class="string">" "</span>)[<span class="number">0</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#cut 命令</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cut -d <span class="string">" "</span> -f1   file</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#awk命令</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">awk <span class="string">'&#123;print $1&#125;'</span> file</span></pre></td></tr></table></figure>

<p>这可能是awk最常用的功能了：<strong>打印文件中的某一列</strong>。它智能的去切分你的数据，不管是<code>空格</code>，还是<code>TAB</code>，大概率是你想要的。<br>对于csv这种文件来说，分隔的字符是<code>,</code>。AWK使用<code>-F</code>参数去指定。以下代码打印csv文件中的第1和第2列。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">awk</span> -F <span class="string">","</span>  <span class="string">'&#123;print <span class="variable">$1</span>,<span class="variable">$2</span>&#125;'</span> file</span></pre></td></tr></table></figure>

<p>由此，我们可以看出一个基本的awk命令的组成部分。<br><img src="http://image.winrains.cn/2019/08/20190829100428-4bf32.jpeg" alt="http://image.winrains.cn/2019/08/20190829100428-4bf32.jpeg"></p>
<blockquote>
<p><strong>一般的开发语言，数组下标是以0开始的，但awk的列<code>$</code>是以<code>1</code>开始的，而<code>0</code>指的是原始字符串。</strong></p>
</blockquote>
<h1 id="网络状态统计"><a href="#网络状态统计" class="headerlink" title="网络状态统计"></a>网络状态统计</h1><p>本小节，采用awk统计netstat命令的一些网络状态，来看一下awk语言的基本要素。netstat的输出类似于：<br><img src="http://image.winrains.cn/2019/08/20190829100429-f24aa.jpeg" alt="http://image.winrains.cn/2019/08/20190829100429-f24aa.jpeg"><br>其中，第6列，标明了网络连接所处于的网络状态。我们先给出awk命令，看一下统计结果。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">netstat</span>  <span class="string">-ant |</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">awk</span> <span class="string">' \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">BEGIN&#123;print</span>  <span class="string">"State","Count" &#125;  \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">/^tcp/</span> <span class="string">\</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">&#123;</span> <span class="string">rt[$6]++ &#125; \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">END&#123;</span>  <span class="string">for(i in rt)&#123;print i,rt[i]&#125;  &#125;'</span></span></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">State</span> <span class="string">Count</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">LAST_ACK</span> <span class="string">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">LISTEN</span> <span class="string">64</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">CLOSE_WAIT</span> <span class="string">43</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">ESTABLISHED</span> <span class="string">719</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">SYN_SENT</span> <span class="string">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">TIME_WAIT</span> <span class="string">146</span></span></pre></td></tr></table></figure>

<p>下面这张图会配合以上命令详细说明，希望你能了解awk的精髓。<br><img src="http://image.winrains.cn/2019/08/20190829100430-463b7.jpeg" alt="http://image.winrains.cn/2019/08/20190829100430-463b7.jpeg"><br>乍一看，好吓人的命令，但是很简单。awk和我们通常的程序不太一样，它分为四个部分。<br>1、<strong>BEGIN 开头部分</strong>，可选的。用来设置一些参数，输出一些表头，定义一些变量等。上面的命令仅打印了一行信息而已。<br>2、<strong>END 结尾部分</strong>，可选的。用来计算一些汇总逻辑，或者输出这些内容。上面的命令，使用简单的for循环，输出了数组rt中的内容。<br>3、<strong>Pattern 匹配部分</strong>，依然可选。用来匹配一些需要处理的行。上面的命令，只匹配tcp开头的行，其他的不进入处理。<br>4、<strong>Action 模块</strong>。主要逻辑体，按行处理，统计打印，都可以。</p>
<blockquote>
<p><strong>注意点</strong><br>1、awk的主程序部分使用单引号‘包围，而不能是双引号<br>2、awk的列开始的index是0，而不是1</p>
</blockquote>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>我们从几个简单的例子，来看下awk的作用。<br>1、输出Recv-Q不为0的记录</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">netstat</span> -ant | awk <span class="string">'<span class="variable">$2</span> &gt; 0 &#123;print&#125;'</span></span></pre></td></tr></table></figure>

<p>2、外网连接数，根据ip分组</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">netstat</span> -ant | awk <span class="string">'/^tcp/&#123;print <span class="variable">$4</span>&#125;'</span> | awk -F: <span class="string">'!/^:/&#123;print <span class="variable">$1</span>&#125;'</span> | sort | uniq -c</span></pre></td></tr></table></figure>

<p>3、打印RSS物理内存占用</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">top -b -n <span class="number">1</span> | awk 'NR&gt;<span class="number">7</span>&#123;rss+=$<span class="number">6</span>&#125;END&#123;print rss&#125;</span></pre></td></tr></table></figure>

<p>4、过滤（去掉）空白行</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">awk <span class="string">'NF'</span> <span class="keyword">file</span></span></pre></td></tr></table></figure>

<p>5、打印奇数行</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">awk <span class="comment">'a=!a' file</span></span></pre></td></tr></table></figure>

<p>6、输出行数</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">awk <span class="string">'END&#123;print NR&#125;'</span> <span class="keyword">file</span></span></pre></td></tr></table></figure>

<p>这些命令，是需要了解awk的一些内部变量的，接下来我们来介绍。</p>
<h1 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h1><h2 id="FS"><a href="#FS" class="headerlink" title="FS"></a>FS</h2><p>下面的两个命令是等价的 。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">awk -F ':'  '&#123;<span class="keyword">print</span> <span class="variable">$3&#125;</span>' <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">awk 'BEGIN&#123;FS=<span class="string">":"</span>&#125;&#123;<span class="keyword">print</span> <span class="variable">$3&#125;</span>' <span class="keyword">file</span></span></pre></td></tr></table></figure>

<p><strong>BEGIN块中的<code>FS</code>，就是内部变量，可以直接指定或者输出。</strong>如果你的文件既有用<code>,</code>分隔的，也有用<code>:</code>分割的，FS甚至可以指定多个分隔符同时起作用。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">FS</span>=<span class="string">"[,:|]"</span></span></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>OFS</strong> 指定输出内容的分割符，列数非常多的时候，简化操作。相似命令：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">awk -F ':' '&#123;<span class="keyword">print</span> <span class="variable">$1</span>,<span class="string">"-"</span>,<span class="variable">$2</span>,<span class="string">"-"</span>,<span class="variable">$4&#125;</span>' <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">awk 'BEGIN&#123;FS=<span class="string">":"</span>;OFS=<span class="string">"-"</span>&#125;&#123;<span class="keyword">print</span> <span class="variable">$1</span>,<span class="variable">$2</span>,<span class="variable">$4&#125;</span>' <span class="keyword">file</span></span></pre></td></tr></table></figure>

<p><strong>NF</strong> 列数。非常有用，比如，过滤一些列数不满足条件的内容。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">awk -F, <span class="string">'&#123;if(NF==3)&#123;print&#125;&#125;'</span> <span class="keyword">file</span></span></pre></td></tr></table></figure>

<p><strong>NR</strong> 行号，例如，下面两个命令是等价的。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cat</span> -<span class="keyword">n</span> <span class="keyword">file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">awk '&#123;<span class="keyword">print</span> NR,<span class="variable">$0&#125;</span>' <span class="keyword">file</span></span></pre></td></tr></table></figure>

<p><strong>RS</strong> 记录分隔标志<br><strong>ORS</strong> 指定记录输出的分隔标志<br><strong>FILENAME</strong> 当前处理的文件名称，在一次性处理多个文件时非常有用</p>
<h2 id="编程语言特性"><a href="#编程语言特性" class="headerlink" title="编程语言特性"></a>编程语言特性</h2><h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><p>从上面的代码可以看出，awk可以做一些简单的运算。它的语言简洁，不需要显示的定义变量的类型。<br>比如上面的<code>rt[$6]++</code>，就已经默认定义了一个叫做rt的hash(array?)，里面的key是网络状态，而value是可以进行运算的(+-*/%)。<br>包含一些内置的数学运算（有限)</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">log</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">sqrt</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">exp</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">sin</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">cos</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">atan2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">rand</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">srand</span></span></pre></td></tr></table></figure>

<h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><p>类似其他语言，awk也内置了很多字符串操作函数。它本来就是处理字符串的，所以必须强大。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">length</span><span class="params">(str)</span></span> #获取字符串长度</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">split</span><span class="params">(input-string,output-array,separator)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">substr</span><span class="params">(input-string, location, length)</span></span></span></pre></td></tr></table></figure>

<h3 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h3><p>awk是个小型的编程语言，看它的基本语法，如果你需要复杂一点的逻辑，请自行深入了解，包括一些时间处理函数：</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line"># logic</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">if</span>(<span class="meta">x</span>=a)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">if</span>(<span class="meta">x</span>=a)&#123;&#125;<span class="meta">else</span>&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">while</span>(<span class="meta">x</span>=a)&#123;break;<span class="meta">continue</span>;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">do</span>&#123;&#125;<span class="meta">while</span>(<span class="meta">x</span>=a)</span></pre></td></tr><tr><td class="code"><pre><span class="line">for(;;)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"># <span class="meta">array</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">arr[<span class="meta">key</span>] = value</span></pre></td></tr><tr><td class="code"><pre><span class="line">for(<span class="meta">key</span> <span class="meta">in</span> arr)&#123;arr[<span class="meta">key</span>]&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">delete</span> arr[<span class="meta">key</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">asort(arr) #简单排序</span></pre></td></tr></table></figure>

<p>据说，awk可以胜任所有的文本操作。因为它本身就是一门语言啊。</p>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>曾经使用awk编写过复杂的日志处理和统计程序。虽然比写<code>sed</code>舒畅了很多，但还是备受煎熬。更加上现在有各种nawk,gawk版本之间的区别，所以业务复杂度一增长，就习惯性的转向更加简洁、工具更全的python。<br>awk处理一些简单的文本还是极其方便的，最常用的还是打印某一列之类的，包括一些格式化输出。对于awk，要简单的滚瓜烂熟，复杂的耳熟能详，毕竟有些<code>大牛</code>，就喜欢写这种脚本呢。</p>
<blockquote>
<p>作者：小姐姐养的狗</p>
<p>来源：<a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650519843&amp;idx=1&amp;sn=fe4a5c405a35b42a850054eb4283ff40&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650519843&amp;idx=1&amp;sn=fe4a5c405a35b42a850054eb4283ff40&amp;scene=21#wechat_redirect</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux技术</category>
      </categories>
      <tags>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud核心组件</title>
    <url>/2019/12/26/Spring-Cloud%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>邻国相望，鸡犬之声相闻，民至老死不相往来。这个世界被小诸侯给切的七零八落，一锅乱麻。<br>而现实是，我的国家因为常年打仗，剩下的女人很多，需要打通远嫁他方的通道；而A国盛产长得和猪一样大的耗子，卖的很好。它们可以做成皮大氅，用来取暖。所以交流是在所难免的。<br>现实是这样的：<br>一、A国不知道B国身处何方，经常有牧民捧着藏宝图一样的破布，葬身在崎岖的山路上。<br>二、B国听不懂C国含糊不清的吐词，感觉他们在求救，等跑近一看，却发现其实是在骂娘。<br>三、C国生产的南瓜就知道卖给D国，剩下的都烂在了地里，E国都开始吃树皮了。<br>四、F国倒是远近闻名，但四面八方蜂拥而至的难民，让他们非常苦恼。其中，G国的难民，最是恶劣。<br>五、曾有其他大陆板块的使者，5年不得要领。见神粥大地现状，作诗一首：《真TM乱》。<br>作为一个穿越者，一个怜悯众生的剩人。我要留给这个世界一张蓝图，好让后人记住我的名字：xjjdog。同时，我也想起了，我为什么有这种这种强大的自信。<br>”回忆“的片段将我带回到21世纪。</p>
<a id="more"></a>

<h1 id="一、我要聊点技术了：单体应用"><a href="#一、我要聊点技术了：单体应用" class="headerlink" title="一、我要聊点技术了：单体应用"></a>一、我要聊点技术了：单体应用</h1><p>我们刚开始的服务，其实并没有那么复杂。我只有一台配置非常低的机器，我的应用，我的代码，我的聪明才智，全部在这一个小小的工程里面。由于我是搞it的，所以我的项目名字就叫<code>jisuanji</code>。有人说我用中文拼音做项目名，太那个。我不听，我就是这么命名。我还把公共模块叫<code>gg</code>，密码字段叫<code>mm</code>，谁管得着呢。<br>对，看下面的图，就是这么简单。项目能活到用nginx来做负载均衡这一步，就算是小成功了。<br><img src="http://image.winrains.cn/2019/08/20190829101552-5f8aa.png" alt="http://image.winrains.cn/2019/08/20190829101552-5f8aa.png"><br>这个时候，所有的代码就是一个整体，用户访问什么，我直接给就是。</p>
<h1 id="二、我拆成了两个服务"><a href="#二、我拆成了两个服务" class="headerlink" title="二、我拆成了两个服务"></a>二、我拆成了两个服务</h1><p>可能是我和我一样二的人有点多，我的项目访问量越来越大，这也许就叫臭味相投吧。我自己的开发速度，已经追不上头脑里的idea，是时候招个人对服务进行拆分了。<br>不能拆的太过火，所以刚开始，我把<code>jisuanji</code>拆成了两个服务。其中的服务B，仅仅部署了一个节点，因为它的压力还不是太大。即使这样，我不得不买上3台服务器来部署服务节点，真是肉痛。我这么抠门的人，数据库当然也是共用的。虽然有时候机器压力有点大，但暂时还死不了人。<br><img src="http://image.winrains.cn/2019/08/20190829101553-259b6.png" alt="http://image.winrains.cn/2019/08/20190829101553-259b6.png"><br>这个时候我就面临了一个选择问题：服务A要怎么访问服务B呢？<br>由于我搞过一段时间的webservice，首先就想到了它。但这玩意太重了，我还不如通过Http访问来的舒爽。通过HttpClient，或者OkHttp，我的服务A，现在可以直接模拟Http请求访问服务B了。<br>当团队里有第二个人，就开始吐槽我的项目了。以下是他罗列的，我的项目的罪状：1、复杂度太高，代码严重耦合；2、技术债务多，拍脑袋需求一箩筐；3、代码不规范，一坨屎；4、技术创新难，一个类几千行…<br>至于么？从一个服务拆成两个，就这么吐槽我。不过为了以后能拆出成百上千个服务，这口气我暂时忍了，毕竟我这人还是比较虚心的。</p>
<h1 id="三、乱成一锅粥了"><a href="#三、乱成一锅粥了" class="headerlink" title="三、乱成一锅粥了"></a>三、乱成一锅粥了</h1><p>等过去半年一看，好家伙，服务给我拆了了几十个。当我的同伴把系统结构图拿给我看，我直接懵逼了。我挑了9个能看的服务，画了张图。<br><img src="http://image.winrains.cn/2019/08/20190829101553-e20ea.jpeg" alt="http://image.winrains.cn/2019/08/20190829101553-e20ea.jpeg"><br>首先进行了业务拆分。比如支付业务，订单业务，用户中心，商品中心等，都组建了独立的团队。每个业务又进行了细分，拆分成不同的服务。<br>在这之间，进行了下面的改动：<br>一、有小伙伴写了个通用的HttpClient调用组件，自己的负载均衡策略。<br>二、有另外一个小伙伴，习惯protobuf，所以选了gRPC。<br>三、事实证明SOA还是有市场的，这不，就有几个服务的交互引入了webservice。<br>四、有人想要用RMI，被我及时发现、否决，腹死胎中了。<br>五、每次建个新服务，都需要更新一下excel，然后将这个excel周知出去。<br>现在的整个系统，简直是个四不像。什么通信方式都有，什么交互格式都不缺。拿最要命的D服务来说，光通讯模块，就引入了20几个jar包。如果应用扩展到上千个…My god…<br>更要命的是，这么多服务，每次上线一个模块都胆战心惊，因为它不知道到底会有什么连锁反应。<br>是时候叫出超级飞侠了。哦不，叫出微服务了。</p>
<h1 id="四、微服务来袭"><a href="#四、微服务来袭" class="headerlink" title="四、微服务来袭"></a>四、微服务来袭</h1><p>目前，最火的微服务框架，就是SpringCloud了。虽然netflix公司对某些组件的维护经常爽约，但有些核心组件还是非常经典的。</p>
<h2 id="1、注册中心：Eureka"><a href="#1、注册中心：Eureka" class="headerlink" title="1、注册中心：Eureka"></a>1、注册中心：Eureka</h2><p>服务A，怎么找到服务B，有很多种方式。比如你生活在一个小镇上，你问xjjdog是谁，老王可能认识他，但小李可能并不知晓；但小李认识老王，所以通过他最终也能找到xjjdog，只不过麻烦一些。<br>你可以随便拉小镇上的一个人，来问xjjdog是谁。你还会变戏法一样拿出一个小本本，把你认识的人，都告诉他们。当你脑残式的问了一个遍，到最后所有人都知道xjjdog了。<br>上面说的就是gossip协议。最终，你们都能够知道彼此，因为都是大嘴巴。比如小郑生了个孩子，过不了多少时间，全镇子的人都把这个孩子记录在本子上了。<br>用这种方式，服务都能够知道彼此，完成通信。</p>
<hr>
<p>可惜这并不美好，从小镇的东头跑到西头，需要很长时间。在这个时间里，小郑刚生的孩子可能因为先天疾病夭折了。我们需要一种信息集中度和实效性更高的方式。<br><strong>这就需要一个中心，那里的信息就是权威。</strong> 在SpringCloud体系中，最常用的注册中心就是Eureka。任何服务启动以后，都会把自己注册到Eureka的注册表中；当服务死亡的时候，也会通知Eureka。<br><img src="http://image.winrains.cn/2019/08/20190829101553-38112.jpeg" alt="http://image.winrains.cn/2019/08/20190829101553-38112.jpeg"><br>这样，当服务A想要找服务B的时候，只需要问一下Eureka Server就可以了，它什么都知道。<br>为了达到这个目的，还是要有一部分工作量的。且看下图。这个注册动作，是由一个叫做Eureka Client的组件来完成的。服务启动和关闭的时候，会通过这个组件推销自己；而当服务A想要调用服务B的时候，直接问Eureka Server就可以了。服务A拿到结果后，会把结果缓存在本地的注册表里。<br>你可以认为是一个拷贝。所以Eureka Server死掉后，并不影响服务A找到服务B。<br><img src="http://image.winrains.cn/2019/08/20190829101553-1da0e.jpeg" alt="http://image.winrains.cn/2019/08/20190829101553-1da0e.jpeg"></p>
<h2 id="2、负载均衡组件：Ribbon"><a href="#2、负载均衡组件：Ribbon" class="headerlink" title="2、负载均衡组件：Ribbon"></a>2、负载均衡组件：Ribbon</h2><p>现在问题来了。服务A拿到服务B的实例列表以后，发现有两台。</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">10.0.0.12</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">10.0.0.16</span></span></pre></td></tr></table></figure>

<p>接下来麻烦了，该调哪台机器呢？这就是SpringCloud中组件Ribbon的作用。其实<code>Round Robin</code>是一个通用的计算机术语。它是最常用的负载均衡策略，请求会均匀的分配给后面的每台服务器。<br>Ribbon工作时，会做下面四件事：<br>1、优先选择在一个Zone且负载较少的Eureka Server，进行连接。<br>2、定期从Eureka更新、过滤服务和实例列表。<br>3、根据负载均衡策略，从注册表中选择一个真正的实例地址。<br>4、通过RestClient对服务发起调用。<br><img src="http://image.winrains.cn/2019/08/20190829101553-68ea9.jpeg" alt="http://image.winrains.cn/2019/08/20190829101553-68ea9.jpeg"><br>可以看到，Ribbon背后，还是采用的Http协议进行交互。看以下代码，就可以直接实现对远端服务的调用。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@LoadBalanced</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">RestTemplate restTemplate()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">RestTemplate</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="code"><pre><span class="line"> @<span class="selector-tag">Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="selector-tag">RestTemplate</span> <span class="selector-tag">restTemplate</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">String</span> <span class="selector-tag">test</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">restTemplate</span><span class="selector-class">.getForObject</span>(<span class="string">"http://test-service/test"</span>, String.class);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Ribbon的Filter会查找<code>test-service</code>，并替换成相应的实例地址。<br><img src="http://image.winrains.cn/2019/08/20190829101554-51598.jpeg" alt="http://image.winrains.cn/2019/08/20190829101554-51598.jpeg"><br><strong>策略</strong><br>Ribbon不仅仅提供了轮询的策略，还有其他的，比如：<br>1、随机Random<br>2、根据响应时间加权<br>3、自定义<br>拿轮询来说，最终的选择逻辑就在RoundRobinRule类中。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> increment<span class="constructor">AndGetModulo(<span class="params">int</span> <span class="params">modulo</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (;;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">int</span> current = nextServerCyclicCounter.get<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">int</span> next = (current + <span class="number">1</span>) % modulo;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (nextServerCyclicCounter.compare<span class="constructor">AndSet(<span class="params">current</span>, <span class="params">next</span>)</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="3、为简化代码而生：Feign"><a href="#3、为简化代码而生：Feign" class="headerlink" title="3、为简化代码而生：Feign"></a>3、为简化代码而生：Feign</h2><p>可以看到，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。而且返回类型不安全，也表达不出什么语义。<br>其实，通过Ribbon方式，已经能够完成微服务之间的调用了。但SpringCloud的开发语言是Java，肯定要进行更加高级的封装，才能体现它的逼格。<br>Feign得益于Java的动态代理机制，最终封装出一套简洁的接口调用方式，将需要调用的其他服务的方法定义成抽象方法即可，不需要自己构建http请求。<br><img src="http://image.winrains.cn/2019/08/20190829101554-1cf4b.jpeg" alt="http://image.winrains.cn/2019/08/20190829101554-1cf4b.jpeg"><br>首先，Feign会根据@FerignClient注解，通过动态代理，创建一个动态代理类。接下来，你只要通过调用接口的方式，就可以构造上面提到的Ribbon调用参数，这个过程会自动填充。最后，通过构造的Ribbon请求，发起真正的调用，并通过反射组装返回值。<br>所以，Feign只是一层皮，最终还是要通过Ribbon进行调用。在我看来，把Ribbon和Feign合成一个组件，也是合理的。<br>它们有一个比较通用的名词，就叫做RPC（远程调用）。</p>
<h2 id="4、异常的保护伞：断路器"><a href="#4、异常的保护伞：断路器" class="headerlink" title="4、异常的保护伞：断路器"></a>4、异常的保护伞：断路器</h2><p>下面以一个支付请求为例，说一下不是风平浪静的情况下，服务会有什么反应。<br>每一个真正的支付请求，都会调用其他四个服务。首先，使用鉴权服务，获取用户的支付权限；然后，风控服务会做一些规则验证；为了更好的推销产品，会调用营销业务，获取一些推荐信息；最后，调用聚合支付服务，进行真正的支付。<br>其中，营销业务其实是可有可无的。让用户首先把钱花出去，是我们的首要任务。<br>考虑下面一种场景，营销业务由于系统故障或者负载问题，发生了大面积的不可用或者超时。然后，所有的请求都卡在了获取营销信息的代码上。<br>如图所示，鉴权和风控都已经通过了。因为一个旁路功能：营销业务，导致真正的支付无法进行。这个时候，如果有人调用支付请求，会发现支付请求也完蛋了。<br>因为它们最终都卡在了营销这一段小代码上。<br><img src="http://image.winrains.cn/2019/08/20190829101554-1f5f1.jpeg" alt="http://image.winrains.cn/2019/08/20190829101554-1f5f1.jpeg"><br>所以，对于营销业务这种不是链路上必备的服务提供者，要有一个手段，让它在发生问题的时候，隔离它一段时间。<br>负责这个功能的组件，就叫做Hystrix。<br>以我们编程的思维来说，这就是个if条件。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(服务发生问题) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="string">"暂时不要处理"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>但我们不能这么编码在业务代码里。所以Hystrix对每个服务开了一个线程池，并有比较复杂的规则，来控制这些出问题的服务的行为。比如，在2分钟内，直接返回营销业务的默认结果，而不是一直卡在那里。<br>这个过程，就叫熔断。就像电源一样，出了问题，先切断保险丝，别把电器给烧了。</p>
<h2 id="5、此网关非彼网关：zuul"><a href="#5、此网关非彼网关：zuul" class="headerlink" title="5、此网关非彼网关：zuul"></a>5、此网关非彼网关：zuul</h2><p>API网关是一个反向的<code>路由</code>，它屏蔽了内部的细节，为调用者提供了统一的入口。网关，其实是一堆<code>过滤器</code>的几何，可以实现一系列和业务无关的横切面功能。<br>熟悉Spring的都知道AOP，路由的一个功能，就是针对于分布式服务的一个AOP。<br>还是先说下网关的职责吧。简单罗列几个：<br>1、安全认证。提供统一的认证方式和鉴权功能，避免重复开发。<br>2、熔断，限流。针对问题服务，进行熔断操作；对流量进行预估，限制访问。<br>3、日志监控。统一流量入口，进行流量分析和监控。<br>4、屏蔽内部细节，对外提供一致的接口。<br>5、实现灰度。使用自定义策略实现分流，达到测试的目的。<br>网关的位置，大体就如下图。<br><img src="http://image.winrains.cn/2019/08/20190829101554-b8b41.jpeg" alt="http://image.winrains.cn/2019/08/20190829101554-b8b41.jpeg"><br>可以看到，我们平常用的nginx，就可以当作网关。但对于微服务来说，nginx的配置实在是太麻烦了。不是说nginx功能不够强大，而是因为它们不是一个体系的，就存在整合成本（比如kong）。<br>zuul就不一样了，它和SpringCloud的其他组件，是一家子的。一家子的，当然会特殊照顾。Zuul本身就是一个Servlet，外部请求经过一系列Filter后，会达到真正的服务。上面说的熔断器，就是高度集成的。</p>
<h2 id="6、一张聚合图"><a href="#6、一张聚合图" class="headerlink" title="6、一张聚合图"></a>6、一张聚合图</h2><p>有了上面关键组件，事情就明了的多了。我们把它放在一张图中，就是下面的样子。<br><img src="http://image.winrains.cn/2019/08/20190829101554-64356.png" alt="http://image.winrains.cn/2019/08/20190829101554-64356.png"><br>我们将其简化一下，就可以得到一张更简洁的图。可以看到，只需要3个关键点：<br>1、服务注册中心，统一管理所有服务的信息，默认组件是Eureka。<br>2、RPC，网络通信组件，服务A怎么调用服务B。在SpringCloud中，就是Ribbon+Feign。<br>3、网关，拆分的服务怎么暴露接口，最终见人的样子。默认组件是Zuul。<br><img src="http://image.winrains.cn/2019/08/20190829101554-df043.png" alt="http://image.winrains.cn/2019/08/20190829101554-df043.png"></p>
<h1 id="征途"><a href="#征途" class="headerlink" title="征途"></a>征途</h1><h2 id="一点道理"><a href="#一点道理" class="headerlink" title="一点道理"></a>一点道理</h2><p>处理杂乱无章的事情，最有效的途径，就是集权和中心化。集权和中心化的核心就是授权或者认同，否则注定失败。授权是对上，各位当权者应该同意我的做法，所以我需要用及其易懂的语言，去说服他们接受这个体系；认同，是对下，最好是从人民的抱怨声中，出具的改善措施，所以要权威专业。<br>和微服务一样，需要给一些陈旧的概念，强行赋予看起来比较自然的新意义。比如我把统一语言，叫做文化融合，就显得高大上一些。<br>第二个，就是把职责拆的足够细。够细才能够精，每个位置上的人才能各司其职。<br>还有一点，整个过程，要能够系统化，能够进行推演。如果一件事有着不可预料的后果，那是冒险家干的事情。</p>
<h2 id="一些途径"><a href="#一些途径" class="headerlink" title="一些途径"></a>一些途径</h2><p>为了对世界进行初步的了解，我成立了资源统计部，对山川河流进行了初步的勘查，绘制出有章可循的地图。对社会的现状和错综复杂的关系进行了摸底。我把这些信息出版成图书，遭到藏宝图收藏者们的嫉妒和憎恶。他们躲藏在不为人知的角落，龌龊行事。<br>我还选了一个自己觉得好听的方言，统一了每个诸侯国的语言。在推行的过程中，多次受到土著们强烈的反对，拒不改正。被我强行斩首了几个之后，以后的推行，就快的多了。<br>对于所有的重要商品，进行了集中管控。这个世界贵重的不是黄金，而是食物，所以我还修建了四通八达的道路和无孔不入的交易中心。从此之后，很少饿死过人。由于这部分是在我的控制范围内，所以进行的很顺畅。<br>G国的民风比较彪悍，经常发生暴力事件。这也难免，从刚开始，这个国家就难以驯化。好在缺了他们，这个系统也能循环的下去。前不久G国又发生了重大的事件，所有其他国家联合抵制，禁止G国国民入境。但时间是化解伤痛的良药，我估计这样的限制不会持续很久。<br>但糟粕还是有的。有人的地方，就有江湖，就有压迫。但这样的糟粕我是不想让其他人看到的。来访的使者，应该只能够看到歌舞升平、安居乐业，这注定了不能让他们和底层接触，否则就发现金玉其外败絮其中的现状了。<br>他们和外交官打的不亦乐乎，我很欣慰。</p>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>我清楚的知道，为了建立一个和谐自然的系统，曾经花费了多大的代价。这其中的组成部分，并不能总是完美无缺的运行。而且，在这个看似平和的整体上，就滋生了其他无数令人头痛的问题 ，不过这是另外一个话题了。<br>就是这样。我所做的一切，我所有的期望，只不过是为了：当新的机会在我身后，我能够从容的、华丽的转身。<br>这就是我为了有一天能够穿越，所做的准备。</p>
<blockquote>
<p>作者：小姐姐养的狗</p>
<p>来源：<a href="https://mp.weixin.qq.com/s/hjYAddJEqgg3ZWTJnPTD9g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/hjYAddJEqgg3ZWTJnPTD9g</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring Cloud</category>
      </categories>
  </entry>
  <entry>
    <title>微服务只是特定领域的子集</title>
    <url>/2019/12/26/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8F%AA%E6%98%AF%E7%89%B9%E5%AE%9A%E9%A2%86%E5%9F%9F%E7%9A%84%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<p>大家都在学SpringCloud，貌似学会了SC就牛逼哄哄，感觉不得了的样子。但微服务，在整个企业级应用中，只占了一小部分。微服务引入的问题比解决的问题还要多，你会遇到各种各样的bottleneck。<br>微服务解决的是计算节点的问题，然而根源却在存储节点。当业务规模变得越来越庞大，存储、编码、管理都会成为问题。<br>接下来我们谈一些放之四海而皆准的道理，不需要贴上”XX公司最佳实践”之类的标签。</p>
<a id="more"></a>

<p>下面是一张因数据扩张引出的微服务相关的图，简约但不简单。中小型公司只要有这些元素，就能玩的很好；大点的公司，因为规模太大，每个组件都会遇到瓶颈，所谓的专项的优化并不能脱离它的本质。<br>那我们开始。</p>
<blockquote>
<p>注意，这张图仅是主要数据路径，一个子集，其他的包括CDN、通讯层等，不在此列。</p>
</blockquote>
<p><img src="http://image.winrains.cn/2019/08/20190829102103-1918a.jpeg" alt="http://image.winrains.cn/2019/08/20190829102103-1918a.jpeg"><br>这张图并不包含某个特定领域的具体架构，属于一个整体性的概括。我们从数据库容量的瓶颈说起，看一下微服务在其中的比重。</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>用户数据要存储，就存在数据库。过去这么多年，NoSQL并不能消除开发人员的恐惧，所以，MySQL之类还是大多数公司的首选存储。<br>假设你的业务增长的很好，这个就有意思多了。项目开始，你的sql玩的越6，那么给后人埋的坑，越多。因为sql的功能太丰富了，一不小心，就炫技了。你会发现，林子越大，对sql的规范要求越高。一些官宣的特性，在公司内是严格禁止的。<br>市场发展很好，终于来报应了。以前的技巧变成了现在的累赘。慢查询、全文扫描，招招毙命。想要加缓存，结果发现无从下手；想要分库分表，结果发现表关系错综复杂。</p>
<h2 id="小表和宽表"><a href="#小表和宽表" class="headerlink" title="小表和宽表"></a>小表和宽表</h2><p>所以第一步，还是得去填坑。一个超过3个表的联合查询业务，大概率是不合理的。在加缓存和分库分表之前，还是得重新设计一下数据表。<br>忘掉什么数据库范式，我们将存在两类表：小表和宽表。<br>小表提供了最基本的数据，可能一个简单的KV就完成了。一些联合查询，是直接可以在程序里进行循环拼接的。程序里循环1000次10毫秒的查询，比单次查询耗费6秒要强的多。这就是分布式系统的特点，小耗时的批量查询，比hang在那里更加有生命力。<br>宽表通过冗余的方式，提供了某个重要功能常用的分析数据。这种表的字段一般都特别多，在写入时通过拼接获取冗余数据，一般用在读多写少的场景。<br>完成了这一步，接下来的工作才能进行。<br><img src="http://image.winrains.cn/2019/08/20190829102103-da4b8.jpeg" alt="http://image.winrains.cn/2019/08/20190829102103-da4b8.jpeg"></p>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>在<a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&mid=2650519118&idx=1&sn=fc4b92154cb9ab6dcec5b5544c6274aa&scene=21#wechat_redirect" target="_blank" rel="noopener">《“分库分表” ？选型和流程要慎重，否则会失控》</a>中，详细的说明了分库分表的选型，这里浅谈一下过程。<br>分库分表很可能会引入某一种中间件，因为仅仅将数据库分开还不行。HA，FailOver等特性，是同时需要的。<br>分库分为垂直分和水平分。垂直面向的是业务拆分，即将一部分表按照业务逻辑独立到其他库中；水平面向的是容量，即通过分库分表的模式使数据有一个扩张的途径。<br>数据一定要有一个可以度量的切分维度，否则就过于分散，或者过于倾斜，影响后续的处理。</p>
<h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><p>有分就有合，比如某些报表业务需要全量的数据。<br>不同业务通过共享数据库来共享数据不得不说是个非常蠢的主意。这个时候就需要一些数据同步工具。<br>数据同步组件可以说是一个公司的必备组件。有基于最后更新时间的高延迟同步工具，也有基于binlog的低延迟同步工具。有的公司为了稳定，还会有所谓的多机房同步。<br>数据同步最怕异常，因为大多数同步都有顺序性要求。一切运行良好的时候，大家皆大欢喜；一旦出现异常，就需要其他手段来保证异常期间的数据同步和延迟。<br>这都是些脏活，自动化有时候会适得其反，监控是第一位的。</p>
<h1 id="分层的数据存储"><a href="#分层的数据存储" class="headerlink" title="分层的数据存储"></a>分层的数据存储</h1><p>可以预见的是，即使你分库分表了，还是能很快达到瓶颈。分库分表后，你的一些统计功能可能还用不了了，在一些传统的管理系统上，这是硬伤。<br>一个分层的数据存储层是必要的。你的一些业务，可能一个分支走的是MySQL，换了另外一个条件就成了ES。<br>不同的DB做不同的事情。RDBMS只做原始数据的存储和查询，是扁平快的数据通道；特定的单机高性能DB，做一些汇聚和科学计算；分布式的类RT的存储，用来存储一些中等规模的数据，并提供一些中延迟的搜索功能；海量的存储系统，存储系统所有的历史记录，并提供离线分析功能。<br><img src="http://image.winrains.cn/2019/08/20190829102104-47af3.jpeg" alt="http://image.winrains.cn/2019/08/20190829102104-47af3.jpeg"><br>不要想着某一类存储解决所有的问题，那是骗人的。存储部分的复杂性不是普通的微服务能够相比的。<br>是谁保证了分层的数据存储设计呢？除了一部分通过MQ分发数据的业务，还是得靠我们的数据同步组件。</p>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>但DB的压力实在是太大了，我们不得不考虑缓存。缓存不能乱用，有两个原则：一个是缓存不能侵入业务，也就是不能带有业务逻辑；一个是缓存的命中率要高，否则适得其反。缓存是对高并发、高速接口的补充，是系统稳定性的必要不充分条件。<br>除了Redis等外置的缓存集群，jvm内缓存也是一个比较重要的场所。缓存的存在是因为I/O设备的缓慢，通常放在内存中，断电后即消失。<br>缓存涉及到源数据库和缓存数据库之间的数据同步。通常，更新源库时，会同时删掉缓存中相关的就数据，这样在下次读取的时候，能够读取到最新的数据。<br><img src="http://image.winrains.cn/2019/08/20190829102105-751f9.jpeg" alt="http://image.winrains.cn/2019/08/20190829102105-751f9.jpeg"><br>缓存限制最大的就是其容量问题，而且都贵的很。假如业务模式固定，一些kv存储使用LevelDB或者HBase等方案，会显著节约成本。</p>
<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>是时候将工程模块化了，毕竟上百个程序员共享一个代码库，风险已经很大了。<br>模块化通常会按照业务线进行拆分。比如，支付模块和报表模块的拆分。<br>模块拆分后，相似的模块会共享数据库。但更多的是通过冗余数据来解决，这样能将业务解耦，一部分出现问题，另一部分能够运行良好。好比你隔壁出了杀人案你第二天还能正常去上班。<br>模块之间要找到一种交互方式，比如使用HttpClient、OkHttp等。重要的是统一，统一了以后就有一个高大上的名字了：RPC。<br>一个小模块很有可能会发展为一个大的业务线，也有可能无人问津。<br><img src="http://image.winrains.cn/2019/08/20190829102106-adb82.jpeg" alt="http://image.winrains.cn/2019/08/20190829102106-adb82.jpeg"></p>
<h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><p>模块化之间另一种共享数据或者数据交互的方式就是MQ。除了有削峰等功效，MQ更多改变的是一种交互模式，一种对业务的解耦。<br>Kafka几乎每个公司都在用，最高能有几十万的吞吐量。RabbitMQ、RocketMQ等，更多用在可靠性要求非常高的场景，但比较耗机器。<br>MQ资源一般都要求绝对的高可靠，作为基础设施，一旦出问题，将带来非常大的事故。设计的时候要考虑异常情况下的数据处理流向，以及MQ恢复后的补偿策略。<br>MQ集群设计的比较小一些才合理，避免不同业务，不同可靠性级别的消息互相影响。MQ在业务上和功能上要相互隔离，做到最小服务集合。<br>为了避免MQ当机对正常业务产生影响，非重要链路上的MQ不能阻塞业务的正常进行，这种消息通常通过异步线程发送。</p>
<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><p>我们已经使用消息和模块化，将系统拆分成了多个工程。将这些工程使用统一的方式管理起来，统一其交互模式和在上面的治理，就是微服务的范畴。<br>微服务就是一个多模块项目规范化的过程。非规范的服务与微服务体系，是要共存一段时间的，如何保证新旧服务的替换，是一个管理上的问题。<br><img src="http://image.winrains.cn/2019/08/20190829102106-7252d.jpeg" alt="http://image.winrains.cn/2019/08/20190829102106-7252d.jpeg"></p>
<h2 id="功能组件"><a href="#功能组件" class="headerlink" title="功能组件"></a>功能组件</h2><p>根据SpringCloud的描述，一个服务想要被发现，需要将自己注册到通用的注册中心，其他服务可以从同一个地方，获取它的实例，进而调用。<br>而真正产生调用的功能，就是RPC的功能。RPC要考虑一系列比如超时、重拾、熔断等功能。在某些访问量非常大的节点，可能还要考虑预热。<br>RPC要能产生一些统计性数据，比如TPS、QPS、TP值等，很显然SpringCloud是缺乏的，我们要借助外部系统进行分析。<br>在外部请求流转到内部之前，需要经过一层网关的处理。像一些通用的操作，比如权限、限流、灰度等，就可以在网关层处理。<br><img src="http://image.winrains.cn/2019/08/20190829102106-c69d8.jpeg" alt="http://image.winrains.cn/2019/08/20190829102106-c69d8.jpeg"></p>
<h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h2><p>微服务最重要的特色就是其治理功能。服务治理的依据就是监控信息。通过统计每次调用的大小、耗时、分布，能够得出服务的大体拓扑。<br>通常以下信息最有用：<br>1、QPS，时间序列的qps分布，最高区间qps<br>2、平均响应时间，接口的平均响应时间，最大耗时和最小耗时<br>3、TP值分布，90%，99%等请求是在x耗时内完成<br>通过以上信息能够对服务进行画像。是扩容、缩容、专项治理的数据依据。<br>微服务引出的另外一个问题就是调用链，即某个请求的真实路径。分布式环境下的问题排查，会非常的困难，调用链能够帮助研发快速定位问题，并帮助理解业务的数据流向。<br>服务治理的目的就是找到不合理的请求和分布，比如某个接口耗时太长；某个接口请求量大，需要加缓存；某个功能依赖链条过长，需要业务优化等。<br>服务治理要借助大量的外部分析工具，更多通用的业务模型，需要大数据平台的支持。<br>我们把监控/报警也放在服务治理的部分，在<a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&mid=2650518678&idx=1&sn=8c8c9c40620b649cfb673ecef70a23f4&scene=21#wechat_redirect" target="_blank" rel="noopener">《这么多监控组件，总有一款适合你》</a>中，我们详细的讨论了监控部分的技术选择方案。</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p><img src="http://image.winrains.cn/2019/08/20190829102107-4e49e.jpeg" alt="http://image.winrains.cn/2019/08/20190829102107-4e49e.jpeg"><br>微服务产生的另外一个问题就是日志太过分散。一个核心的业务可能有上百个实例，你不可能打开100个终端去看日志。这就涉及到日志的收集。<br>日志归集功能就是把分散的日志集合到一个地方，它的主要挑战就是数据量。<br>通常日志分为两部分，一部分是全量的，可以通过定时同步等方式，备份到日志堡垒机或者hdfs中；一部分是过滤后的日志，比如一些异常信息，集中在某一个处理平台中进行报警。<br>很多研发喜欢将用户行为数据输出到日志文件中，这部分日志被收集后，会通过流计算或者离线计算，得到一些推荐和模型。日志信息进入了大数据处理的范畴，我们不过多描述。</p>
<h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><p>如果一个上点规模的公司，技术团队有什么值得一做的系统，那么发布系统算一个。<a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&mid=2650518647&idx=1&sn=8e616b6ff14d69d31db768a131b572c4&scene=21#wechat_redirect" target="_blank" rel="noopener">《发布系统有那么难么?》</a>中，谈了一种可能的模式。<br>发布系统就是给一堆脚本包了一张方便的皮。一些流程性工具、发布验证、CI/CD功能，很容易能够添加到自己的发布系统中。<br>很多微服务推广的文章中，谈到虚拟化（Docker）等，其实不是必须的。虚拟化减少了服务编排的时间，能够方便的进行扩容和缩容，但对监控、日志收集、网络拓扑等，要求比较高。建议是整个体系中的最后一步而不是第一步。<br>你的系统是否灵活，还与公司的文化环境相关。如果上个线走审批流程就需要一两周，那么做一个敏捷的持续集成系统就不是那么必要了。</p>
<h1 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h1><p>基础设施更多指的是运维体系，这是支撑整个系统健康发展的基石。我倾向于基础运维和基础架构不分家，因为它们的模式和文化，是一个公司研发环境的基石。<br><img src="http://image.winrains.cn/2019/08/20190829102107-6990d.jpeg" alt="http://image.winrains.cn/2019/08/20190829102107-6990d.jpeg"><br>另外一些基础组件，比如配置中心、调度中心、分布式锁管理等，都对可靠性有较高的要求。</p>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>这套体系看着简单，也有固定的解决方案。但问题就在于，许多公司从成立玩到倒闭，玩了那么多年，还是没玩明白。<br>真是可怜。</p>
<blockquote>
<p>作者：小姐姐养的狗</p>
<p>来源：<a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650519373&amp;idx=1&amp;sn=e3aeeb36137a8a20765ee6bfa902071c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650519373&amp;idx=1&amp;sn=e3aeeb36137a8a20765ee6bfa902071c&amp;scene=21#wechat_redirect</a></p>
</blockquote>
]]></content>
      <categories>
        <category>系统架构</category>
        <category>微服务</category>
      </categories>
  </entry>
  <entry>
    <title>WebSocket协议八问</title>
    <url>/2019/12/26/WebSocket%E5%8D%8F%E8%AE%AE%E5%85%AB%E9%97%AE/</url>
    <content><![CDATA[<p>WebSocket是一种比较新的协议，它是伴随着<code>html5</code>规范而生的，虽然还比较年轻，但大多主流浏览器都已经支持。它使用方便、应用广泛，已经渗透到前后端开发的各种场景中。<br>对http<code>一问一答</code>中二式流程的不满，催生了支持双向通信的<code>WebSocket</code>诞生。WebSocket是个<code>不太干净</code>协议。</p>
<hr>
<p><strong>本文包括以下内容：</strong><br>一、WebSocket协议只能浏览器发起么？<br>二、WebSocket和HTTP什么关系？<br>三、WebSocket和长轮询有什么区别？<br>四、如何创建一个连接？<br>五、如何处理数据？<br>六、如何使用Nginx做负载均衡？<br>七、java服务端怎么实现？<br>八、WebSocket能干些啥？</p>
<a id="more"></a>

<hr>
<h1 id="一、WebSocket协议只能浏览器发起么？"><a href="#一、WebSocket协议只能浏览器发起么？" class="headerlink" title="一、WebSocket协议只能浏览器发起么？"></a>一、WebSocket协议只能浏览器发起么？</h1><p>不是。目前此协议的受众的也不仅仅是web开发者。<br>WebSocket只是一种协议，它和http协议一样，使用<code>类似okhttp</code>的组件，可以在任何地方进行调用，甚至可以借助WebSocket实现<code>RPC</code>框架。<br><img src="http://image.winrains.cn/2019/08/32d70-20190829103016-beab0.jpeg" alt="http://image.winrains.cn/2019/08/32d70-20190829103016-beab0.jpeg"></p>
<h1 id="二、WebSocket和HTTP什么关系？"><a href="#二、WebSocket和HTTP什么关系？" class="headerlink" title="二、WebSocket和HTTP什么关系？"></a>二、WebSocket和HTTP什么关系？</h1><p>WebSocket和http一样，都是处于<code>OSI</code>模型中的最高层：<code>应用层</code>。<br><img src="http://image.winrains.cn/2019/08/1b408-20190829103017-8d087.jpeg" alt="http://image.winrains.cn/2019/08/1b408-20190829103017-8d087.jpeg"><br>WebSocket借助<code>http</code>协议进行握手，握手成功后，就会变身为<code>TCP通道</code>，从此与http不再相见。<br>使用netstat或者ss，能够看到对应的连接，它与处于抽象层的socket，在外观上没有区别。</p>
<h1 id="三、WebSocket和长轮询有什么区别？"><a href="#三、WebSocket和长轮询有什么区别？" class="headerlink" title="三、WebSocket和长轮询有什么区别？"></a>三、WebSocket和长轮询有什么区别？</h1><p>长轮询，就是客户端发送一个请求，服务端将一直在这个连接上等待（当然有一个超长的超时时间），直到有数据才返回，它依然是一个一问一答的模式。比如著名的comted。<br>WebSocket在握手成功后，就是<code>全双工</code>的TCP通道，数据可以主动从服务端发送到客户端，处于链接两端的应用没有任何区别。<br>WebSocket创建的连接和Http的长连接是不一样的。由于Http长连接底层依然是Http协议，所以它还是一问一答，只是Hold住了一条命长点的连接而已。<br>长轮询和Http长连接是阻塞的I/O，但WebSocket可以是非阻塞的（具体是多路复用）。<br><img src="http://image.winrains.cn/2019/08/d701e-20190829103017-1ff82.jpeg" alt="http://image.winrains.cn/2019/08/d701e-20190829103017-1ff82.jpeg"></p>
<h1 id="四、如何创建一个连接？"><a href="#四、如何创建一个连接？" class="headerlink" title="四、如何创建一个连接？"></a>四、如何创建一个连接？</h1><p>WebSocket的连接创建是借助Http协议进行的。这样设计主要是考虑兼容性，在浏览器中就可以很方便的发起请求，看起来比较具有迷惑性。<br>下图是一个典型的由浏览器发起的ws请求，可以看到和http请求长的是非常相似的。但是，它只是请求阶段长得像而已：<br><img src="http://image.winrains.cn/2019/08/6dda7-20190829103017-cf6d8.jpeg" alt="http://image.winrains.cn/2019/08/6dda7-20190829103017-cf6d8.jpeg"><br>请求的地址，一般是：<code>ws://\*\*\*</code>，或者是使用了SSL/TLS加密的安全协议<code>wss:</code>，用来标识是WebSocket请求。<br>1、 首先，通过Http头里面的<code>Upgrade</code>域，请求进行协议转换。如果服务端支持的话，就可以切换到WebSocket协议。简单点讲：连接已经在那了，通过握手切换成ws协议，就是切换了连接的一个状态而已。<br>1、<code>Connection</code>域可以认为是与<code>Upgrade</code>域配对的头信息。像nginx等代理服务器，是要先处理Connection，然后再发起协议转换的。<br>Sec-WebSocket-Key 是随机的字符串，服务器端会用这些数据来构造出一个 SHA-1 的信息摘要。如此操作，可以尽量避免普通 HTTP 请求被误认为 WebSocket 协议。<br>其他的，像Sec-WebSocket*字样的头信息，表明了客户端支持的子协议以及其他信息。像loT中很流行的mqtt，就可以作为WebSocket的子协议。<br><img src="http://image.winrains.cn/2019/08/77963-20190829103017-eb89d.jpeg" alt="http://image.winrains.cn/2019/08/77963-20190829103017-eb89d.jpeg"><br>使用javascript，可以很容易连接一个WebSocket服务端。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="actionscript">  <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:80'</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="actionscript">  ws.onopen = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'ws onopen'</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="actionscript">    ws.send(<span class="string">'from client: hello'</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="actionscript">  ws.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'ws onmessage'</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'from server: '</span> + e.data);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr></table></figure>

<h1 id="五、如何处理数据？"><a href="#五、如何处理数据？" class="headerlink" title="五、如何处理数据？"></a>五、如何处理数据？</h1><p>WebSocket是通过事件通知的方式运行的。它包含四个事件和两个动作（发送和关闭）。<br><strong>WebSocket的事件</strong></p>
<table>
<thead>
<tr>
<th>事件</th>
<th>钩子</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>open</td>
<td>onopen</td>
<td>连接建立时触发</td>
</tr>
<tr>
<td>message</td>
<td>onmessage</td>
<td>客户端接收服务端数据时触发</td>
</tr>
<tr>
<td>error</td>
<td>onerror</td>
<td>通信发生错误时触发</td>
</tr>
<tr>
<td>close</td>
<td>onclose</td>
<td>连接关闭时触发</td>
</tr>
</tbody></table>
<p>数据可直接通过<code>Socket.send()</code>方法进行传输。<br>通过chrome的Inspect-&gt;Network-&gt;WS，可以看到页面上的WebSocket连接。如图Opcode为2，表明它是一个二进制帧。<br><img src="http://image.winrains.cn/2019/08/eb9c2-20190829103018-9f834.jpeg" alt="http://image.winrains.cn/2019/08/eb9c2-20190829103018-9f834.jpeg"><br>WebSocket有类似tcp协议的帧格式，在此不做过多解释。<br>参考：(<a href="https://tools.ietf.org/html/rfc6455#section-5.1" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6455#section-5.1</a>)</p>
<h2 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h2><p>心跳对应的ping、pong操作，opcode分别是0x9、0xA。收到心跳的一方需要自行更新心跳的更新时间。同《<a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&mid=2650519418&idx=1&sn=b465291cbc396a0b665ed120d1176f68&scene=21#wechat_redirect" target="_blank" rel="noopener">使用Netty，我们到底在开发些什么？</a>》介绍的类似，在一些移动环境中，需要更加智能的控制心跳。</p>
<h1 id="六、如何使用Nginx做负载均衡？"><a href="#六、如何使用Nginx做负载均衡？" class="headerlink" title="六、如何使用Nginx做负载均衡？"></a>六、如何使用Nginx做负载均衡？</h1><p>nginx官网已经给出了例子。主要是Upgrade和Connection头的设置。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">map <span class="variable">$http_upgrade</span> <span class="variable">$connection_upgrade</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    default upgrade;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">''</span> close;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">location <span class="regexp">/chat/</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    proxy_pass http:<span class="regexp">//</span>backend;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    proxy_http_version <span class="number">1.1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    proxy_set_header Upgrade <span class="variable">$http_upgrade</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    proxy_set_header Connection <span class="variable">$connection_upgrade</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>需要注意的是，nginx做负载均衡，不需要配置<code>ip_hash</code>等参数，nginx天然支持。由于ip_hash仅使用ip地址的前三个数字做hash，还有可能造成服务端的不均衡。</p>
<h1 id="七、java服务端怎么实现？"><a href="#七、java服务端怎么实现？" class="headerlink" title="七、java服务端怎么实现？"></a>七、java服务端怎么实现？</h1><p>可以实现javax.WebSocket下的包，简单的实现ws服务端。目前基本可以通过注解的方式去编写代码，比如<code>ServerEndpoint</code>。<br>推荐使用基于netty的netty-socketio进行服务端的编写。由于使用的是netty，所以能够在多个层面进行切入，获取一些统计数据，执行一些控制指令。socketio是一套解决方案，它有多个语言的客户端，并处理了市面上大多数的兼容问题。</p>
<h1 id="八、WebSocket能干些啥？"><a href="#八、WebSocket能干些啥？" class="headerlink" title="八、WebSocket能干些啥？"></a>八、WebSocket能干些啥？</h1><h2 id="通知功能"><a href="#通知功能" class="headerlink" title="通知功能"></a>通知功能</h2><p>保持一个长连接，当服务端游新的消息，能够实时的推送到使用方。像知乎的点赞通知、评论等，都可以使用WebSocket通信。<br>某些使用<code>H5</code>的客户端，为了简化开发，也会使用WebSocket进行消息的通知，由于它是实时推送的，会有更好的用户体验。</p>
<h2 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h2><p>一些次优级别的数据，比如行为日志、trace、异常执栈收集等，都可以开辟专门的WebSocket通道进行传输。这能够增加信息的集中度，并能及时的针对用户的行为进行合适的配置推送。由于大多数浏览器内核都支持，它将使客户端<code>APM</code>编程模型变得简单。</p>
<h2 id="加密-amp-amp-认证"><a href="#加密-amp-amp-认证" class="headerlink" title="加密 &amp;&amp; 认证"></a>加密 &amp;&amp; 认证</h2><p>虽然使用Fiddler、Charles等能够抓到很多WebSocket包。但如果同时开启SSL，传输加密后的二进制数据，会大幅增加破解的成本，会安全的多。</p>
<h2 id="反向控制钩子"><a href="#反向控制钩子" class="headerlink" title="反向控制钩子"></a>反向控制钩子</h2><p>这个…由于是双工长连接，服务端完全可以推送一些钩子命令，甚至直接是代码，在客户端进行执行。比如截个屏，录个音，种个小马。用户只要通过了授权申请，剩下的就随你发挥了。<br>支付宝偷偷调用你的相机给你拍照的梗，我是相信的。</p>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>想当年，cometd的出现，惊为天人，振奋了很久。但技术日新月异，cometd已经衰老，而Socket.io得到了快速发展。WebSocket经过一段时间的混沌期，规范已经越来越完善，使用也越来越方便，不需要再处理那么多的兼容。<br>但它的本质，还是新瓶装旧酒，换汤不换药。WebSocket的发展得益于HTML5规范的制定。规范的意义，就是约束厂商们天马行空的实现，以及指明发展的方向。<br>这当然有典型的反例，那就是<code>ie</code>。现在，只有一群公认的**，还坚持在用。</p>
<blockquote>
<p>作者：小姐姐养的狗</p>
<p>来源：<a href="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650519450&amp;idx=1&amp;sn=a8ba905f2410671cb8e2f8ec6b33a7a9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;mid=2650519450&amp;idx=1&amp;sn=a8ba905f2410671cb8e2f8ec6b33a7a9&amp;scene=21#wechat_redirect</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>StringBuilder为什么线程不安全</title>
    <url>/2019/12/26/StringBuilder%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>周五去面试又被面试的一个问题问哑巴了</p>
<blockquote>
<p>面试官：StringBuilder和StringBuffer的区别在哪？<br>我：StringBuilder不是线程安全的，StringBuffer是线程安全的<br>面试官：那StringBuilder不安全的点在哪儿？<br>我：。。。（哑巴了）</p>
</blockquote>
<p>在这之前我只记住了StringBuilder不是线程安全的，StringBuffer是线程安全的这个结论，至于StringBuilder为什么不安全从来没有去想过。</p>
<a id="more"></a>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote>
<p>在分析设个问题之前我们要知道StringBuilder和StringBuffer的内部实现跟String类一样，都是通过一个char数组存储字符串的，不同的是String类里面的char数组是final修饰的，是不可变的，而StringBuilder和StringBuffer的char数组是可变的。</p>
</blockquote>
<p>首先通过一段代码去看一下多线程操作StringBuilder对象会出现什么问题</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">StringBuilderDemo</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) throws InterruptedException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        StringBuilder <span class="built_in">string</span>Builder = new StringBuilder();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            new Thread(new Runnable() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">public</span> <span class="built_in">void</span> run() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="built_in">string</span>Builder.append(<span class="string">"a"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;).start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Thread.sleep(<span class="number">100</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(<span class="built_in">string</span>Builder.length());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们能看到这段代码创建了10个线程，每个线程循环1000次往StringBuilder对象里面append字符。正常情况下代码应该输出10000，但是实际运行会输出什么呢？</p>
<p><img src="http://image.winrains.cn/2019/08/20190829104615-6ff18.png" alt="img"></p>
<p>我们看到输出了“9326”，小于预期的10000，并且还抛出了一个ArrayIndexOutOfBoundsException异常（异常不是必现）。</p>
<h4 id="1、为什么输出值跟预期值不一样"><a href="#1、为什么输出值跟预期值不一样" class="headerlink" title="1、为什么输出值跟预期值不一样"></a>1、为什么输出值跟预期值不一样</h4><p>我们先看一下StringBuilder的两个成员变量（这两个成员变量实际上是定义在AbstractStringBuilder里面的，StringBuilder和StringBuffer都继承了AbstractStringBuilder）</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储字符串的具体内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//已经使用的字符数组的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">count</span>;</span></pre></td></tr></table></figure>

<p>再看StringBuilder的append()方法：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">@Override</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> StringBuilder <span class="built_in">append</span>(<span class="keyword">String</span> <span class="built_in">str</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">super</span>.<span class="built_in">append</span>(<span class="built_in">str</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>StringBuilder的append()方法调用的父类AbstractStringBuilder的append()方法</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder append(String <span class="keyword">str</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">str</span> == <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> appendNull();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> len = <span class="keyword">str</span>.length();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ensureCapacityInternal(<span class="keyword">count</span> + len);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">str</span>.getChars(<span class="number">0</span>, len, value, <span class="keyword">count</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">count</span> += len;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们先不管代码的第五行和第六行干了什么，直接看第七行，count += len不是一个原子操作。假设这个时候count值为10，len值为1，两个线程同时执行到了第七行，拿到的count值都是10，执行完加法运算后将结果赋值给count，所以两个线程执行完后count值为11，而不是12。这就是为什么测试代码输出的值要比10000小的原因。</p>
<h4 id="2、为什么会抛出ArrayIndexOutOfBoundsException异常"><a href="#2、为什么会抛出ArrayIndexOutOfBoundsException异常" class="headerlink" title="2、为什么会抛出ArrayIndexOutOfBoundsException异常"></a>2、为什么会抛出ArrayIndexOutOfBoundsException异常</h4><p>我们看回AbstractStringBuilder的append()方法源码的第五行，ensureCapacityInternal()方法是检查StringBuilder对象的原char数组的容量能不能盛下新的字符串，如果盛不下就调用expandCapacity()方法对char数组进行扩容。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void ensure<span class="constructor">CapacityInternal(<span class="params">int</span> <span class="params">minimumCapacity</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// overflow-conscious code</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        expand<span class="constructor">Capacity(<span class="params">minimumCapacity</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>扩容的逻辑就是new一个新的char数组，新的char数组的容量是原来char数组的两倍再加2，再通过System.arryCopy()函数将原数组的内容复制到新数组，最后将指针指向新的char数组。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void expand<span class="constructor">Capacity(<span class="params">int</span> <span class="params">minimumCapacity</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//计算新的容量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">int</span> newCapacity = value.length<span class="operator"> * </span><span class="number">2</span> + <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//中间省略了一些检查逻辑</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    value = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>copy<span class="constructor">Of(<span class="params">value</span>, <span class="params">newCapacity</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Arrys.copyOf()方法</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">char</span>[] copyOf(<span class="built_in">char</span>[] original, <span class="built_in">int</span> newLength) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">char</span>[] <span class="built_in">copy</span> = <span class="keyword">new</span> <span class="built_in">char</span>[newLength];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//拷贝数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.arraycopy(original, <span class="number">0</span>, <span class="built_in">copy</span>, <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                         Math.<span class="built_in">min</span>(original.length, newLength));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">copy</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>AbstractStringBuilder的append()方法源码的第六行，是将String对象里面char数组里面的内容拷贝到StringBuilder对象的char数组里面，代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">str.get<span class="constructor">Chars(0, <span class="params">len</span>, <span class="params">value</span>, <span class="params">count</span>)</span>;</span></pre></td></tr></table></figure>

<p>getChars()方法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void get<span class="constructor">Chars(<span class="params">int</span> <span class="params">srcBegin</span>, <span class="params">int</span> <span class="params">srcEnd</span>, <span class="params">char</span> <span class="params">dst</span>[], <span class="params">int</span> <span class="params">dstBegin</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//中间省略了一些检查</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>拷贝流程见下图</p>
<p><img src="http://image.winrains.cn/2019/08/20190829104616-1d8a7.png" alt="img"></p>
<p>假设现在有两个线程同时执行了StringBuilder的append()方法，两个线程都执行完了第五行的ensureCapacityInternal()方法，此刻count=5。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829104616-ea5e7.png" alt="img"></p>
<p>这个时候线程1的cpu时间片用完了，线程2继续执行。线程2执行完整个append()方法后count变成6了</p>
<p><img src="http://image.winrains.cn/2019/08/20190829104617-849b5.png" alt="img"></p>
<p>线程1继续执行第六行的str.getChars()方法的时候拿到的count值就是6了，执行char数组拷贝的时候就会抛出ArrayIndexOutOfBoundsException异常。<br>至此，StringBuilder为什么不安全已经分析完了。如果我们将测试代码的StringBuilder对象换成StringBuffer对象会输出什么呢？</p>
<p><img src="http://image.winrains.cn/2019/08/20190829104618-6d57d.png" alt="img"></p>
<p>当然是输出10000啦！那么StringBuffer用什么手段保证线程安全的？这个问题你点进StringBuffer的append()方法里面就知道了。</p>
<blockquote>
<p>作者：千山qianshan</p>
<p>来源：<a href="https://juejin.im/post/5d6228046fb9a06add4e37fe" target="_blank" rel="noopener">https://juejin.im/post/5d6228046fb9a06add4e37fe</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解多线程（五）：Java虚拟机的锁优化技术</title>
    <url>/2019/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E9%94%81%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>本文是《<a href="http://www.hollischuang.com/archives/tag/深入理解多线程" target="_blank" rel="noopener">深入理解多线程</a>》的第五篇文章，前面几篇文章中我们从synchronized的实现原理开始，一直介绍到了Monitor的实现原理。</p>
<a id="more"></a>

<h3 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h3><p>通过前面几篇文章，我们已经知道：<br>1、同步方法通过<code>ACC_SYNCHRONIZED</code>关键字隐式的对方法进行加锁。当线程要执行的方法被标注上<code>ACC_SYNCHRONIZED</code>时，需要先获得锁才能执行该方法。《<a href="http://www.hollischuang.com/archives/1883" target="_blank" rel="noopener">深入理解多线程（一）——Synchronized的实现原理</a>》<br>2、同步代码块通过<code>monitorenter</code>和<code>monitorexit</code>执行来进行加锁。当线程执行到<code>monitorenter</code>的时候要先获得所锁，才能执行后面的方法。当线程执行到<code>monitorexit</code>的时候则要释放锁。《<a href="http://www.hollischuang.com/archives/2030" target="_blank" rel="noopener">深入理解多线程（四）—— Moniter的实现原理</a>》<br>3、在HotSpot虚拟机中，使用<strong>oop-klass模型</strong>来表示对象。每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个<code>instanceKlass</code>，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个<code>instanceOopDesc</code>对象，这个对象中包含了对象头以及实例数据。《<a href="http://www.hollischuang.com/archives/1910" target="_blank" rel="noopener">深入理解多线程（二）—— Java的对象模型</a>》<br>4、对象头中主要包含了GC分代年龄、锁状态标记、哈希码、epoch等信息。对象的状态一共有五种，分别是无锁态、轻量级锁、重量级锁、GC标记和偏向锁。《<a href="http://www.hollischuang.com/archives/1953" target="_blank" rel="noopener">深入理解多线程（三）—— Java的对象头</a>》<br><strong>在上一篇文章的最后，我们说过，事实上，只有在JDK1.6之前，<code>synchronized</code>的实现才会直接调用<code>ObjectMonitor</code>的<code>enter</code>和<code>exit</code>，这种锁被称之为重量级锁。</strong><br><strong>高效并发是从JDK 1.5 到 JDK 1.6的一个重要改进，HotSpot虚拟机开发团队在这个版本中花费了很大的精力去对Java中的锁进行优化，如适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等。这些技术都是为了在线程之间更高效的共享数据，以及解决竞争问题。</strong><br>本文，主要先来介绍一下自旋、锁消除以及锁粗化等技术。<br>这里简单说明一下，本文要介绍的这几个概念，以及后面要介绍的轻量级锁和偏向锁，其实对于使用他的开发者来说是屏蔽掉了的，也就是说，<strong>作为一个Java开发，你只需要知道你想在加锁的时候使用synchronized就可以了，具体的锁的优化是虚拟机根据竞争情况自行决定的。</strong><br>也就是说，在JDK 1.5 以后，我们即将介绍的这些概念，都被封装在synchronized中了。</p>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>要想把锁说清楚，一个重要的概念不得不提，那就是线程和线程的状态。锁和线程的关系是怎样的呢，举个简单的例子你就明白了。<br>比如，你今天要去银行办业务，你到了银行之后，要先取一个号，然后你坐在休息区等待叫号，过段时间，广播叫到你的号码之后，会告诉你去哪个柜台办理业务，这时，你拿着你手里的号码，去到对应的柜台，找相应的柜员开始办理业务。当你办理业务的时候，这个柜台和柜台后面的柜员只能为你自己服务。当你办完业务离开之后，广播再喊其他的顾客前来办理业务。<br><a href="http://image.winrains.cn/2019/08/f092d-Pic1.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/f092d-Pic1.png" alt="Pic1"></a></p>
<blockquote>
<p>这个例子中，每个顾客是一个<strong>线程</strong>。 柜台前面的那把椅子，就是<strong>锁</strong>。 柜台后面的柜员，就是<strong>共享资源</strong>。 你发现无法直接办理业务，要取号等待的过程叫做<strong>阻塞</strong>。 当你听到叫你的号码的时候，你起身去办业务，这就是<strong>唤醒</strong>。 当你坐在椅子上开始办理业务的时候，你就<strong>获得锁</strong>。 当你办完业务离开的时候，你就<strong>释放锁</strong>。</p>
</blockquote>
<p>对于线程来说，一共有五种状态，分别为：初始状态(New) 、就绪状态(Runnable) 、运行状态(Running) 、阻塞状态(Blocked) 和死亡状态(Dead) 。<br><a href="http://image.winrains.cn/2019/08/6d157-thread.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/6d157-thread.png" alt="thread"></a></p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>在<a href="http://www.hollischuang.com/archives/2030" target="_blank" rel="noopener">前一篇</a>文章中，我们介绍的<code>synchronized</code>的实现方式中使用<code>Monitor</code>进行加锁，这是一种互斥锁，为了表示他对性能的影响我们称之为重量级锁。<br>这种互斥锁在互斥同步上对性能的影响很大，Java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统的帮忙，这就要从用户态转换到内核态，因此状态转换需要花费很多的处理器时间。<br>就像去银行办业务的例子，当你来到银行，发现柜台前面都有人的时候，你需要取一个号，然后再去等待区等待，一直等待被叫号。这个过程是比较浪费时间的，那么有没有什么办法改进呢？<br>有一种比较好的设计，那就是银行提供自动取款机，当你去银行取款的时候，你不需要取号，不需要去休息区等待叫号，你只需要找到一台取款机，排在其他人后面等待取款就行了。<br><a href="http://image.winrains.cn/2019/08/1e69c-Pic2.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/1e69c-Pic2.png" alt="Pic2"></a><br>之所以能这样做，是因为取款的这个过程相比较之下是比较节省时间的。如果所有人去银行都只取款，或者办理业务的时间都很短的话，那也就可以不需要取号，不需要去单独的休息区，不需要听叫号，也不需要再跑到对应的柜台了。<br>而，在程序中，Java虚拟机的开发工程师们在分析过大量数据后发现：共享数据的锁定状态一般只会持续很短的一段时间，为了这段时间去挂起和恢复线程其实并不值得。<br>如果物理机上有多个处理器，可以让多个线程同时执行的话。我们就可以让后面来的线程“稍微等一下”，但是并不放弃处理器的执行时间，看看持有锁的线程会不会很快释放锁。这个“稍微等一下”的过程就是自旋。<br>自旋锁在JDK 1.4中已经引入，在JDK 1.6中默认开启。<br>很多人在对于自旋锁的概念不清楚的时候可能会有以下疑问：这么听上去，自旋锁好像和阻塞锁没啥区别，反正都是等着嘛。</p>
<ul>
<li>对于去银行取钱的你来说，站在取款机面前等待和去休息区等待叫号有一个很大的区别：<ul>
<li>那就是如果你在休息区等待，这段时间你什么都不需要管，随意做自己的事情，等着被唤醒就行了。</li>
<li>如果你在取款机面前等待，那么你需要时刻关注自己前面还有没有人，因为没人会唤醒你。</li>
<li>很明显，这种直接去取款机前面排队取款的效率是比较高。</li>
</ul>
</li>
</ul>
<p><strong>所以呢，自旋锁和阻塞锁最大的区别就是，到底要不要放弃处理器的执行时间。对于阻塞锁和自旋锁来说，都是要等待获得共享资源。但是阻塞锁是放弃了CPU时间，进入了等待区，等待被唤醒。而自旋锁是一直“自旋”在那里，时刻的检查共享资源是否可以被访问。</strong><br>由于自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。如果线程竞争不激烈，并且保持锁的时间段。适合使用自旋锁。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>除了自旋锁之后，JDK中还有一种锁的优化被称之为锁消除。还拿去银行取钱的例子说。<br>你去银行取钱，所有情况下都需要取号，并且等待吗？其实是不用的，当银行办理业务的人不多的时候，可能根本不需要取号，直接走到柜台前面办理业务就好了。<br><a href="http://image.winrains.cn/2019/08/21271-Pic3.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/21271-Pic3.png" alt="Pic3"></a><br>能这么做的前提是，没有人和你抢着办业务。<br>上面的这种例子，在锁优化中被称作“锁消除”，是JIT编译器对内部锁的具体实现所做的一种优化。<br>在动态编译同步块的时候，JIT编译器可以借助一种被称为逃逸分析（Escape Analysis）的技术来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。<br>如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。<br>如以下代码：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> f() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">Object</span> hollis = <span class="built_in">new</span> <span class="keyword">Object</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    synchronized(hollis) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(hollis);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>代码中对<code>hollis</code>这个对象进行加锁，但是<code>hollis</code>对象的生命周期只在<code>f()</code>方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。优化成：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> f() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">Object</span> hollis = <span class="built_in">new</span> <span class="keyword">Object</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(hollis);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>这里，可能有读者会质疑了，代码是程序员自己写的，程序员难道没有能力判断要不要加锁吗？就像以上代码，完全没必要加锁，有经验的开发者一眼就能看的出来的。其实道理是这样，但是还是有可能有疏忽，比如我们经常在代码中使用<code>StringBuffer</code>作为局部变量，而<code>StringBuffer</code>中的<code>append</code>是线程安全的，有<code>synchronized</code>修饰的，这种情况开发者可能会忽略。这时候，JIT就可以帮忙优化，进行锁消除。</p>
</blockquote>
<p>了解我的朋友都知道，一般到这个时候，我就会开始反编译，然后拿出反编译之后的代码来证明锁优化确实存在。<br>但是，之前很多例子之所以可以用反编译工具，是因为那些“优化”，如语法糖等，是在<code>javac编译</code>阶段发生的，并不是在<code>JIT编译</code>阶段发生的。而锁优化，是JIT编译器的功能，所以，无法使用现有的反编译工具查看具体的优化结果。（关于javac编译和JIT编译的关系和区别，我在我的知识星球中单独发了一篇文章介绍。）</p>
<blockquote>
<p>但是，如果读者感兴趣，还是可以看的，只是会复杂一点，首先你要自己build一个fasttest版本的jdk，然后在使用java命令对<code>.class</code>文件进行执行的时候加上<code>-XX:+PrintEliminateLocks</code>参数。而且jdk的模式还必须是server模式。</p>
</blockquote>
<p>总之，读者只需要知道，在使用<code>synchronized</code>的时候，如果JIT经过逃逸分析之后发现并无线程安全问题的话，就会做锁消除。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>很多人都知道，在代码中，需要加锁的时候，我们提倡尽量减小锁的粒度，这样可以避免不必要的阻塞。<br>这也是很多人原因是用同步代码块来代替同步方法的原因，因为往往他的粒度会更小一些，这其实是很有道理的。<br>还是我们去银行柜台办业务，最高效的方式是你坐在柜台前面的时候，只办和银行相关的事情。如果这个时候，你拿出手机，接打几个电话，问朋友要往哪个账户里面打钱，这就很浪费时间了。最好的做法肯定是提前准备好相关资料，在办理业务时直接办理就好了。<br><a href="http://image.winrains.cn/2019/08/de86f-Pic4.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/de86f-Pic4.png" alt="Pic4"></a><br>加锁也一样，把无关的准备工作放到锁外面，锁内部只处理和并发相关的内容。这样有助于提高效率。<br>那么，这和锁粗化有什么关系呢？可以说，大部分情况下，减小锁的粒度是很正确的做法，只有一种特殊的情况下，会发生一种叫做锁粗化的优化。<br>就像你去银行办业务，你为了减少每次办理业务的时间，你把要办的五个业务分成五次去办理，这反而适得其反了。因为这平白的增加了很多你重新取号、排队、被唤醒的时间。<br>如果在一段代码中连续的对同一个对象反复加锁解锁，其实是相对耗费资源的，这种情况可以适当放宽加锁的范围，减少性能消耗。<br>当JIT发现一系列连续的操作都对同一个对象反复加锁和解锁，甚至加锁操作出现在循环体中的时候，会将加锁同步的范围扩散（粗化）到整个操作序列的外部。<br>如以下代码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    synchronized(<span class="keyword">this</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">do</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>会被粗化成：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">synchronized(<span class="keyword">this</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">do</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>这其实和我们要求的减小锁粒度并不冲突。减小锁粒度强调的是不要在银行柜台前做准备工作以及和办理业务无关的事情。而锁粗化建议的是，同一个人，要办理多个业务的时候，可以在同一个窗口一次性办完，而不是多次取号多次办理。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>自Java 6/Java 7开始，Java虚拟机对内部锁的实现进行了一些优化。这些优化主要包括锁消除（Lock Elision）、锁粗化（Lock Coarsening）、偏向锁（Biased Locking）以及适应性自旋锁（Adaptive Locking）。这些优化仅在Java虚拟机server模式下起作用（即运行Java程序时我们可能需要在命令行中指定Java虚拟机参数“-server”以开启这些优化）。<br>本文主要介绍了自旋锁、锁粗化和锁消除的概念。在JIT编译过程中，虚拟机会根据情况使用这三种技术对锁进行优化，目的是减少锁的竞争，提升性能。</p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/2344" target="_blank" rel="noopener">https://www.hollischuang.com/archives/2344</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解多线程（四）：Monitor的实现原理</title>
    <url>/2019/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AMonitor%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>在<a href="http://www.hollischuang.com/archives/1883" target="_blank" rel="noopener">深入理解多线程（一）——Synchronized的实现原理</a>中介绍过关于<code>Synchronize</code>的实现原理，无论是同步方法还是同步代码块，无论是<code>ACC_SYNCHRONIZED</code>还是<code>monitorenter</code>、<code>monitorexit</code>都是基于<code>Monitor</code>实现的，那么这篇来介绍下什么是<strong>Monitor</strong>。</p>
<a id="more"></a>

<h3 id="操作系统中的管程"><a href="#操作系统中的管程" class="headerlink" title="操作系统中的管程"></a>操作系统中的管程</h3><p>如果你在大学学习过操作系统，你可能还记得管程（monitors）在操作系统中是很重要的概念。同样Monitor在java同步机制中也有使用。</p>
<blockquote>
<p>管程 (英语：Monitors，也称为监视器) 是一种程序结构，结构内的多个子程序（对象或模块）形成的多个工作线程互斥访问共享资源。这些共享资源一般是硬件设备或一群变量。管程实现了在一个时间点，最多只有一个线程在执行管程的某个子程序。与那些通过修改数据结构实现互斥访问的并发程序设计相比，管程实现很大程度上简化了程序设计。 管程提供了一种机制，线程可以临时放弃互斥访问，等待某些条件得到满足后，重新获得执行权恢复它的互斥访问。</p>
</blockquote>
<h3 id="Java线程同步相关的Monitor"><a href="#Java线程同步相关的Monitor" class="headerlink" title="Java线程同步相关的Monitor"></a>Java线程同步相关的Monitor</h3><p>在多线程访问共享资源的时候，经常会带来可见性和原子性的安全问题。为了解决这类线程安全的问题，Java提供了同步机制、互斥锁机制，这个机制保证了在同一时刻只有一个线程能访问共享资源。这个机制的保障来源于监视锁Monitor，每个对象都拥有自己的监视锁Monitor。<br>先来举个例子，然后我们在上源码。我们可以把监视器理解为包含一个特殊的房间的建筑物，这个特殊房间同一时刻只能有一个客人（线程）。这个房间中包含了一些数据和代码。<br><a href="http://image.winrains.cn/2019/08/df48a-Java-Monitor.jpg" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/df48a-Java-Monitor.jpg" alt="Java-Monitor"></a><br>如果一个顾客想要进入这个特殊的房间，他首先需要在走廊（Entry Set）排队等待。调度器将基于某个标准（比如 FIFO）来选择排队的客户进入房间。如果，因为某些原因，该客户客户暂时因为其他事情无法脱身（线程被挂起），那么他将被送到另外一间专门用来等待的房间（Wait Set），这个房间的可以可以在稍后再次进入那件特殊的房间。如上面所说，这个建筑屋中一共有三个场所。<br><a href="http://image.winrains.cn/2019/08/64de8-java-monitor-associate-with-object.jpg" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/64de8-java-monitor-associate-with-object.jpg" alt="java-monitor-associate-with-object"></a><br>总之，监视器是一个用来监视这些线程进入特殊的房间的。他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。<br>Monitor其实是一种同步工具，也可以说是一种同步机制，它通常被描述为一个对象，主要特点是：</p>
<blockquote>
<p>对象的所有方法都被“互斥”的执行。好比一个Monitor只有一个运行“许可”，任一个线程进入任何一个方法都需要获得这个“许可”，离开时把许可归还。<br>通常提供singal机制：允许正持有“许可”的线程暂时放弃“许可”，等待某个谓词成真（条件变量），而条件成立后，当前进程可以“通知”正在等待这个条件变量的线程，让他可以重新去获得运行许可。</p>
</blockquote>
<h3 id="监视器的实现"><a href="#监视器的实现" class="headerlink" title="监视器的实现"></a>监视器的实现</h3><p>在Java虚拟机(HotSpot)中，Monitor是基于C++实现的，由<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp" target="_blank" rel="noopener">ObjectMonitor</a>实现的，其主要数据结构如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">ObjectMonitor()</span> <span class="string">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_header</span>       <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_count</span>        <span class="string">=</span> <span class="number">0</span><span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_waiters</span>      <span class="string">=</span> <span class="number">0</span><span class="string">,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_recursions</span>   <span class="string">=</span> <span class="number">0</span><span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_object</span>       <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_owner</span>        <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_WaitSet</span>      <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_WaitSetLock</span>  <span class="string">=</span> <span class="number">0</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_Responsible</span>  <span class="string">=</span> <span class="literal">NULL</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_succ</span>         <span class="string">=</span> <span class="literal">NULL</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_cxq</span>          <span class="string">=</span> <span class="literal">NULL</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">FreeNext</span>      <span class="string">=</span> <span class="literal">NULL</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_EntryList</span>    <span class="string">=</span> <span class="literal">NULL</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_SpinFreq</span>     <span class="string">=</span> <span class="number">0</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">_SpinClock</span>    <span class="string">=</span> <span class="number">0</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">OwnerIsThread</span> <span class="string">=</span> <span class="number">0</span> <span class="string">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">&#125;</span></span></pre></td></tr></table></figure>

<p>源码地址：<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.hpp#L193" target="_blank" rel="noopener">objectMonitor.hpp</a><br>ObjectMonitor中有几个关键属性：</p>
<blockquote>
<p>_owner：指向持有ObjectMonitor对象的线程<br>_WaitSet：存放处于wait状态的线程队列<br>_EntryList：存放处于等待锁block状态的线程队列<br>_recursions：锁的重入次数<br>_count：用来记录该线程获取锁的次数</p>
</blockquote>
<p>当多个线程同时访问一段同步代码时，首先会进入<code>_EntryList</code>队列中，当某个线程获取到对象的monitor后进入<code>_Owner</code>区域并把monitor中的<code>_owner</code>变量设置为当前线程，同时monitor中的计数器<code>_count</code>加1。即获得对象锁。<br>若持有monitor的线程调用<code>wait()</code>方法，将释放当前持有的monitor，<code>_owner</code>变量恢复为<code>null</code>，<code>_count</code>自减1，同时该线程进入<code>_WaitSet</code>集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示<br><a href="http://image.winrains.cn/2019/08/bd30d-monitor.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/bd30d-monitor.png" alt="monitor"></a><br>ObjectMonitor类中提供了几个方法：<br><strong>获得锁</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">void ATTR ObjectMonitor::enter(TRAPS) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Thread * <span class="keyword">const</span> <span class="keyword">Self</span> = THREAD ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void * cur ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//通过CAS尝试把monitor的`_owner`字段设置为当前线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cur = Atomic::cmpxchg_ptr (<span class="keyword">Self</span>, &amp;_owner, <span class="keyword">NULL</span>) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//获取锁失败</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (cur == <span class="keyword">NULL</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        assert (_recursions == <span class="number">0</span>   , <span class="string">"invariant"</span>) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        assert (_owner      == <span class="keyword">Self</span>, <span class="string">"invariant"</span>) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// CONSIDER: set or assert OwnerIsThread == 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果旧值和当前线程一样，说明当前线程已经持有锁，此次为重入，_recursions自增，并获得锁。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (cur == <span class="keyword">Self</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// TODO-<span class="doctag">FIXME:</span> check for integer overflow!  BUGID 6557169.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        _recursions ++ ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果当前线程是第一次进入该monitor，设置_recursions为1，_owner为当前线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">Self</span>-&gt;is_lock_owned ((address)cur)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        assert (_recursions == <span class="number">0</span>, <span class="string">"internal state error"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _recursions = <span class="number">1</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Commute owner from a thread-specific on-stack BasicLockObject address to</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// a full-fledged "Thread *".</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        _owner = <span class="keyword">Self</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        OwnerIsThread = <span class="number">1</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 省略部分代码。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 通过自旋执行ObjectMonitor::EnterI方法等待锁的释放</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (;;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        jt-&gt;set_suspend_equivalent();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// cleared by handle_special_suspend_equivalent_condition()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// or java_suspend_self()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        EnterI (THREAD) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!ExitSuspendEquivalent(jt)) <span class="keyword">break</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// We have acquired the contended monitor, but while we were</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// waiting another thread suspended us. We don't want to enter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// the monitor while suspended because that would surprise the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// thread that suspended us.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        _recursions = <span class="number">0</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _succ = <span class="keyword">NULL</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">exit</span> (<span class="keyword">Self</span>) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        jt-&gt;java_suspend_self();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><a href="http://image.winrains.cn/2019/08/b370f-lockenter.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/b370f-lockenter.png" alt="lockenter"></a><br>释放锁</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">void ATTR ObjectMonitor::<span class="keyword">exit</span>(TRAPS) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   Thread * Self = THREAD ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">//如果当前线程不是Monitor的所有者</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (THREAD != <span class="variable">_owner</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">if</span> (THREAD-&gt;is_lock_owned((address) <span class="variable">_owner</span>)) &#123; <span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// Transmute _owner from a BasicLock pointer to a Thread address.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// We don't need to hold _mutex for this transition.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// Non-null to Non-null is safe as long as all readers can</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// tolerate either flavor.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="built_in">assert</span> (<span class="variable">_recursions</span> == <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="variable">_owner</span> = THREAD ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="variable">_recursions</span> = <span class="number">0</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       OwnerIsThread = <span class="number">1</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// <span class="doctag">NOTE:</span> we need to handle unbalanced monitor enter/exit</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// in native code by throwing an exception.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="comment">// <span class="doctag">TODO:</span> Throw an IllegalMonitorStateException ?</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       TEVENT (<span class="keyword">Exit</span> - <span class="keyword">Throw</span> IMSX) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="built_in">assert</span>(<span class="literal">false</span>, <span class="string">"Non-balanced monitor enter/exit!"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">THROW</span>(vmSymbols::java_lang_IllegalMonitorStateException());</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       return;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果_recursions次数不为0.自减</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (<span class="variable">_recursions</span> != <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="variable">_recursions</span>--;        <span class="comment">// this is simple recursive enter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     TEVENT (Inflated <span class="keyword">exit</span> - recursive) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     return ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">//省略部分代码，根据不同的策略（由QMode指定），从cxq或EntryList中获取头节点，通过ObjectMonitor::ExitEpilog方法唤醒该节点封装的线程，唤醒操作最终由unpark完成。</span></span></pre></td></tr></table></figure>

<p><a href="http://image.winrains.cn/2019/08/ce586-lockexit.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/ce586-lockexit.png" alt="lockexit"></a><br>除了enter和exit方法以外，<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp" target="_blank" rel="noopener">objectMonitor.cpp</a>中还有</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>      <span class="title">wait</span><span class="params">(jlong <span class="built_in">millis</span>, <span class="keyword">bool</span> interruptable, TRAPS)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>      <span class="title">notify</span><span class="params">(TRAPS)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>      <span class="title">notifyAll</span><span class="params">(TRAPS)</span></span>;</span></pre></td></tr></table></figure>

<p>等方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面介绍的就是HotSpot虚拟机中Monitor的的加锁以及解锁的原理。<br>通过这篇文章我们知道了<code>sychronized</code>加锁的时候，会调用objectMonitor的<code>enter</code>方法，解锁的时候会调用<code>exit</code>方法。事实上，只有在JDK1.6之前，<code>synchronized</code>的实现才会直接调用ObjectMonitor的<code>enter</code>和<code>exit</code>，这种锁被称之为重量级锁。为什么说这种方式操作锁很重呢？</p>
<ul>
<li>Java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统的帮忙，这就要从用户态转换到核心态，因此状态转换需要花费很多的处理器时间，对于代码简单的同步块（如被<code>synchronized</code>修饰的<code>get</code> 或<code>set</code>方法）状态转换消耗的时间有可能比用户代码执行的时间还要长，所以说<code>synchronized</code>是java语言中一个重量级的操纵。</li>
</ul>
<p>所以，在JDK1.6中出现对锁进行了很多的优化，进而出现轻量级锁，偏向锁，锁消除，适应性自旋锁，锁粗化(自旋锁在1.4就有 只不过默认的是关闭的，jdk1.6是默认开启的)，这些操作都是为了在线程之间更高效的共享数据 ，解决竞争问题。后面的文章会继续介绍这几种锁以及他们之间的关系。<br><a href="http://bigdatadecode.club/JavaSynchronizedTheory.html" target="_blank" rel="noopener">Java Synchronized实现原理</a><br><a href="http://www.jianshu.com/p/f4454164c017" target="_blank" rel="noopener">JVM源码分析之Object.wait/notify实现</a><br><a href="http://blog.csdn.net/penngrove/article/details/44175387" target="_blank" rel="noopener">Linux Kernel CMPXCHG函数分析</a><br><a href="https://www.cnblogs.com/kundeg/p/8422557.html" target="_blank" rel="noopener">从jvm源码看synchronized</a></p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/2030" target="_blank" rel="noopener">https://www.hollischuang.com/archives/2030</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解多线程（三）：Java的对象头</title>
    <url>/2019/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AJava%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%A4%B4/</url>
    <content><![CDATA[<p><a href="http://www.hollischuang.com/archives/1910" target="_blank" rel="noopener">上一篇</a>文章中我们从HotSpot的源码入手，介绍了Java的对象模型。这一篇文章在上一篇文章的基础上再来介绍一下Java的对象头。主要介绍一下对象头的作用，结构以及他和锁的关系。</p>
<a id="more"></a>

<h3 id="Java对象模型回顾与勘误"><a href="#Java对象模型回顾与勘误" class="headerlink" title="Java对象模型回顾与勘误"></a>Java对象模型回顾与勘误</h3><p>在上一篇文章中，关于对象头的部分描述有误，我已经在我博客的文章中就行修正 。这里再重新表述一下。<br>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个<code>instanceKlass</code>，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个<code>instanceOopDesc</code>对象，这个对象中包含了对象头以及实例数据。<br>这里提到的对象头到底是什么呢？</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">oopDesc</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  friend <span class="class"><span class="keyword">class</span> <span class="title">VMStructs</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="symbol">private:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  volatile markOop  _mark;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">_metadata</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    wideKlassOop    _klass;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    narrowOop       _compressed_klass;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125; _metadata;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面代码中的<code>_mark</code>和<code>_metadata</code>其实就是对象头的定义。关于<code>_metadata</code>之前就介绍过，这里不再赘述。由于这个专题主要想介绍和JAVA并发相关的知识，所以本文展开介绍一下<code>_mark</code> ，即mark word。<br>对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。<br>对markword的设计方式上，非常像网络协议报文头：将mark word划分为多个比特位区间，并在不同的对象状态下赋予比特位不同的含义。下图描述了在32位虚拟机上，在对象不同状态时 mark word各个比特位区间的含义。<br><img src="http://image.winrains.cn/2019/08/acec7-ObjectHead-1024x329.png" alt="ObjectHead"><br>同样，在HotSpot的源码中我们可以找到关于对象头对象的定义，会一一印证上图的描述。对应与<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/markOop.hpp" target="_blank" rel="noopener">markOop.hpp</a>类。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; age_bits                 = <span class="number">4</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      lock_bits                = <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      biased_lock_bits         = <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      max_hash_bits            = BitsPerWord - age_bits - lock_bits - biased_lock_bits,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      hash_bits                = max_hash_bits &gt; <span class="number">31</span> ? <span class="number">31</span> : max_hash_bits,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      cms_bits                 = LP64_ONLY(<span class="number">1</span>) NOT_LP64(<span class="number">0</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      epoch_bits               = <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>从上面的枚举定义中可以看出，对象头中主要包含了GC分代年龄、锁状态标记、哈希码、epoch等信息。<br>从上图中可以看出，对象的状态一共有五种，分别是无锁态、轻量级锁、重量级锁、GC标记和偏向锁。在32位的虚拟机中有两个Bits是用来存储锁的标记为的，但是我们都知道，两个bits最多只能表示四种状态：00、01、10、11，那么第五种状态如何表示呢 ，就要额外依赖1Bit的空间，使用0和1来区分。</p>
<blockquote>
<p>在32位的HotSpot虚拟机 中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码(HashCode)，4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，表示非偏向锁。</p>
</blockquote>
<p><a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/markOop.hpp" target="_blank" rel="noopener">markOop.hpp</a>类中有关于对象状态的定义：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; locked_value             = <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       unlocked_value           = <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       monitor_value            = <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       marked_value             = <span class="number">3</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       biased_lock_pattern      = <span class="number">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>简单翻译一下：</p>
<blockquote>
<p>locked_value(00) = 0<br>unlocked_value(01) = 1<br>monitor_value(10) = 2<br>marked_value(11) = 3<br>biased_lock_pattern(101) = 5</p>
</blockquote>
<p>关于为什么要定义这么多状态，上面提到的轻量级锁、重量级锁、偏向锁以及他们之前的关系，会在下一篇文章中重点阐述，敬请期待。</p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/1953" target="_blank" rel="noopener">https://www.hollischuang.com/archives/1953</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解多线程（二）：Java的对象模型</title>
    <url>/2019/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AJava%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p><a href="http://www.hollischuang.com/archives/1883" target="_blank" rel="noopener">上一篇</a>文章中简单介绍过<code>synchronized</code>关键字的方式，其中，同步代码块使用<code>monitorenter</code>和<code>monitorexit</code>两个指令实现，同步方法使用<code>ACC_SYNCHRONIZED</code>标记符实现。后面几篇文章会从JVM源码的角度更加深入，层层剥开<code>synchronized</code>的面纱。在进入正题之前，肯定有些基础知识需要铺垫，那么先来看一下一个容易被忽略的但是又很重要的知识点 —— Java对象模型 。<br>大家都知道的是，Java对象保存在堆内存中。在内存中，一个Java对象包含三部分：对象头、实例数据和对齐填充。其中对象头是一个很关键的部分，因为<strong>对象头中包含锁状态标志、线程持有的锁等标志</strong>。这篇文章就主要从Java对象模型入手，找一找我们关系的对象头以及对象头中和锁相关的运行时数据在JVM中是如何表示的。</p>
<a id="more"></a>

<h3 id="Java的对象模型"><a href="#Java的对象模型" class="headerlink" title="Java的对象模型"></a>Java的对象模型</h3><p>任何一个接触过Java的人都知道，Java是一种面向对象语言。在学习Java的过程中你一定对下面两句话不陌生：</p>
<ul>
<li>1、在面向对象的软件中，对象（Object）是某一个类（Class）的实例。 <a href="https://zh.wikipedia.org/wiki/对象_(计算机科学)" target="_blank" rel="noopener">维基百科</a></li>
<li>2、一切皆对象 <a href="https://book.douban.com/subject/1474824/" target="_blank" rel="noopener">Thinking In Java</a></li>
</ul>
<p>我们还知道，在JVM的内存结构中，对象保存在堆内存中，而我们在对对象进行操作时，其实操作的是对象的引用。那么对象本身在JVM中的结构是什么样的呢？本文的所有分析均基于<a href="https://github.com/openjdk-mirror/jdk7u-hotspot" target="_blank" rel="noopener">HotSpot</a>虚拟机。</p>
<h3 id="oop-klass-model"><a href="#oop-klass-model" class="headerlink" title="oop-klass model"></a>oop-klass model</h3><p>HotSpot是基于c++实现，而c++是一门面向对象的语言，本身是具备面向对象基本特征的，所以Java中的对象表示，最简单的做法是为每个Java类生成一个c++类与之对应。但HotSpot JVM并没有这么做，而是设计了一个<code>OOP-Klass Model</code>。OOP（<code>Ordinary Object Pointer</code>）指的是普通对象指针，而<code>Klass</code>用来描述对象实例的具体类型。<br>为什么HotSpot要设计一套<code>oop-klass model</code>呢？答案是：HotSopt JVM的设计者不想让每个对象中都含有一个<code>vtable</code>（虚函数表）<br>这个解释似乎可以说得通。众所周知，C++和Java都是面向对象的语言，面向对象语言有一个很重要的特性就是多态。关于多态的实现，C++和Java有着本质的区别。</p>
<blockquote>
<p>多态是面向对象的最主要的特性之一，是一种方法的动态绑定，实现运行时的类型决定对象的行为。多态的表现形式是父类指针或引用指向子类对象，在这个指针上调用的方法使用子类的实现版本。多态是IOC、模板模式实现的关键。</p>
<blockquote>
<p>在C++中通过虚函数表的方式实现多态，每个包含虚函数的类都具有一个虚函数表（virtual table），在这个类对象的地址空间的最靠前的位置存有指向虚函数表的指针。在虚函数表中，按照声明顺序依次排列所有的虚函数。由于C++在运行时并不维护类型信息，所以在编译时直接在子类的虚函数表中将被子类重写的方法替换掉。<br>在Java中，在运行时会维持类型信息以及类的继承体系。每一个类会在方法区中对应一个数据结构用于存放类的信息，可以通过Class对象访问这个数据结构。其中，类型信息具有superclass属性指示了其超类，以及这个类对应的方法表（其中只包含这个类定义的方法，不包括从超类继承来的）。而每一个在堆上创建的对象，都具有一个指向方法区类型信息数据结构的指针，通过这个指针可以确定对象的类型。</p>
</blockquote>
</blockquote>
<p>上面这段是我从网上摘取过来的，说的有一定道理，但是也不全对。至于为啥，我会在后文介绍到Klass的时候细说。<br>关于opp-klass模型的整体定义，在HotSpot的<a href="https://github.com/openjdk-mirror/jdk7u-hotspot" target="_blank" rel="noopener">源码</a>中可以找到。<br>oops模块可以分成两个相对独立的部分：OOP框架和Klass框架。<br>在<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/oopsHierarchy.hpp" target="_blank" rel="noopener">oopsHierarchy.hpp</a>里定义了oop和klass各自的体系。</p>
<h3 id="oop-klass结构"><a href="#oop-klass结构" class="headerlink" title="oop-klass结构"></a>oop-klass结构</h3><p><a href="http://image.winrains.cn/2019/08/d99a2-oops.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/d99a2-oops.png" alt="oops"></a><br>oop体系：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义了oops共同基类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">oopDesc</span>*                            <span class="title">oop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示一个Java类型实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">instanceOopDesc</span>*            <span class="title">instanceOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示一个Java方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">methodOopDesc</span>*                    <span class="title">methodOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示一个Java方法中的不变信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">constMethodOopDesc</span>*            <span class="title">constMethodOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//记录性能信息的数据结构</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">methodDataOopDesc</span>*            <span class="title">methodDataOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//定义了数组OOPS的抽象基类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">arrayOopDesc</span>*                    <span class="title">arrayOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示持有一个OOPS数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">objArrayOopDesc</span>*            <span class="title">objArrayOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示容纳基本类型的数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">typeArrayOopDesc</span>*            <span class="title">typeArrayOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示在Class文件中描述的常量池</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">constantPoolOopDesc</span>*            <span class="title">constantPoolOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//常量池告诉缓存</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">constantPoolCacheOopDesc</span>*   <span class="title">constantPoolCacheOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//描述一个与Java类对等的C++类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">klassOopDesc</span>*                    <span class="title">klassOop</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示对象头</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">markOopDesc</span>*                    <span class="title">markOop</span>;</span></span></pre></td></tr></table></figure>

<p><strong>上面列出的是整个Oops模块的组成结构，其中包含多个子模块。每一个子模块对应一个类型，每一个类型的OOP都代表一个在JVM内部使用的特定对象的类型。</strong><br>从上面的代码中可以看到，有一个变量opp的类型是<code>oppDesc</code> ，OOPS类的共同基类型为<code>oopDesc</code>。<br><strong>在Java程序运行过程中，每创建一个新的对象，在JVM内部就会相应地创建一个对应类型的OOP对象。</strong>在HotSpot中，根据JVM内部使用的对象业务类型，具有多种<code>oopDesc</code>的子类。除了<code>oppDesc</code>类型外，opp体系中还有很多<code>instanceOopDesc</code>、<code>arrayOopDesc</code> 等类型的实例，他们都是<code>oopDesc</code>的子类。<br><a href="http://image.winrains.cn/2019/08/c4110-OOP结构.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/c4110-OOP%E7%BB%93%E6%9E%84.png" alt="OOP结构"></a><br>这些OOPS在JVM内部有着不同的用途，例如<strong>，<code>instanceOopDesc</code>表示类实例，<code>arrayOopDesc</code>表示数组。</strong>也就是说，<strong>当我们使用<code>new</code>创建一个Java对象实例的时候，JVM会创建一个<code>instanceOopDesc</code>对象来表示这个Java对象。同理，当我们使用<code>new</code>创建一个Java数组实例的时候，JVM会创建一个<code>arrayOopDesc</code>对象来表示这个数组对象。</strong><br>在HotSpot中，oopDesc类定义在<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/oop.hpp" target="_blank" rel="noopener">oop.hpp</a>中，instanceOopDesc定义在<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/instanceOop.hpp" target="_blank" rel="noopener">instanceOop.hpp</a>中，arrayOopDesc定义在<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/arrayOop.hpp" target="_blank" rel="noopener">arrayOop.hpp</a>中。<br>简单看一下相关定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">oopDesc</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VMStructs</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">volatile</span> markOop  _mark;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">union</span> _metadata &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wideKlassOop    _klass;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        narrowOop       _compressed_klass;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; _metadata;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// field addresses in oop</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">void</span>*     <span class="title">field_base</span><span class="params">(<span class="keyword">int</span> offset)</span>        <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jbyte*    <span class="title">byte_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span>   <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jchar*    <span class="title">char_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span>   <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jboolean* <span class="title">bool_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span>   <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jint*     <span class="title">int_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span>    <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jshort*   <span class="title">short_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span>  <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jlong*    <span class="title">long_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span>   <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jfloat*   <span class="title">float_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span>  <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">jdouble*  <span class="title">double_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="function">address*  <span class="title">address_field_addr</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">instanceOopDesc</span> :</span> <span class="keyword">public</span> oopDesc &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arrayOopDesc</span> :</span> <span class="keyword">public</span> oopDesc &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过上面的源码可以看到，<code>instanceOopDesc</code>实际上就是继承了<code>oopDesc</code>，并没有增加其他的数据结构，也就是说<code>instanceOopDesc</code>中主要包含以下几部分数据：<code>markOop  _mark</code>和<code>union _metadata</code> 以及一些不同类型的 <code>field</code>。<br>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头、实例数据和对齐填充。在虚拟机内部，一个Java对象对应一个<code>instanceOopDesc</code>的对象。其中对象头包含了两部分内容：<code>_mark</code>和<code>_metadata</code>，而实例数据则保存在oopDesc中定义的各种field中。</p>
<h4 id="mark"><a href="#mark" class="headerlink" title="_mark"></a>_mark</h4><p>文章开头我们就说过，之所以我们要写这篇文章，是因为对象头中有和锁相关的运行时数据，这些运行时数据是<code>synchronized</code>以及其他类型的锁实现的重要基础，而关于锁标记、GC分代等信息均保存在<code>_mark</code>中。因为本文主要介绍的<code>oop-klass</code>模型，在这里暂时不对对象头做展开，下一篇文章介绍。</p>
<h4 id="metadata"><a href="#metadata" class="headerlink" title="_metadata"></a>_metadata</h4><p>前面介绍到的<code>_metadata</code>是一个共用体，其中<code>_klass</code>是普通指针，<code>_compressed_klass</code>是压缩类指针。在深入介绍之前，就要来到<code>oop-Klass</code>中的另外一个主角<code>klass</code>了。</p>
<h3 id="klass"><a href="#klass" class="headerlink" title="klass"></a>klass</h3><p>klass体系</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//klassOop的一部分，用来描述语言层的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Klass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//在虚拟机层面描述一个Java类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">instanceKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//专有instantKlass，表示java.lang.Class的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>     <span class="title">instanceMirrorKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//专有instantKlass，表示java.lang.ref.Reference的子类的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>     <span class="title">instanceRefKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示methodOop的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">methodKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示constMethodOop的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">constMethodKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示methodDataOop的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">methodDataKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//最为klass链的端点，klassKlass的Klass就是它自身</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">klassKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示instanceKlass的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>     <span class="title">instanceKlassKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示arrayKlass的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>     <span class="title">arrayKlassKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示objArrayKlass的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>       <span class="title">objArrayKlassKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示typeArrayKlass的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>       <span class="title">typeArrayKlassKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示array类型的抽象基类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">arrayKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示objArrayOop的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>     <span class="title">objArrayKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示typeArrayOop的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>     <span class="title">typeArrayKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示constantPoolOop的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">constantPoolKlass</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示constantPoolCacheOop的Klass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">constantPoolCacheKlass</span>;</span></span></pre></td></tr></table></figure>

<p>和<code>oopDesc</code>是其他oop类型的父类一样，Klass类是其他klass类型的父类。<br><a href="http://image.winrains.cn/2019/08/527b3-klass.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/527b3-klass.png" alt="klass"></a><br>Klass向JVM提供两个功能：</p>
<ul>
<li>实现语言层面的Java类（在Klass基类中已经实现）</li>
<li>实现Java对象的分发功能（由Klass的子类提供虚函数实现）</li>
</ul>
<p>文章开头的时候说过：之所以设计<code>oop-klass</code>模型，是因为HotSopt JVM的设计者不想让每个对象中都含有一个虚函数表。<br>HotSopt JVM的设计者把对象一拆为二，分为<code>klass</code>和<code>oop</code>，其中<code>oop</code>的职能主要在于表示对象的实例数据，所以其中不含有任何虚函数。而klass为了实现虚函数多态，所以提供了虚函数表。所以，关于Java的多态，其实也有虚函数的影子在。<br><code>_metadata</code>是一个共用体，其中<code>_klass</code>是普通指针，<code>_compressed_klass</code>是压缩类指针。这两个指针都指向<code>instanceKlass</code>对象，它用来描述对象的具体类型。</p>
<h3 id="instanceKlass"><a href="#instanceKlass" class="headerlink" title="instanceKlass"></a>instanceKlass</h3><p>JVM在运行时，需要一种用来标识Java内部类型的机制。在HotSpot中的解决方案是：为每一个已加载的Java类创建一个<code>instanceKlass</code>对象，用来在JVM层表示Java类。<br>来看下<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/instanceKlass.hpp" target="_blank" rel="noopener">instanceKlass</a>的内部结构：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类拥有的方法列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">objArrayOop     <span class="variable">_methods</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//描述方法顺序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">typeArrayOop    <span class="variable">_method_ordering</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//实现的接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">objArrayOop     <span class="variable">_local_interfaces</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//继承的接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">objArrayOop     <span class="variable">_transitive_interfaces</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//域</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">typeArrayOop    <span class="variable">_fields</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//常量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">constantPoolOop <span class="variable">_constants</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//类加载器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">oop             <span class="variable">_class_loader</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//protected域</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">oop             <span class="variable">_protection_domain</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ....</span></pre></td></tr></table></figure>

<p>可以看到，一个类该具有的东西，这里面基本都包含了。<br>这里还有个点需要简单介绍一下。<br>在JVM中，对象在内存中的基本存在形式就是oop。那么，对象所属的类，在JVM中也是一种对象，因此它们实际上也会被组织成一种oop，即klassOop。同样的，对于klassOop，也有对应的一个klass来描述，它就是klassKlass，也是klass的一个子类。klassKlass作为oop的klass链的端点。关于对象和数组的klass链大致如下图：<br><a href="http://image.winrains.cn/2019/08/e6430-400_ac3_932.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/e6430-400_ac3_932.png" alt="400_ac3_932"></a><br>在这种设计下，JVM对内存的分配和回收，都可以采用统一的方式来管理。oop-klass-klassKlass关系如图：<br><a href="http://image.winrains.cn/2019/08/ce592-2579123-5b117a7c06e83d84.png" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/ce592-2579123-5b117a7c06e83d84.png" alt="2579123-5b117a7c06e83d84"></a></p>
<h3 id="内存存储"><a href="#内存存储" class="headerlink" title="内存存储"></a>内存存储</h3><p>关于一个Java对象，他的存储是怎样的，一般很多人会回答：对象存储在堆上。稍微好一点的人会回答：对象存储在堆上，对象的引用存储在栈上。今天，再给你一个更加显得牛逼的回答：</p>
<blockquote>
<p>对象的实例（instantOopDesc)保存在堆上，对象的元数据（instantKlass）保存在方法区，对象的引用保存在栈上。</p>
</blockquote>
<p>其实如果细追究的话，上面这句话有点故意卖弄的意思。因为我们都知道。<strong>方法区用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong> 所谓加载的类信息，其实不就是给每一个被加载的类都创建了一个 instantKlass对象么。<br>talk is cheap ,show me the code ：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Model</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.b = b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> c = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Model modelA = <span class="keyword">new</span> Model(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Model modelB = <span class="keyword">new</span> Model(<span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>存储结构如下：<br><a href="http://image.winrains.cn/2019/08/e3b37-20170615230126453.jpeg" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/08/e3b37-20170615230126453.jpeg" alt="20170615230126453"></a><br>从上图中可以看到，在方法区的instantKlass中有一个<code>int a=1</code>的数据存储。在堆内存中的两个对象的oop中，分别维护着<code>int b=3</code>,<code>int b=2</code>的实例数据。和oopDesc一样，instantKlass也维护着一些<code>fields</code>，用来保存类中定义的类数据，比如<code>int a=1</code>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个<code>instanceKlass</code>，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个<code>instanceOopDesc</code>对象，这个对象中包含了两部分信息，对象头以及元数据。对象头中有一些运行时数据，其中就包括和多线程相关的锁的信息。元数据其实维护的是指针，指向的是对象所属的类的<code>instanceKlass</code>。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://blog.csdn.net/linxdcn/article/details/73287490" target="_blank" rel="noopener">【理解HotSpot虚拟机】对象在jvm中的表示：OOP-Klass模型</a><br><a href="http://www.jianshu.com/p/b6cb4c694951" target="_blank" rel="noopener">Java反射: 从JDK到JVM全链路详解</a><br><a href="http://www.voidcn.com/article/p-pzznrtkc-ez.html" target="_blank" rel="noopener">HotSpotVM 对象机制实现浅析#1</a><br><a href="https://book.douban.com/subject/25847620/" target="_blank" rel="noopener">HotSpot实战</a></p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/1910" target="_blank" rel="noopener">https://www.hollischuang.com/archives/1910</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解多线程（一）：Synchronized的实现原理</title>
    <url>/2019/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ASynchronized%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><code>synchronized</code>，是Java中用于解决并发情况下数据同步访问的一个很重要的关键字。当我们想要保证一个共享资源在同一时间只会被一个线程访问到时，我们可以在代码中使用<code>synchronized</code>关键字对类或者对象加锁。那么，本文来介绍一下<code>synchronized</code>关键字的实现原理是什么。在阅读本文之间，建议先看下<a href="http://www.hollischuang.com/archives/1876" target="_blank" rel="noopener">Java虚拟机是如何执行线程同步的</a> 。</p>
<a id="more"></a>

<h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><p>众所周知，在Java中，<code>synchronized</code>有两种使用形式，同步方法和同步代码块。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hollis 17/11/9.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth1</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">synchronized</span> (SynchronizedTest<span class="class">.<span class="keyword">class</span>)</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.println(<span class="string">"Hello World"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们先来使用<a href="http://www.hollischuang.com/archives/1107" target="_blank" rel="noopener">Javap</a>来反编译以上代码，结果如下（部分无用信息过滤掉了）：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> synchronized <span class="built_in">void</span> doSth();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  descriptor: ()V</span></pre></td></tr><tr><td class="code"><pre><span class="line">  flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Code:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String Hello World</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> doSth1();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  descriptor: ()V</span></pre></td></tr><tr><td class="code"><pre><span class="line">  flags: ACC_PUBLIC</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Code:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">0</span>: ldc           #<span class="number">5</span>                  <span class="comment">// class com/hollis/SynchronizedTest</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">2</span>: dup</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">3</span>: astore_1</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">4</span>: monitorenter</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">5</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="number">8</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String Hello World</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">10</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">13</span>: aload_1</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">14</span>: monitorexit</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">15</span>: goto          <span class="number">23</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">18</span>: astore_2</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">19</span>: aload_1</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">20</span>: monitorexit</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">21</span>: aload_2</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">22</span>: athrow</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="number">23</span>: <span class="keyword">return</span></span></pre></td></tr></table></figure>

<p><a href="http://www.hollischuang.com/archives/58" target="_blank" rel="noopener">反编译</a>后，我们可以看到Java编译器为我们生成的字节码。在对于<code>doSth</code>和<code>doSth1</code>的处理上稍有不同。也就是说。JVM对于同步方法和同步代码块的处理方式不同。<br>对于同步方法，JVM采用<code>ACC_SYNCHRONIZED</code>标记符来实现同步。 对于同步代码块。JVM采用<code>monitorenter</code>、<code>monitorexit</code>两个指令来实现同步。<br>关于这部分内容，在<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.14" target="_blank" rel="noopener">JVM规范</a>中也可以找到相关的描述。</p>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10" target="_blank" rel="noopener">The Java® Virtual Machine Specification</a>中有关于方法级同步的介绍：</p>
<blockquote>
<p>Method-level synchronization is performed implicitly, as part of method invocation and return. A synchronized method is distinguished in the run-time constant pool’s method_info structure by the ACC_SYNCHRONIZED flag, which is checked by the method invocation instructions. When invoking a method for which ACC_SYNCHRONIZED is set, the executing thread enters a monitor, invokes the method itself, and exits the monitor whether the method invocation completes normally or abruptly. During the time the executing thread owns the monitor, no other thread may enter it. If an exception is thrown during invocation of the synchronized method and the synchronized method does not handle the exception, the monitor for the method is automatically exited before the exception is rethrown out of the synchronized method.</p>
</blockquote>
<p>主要说的是： 方法级的同步是隐式的。同步方法的常量池中会有一个<code>ACC_SYNCHRONIZED</code>标志。当某个线程要访问某个方法的时候，会检查是否有<code>ACC_SYNCHRONIZED</code>，如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁。这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。</p>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>同步代码块使用<code>monitorenter</code>和<code>monitorexit</code>两个指令实现。 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html" target="_blank" rel="noopener">The Java® Virtual Machine Specification</a> 中有关于这两个指令的介绍：</p>
<h4 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h4><blockquote>
<p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:</p>
<blockquote>
<p>If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.<br>If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.<br>If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.</p>
</blockquote>
</blockquote>
<h4 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h4><blockquote>
<p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.<br>The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p>
</blockquote>
<p>大致内容如下： 可以把执行<code>monitorenter</code>指令理解为加锁，执行<code>monitorexit</code>理解为释放锁。 每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁（执行<code>monitorenter</code>）后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁（执行<code>monitorexit</code>指令）的时候，计数器再自减。当计数器为0的时候。锁将被释放，其他线程便可以获得锁。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>同步方法通过<code>ACC_SYNCHRONIZED</code>关键字隐式的对方法进行加锁。当线程要执行的方法被标注上<code>ACC_SYNCHRONIZED</code>时，需要先获得锁才能执行该方法。<br>同步代码块通过<code>monitorenter</code>和<code>monitorexit</code>执行来进行加锁。当线程执行到<code>monitorenter</code>的时候要先获得所锁，才能执行后面的方法。当线程执行到<code>monitorexit</code>的时候则要释放锁。<br>每个对象自身维护这一个被加锁次数的计数器，当计数器数字为0时表示可以被任意线程获得锁。当计数器不为0时，只有获得锁的线程才能再次获得锁。即可重入锁。</p>
</blockquote>
<p>至此，我们大致了解了Synchronized的原理。但是还有几个问题并没有介绍清楚，比如，Monitor到底是什么？对象的锁的状态保存在哪里？ 别急，后面会再介绍。</p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/1883" target="_blank" rel="noopener">https://www.hollischuang.com/archives/1883</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>Synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>同步容器Vector并不是所有操作都线程安全</title>
    <url>/2019/12/26/%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8Vector%E5%B9%B6%E4%B8%8D%E6%98%AF%E6%89%80%E6%9C%89%E6%93%8D%E4%BD%9C%E9%83%BD%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h3 id="问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？"><a href="#问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？" class="headerlink" title="问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？"></a><strong>问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？</strong></h3><p><strong>答：同步容器中的所有自带方法都是线程安全的，因为方法都使用<code>synchronized</code>关键字标注。但是，对这些集合类的复合操作无法保证其线程安全性。需要客户端通过主动加锁来保证</strong><br>如果你看过JDK的源码，那么你会发现，像Vector这样的同步容器的所有共有方法全都是<code>synchronized</code>的。也就是说，我们可以在多线程场景中放心的使用<strong>单独</strong>这些方法，因为这些方法本身的确是线程安全的。那么为什么又说复合操作无法保证线程安全呢？这里举个栗子，我们定义如下删除Vector中最后一个元素方法：</p>
<a id="more"></a>

<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">deleteLast</span><span class="params">(Vector v)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> lastIndex  = v.<span class="built_in">size</span>()<span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    v.<span class="built_in">remove</span>(lastIndex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面这个方法是一个复合方法，包括<code>size(）</code>和<code>remove()</code>，乍一看上去好像并没有什么问题，无论是<code>size()</code>方法还是<code>remove()</code>方法都是线程安全的，那么整个<code>deleteLast</code>方法应该也是线程安全的。但是时，如果多线程调用该方法的过程中有，<code>remove</code>方法有可能抛出<code>ArrayIndexOutOfBoundsException</code>。我们看一下<code>remove</code>方法具体实现，什么情况下会抛出这个异常呢。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> synchronized E remove(<span class="keyword">int</span> <span class="keyword">index</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    modCount++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">index</span> &gt;= elementCount)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="keyword">index</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    E oldValue = elementData(<span class="keyword">index</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> numMoved = elementCount - <span class="keyword">index</span> - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.arraycopy(elementData, <span class="keyword">index</span>+<span class="number">1</span>, elementData, <span class="keyword">index</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                         numMoved);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> oldValue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>从上面代码中可以看出，当<code>index &gt;= elementCount</code>时，会抛出<code>ArrayIndexOutOfBoundsException</code>，也就是说，当当前索引值不再有效的时候，将会抛出这个异常。因为<code>removeLast</code>方法，有可能被多个线程同时执行，当线程一通过<code>index()</code>获得索引值为10，在尝试通过<code>remove()</code>删除该索引位置的元素之前，线程2把该索引位置的值删除掉了，这时线程一在执行时便会抛出异常。<br>为了避免出现类似问题，可以尝试加锁：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    synchronized (v) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> index = v.<span class="built_in">size</span>() - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        v.<span class="built_in">remove</span>(index);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如上，我们在<code>deleteLast</code>中，对v进行加锁，即可保证同一时刻，不会有其他线程删除掉v中的元素。<br>至此，我们已经解释清楚了我们的问题。</p>
<h3 id="问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？-1"><a href="#问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？-1" class="headerlink" title="问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？"></a><strong>问：对于线程安全的集合类（例如Vector）的任何操作是不是都能保证线程安全？</strong></h3><p><strong>答：同步容器中的所有自带方法都是线程安全的，因为方法都使用<code>synchronized</code>关键字标注。但是，对这些集合类的复合操作无法保证其线程安全性。需要客户端通过主动加锁来保证。</strong><br>由于我们自己已知<code>Vector</code>等同步容器是线程安全的，所以我们通常在多线程场景中会直接拿来使用，并不会考虑太多，从而可能导致问题。<br>所以，我们在使用同步容器的时候，如果只使用其中的自带方法，那么可以放心使用，因为他们是线程安全的，但是如果我们想做复合操作，尤其是涉及到删除容器中的元素时，一定要注意是否需要客户端主动加锁。<br>下面，我们考虑以下代码，如果在多线程场景中使用会不会出现线程安全问题：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &lt; v.size(); i++) &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="name">v</span>.get(<span class="name">i</span>))<span class="comment">;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>显然，以上代码在迭代的过程中，并不会出现线程安全问题。但是，如果在程序中还有以下代码有可能被同时调用呢？</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; v.<span class="built_in">size</span>(); <span class="built_in">i</span>++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    v.remove(<span class="built_in">i</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>由于，不同线程在同一时间操作同一个Vector，其中包括删除操作，那么就同样有可能发生线程安全问题。所以，在使用同步容器的时候，如果涉及到多个线程同时执行删除操作，就要考虑下是否需要加锁。</p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/1786" target="_blank" rel="noopener">https://www.hollischuang.com/archives/1786</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>线程安全</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中String类型是否有长度限制</title>
    <url>/2019/12/26/Java%E4%B8%ADString%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E6%9C%89%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/</url>
    <content><![CDATA[<p>String是Java中很重要的一个数据类型，除了基本数据类型以外，String是被使用的最广泛的了，但是，关于String，其实还是有很多东西容易被忽略的。就如本文我们要讨论的问题：Java中的String有没有长度限制？这个问题要分两个阶段看，分别是编译期和运行期。不同的时期限制不一样。</p>
<a id="more"></a>

<h3 id="编译期"><a href="#编译期" class="headerlink" title="编译期"></a>编译期</h3><p>首先，我们先来合理的推断一下，当我们在代码中使用String s = “”;的形式来定义String对象的时候，””中字符的个数有没有限制呢？<br>既然是合理的推断，那就要要足够的依据，所以我们可以从String的源码入手，根据public String(char value[], int offset, int count)的定义，count是int类型的，所以，char value[]中最多可以保存Integer.MAX_VALUE个,即2147483647字符。(jdk1.8.0_73)<br>但是，实验证明，String s = “”;中，最多可以有65534个字符。如果超过这个个数。就会在编译期报错。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">String</span> s = <span class="string">"a...a"</span>;<span class="comment">// 共65534个a</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.<span class="built_in">println</span>(s.length());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">String</span> s1 = <span class="string">"a...a"</span>;<span class="comment">// 共65535个a</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.<span class="built_in">println</span>(s1.length());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>以上代码，会在String s1 = “a…a”;// 共65535个a处编译失败：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">✗ javac <span class="module-access"><span class="module"><span class="identifier">StringLenghDemo</span>.</span></span>java</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">StringLenghDemo</span>.</span></span>java:<span class="number">11</span>: 错误: 常量字符串过长</span></pre></td></tr></table></figure>

<p><strong>明明说好的长度限制是2147483647，为什么65535个字符就无法编译了呢？</strong><br>当我们使用字符串字面量直接定义String的时候，是会把字符串在常量池中存储一份的。那么上面提到的65534其实是常量池的限制。<br>常量池中的每一种数据项也有自己的类型。Java中的UTF-8编码的Unicode字符串在常量池中以CONSTANT_Utf8类型表示。<br>CONSTANTUtf8info是一个CONSTANTUtf8类型的常量池数据项，它存储的是一个常量字符串。常量池中的所有字面量几乎都是通过CONSTANTUtf8info描述的。CONSTANTUtf8_info的定义如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">CONSTANT_Utf8_info</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">u1</span> tag;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">u2</span> length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attribute">u1</span> bytes[length];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>由于本文的重点并不是CONSTANTUtf8info的介绍，这里就不详细展开了，我们只需要我们使用字面量定义的字符串在class文件中，是使用CONSTANTUtf8info存储的，而CONSTANTUtf8info中有u2 length;表明了该类型存储数据的长度。<br>u2是无符号的16位整数，因此理论上允许的的最大长度是2^16=65536。而 java class 文件是使用一种变体UTF-8格式来存放字符的，null 值使用两个 字节来表示，因此只剩下 65536－ 2 ＝ 65534个字节。<br>关于这一点，在the class file format spec中也有明确说明：</p>
<blockquote>
<p>The length of field and method names, field and method descriptors, and other constant string values is limited to 65535 characters by the 16-bit unsigned length item of the CONSTANTUtf8info structure (§4.4.7). Note that the limit is on the number of bytes in the encoding and not on the number of encoded characters. UTF-8 encodes some characters using two or three bytes. Thus, strings incorporating multibyte characters are further constrained.</p>
</blockquote>
<p><strong>也就是说，在Java中，所有需要保存在常量池中的数据，长度最大不能超过65535，这当然也包括字符串的定义咯。</strong></p>
<h3 id="运行期"><a href="#运行期" class="headerlink" title="运行期"></a>运行期</h3><p>上面提到的这种String长度的限制是编译期的限制，也就是使用String s= “”;这种字面值方式定义的时候才会有的限制。<br>那么。String在运行期有没有限制呢，答案是有的，就是我们前文提到的那个Integer.MAX_VALUE ，这个值约等于4G，在运行期，如果String的长度超过这个范围，就可能会抛出异常。(在jdk 1.9之前）<br>int 是一个 32 位变量类型，取正数部分来算的话，他们最长可以有</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>^<span class="number">31</span>-<span class="number">1</span> =<span class="number">2147483647</span> 个 <span class="number">16</span>-bit Unicodecharacter</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">2147483647 </span>* <span class="number">16</span> = <span class="number">34359738352</span> 位</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">34359738352 </span>/ <span class="number">8</span> = <span class="number">4294967294</span> (Byte)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">4294967294 </span>/ <span class="number">1024</span> = <span class="number">4194303.998046875</span> (KB)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4194303.998046875</span> / <span class="number">1024</span> = <span class="number">4095.9999980926513671875</span> (MB)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4095.9999980926513671875</span> / <span class="number">1024</span> = <span class="number">3.99999999813735485076904296875</span> (GB)</span></pre></td></tr></table></figure>

<p>有近 4G 的容量。</p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/3916" target="_blank" rel="noopener">https://www.hollischuang.com/archives/3916</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
  </entry>
  <entry>
    <title>工厂模式介绍</title>
    <url>/2019/12/26/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>很多人认为工厂模式很简单，只是有一个建造工厂，帮我们进行对象构造而已。那么请尝试回答下以下问题：</p>
<blockquote>
<p>1、工厂模式分为几类？<br>2、GOF 23种设计模式中，工厂方法模式和抽象工厂模式有什么区别？<br>3、不在GOF 23种设计模式中的简单工厂模式是什么？<br>4、简单工厂模式、工厂方法模式和抽象工厂模式各自解决什么问题？有什么不同？</p>
</blockquote>
<p>如果以上四个问题，你都可以很好的回答的话，那么这篇文章就没有继续读下去的必要了，否则，建议你好好学习下本文。</p>
<a id="more"></a>

<h3 id="三种工厂模式"><a href="#三种工厂模式" class="headerlink" title="三种工厂模式"></a>三种工厂模式</h3><p>工厂模式可以分为三类：</p>
<ul>
<li>1）简单工厂模式（Simple Factory）</li>
<li>2）工厂方法模式（Factory Method）</li>
<li>3）抽象工厂模式（Abstract Factory）</li>
</ul>
<p>这三种模式从上到下逐步抽象，并且更具一般性。<br>GOF在《设计模式》一书中将工厂模式分为两类：工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）。<br>将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。<br>这三种工厂模式在设计模式的分类中都属于<strong>创建型模式</strong>。<br>创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。<br>创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。<br>创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。<br>工厂模式是创建型模式中比较重要的。工厂模式的主要功能就是帮助我们实例化对象的。<strong>之所以名字中包含工厂模式四个字，是因为对象的实例化过程是通过工厂实现的，是用工厂代替new操作的。</strong><br>这样做的好处是封装了对象的实例化细节，尤其是对于实例化较复杂或者对象的生命周期应该集中管理的情况。会给你系统带来更大的可扩展性和尽量少的修改量。<br>接下来我们分别介绍下这三种工厂模式。</p>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。<br>在介绍简单工厂模式之前，我们尝试解决以下问题：<br>现在我们要使用面向对象的形式定义计算器，为了实现各算法之间的解耦。主要的用到的类如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算类的基类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> double value1 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> double value2 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public double getValue1() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> value1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void setValue1(double value1) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.value1 = value1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public double getValue2() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> value2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void setValue2(double value2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.value2 = value2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> double getResule();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//加法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> double getResule() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> getValue1() + getValue2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//减法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OperationSub</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> double getResule() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> getValue1() - getValue2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//乘法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OperationMul</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> double getResule() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> getValue1() * getValue2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//除法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OperationDiv</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> double getResule() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (getValue2() != <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> getValue1() / getValue2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"除数不能为零"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>当我想要执行加法运算时，可以使用如下代码：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        OperationAdd operationAdd = <span class="keyword">new</span> OperationAdd();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        operationAdd.setValue1(<span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        operationAdd.setValue2(<span class="number">5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(operationAdd.getResule());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>当我需要执行减法运算时，我就要创建一个OperationSub类。也就是说，我想要使用不同的运算的时候就要创建不同的类，并且要明确知道该类的名字。<br>那么这种重复的创建类的工作其实可以放到一个统一的工厂类中。简单工厂模式有以下优点：</p>
<blockquote>
<p>1、一个调用者想创建一个对象，只要知道其名称就可以了。<br>2、屏蔽产品的具体实现，调用者只关心产品的接口。</p>
</blockquote>
<h4 id="简单工厂模式实现方式"><a href="#简单工厂模式实现方式" class="headerlink" title="简单工厂模式实现方式"></a><strong>简单工厂模式实现方式</strong></h4><p>简单工厂模式其实和他的名字一样，很简单。先来看看它的组成:</p>
<blockquote>
<p>Factory:这是本模式的核心,含有一定的商业逻辑和判断逻辑。在java中它往往由 一个具体类实现。（OperationFactory）<br>Product:它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。（Operation）<br>ConcreteProduct:工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。 来用类图来清晰的表示下的它们之间的关系（OperationAdd\OperationSub等）</p>
</blockquote>
<p><img src="http://image.winrains.cn/2019/08/c5e3c-15588649289622.jpg" alt="img"><br>在原有类的基础上，定义工厂类：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工厂类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Operation createOperation(<span class="keyword">String</span> operation) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Operation oper = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">"+"</span>:<span class="type"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="type">                oper </span>= <span class="keyword">new</span> <span class="type">OperationAdd</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">"-"</span>:<span class="type"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="type">                oper </span>= <span class="keyword">new</span> <span class="type">OperationSub</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">"*"</span>:<span class="type"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="type">                oper </span>= <span class="keyword">new</span> <span class="type">OperationMul</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">"/"</span>:<span class="type"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="type">                oper </span>= <span class="keyword">new</span> <span class="type">OperationDiv</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">default</span>:<span class="type"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="type">                throw new UnsupportedOperationException</span>(<span class="string">"不支持该操作"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> oper;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>有了工厂类之后，可以使用工厂创建对象：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Operation operationAdd = <span class="module-access"><span class="module"><span class="identifier">OperationFactory</span>.</span></span>create<span class="constructor">Operation(<span class="string">"+"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">operationAdd.set<span class="constructor">Value1(10)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">operationAdd.set<span class="constructor">Value2(5)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(operationAdd.get<span class="constructor">Resule()</span>);</span></pre></td></tr></table></figure>

<p>通过简单工厂模式，该计算器的使用者不需要关系实现加法逻辑的那个类的具体名字，他只要知道该类对应的参数”+”就可以了。</p>
<h4 id="简单工厂模式存在的问题"><a href="#简单工厂模式存在的问题" class="headerlink" title="简单工厂模式存在的问题"></a><strong>简单工厂模式存在的问题</strong></h4><p>当我们需要增加一种计算时，例如开平方。这个时候我们需要先定义一个类继承<code>Operation</code>类，其中实现平方的代码。除此之外我们还要修改<code>OperationFactory</code>类的代码，增加一个case。这显然是违背开闭原则的。可想而知对于新产品的加入，工厂类是很被动的。<br>我们举的例子是最简单的情况。而在实际应用中，很可能产品是一个多层次的树状结构。 简单工厂可能就不太适用了。</p>
<h4 id="简单工厂模式总结"><a href="#简单工厂模式总结" class="headerlink" title="简单工厂模式总结"></a><strong>简单工厂模式总结</strong></h4><p>工厂类是整个简单工厂模式的关键。包含了必要的逻辑判断，根据外界给定的信息，决定究竟应该创建哪个具体类的对象。通过使用工厂类，外界可以从直接创建具体产品对象的尴尬局面摆脱出来，仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的。明确了各自的职责和权利，有利于整个软件体系结构的优化。<br>但是由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。<br>当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；<br>这些缺点在工厂方法模式中得到了一定的解决。</p>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。<br>工厂方法模式是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。</p>
<blockquote>
<p>工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。”</p>
</blockquote>
<h4 id="工厂方法模式用途"><a href="#工厂方法模式用途" class="headerlink" title="工厂方法模式用途"></a><strong>工厂方法模式用途</strong></h4><p>工厂方法模式和简单工厂模式虽然都是通过工厂来创建对象，他们之间最大的不同是——<strong>工厂方法模式在设计上完全完全符合“开闭原则”。</strong><br>在以下情况下可以使用工厂方法模式：</p>
<blockquote>
<p>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。<br>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。<br>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</p>
</blockquote>
<h4 id="工厂方法模式实现方式"><a href="#工厂方法模式实现方式" class="headerlink" title="工厂方法模式实现方式"></a><strong>工厂方法模式实现方式</strong></h4><p>工厂方法模式包含如下角色：</p>
<blockquote>
<p>Product：抽象产品（<code>Operation</code>）<br>ConcreteProduct：具体产品(<code>OperationAdd</code>)<br>Factory：抽象工厂(<code>IFactory</code>)<br>ConcreteFactory：具体工厂(<code>AddFactory</code>)</p>
</blockquote>
<p><img src="http://image.winrains.cn/2019/08/7fbba-15588647240804.jpg" alt="img"><br>这里还用计算器的例子。在保持<code>Operation</code>，<code>OperationAdd</code>，<code>OperationDiv</code>，<code>OperationSub</code>，<code>OperationMul</code>等几个方法不变的情况下，修改简单工厂模式中的工厂类（<code>OperationFactory</code>）。替代原有的那个”万能”的大工厂类，这里使用工厂方法来代替：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工厂接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">Operation <span class="title">CreateOption</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//加法类工厂</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOption</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationAdd();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//除法类工厂</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOption</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationDiv();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//除法类工厂</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOption</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationMul();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//减法类工厂</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOption</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationSub();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这样，在客户端中想要执行加法运算时，需要以下方式：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        IFactory factory = <span class="keyword">new</span> AddFactory();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Operation operationAdd =  factory.CreateOption();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        operationAdd.setValue1(<span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        operationAdd.setValue2(<span class="number">5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(operationAdd.<span class="built_in">getResult</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>到这里，一个工厂方法模式就已经写好了。<br>从代码量上看，这种工厂方法模式比简单工厂方法模式更加复杂。针对不同的操作（Operation）类都有对应的工厂。很多人会有以下疑问：</p>
<blockquote>
<p>貌似工厂方法模式比简单工厂模式要复杂的多？<br>工厂方法模式和我自己创建对象没什么区别？为什么要多搞出一些工厂来？</p>
</blockquote>
<p>下面就针对以上两个问题来深入理解一下工厂方法模式。</p>
<h4 id="为什么要使用工厂来创建对象？"><a href="#为什么要使用工厂来创建对象？" class="headerlink" title="为什么要使用工厂来创建对象？"></a><strong>为什么要使用工厂来创建对象？</strong></h4><blockquote>
<p>封装对象的创建过程</p>
</blockquote>
<p>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户<strong>隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</strong><br>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。<strong>它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。</strong>工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</p>
<h4 id="为什么每种对象要单独有一个工厂？"><a href="#为什么每种对象要单独有一个工厂？" class="headerlink" title="为什么每种对象要单独有一个工厂？"></a><strong>为什么每种对象要单独有一个工厂？</strong></h4><blockquote>
<p>符合『开放-封闭原则』</p>
</blockquote>
<p>主要目的是为了解耦。在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则。<br>以上就是工厂方法模式的优点。但是，工厂模式也有一些不尽如人意的地方：</p>
<blockquote>
<p>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。<br>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</p>
</blockquote>
<h4 id="工厂方法模式总结"><a href="#工厂方法模式总结" class="headerlink" title="工厂方法模式总结"></a><strong>工厂方法模式总结</strong></h4><p>工厂方法模式是简单工厂模式的进一步抽象和推广。<br>由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。<br>在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。<br>工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。<br>抽象工厂模式提供了一种方式，可以将同一产品族的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。</p>
<h4 id="产品族"><a href="#产品族" class="headerlink" title="产品族"></a><strong>产品族</strong></h4><p>来认识下什么是产品族: 位于不同产品等级结构中,功能相关的产品组成的家族。如下面的例子，就有两个产品族：跑车族和商务车族。<br><img src="http://image.winrains.cn/2019/08/5a461-15588644956826.jpg" alt="img"></p>
<h4 id="抽象工厂模式用途"><a href="#抽象工厂模式用途" class="headerlink" title="抽象工厂模式用途"></a><strong>抽象工厂模式用途</strong></h4><p>抽象工厂模式和工厂方法模式一样，都符合开放-封闭原则。但是不同的是，工厂方法模式在增加一个具体产品的时候，都要增加对应的工厂。但是抽象工厂模式只有在新增一个类型的具体产品时才需要新增工厂。也就是说，工厂方法模式的一个工厂只能创建一个具体产品。而抽象工厂模式的一个工厂可以创建属于一类类型的多种具体产品。工厂创建产品的个数介于简单工厂模式和工厂方法模式之间。<br>在以下情况下可以使用抽象工厂模式：</p>
<blockquote>
<p>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。<br>系统中有多于一个的产品族，而每次只使用其中某一产品族。<br>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。<br>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</p>
</blockquote>
<h4 id="抽象工厂模式实现方式"><a href="#抽象工厂模式实现方式" class="headerlink" title="抽象工厂模式实现方式"></a><strong>抽象工厂模式实现方式</strong></h4><p>抽象工厂模式包含如下角色：</p>
<blockquote>
<p>AbstractFactory(抽象工厂)：用于声明生成抽象产品的方法<br>ConcreteFactory(具体工厂)：实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中；<br>AbstractProduct(抽象产品)：为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法；<br>Product(具体产品)：定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。</p>
</blockquote>
<p>本文的例子采用一个汽车代工厂造汽车的例子。假设我们是一家汽车代工厂商，我们负责给奔驰和特斯拉两家公司制造车子。我们简单的把奔驰车理解为需要加油的车，特斯拉为需要充电的车。其中奔驰车中包含跑车和商务车两种，特斯拉同样也包含奔驰车和商务车。<br><img src="http://image.winrains.cn/2019/08/c1a96-15588645213493.jpg" alt="img"><br>以上场景，我们就可以把跑车和商务车分别对待，对于跑车有单独的工厂创建，商务车也有单独的工厂。这样，以后无论是再帮任何其他厂商造车，只要是跑车或者商务车我们都不需要再引入工厂。同样，如果我们要增加一种其他类型的车，比如越野车，我们也不需要对跑车或者商务车的任何东西做修改。<br>下面是抽象产品，奔驰车和特斯拉车：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">BenzCar</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//加汽油</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> gasUp();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">TeslaCar</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//充电</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> charge();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>下面是具体产品，奔驰跑车、奔驰商务车、特斯拉跑车、特斯拉商务车：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">BenzSportCar</span> <span class="symbol">implements</span> <span class="symbol">BenzCar</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> gasUp() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"给我的奔驰跑车加最好的汽油"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">BenzBusinessCar</span> <span class="symbol">implements</span> <span class="symbol">BenzCar</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> gasUp() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"给我的奔驰商务车加一般的汽油"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">TeslaSportCar</span> <span class="symbol">implements</span> <span class="symbol">TeslaCar</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> charge() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"给我特斯拉跑车冲满电"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">TeslaBusinessCar</span> <span class="symbol">implements</span> <span class="symbol">TeslaCar</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> charge() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"不用给我特斯拉商务车冲满电"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>下面是抽象工厂：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>CarFactory &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public BenzCar getBenzCar();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public TeslaCar getTeslaCar();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>下面是具体工厂：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SportCarFactory</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">CarFactory</span></span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> BenzCar getBenzCar() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">BenzSportCar</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> TeslaCar getTeslaCar() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">TeslaSportCar</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessCarFactory</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">CarFactory</span></span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> BenzCar getBenzCar() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">BenzBusinessCar</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> TeslaCar getTeslaCar() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">TeslaBusinessCar</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="“开闭原则”的倾斜性"><a href="#“开闭原则”的倾斜性" class="headerlink" title="“开闭原则”的倾斜性"></a><strong>“开闭原则”的倾斜性</strong></h4><p>“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的。对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：</p>
<blockquote>
<p>增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。<br>增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持“开闭原则”。</p>
</blockquote>
<p>抽象工厂模式的这种性质称为“开闭原则”的倾斜性，抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，但不能为新的产品等级结构的增加提供这样的方便。</p>
<h4 id="抽象工厂模式总结"><a href="#抽象工厂模式总结" class="headerlink" title="抽象工厂模式总结"></a><strong>抽象工厂模式总结</strong></h4><p>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。<br>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。<br>抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。</p>
<h3 id="三种工厂模式对比"><a href="#三种工厂模式对比" class="headerlink" title="三种工厂模式对比"></a>三种工厂模式对比</h3><h4 id="简单工厂模式的优缺点"><a href="#简单工厂模式的优缺点" class="headerlink" title="简单工厂模式的优缺点"></a><strong>简单工厂模式的优缺点</strong></h4><ul>
<li>优点：<ul>
<li>1、屏蔽产品的具体实现，调用者只关心产品的接口。</li>
<li>2、实现简单</li>
</ul>
</li>
<li>缺点：<ul>
<li>1、增加产品，需要修改工厂类，不符合开放-封闭原则</li>
<li>2、工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则</li>
</ul>
</li>
</ul>
<h4 id="工厂方法模式的优缺点"><a href="#工厂方法模式的优缺点" class="headerlink" title="工厂方法模式的优缺点"></a><strong>工厂方法模式的优缺点</strong></h4><ul>
<li>优点：<ul>
<li>1、继承了简单工厂模式的优点</li>
<li>2、符合开放-封闭原则</li>
</ul>
</li>
<li>缺点：<ul>
<li>1、增加产品，需要增加新的工厂类，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</li>
</ul>
</li>
</ul>
<h4 id="抽象工厂模式的优缺点"><a href="#抽象工厂模式的优缺点" class="headerlink" title="抽象工厂模式的优缺点"></a><strong>抽象工厂模式的优缺点</strong></h4><ul>
<li>优点：<ul>
<li>1、隔离了具体类的生成，使得客户并不需要知道什么被创建</li>
<li>2、每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；</li>
</ul>
</li>
<li>缺点<ul>
<li>增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。</li>
</ul>
</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/eb056-15588638543500.jpg" alt="img"><br>简单工厂 ： 用来生产同一等级结构中的任意产品。（对于增加新的产品，主要是新增产品，就要修改工厂类。符合单一职责原则。不符合开放-封闭原则）<br>工厂方法 ：用来生产同一等级结构中的固定产品。（支持增加任意产品，新增产品时不需要更改已有的工厂，需要增加该产品对应的工厂。符合单一职责原则、符合开放-封闭原则。但是引入了复杂性）<br>抽象工厂 ：用来生产不同产品族的全部产品。（增加新产品时，需要修改工厂，增加产品族时，需要增加工厂。符合单一职责原则，部分符合开放-封闭原则，降低了复杂性）<br>最后，三种工厂模式各有优缺点，没有最好的，只有最合适的！</p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/3709" target="_blank" rel="noopener">https://www.hollischuang.com/archives/3709</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>工厂模式</category>
      </categories>
  </entry>
  <entry>
    <title>IntelliJ IDEA必装插件</title>
    <url>/2019/12/26/IntelliJ-IDEA%E5%BF%85%E8%A3%85%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>本文，给大家推荐几款我私藏已久的，自己经常使用的，可以提升代码效率的插件。</p>
<a id="more"></a>

<h2 id="IDEA插件简介"><a href="#IDEA插件简介" class="headerlink" title="IDEA插件简介"></a>IDEA插件简介</h2><p>常见的IDEA插件主要有如下几类：</p>
<h3 id="常用工具支持"><a href="#常用工具支持" class="headerlink" title="常用工具支持"></a>常用工具支持</h3><p>Java日常开发需要接触到很多常用的工具，为了便于使用，很多工具也有IDEA插件供开发使用，其中大部分已经在IDEA中默认集成了。例如maven、git、svn、tomcat、jetty、jrebel、Gradle等。</p>
<h3 id="功能增强"><a href="#功能增强" class="headerlink" title="功能增强"></a>功能增强</h3><p>还有些插件提供了一些IDE中不具有的功能，比如静态代码扫描、代码自动生成等。</p>
<h3 id="框架集成"><a href="#框架集成" class="headerlink" title="框架集成"></a>框架集成</h3><p>集成框架主要是为了提供框架定制的代码和配置的生成，以及快速的访问框架提供的功能。例如集成Spring框架，Mybatis框架等。</p>
<h3 id="UI定制化及优化"><a href="#UI定制化及优化" class="headerlink" title="UI定制化及优化"></a>UI定制化及优化</h3><p>UI定制化相关的插件主要提供一下个性化需求定制，例如修改编辑区的背景图片插件、修改代码颜色等。</p>
<h3 id="其他编程语言支持"><a href="#其他编程语言支持" class="headerlink" title="其他编程语言支持"></a>其他编程语言支持</h3><p>IDEA主要支持Java，为了使用其他语言，可以使用一些支持其他语言的插件，通过这些插件可以实现语法分析，配色主题，代码格式化和提示等功能。例如Go语言的支持的插件。</p>
<h3 id="个人或者公司特殊需求"><a href="#个人或者公司特殊需求" class="headerlink" title="个人或者公司特殊需求"></a>个人或者公司特殊需求</h3><p>公司内部插件</p>
<h2 id="我的插件一览"><a href="#我的插件一览" class="headerlink" title="我的插件一览"></a>我的插件一览</h2><p>这里简单介绍一些笔者日常开发中使用到的插件。 以下是我的IDEA中自己安装的插件列表。这些插件都是我经过很长时间的使用之后最终保留下来的，都是值得安装的一些插件。其中被我打码的就是公司内部插件。<br><img src="http://image.winrains.cn/2019/08/40c4f-15479665089765.jpg" alt="img"></p>
<h2 id="IDEA插件安装"><a href="#IDEA插件安装" class="headerlink" title="IDEA插件安装"></a>IDEA插件安装</h2><p>IDEA的插件安装非常简单，对于很多插件来说，只要你知道插件的名字就可以在IDEA里面直接安装。<br>Preferences—&gt;Plugins—&gt;查找所需插件—&gt;Install<br>或者<br>Preferences—&gt;Plugins—&gt;Install plug from disk —&gt;选择下载好的插件安装<br>安装之后重启IDEA即可生效</p>
<h3 id="IDEA插件仓库"><a href="#IDEA插件仓库" class="headerlink" title="IDEA插件仓库"></a>IDEA插件仓库</h3><p>IntelliJ IDEA激发了许多Java开发人员编写插件， IntelliJ IDEA Plugins（<a href="https://plugins.jetbrains.com/?idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/?idea</a> ）中目前包含3000+个插件并且还在不断增长。<br><img src="http://image.winrains.cn/2019/08/58b19-15479620248612.jpg" alt="img"></p>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><p>作者目前使用的IntelliJ IDEA版本是专业版2018.2.4（Ultimate Edition）<br><img src="http://image.winrains.cn/2019/08/4483c-15479603329394.jpg" alt="img"><br>很多插件中提供的功能在这个版本中都已经集成进来了，这里简单说几个可能比较常用的，这几种功能就无需加装插件了。</p>
<h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><p>目前，IDEA支持设置背景图片。这对于广大程序员来说无疑是个好功能。整日对着枯燥的代码实在是会让人疲乏。要是可以设置一张美女图片的话。。。<br><strong>设置方法</strong><br>Ctrl+Shift+A(或者help -&gt; find action)调用弹窗后输入Set Background Image<br><img src="http://image.winrains.cn/2019/08/28b10-15479606563989.jpg" alt="img"><br>在里面设定要设置为Image的图片,透明度调到15左右，保存即可。<br><img src="http://image.winrains.cn/2019/08/1ac63-15479609892646.jpg" alt="img"><br><strong>效果如下</strong><br><img src="http://image.winrains.cn/2019/08/a4dfc-15479609485695.jpg" alt="img"></p>
<h3 id="内置terminal"><a href="#内置terminal" class="headerlink" title="内置terminal"></a>内置terminal</h3><p>目前IntelliJ IDEA已经有一个内置的terminal工具，可以方便的使用shell命令。<br><img src="http://image.winrains.cn/2019/08/75127-15479610703144.jpg" alt="img"></p>
<h3 id="内置support"><a href="#内置support" class="headerlink" title="内置support"></a>内置support</h3><p>目前很多新版本的IntelliJ IDEA中，已经内置了很多support插件，比如我们常用的markdown support 、UML support 以及 android support等。<br><img src="http://image.winrains.cn/2019/08/f2924-15479615077554.jpg" alt="img"><br>PS：由于作者使用的是专业版，不知道社区版是否也会内置这些插件，如果没有内置的话，读者可以根据需要自行下载相关插件并安装。<br>有了markdowm support插件以后，就可以直接预览md语法的内容了。<br><img src="http://image.winrains.cn/2019/08/761da-15479618675094.jpg" alt="img"></p>
<h2 id="必备插件"><a href="#必备插件" class="headerlink" title="必备插件"></a>必备插件</h2><h3 id="Maven-Helper"><a href="#Maven-Helper" class="headerlink" title="Maven Helper"></a>Maven Helper</h3><p>目前，Java开发很多都在使用maven进行项目管理和自动构建。<br>日常开发中，可能经常会遇到jar包冲突等问题，就需要通过查看maven依赖树来查查看依赖情况。这种方式不是很高效，这里推荐一个插件，安装之后，直接打开pom文件，即可查看依赖数，还能自动分析是否存在jar包冲突。<br>一旦安装了Maven Helper插件，只要打开pom文件，就可以打开该pom文件的Dependency Analyzer视图（在文件打开之后，文件下面会多出这样一个tab）。<br><img src="http://image.winrains.cn/2019/08/3d81a-15479624935730.jpg" alt="img"><br>进入Dependency Analyzer视图之后有三个查看选项，分别是Conflicts(冲突)、All Dependencies as List(列表形式查看所有依赖)、All Dependencies as Tree(树结构查看所有依赖)。并且这个页面还支持搜索。</p>
<h3 id="FindBugs-IDEA"><a href="#FindBugs-IDEA" class="headerlink" title="FindBugs-IDEA"></a>FindBugs-IDEA</h3><p>FindBugs很多人都并不陌生，Eclipse中有插件可以帮助查找代码中隐藏的bug，IDEA中也有这款插件。<br>使用方法很简单，就是可以对多种级别的内容进行finbugs<br><img src="http://image.winrains.cn/2019/08/a365c-15479625706835.png" alt="img"><br>分析完之后会有一个视图进行提示，详细的说明是哪种问题。<br><img src="http://image.winrains.cn/2019/08/c79aa-15479625758685.png" alt="img"><br>按照提示解决完问题之后再执行findbug查看情况即可。</p>
<h3 id="阿里巴巴代码规约检测"><a href="#阿里巴巴代码规约检测" class="headerlink" title="阿里巴巴代码规约检测"></a>阿里巴巴代码规约检测</h3><p>2017年10月14日杭州云栖大会，Java代码规约扫描插件全球首发仪式正式启动，规范正式以插件形式公开走向业界，引领Java语言的规范之路。<br>Java代码规约扫描插件以今年年初发布的《阿里巴巴Java开发规约》为标准，作为Eclipse、IDEA的插件形式存在，检测JAVA代码中存在不规范得位置然后给予提示。规约插件是采用kotlin语言开发的，感兴趣的同学可以去开看插件源码。<br>阿里巴巴规约插件包含三个子菜单：编码规约扫描、关闭试试检测功能。<br><img src="http://image.winrains.cn/2019/08/63d65-15479626591284.jpg" alt="img"><br>并且，该插件支持在编写代码的同时进行提示，<br><img src="http://image.winrains.cn/2019/08/74649-15479627335217.jpg" alt="img"><br>这款插件，真的可以很大程度上提升代码质量，一定要安装。</p>
<h3 id="GsonFormat"><a href="#GsonFormat" class="headerlink" title="GsonFormat"></a>GsonFormat</h3><p>Java开发中，经常有把json格式的内容转成Object的需求，比如项目开始时，合作方给你提供了一个json格式request/response，这时候你就需要将其定义成一个Java类，GsonFormat这款插件可以实现该功能。<br><img src="http://image.winrains.cn/2019/08/abd2e-15479627865604.gif" alt="img"></p>
<h3 id="Lombok-plugin"><a href="#Lombok-plugin" class="headerlink" title="Lombok plugin"></a>Lombok plugin</h3><p>在Java中，我们经常会定义很多JavaBean，这些Bean需要有getter、setter、toString、equals和hashCode等方法。<br>通常情况下，我们可以使用IDEA的快捷键生成这些代码，但是自动生成的代码后，如果bean中的属性一旦有修改，需要重新生成，给代码维护增加了一定的负担。<br>有一款很好的插件，可以帮助开发者节省这部分工作。那就是Lombok。<br>只要在IDEA中安装了该插件，只需要在JavaBean中添加一行注解代码，插件就会自动帮我们生成getter、setter、toString、equals和hashCode等方法。<br>当然，这些方法不止在IDE中的代码调用中需要用到，在真正线上部署的时候也需要有，所以，还需要使用maven引入一个lombok的包。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;groupId&gt;org.projectlombok&lt;<span class="regexp">/groupId&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">      &lt;artifactId&gt;lombok&lt;/</span>artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;version&gt;<span class="number">1.16</span><span class="number">.10</span>&lt;<span class="regexp">/version&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">&lt;/</span>dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * @author Hollis</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HollisLab</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Wechat wechat = <span class="keyword">new</span> Wechat();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wechat.setId(<span class="string">"Hollis"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wechat.setDesc(<span class="string">"每日更新Java技术文章"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(wechat);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Data</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wechat</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private <span class="built_in">String</span> id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private <span class="built_in">String</span> desc;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Wechat(<span class="attribute">id</span>=Hollis, <span class="attribute">desc</span>=每日更新Java技术文章)</span></pre></td></tr></table></figure>

<p>我们在Wechat类上面添加了@Data注解，插件就自动帮我们添加了getter/setter和toString方法。</p>
<h3 id="String-Manipulation"><a href="#String-Manipulation" class="headerlink" title="String Manipulation"></a>String Manipulation</h3><p>字符串日常开发中经常用到的，但是不同的字符串类型在不同的地方可能有一些不同的规则，比如类名要用驼峰形式、常量需要全部大写等，有时候还需要进行编码解码等。这里推荐一款强大的字符串转换工具——String Manipulation。<br>它强大到什么程度，看下他的功能列表你就知道了：<br><img src="http://image.winrains.cn/2019/08/59068-15479639987089.jpg" alt="img"></p>
<ul>
<li>文本转换操作<ul>
<li>切换样式（camelCase, hyphen-lowercase, HYPHEN-UPPERCASE, snake_case, SCREAMING_SNAKE_CASE, dot.case, words lowercase, Words Capitalized, PascalCase）</li>
<li>转换为SCREAMING_SNAKE_CASE (或转换为camelCase)</li>
<li>转换为 snake_case (或转换为camelCase)</li>
<li>转换为dot.case (或转换为camelCase)</li>
<li>转换为hyphen-case (或转换为camelCase)</li>
<li>转换为hyphen-case (或转换为snake_case)</li>
<li>转换为camelCase (或转换为Words)</li>
<li>转换为camelCase (或转换为lowercase words)</li>
<li>转换为PascalCase (或转换为camelCase)</li>
<li>选定文本大写</li>
<li>样式反转</li>
</ul>
</li>
<li>Un/Escape<ul>
<li>Un/Escape 选中的 java 文本</li>
<li>Un/Escape 选中的 javascript 文本</li>
<li>Un/Escape 选中的 HTML 文本</li>
<li>Un/Escape 选中的 XML 文本</li>
<li>Un/Escape 选中的 SQL 文本</li>
<li>Un/Escape 选中的 PHP 文本</li>
<li>将 diacritics(accents) 转换为 ASCII</li>
<li>将非ASCII 转换为转义的Unicode</li>
<li>将转义的Unicode转换为字符串</li>
</ul>
</li>
<li>Encode/Decode<ul>
<li>Encode 选中的文本为 MD5 Hex16</li>
<li>De/Encode 选中的文本为 URL</li>
<li>De/Encode 选中的文本为 Base64</li>
</ul>
</li>
<li>递增/递减<ul>
<li>递增/递减所有找到的数字</li>
<li>复制行并且递增/递减所有找到的数字</li>
<li>创建序列：保持第一个数字，递增替换所有其他数字</li>
<li>递增重复的数字</li>
</ul>
</li>
<li>按自然顺序排序<ul>
<li>按行倒序</li>
<li>按行随机排序</li>
<li>区分大小写A-z排序</li>
<li>区分大小写z-A排序</li>
<li>不区分大小写A-Z排序</li>
<li>不区分大小写Z-A排序</li>
<li>按行长度排序</li>
<li>通过子选择行排序：每行仅处理一个选择/插入符号</li>
</ul>
</li>
<li>对齐<ul>
<li>通过选定的分隔将选定的文本格式化为列/表格</li>
<li>将文本对齐为左/中/右</li>
</ul>
</li>
<li>过滤/删除/移除<ul>
<li>grep选定的文本，所有行不匹配输入文字将被删除。 （不能在列模式下工作）</li>
<li>移除选定的文本</li>
<li>移除选定文本中的所有空格</li>
<li>删除选定文本中的所有空格</li>
<li>删除重复的行</li>
<li>只保留重复的行</li>
<li>删除空行</li>
<li>删除所有换行符</li>
</ul>
</li>
<li>其他<ul>
<li>交换字符/选择/线/标记</li>
<li>切换文件路径分隔符：Windows &lt; – &gt; UNIX</li>
</ul>
</li>
</ul>
<p>安装好插件后，选中需要处理的内容后，按快捷键Alt+m，即可弹出工具功能列表。<br>很好很强大的一款字符串处理工具。</p>
<h3 id="ignore"><a href="#ignore" class="headerlink" title=".ignore"></a>.ignore</h3><p>目前很多开发都在使用git做版本控制工具，但是有些时候有些代码我们是不想提到到我们的代码仓库中的，比如ide自动生成的一些配置文件，或者是我们打包生成的一些jar文件等，这时候就需要编写一个.ignore文件，来排除那些不想被版本管理的文件。<br>这里推荐一个好用的插件.ignore，他可以帮我们方便的生成各种ignore文件。<br>安装插件后，选中项目，右键新建的时候，会多出一个.ignore文件的选项，可以通过这个选项创建ignore文件。<br><img src="http://image.winrains.cn/2019/08/9ab64-15479645941037.jpg" alt="img"><br>在弹出的对话框中，可以自动帮我们生成一份.ignore文件，这里我们让其帮忙自动排除所有和idea有关的文件。 <img src="http://image.winrains.cn/2019/08/68614-15479646877699.jpg" alt="img"></p>
<h3 id="Mybatis-plugin"><a href="#Mybatis-plugin" class="headerlink" title="Mybatis plugin"></a>Mybatis plugin</h3><p>目前ORM框架中，Mybatis非常受欢迎。但是，同时给很多开发带来困扰的就是Mybatis需要很多xml的配置文件，有的时候很难去进行修改。<br>这里推荐一款神器，可以让你像编辑java代码一样编辑mybatis的文件。<br>Intellij Idea Mybatis插件主要功能：</p>
<ul>
<li>提供Mapper接口与配置文件中对应SQL的导航</li>
<li>编辑XML文件时自动补全</li>
<li>根据Mapper接口, 使用快捷键生成xml文件及SQL标签</li>
<li>ResultMap中的property支持自动补全，支持级联(属性A.属性B.属性C)</li>
<li>快捷键生成@Param注解</li>
<li>XML中编辑SQL时, 括号自动补全</li>
<li>XML中编辑SQL时, 支持参数自动补全(基于@Param注解识别参数)</li>
<li>自动检查Mapper XML文件中ID冲突</li>
<li>自动检查Mapper XML文件中错误的属性值</li>
<li>支持Find Usage</li>
<li>支持重构从命名</li>
<li>支持别名</li>
<li>自动生成ResultMap属性</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/c18c4-15479651996039.jpg" alt="img"><br><img src="http://image.winrains.cn/2019/08/dd63b-15479652100916.jpg" alt="img"><br>（图源：<a href="https://www.oschina.net/p/intellij-mybatis-plugin）" target="_blank" rel="noopener">https://www.oschina.net/p/intellij-mybatis-plugin）</a><br>但是这款插件是收费的，但是不影响他确实是一个很实用，可以很大程度上提升开发效率的插件。读者可以考虑使用Free Mybatis plugin（这款插件我没用过，具体是否好用有待考证）。</p>
<h3 id="Key-promoter-X"><a href="#Key-promoter-X" class="headerlink" title="Key promoter X"></a>Key promoter X</h3><p>对于很多刚刚开始使用IDEA的开发者来说，最苦恼的就是不知道快捷键操作是什么。<br>使用IDEA，如果所有操作都使用鼠标，那么说明你还不是一个合格的程序员。<br>这里推荐一款可以进行快捷键提示的插件Key promoter X。<br>Key Promoter X 是一个提示插件，当你在IDEA里面使用鼠标的时候，如果这个鼠标操作是能够用快捷键替代的，那么Key Promoter X会弹出一个提示框，告知你这个鼠标操作可以用什么快捷键替代。<br>当我使用鼠标查看一个方法都被哪些类使用的时候，就会提示：<br><img src="http://image.winrains.cn/2019/08/78545-15479654859661.jpg" alt="img"><br>记住这个快捷键以后，就可以使用快捷键代替鼠标啦。</p>
<h3 id="AceJump"><a href="#AceJump" class="headerlink" title="AceJump"></a>AceJump</h3><p>前面介绍了一款可以通过使用快捷键来代替鼠标操作的插件，这里再介绍一款可以彻底摆脱鼠标的插件，即AceJump<br>AceJump允许您快速将光标导航到编辑器中可见的任何位置，只需点击“ctrl +;”，然后输入一个你想要跳转到的字符，之后键入匹配的字符就跳转到你想要挑战的地方了。<br><img src="http://image.winrains.cn/2019/08/2fc37-15479658623827.jpg" alt="img"><br>如以上代码，我想在这个类中，跳转到println那个位置，只需要按下快捷键：“ctrl +;”，然后输入println，即可定位到目标位置。<br>上图中，我输入了pri三个字母后，页面提示三个可选项，分别用字母G、H、D标注，这时候只需要按下对应字母，即可快速定位到指定位置，是不是很方便。</p>
<h3 id="activate-power-mode"><a href="#activate-power-mode" class="headerlink" title="activate-power-mode"></a>activate-power-mode</h3><p>最后，介绍一款程序员很好的在妹子面前装X的插件——activate-power-mode 。<br>安装了这款插件之后，你写代码的时候，就会附加一些狂拽炫酷屌炸天的效果：<br><img src="http://image.winrains.cn/2019/08/a45d6-15479661234183.gif" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文一共介绍了11款可以提升程序员开发效率、提升代码质量、提升编码心情的软件。欢迎大家安装尝试一下。</p>
<blockquote>
<p>作者：Hollis</p>
<p>来源：<a href="https://www.hollischuang.com/archives/3220" target="_blank" rel="noopener">https://www.hollischuang.com/archives/3220</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>IntelliJ IDEA</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构</title>
    <url>/2019/12/26/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>redis 是 key-value 类型的数据库，key 一般是一个字符串，但他的value可以储存5种数据类型</p>
<h2 id="key-的定义注意事项"><a href="#key-的定义注意事项" class="headerlink" title="key 的定义注意事项"></a>key 的定义注意事项</h2><p>它的 key 在定义时，需要注意以下事项</p>
<ul>
<li>不要超过 1024 个字节，过长除了会消耗内存，还会降低查找效率</li>
<li>有统一的命名规范</li>
</ul>
<a id="more"></a>

<h3 id="key-常用的命令"><a href="#key-常用的命令" class="headerlink" title="key 常用的命令"></a>key 常用的命令</h3><ul>
<li><strong>查询所有的键</strong>：<code>keys *</code></li>
<li><strong>查询所有以某个字符串开头的的键</strong>：<code>keys 字符串?</code></li>
<li><strong>删除键</strong>：<code>del 键1 键2</code></li>
<li><strong>查看键是否存在</strong>：<code>exists 键</code> 存在返回1 不存在返回0</li>
<li><strong>对键重命名</strong>： <code>rename 键 新键名</code></li>
<li><strong>设置过期时间</strong>：<code>expire 键 秒</code></li>
<li><strong>查看键的剩余过期时间</strong>：<code>ttl 键</code> 返回剩余的秒 如果键没有设置超时时间返回-1</li>
<li><strong>查看键对应的值的类型</strong>：<code>type 键</code> <strong>sorted-set</strong> 类型的值会返回 zset</li>
</ul>
<h2 id="五种数据类型"><a href="#五种数据类型" class="headerlink" title="五种数据类型"></a>五种数据类型</h2><p>redis 的值有五种数据类型</p>
<ul>
<li><strong>String</strong>：存储字符串、整数、浮点数</li>
<li><strong>list</strong>: 存储字符串、整数、浮点数列表</li>
<li><strong>set</strong>：存储字符串、整数、浮点数集合</li>
<li><strong>sort set</strong>：存储有序字符串、整数、浮点数集合</li>
<li><strong>hash</strong>：存储键值对</li>
</ul>
<p>比较常用的是 <strong>String</strong>、<strong>hash</strong></p>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>string 类型的数据在redis中是以二进制的方式存储的，这就避免了编码格式的问题，存入的是什么编码格式的字符串，读取的就是什么编码格式的字符串</p>
<ul>
<li>以二进制形式存储，存入和获取的数据一致</li>
<li>value 最多可以容纳的数据长度是 512M</li>
</ul>
<h3 id="string-常用命令"><a href="#string-常用命令" class="headerlink" title="string 常用命令"></a>string 常用命令</h3><ul>
<li><strong>赋值</strong>：<code>set 键 值</code></li>
<li><strong>不存在才赋值</strong>:<code>setnx 键 值</code> 存在不赋值，返回0， 不存在才赋值，返回1</li>
<li><strong>取值</strong>：<code>get 键</code> 获取键的值</li>
<li><strong>修改</strong>：<code>getset 键 新值</code> 将键的值改为新值</li>
<li><strong>删除</strong>：<code>del 键</code> 删除键的值</li>
<li><strong>数值加1</strong>：<code>inc 键</code> 如果 键 不存在，则创建 键 并设置值为0再加1，如果存在就直接加1，如果存在但值不能转成整型，就会报错</li>
<li><strong>数值减1</strong>：<code>decr 键</code>，decr 正好 与 inc 命令相反，它是减1</li>
<li><strong>数值加</strong>：：<code>incby 键 数值</code>，与 <code>inc 键</code> 相同，不同的地方在于他指定了要加的数值</li>
<li><strong>数值减</strong>：<code>decrby 键 数值</code>，与 <code>inc 键</code> 相同，不同的地方在于他指定了要减的数值</li>
<li><strong>拼接</strong>：<code>append 键 值</code> 在指定键后面拼接值，如果键不存在，创建 键 并初始化化为 值</li>
<li><strong>判断键是否存在</strong>：<code>exists 键</code>， 存在返回1，不存在返回0</li>
</ul>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>hash 类型可以看做是 string key 和 string value 的 map 容器<br>一个hesh可以存储 4294967295 个键值对</p>
<h3 id="hash-常用命令"><a href="#hash-常用命令" class="headerlink" title="hash 常用命令"></a>hash 常用命令</h3><ul>
<li><strong>赋值</strong>：<code>hset 键 hash的键 hash的值</code> 存入一对 hash ，同一个 键 可以存入多对hash</li>
<li><strong>批量赋值</strong>：<code>hmset 键 hash的键1 hash的值1 hash的键2 hash的值2</code> 在一个键中同时存入多对hash</li>
<li><strong>取值</strong>：<code>hget 键 hash的键</code> 取出 hash键对应的值</li>
<li><strong>批量取值</strong>：<code>hmget 键 hash的键1 hash的键2</code> 取出 hash键1、hash键2对应的值</li>
<li><strong>获取全部的值</strong>：<code>hgetall 键</code> 获取 键 中所有 hash键对应的值</li>
<li><strong>删除</strong>：<code>hdel 键 hash的键1 hash的键2</code> 删除hash的键1、hash的键2对应的键值对</li>
<li><strong>数值加</strong>：：<code>hincby 键 hash的键 数值</code>，给 hash的键对应的值 加上指定的数值</li>
<li><strong>判断某个 hash键 是否存在</strong>：<code>hexists 键 hash的键</code>， 存在返回1，不存在返回0</li>
<li><strong>获取 hash对 的数量</strong>：<code>hlen 键</code> 获取该键中 hash 对的数量</li>
<li><strong>获取所有的 hash键</strong>： <code>hkeys</code> 获取该键中 hash键的列表</li>
<li><strong>获取所有的 hash值</strong>： <code>hvals</code> 获取该键中 hash值的列表</li>
</ul>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）<br>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。<br>如果列表中的所以元素被删除，那么列表本身也会被删除</p>
<h3 id="list-常用命令"><a href="#list-常用命令" class="headerlink" title="list 常用命令"></a>list 常用命令</h3><ul>
<li><strong>左端添加</strong>：<code>lpush 键 值1 值2 值3</code> 在list左边添加值 如果键不存在则创建 插入后的顺序为值3 值2 值1</li>
<li><strong>右端添加</strong>：<code>rpush 键 值1 值2 值3</code> 在list右边添加值 如果键不存在则创建 插入后的顺序为值1 值2 值3</li>
<li><strong>查看</strong>：<code>lrange 键 开始下标 结束下标</code> 包括开始不包括结束 下标可以从0开始 也可以从-1开始，-1就表示倒数第一个</li>
<li><strong>左端弹出</strong>：<code>lpop 键</code> 删除掉list左边第一个元素</li>
<li><strong>右端弹出</strong>：<code>rpop 键</code> 删除掉list右边第一个元素</li>
<li><strong>获取列表中元素的个数</strong>： <code>llen 键</code> 如果键不存在，返回0</li>
<li><strong>list存在时，左端添加</strong>：<code>lpushx 键 值</code> 键存在则添加，键不存在不添加</li>
<li><strong>list存在时，右端添加</strong>：<code>rpushx 键 值</code> 键存在则添加，键不存在不添加</li>
<li><strong>批量删除某个元素</strong>：<code>lrem 键 个数 元素</code> 个数为正数则从左往右删除 个数为负数则从右往左删除 个数为0则删除所有 举例 lrem nameList 2 tom 表示从左往右删除 nameList 中2个 tom 元素。lrem nameList -3 joy 表示从右往左删除 nameList 中3个 joy 元素。lrem nameList 0 ros 删除nameList中所以的 ros</li>
<li><strong>修改某一下标的值</strong>：<code>lset 键 下标的值</code> 下标可以从0开始 也可以从-1开始，-1就表示倒数第一个 如果下标存在则覆盖原有值 如果下标不存在则报错</li>
<li><strong>在某个元素之前插入元素</strong> ：<code>linsert 键 before 元素 要插入的元素</code> 从左往右匹配第一个找到的元素 插入之后，插入点后面的元素下标+1</li>
<li><strong>在某个元素之后插入元素</strong> ：<code>linsert 键 after 元素 要插入的元素</code> 从左往右匹配第一个找到的元素 插入之后，插入点后面的元素下标+1</li>
<li><strong>将链表a的尾部元素弹出插入到链表b的头部</strong>：<code>rpoplpush 键a 键b</code> 完成之后 链表a会少一个元素 链表b会多一个元素</li>
</ul>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set 可以看成是没有排序的字符集合，和list不同的是 set 中不允许出现重复元素<br>一个set 最多可以包含 232 - 1 个元素</p>
<h3 id="set-常用命令"><a href="#set-常用命令" class="headerlink" title="set 常用命令"></a>set 常用命令</h3><ul>
<li><strong>添加元素</strong>：<code>sadd 键 元素1 元素2 元素3</code> 重复的元素只会保留一份</li>
<li><strong>删除元素</strong>：<code>srem 键 元素1 元素2</code></li>
<li><strong>查看元素</strong>：<code>smembers 键</code> 它会列出所有的元素</li>
<li><strong>查看set中是否包含某元素</strong>：<code>sismember 键 元素</code> 返回1表示存在 0表示不存在</li>
<li><strong>获取set中元素的数量</strong>： <code>scard 键</code></li>
<li><strong>随机获取一个元素</strong>： <code>srandmember 键</code></li>
</ul>
<h4 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h4><p>假设 set1 中有 a、b、c， set2 中有 1、2、c</p>
<ul>
<li><strong>差集(补集)运算</strong>： <code>sdiff 键a 键b</code> 谁在前面，求谁的差集(补集)</li>
</ul>
<p>set1的差集(补集)为红色部分中的 1、2，命令写作 <code>sdiff set1 set2</code></p>
<p><img src="http://image.winrains.cn/2019/08/20190829134305-4eff6.png" alt="img"></p>
<p>set2的差集(补集)为红色部分中的 a、b，命令写作 <code>sdiff set2 set1</code></p>
<p><img src="http://image.winrains.cn/2019/08/20190829134305-cd37f.png" alt="img"></p>
<ul>
<li><p><strong>存储差集(补集)到新set</strong>：<code>sdiffstore 新集合 集合1 集合2</code> 将集合1的差集(补集) 存入新集合</p>
</li>
<li><p>交集运算</p>
<p>：</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">sinter</span> <span class="comment">键a</span> <span class="comment">键b</span></span></pre></td></tr></table></figure>

<p> 结果是两个set 中都有的元素</p>
<p><img src="http://image.winrains.cn/2019/08/20190829134306-4b266.png" alt="img"></p>
</li>
<li><p><strong>存储交集到新set</strong>：<code>sinterstore 新集合 集合1 集合2</code> 将集合1 和集合2的交集存入新集合</p>
</li>
<li><p>并集运算</p>
<p>：</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">sunion</span> <span class="comment">键a</span> <span class="comment">键b</span></span></pre></td></tr></table></figure>

<p> 会将两个 set 中的元素合并在一起，重复的元素只会保留一份</p>
<p><img src="http://image.winrains.cn/2019/08/20190829134306-3b37d.png" alt="img"></p>
</li>
<li><p><strong>存储并集到新set</strong>：<code>sunionstore 新集合 集合1 集合2</code> 将集合1 和集合2的并集存入新集合</p>
</li>
</ul>
<h2 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted-set"></a>sorted-set</h2><p>有序的set集合，除了顺序其他都和set一致，比如不允许出现重复元素<br>sorted-set 中的每一个成员都有一个对应的分数，sorted-set 通过分数确定成员的顺序<br>如果两个元素的分数一样，那么按照元素的字典顺序排序</p>
<h3 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h3><ul>
<li><strong>添加元素</strong>：<code>zadd 键 分数1 值1 分数2 值2</code> 例如 zadd sortName 90 张三 93 王五</li>
<li><strong>更新分数</strong>：<code>zadd 键 新分数 值1</code> 例如 zadd sortName 100 张三</li>
<li><strong>获取元素的分数</strong>：<code>zscore 键 值</code></li>
<li><strong>获取元素数量</strong>：<code>zcard 键</code></li>
<li><strong>删除某个元素</strong>：<code>zrem 键 值1 值2</code></li>
<li><strong>查看元素</strong>：<code>zrange 键 序号1 序号2</code> 序号可以从0开始 也可以从-1开始，-1就表示倒数第一个 比如 zrange sortName 0 -1 表示查看 sortName 的第一个元素到最后一个元素</li>
<li><strong>查看元素和对应的分数</strong>：<code>zrange 键 序号1 序号2 withscorse</code> 按分数从小到大排序</li>
<li><strong>查看元素和对应的分数</strong>：<code>zrevrange 键 序号1 序号2 withscorse</code> 按分数从大到小排序</li>
<li><strong>按照排名的范围删除元素</strong>：<code>zremrangebyrank 键 序号1 序号2</code> 包含开始不包含结束</li>
<li><strong>按照分数的范围删除元素</strong>：<code>zremrangebyscore 键 分数1 分数2</code> 包含开始分数不包含结束分数</li>
<li><strong>获取某段分数内的元素</strong>：<code>zrangebyscore 键 分数1 分数2 withscorse limit 数字1 数字2</code> 包含开始分数不包含结束分数， 结果按分数从小到大排序， withscorse是可选参数，加上之后会显示分数 limit也是可选参数，例如 limit 0 2 表示只取结果集的前两位</li>
<li><strong>给元素加分数</strong>：<code>zincrby 键 要加的分数 值</code></li>
<li><strong>获取某段分数中元素的个数</strong>：<code>zcount 键 分数1 分数2</code></li>
</ul>
<blockquote>
<p>作者：我妻礼弥</p>
<p>来源：<a href="https://juejin.im/post/5d64806151882528307e7e79" target="_blank" rel="noopener">https://juejin.im/post/5d64806151882528307e7e79</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>最全的select加锁分析</title>
    <url>/2019/12/26/%E6%9C%80%E5%85%A8%E7%9A%84select%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>大家在面试中有没遇到面试官问你下面六句Sql的区别呢</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ?</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> &lt; ?</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> &lt; ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ? <span class="keyword">for</span> <span class="keyword">update</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> &lt; ? <span class="keyword">for</span> <span class="keyword">update</span></span></pre></td></tr></table></figure>

<a id="more"></a>

<p>如果你能清楚的说出，这六句sql在不同的事务隔离级别下，是否加锁，加的是共享锁还是排他锁，是否存在间隙锁，那这篇文章就没有看的意义了。 之所以写这篇文章是因为目前为止网上这方面的文章太片面，都只说了一半，且大多没指明隔离级别，以及<code>where</code>后跟的是否为索引条件列。在此，我就不一一列举那些有误的文章了，大家可以自行百度一下，大多都是讲不清楚。 OK，要回答这个问题，先问自己三个问题</p>
<ul>
<li>当前事务隔离级别是什么</li>
<li>id列是否存在索引</li>
<li>如果存在索引是聚簇索引还是非聚簇索引呢？</li>
</ul>
<p>OK，开始回答</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ul>
<li>innodb一定存在聚簇索引，默认以主键作为聚簇索引</li>
<li>有几个索引，就有几棵B+树(不考虑hash索引的情形)</li>
<li>聚簇索引的叶子节点为磁盘上的真实数据。非聚簇索引的叶子节点还是索引，指向聚簇索引B+树。</li>
</ul>
<p>下面啰嗦点基础知识</p>
<h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><p><strong>共享锁</strong>(S锁):假设事务T1对数据A加上共享锁，那么事务T2<strong>可以</strong>读数据A，<strong>不能</strong>修改数据A。<br><strong>排他锁</strong>(X锁):假设事务T1对数据A加上共享锁，那么事务T2<strong>不能</strong>读数据A，<strong>不能</strong>修改数据A。 我们通过<code>update</code>、<code>delete</code>等语句加上的锁都是行级别的锁。只有<code>LOCK TABLE … READ</code>和<code>LOCK TABLE … WRITE</code>才能申请表级别的锁。<br><strong>意向共享锁</strong>(IS锁):一个事务在获取（任何一行/或者全表）S锁之前，一定会先在所在的表上加IS锁。<br><strong>意向排他锁</strong>(IX锁):一个事务在获取（任何一行/或者全表）X锁之前，一定会先在所在的表上加IX锁。</p>
<blockquote>
<p><strong>意向锁存在的目的?</strong></p>
</blockquote>
<p>OK，这里说一下意向锁存在的目的。假设事务T1，用X锁来锁住了表上的几条记录，那么此时表上存在IX锁，即意向排他锁。那么此时事务T2要进行<code>LOCK TABLE … WRITE</code>的表级别锁的请求，可以直接根据意向锁是否存在而判断是否有锁冲突。</p>
<h3 id="加锁算法"><a href="#加锁算法" class="headerlink" title="加锁算法"></a>加锁算法</h3><p>我的说法是来自官方文档: <code>https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html</code> 加上自己矫揉造作的见解得出。<br>ok，记得如下三种，本文就够用了<br><code>Record Locks</code>：简单翻译为行锁吧。注意了，该锁是对索引记录进行加锁！锁是在加索引上而不是行上的。注意了，innodb一定存在聚簇索引，因此行锁最终都会落到聚簇索引上！<br><code>Gap Locks</code>：简单翻译为间隙锁，是对索引的间隙加锁，其目的只有一个，防止其他事物插入数据。在<code>Read Committed</code>隔离级别下，不会使用间隙锁。这里我对官网补充一下，隔离级别比<code>Read Committed</code>低的情况下，也不会使用间隙锁，如隔离级别为<code>Read Uncommited</code>时，也不存在间隙锁。当隔离级别为<code>Repeatable Read</code>和<code>Serializable</code>时，就会存在间隙锁。<br><code>Next-Key Locks</code>：这个理解为<code>Record Lock</code>+索引前面的<code>Gap Lock</code>。记住了，锁住的是索引前面的间隙！比如一个索引包含值，10，11，13和20。那么，间隙锁的范围如下</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(negative infinity, <span class="number">10</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">(<span class="number">10</span>, <span class="number">11</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">(<span class="number">11</span>, <span class="number">13</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">(<span class="number">13</span>, <span class="number">20</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">(<span class="number">20</span>, positive infinity)</span></pre></td></tr></table></figure>

<h3 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h3><p>最后一点基础知识了，大家坚持看完，这些是后面分析的基础！ 在mysql中select分为快照读和当前读，执行下面的语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ?;</span></pre></td></tr></table></figure>

<p>执行的是快照读，读的是数据库记录的快照版本，是不加锁的。（这种说法在隔离级别为<code>Serializable</code>中不成立，后面我会补充。） 那么，执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span></pre></td></tr></table></figure>

<p>会对读取记录加S锁 (共享锁)，执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ? <span class="keyword">for</span> <span class="keyword">update</span></span></pre></td></tr></table></figure>

<p>会对读取记录加X锁 (排他锁)，那么</p>
<blockquote>
<p><strong>加的是表锁还是行锁呢？</strong></p>
</blockquote>
<p>针对这点，我们先回忆一下事务的四个隔离级别，他们由弱到强如下所示:</p>
<ul>
<li><code>Read Uncommited(RU)</code>：读未提交，一个事务可以读到另一个事务未提交的数据！</li>
<li><code>Read Committed (RC)</code>：读已提交，一个事务可以读到另一个事务已提交的数据!</li>
<li><code>Repeatable Read (RR)</code>:可重复读，加入间隙锁，一定程度上避免了幻读的产生！注意了，只是一定程度上，并没有完全避免!我会在下一篇文章说明!另外就是记住从该级别才开始加入间隙锁(这句话记下来，后面有用到)!</li>
<li><code>Serializable</code>：串行化，该级别下读写串行化，且所有的<code>select</code>语句后都自动加上<code>lock in share mode</code>，即使用了共享锁。因此在该隔离级别下，使用的是当前读，而不是快照读。</li>
</ul>
<p>那么关于是表锁还是行锁，大家可以看到网上最流传的一个说法是这样的，</p>
<blockquote>
<p><strong>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。 InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong></p>
</blockquote>
<p>这句话大家可以搜一下，都是你抄我的，我抄你的。那么，这句话本身有两处错误！ <strong>错误一</strong>:并不是用表锁来实现锁表的操作，而是利用了<code>Next-Key Locks</code>，也可以理解为是用了行锁+间隙锁来实现锁表的操作! 为了便于说明，我来个例子，假设有表数据如下，pId为主键索引</p>
<table>
<thead>
<tr>
<th>pId(int)</th>
<th>name(varchar)</th>
<th>num(int)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>aaa</td>
<td>100</td>
</tr>
<tr>
<td>2</td>
<td>bbb</td>
<td>200</td>
</tr>
<tr>
<td>7</td>
<td>ccc</td>
<td>200</td>
</tr>
</tbody></table>
<p>执行语句(name列无索引)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">`aaa`</span> <span class="keyword">for</span> <span class="keyword">update</span></span></pre></td></tr></table></figure>

<p>那么此时在pId=1,2,7这三条记录上存在行锁(把行锁住了)。另外，在(-∞,1)(1,2)(2,7)(7,+∞)上存在间隙锁(把间隙锁住了)。因此，给人一种整个表锁住的错觉！<br><code>ps:</code>对该结论有疑问的，可自行执行<code>show engine innodb status;</code>语句进行分析。<br><strong>错误二</strong>:所有文章都不提隔离级别！<br>注意我上面说的，之所以能够锁表，是通过行锁+间隙锁来实现的。那么，<code>RU</code>和<code>RC</code>都不存在间隙锁，这种说法在<code>RU</code>和<code>RC</code>中还能成立么？ 因此，该说法只在<code>RR</code>和<code>Serializable</code>中是成立的。如果隔离级别为<code>RU</code>和<code>RC</code>，无论条件列上是否有索引，都不会锁表，只锁行！</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>下面来对开始的问题作出解答，假设有表如下，pId为主键索引</p>
<table>
<thead>
<tr>
<th>pId(int)</th>
<th>name(varchar)</th>
<th>num(int)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>aaa</td>
<td>100</td>
</tr>
<tr>
<td>2</td>
<td>bbb</td>
<td>200</td>
</tr>
<tr>
<td>3</td>
<td>bbb</td>
<td>300</td>
</tr>
<tr>
<td>7</td>
<td>ccc</td>
<td>200</td>
</tr>
</tbody></table>
<h4 id="RC-RU-条件列非索引"><a href="#RC-RU-条件列非索引" class="headerlink" title="RC/RU+条件列非索引"></a>RC/RU+条件列非索引</h4><p>(1)<code>select * from table where num = 200</code><br>不加任何锁，是快照读。<br>(2)<code>select * from table where num &gt; 200</code><br>不加任何锁，是快照读。<br>(3)<code>select * from table where num = 200 lock in share mode</code><br>当num = 200，有两条记录。这两条记录对应的pId=2，7，因此在pId=2，7的聚簇索引上加行级S锁，采用当前读。<br>(4)<code>select * from table where num &gt; 200 lock in share mode</code><br>当num &gt; 200，有一条记录。这条记录对应的pId=3，因此在pId=3的聚簇索引上加上行级S锁，采用当前读。<br>(5)<code>select * from table where num = 200 for update</code><br>当num = 200，有两条记录。这两条记录对应的pId=2，7，因此在pId=2，7的聚簇索引上加行级X锁，采用当前读。<br>(6)<code>select * from table where num &gt; 200 for update</code><br>当num &gt; 200，有一条记录。这条记录对应的pId=3，因此在pId=3的聚簇索引上加上行级X锁，采用当前读。</p>
<h4 id="RC-RU-条件列是聚簇索引"><a href="#RC-RU-条件列是聚簇索引" class="headerlink" title="RC/RU+条件列是聚簇索引"></a>RC/RU+条件列是聚簇索引</h4><p>恩，大家应该知道pId是主键列，因此pId用的就是聚簇索引。此情况其实和<strong>RC/RU+条件列非索引</strong>情况是类似的。<br>(1)<code>select * from table where pId = 2</code><br>不加任何锁，是快照读。<br>(2)<code>select * from table where pId &gt; 2</code><br>不加任何锁，是快照读。<br>(3)<code>select * from table where pId = 2 lock in share mode</code><br>在pId=2的聚簇索引上，加S锁，为当前读。<br>(4)<code>select * from table where pId &gt; 2 lock in share mode</code><br>在pId=3，7的聚簇索引上，加S锁，为当前读。<br>(5)<code>select * from table where pId = 2 for update</code><br>在pId=2的聚簇索引上，加X锁，为当前读。<br>(6)<code>select * from table where pId &gt; 2 for update</code><br>在pId=3，7的聚簇索引上，加X锁，为当前读。<br>这里，大家可能有疑问</p>
<blockquote>
<p><strong>为什么条件列加不加索引，加锁情况是一样的？</strong></p>
</blockquote>
<p>ok,其实是不一样的。在RC/RU隔离级别中，MySQL Server做了优化。在条件列没有索引的情况下，尽管通过聚簇索引来扫描全表，进行全表加锁。但是，MySQL Server层会进行过滤并把不符合条件的锁当即释放掉，因此你看起来最终结果是一样的。但是<strong>RC/RU+条件列非索引</strong>比本例多了一个释放不符合条件的锁的过程！</p>
<h4 id="RC-RU-条件列是非聚簇索引"><a href="#RC-RU-条件列是非聚簇索引" class="headerlink" title="RC/RU+条件列是非聚簇索引"></a>RC/RU+条件列是非聚簇索引</h4><p>我们在num列上建上非唯一索引。此时有一棵聚簇索引(主键索引，pId)形成的B+索引树，其叶子节点为硬盘上的真实数据。以及另一棵非聚簇索引(非唯一索引，num)形成的B+索引树，其叶子节点依然为索引节点，保存了num列的字段值，和对应的聚簇索引。<br>接下来分析开始<br>(1)<code>select * from table where num = 200</code><br>不加任何锁，是快照读。<br>(2)<code>select * from table where num &gt; 200</code><br>不加任何锁，是快照读。<br>(3)<code>select * from table where num = 200 lock in share mode</code><br>当num = 200，由于num列上有索引，因此先在 num = 200的两条索引记录上加行级S锁。接着，去聚簇索引树上查询，这两条记录对应的pId=2，7，因此在pId=2，7的聚簇索引上加行级S锁，采用当前读。<br>(4)<code>select * from table where num &gt; 200 lock in share mode</code><br>当num &gt; 200，由于num列上有索引，因此先在符合条件的 num = 300的一条索引记录上加行级S锁。接着，去聚簇索引树上查询，这条记录对应的pId=3，因此在pId=3的聚簇索引上加行级S锁，采用当前读。<br>(5)<code>select * from table where num = 200 for update</code><br>当num = 200，由于num列上有索引，因此先在 num = 200的两条索引记录上加行级X锁。接着，去聚簇索引树上查询，这两条记录对应的pId=2，7，因此在pId=2，7的聚簇索引上加行级X锁，采用当前读。<br>(6)<code>select * from table where num &gt; 200 for update</code><br>当num &gt; 200，由于num列上有索引，因此先在符合条件的 num = 300的一条索引记录上加行级X锁。接着，去聚簇索引树上查询，这条记录对应的pId=3，因此在pId=3的聚簇索引上加行级X锁，采用当前读。</p>
<h4 id="RR-Serializable-条件列非索引"><a href="#RR-Serializable-条件列非索引" class="headerlink" title="RR/Serializable+条件列非索引"></a>RR/Serializable+条件列非索引</h4><p>RR级别需要多考虑的就是gap lock，他的加锁特征在于，无论你怎么查都是锁全表。如下所示 接下来分析开始<br>(1)<code>select * from table where num = 200</code><br>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，在pId = 1,2,3,7（全表所有记录）的聚簇索引上加S锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock<br>(2)<code>select * from table where num &gt; 200</code><br>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，在pId = 1,2,3,7（全表所有记录）的聚簇索引上加S锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock<br>(3)<code>select * from table where num = 200 lock in share mode</code><br>在pId = 1,2,3,7（全表所有记录）的聚簇索引上加S锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock<br>(4)<code>select * from table where num &gt; 200 lock in share mode</code><br>在pId = 1,2,3,7（全表所有记录）的聚簇索引上加S锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock<br>(5)<code>select * from table where num = 200 for update</code><br>在pId = 1,2,3,7（全表所有记录）的聚簇索引上加X锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock<br>(6)<code>select * from table where num &gt; 200 for update</code><br>在pId = 1,2,3,7（全表所有记录）的聚簇索引上加X锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock</p>
<h4 id="RR-Serializable-条件列是聚簇索引"><a href="#RR-Serializable-条件列是聚簇索引" class="headerlink" title="RR/Serializable+条件列是聚簇索引"></a>RR/Serializable+条件列是聚簇索引</h4><p>恩，大家应该知道pId是主键列，因此pId用的就是聚簇索引。该情况的加锁特征在于，如果<code>where</code>后的条件为精确查询(<code>=</code>的情况)，那么只存在record lock。如果<code>where</code>后的条件为范围查询(<code>&gt;</code>或<code>&lt;</code>的情况)，那么存在的是record lock+gap lock。<br>(1)<code>select * from table where pId = 2</code><br>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，是当前读，在pId=2的聚簇索引上加S锁，不存在gap lock。<br>(2)<code>select * from table where pId &gt; 2</code><br>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，是当前读，在pId=3,7的聚簇索引上加S锁。在(2,3)(3,7)(7,+∞)加上gap lock<br>(3)<code>select * from table where pId = 2 lock in share mode</code><br>是当前读，在pId=2的聚簇索引上加S锁，不存在gap lock。<br>(4)<code>select * from table where pId &gt; 2 lock in share mode</code><br>是当前读，在pId=3,7的聚簇索引上加S锁。在(2,3)(3,7)(7,+∞)加上gap lock<br>(5)<code>select * from table where pId = 2 for update</code><br>是当前读，在pId=2的聚簇索引上加X锁。<br>(6)<code>select * from table where pId &gt; 2 for update</code><br>在pId=3,7的聚簇索引上加X锁。在(2,3)(3,7)(7,+∞)加上gap lock<br>(7)<code>select * from table where pId = 6 [lock in share mode|for update]</code><br>注意了，pId=6是不存在的列，这种情况会在(3,7)上加gap lock。<br>(8)<code>select * from table where pId &gt; 18 [lock in share mode|for update]</code><br>注意了，pId&gt;18，查询结果是空的。在这种情况下，是在(7,+∞)上加gap lock。</p>
<h4 id="RR-Serializable-条件列是非聚簇索引"><a href="#RR-Serializable-条件列是非聚簇索引" class="headerlink" title="RR/Serializable+条件列是非聚簇索引"></a>RR/Serializable+条件列是非聚簇索引</h4><p>这里非聚簇索引，需要区分是否为唯一索引。因为如果是非唯一索引，间隙锁的加锁方式是有区别的。<br>先说一下，唯一索引的情况。如果是唯一索引，情况和<strong>RR/Serializable+条件列是聚簇索引</strong>类似，唯一有区别的是:这个时候有两棵索引树，加锁是加在对应的非聚簇索引树和聚簇索引树上！大家可以自行推敲!<br>下面说一下，非聚簇索引是非唯一索引的情况，他和唯一索引的区别就是通过索引进行精确查询以后，不仅存在record lock，还存在gap lock。而通过唯一索引进行精确查询后，只存在record lock，不存在gap lock。老规矩在num列建立非唯一索引<br>(1)<code>select * from table where num = 200</code><br>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，是当前读，在pId=2，7的聚簇索引上加S锁，在num=200的非聚集索引上加S锁，在(100,200)(200,300)加上gap lock。<br>(2)<code>select * from table where num &gt; 200</code><br>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，是当前读，在pId=3的聚簇索引上加S锁，在num=300的非聚集索引上加S锁。在(200,300)(300,+∞)加上gap lock<br>(3)<code>select * from table where num = 200 lock in share mode</code><br>是当前读，在pId=2，7的聚簇索引上加S锁，在num=200的非聚集索引上加S锁，在(100,200)(200,300)加上gap lock。<br>(4)<code>select * from table where num &gt; 200 lock in share mode</code><br>是当前读，在pId=3的聚簇索引上加S锁，在num=300的非聚集索引上加S锁。在(200,300)(300,+∞)加上gap lock。<br>(5)<code>select * from table where num = 200 for update</code><br>是当前读，在pId=2，7的聚簇索引上加S锁，在num=200的非聚集索引上加X锁，在(100,200)(200,300)加上gap lock。<br>(6)<code>select * from table where num &gt; 200 for update</code><br>是当前读，在pId=3的聚簇索引上加S锁，在num=300的非聚集索引上加X锁。在(200,300)(300,+∞)加上gap lock<br>(7)<code>select * from table where num = 250 [lock in share mode|for update]</code><br>注意了，num=250是不存在的列，这种情况会在(200,300)上加gap lock。<br>(8)<code>select * from table where num &gt; 400 [lock in share mode|for update]</code><br>注意了，pId&gt;400，查询结果是空的。在这种情况下，是在(400,+∞)上加gap lock。</p>
<blockquote>
<p>作者：RDJ</p>
<p>来源：<a href="https://juejin.im/post/5d5671a2e51d45620821cea7" target="_blank" rel="noopener">https://juejin.im/post/5d5671a2e51d45620821cea7</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型中的通配符</title>
    <url>/2019/12/26/Java%E6%B3%9B%E5%9E%8B%E4%B8%AD%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许开发者在编译时检测到非法的类型。<br>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<a id="more"></a>

<h2 id="泛型带来的好处"><a href="#泛型带来的好处" class="headerlink" title="泛型带来的好处"></a>泛型带来的好处</h2><p>在没有泛型的情况的下，通过对类型 Object 的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是本身就是一个安全隐患。<br>那么泛型的好处就是在编译的时候能够检查类型安全，并且所有的强制转换都是自动和隐式的。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperGeneric</span>&lt;T&gt; &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> T t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">this</span>.t = t; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// do nothing</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    * 不指定类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noSpecifyType</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        GlmapperGeneric glmapperGeneric = <span class="keyword">new</span> GlmapperGeneric();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        glmapperGeneric.<span class="built_in">set</span>(<span class="string">"test"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 需要强制类型转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">String</span> test = (<span class="keyword">String</span>) glmapperGeneric.<span class="built_in">get</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(test);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 指定类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specifyType</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        GlmapperGeneric&lt;<span class="keyword">String</span>&gt; glmapperGeneric = <span class="keyword">new</span> GlmapperGeneric();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        glmapperGeneric.<span class="built_in">set</span>(<span class="string">"test"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 不需要强制类型转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">String</span> test = glmapperGeneric.<span class="built_in">get</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.<span class="built_in">println</span>(test);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面这段代码中的 specifyType 方法中 省去了强制转换，可以在编译时候检查类型安全，可以用在类，方法，接口上。</p>
<h2 id="泛型中通配符"><a href="#泛型中通配符" class="headerlink" title="泛型中通配符"></a>泛型中通配符</h2><p>我们在定义泛型类，泛型方法，泛型接口的时候经常会碰见很多不同的通配符，比如 T，E，K，V 等等，这些通配符又都是什么意思呢？</p>
<h3 id="常用的-T，E，K，V，？"><a href="#常用的-T，E，K，V，？" class="headerlink" title="常用的 T，E，K，V，？"></a>常用的 T，E，K，V，？</h3><p>本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。<strong>通常情况下，T，E，K，V，？ 是这样约定的：</strong></p>
<ul>
<li>？ 表示不确定的 java 类型</li>
<li>T (type) 表示具体的一个java类型</li>
<li>K V (key value) 分别代表java键值中的Key Value</li>
<li>E (element) 代表Element</li>
</ul>
<h3 id="？-无界通配符"><a href="#？-无界通配符" class="headerlink" title="？ 无界通配符"></a>？ <strong>无界通配符</strong></h3><p>先从一个小例子看起，原文在 <a href="https://link.juejin.im?target=https%3A%2F%2Fcodeday.me%2Fbug%2F20180113%2F116421.html">这里</a> 。<br>我有一个父类 Animal 和几个子类，如狗、猫等，现在我需要一个动物的列表，我的第一个想法是像这样的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">List<span class="tag">&lt;<span class="name">Animal</span>&gt;</span> listAnimals</span></pre></td></tr></table></figure>

<p>但是老板的想法确实这样的：</p>
<figure class="highlight capnproto"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;? <span class="keyword">extends</span> Animal&gt; listAnimals</span></pre></td></tr></table></figure>

<p>为什么要使用通配符而不是简单的泛型呢？通配符其实在声明局部变量时是没有什么意义的，但是当你为一个方法声明一个参数时，它是非常重要的。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countLegs</span> <span class="params">(List&lt;? extends Animal &gt; animals )</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> ( Animal animal : animals )</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        retVal += animal.countLegs();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> retVal;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countLegs1</span> <span class="params">(List&lt; Animal &gt; animals )</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> ( Animal animal : animals )</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        retVal += animal.countLegs();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> retVal;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;Dog&gt; dogs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 不会报错</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    countLegs( dogs );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 报错</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    countLegs1(dogs);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>当调用 countLegs1 时，就会飘红，提示的错误信息如下：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829135619-25fc4.png" alt="img"></p>
<p>所以，对于不确定或者不关心实际要操作的类型，可以使用无限制通配符（尖括号里一个问号，即 &lt;?&gt; ），表示可以持有任何类型。像 countLegs 方法中，限定了上届，但是不关心具体类型是什么，所以对于传入的 Animal 的所有子类都可以支持，并且不会报错。而 countLegs1 就不行。</p>
<h3 id="上界通配符-lt-extends-E-gt"><a href="#上界通配符-lt-extends-E-gt" class="headerlink" title="上界通配符 &lt; ? extends E&gt;"></a>上界通配符 &lt; ? extends E&gt;</h3><blockquote>
<p>上届：用 extends 关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。</p>
</blockquote>
<p>在类型参数中使用 extends 表示这个泛型中的参数必须是 E 或者 E 的子类，这样有两个好处：</p>
<ul>
<li>如果传入的类型不是 E 或者 E 的子类，编译不成功</li>
<li>泛型中可以使用 E 的方法，要不然还得强转成 E 才能使用</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;K <span class="keyword">extends</span> A, E <span class="keyword">extends</span> B&gt; <span class="function">E <span class="title">test</span><span class="params">(K arg1, E arg2)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    E result = arg2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    arg2.compareTo(arg1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//.....</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> result;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>类型参数列表中如果有多个类型参数上限，用逗号分开</p>
</blockquote>
<h3 id="下界通配符-lt-super-E-gt"><a href="#下界通配符-lt-super-E-gt" class="headerlink" title="下界通配符 &lt; ? super E&gt;"></a>下界通配符 &lt; ? super E&gt;</h3><blockquote>
<p>下界: 用 super 进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object</p>
</blockquote>
<p>在类型参数中使用 super 表示这个泛型中的参数必须是 E 或者 E 的父类。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;<span class="type">T</span>&gt; void test(<span class="type">List</span>&lt;? <span class="keyword">super</span> <span class="type">T</span>&gt; dst, <span class="type">List</span>&lt;<span class="type">T</span>&gt; src)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="type">T</span> t : src) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dst.add(t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public static void main(<span class="type">String</span>[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="type">List</span>&lt;<span class="type">Dog</span>&gt; dogs = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="type">List</span>&lt;<span class="type">Animal</span>&gt; animals = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">new</span> <span class="type">Test3</span>().test(animals,dogs);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Dog 是 Animal 的子类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>dst 类型 “大于等于” src 的类型，这里的“大于等于”是指 dst 表示的范围比 src 要大，因此装得下 dst 的容器也就能装 src 。</p>
<h3 id="？-和-T-的区别"><a href="#？-和-T-的区别" class="headerlink" title="？ 和 T 的区别"></a>？ 和 T 的区别</h3><p><img src="http://image.winrains.cn/2019/08/20190829135619-75ae8.png" alt="img"></p>
<p>？和 T 都表示不确定的类型，区别在于我们可以对 T 进行操作，但是对 ？ 不行，比如如下这种 ：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">T t = operate<span class="comment">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 不可以</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">？ car = operate<span class="comment">()</span>;</span></pre></td></tr></table></figure>

<p>简单总结下：<br>T 是一个 确定的 类型，通常用于泛型类和泛型方法的定义，？是一个 不确定 的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。</p>
<h4 id="区别1：通过-T-来-确保-泛型参数的一致性"><a href="#区别1：通过-T-来-确保-泛型参数的一致性" class="headerlink" title="区别1：通过 T 来 确保 泛型参数的一致性"></a>区别1：通过 T 来 确保 泛型参数的一致性</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 T 来 确保 泛型参数的一致性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="built_in">Number</span>&gt; <span class="built_in">void</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">test(List&lt;T&gt; dest, List&lt;T&gt; src)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">test(List&lt;? <span class="keyword">extends</span> <span class="built_in">Number</span>&gt; dest, List&lt;? <span class="keyword">extends</span> <span class="built_in">Number</span>&gt; src)</span></pre></td></tr></table></figure>

<p>像下面的代码中，约定的 T 是 Number 的子类才可以，但是申明时是用的 String ，所以就会飘红报错。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829135620-2b52e.png" alt="img"></p>
<p>不能保证两个 List 具有相同的元素类型的情况</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">GlmapperGeneric&lt;<span class="keyword">String</span>&gt; glmapperGeneric = <span class="keyword">new</span> <span class="type">GlmapperGeneric</span>&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;<span class="keyword">String</span>&gt; dest = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;Number&gt; src = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">glmapperGeneric.testNon(dest,src);</span></pre></td></tr></table></figure>

<p>上面的代码在编译器并不会报错，但是当进入到 testNon 方法内部操作时（比如赋值），对于 dest 和 src 而言，就还是需要进行类型转换。</p>
<h4 id="区别2：类型参数可以多重限定而通配符不行"><a href="#区别2：类型参数可以多重限定而通配符不行" class="headerlink" title="区别2：类型参数可以多重限定而通配符不行"></a>区别2：类型参数可以多重限定而通配符不行</h4><p><img src="http://image.winrains.cn/2019/08/20190829135620-be4a2.png" alt="img"></p>
<p>使用 &amp; 符号设定多重边界（Multi Bounds)，指定泛型类型 T 必须是 MultiLimitInterfaceA 和 MultiLimitInterfaceB 的共有子类型，此时变量 t 就具有了所有限定的方法和属性。对于通配符来说，因为它不是一个确定的类型，所以不能进行多重限定。</p>
<h4 id="区别3：通配符可以使用超类限定而类型参数不行"><a href="#区别3：通配符可以使用超类限定而类型参数不行" class="headerlink" title="区别3：通配符可以使用超类限定而类型参数不行"></a>区别3：通配符可以使用超类限定而类型参数不行</h4><p>类型参数 T 只具有 一种 类型限定方式：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">T <span class="keyword">extends</span> A</span></pre></td></tr></table></figure>

<p>但是通配符 ? 可以进行 两种限定：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">? <span class="keyword">extends</span> A</span></pre></td></tr><tr><td class="code"><pre><span class="line">? <span class="keyword">super</span> A</span></pre></td></tr></table></figure>

<h2 id="Class-和-Class-区别"><a href="#Class-和-Class-区别" class="headerlink" title="Class 和 Class 区别"></a><code>Class</code> 和 <code>Class</code> 区别</h2><p>前面介绍了 ？ 和 T 的区别，那么对于，<code>Class</code> 和 `` 又有什么区别呢？<br><code>Class</code> 和 <code>Class</code><br>最常见的是在反射场景下的使用，这里以用一段发射的代码来说明下。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过反射的方式生成  multiLimit</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 对象，这里比较明显的是，我们需要使用强制类型转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">MultiLimit multiLimit = (MultiLimit)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name(<span class="string">"com.glmapper.bridge.boot.generic.MultiLimit"</span>)</span>.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span></pre></td></tr></table></figure>

<p>对于上述代码，在运行期，如果反射的类型不是 MultiLimit 类，那么一定会报 java.lang.ClassCastException 错误。<br>对于这种情况，则可以使用下面的代码来代替，使得在在编译期就能直接 检查到类型的问题：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829135621-e19b0.png" alt="img"></p>
<p><code>Class</code> 在实例化的时候，T 要替换成具体类。<code>Class</code> 它是个通配泛型，? 可以代表任何类型，所以主要用于声明时的限制情况。比如，我们可以这样做申明：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Class</span>&lt;?&gt; clazz;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 不可以，因为 T 需要指定类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Class</span>&lt;T&gt; clazzT;</span></pre></td></tr></table></figure>

<p>所以当不知道定声明什么类型的 Class 的时候可以定义一 个Class&lt;?&gt;。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829135622-b7ad1.png" alt="img"></p>
<p>那如果也想 <code>public Class clazzT;</code> 这样的话，就必须让当前的类也指定 T ，</p>
<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span>&lt;<span class="title">T</span>&gt; &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">Class</span>&lt;?&gt; <span class="title">clazz</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    // 不会报错</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">Class</span>&lt;<span class="title">T</span>&gt; <span class="title">clazzT</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文零碎整理了下 JAVA 泛型中的一些点，不是很全，仅供参考。如果文中有不当的地方，欢迎指正。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.toutiao.com%2Fa6694132392728199683">JAVA泛型通配符T，E，K，V区别，网友回复：一文秒懂</a></li>
</ul>
<blockquote>
<p>作者：glmapper</p>
<p>来源：<a href="https://juejin.im/post/5d5789d26fb9a06ad0056bd9" target="_blank" rel="noopener">https://juejin.im/post/5d5789d26fb9a06ad0056bd9</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring AOP介绍</title>
    <url>/2019/12/26/Spring-AOP%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="为什么要有aop"><a href="#为什么要有aop" class="headerlink" title="为什么要有aop"></a>为什么要有aop</h3><p>我们都知道Java是一种面向对象编程【也就是OOP】的语言，不得不说面向对象编程是一种及其优秀的设计，但是任何语言都无法十全十美，对于OOP语言来说，当需要为部分对象引入公共部分的时候，OOP就会引入大量的重复代码【这些代码我们可以称之为横切代码】。而这也是Aop出现的原因，没错，<strong>Aop就是被设计出来弥补OOP短板的</strong>。Aop便是将这些横切代码封装到一个可重用模块中，继而降低模块间的耦合度，这样也有利于后面维护。</p>
<a id="more"></a>

<h3 id="Aop是什么东西"><a href="#Aop是什么东西" class="headerlink" title="Aop是什么东西"></a>Aop是什么东西</h3><p>学过Spring的都知道，Spring内比较核心的功能便是Ioc和Aop，Ioc的主要作用是应用对象之间的解耦，而Aop则可以实现横切代码【如权限、日志等】与他们绑定的对象之间的解耦，举个浅显易懂的小栗子，在用户调用很多接口的地方，我们都需要做权限认证，判断用户是否有调用该接口的权限，如果每个接口都要自己去做类似的处理，未免有点sb了，也不够装x，因此Aop就可以派上用场了，将这些处理的代码放到切片中，定义一下切片、连接点和通知，刷刷刷跑起来就ojbk了。<br>想要了解Aop，就要先理解以下几个术语，如PointCut、Advice、JoinPoint。接下来尽量用白话文描述下。<br><strong>PointCut【切点】</strong> 其实切点的概念很好理解，你想要去切某个东西之前总得先知道要在哪里切入是吧，切点格式如下：execution(* com.nuofankj.springdemo.aop.<em>Service.</em>(..)) 可以看出来，格式使用了正常表达式来定义那个范围内的类、那些接口会被当成切点，简单明了。<br><strong>Advice</strong> Advice行内很多人都定义成了通知，但是我总觉得有点勉强。所谓的Advice其实就是定义了Aop何时被调用，确实有种通知的感觉，何时调用其实也不过以下几种：</p>
<ul>
<li>Before 在方法被调用之前调用</li>
<li>After 在方法完成之后调用</li>
<li>After-returning 在方法成功执行之后调用</li>
<li>After-throwing 在方法抛出异常之后调用</li>
<li>Around 在被通知的方法调用之前和调用之后调用</li>
</ul>
<p><strong>JoinPoint【连接点】</strong> JoinPoint连接点，其实很好理解，上面又有通知、又有切点，那和具体业务的连接点又是什么呢？没错，其实就是对应业务的方法对象，因为我们在横切代码中是有可能需要用到具体方法中的具体数据的，而连接点便可以做到这一点。</p>
<h3 id="给出一个Aop在实际中的应用场景"><a href="#给出一个Aop在实际中的应用场景" class="headerlink" title="给出一个Aop在实际中的应用场景"></a>给出一个Aop在实际中的应用场景</h3><p>先给出两个业务内的接口，一个是聊天，一个是购买东西</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140729-c2c96.png" alt="图片描述"></p>
<p><img src="http://image.winrains.cn/2019/08/20190829140730-705db.png" alt="图片描述"></p>
<p>接下来该给出说了那么久的切片了</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140730-b536d.png" alt="图片描述"></p>
<p>可以从中看到PointCut【切点】是</p>
<blockquote>
<p>execution(* com.nuofankj.springdemo.aop.<em>Service.</em>(..))</p>
</blockquote>
<p>Advice是</p>
<blockquote>
<p>Before</p>
</blockquote>
<p>JoinPoint【连接点】是</p>
<blockquote>
<p>MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod();</p>
</blockquote>
<p>代码浅显易懂，其实就是将ChatService和BuyService里边给userId做权限校验的逻辑抽出来做成切片。<br>那么如何拿到具体业务方法内的具体参数呢？ 这里是定义了一个新的注解</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140731-c3324.png" alt="图片描述"></p>
<p>作用可以直接看注释，使用地方如下</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140732-e1517.png" alt="图片描述"></p>
<p>可以看到对应接口使用了AuthPermission的注解，而取出的地方在于</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140732-ad2a0.png" alt="图片描述"></p>
<p>是的，这样便可以取出来对应的接口传递的userId具体是什么了，而校验逻辑可以自己处理。送佛送到西，不对，撸码撸整套，接下来给出运行的主类</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140733-a9a1f.png" alt="图片描述"></p>
<p>可以看到，上面有一个接口传递的userId是1，另一个是123，而上面权限认证只有1才说通过，否则会抛出异常。运行结果如下</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140734-55ef4.png" alt="图片描述"></p>
<p>运行结果可想而知，1的通过验证，123的失败。</p>
<h3 id="Spring-Aop做了什么【开始源码跟踪阅读】"><a href="#Spring-Aop做了什么【开始源码跟踪阅读】" class="headerlink" title="Spring Aop做了什么【开始源码跟踪阅读】"></a>Spring Aop做了什么【开始源码跟踪阅读】</h3><p>首先给出Main类</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140734-e3249.png" alt="2"></p>
<p>可以看到我这里用的是AnnotationConfigApplicationContext，解释下</p>
<blockquote>
<p>AnnotationConfigApplicationContext是一个用来管理注解bean的容器，所以我可以用该容器取得我定义了@Service注解的类的实例。</p>
</blockquote>
<p>打断点后，启动程序，我们可以看到TestDemo的实例在idea的表现是这样的</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140735-31fda.png" alt="3"></p>
<p>而BuyService的实例却不同</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140736-d6fe1.png" alt="4"></p>
<p>我们可以从看到BuyService是SpringCGLIB强化过的一个实例，那么问题来了</p>
<ul>
<li>为什么BuyService被强化过而TestDemo没有？</li>
<li>SpringCGLIB又是什么？</li>
<li>Spring是在什么时候生成一个强化后的实例的？</li>
</ul>
<p>带着这些疑问，让我们一步步从Spring源码中找到答案。<br><strong>为什么BuyService被强化过而TestDemo没有？</strong><br>这个问题比较简单，我们可以看回上面我对切片的定义</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140737-98698.png" alt="5"></p>
<p>可以从代码中看出，我定义的切点是<em>Service命名的类，而TestDemo很明显不符合这个设定，因此TestDemo逃过被强化的命运。<br>*</em>SpringCGLIB又是什么？**<br>CGLIB其实就是一种实现动态代理的技术，利用了ASM开源包，先将代理对象类的class文件加载进来，之后通过修改其字节码并且生成子类。结合demo来解读便是SpringCGLIB会先将BuyService加载到内存中，之后通过修改字节码生成BuyService的子类，该子类便是强化后的BuyService，上文看到的强化后的实例便是该子类的实例。<br><strong>Spring是在什么时候生成一个强化后的实例的？</strong><br>这个便厉害了，首先，我们要先从Spring如何加载切片入手。</p>
<blockquote>
<p><strong>【思考Time】</strong> 为什么我会选择从切片入手呢？原因很简单，Spring就是因为发现了切片，并且对切片进行解析后才知道了要强化哪些类。</p>
</blockquote>
<p><img src="http://image.winrains.cn/2019/08/20190829140737-9f030.png" alt="6"></p>
<p>切片的处理第一步便是要加上@Aspect注解，学过注解的都知道，注解的作用更多的是标志识别，也就是告诉Spring这个类要做相关特殊处理，因此我们可以基于该认识，反调该注解使用的地方</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140738-1885b.png" alt="7"></p>
<p>可以从截图看出，我反调了@Aspect后定位到了AbstractAspectJAdvisorFactory类中的hasAspectAnnotation函数，并且携带参数clazz，因此我猜测该接口就是用来识别clazz是否使用了注解@Aspect的地方，于是我打上了断点，并且加了条件 clazz == AuthAspect.class ，重新启动后</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140740-97aaf.png" alt="8"></p>
<p>我们看到确实被断点到了，可以得出我的猜测是对的。 我们先看下断点后做了什么事情，之后再看下具体是哪里进行了扫描。在断点处按F8继续往下走，最后发现</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140740-1f21b.png" alt="13"></p>
<p>没错，可以看到最终是构建成了一个Advisor对象 ，并且放入了BeanFactoryAspectJAdvisorsBuilder中的advisorsCache中，<strong>这样意味着Spring最终会将使用了@Aspect注解的类构建成Advisor对象后保存进BeanFactoryAspectJAdvisorsBuilder.advisorsCache中。</strong><br>接下来我们看看具体是哪里进行了使用@Aspect注解的相关类的扫描，这次我断点的地方在BeanFactoryAspectJAdvisorsBuilder中的advisorsCache调用了put的地方。</p>
<blockquote>
<p><strong>【思考Time】</strong> 为什么我会选择在advisorsCache调用了put的地方打断点呢？原因很简单，因为我们上面已经分析出@Aspect注解的类构建成Advisor对象后保存进BeanFactoryAspectJAdvisorsBuilder.advisorsCache中，而我通过反调知道put的地方只有一个，因此我可以断定在此处打断点可以知道到底哪里进行了扫描的操作。</p>
</blockquote>
<p><img src="http://image.winrains.cn/2019/08/20190829140741-95484.png" alt="14"></p>
<p>通过打断点后我从idea的Frames面板中看到</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140742-20566.png" alt="19"></p>
<p>没错，做了扫描@Aspect注解的扫描器是AbstractAutoProxyCreator类</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140743-80ddb.png" alt="11"></p>
<p><img src="http://image.winrains.cn/2019/08/20190829140743-99987.png" alt="12"></p>
<p>我们可以从中看到AbstractAutoProxyCreator最终实现了InstantiationAwareBeanPostProcessor接口。</p>
<blockquote>
<p><strong>【思考Time】</strong> 这个接口有什么作用呢？具体可以看我前阵子写的一篇文章：<a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fr2OEqsap6NgaEnNveO1mVg">mp.weixin.qq.com/s/r2OEqsap6…</a></p>
</blockquote>
<p>现在已经找到了扫描注解的地方，并且我们也看到了最终是生成了Advisor对象 ，并且放入了BeanFactoryAspectJAdvisorsBuilder中的advisorsCache中，那么Spring是在什么时候生成强化后的实例的呢？ 接下来我的切入点是AbstractAutoProxyCreator中的postProcessAfterInitialization接口。</p>
<blockquote>
<p><strong>【思考Time】</strong> 之所以会选择AbstractAutoProxyCreator为切入点，是因为通过命名可以看出这是SpringAop用来构建代理[强化]对象的地方，并且由于SpringCGLIB是先将目标类加载到内存中，之后通过修改字节码生成目标类的子类，因此我猜测强化是在目标类实例化后触发postProcessAfterInitialization的时候进行的。</p>
</blockquote>
<p>因此我在postProcessAfterInitialization接口中做了断点，并且加了调试条件。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140744-e739c.png" alt="14"></p>
<p>可以看到我这里断点到了ChatService这个类。</p>
<blockquote>
<p><strong>【思考Time】</strong> 为什么专门断点ChatService这个类？之所以会专门定位这个类，因为我的切面的目标类就包含了ChatService，通过定位到该类，我们可以一步步捕捉Spring的强化操作。</p>
</blockquote>
<p>我们可以看到，生成强化后的对象就藏在wrapIfNecessary中。</p>
<blockquote>
<p><strong>【思考Time】</strong> 为什么我会知道是生成强化后的对象就藏在wrapIfNecessary中呢？因为我通过调试发现，在调用了wrapIfNecessary接口后，返回的对象是强化后的对象。</p>
</blockquote>
<p>那么问题来了，为什么Spring会知道ChatService类需要进行进行强化呢？我们可以从wrapIfNecessary中走入更深一层，通过调试，可以看到</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140744-61c41.png" alt="16"></p>
<p>在此处会从advisorsCache中根据aspectName取出对应的Advisor。拿到Advisor后，便是进行过滤的地方了，通过F8往后走，可以看到过滤的地方在AopUtils.canApply接口中。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140745-70bb8.png" alt="17"></p>
<p>可以看到此处传进来的targetClass符合切面的要求，因此可以进行构建强化对象。 接下来让我们看下真正产生强化对象的地方了</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140746-c6df7.png" alt="18"></p>
<p>我们可以看到在AbstractAutoProxyCreator的createProxy函数中看到，最后会构造出一个强化后的chatService。 那么createProxy又做了什么呢？通过断点一层层深入后，发现最后会到达</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140747-61a37.png" alt="18"></p>
<p>通过源码分析，我们发现在AbstractAutoProxyCreator构建强化对象的时候是调用了createAopProxy函数，重点来了，我们可以看到针对targetClass，也就是ChatService做了判断，如果targetClass有实现接口或者targetClass是Proxy的子类，那么使用的是JDK的动态代理实现AOP，如果不是才会使用CGLIB实现动态代理。<br><strong>那么JDK实现的动态代理和CGLIB实现的动态代理有什么区别吗？</strong> 首先动态代理可以分为两种：JDK动态代理和CGLIB动态代理。从文中我们也可以看出，当目标类有接口的时候才会使用JDK动态代理，其实是因为JDK动态代理无法代理一个没有接口的类。JDK动态代理是利用反射机制生成一个实现代理接口的匿名类，而CGLIB是针对类实现代理，主要是对指定的类生成一个子类，并且覆盖其中的方法。</p>
<h3 id="Aop实现机制之代理模式"><a href="#Aop实现机制之代理模式" class="headerlink" title="Aop实现机制之代理模式"></a>Aop实现机制之代理模式</h3><p>本来想一篇文章说完源码跟踪分析Aop和Aop的实现机制代理模式，发现源码跟踪分析已经很占篇幅了，因此没办法只能再开一篇文章专门阐述Aop的实现机制代理模式，期待下篇文章。<br>大家都知道，我有个习惯，在动手写一篇文章之前会先将该文章相关的资料仔细琢磨一遍，然后再结合源码再调试一遍，结果，说好的</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140748-b1917.png" alt="img"></p>
<p>看源码也确实是</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140748-23b5b.png" alt="img"></p>
<p>源码确实有进行了是否是接口的判断，但是问题来了，我调试的时候发现无论代理类是否有接口，最终都会被强制使用CGLIB代理，没办法，只能翻看SpringBoot的相关文档，最终发现原来SpringBoot从2.0开始就默认使用Cglib代理了，好家伙，怪不得我调试半天找不到原因。<br>那么如何解决呢？肯定是通过配置啦，按照如下配置即可</p>
<blockquote>
<p>在application.properties文件中配置 spring.aop.proxy-target-class=false</p>
</blockquote>
<p>即可。</p>
<blockquote>
<p><strong>【划重点】</strong> 曾经遇见过面试官问，SpringBoot默认代理类型是什么？看完该篇文章，我们就可以果断的回答是Cglib代理了。通过调试代码发现的规则，我想我这辈子都不会忘记这个默认规则。</p>
</blockquote>
<h3 id="动态代理原理剖析"><a href="#动态代理原理剖析" class="headerlink" title="动态代理原理剖析"></a>动态代理原理剖析</h3><h4 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h4><p>简单来说，就是在运行的时候为目标类动态生成代理类，而在操作的时候都是操作代理类，代理模式有个显而易见的好处，那便是可以在不改变对象方法的情况下对方法进行增强。试想下，我们在<a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FtQLO-lF_HiG6YK1kGQeD9w">你必须要懂的Spring-Aop之应用篇</a>有提到使用Aop来做权限认证，如果不用Aop，那么我们就必须要为所有需要权限认证的方法都加上权限认证代码，听起来就觉得<strong>蛋疼</strong>，你觉得对不对？</p>
<h4 id="为什么不用静态代理"><a href="#为什么不用静态代理" class="headerlink" title="为什么不用静态代理"></a>为什么不用静态代理</h4><p>静态代理类不是说不可以用，如果只有一个类需要被代理，那么自然可以用，如 这是在<a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FtQLO-lF_HiG6YK1kGQeD9w">你必须要懂的Spring-Aop之应用篇</a>使用的一个例子类，该类的作用只是打印出我要买东西。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140748-979ec.png" alt="3"></p>
<p>代理类如下</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140749-8c4a0.png" alt="4"></p>
<p>可以看到这个BuyProxy代理类只是塞了一个IBuyServcie接口进行，而且自身也实现了接口IBuyService，而在buyItem方法被调用的时候会先做自己的操作，再调用塞进去的接口的buyItem方法。 测试类很简单，如下</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140750-74a87.png" alt="5"></p>
<p>运行后很自然而然的打印出</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140751-89b3c.png" alt="6"></p>
<p>静态代理就是简单，但是<strong>弊端</strong>也很明显，如果有多个类都需要同样的代理，都实现了同样的接口，那么如果使用静态代理的话，我们就要构造多个Proxy类，就会造成<strong>类爆炸</strong>。 而使用了Aop后，也就是动态代理后，便可以一次性解决该问题了，具体可以看<a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FtQLO-lF_HiG6YK1kGQeD9w">你必须要懂的Spring-Aop之应用篇</a>中的操作方法。</p>
<h4 id="JDK动态代理原理"><a href="#JDK动态代理原理" class="headerlink" title="JDK动态代理原理"></a>JDK动态代理原理</h4><p>这里给出一个JDK动态代理的demo 首先给出一个简单的业务类，Hello类和接口</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140751-69aba.png" alt="7"></p>
<p><img src="http://image.winrains.cn/2019/08/20190829140751-de9d6.png" alt="8"></p>
<p>真正实现了类的代理功能的其实就是这个实现了接口InvocationHandler的JdkProxy类</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140752-d5d78.png" alt="9"></p>
<p>我们可以看到其中必须实现的方法是invoke，可以看到invoke方法的参数带有Method对象，这个就是我们的目标Method，现在我们的目的就是要在这个Method在被调用前后实现我们的业务，可以看到在method.invoke反调前后实现了before和after业务。<br>这里再给出一个Main测试类，作用是取得Hello的代理类，然后调用其中的say方法。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140753-a95d2.png" alt="10"></p>
<p>运行结果如下</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140754-ab525.png" alt="11"></p>
<p><strong>原理很简单</strong> 在JdkProxyMain中hello调用say的时候，由于Hello已经被“代理”了，所以在调用say函数的时候其实是调用JdkProxy类中的invoke函数，而在invoke函数中先是实现了before函数才实现Object result = method.invoke(target, args)，这一句其实是调用say函数，而后才实现after函数，于是这样就可以不必在改动目标类的前提下实现代理了，并且不会像静态代理那样导致类爆炸。</p>
<h4 id="CGLIB动态代理原理"><a href="#CGLIB动态代理原理" class="headerlink" title="CGLIB动态代理原理"></a>CGLIB动态代理原理</h4><p>先给出一个Cglib动态代理的demo</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140754-4e272.png" alt="13"></p>
<p>核心类是实现了MethodInterceptor的CGlibProxy类</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140754-3e363.png" alt="14"></p>
<p>可以看到其中实现了方法intercept，先是在目标函数被调用前实现自己的业务，比如before()和after()，之后再通过 proxy.invokeSuper(obj, args) 触发目标函数。<br>最后给出入口类</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140755-ec283.png" alt="15"></p>
<p>最后给出运行类，运行类如下</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140756-563b0.png" alt="15"></p>
<p>可以看到运行结果</p>
<p><img src="http://image.winrains.cn/2019/08/20190829140756-eeee5.png" alt="16"></p>
<p><strong>原理很简单</strong> 在CglibProxyMain中hello调用say的时候，由于Hello已经被“代理”了，所以在调用say函数的时候其实是调用CGlibProxy类中的intercept函数。</p>
<blockquote>
<p>作者：饭谈编程</p>
<p>来源：<a href="https://juejin.im/post/5d558819e51d45620b21c3a7" target="_blank" rel="noopener">https://juejin.im/post/5d558819e51d45620b21c3a7</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring7大知识点</title>
    <url>/2019/12/26/Spring7%E5%A4%A7%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>Spring框架自诞生以来一直备受开发者青睐，有人亲切的称之为：Spring 全家桶。它包括SpringMVC、SpringBoot、Spring Cloud、Spring Cloud Dataflow等解决方案。<br>很多研发人员把spring看作心目中最好的java项目，没有之一。<br>所以这是重点也是难点，工作中必须会，面试时肯定考。<br><strong>那么，今天花费10分钟，梳理Spring框架相关知识</strong>。</p>
<a id="more"></a>

<h1 id="一、Spring知识点-汇总"><a href="#一、Spring知识点-汇总" class="headerlink" title="一、Spring知识点-汇总"></a>一、Spring知识点-汇总</h1><hr>
<p>spring系列包含非常多的项目，可以满足java开发中的方方面面。<br>先来看常用框架的知识点汇总，如图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829141013-a68f8.png" alt="img"></p>
<h2 id="Ⅰ、5个常用的spring框架"><a href="#Ⅰ、5个常用的spring框架" class="headerlink" title="Ⅰ、5个常用的spring框架"></a>Ⅰ、5个常用的spring框架</h2><hr>
<h3 id="1-spring-framework"><a href="#1-spring-framework" class="headerlink" title="1.spring framework"></a>1.spring framework</h3><p>也就是我们经常说的spring框架，包括了ioc依赖注入，Context上下文、bean管理、springmvc等众多功能模块，其它spring项目比如spring boot也会依赖spring框架。</p>
<h3 id="2-spring-boot"><a href="#2-spring-boot" class="headerlink" title="2.spring boot"></a>2.spring boot</h3><p>它的目标是简化Spring应用和服务的创建、开发与部署，简化了配置文件，使用嵌入式web服务器，含有诸多开箱即用的微服务功能，可以和spring cloud联合部署。<br>Spring Boot的核心思想是约定大于配置，应用只需要很少的配置即可，简化了应用开发模式。</p>
<h3 id="3-Spring-Data"><a href="#3-Spring-Data" class="headerlink" title="3.Spring Data"></a>3.Spring Data</h3><p>是一个数据访问及操作的工具集，封装了多种数据源的操作能力，包括：jdbc、Redis、MongoDB等。</p>
<h3 id="4-Spring-Cloud"><a href="#4-Spring-Cloud" class="headerlink" title="4.Spring Cloud"></a>4.Spring Cloud</h3><p>是一套完整的微服务解决方案，是一系列不同功能的微服务框架的集合。Spring Cloud基于Spring Boot，简化了分布式系统的开发，集成了服务发现、配置管理、消息总线、负载均衡、断路器、数据监控等各种服务治理能力。比如sleuth提供了全链路追踪能力，Netflix套件提供了hystrix熔断器、zuul网关等众多的治理组件。config组件提供了动态配置能力，bus组件支持使用RabbitMQ、kafka、Activemq等消息队列，实现分布式服务之间的事件通信。</p>
<h3 id="5-Spring-Security"><a href="#5-Spring-Security" class="headerlink" title="5. Spring Security"></a>5. Spring Security</h3><p>主要用于快速构建安全的应用程序和服务，在Spring Boot和Spring Security OAuth2的基础上，可以快速实现常见安全模型，如单点登录，令牌中继和令牌交换。你可以了解一下oauth2授权机制和jwt认证方式。oauth2是一种授权机制，规定了完备的授权、认证流程。JWT全称是JSON Web Token，是一种把认证信息包含在token中的认证实现，oauth2授权机制中就可以应用jwt来作为认证的具体实现方法。</p>
<h2 id="Ⅱ、Struts的具体作用"><a href="#Ⅱ、Struts的具体作用" class="headerlink" title="Ⅱ、Struts的具体作用"></a>Ⅱ、Struts的具体作用</h2><hr>
<p>struts是曾经非常火爆的web组合ssh中的控制层。我们知道web服务一般都采用MVC分层模型构建，就是model层负责内部数据模型，controller负责请求的分发控制，view层负责返回给用户展示的视图。struts实现的就是其中控制层的角色。<br>Struts采用Filter实现，针对类进行拦截，每次请求就会创建一个Action。使用struts的SSH组合已经逐渐被使用springMVC的SSM组合代替，也就是Spring-MVC+Spring+MyBatis的组合，一方面原因是由于struts对几次安全漏洞的处理，让大家对struts的信心受到影响；另一方面，springmvc更加的灵活，不需要额外配置，不存在和spring整合等问题，使用更加方便，所以建议以SSM框架的学习为主。</p>
<h2 id="Ⅲ、常用的ORM框架"><a href="#Ⅲ、常用的ORM框架" class="headerlink" title="Ⅲ、常用的ORM框架"></a>Ⅲ、常用的ORM框架</h2><hr>
<p>ORM就是对象关系匹配，是为了解决面向对象与关系数据库存在的互不匹配的问题。简单来说，就是把关系数据库中的数据转换成面向对象程序中的对象。<br>常用的ORM框架有Hibernate和MyBatis，也就是ssh组合和ssm组合中的h与m。<br><strong>它们的特点和区别如下</strong>：<br>Hibernate对数据库结构提供了完整的封装，实现了POJO对象与数据库表之间的映射，能够自动生成并执行SQL语句。只要定义了POJO 到数据库表的映射关系，就可以通过Hibernate提供的方法完成数据库操作。Hibernate符合JPA规范，就是Java持久层API。<br>mybatis通过映射配置文件，将SQL所需的参数和返回的结果字段映射到指定对象，mybatis不会自动生成sql，需要自己定义sql语句，不过更方便对sql语句进行优化。<br><strong>总结起来</strong>：</p>
<ol>
<li>hibernate配置要比mybatis复杂的多，学习成本也比mybatis高。mybatis，简单、高效、灵活，但是需要自己维护sql；</li>
<li>hibernate功能强大、全自动、适配不同数据库，但是非常复杂，灵活性稍差。</li>
</ol>
<h2 id="Ⅳ、Netty简介"><a href="#Ⅳ、Netty简介" class="headerlink" title="Ⅳ、Netty简介"></a>Ⅳ、Netty简介</h2><hr>
<p>Netty是一个高性能的异步事件驱动的网络通信框架，Netty对JDK原生NIO进行封装，简化了网络服务的开发。下文会详细讲解<br>另外，同类型的框架还有mina、grizzly，不过目前使用的相对较少，一般不会在面试中出现，可以作为兴趣简单了解。</p>
<h2 id="Ⅴ、RPC服务"><a href="#Ⅴ、RPC服务" class="headerlink" title="Ⅴ、RPC服务"></a>Ⅴ、RPC服务</h2><hr>
<p>Motan、Dubbo、gRPC都是比较常用的高性能rpc框架，可以提供完善的服务治理能力，java版本的通信层都是基于前面提到的Netty实现。它们的特点稍后介绍。</p>
<h2 id="Ⅵ、其他常用框架"><a href="#Ⅵ、其他常用框架" class="headerlink" title="Ⅵ、其他常用框架"></a>Ⅵ、其他常用框架</h2><hr>
<p>jersy和restEasy都是可以快速开发restful服务的框架。<br>和springmvc相比，这两个框架都是基于jax-rs标准，而springmvcs基于servlet，使用自己构建的API，是两个不同的标准。<br>shiro框架是一个与spring security类似的开源的权限管理框架，用于访问授权、认证、加密及会话管理。能够支持单机与分布式session管理。<br>相比security，shiro更加简单易用。</p>
<h1 id="二、Spring知识点-详解"><a href="#二、Spring知识点-详解" class="headerlink" title="二、Spring知识点-详解"></a>二、Spring知识点-详解</h1><hr>
<h2 id="Ⅰ、spring基本概念"><a href="#Ⅰ、spring基本概念" class="headerlink" title="Ⅰ、spring基本概念"></a>Ⅰ、spring基本概念</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141014-5112a.png" alt="Sping中的基本概念"></p>
<p>本文涉及的流程与实现默认都是基于最新的5.x版本。<br>spring中的几个重要概念如下：</p>
<h3 id="1-IOC"><a href="#1-IOC" class="headerlink" title="1.IOC"></a>1.IOC</h3><p>IOC，就是控制反转，如最左边，拿公司招聘岗位来举例：<br>假设一个公司有产品、研发、测试等岗位。如果是公司根据岗位要求，逐个安排人选，如图中向下的箭头，这是正向流程。如果反过来，不用公司来安排候选人，而是由第三方猎头来匹配岗位和候选人，然后进行推荐，如图中向上的箭头，这就是控制反转。<br>在spring中，对象的属性是由对象自己创建的，就是正向流程；如果属性不是对象创建，而是由spring来自动进行装配，就是控制反转。这里的DI也就是依赖注入，就是实现控制反转的方式。正向流程导致了对象于对象之间的高耦合，IOC可以解决对象耦合的问题，有利于功能的复用，能够使程序的结构变得非常灵活。</p>
<h3 id="2-context上下文和bean"><a href="#2-context上下文和bean" class="headerlink" title="2.context上下文和bean"></a>2.context上下文和bean</h3><p>spring进行IOC实现时使用的有两个概念：context上下文和bean。<br>如中间图所示，所有被spring管理的、由spring创建的、用于依赖注入的对象，就叫做一个bean。Spring创建并完成依赖注入后，所有bean统一放在一个叫做context的上下文中进行管理。</p>
<h3 id="3-AOP"><a href="#3-AOP" class="headerlink" title="3.AOP"></a>3.AOP</h3><p>AOP就是面向切面编程。如右面的图，一般程序执行流程是从controller层调用service层、然后service层调用DAO层访问数据，最后在逐层返回结果。<br>这个是图中向下箭头所示的按程序执行顺序的纵向处理。但是，一个系统中会有多个不同的服务，例如用户服务、商品信息服务等等，每个服务的controller层都需要验证参数，都需要处理异常，如果按照图中红色的部分，对不同服务的纵向处理流程进行横切，在每个切面上完成通用的功能，例如身份认证、验证参数、处理异常等等、这样就不用在每个服务中都写相同的逻辑了，这就是AOP思想解决的问题。<br>AOP以功能进行划分，对服务顺序执行流程中的不同位置进行横切，完成各服务共同需要实现的功能。</p>
<h2 id="Ⅱ、spring框架"><a href="#Ⅱ、spring框架" class="headerlink" title="Ⅱ、spring框架"></a>Ⅱ、spring框架</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141015-b9e55.png" alt="Spring框架组件"></p>
<p>上图列出了spring框架主要包含的组件。这张图来自spring4.x的文档。目前最新的5.x版本中右面的portlet组件已经被废弃掉，同时增加了用于异步响应式处理的WebFlux组件。<br>并不需要对所有的组件都详细了解，只需重点了解最常用的几个组件实现，以及知道每个组件用来实现哪一类功能。<br>图中红框是比较重要的组件，core组件是spring所有组件的核心；bean组件和context组件我刚才提到了，是实现IOC和依赖注入的基础；AOP组件用来实现面向切面编程；web组件包括springmvc是web服务的控制层实现。</p>
<h2 id="Ⅲ、spring中机制和实现"><a href="#Ⅲ、spring中机制和实现" class="headerlink" title="Ⅲ、spring中机制和实现"></a>Ⅲ、spring中机制和实现</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141015-66563.png" alt="img"></p>
<h3 id="1-AOP"><a href="#1-AOP" class="headerlink" title="1.AOP"></a>1.AOP</h3><p>AOP的实现是通过代理模式，在调用对象的某个方法时，执行插入的切面逻辑。实现的方式有动态代理也叫运行时增强，比如jdk代理、CGLIB；静态代理是在编译时进行织入或类加载时进行织入，比如AspectJ。<br>关于AOP还需要了解一下对应的Aspect、pointcut、advice等注解和具体使用方式。</p>
<h3 id="2-placeHolder动态替换"><a href="#2-placeHolder动态替换" class="headerlink" title="2.placeHolder动态替换"></a>2.placeHolder动态替换</h3><p>主要需要了解替换发生的时间，是在bean definition创建完成后，bean初始化之前，是通过实现<code>BeanFactoryPostProcessor</code>接口实现的。主要实现方式有<code>PropertyPlaceholderConfigurer</code>和<code>PropertySourcesPlaceholderConfigurer</code>。这两个类实现逻辑不一样，spring boot使用<code>PropertySourcesPlaceholderConfigurer</code>实现。</p>
<h3 id="3-事务"><a href="#3-事务" class="headerlink" title="3.事务"></a>3.事务</h3><p>需要了解spring 中对事务规定的隔离类型和事务传播类型。要知道事务的隔离级别是由具体的数据库来实现的，在数据库部分我会详细介绍。<br>事务的传播类型，可以重点了解最常用的REQUIRED和SUPPORTS类型。</p>
<h3 id="4-核心接口类"><a href="#4-核心接口类" class="headerlink" title="4.核心接口类"></a>4.核心接口类</h3><ul>
<li>ApplicationContext保存了ioc的整个应用上下文，可以通过其中的beanfactory获取到任意到bean；</li>
<li>BeanFactory主要的作用是根据bean definition来创建具体的bean；</li>
<li>BeanWrapper是对Bean的包装，一般情况下是在spring ioc内部使用，提供了访问bean的属性值、属性编辑器注册、类型转换等功能，方便ioc容器用统一的方式来访问bean的属性；</li>
<li>FactoryBean通过getObject方法返回实际的bean对象，例如motan框架中referer对service的动态代理就是通过FactoryBean来实现的。</li>
</ul>
<h3 id="5-Scope"><a href="#5-Scope" class="headerlink" title="5.Scope"></a>5.Scope</h3><p>bean的scope是指bean的作用域，默认情况下是单例模式，这也是使用最多的一种方式；多例模式，即每次从beanFactory中获取bean都会创建一个新的bean。<br>request、session、global-session是在web服务中使用的scope，request每次请求都创建一个实例，session是在一个会话周期内保证只有一个实例。<br>global-session在5.x版本中已经不在使用，同时增加了Application和Websocket两种scope，分别保证在一个ServletContext与一个WebSocket中只创建一个实例。</p>
<h3 id="6-事件机制"><a href="#6-事件机制" class="headerlink" title="6.事件机制"></a>6.事件机制</h3><p>spring的事件机制需要知道spring定义的五种标准事件，具体事件可见上图，了解如何自定义事件和实现对应的applicationListener来处理自定义事件。</p>
<h2 id="Ⅳ、spring应用相关"><a href="#Ⅳ、spring应用相关" class="headerlink" title="Ⅳ、spring应用相关"></a>Ⅳ、spring应用相关</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141016-e1017.png" alt="img"></p>
<h3 id="1-常用注释"><a href="#1-常用注释" class="headerlink" title="1.常用注释"></a>1.常用注释</h3><h4 id="a-类型类注释："><a href="#a-类型类注释：" class="headerlink" title="a.类型类注释："></a><strong>a.类型类注释</strong>：</h4><p>类型类注释包括<code>controller</code>、<code>service</code>等，需要重点了解<br>其中<code>component</code>和<code>bean</code>注解的区别如下：</p>
<ul>
<li><code>@Component</code>注解在类上使用表明这个类是个组件类，需要Spring为这个类创建bean。</li>
<li><code>@Bean</code>注解使用在方法上，告诉Spring这个方法将会返回一个Bean对象，需要把返回的对象注册到Spring的应用上下文中。</li>
</ul>
<h4 id="b-设置类注解"><a href="#b-设置类注解" class="headerlink" title="b.设置类注解"></a><strong>b.设置类注解</strong></h4><p>重点了解<code>@Autowire</code>和<code>@Qualifier</code>以及bytype、byname等不同的自动装配机制。</p>
<h4 id="c-web类注解"><a href="#c-web类注解" class="headerlink" title="c.web类注解"></a><strong>c.web类注解</strong></h4><p>主要以了解为主，关注<code>@RequestMapping</code>、<code>@GetMapping</code>、<code>@PostMapping</code>等路径匹配注解，以及<code>@PathVariable</code>、<code>@RequestParam</code> 等参数获取注解。</p>
<h4 id="d-功能类注解"><a href="#d-功能类注解" class="headerlink" title="d.功能类注解"></a><strong>d.功能类注解</strong></h4><p>包括<code>@ImportResource</code>引用配置、<code>@ComponentScan</code>注解自动扫描、<code>@Transactional</code>事务注解等等，这里不一一介绍了。</p>
<h3 id="2-配置方式"><a href="#2-配置方式" class="headerlink" title="2.配置方式"></a>2.配置方式</h3><p>需要了解配置spring的几种方式，xml文件配置、注解配置和使用api进行配置。<br>自动装配机制需要了解按类型匹配进行自动装配，按bean名称进行自动装配，构造器中的自动装配和自动检测等主要的四种方式。<br>还需要了解一下list、set、map等集合类属性的配置方式以及内部bean的使用。</p>
<h2 id="Ⅴ、Spring的Context的初始化流程"><a href="#Ⅴ、Spring的Context的初始化流程" class="headerlink" title="Ⅴ、Spring的Context的初始化流程"></a>Ⅴ、Spring的Context的初始化流程</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141016-37f83.png" alt="Spring Context初始化流程"></p>
<p>图中左上角是三种类型的context，xml配置方式的context、springboot的context和web服务的context。不论哪种context，创建后都会调用到AbstractApplicationContext类的refresh方法，这个方法是我们要重点分析的。<br><strong>refresh方法中，操作共分13步</strong>：<br><strong>第1步</strong>：对刷新进行准备，包括设置开始时间、设置激活状态、初始化context环境中的占位符，这个动作根据子类的需求由子类来执行，然后验证是否缺失必要的properties；<br><strong>第2步</strong>：刷新并获得内部的bean factory；<br><strong>第3步</strong>：对bean factory进行准备工作，比如设置类加载器和后置处理器、配置不进行自动装配的类型、注册默认的环境bean；<br><strong>第4步</strong>：为context的子类提供后置处理bean factory的扩展能力。如果子类想在bean定义加载完成后，开始初始化上下文之前做一些特殊逻辑，可以复写这个方法；<br><strong>第5步</strong>，执行context中注册的bean factory后缀处理器；</p>
<blockquote>
<p>注：这里有两种后置处理器，一种是可以注册bean的后缀处理器，另一种是针对bean factory进行处理的后置处理器。执行的顺序是，先按优先级执行可注册bean的处理器，在按优先级执行针对beanfactory的处理器。</p>
</blockquote>
<blockquote>
<p>对springboot来说，这一步会进行注解bean definition的解析。流程如右面小框中所示，由ConfigurationClassPostProcessor触发、由ClassPathBeanDefinitionScanner解析并注册到bean factory。</p>
</blockquote>
<p><strong>第6步</strong>：按优先级顺序在beanfactory中注册bean的后缀处理器，bean后置处理器可以在bean初始化前、后执行处理；<br><strong>第7步</strong>：初始化消息源，消息源用来支持消息的国际化；<br><strong>第8步</strong>：初始化应用事件广播器。事件广播器用来向applicationListener通知各种应用产生的事件，是一个标准的观察者模式；<br><strong>第9步</strong>：是留给子类的扩展步骤，用来让特定的context子类初始化其他的bean；<br><strong>第10步</strong>：把实现了ApplicationListener的bean注册到事件广播器，并对广播器中的早期未广播事件进行通知；<br><strong>第11步</strong>：冻结所有bean描述信息的修改，实例化非延迟加载的单例bean；<br><strong>第12步</strong>：完成上下文的刷新工作，调用LifecycleProcessor的onFresh()方法以及发布ContextRefreshedEvent事件；<br><strong>第13步</strong>：在finally中，执行第十三步，重置公共的缓存，比如ReflectionUtils中的缓存、AnnotationUtils中的缓存等等；<br>至此，spring的context初始化完成。这里仅介绍了最主要的主流程，建议课后阅读源码来复习这个知识点，补全细节。</p>
<h2 id="Ⅵ、Spring中bean的生命周期"><a href="#Ⅵ、Spring中bean的生命周期" class="headerlink" title="Ⅵ、Spring中bean的生命周期"></a>Ⅵ、Spring中bean的生命周期</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141016-8d203.png" alt="Spring中bean的生命周期"></p>
<p><strong>面试中经常问到的bean的生命周期，先看绿色的部分，bean的创建过程</strong>：<br><strong>第1步</strong>：调用bean的构造方法创建bean；<br><strong>第2步</strong>：通过反射调用setter方法进行属性的依赖注入；<br><strong>第3步</strong>：如果实现BeanNameAware接口的话，会设置bean的name；<br><strong>第4步</strong>：如果实现了BeanFactoryAware，会把bean factory设置给bean；<br><strong>第5步</strong>：如果实现了ApplicationContextAware，会给bean设置ApplictionContext；<br><strong>第6步</strong>：如果实现了BeanPostProcessor接口，则执行前置处理方法；<br><strong>第7步</strong>：实现了InitializingBean接口的话，执行afterPropertiesSet方法；<br><strong>第8步</strong>：执行自定义的init方法；<br><strong>第9步</strong>：执行BeanPostProcessor接口的后置处理方法。<br>这时，就完成了bean的创建过程。<br>在使用完bean需要销毁时，会先执行DisposableBean接口的destroy方法，然后在执行自定义的destroy方法。<br>这部分也建议阅读源码加深理解。</p>
<h2 id="Ⅶ、Spring扩展接口"><a href="#Ⅶ、Spring扩展接口" class="headerlink" title="Ⅶ、Spring扩展接口"></a>Ⅶ、Spring扩展接口</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141018-3633a.png" alt="Spring扩展接口"></p>
<p>对spring进行定制化功能扩展时，可以选择如下一些扩展点：</p>
<h3 id="1-BeanFactoryPostProcessor"><a href="#1-BeanFactoryPostProcessor" class="headerlink" title="1.BeanFactoryPostProcessor"></a>1.BeanFactoryPostProcessor</h3><p>是beanFactory后置处理器，支持在bean factory标准初始化完成后，对bean factory进行一些额外处理。在讲context初始化流程时介绍过，这时所有的bean的描述信息已经加载完毕，但是还没有进行bean初始化。例如前面提到的PropertyPlaceholderConfigurer，就是在这个扩展点上对bean属性中的占位符进行替换。</p>
<h3 id="2-BeanDefinitionRegistryPostProcessor"><a href="#2-BeanDefinitionRegistryPostProcessor" class="headerlink" title="2.BeanDefinitionRegistryPostProcessor"></a>2.BeanDefinitionRegistryPostProcessor</h3><p>它扩展自BeanFactoryPostProcessor，在执行BeanFactoryPostProcessor的功能前，提供了可以添加bean definition的能力，允许在初始化一般bean前，注册额外的bean。例如可以在这里根据bean的scope创建一个新的代理bean。</p>
<h3 id="3-BeanPostProcessor"><a href="#3-BeanPostProcessor" class="headerlink" title="3.BeanPostProcessor"></a>3.BeanPostProcessor</h3><p>提供了在bean初始化之前和之后插入自定义逻辑的能力。与BeanFactoryPostProcessor的区别是处理的对象不同，BeanFactoryPostProcessor是对beanfactory进行处理，BeanPostProcessor是对bean进行处理。</p>
<blockquote>
<p>注：上面这三个扩展点，可以通过实现Ordered和PriorityOrdered接口来指定执行顺序。实现PriorityOrdered接口的processor会先于实现Ordered接口的执行。</p>
</blockquote>
<h3 id="4-ApplicationContextAware"><a href="#4-ApplicationContextAware" class="headerlink" title="4.ApplicationContextAware"></a>4.ApplicationContextAware</h3><p>可以获得ApplicationContext及其中的bean，当需要在代码中动态获取bean时，可以通过实现这个接口来实现。</p>
<h3 id="5-InitializingBean"><a href="#5-InitializingBean" class="headerlink" title="5.InitializingBean"></a>5.InitializingBean</h3><p>可以在bean初始化完成，所有属性设置完成后执行特定逻辑，例如对自动装配对属性进行验证等等。</p>
<h3 id="6-DisposableBean"><a href="#6-DisposableBean" class="headerlink" title="6.DisposableBean"></a>6.DisposableBean</h3><p>用于在bean被销毁前执行特定的逻辑，例如做一些回收工作等。</p>
<h3 id="7-ApplicationListener"><a href="#7-ApplicationListener" class="headerlink" title="7.ApplicationListener"></a>7.ApplicationListener</h3><p>用来监听spring的标准应用事件或者自定义事件。</p>
<h2 id="Ⅷ、springboot相关的知识点"><a href="#Ⅷ、springboot相关的知识点" class="headerlink" title="Ⅷ、springboot相关的知识点"></a>Ⅷ、springboot相关的知识点</h2><hr>
<p><img src="http://image.winrains.cn/2019/08/20190829141019-666c3.png" alt="img"></p>
<h3 id="1-启动流程"><a href="#1-启动流程" class="headerlink" title="1.启动流程"></a>1.启动流程</h3><p>主要步骤首先要配置environment，然后准备context上下文，包括执行applicationContext的后置处理、初始化initializer、通知listener处理contextPrepared和contextLoaded事件。最后执行refreshContext，也就是前面介绍过的AbstractApplicationContext类的refresh方法。</p>
<h3 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2.配置文件"></a>2.配置文件</h3><p>然后要知道在Spring Boot中有两种上下文，一种是bootstrap, 另外一种是application。<br>bootstrap是应用程序的父上下文，也就是说bootstrap会先于applicaton加载。bootstrap主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。bootstrap里面的属性会优先加载，默认也不能被本地相同配置覆盖。</p>
<h3 id="3-注解"><a href="#3-注解" class="headerlink" title="3.注解"></a>3.注解</h3><p><code>@SpringBootApplication</code>包含了<code>@ComponentScan</code>、<code>@EnableAutoConfiguration</code>、<code>@SpringBootConfiguration</code>三个注解<br>而<code>@SpringBootConfiguration</code>注解包含了<code>@Configuration</code>注解。也就是springboot的自动配置功能。<br><code>@Conditional</code>注解就是控制自动配置的生效条件的注解，例如bean或class存在、不存在时进行配置，当满足条件时进行配置等等。</p>
<h3 id="4-特色模块"><a href="#4-特色模块" class="headerlink" title="4.特色模块"></a>4.特色模块</h3><ul>
<li>starter是springboot提供的无缝集成功能的一种方式，使用某个功能时开发者不需要关注各种依赖库的处理，不需要具体的配置信息，由Spring Boot自动配置进行bean的创建。例如需要使用web功能时，只需要在依赖中引入spring-boot-starter-web即可。</li>
<li>actuator是用来对应用程序进行监视和管理，通过restful api请求来监管、审计、收集应用的运行情况。</li>
<li>devtools提供了一系列开发工具的支持，来提高开发效率。例如热部署能力等。</li>
<li>CLI就是命令行接口，是一个命令行工具，支持使用Groovy脚本，可以快速搭建spring原型项目。</li>
</ul>
<p>以上为Spring框架需要掌握的内容，前面提到的核心机制、核心流程，建议阅读源码加深理解。</p>
<blockquote>
<p>作者：Java_苏先生</p>
<p>来源：<a href="https://juejin.im/post/5cc175e2e51d456e2e656d7b" target="_blank" rel="noopener">https://juejin.im/post/5cc175e2e51d456e2e656d7b</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>BeanFactory和ApplicationContext的区别</title>
    <url>/2019/12/26/BeanFactory%E5%92%8CApplicationContext%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>接口 BeanFactory 和 ApplicationContext 都是用来从容器中获取 Spring beans 的，但是，他们二者有很大不同</p>
</blockquote>
<p>我看到过很多问 BeanFactory 和 ApplicationContext 不同点的问题，考虑到这，我应该使用前者还是后者从 Spring 容器中获取 beans 呢？请向下看</p>
<a id="more"></a>

<h2 id="什么是-Spring-Bean"><a href="#什么是-Spring-Bean" class="headerlink" title="什么是 Spring Bean"></a>什么是 Spring Bean</h2><p>这是一个非常简单而又很复杂的问题，通常来说，Spring beans 就是被 Spring 容器所管理的 Java 对象，来看一个简单的例子</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package com.zoltanraffai;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">String</span> message;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(<span class="keyword">String</span> message)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">this</span>.message  = message;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMessage</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      System.out.<span class="built_in">println</span>(<span class="string">"My Message : "</span> + message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在基于 XML 的配置中， beans.xml 为 Spring 容器管理 bean 提供元数据</p>
<h2 id="什么是-Spring-容器"><a href="#什么是-Spring-容器" class="headerlink" title="什么是 Spring 容器"></a>什么是 Spring 容器</h2><p>Spring 容器负责实例化，配置和装配 Spring beans，下面来看如何为 IoC 容器配置我们的 HelloWorld POJO</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version = "1.0" encoding = "UTF-8"?&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span> = <span class="string">"http://www.springframework.org/schema/beans"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span> = <span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span> = <span class="string">"http://www.springframework.org/schema/beans</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"helloWorld"</span> <span class="attr">class</span> = <span class="string">"com.zoltanraffai.HelloWorld"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"message"</span> <span class="attr">value</span> = <span class="string">"Hello World!"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<p>现在，它已经被 Spring 容器管理了，接下来的问题是：我们怎样获取它？</p>
<h2 id="BeanFactory-和-ApplicationContext-的不同点"><a href="#BeanFactory-和-ApplicationContext-的不同点" class="headerlink" title="BeanFactory 和 ApplicationContext 的不同点"></a>BeanFactory 和 ApplicationContext 的不同点</h2><h3 id="BeanFactory-接口"><a href="#BeanFactory-接口" class="headerlink" title="BeanFactory 接口"></a>BeanFactory 接口</h3><p>这是一个用来访问 Spring 容器的 root 接口，要访问 Spring 容器，我们将使用 Spring 依赖注入功能，使用 BeanFactory 接口和它的子接口 <strong>特性：</strong></p>
<ul>
<li>Bean 的实例化/串联 通常情况，BeanFactory 的实现是使用懒加载的方式，这意味着 beans 只有在我们通过 getBean() 方法直接调用它们时才进行实例化 实现 BeanFactory 最常用的 API 是 XMLBeanFactory 这里是如何通过 BeanFactory 获取一个 bean 的例子：</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">package com.zoltanraffai;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.<span class="keyword">factory</span>.InitializingBean;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.<span class="keyword">factory</span>.xml.XmlBeanFactory;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldApp</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      XmlBeanFactory <span class="keyword">factory</span> = <span class="keyword">new</span> XmlBeanFactory (<span class="keyword">new</span> ClassPathResource(<span class="string">"beans.xml"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">      HelloWorld obj = (HelloWorld) <span class="keyword">factory</span>.getBean(<span class="string">"helloWorld"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      obj.getMessage();</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="ApplicationContext-接口"><a href="#ApplicationContext-接口" class="headerlink" title="ApplicationContext 接口"></a>ApplicationContext 接口</h3><p>ApplicationContext 是 Spring 应用程序中的中央接口，用于向应用程序提供配置信息 它继承了 BeanFactory 接口，所以 ApplicationContext 包含 BeanFactory 的所有功能以及更多功能！它的主要功能是支持大型的业务应用的创建 <strong>特性：</strong></p>
<ul>
<li>Bean instantiation/wiring</li>
<li>Bean 的实例化/串联</li>
<li>自动的 BeanPostProcessor 注册</li>
<li>自动的 BeanFactoryPostProcessor 注册</li>
<li>方便的 MessageSource 访问（i18n）</li>
<li>ApplicationEvent 的发布 与 BeanFactory 懒加载的方式不同，它是预加载，所以，每一个 bean 都在 ApplicationContext 启动之后实例化 这里是 ApplicationContext 的使用例子：</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package com.zoltanraffai;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.xml.XmlBeanFactory;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldApp</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ApplicationContext context=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      HelloWorld obj = (HelloWorld) context.getBean(<span class="string">"helloWorld"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      obj.getMessage();</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>ApplicationContext 包含 BeanFactory 的所有特性，通常推荐使用前者。但是也有一些限制情形，比如移动应用内存消耗比较严苛，在那些情景中，使用更轻量级的 BeanFactory 是更合理的。然而，在大多数企业级的应用中，ApplicationContext 是你的首选。</p>
</blockquote>
<blockquote>
<p>作者：日拱一兵</p>
<p>来源：<a href="https://juejin.im/post/5d195530f265da1bb80c4560" target="_blank" rel="noopener">https://juejin.im/post/5d195530f265da1bb80c4560</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>面试中常问的Spring方面问题</title>
    <url>/2019/12/26/%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%B8%B8%E9%97%AE%E7%9A%84Spring%E6%96%B9%E9%9D%A2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>Spring Framework 现在几乎已成为 Java Web 开发的标配框架。那么，作为 Java 程序员，你对 Spring 的主要技术点又掌握了多少呢？不妨用本文的问题来检测一下。</p>
<a id="more"></a>

<h2 id="1、一般问题"><a href="#1、一般问题" class="headerlink" title="1、一般问题"></a>1、一般问题</h2><h3 id="1-1-不同版本的-Spring-Framework-有哪些主要功能？"><a href="#1-1-不同版本的-Spring-Framework-有哪些主要功能？" class="headerlink" title="1.1. 不同版本的 Spring Framework 有哪些主要功能？"></a>1.1. 不同版本的 Spring Framework 有哪些主要功能？</h3><p>VersionFeatureSpring 2.5发布于 2007 年。这是第一个支持注解的版本。Spring 3.0发布于 2009 年。它完全利用了 Java5 中的改进，并为 JEE6 提供了支持。Spring 4.0发布于 2013 年。这是第一个完全支持 JAVA8 的版本。</p>
<h3 id="1-2-什么是-Spring-Framework？"><a href="#1-2-什么是-Spring-Framework？" class="headerlink" title="1.2. 什么是 Spring Framework？"></a>1.2. 什么是 Spring Framework？</h3><ul>
<li>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</li>
<li>它是轻量级、松散耦合的。</li>
<li>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</li>
<li>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。</li>
</ul>
<h3 id="1-3-列举-Spring-Framework-的优点。"><a href="#1-3-列举-Spring-Framework-的优点。" class="headerlink" title="1.3. 列举 Spring Framework 的优点。"></a>1.3. 列举 Spring Framework 的优点。</h3><ul>
<li>由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。</li>
<li>Spring Framework 支持 POJO(Plain Old Java Object) 编程，从而具备持续集成和可测试性。</li>
<li>由于依赖注入和控制反转，JDBC 得以简化。</li>
<li>它是开源免费的。</li>
</ul>
<h3 id="1-4-Spring-Framework-有哪些不同的功能？"><a href="#1-4-Spring-Framework-有哪些不同的功能？" class="headerlink" title="1.4. Spring Framework 有哪些不同的功能？"></a>1.4. Spring Framework 有哪些不同的功能？</h3><ul>
<li><strong>轻量级</strong> - Spring 在代码量和透明度方面都很轻便。</li>
<li><strong>IOC</strong> - 控制反转</li>
<li><strong>AOP</strong> - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。</li>
<li><strong>容器</strong> - Spring 负责创建和管理对象（Bean）的生命周期和配置。</li>
<li><strong>MVC</strong> - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</li>
<li><strong>事务管理</strong> - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。</li>
<li><strong>JDBC 异常</strong> - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</li>
</ul>
<h3 id="1-5-Spring-Framework-中有多少个模块，它们分别是什么？"><a href="#1-5-Spring-Framework-中有多少个模块，它们分别是什么？" class="headerlink" title="1.5. Spring Framework 中有多少个模块，它们分别是什么？"></a>1.5. Spring Framework 中有多少个模块，它们分别是什么？</h3><p><img src="http://image.winrains.cn/2019/08/641e0-2c9c6daadf8154be46afbfd87d3e5824.jpeg-wh_651x-s_919540347.jpeg" alt="http://image.winrains.cn/2019/08/641e0-2c9c6daadf8154be46afbfd87d3e5824.jpeg-wh_651x-s_919540347.jpeg"></p>
<ul>
<li><p>Spring 核心容器</p>
<p> – 该层基本上是 Spring Framework 的核心。它包含以下模块：</p>
<ul>
<li>Spring Core</li>
<li>Spring Bean</li>
<li>SpEL (Spring Expression Language)</li>
<li>Spring Context</li>
</ul>
</li>
<li><p>数据访问/集成</p>
<p> – 该层提供与数据库交互的支持。它包含以下模块：</p>
<ul>
<li>JDBC (Java DataBase Connectivity)</li>
<li>ORM (Object Relational Mapping)</li>
<li>OXM (Object XML Mappers)</li>
<li>JMS (Java Messaging Service)</li>
<li>Transaction</li>
</ul>
</li>
<li><p>Web</p>
<p> – 该层提供了创建 Web 应用程序的支持。它包含以下模块：</p>
<ul>
<li>Web</li>
<li>Web – Servlet</li>
<li>Web – Socket</li>
<li>Web – Portlet</li>
</ul>
</li>
<li><p><strong>AOP</strong> – 该层支持面向切面编程</p>
</li>
<li><p><strong>Instrumentation</strong> – 该层为类检测和类加载器实现提供支持。</p>
</li>
<li><p><strong>Test</strong> – 该层为使用 JUnit 和 TestNG 进行测试提供支持。</p>
</li>
<li><p>几个杂项模块:</p>
<ul>
<li>Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。</li>
<li>Aspects – 该模块为与 AspectJ 的集成提供支持。</li>
</ul>
</li>
</ul>
<h3 id="1-6-什么是-Spring-配置文件？"><a href="#1-6-什么是-Spring-配置文件？" class="headerlink" title="1.6. 什么是 Spring 配置文件？"></a>1.6. 什么是 Spring 配置文件？</h3><p>Spring 配置文件是 XML 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。但是，XML 配置文件冗长且更加干净。如果没有正确规划和编写，那么在大项目中管理变得非常困难。</p>
<h3 id="1-7-Spring-应用程序有哪些不同组件？"><a href="#1-7-Spring-应用程序有哪些不同组件？" class="headerlink" title="1.7. Spring 应用程序有哪些不同组件？"></a>1.7. Spring 应用程序有哪些不同组件？</h3><p>Spring 应用一般有以下组件：</p>
<ul>
<li><strong>接口</strong> - 定义功能。</li>
<li><strong>Bean 类</strong> - 它包含属性，setter 和 getter 方法，函数等。</li>
<li><strong>Spring 面向切面编程（AOP）</strong> - 提供面向切面编程的功能。</li>
<li><strong>Bean 配置文件</strong> - 包含类的信息以及如何配置它们。</li>
<li><strong>用户程序</strong> - 它使用接口。</li>
</ul>
<h3 id="1-8-使用-Spring-有哪些方式？"><a href="#1-8-使用-Spring-有哪些方式？" class="headerlink" title="1.8. 使用 Spring 有哪些方式？"></a>1.8. 使用 Spring 有哪些方式？</h3><p>使用 Spring 有以下方式：</p>
<ul>
<li>作为一个成熟的 Spring Web 应用程序。</li>
<li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li>
<li>用于远程使用。</li>
<li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li>
</ul>
<h2 id="2、依赖注入（Ioc）"><a href="#2、依赖注入（Ioc）" class="headerlink" title="2、依赖注入（Ioc）"></a>2、依赖注入（Ioc）</h2><h3 id="2-1-什么是-Spring-IOC-容器？"><a href="#2-1-什么是-Spring-IOC-容器？" class="headerlink" title="2.1. 什么是 Spring IOC 容器？"></a>2.1. 什么是 Spring IOC 容器？</h3><p>Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过 XML，Java 注解或 Java 代码提供。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829143756-2ecdd.jpeg" alt="img"></p>
<h3 id="2-2-什么是依赖注入？"><a href="#2-2-什么是依赖注入？" class="headerlink" title="2.2. 什么是依赖注入？"></a>2.2. 什么是依赖注入？</h3><p>在依赖注入中，您不必创建对象，但必须描述如何创建它们。您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。由 IoC 容器将它们装配在一起。</p>
<h3 id="2-3-可以通过多少种方式完成依赖注入？"><a href="#2-3-可以通过多少种方式完成依赖注入？" class="headerlink" title="2.3. 可以通过多少种方式完成依赖注入？"></a>2.3. 可以通过多少种方式完成依赖注入？</h3><p>通常，依赖注入可以通过三种方式完成，即：</p>
<ul>
<li>构造函数注入</li>
<li>setter 注入</li>
<li>接口注入</li>
</ul>
<p>在 Spring Framework 中，仅使用构造函数和 setter 注入。</p>
<h3 id="2-4-区分构造函数注入和-setter-注入。"><a href="#2-4-区分构造函数注入和-setter-注入。" class="headerlink" title="2.4. 区分构造函数注入和 setter 注入。"></a>2.4. 区分构造函数注入和 setter 注入。</h3><p>构造函数注入setter 注入没有部分注入有部分注入不会覆盖 setter 属性会覆盖 setter 属性任意修改都会创建一个新实例任意修改不会创建一个新实例适用于设置很多属性适用于设置少量属性</p>
<h3 id="2-5-spring-中有多少种-IOC-容器？"><a href="#2-5-spring-中有多少种-IOC-容器？" class="headerlink" title="2.5. spring 中有多少种 IOC 容器？"></a>2.5. spring 中有多少种 IOC 容器？</h3><ul>
<li>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。</li>
<li>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。</li>
</ul>
<h3 id="2-6-区分-BeanFactory-和-ApplicationContext。"><a href="#2-6-区分-BeanFactory-和-ApplicationContext。" class="headerlink" title="2.6. 区分 BeanFactory 和 ApplicationContext。"></a>2.6. 区分 BeanFactory 和 ApplicationContext。</h3><p>BeanFactoryApplicationContext它使用懒加载它使用即时加载它使用语法显式提供资源对象它自己创建和管理资源对象不支持国际化支持国际化不支持基于依赖的注解支持基于依赖的注解</p>
<h3 id="2-7-列举-IoC-的一些好处。"><a href="#2-7-列举-IoC-的一些好处。" class="headerlink" title="2.7. 列举 IoC 的一些好处。"></a>2.7. 列举 IoC 的一些好处。</h3><p>IoC 的一些好处是：</p>
<ul>
<li>它将最小化应用程序中的代码量。</li>
<li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li>
<li>它以最小的影响和最少的侵入机制促进松耦合。</li>
<li>它支持即时的实例化和延迟加载服务。</li>
</ul>
<h3 id="2-8-Spring-IoC-的实现机制。"><a href="#2-8-Spring-IoC-的实现机制。" class="headerlink" title="2.8. Spring IoC 的实现机制。"></a>2.8. Spring IoC 的实现机制。</h3><p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。<br>示例：</p>
<p><img src="http://image.winrains.cn/2019/08/a4f36-223b876d39a7bd0d001271c445d56aa7.jpeg" alt="http://image.winrains.cn/2019/08/a4f36-223b876d39a7bd0d001271c445d56aa7.jpeg"></p>
<h2 id="3-Beans"><a href="#3-Beans" class="headerlink" title="3. Beans"></a>3. Beans</h2><h3 id="3-1-什么是-spring-bean？"><a href="#3-1-什么是-spring-bean？" class="headerlink" title="3.1. 什么是 spring bean？"></a>3.1. 什么是 spring bean？</h3><ul>
<li>它们是构成用户应用程序主干的对象。</li>
<li>Bean 由 Spring IoC 容器管理。</li>
<li>它们由 Spring IoC 容器实例化，配置，装配和管理。</li>
<li>Bean 是基于用户提供给容器的配置元数据创建。</li>
</ul>
<h3 id="3-2-spring-提供了哪些配置方式？"><a href="#3-2-spring-提供了哪些配置方式？" class="headerlink" title="3.2. spring 提供了哪些配置方式？"></a>3.2. spring 提供了哪些配置方式？</h3><ul>
<li><ul>
<li>基于 xml 配置</li>
</ul>
</li>
</ul>
<p>bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">"studentbean"</span> <span class="built_in">class</span>=<span class="string">"org.edureka.firstSpring.StudentBean"</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"name"</span> value=<span class="string">"Edureka"</span>&gt;&lt;/<span class="keyword">property</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;/bean&gt;</span></pre></td></tr></table></figure>

<ul>
<li>基于注解配置</li>
</ul>
<p>您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bean definitions go here --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<ul>
<li>基于 Java API 配置</li>
</ul>
<p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>
<ol>
<li>@Bean 注解扮演与 <bean /> 元素相同的角色。</li>
<li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="3-3-spring-支持集中-bean-scope？"><a href="#3-3-spring-支持集中-bean-scope？" class="headerlink" title="3.3. spring 支持集中 bean scope？"></a>3.3. spring 支持集中 bean scope？</h3><p>Spring bean 支持 5 种 scope：</p>
<ul>
<li><strong>Singleton</strong> - 每个 Spring IoC 容器仅有一个单实例。</li>
<li><strong>Prototype</strong> - 每次请求都会产生一个新的实例。</li>
<li><strong>Request</strong> - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。</li>
<li><strong>Session</strong> - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。</li>
<li><strong>Global-session</strong> - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。</li>
</ul>
<p>仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。</p>
<h3 id="3-4-spring-bean-容器的生命周期是什么样的？"><a href="#3-4-spring-bean-容器的生命周期是什么样的？" class="headerlink" title="3.4. spring bean 容器的生命周期是什么样的？"></a>3.4. spring bean 容器的生命周期是什么样的？</h3><p>spring bean 容器的生命周期流程如下：</p>
<ol>
<li>Spring 容器根据配置中的 bean 定义中实例化 bean。</li>
<li>Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。</li>
<li>如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。</li>
<li>如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。</li>
<li>如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。</li>
<li>如果为 bean 指定了 init 方法（<bean> 的 init-method 属性），那么将调用它。</li>
<li>最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。</li>
<li>如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。</li>
<li>如果为 bean 指定了 destroy 方法（<bean> 的 destroy-method 属性），那么将调用它。<img src="http://image.winrains.cn/2019/08/af3ef-41bc3485d75dc4aabe3d843ac2048790.jpeg" alt="http://image.winrains.cn/2019/08/af3ef-41bc3485d75dc4aabe3d843ac2048790.jpeg"></li>
</ol>
<h3 id="3-5-什么是-spring-的内部-bean？"><a href="#3-5-什么是-spring-的内部-bean？" class="headerlink" title="3.5. 什么是 spring 的内部 bean？"></a>3.5. 什么是 spring 的内部 bean？</h3><p>只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean。为了定义 bean，Spring 的基于 XML 的配置元数据在 <property> 或 <constructor-arg>中提供了 <bean> 元素的使用。内部 bean 总是匿名的，它们总是作为原型。<br>例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。<br>Student.java</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Student</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Person person;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//Setters and Getters</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Person</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> String name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> String address;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//Setters and Getters</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>bean.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“StudentBean</span>" <span class="attr">class</span>=<span class="string">"com.edureka.Student"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"person"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!--This is inner bean --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.edureka.Person"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">“Scott</span>"&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">value</span>=<span class="string">“Bangalore</span>"&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>

<h3 id="3-6-什么是-spring-装配？"><a href="#3-6-什么是-spring-装配？" class="headerlink" title="3.6. 什么是 spring 装配？"></a>3.6. 什么是 spring 装配？</h3><p>当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。 Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。</p>
<h3 id="3-7-自动装配有哪些方式？"><a href="#3-7-自动装配有哪些方式？" class="headerlink" title="3.7. 自动装配有哪些方式？"></a>3.7. 自动装配有哪些方式？</h3><p>Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。<br>自动装配的不同模式：</p>
<ul>
<li><strong>no</strong> - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li>
<li><strong>byName</strong> - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</li>
<li><strong>byType</strong> - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</li>
<li><strong>构造函数</strong> - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li>
<li><strong>autodetect</strong> - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li>
</ul>
<h3 id="3-8-自动装配有什么局限？"><a href="#3-8-自动装配有什么局限？" class="headerlink" title="3.8. 自动装配有什么局限？"></a>3.8. 自动装配有什么局限？</h3><ul>
<li>覆盖的可能性 - 您始终可以使用 <constructor-arg> 和 <property> 设置指定依赖项，这将覆盖自动装配。</li>
<li>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</li>
<li>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</li>
</ul>
<h2 id="4、注解"><a href="#4、注解" class="headerlink" title="4、注解"></a>4、注解</h2><h3 id="4-1-什么是基于注解的容器配置？"><a href="#4-1-什么是基于注解的容器配置？" class="headerlink" title="4.1. 什么是基于注解的容器配置？"></a>4.1. 什么是基于注解的容器配置？</h3><p>不使用 XML 来描述 bean 装配，开发人员通过在相关的类，方法或字段声明上使用注解将配置移动到组件类本身。它可以作为 XML 设置的替代方案。例如：<br>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>
<ul>
<li>@Bean 注解扮演与</li>
<li>元素相同的角色。</li>
<li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="4-2-如何在-spring-中启动注解装配？"><a href="#4-2-如何在-spring-中启动注解装配？" class="headerlink" title="4.2. 如何在 spring 中启动注解装配？"></a>4.2. 如何在 spring 中启动注解装配？</h3><p>默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置&lt;context：annotation-config /&gt; 元素在 Spring 配置文件中启用它。</p>
<h3 id="4-3-Component-Controller-Repository-Service-有何区别？"><a href="#4-3-Component-Controller-Repository-Service-有何区别？" class="headerlink" title="4.3. @Component, @Controller, @Repository, @Service 有何区别？"></a>4.3. @Component, @Controller, @Repository, @Service 有何区别？</h3><ul>
<li>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li>
<li>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</li>
<li>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</li>
<li>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li>
</ul>
<h3 id="4-4-Required-注解有什么用？"><a href="#4-4-Required-注解有什么用？" class="headerlink" title="4.4. @Required 注解有什么用？"></a>4.4. @Required 注解有什么用？</h3><p>@Required 应用于 bean 属性 setter 方法。此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性。如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。<br>示例：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Required</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name=name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">return</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="4-5-Autowired-注解有什么用？"><a href="#4-5-Autowired-注解有什么用？" class="headerlink" title="4.5. @Autowired 注解有什么用？"></a>4.5. @Autowired 注解有什么用？</h3><p>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是类型驱动的注入。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name=name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="4-6-Qualifier-注解有什么用？"><a href="#4-6-Qualifier-注解有什么用？" class="headerlink" title="4.6. @Qualifier 注解有什么用？"></a>4.6. @Qualifier 注解有什么用？</h3><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。<br>例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount 中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。<br>Employee.java</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>EmpAccount.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpAccount</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Employee emp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Qualifier</span>(emp1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showName</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Employee name : "</span> + emp.getName);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="4-7-RequestMapping-注解有什么用？"><a href="#4-7-RequestMapping-注解有什么用？" class="headerlink" title="4.7. @RequestMapping 注解有什么用？"></a>4.7. @RequestMapping 注解有什么用？</h3><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：</p>
<ul>
<li>类级别：映射请求的 URL</li>
<li>方法级别：映射 URL 以及 HTTP 请求方法</li>
</ul>
<h2 id="5、数据访问"><a href="#5、数据访问" class="headerlink" title="5、数据访问"></a>5、数据访问</h2><h3 id="5-1-spring-DAO-有什么用？"><a href="#5-1-spring-DAO-有什么用？" class="headerlink" title="5.1. spring DAO 有什么用？"></a>5.1. spring DAO 有什么用？</h3><p>Spring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p>
<h3 id="5-2-列举-Spring-DAO-抛出的异常。"><a href="#5-2-列举-Spring-DAO-抛出的异常。" class="headerlink" title="5.2. 列举 Spring DAO 抛出的异常。"></a>5.2. 列举 Spring DAO 抛出的异常。</h3><p><img src="http://image.winrains.cn/2019/08/caa7f-d6ebd1c162702b14bf48320d0ce48921.jpeg" alt="http://image.winrains.cn/2019/08/caa7f-d6ebd1c162702b14bf48320d0ce48921.jpeg"></p>
<h3 id="5-3-spring-JDBC-API-中存在哪些类？"><a href="#5-3-spring-JDBC-API-中存在哪些类？" class="headerlink" title="5.3. spring JDBC API 中存在哪些类？"></a>5.3. spring JDBC API 中存在哪些类？</h3><ul>
<li>JdbcTemplate</li>
<li>SimpleJdbcTemplate</li>
<li>NamedParameterJdbcTemplate</li>
<li>SimpleJdbcInsert</li>
<li>SimpleJdbcCall</li>
</ul>
<h3 id="5-4-使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#5-4-使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="5.4. 使用 Spring 访问 Hibernate 的方法有哪些？"></a>5.4. 使用 Spring 访问 Hibernate 的方法有哪些？</h3><p>我们可以通过两种方式使用 Spring 访问 Hibernate：</p>
<ol>
<li>使用 Hibernate 模板和回调进行控制反转</li>
<li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li>
</ol>
<h3 id="5-5-列举-spring-支持的事务管理类型"><a href="#5-5-列举-spring-支持的事务管理类型" class="headerlink" title="5.5. 列举 spring 支持的事务管理类型"></a>5.5. 列举 spring 支持的事务管理类型</h3><p>Spring 支持两种类型的事务管理：</p>
<ol>
<li>程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。</li>
<li>声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。</li>
</ol>
<h3 id="5-6-spring-支持哪些-ORM-框架？"><a href="#5-6-spring-支持哪些-ORM-框架？" class="headerlink" title="5.6. spring 支持哪些 ORM 框架？"></a>5.6. spring 支持哪些 ORM 框架？</h3><ul>
<li>Hibernate</li>
<li>iBatis</li>
<li>JPA</li>
<li>JDO</li>
<li>OJB</li>
</ul>
<h2 id="6、AOP"><a href="#6、AOP" class="headerlink" title="6、AOP"></a>6、AOP</h2><h3 id="6-1-什么是-AOP？"><a href="#6-1-什么是-AOP？" class="headerlink" title="6.1. 什么是 AOP？"></a>6.1. 什么是 AOP？</h3><p>AOP(Aspect-Oriented Programming), 即 <strong>面向切面编程</strong>, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角.<br>在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 <strong>Aspect(切面)</strong></p>
<h3 id="6-2-什么是-Aspect？"><a href="#6-2-什么是-Aspect？" class="headerlink" title="6.2. 什么是 Aspect？"></a>6.2. 什么是 Aspect？</h3><p>aspect 由 pointcount 和 advice 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.<br>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p>
<ol>
<li>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上</li>
<li>如何在 advice 中编写切面代码.</li>
</ol>
<p><strong>可以简单地认为, 使用 @Aspect 注解的类就是切面.</strong><br><img src="http://image.winrains.cn/2019/08/2a040-bc1af77af5b09fb02a8920292ff4f8e1.jpeg" alt="http://image.winrains.cn/2019/08/2a040-bc1af77af5b09fb02a8920292ff4f8e1.jpeg"></p>
<h3 id="6-3-什么是切点（JoinPoint）"><a href="#6-3-什么是切点（JoinPoint）" class="headerlink" title="6.3. 什么是切点（JoinPoint）"></a>6.3. 什么是切点（JoinPoint）</h3><p>程序运行中的一些时间点, 例如一个方法的执行, 或者是一个异常的处理.<br>在 Spring AOP 中, join point 总是方法的执行点。</p>
<h3 id="6-4-什么是通知（Advice）？"><a href="#6-4-什么是通知（Advice）？" class="headerlink" title="6.4. 什么是通知（Advice）？"></a>6.4. 什么是通知（Advice）？</h3><p>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice。Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的拦截器。</p>
<h3 id="6-5-有哪些类型的通知（Advice）？"><a href="#6-5-有哪些类型的通知（Advice）？" class="headerlink" title="6.5. 有哪些类型的通知（Advice）？"></a>6.5. 有哪些类型的通知（Advice）？</h3><ul>
<li><strong>Before</strong> - 这些类型的 Advice 在 joinpoint 方法之前执行，并使用 @Before 注解标记进行配置。</li>
<li><strong>After Returning</strong> - 这些类型的 Advice 在连接点方法正常执行后执行，并使用@AfterReturning 注解标记进行配置。</li>
<li><strong>After Throwing</strong> - 这些类型的 Advice 仅在 joinpoint 方法通过抛出异常退出并使用 @AfterThrowing 注解标记配置时执行。</li>
<li><strong>After (finally)</strong> - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @After 注解标记进行配置。</li>
<li><strong>Around</strong> - 这些类型的 Advice 在连接点之前和之后执行，并使用 @Around 注解标记进行配置。</li>
</ul>
<h3 id="6-6-指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处"><a href="#6-6-指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处" class="headerlink" title="6.6. 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处"></a>6.6. 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处</h3><p>concern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。<br>cross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。</p>
<h3 id="6-7-AOP-有哪些实现方式"><a href="#6-7-AOP-有哪些实现方式" class="headerlink" title="6.7. AOP 有哪些实现方式"></a>6.7. AOP 有哪些实现方式</h3><p>实现 AOP 的技术，主要分为两大类：</p>
<ul>
<li>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；</li>
<li>编译时编织（特殊编译器实现）</li>
<li>类加载时编织（特殊的类加载器实现）。</li>
<li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</li>
<li>JDK 动态代理</li>
<li>CGLIB</li>
</ul>
<h3 id="6-8-Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#6-8-Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="6.8. Spring AOP and AspectJ AOP 有什么区别？"></a>6.8. Spring AOP and AspectJ AOP 有什么区别？</h3><p>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。<br>Spring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。</p>
<h3 id="6-9-如何理解-Spring-中的代理？"><a href="#6-9-如何理解-Spring-中的代理？" class="headerlink" title="6.9. 如何理解 Spring 中的代理？"></a>6.9. 如何理解 Spring 中的代理？</h3><p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。<br>Advice + Target Object = Proxy</p>
<h3 id="6-10-什么是编织（Weaving）？"><a href="#6-10-什么是编织（Weaving）？" class="headerlink" title="6.10. 什么是编织（Weaving）？"></a>6.10. 什么是编织（Weaving）？</h3><p>为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）。在 Spring AOP 中，编织在运行时执行。请参考下图：<br><img src="http://image.winrains.cn/2019/08/dfa9f-801b410c598b76a9ac602373008c90e1.jpeg" alt="http://image.winrains.cn/2019/08/dfa9f-801b410c598b76a9ac602373008c90e1.jpeg"></p>
<h2 id="7、MVC"><a href="#7、MVC" class="headerlink" title="7、MVC"></a>7、MVC</h2><h3 id="7-1-Spring-MVC-框架有什么用？"><a href="#7-1-Spring-MVC-框架有什么用？" class="headerlink" title="7.1. Spring MVC 框架有什么用？"></a>7.1. Spring MVC 框架有什么用？</h3><p>Spring Web MVC 框架提供 <strong>模型-视图-控制器</strong> 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。 MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。</p>
<h3 id="7-2-描述一下-DispatcherServlet-的工作流程"><a href="#7-2-描述一下-DispatcherServlet-的工作流程" class="headerlink" title="7.2. 描述一下 DispatcherServlet 的工作流程"></a><strong>7.2. 描述一下 DispatcherServlet 的工作流程</strong></h3><p>DispatcherServlet 的工作流程可以用一幅图来说明：<br><img src="http://image.winrains.cn/2019/08/62864-0a2ce874e9e8b25d524d2fe7b4da8770.jpeg" alt="http://image.winrains.cn/2019/08/62864-0a2ce874e9e8b25d524d2fe7b4da8770.jpeg"></p>
<ol>
<li>向服务器发送 HTTP 请求，请求被前端控制器 DispatcherServlet 捕获。</li>
<li>DispatcherServlet 根据 <strong>-servlet.xml</strong> 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以HandlerExecutionChain 对象的形式返回。</li>
<li>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的 preHandler(…)方法）。</li>
<li>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：</li>
</ol>
<ul>
<li>HttpMessageConveter： 将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。</li>
<li>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等。</li>
<li>数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。</li>
<li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中。</li>
</ul>
<ol>
<li>Handler(Controller)执行完成后，向 DispatcherServlet 返回一个ModelAndView 对象；</li>
<li>根据返回的ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的ViewResolver)返回给DispatcherServlet。</li>
<li>ViewResolver 结合Model和View，来渲染视图。</li>
<li>视图负责将渲染结果返回给客户端。</li>
</ol>
<h3 id="7-3-介绍一下-WebApplicationContext"><a href="#7-3-介绍一下-WebApplicationContext" class="headerlink" title="7.3. 介绍一下 WebApplicationContext"></a><strong>7.3. 介绍一下 WebApplicationContext</strong></h3><p>WebApplicationContext 是 ApplicationContext 的扩展。它具有 Web 应用程序所需的一些额外功能。它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。</p>
<blockquote>
<p>作者：51CTO</p>
<p>来源：<a href="http://developer.51cto.com/art/201808/580655.htm" target="_blank" rel="noopener">http://developer.51cto.com/art/201808/580655.htm</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring使用注解式声明与使用切面</title>
    <url>/2019/12/26/Spring%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%A3%B0%E6%98%8E%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%88%87%E9%9D%A2/</url>
    <content><![CDATA[<h3 id="1-什么是面向切面"><a href="#1-什么是面向切面" class="headerlink" title="1 什么是面向切面"></a>1 什么是面向切面</h3><p>这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。<br>AOP是Spring提供的关键特性之一。AOP即面向切面编程，是OOP编程的有效补充。使用AOP技术，可以将一些系统性相关的编程工作，独立提取出来，独立实现，然后通过切面切入进系统。从而避免了在业务逻辑的代码中混入很多的系统相关的逻辑——比如权限管理，事物管理，日志记录等等。这些系统性的编程工作都可以独立编码实现，然后通过AOP技术切入进系统即可。从而达到了 将不同的关注点分离出来的效果。</p>
<a id="more"></a>

<h3 id="2-AOP术语"><a href="#2-AOP术语" class="headerlink" title="2 AOP术语"></a>2 AOP术语</h3><h4 id="2-1-通知（Advice）"><a href="#2-1-通知（Advice）" class="headerlink" title="2.1 通知（Advice）"></a>2.1 通知（Advice）</h4><p>切面必须要完成的工作即称为通知。通知定义了切面是什么以及什么时候实用。<br>spring切面可以实用的5种类型通知：</p>
<ul>
<li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li>
<li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li>
<li>返回通知（After-returning）：在目标方法成功执行之后调用通知；</li>
<li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li>
<li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li>
</ul>
<h4 id="2-2-连接点（Join-point）"><a href="#2-2-连接点（Join-point）" class="headerlink" title="2.2 连接点（Join point）"></a>2.2 连接点（Join point）</h4><p>我们的应用可能有数以千计的时机应用通知。这些时机被称 为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p>
<h4 id="2-3-切点（Poincut）"><a href="#2-3-切点（Poincut）" class="headerlink" title="2.3 切点（Poincut）"></a>2.3 切点（Poincut）</h4><p>切点定义了从何处切入。切点的定义会匹配通知所要织入的一个或多个连接点。通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p>
<h4 id="2-4-切面（Aspect）"><a href="#2-4-切面（Aspect）" class="headerlink" title="2.4 切面（Aspect）"></a>2.4 切面（Aspect）</h4><p>切面是通知和切点的结合。通知和切点共同定义了切面的全部内容—-它是什么，在何时和何处完成其功能。</p>
<h4 id="2-5-引入（Introduction）"><a href="#2-5-引入（Introduction）" class="headerlink" title="2.5 引入（Introduction）"></a>2.5 引入（Introduction）</h4><p>引入允许我们向现有的类添加新方法或属性。</p>
<h4 id="2-6-织入（Weaving）"><a href="#2-6-织入（Weaving）" class="headerlink" title="2.6 织入（Weaving）"></a>2.6 织入（Weaving）</h4><p>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。</p>
<ul>
<li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li>
<li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ 5的加载时织入（load-timeweaving，LTW）就支持以这种方式织入切面。</li>
<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。</li>
</ul>
<h3 id="3-Spring对切面的支持"><a href="#3-Spring对切面的支持" class="headerlink" title="3 Spring对切面的支持"></a>3 Spring对切面的支持</h3><p>Spring提供了4种类型的AOP支持：</p>
<ul>
<li>基于代理的经典Spring AOP；</li>
<li>纯POJO切面；</li>
<li>@AspectJ注解驱动的切面；</li>
<li>注入式AspectJ切面（适用于Spring各版本）。</li>
</ul>
<p>前三种都是Spring AOP实现的变体，Spring AOP构建在动态代理基础之上，因此，Spring对AOP的支持局限于方法拦截。</p>
<h3 id="4-认识切点"><a href="#4-认识切点" class="headerlink" title="4 认识切点"></a>4 认识切点</h3><p>在Spring AOP中，要使用AspectJ的切点表达式语言来定义切点。<br>首先定义一个接口来作为切点：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> interface Performance &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="type">void</span> <span class="keyword">perform</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>假设我们想编写Performance的perform()方法触发的通 知。下面的表达式能够设置当perform()方法执行时触发通知的调用。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">execution(* com.wtj.springlearn.aop.Performance.<span class="keyword">perform</span>(..))</span></pre></td></tr></table></figure>

<p>execution()指示器选择Performance的perform()方法。方法表达式以“*”号开始，表明了不关心方法返回值的类型。然后指定了全限定类名和方法名。对于方法参数列表，使用两个点号（..）表明切点要选择任意的perform()方法，无论该方法的入参是什么。<br>如果我们需要设置切点匹配com.wtj.springlearn.aop包，可以使用within()来限定匹配。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">execution(* com.wtj.springlearn.aop.Performance.<span class="keyword">perform</span>(..)） &amp;&amp; <span class="keyword">within</span>(com.wtj.springlearn.aop.*)</span></pre></td></tr></table></figure>

<p>表示com.wtj.springlearn.aop包下任意类的方法被调用时。<br>使用“&amp;&amp;”操作符把execution()和within()指示器连接在一起形成与（and）关系（切点必须匹配所有的指示器）。类似地，我们可以使用“||”操作符来标识或（or）关系，而使用“!”操作符来标识非（not）操作。<br>因为“&amp;”在XML中有特殊含义，所以在Spring的XML配置里面描述切点时，我们可以使用and来代替“&amp;&amp;”。同样，or和not可以分别用来代替“||”和“!”。<br>还可以使用bean的ID来标识bean。bean()使用bean ID或bean名称作为参数来限制切点只匹配特定的bean。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">execution(* com.wtj.springlearn.aop.Performance.<span class="keyword">perform</span>(..)) &amp;&amp; bean(<span class="string">'book'</span>)</span></pre></td></tr></table></figure>

<p>这里表示执行perform方法时通知，但是只限于bean的ID为book。</p>
<h3 id="5-通过注解创建切面"><a href="#5-通过注解创建切面" class="headerlink" title="5 通过注解创建切面"></a>5 通过注解创建切面</h3><blockquote>
<p>本篇主要介绍注解方式的切面定义方式</p>
</blockquote>
<p>通过@Aspect进行标注，表示该Audience不仅是一个POJO还是一个切面。类中的方法表示了切面的具体行为。<br>Spring提供了五种注解来定义通知时间：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829144905-e7439.png" alt="img"></p>
<p>首先创建一个切面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//表演前 手机静音</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.wtj.springlearn.aop.Performance.perform(..))"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhone</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"silence Cell Phone"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//表演成功-clap</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"execution(** com.wtj.springlearn.aop.Performance.perform(..))"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clap</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"clap clap clap"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//表演失败-退款</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"execution(** com.wtj.springlearn.aop.Performance.perform(..))"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refund</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"refund refund refund"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Performance的实现类：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@Component</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> PerformanceImpl implements Performance &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">public</span> <span class="type">void</span> <span class="keyword">perform</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("the perform is good");</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>最后还需要开启自动代理功能</strong>，通过JavaConfig进行配置，使用<code>@EnableAspectJAutoProxy</code>标签开启。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@EnableAspectJAutoProxy</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@ComponentScan</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class AudienceConfig &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Audience audience()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">Audience</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>最后通过一个简单的测试用例就可以来验证了。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.<span class="keyword">class</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">@ContextConfiguration(classes = AudienceConfig.<span class="keyword">class</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> PerformanceTest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Performance performance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Test</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">public</span> <span class="type">void</span> perTest()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        performance.<span class="keyword">perform</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">silence Cell Phone</span></pre></td></tr><tr><td class="code"><pre><span class="line">the <span class="keyword">perform</span> <span class="keyword">is</span> good</span></pre></td></tr><tr><td class="code"><pre><span class="line">clap clap clap</span></pre></td></tr></table></figure>

<h4 id="5-1-PointCut声明切点"><a href="#5-1-PointCut声明切点" class="headerlink" title="5.1 @PointCut声明切点"></a>5.1 @PointCut声明切点</h4><p>你会发现上面切面的方法中，切点的声明都是一样的，这种情况下可以使用<code>@Pointcut</code>注解来定义切点。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.wtj.springlearn.aop.Performance.perform(..))"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">per</span><span class="params">()</span></span>&#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表演前 手机静音</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"per()"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">silenceCellPhone</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"silence Cell Phone"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>per()方法本身并不重要，该方法只是一个标识，供@PointCut注解依附。</p>
<h4 id="5-2-环绕通知"><a href="#5-2-环绕通知" class="headerlink" title="5.2 环绕通知"></a>5.2 环绕通知</h4><p>环绕通知是最为强大的通知类型。它能够让你所编写的逻辑将被通知的目标方法完全包装起来。实际上就像在一个通知方法中同时编写前置通知和后置通知。<br>重写Audience切面，使用环绕通知替代之前多个不同的前置通知和后置通知。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@Around("per()")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> watch(ProceedingJoinPoint <span class="type">point</span>) throws Throwable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    try&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("silence Cell Phone");</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="type">point</span>.proceed();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("clap clap clap");</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;catch (<span class="keyword">Exception</span> e)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("refund refund refund");</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>首先注意到的可能是它接受ProceedingJoinPoint作为参数。这个对象是必须要有的，因为你要在通知中通过它来调用被通知的方法。通知方法中可以做任何的事情，当要将控制权交给被通知的方法时，它需要调用ProceedingJoinPoint的proceed()方法。<br>如果不调proceed()这个方法的话，那么你的通知实际上会阻塞对被通知方法的调用。同样的，你也可以调用多次。</p>
<h4 id="5-3-向通知中传入参数"><a href="#5-3-向通知中传入参数" class="headerlink" title="5.3 向通知中传入参数"></a>5.3 向通知中传入参数</h4><p>上面我们创建的切面都很简单，没有任何参数。那么切面能访问和使用传递给被通知方法的参数么？<br>Performance中新增方法：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="keyword">perform</span>(String <span class="type">name</span>);</span></pre></td></tr></table></figure>

<p>实现类：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> <span class="keyword">perform</span>(String <span class="type">name</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("下面请 "+<span class="type">name</span>+" 开始他的表演");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>修改Audience中的切点和切面</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@Pointcut("execution(* com.wtj.springlearn.aop.Performance.perform(String)) &amp;&amp; args(name)")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> per(String <span class="type">name</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Around("per(name)")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> toWatch(ProceedingJoinPoint <span class="type">point</span>, String <span class="type">name</span>) throws Throwable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    try &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="type">point</span>.proceed();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span> + " 上场啦");</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span> + " 演出结束");</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; catch (<span class="keyword">Exception</span> e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("refund refund refund");</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>表达式<code>args(name)</code>限定符，它表示传递给perform(String name)方法的String类型参数也会传到通知中去，参数名与切点中的参数名相同。<code>perform(String)</code>指明了传入参数的类型。<br>然后在<code>@Around</code>注解中指明切点与参数名，这样就完成了参数转移。<br>最后修改一下测试用例就完成了</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@Test</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> perTest()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    performance.<span class="keyword">perform</span>("渣渣辉");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>打印输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下面请 渣渣辉 开始他的表演</span></pre></td></tr><tr><td class="code"><pre><span class="line">渣渣辉 上场啦</span></pre></td></tr><tr><td class="code"><pre><span class="line">渣渣辉 演出结束</span></pre></td></tr></table></figure>

<h4 id="5-4-通过注解-DeclareParents引入新方法"><a href="#5-4-通过注解-DeclareParents引入新方法" class="headerlink" title="5.4 通过注解@DeclareParents引入新方法"></a>5.4 通过注解@DeclareParents引入新方法</h4><p>如果我们想在一个类上新增方法，通常情况下我们会怎么做呢？最简单的办法就是在此目标类上增加此方法，但是如果原目标类非常复杂，动一发而牵全身。并且有些时候我们是没有目标类的源码的，哪这个时候怎么办呢？<br>我们可以为需要添加的方法建立一个类，然后建一个代理类，同时代理该类和目标类。用一个图来表示</p>
<p><img src="http://image.winrains.cn/2019/08/20190829144906-93ff8.png" alt="img"></p>
<p>当引入接口的方法被调用时，代理会把此调用委托给实现了新接口的某个其他对象。<br>还是上面的例子，假设我们需要让表演者跳起来。<br>新建Jump接口以及实现类：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">Jump</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">void</span> duJump();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">JumpImpl</span> <span class="symbol">implements</span> <span class="symbol">Jump</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> duJump() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"do Jump"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后我们代理两个类：</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@Aspect</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> JumpIntroducer &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">@DeclareParents</span>(value = <span class="string">"com.wtj.springlearn.aop.Performance+"</span>,defaultImpl = JumpImpl.<span class="keyword">class</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jump jump;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>@DeclareParents注解由三部分组成：</p>
<ul>
<li>value属性指定了哪种类型的bean要引入该接口。在本例中，也就是所有实现Performance的类型。（标记符后面的加号表示是Performance的所有子类型，而不是Performance本 身。）</li>
<li>defaultImpl属性指定了为引入功能提供实现的类。</li>
<li>@DeclareParents注解所标注的静态属性指明了要引入了接 口。</li>
</ul>
<p><strong>通过配置将JumpIntroducer声明</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@ComponentScan</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@EnableAspectJAutoProxy</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class JumpConfig &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public JumpIntroducer jumpIntroducer()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">JumpIntroducer</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>或者你也可以在JumpIntroducer类上加入<code>@Component</code>注解，就可以不用声明bean了。<br>最后通过测试用例进行测试：</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@RunWith</span>(SpringJUnit4ClassRunner.<span class="keyword">class</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@ContextConfiguration</span>(classes = JumpConfig.<span class="keyword">class</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> PerformanceTest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> Performance performance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">@Test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> perTest()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//类型转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Jump jump = (Jump) performance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        jump.duJump();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> Jump</span></pre></td></tr></table></figure>

<blockquote>
<p>作者：爱西考的王同学</p>
<p>来源：<a href="https://juejin.im/post/5d394d4ce51d4550a629b35a" target="_blank" rel="noopener">https://juejin.im/post/5d394d4ce51d4550a629b35a</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud介绍</title>
    <url>/2019/12/26/Spring-Cloud%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><blockquote>
<p>只有光头才能变强</p>
</blockquote>
<p>认识我的朋友可能都知道我这阵子去实习啦，去的公司说是用SpringCloud(但我觉得使用的力度并不大啊<del>)…<br>所以，这篇主要来讲讲SpringCloud的一些基础的知识。(我就是现学现卖了，主要当做我学习SpringCloud的笔记吧！)当然了，我的水平是有限的，可能会有一些理解错的的概念/知识点，还请大家不吝在评论区指正啊</del></p>
<a id="more"></a>

<p>SpringCloud GitHub Demo(看完文章的同学可以自己练手玩玩)：</p>
<ul>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FZhongFuCheng3y%2Fmsc-Demo">github.com/ZhongFuChen…</a></li>
</ul>
<p>项目结构图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151036-c9caa.png" alt="img"></p>
<h1 id="二、集群-分布式-微服务-SOA是什么？"><a href="#二、集群-分布式-微服务-SOA是什么？" class="headerlink" title="二、集群/分布式/微服务/SOA是什么？"></a>二、集群/分布式/微服务/SOA是什么？</h1><p>像我这种技术小白，看到这些词(<code>集群/分布式/微服务/SOA</code>)的时候，感觉就是遥不可及的(高大尚的技术！！)。就好像刚学Java面向对象的时候，在论坛上翻阅资料的时候，无意看到”面向切面编程”，也认为这是遥不可及的(高大尚的技术！！)。<br>但真正接触到”面向切面编程”的时候，发现原来就是如此啊，也没什么大不了的。只不过当时被它的名字给唬住了…<br>不知道各位在刚接触这些名字<code>集群/分布式/微服务/SOA</code>的时候，有没有被唬住了呢？？</p>
<ul>
<li>下面我就<strong>简单</strong>说说这些名词的意思</li>
</ul>
<h2 id="2-1什么是集群"><a href="#2-1什么是集群" class="headerlink" title="2.1什么是集群"></a>2.1什么是集群</h2><p>以下内容来源维基百科：</p>
<blockquote>
<p>计算机集群简称集群是一种计算机系统，它通过一组松散集成的计算机软件和/或硬件连接起来高度紧密地协作完成计算工作。在某种意义上，他们可以被看作是一台计算机。集群系统中的单个计算机通常称为节点，通常通过局域网连接，但也有其它的可能连接方式。集群计算机通常用来改进单个计算机的计算速度和/或可靠性。一般情况下集群计算机比单个计算机，比如工作站或超级计算机性能价格比要高得多</p>
</blockquote>
<p>集群技术特点：</p>
<ul>
<li>通过<strong>多台计算机完成同一个工作</strong>，达到更高的效率。</li>
<li><strong>两机或多机内容、工作过程等完全一样</strong>。如果一台死机，另一台可以起作用。</li>
</ul>
<p>在维基百科上说得也挺明白的了，我来举个<strong>例子</strong>吧。</p>
<ul>
<li><p>小周在公司写Java程序，但公司业务在发展，一个Java开发者可能</p>
<p>忙不过来</p>
<p>，小周有的时候也得</p>
<p>请个假呀</p>
<p>。于是请了3y过去</p>
<p>一起做Java开发</p>
<p>。平时小周和3y就写Java程序，但3y可能</p>
<p>有事</p>
<p>要回学校一趟。没事，公司还有小周做Java开发呢，公司开发还能继续运作。</p>
<ul>
<li>3y跟小周<strong>都是做Java开发</strong>。</li>
<li>3y来了，小周的工作可以<strong>分担</strong>一些。</li>
<li>3y请假了，还有小周在呢。</li>
</ul>
</li>
</ul>
<p>我写了一个910便利网发布到服务器去了，现在越来越多的人访问了，访问有点慢，怎么办？？？很简单，(只有充钱才能变强)，加配置吧(加cpu，加内存)。升级完配置之后，访问人数越来越多，于是发现又不禁用啦，在这台机器上加配置已经解决不了了，怎么办？？？很简单，(只有充钱才能变强)，我<strong>再买一台服务器，将910便利网也发布到新买的这台服务器上去</strong>。<br>特点：</p>
<ul>
<li>这两台服务器都是运行<strong>同一个系统</strong>—&gt;910便利网</li>
</ul>
<p>好处：</p>
<ul>
<li>本来只有一台机器处理访问，现在有两台机器处理访问了，<strong>分担了压力</strong>。</li>
<li>如果其中一台忘记缴费了，暂时用不了了。没关系，还有另一台可以用呢。</li>
</ul>
<p><strong>集群</strong>：同一个业务，部署在多个服务器上(不同的服务器运行同样的代码，干同一件事)</p>
<h2 id="2-2什么是分布式"><a href="#2-2什么是分布式" class="headerlink" title="2.2什么是分布式"></a>2.2什么是分布式</h2><p>以下内容来源维基百科：</p>
<blockquote>
<p>分布式系统是一组计算机，通过网络相互连接传递消息与通信后并协调它们的行为而形成的系统。<strong>组件之间彼此进行交互以实现一个共同的目标</strong>。</p>
</blockquote>
<p>我也来举个例子来说明一下吧：</p>
<ul>
<li><p>现在公司有小周和3y一起做Java开发，做Java开发一般jQuery，AJAX都能写一点，所以这些活都由我们来干。可是呢，3y对前端不是很熟，有的时候调试半天都调不出来。老板认为3y是真的菜！于是让小周</p>
<p>专门来处理前端</p>
<p>的事情。这样3y就高兴了，可以</p>
<p>专心写自己的Java</p>
<p>，前端就</p>
<p>专门</p>
<p>交由小周负责了。于是，小周和3y就变成了</p>
<p>协作开发</p>
<p>。</p>
<ul>
<li>3y对前端不熟(能写出来)，但在调试的时候可能会花费很多时间</li>
<li>小周来<strong>专门做前端</strong>的事，3y可以<strong>专心写自己的Java程序</strong>了。</li>
<li>都是为了项目正常运行以及迭代。</li>
</ul>
</li>
</ul>
<p>我的910便利网已经部署到两台服务器去了，但是越来越多的人去访问。现在也逐渐承受不住啦。那现在怎么办啊？？那继续充钱变强？？作为一个理智的我，肯定得想想是哪里有问题。现在910便利网的模块有好几个，全都丢在同一个Tomcat里边。<br>其实有些模块的访问是很低的(比如后台管理)，那我可不可以这样做：将每个模块<strong>抽取独立</strong>出来，访问量大的模块用好的服务器装着，没啥人访问的模块用差的服务器装着。这样的好处是：一、<strong>资源合理利用了</strong>(没人访问的模块用性能差的服务器，访问量大的模块<strong>单独提升性能</strong>就好了)。二、<strong>耦合度降低了</strong>：每个模块独立出来，各干各的事(专业的人做专业的事)，便于扩展<br>特点：</p>
<ul>
<li>将910便利网的<strong>功能拆分，模块之间独立</strong>，在使用的时候再将这些<strong>独立的模块组合起来</strong>就是一个系统了。</li>
</ul>
<p>好处：</p>
<ul>
<li>模块之间独立，各做各的事，<strong>便于扩展，复用性高</strong></li>
<li><strong>高吞吐量</strong>。某个任务需要一个机器运行10个小时，将该任务用10台机器的分布式跑(将这个任务拆分成10个小任务)，可能2个小时就跑完了</li>
</ul>
<p><strong>分布式</strong>：一个业务分拆多个子业务，部署在不同的服务器上(不同的服务器，运行不同的代码，为了同一个目的)</p>
<h2 id="2-3集群-分布式"><a href="#2-3集群-分布式" class="headerlink" title="2.3集群/分布式"></a>2.3集群/分布式</h2><p>集群和分布式并不冲突，可以有<strong>分布式集群</strong><br>现在3y的公司规模变大了，有5个小伙子写Java，4个小伙子写前端，2个小伙子做测试，1个小伙子做DBA。</p>
<ul>
<li>Java，前端，测试，DBA的关系看作是分布式的</li>
<li>5个Java看作是集群的(前端，测试同理)…</li>
</ul>
<h2 id="2-4分布式-微服务-SOA"><a href="#2-4分布式-微服务-SOA" class="headerlink" title="2.4分布式/微服务/SOA"></a>2.4分布式/微服务/SOA</h2><p>其实我认为分布式/微服务/SOA这三个概念是差不多的，了解了其中的一个，然后将自己的理解往上面套就好了。<strong>没必要细分每个的具体概念</strong>~~(当然了，我很期待有大佬可以在评论区留言说下自己的看法哈)<br>参考资料：</p>
<ul>
<li>分布式与集群的区别是什么？<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F20004877">www.zhihu.com/question/20…</a></li>
<li>分布式、集群、微服务、SOA 之间的区别<a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fheatdeath%2Farticle%2Fdetails%2F79038795">blog.csdn.net/heatdeath/a…</a></li>
</ul>
<h1 id="三、CAP理论"><a href="#三、CAP理论" class="headerlink" title="三、CAP理论"></a>三、CAP理论</h1><p>从上面所讲的分布式概念我们已经知道，分布式简单理解就是：<strong>一个业务分拆多个子业务，部署在不同的服务器上</strong></p>
<ul>
<li>一般来说，一个子业务我们称为<strong>节点</strong>。</li>
</ul>
<p>如果你接触过一些分布式的基础概念，那肯定会听过CAP这个理论。就比如说：你学了MySQL的InnoDB存储引擎相关知识，你肯定听过ACID！<br>首先，我们来看一下CAP分别代表的是什么意思：</p>
<ul>
<li>C：数据一致性(consistency)<ul>
<li><strong>所有</strong>节点拥有数据的最新版本</li>
</ul>
</li>
<li>A：可用性(availability)<ul>
<li>数据具备高可用性</li>
</ul>
</li>
<li>P：分区容错性(partition-tolerance)<ul>
<li><strong>容忍网络出现分区</strong>，分区之间网络不可达。</li>
</ul>
</li>
</ul>
<p>下面有三个节点(它们是集群的)，此时三个节点都能够相互通信：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151037-626c9.png" alt="img"></p>
<p>由于我们的系统是分布式的，节点之间的通信是通过网络来进行的。<strong>只要是分布式系统</strong>，那很有可能会出现一种情况：因为一些<strong>故障</strong>，使得有些<strong>节点之间不连通</strong>了，整个网络就分成了<strong>几块区域</strong>。</p>
<ul>
<li>数据就散布在了这些不连通的区域中，这就叫<strong>分区</strong></li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829151038-3bfa5.png" alt="img"></p>
<p>现在出现了网络分区后，此时有一个请求过来了，想要注册一个账户。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151038-1e806.png" alt="img"></p>
<p>此时我们<strong>节点一和节点三是不可通信的</strong>，这就有了抉择：</p>
<ul>
<li><p>如果</p>
<p>允许</p>
<p>当前用户注册一个账户，此时注册的记录数据只会在节点一和节点二或者节点二和节点三</p>
<p>同步</p>
<p>，因为节点一和节点三的记录不能同步的。</p>
<ul>
<li>这种情况其实就是选择了可用性(availability)，抛弃了数据一致性(consistency)</li>
</ul>
</li>
<li><p>如果</p>
<p>不允许</p>
<p>当前用户注册一个账户(就是要</p>
<p>等到</p>
<p>节点一和节点三恢复通信)。节点一和节点三一旦恢复通信，我们就可以</p>
<p>保证节点拥有的数据是最新版本</p>
<p>。</p>
<ul>
<li>这种情况其实就是抛弃了可用性(availability)，选择了数据一致性(consistency)</li>
</ul>
</li>
</ul>
<h2 id="3-1再次梳理一下CAP理论"><a href="#3-1再次梳理一下CAP理论" class="headerlink" title="3.1再次梳理一下CAP理论"></a>3.1再次梳理一下CAP理论</h2><p>一般我们说的分布式系统，P：分区容错性(partition-tolerance)这个是<strong>必需</strong>的，这是客观存在的。<br>CAP是无法完全兼顾的，从上面的例子也可以看出，我们可以选AP，也可以选CP。但是，要<strong>注意的是</strong>：不是说选了AP，C就完全抛弃了。不是说选了CP，A就完全抛弃了！<br>在CAP理论中，<strong>C所表示的一致性是强一致性</strong>(每个节点的数据都是最新版本)，其实一致性还有其他级别的：</p>
<ul>
<li>弱一致性：弱一致性是相对于强一致性而言，它不保证总能得到最新的值；</li>
<li>最终一致性(eventual consistency)：放宽对时间的要求，在被调完成操作响应后的某个时间点，被调多个节点的数据最终达成一致</li>
</ul>
<p>可用性的值域可以定义成<strong>0到100%的连续区间</strong>。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151039-cf259.png" alt="img"></p>
<p>所以，<strong>CAP理论定义的其实是在容忍网络分区的条件下，“强一致性”和“极致可用性”无法同时达到</strong>。<br>参考资料：</p>
<ul>
<li>CAP理论中的P到底是个什么意思？<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F54105974">www.zhihu.com/question/54…</a></li>
<li>浅谈分布式系统的基本问题：可用性与一致性：<a href="https://link.juejin.im?target=https%3A%2F%2Fm.aliyun.com%2Fyunqi%2Farticles%2F2709">m.aliyun.com/yunqi/artic…</a></li>
<li>分布式系统的CAP理论：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F666">www.hollischuang.com/archives/66…</a></li>
<li>为什么CAP理论在舍弃P的情况下，可以有完美的CA？<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F285878189">www.zhihu.com/question/28…</a></li>
<li>不懂点CAP理论，你好意思说你是做分布式的吗？<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.yunweipai.com%2Farchives%2F8432.html">www.yunweipai.com/archives/84…</a></li>
</ul>
<p>扩展阅读：</p>
<ul>
<li>浅谈分布式事务：<a href="https://link.juejin.im?target=https%3A%2F%2Fm.aliyun.com%2Fyunqi%2Farticles%2F230242">m.aliyun.com/yunqi/artic…</a></li>
</ul>
<h1 id="四、SpringCloud就是这么简单"><a href="#四、SpringCloud就是这么简单" class="headerlink" title="四、SpringCloud就是这么简单"></a>四、SpringCloud就是这么简单</h1><p>相信大家读到这里，对分布式/微服务已经有一定的了解了，其实单从概念来说，是非常容易理解的。只是很可能被它的名字给唬住了。<br>下面我就来讲讲SpringCloud<strong>最基础</strong>的知识~</p>
<h2 id="4-1为什么需要SpringCloud？"><a href="#4-1为什么需要SpringCloud？" class="headerlink" title="4.1为什么需要SpringCloud？"></a>4.1为什么需要SpringCloud？</h2><p>前面也讲了，从分布式/微服务的角度而言：就是把我们一<strong>大</strong>的项目，<strong>分解</strong>成多个<strong>小</strong>的模块。这些小的模块组合起来，完成功能。<br>举个可能不太恰当的例子(现实可能不会这么拆分，但意思到位就好了)：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151040-e70c0.png" alt="img"></p>
<p>拆分出多个模块以后，就会出现<strong>各种各样</strong>的问题，而SpringCloud提供了<strong>一整套</strong>的解决方案！</p>
<ul>
<li>注：这些模块是<strong>独立</strong>成一个子系统的(不同主机)。</li>
</ul>
<p>SpringCloud的<strong>基础功能</strong>：</p>
<ul>
<li>服务治理： Spring Cloud Eureka</li>
<li>客户端负载均衡： Spring Cloud Ribbon</li>
<li>服务容错保护： Spring Cloud Hystrix</li>
<li>声明式服务调用： Spring Cloud Feign</li>
<li>API网关服务：Spring Cloud Zuul</li>
<li>分布式配置中心： Spring Cloud Config</li>
</ul>
<p>SpringCloud的高级功能(本文不讲)：</p>
<ul>
<li>消息总线： Spring Cloud Bus</li>
<li>消息驱动的微服务： Spring Cloud Stream</li>
<li>分布式服务跟踪： Spring Cloud Sleuth</li>
</ul>
<h1 id="五、引出Eureka"><a href="#五、引出Eureka" class="headerlink" title="五、引出Eureka"></a>五、引出Eureka</h1><p>那会出现什么问题呢？？首当其冲的就是子系统之间的<strong>通讯</strong>问题。子系统与子系统之间不是在同一个环境下，那就需要<strong>远程调用</strong>。远程调用可能就会想到httpClient，WebService等等这些技术来实现。<br>既然是远程调用，就必须知道ip地址，我们可能有以下的场景。</p>
<ul>
<li>功能实现一：A服务需要调用B服务<ul>
<li>在A服务的代码里面调用B服务，<strong>显式通过IP地址调用</strong>：<code>http://123.123.123.123:8888/java3y/3</code></li>
</ul>
</li>
<li>功能实现二：A服务调用B服务，B服务调用C服务，C服务调用D服务<ul>
<li>在A服务的代码里面调用B服务，显式通过IP地址调用：<code>http://123.123.123.123:8888/java3y/3</code>，(同样地)B-&gt;C，C-&gt;D</li>
</ul>
</li>
<li>功能实现三：D服务调用B服务，B服务调用C服务<ul>
<li>在D服务的代码里面调用B服务，显式通过IP地址调用：<code>http://123.123.123.123:8888/java3y/3</code>，(同样地)B-&gt;C</li>
</ul>
</li>
<li>…..等等等等</li>
</ul>
<p>万一，我们<strong>B服务的IP地址变了</strong>，想想会出现什么问题：A服务,D服务(等等)需要<strong>手动更新</strong>B服务的地址</p>
<ul>
<li>在服务多的情况下，手动来维护这些静态配置就是噩梦！</li>
</ul>
<blockquote>
<p>为了解决微服务架构中的<strong>服务实例维护问题(ip地址)</strong>， 产生了大量的<strong>服务治理</strong>框架和产品。 这些框架和产品的实现都围绕着服务注册与服务发现机制来完成对微服务应用实例的<strong>自动化管理</strong>。</p>
</blockquote>
<p>在SpringCloud中我们的服务治理框架一般使用的就是Eureka。<br>我们的问题：</p>
<ul>
<li>现在有A、B、C、D四个服务，它们之间会互相调用(而且IP地址很可能会发生变化)，一旦某个服务的IP地址变了，那服务中的代码要跟着变，手动维护这些静态配置(IP)非常麻烦！</li>
</ul>
<p>Eureka是这样解决上面所说的情况的：</p>
<ul>
<li>创建一个E服务，将A、B、C、D四个服务的信息都<strong>注册</strong>到E服务上，E服务维护这些已经注册进来的信息</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829151040-c277f.png" alt="img"></p>
<p>A、B、C、D四个服务都可以<strong>拿到</strong>Eureka(服务E)那份<strong>注册清单</strong>。A、B、C、D四个服务互相调用不再通过具体的IP地址，而是<strong>通过服务名来调用</strong>！</p>
<ul>
<li>拿到注册清单—&gt;注册清单上有服务名—&gt;自然就能够拿到服务具体的位置了(IP)。</li>
<li>其实简单来说就是：代码中通过<strong>服务名找到对应的IP地址</strong>(IP地址会变，但服务名一般不会变)</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829151042-3b61f.png" alt="img"></p>
<h2 id="5-1Eureka细节"><a href="#5-1Eureka细节" class="headerlink" title="5.1Eureka细节"></a>5.1Eureka细节</h2><p>Eureka专门用于给其他服务注册的称为Eureka Server(服务注册中心)，其余注册到Eureka Server的服务称为Eureka Client。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151042-81de6.png" alt="img"></p>
<p>在Eureka Server一般我们会这样配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">register-with-eureka:</span> <span class="literal">false</span>     <span class="comment">#false表示不向注册中心注册自己。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">fetch-registry:</span> <span class="literal">false</span>     <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span></pre></td></tr></table></figure>

<p>Eureka Client<strong>分为服务提供者和服务消费者</strong>。</p>
<ul>
<li>但很可能，某服务<strong>既是服务提供者又是服务消费者</strong>。</li>
</ul>
<p>如果在网上看到SpringCloud的<strong>某个服务配置没有”注册”到Eureka-Server也不用过于惊讶</strong>(但是它是可以获取Eureka服务清单的)</p>
<ul>
<li>很可能只是作者把该服务认作为<strong>单纯的服务消费者</strong>，单纯的服务消费者无需对外提供服务，也就无须注册到Eureka中了</li>
</ul>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="symbol">eureka:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="symbol">client:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    register-<span class="keyword">with</span>-<span class="symbol">eureka:</span> <span class="literal">false</span>  <span class="comment"># 当前微服务不注册到eureka中(消费端)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    service-<span class="symbol">url:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="symbol">defaultZone:</span> <span class="symbol">http:</span>/<span class="regexp">/eureka7001.com:7001/eureka</span><span class="regexp">/,http:/</span><span class="regexp">/eureka7002.com:7002/eureka</span><span class="regexp">/,http:/</span><span class="regexp">/eureka7003.com:7003/eureka</span><span class="regexp">/</span></span></pre></td></tr></table></figure>

<p>下面是Eureka的治理机制：</p>
<ul>
<li>服务提供者<ul>
<li><strong>服务注册：启动的时候会通过发送REST请求的方式将自己注册到Eureka Server上</strong>，同时带上了自身服务的一些元数据信息。</li>
<li><strong>服务续约：</strong>在注册完服务之后，<strong>服务提供者会维护一个心跳</strong>用来持续告诉Eureka Server: “我还活着 ” 、</li>
<li><strong>服务下线：当服务实例进行正常的关闭操作时，它会触发一个服务下线的REST请求</strong>给Eureka Server, 告诉服务注册中心：“我要下线了 ”。</li>
</ul>
</li>
<li>服务消费者<ul>
<li><strong>获取服务：当我们启动服务消费者</strong>的时候，它会发送一个REST请求给服务注册中心，来获取上面注册的服务清单</li>
<li><strong>服务调用：服务消费者在获取服务清单后，通过服务名</strong>可以获得具体提供服务的实例名和该实例的元数据信息。在进行服务调用的时候，<strong>优先访问同处一个Zone中的服务提供方</strong>。</li>
</ul>
</li>
<li>Eureka Server(服务注册中心)：<ul>
<li><strong>失效剔除：</strong>默认每隔一段时间（默认为60秒） 将当前清单中超时（默认为90秒）<strong>没有续约的服务剔除出去</strong>。</li>
<li><strong>自我保护：</strong>。EurekaServer 在运行期间，会统计心跳失败的比例在15分钟之内是否低于85%(通常由于网络不稳定导致)。 Eureka Server会将当前的<strong>实例注册信息保护起来</strong>， 让这些实例不会过期，尽可能<strong>保护这些注册信息</strong>。</li>
</ul>
</li>
</ul>
<p>最后，我们就有了这张图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151043-cdb68.png" alt="img"></p>
<p>举个例子：</p>
<ul>
<li>3y跟女朋友去东站的东方宝泰逛街，但不知道东方宝泰有什么好玩的。于是就去<strong>物业</strong>搜了一下<strong>东方宝泰商户清单</strong>，发现一楼有优衣库，二楼有星巴克，三楼有麦当劳。</li>
<li>在优衣库旁边，有新开张的KFC，在墙壁打上了很大的标识“欢迎KFC<strong>入驻</strong>东方宝泰”。</li>
<li>商家们需要定时<strong>交物业费</strong>给物业。</li>
<li><strong>物业维持</strong>东方宝泰的稳定性。如果某个商家不想在东方宝泰运营了，告诉了物业。物业自然就会将其在东方宝泰商户清单去除。</li>
</ul>
<p>优秀博文：</p>
<ul>
<li>Spring Cloud Eureka详解：<a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fsunhuiliang85%2Farticle%2Fdetails%2F76222517">blog.csdn.net/sunhuiliang…</a></li>
<li>《Spring Cloud Netflix》 – 服务注册和服务发现-Eureka 的使用：<a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F26472547">zhuanlan.zhihu.com/p/26472547</a></li>
<li>微服务架构：Eureka参数配置项详解：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Ffangfuhai%2Fp%2F7070325.html">www.cnblogs.com/fangfuhai/p…</a></li>
</ul>
<h1 id="六、引出RestTemplate和Ribbon"><a href="#六、引出RestTemplate和Ribbon" class="headerlink" title="六、引出RestTemplate和Ribbon"></a>六、引出RestTemplate和Ribbon</h1><p>通过Eureka服务治理框架，我们可以通过服务名来获取具体的服务实例的位置了(IP)。一般在使用SpringCloud的时候<strong>不需要自己手动创建</strong>HttpClient来进行远程调用。<br>可以使用Spring封装好的<strong>RestTemplate</strong>工具类，使用起来很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统的方式，直接显示写死IP是不好的！</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// private static final String REST_URL_PREFIX = "http://localhost:8001";</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 服务实例名</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REST_URL_PREFIX = <span class="string">"http://MICROSERVICECLOUD-DEPT"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 使用 使用restTemplate访问restful接口非常的简单粗暴无脑。 (url, requestMap,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * ResponseBean.class)这三个参数分别代表 REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/consumer/dept/add"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Dept dept)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> restTemplate.postForObject(REST_URL_PREFIX + <span class="string">"/dept/add"</span>, dept, Boolean<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>为了实现服务的<strong>高可用</strong>，我们可以将<strong>服务提供者集群</strong>。比如说，现在一个秒杀系统设计出来了，准备上线了。在11月11号时为了能够支持高并发，我们开多台机器来支持并发量。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151044-6ca5a.png" alt="img"></p>
<p>现在想要这三个秒杀系统<strong>合理摊分</strong>用户的请求(专业来说就是负载均衡)，可能你会想到nginx。<br>其实SpringCloud也支持的负载均衡功能，只不过它是<strong>客户端的负载均衡</strong>，这个功能实现就是Ribbon！<br>负载均衡又区分了两种类型：</p>
<ul>
<li>客户端负载均衡(Ribbon)<ul>
<li>服务实例的<strong>清单在客户端</strong>，客户端进行负载均衡算法分配。</li>
<li>(从上面的知识我们已经知道了：客户端可以从Eureka Server中得到一份服务清单，在发送请求时通过负载均衡算法，<strong>在多个服务器之间选择一个进行访问</strong>)</li>
</ul>
</li>
<li>服务端负载均衡(Nginx)<ul>
<li>服务实例的<strong>清单在服务端</strong>，服务器进行负载均衡算法分配</li>
</ul>
</li>
</ul>
<p>所以，我们的图可以画成这样：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151045-bac78.png" alt="img"></p>
<h2 id="6-1Ribbon细节"><a href="#6-1Ribbon细节" class="headerlink" title="6.1Ribbon细节"></a>6.1Ribbon细节</h2><p>Ribbon是支持负载均衡，默认的负载均衡策略是轮询，我们也是可以根据自己实际的需求自定义负载均衡策略的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelfRule</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">myRule</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// return new RandomRule();// Ribbon默认是轮询，我自定义为随机</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// return new RoundRobinRule();// Ribbon默认是轮询，我自定义为随机</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule_ZY();<span class="comment">// 我自定义为每台机器5次</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>实现起来也很简单：继承AbstractLoadBalancerRule类，重写<code>public Server choose(ILoadBalancer lb, Object key)</code>即可。<br>SpringCloud 在CAP理论是选择了AP的，在Ribbon中还可以配置<strong>重试机制</strong>的(有兴趣的同学可以去搜搜)~<br>举个例子：</p>
<ul>
<li>3y跟女朋友过了几个月，又去东方宝泰了。由于记性不好，又去物业那弄了一份东方宝泰商户清单。</li>
<li>这次看到东方宝泰又开了一间麦当劳，一间在二楼，一间在三楼。原来生意太好了，为了能提高用户体验，在二楼<strong>多开了一间麦当劳</strong>。</li>
<li>这时，3y问女朋友：“去哪间麦当劳比较好？要不我们抛硬币决定？”3y女朋友说：”你是不是傻，肯定哪间近去哪间啊“</li>
</ul>
<p>优秀博文：</p>
<ul>
<li>撸一撸Spring Cloud Ribbon的原理-负载均衡策略：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fkongxianghai%2Fp%2F8477781.html">www.cnblogs.com/kongxiangha…</a></li>
</ul>
<h1 id="七、引出Hystrix"><a href="#七、引出Hystrix" class="headerlink" title="七、引出Hystrix"></a>七、引出Hystrix</h1><p>到目前为止，我们的服务看起来好像挺好的了：能够根据服务名来远程调用其他的服务，可以实现客户端的负载均衡。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151046-2109a.png" alt="img"></p>
<p>但是，如果我们在<strong>调用多个远程服务时，某个服务出现延迟</strong>，会怎么样？？</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151047-90a16.jpeg" alt="img"></p>
<p>在<strong>高并发</strong>的情况下，由于单个服务的延迟，可能导致<strong>所有的请求都处于延迟状态</strong>，甚至在几秒钟就使服务处于负载饱和的状态，资源耗尽，直到不可用，最终导致这个分布式系统都不可用，这就是“雪崩”。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151047-1ef55.jpeg" alt="img"></p>
<p>针对上述问题， Spring Cloud Hystrix实现了<strong>断路器、线程隔离</strong>等一系列服务保护功能。</p>
<ul>
<li>Fallback(失败快速返回)：当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝）， <strong>向调用方返回一个错误响应， 而不是长时间的等待</strong>。这样就不会使得线程因调用故障服务被长时间占用不释放，<strong>避免</strong>了故障在分布式系统中的<strong>蔓延</strong>。</li>
<li>资源/依赖隔离(线程池隔离)：它会为<strong>每一个依赖服务创建一个独立的线程池</strong>，这样就算某个依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响， 而<strong>不会拖慢其他的依赖服务</strong>。</li>
</ul>
<p>Hystrix提供几个熔断关键参数：<code>滑动窗口大小（20）、 熔断器开关间隔（5s）、错误率（50%）</code></p>
<ul>
<li>每当20个请求中，有50%失败时，熔断器就会打开，此时再调用此服务，将会<strong>直接返回失败</strong>，不再调远程服务。</li>
<li>直到5s钟之后，重新检测该触发条件，<strong>判断是否把熔断器关闭，或者继续打开</strong>。</li>
</ul>
<p>Hystrix还有请求合并、请求缓存这样强大的功能，在此我就不具体说明了，有兴趣的同学可继续深入学习~</p>
<h2 id="7-1Hystrix仪表盘"><a href="#7-1Hystrix仪表盘" class="headerlink" title="7.1Hystrix仪表盘"></a>7.1Hystrix仪表盘</h2><p>Hystrix仪表盘：它主要用来<strong>实时监控Hystrix的各项指标信息</strong>。通过Hystrix Dashboard反馈的实时信息，可以帮助我们快速发现系统中存在的问题，从而及时地采取应对措施。<br>启动时的页面：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151048-d634c.png" alt="img"></p>
<p><strong>监控单服务</strong>的页面：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151049-6494b.png" alt="img"></p>
<p>我们现在的服务是这样的：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151050-b2592.png" alt="img"></p>
<p>除了可以开启单个实例的监控页面之外，还有一个监控端点 <code>/turbine.stream</code>是对<strong>集群</strong>使用的。 从端点的命名中，可以引入Turbine, 通过它来<strong>汇集监控信息</strong>，并将聚合后的信息提供给 HystrixDashboard 来<strong>集中展示和监控</strong>。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151051-75606.png" alt="img"></p>
<p>举个例子：</p>
<ul>
<li>3y和女朋友决定去万达玩，去到万达的停车场发现在负一层已经大大写上“负一层已停满，请下负二层，负二层空余停车位还有100个！”</li>
<li>这时，3y就跟女朋友说：“万达停车场是做得挺好的，如果它没有<strong>直接</strong>告知我负一层已满，可能我就去负一层找位置了，要是一堆人跑去负一层但都找不到车位的话，恐怕就塞死了”。3y接着说：“看停车位的状态也做得不错，在停车位上头有一个<strong>感应(监控)</strong>，如果是红色就代表已被停了，如果是绿色就说明停车位是空的”。</li>
<li>3y女朋友不屑的说：“你话是真的多”</li>
</ul>
<p>参考资料：</p>
<ul>
<li>Hystrix ，为什么说它是每个系统不可或缺的开源框架？<a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F34304136">zhuanlan.zhihu.com/p/34304136</a></li>
<li>深入理解Hystrix之文档翻译：<a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F28523060">zhuanlan.zhihu.com/p/28523060</a></li>
<li>谈谈我对服务熔断、服务降级的理解：<a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fguwei9111986%2Farticle%2Fdetails%2F51649240">blog.csdn.net/guwei911198…</a></li>
<li>Hystrix几篇文章《青芒》：<a href="https://link.juejin.im?target=https%3A%2F%2Fsegmentfault.com%2Fu%2Fyedge%2Farticles">segmentfault.com/u/yedge/art…</a></li>
</ul>
<h1 id="八、引出Feign"><a href="#八、引出Feign" class="headerlink" title="八、引出Feign"></a>八、引出Feign</h1><p>上面已经介绍了Ribbon和Hystrix了，可以发现的是：他俩作为基础工具类框架<strong>广泛地应用</strong>在各个微服务的实现中。我们会发现对这两个框架的<strong>使用几乎是同时出现</strong>的。<br>为了<strong>简化</strong>我们的开发，Spring Cloud Feign出现了！它基于 Netflix Feign 实现，<strong>整合</strong>了 Spring Cloud Ribbon 与 Spring Cloud Hystrix, 除了整合这两者的强大功能之外，它还提 供了<strong>声明式的服务调用</strong>(不再通过RestTemplate)。</p>
<blockquote>
<p>Feign是一种声明式、模板化的HTTP客户端。在Spring Cloud中使用Feign, 我们可以做到使用HTTP请求远程服务时能与调用本地方法一样的编码体验，开发者完全感知不到这是远程方法，更感知不到这是个HTTP请求。</p>
</blockquote>
<p>下面就简单看看Feign是怎么优雅地实现远程调用的：<br>服务绑定：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// value ---&gt;指定调用哪个服务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// fallbackFactory---&gt;熔断器的降级提示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@FeignClient</span>(value = <span class="string">"MICROSERVICECLOUD-DEPT"</span>, fallbackFactory = DeptClientServiceFallbackFactory.class)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public interface DeptClientService &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 采用Feign我们可以使用SpringMVC的注解来对服务进行绑定！</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@RequestMapping</span>(value = <span class="string">"/dept/get/&#123;id&#125;"</span>, method = RequestMethod.GET)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Dept get(<span class="variable">@PathVariable</span>(<span class="string">"id"</span>) long id);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@RequestMapping</span>(value = <span class="string">"/dept/list"</span>, method = RequestMethod.GET)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public List&lt;Dept&gt; list();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@RequestMapping</span>(value = <span class="string">"/dept/add"</span>, method = RequestMethod.POST)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public boolean add(Dept dept);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Feign中使用熔断器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Feign中使用断路器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 这里主要是处理异常出错的情况(降级/熔断时服务不可用，fallback就会找到这里来)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 不要忘记添加，不要忘记添加</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptClientServiceFallbackFactory</span> <span class="keyword">implements</span> <span class="title">FallbackFactory</span>&lt;<span class="title">DeptClientService</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> DeptClientService <span class="title">create</span><span class="params">(Throwable throwable)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DeptClientService() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">public</span> Dept <span class="title">get</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Dept().setDeptno(id).setDname(<span class="string">"该ID："</span> + id + <span class="string">"没有没有对应的信息,Consumer客户端提供的降级信息,此刻服务Provider已经关闭"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        .setDb_source(<span class="string">"no this database in MySQL"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">public</span> List&lt;Dept&gt; <span class="title">list</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Dept dept)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>调用：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151052-9a6e4.png" alt="img"></p>
<h1 id="九、引出Zuul"><a href="#九、引出Zuul" class="headerlink" title="九、引出Zuul"></a>九、引出Zuul</h1><p>基于上面的学习，我们现在的架构很可能会设计成这样：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151052-a2fbe.png" alt="img"></p>
<p>这样的架构会有两个比较麻烦的问题：</p>
<ol>
<li><strong>路由规则与服务实例的维护间题</strong>：外层的负载均衡(nginx)需要<strong>维护</strong>所有的服务实例清单(图上的OpenService)</li>
<li><strong>签名校验、 登录校验冗余问题</strong>：为了保证对外服务的安全性， 我们在服务端实现的微服务接口，往往都会有一定的<strong>权限校验机制</strong>，但我们的服务是独立的，我们<strong>不得不在这些应用中都实现这样一套校验逻辑</strong>，这就会造成校验逻辑的冗余。</li>
</ol>
<p>还是画个图来理解一下吧：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151053-1d37f.png" alt="img"></p>
<p>每个服务都有自己的IP地址，Nginx想要正确请求转发到服务上，就必须<strong>维护着每个服务实例的地址</strong>！</p>
<ul>
<li>更是灾难的是：这些服务实例的IP地址还有可能会变，服务之间的划分也很可能会变。</li>
</ul>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//123.123.123.123</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//123.123.123.124</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//123.123.123.125</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//123.123.123.126</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//123.123.123.127</span></span></pre></td></tr></table></figure>

<p>购物车和订单模块都需要用户登录了才可以正常访问，基于现在的架构，只能在<strong>购物车和订单模块都编写校验逻辑</strong>，这无疑是冗余的代码。<br>为了解决上面这些常见的架构问题，<strong>API网关</strong>的概念应运而生。在SpringCloud中了提供了基于Netfl ix Zuul实现的API网关组件<strong>Spring Cloud Zuul</strong>。<br>Spring Cloud Zuul是这样解决上述两个问题的：</p>
<ul>
<li>SpringCloud Zuul通过与SpringCloud Eureka进行整合，将自身注册为Eureka服务治理下的应用，同时从Eureka中获得了所有其他微服务的实例信息。<strong>外层调用都必须通过API网关</strong>，使得<strong>将维护服务实例的工作交给了服务治理框架自动完成</strong>。</li>
<li>在API网关服务上进行统一调用来<strong>对微服务接口做前置过滤</strong>，以实现对微服务接口的<strong>拦截和校验</strong>。</li>
</ul>
<p>Zuul天生就拥有线程隔离和断路器的自我保护功能，以及对服务调用的客户端负载均衡功能。也就是说：<strong>Zuul也是支持Hystrix和Ribbon</strong>。<br>关于Zuul还有很多知识点(由于篇幅问题，这里我就不细说了)：</p>
<ul>
<li>路由匹配(动态路由)</li>
<li>过滤器实现(动态过滤器)</li>
<li>默认会过滤掉Cookie与敏感的HTTP头信息(额外配置)</li>
</ul>
<h2 id="9-1可能对Zuul的疑问"><a href="#9-1可能对Zuul的疑问" class="headerlink" title="9.1可能对Zuul的疑问"></a>9.1可能对Zuul的疑问</h2><p>Zuul支持Ribbon和Hystrix，也能够实现客户端的负载均衡。我们的Feign不也是实现客户端的负载均衡和Hystrix的吗？既然Zuul已经能够实现了，那我们的Feign还有必要吗？</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151054-d6685.png" alt="img"></p>
<p>或者可以这样理解：</p>
<ul>
<li>zuul是对外暴露的唯一接口相当于路由的是controller的请求，而Ribbonhe和Fegin路由了service的请求</li>
<li>zuul做最外层请求的负载均衡 ，而Ribbon和Fegin做的是系统内部各个微服务的service的调用的负载均衡</li>
</ul>
<p>有了Zuul，还需要Nginx吗？他俩可以一起使用吗？</p>
<ul>
<li>我的理解：Zuul和Nginx是可以一起使用的(毕竟我们的Zuul也是可以搭成集群来实现高可用的)，要不要一起使用得看架构的复杂度了(业务)<del>~</del></li>
</ul>
<p>参考资料：</p>
<ul>
<li>微服务与API网关（上）: 为什么需要API网关？：<a href="https://link.juejin.im?target=http%3A%2F%2Fblog.didispace.com%2Fhzf-ms-apigateway-1%2F">blog.didispace.com/hzf-ms-apig…</a></li>
<li>谈谈 API 网关：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fb52a2773e75f">www.jianshu.com/p/b52a2773e…</a></li>
<li>谈谈微服务中的 API 网关（API Gateway）：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fsavorboard%2Fp%2Fapi-gateway.html">www.cnblogs.com/savorboard/…</a></li>
<li>API网关性能比较：NGINX vs. ZUUL vs. Spring Cloud Gateway ：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.360doc.com%2Fcontent%2F18%2F0208%2F05%2F46368139_728502763.shtml">www.360doc.com/content/18/…</a></li>
<li>谈API网关的背景、架构以及落地方案：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.infoq.com%2Fcn%2Fnews%2F2016%2F07%2FAPI-background-architecture-floo">www.infoq.com/cn/news/201…</a></li>
<li>zuul和nginx：<a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F37385481">zhuanlan.zhihu.com/p/37385481</a></li>
</ul>
<h1 id="十、引出SpringCloud-Config"><a href="#十、引出SpringCloud-Config" class="headerlink" title="十、引出SpringCloud Config"></a>十、引出SpringCloud Config</h1><p>随着业务的扩展，我们的服务会越来越多，越来越多。每个服务都有自己的配置文件。<br>既然是配置文件，给我们配置的东西，那<strong>难免会有些改动</strong>的。<br>比如我们的Demo中，每个服务都写上<strong>相同</strong>的配置文件。万一我们有一天，配置文件中的密码需要更换了，那就得<strong>三个都要重新更改</strong>。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829151055-7a0e8.png" alt="img"></p>
<blockquote>
<p>在分布式系统中，某一个基础服务信息变更，都<strong>很可能</strong>会引起一系列的更新和重启</p>
</blockquote>
<p>Spring Cloud Config项目是一个解决分布式系统的配置管理方案。它包含了Client和Server两个部分，<strong>server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，client通过接口获取数据、并依据此数据初始化自己的应用</strong>。</p>
<ul>
<li>简单来说，使用Spring Cloud Config就是将配置文件放到<strong>统一的位置管理</strong>(比如GitHub)，客户端通过接口去获取这些配置文件。</li>
<li>在GitHub上修改了某个配置文件，应用加载的就是修改后的配置文件。</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829151056-71b18.png" alt="img"></p>
<p>SpringCloud Config其他的知识：</p>
<ul>
<li>在SpringCloud Config的服务端， 对于配置仓库的默认<strong>实现采用了Git</strong>，我们也可以配置SVN。</li>
<li>配置文件内的信息<strong>加密和解密</strong></li>
<li>修改了配置文件，希望不用重启来<strong>动态刷新配置</strong>，配合Spring Cloud Bus 使用~</li>
</ul>
<p>使用SpringCloud Config可能的疑问：application.yml和 bootstrap.yml区别</p>
<ul>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2FBlogNetSpace%2Fp%2F8469033.html">www.cnblogs.com/BlogNetSpac…</a></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要写了SpringCloud的基础知识，希望大家看完能有所帮助~<br>SpringCloud的资料也很多，我整理一些我认为比较好，想要深入的同学不妨看看下边的资源<del>~</del><br>SpringCloud系列文章参考资料：</p>
<ul>
<li>史上最简单的 SpringCloud 教程 | 终章<a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fforezp%2Farticle%2Fdetails%2F70148833">blog.csdn.net/forezp/arti…</a></li>
<li>Spring Cloud基础教程《程序员DD》<a href="https://link.juejin.im?target=http%3A%2F%2Fblog.didispace.com%2FSpring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%2F">blog.didispace.com/Spring-Clou…</a></li>
<li>Spring Cloud 系列文章《纯洁的微笑》：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.ityouknow.com%2Fspring-cloud.html">www.ityouknow.com/spring-clou…</a></li>
<li>SpringCloud系列文章：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fwoshimrf%2Ftag%2FSpringCloud%2F">www.cnblogs.com/woshimrf/ta…</a></li>
<li>SpringCloud系列文章《狂小白》：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fhuangjuncong%2Ftag%2FSpringCloud%2F">www.cnblogs.com/huangjuncon…</a></li>
<li>SpringCloud官方文档：<a href="https://link.juejin.im?target=http%3A%2F%2Fprojects.spring.io%2Fspring-cloud%2F">projects.spring.io/spring-clou…</a></li>
<li>Spring Cloud 中文文档：<a href="https://link.juejin.im?target=https%3A%2F%2Fspringcloud.cc%2Fspring-cloud-dalston.html%23_appendix_compendium_of_configuration_properties">springcloud.cc/spring-clou…</a></li>
</ul>
<p>参考书籍：</p>
<ul>
<li>《SpringCloud 微服务实战》</li>
</ul>
<p>SpringCloud GitHub Demo(看完文章的同学可以自己练手玩玩，写好了ReadMe了)：</p>
<ul>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FZhongFuCheng3y%2Fmsc-Demo">github.com/ZhongFuChen…</a></li>
</ul>
<blockquote>
<p>作者：Java3y</p>
<p>来源：<a href="https://juejin.im/post/5b83466b6fb9a019b421cecc" target="_blank" rel="noopener">https://juejin.im/post/5b83466b6fb9a019b421cecc</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring Cloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringMVC 源码解析</title>
    <url>/2019/12/26/SpringMVC-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>年初面试时接触到一道面试题，在聊到SpringMVC时提到了SpringMVC的开发者为何要设计父子容器呢，又或者说是父子容器的设计有什么更实际的作用呢？ 首先要理解对于一个web应用，当期部署在web容器上时，容器会为其提供一个全局上下文环境ServletContext，这个上下文环境将为后续的Spring提供宿主环境。</p>
<a id="more"></a>

<h2 id="SpringMVC工作流程"><a href="#SpringMVC工作流程" class="headerlink" title="SpringMVC工作流程"></a>SpringMVC工作流程</h2><p><img src="http://image.winrains.cn/2019/08/20190829153349-d1b15.png" alt="20180708224853769.png"></p>
<h2 id="DispatcherServlet上下文继承关系"><a href="#DispatcherServlet上下文继承关系" class="headerlink" title="DispatcherServlet上下文继承关系"></a>DispatcherServlet上下文继承关系</h2><p><img src="http://image.winrains.cn/2019/08/20190829153350-5d564.png" alt="mvc-context-hierarchy.png"></p>
<h2 id="SpringMVC设计的父子容器"><a href="#SpringMVC设计的父子容器" class="headerlink" title="SpringMVC设计的父子容器"></a>SpringMVC设计的父子容器</h2><h3 id="父子容器配置文件"><a href="#父子容器配置文件" class="headerlink" title="父子容器配置文件"></a>父子容器配置文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在web.xml中配置，两个重要的xml:applicationContext.xml和SpringMVC-conf.xml--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:applictionContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher-servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:springMVC-conf.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher-servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span></pre></td></tr></table></figure>

<h3 id="父子容器的设计目的"><a href="#父子容器的设计目的" class="headerlink" title="父子容器的设计目的"></a>父子容器的设计目的</h3><p>根据SpringMVC的官方解释，父（根）容器主要包括一些基础脚手架的bean，比如Pool、DataSource、Dao、Service。目的是在不同的Servlet实例之间共享。这些不同的bean可以在子容器中重写。 而子容器主要包括一些Controller、View等一些web相关的bean。</p>
<h2 id="DispatcherServlet源码分析"><a href="#DispatcherServlet源码分析" class="headerlink" title="DispatcherServlet源码分析"></a>DispatcherServlet源码分析</h2><p>既然SpringMVC中同时包含Spring容器和SpringMVC容器，那么这两个容器都是在什么时候初始化呢？</p>
<h3 id="根容器初始化"><a href="#根容器初始化" class="headerlink" title="根容器初始化"></a>根容器初始化</h3><p>首先，根容器是通过ServletContext监听器进行创建，默认的监听器为ContextLoaderListener，当web应用启动时，会调用监听器的<strong>contextInitialized</strong>方法。 那么根容器的初始化就从<strong>ContextLoaderListener</strong>类说起吧，，Spring官方对该类的描述是启动监听器去启动和关闭Spring的root WebApplicationContext（翻译的实在有点蹩脚）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">(WebApplicationContext context)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">super</span>(context);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// ===初始化root WebApplicationContext===</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        initWebApplicationContext(event.getServletContext());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        closeWebApplicationContext(event.getServletContext());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ContextCleanupListener.cleanupAttributes(event.getServletContext());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// ContextLoader.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 初始化Spring容器时如果发现servlet</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 容器中已存在根Spring容根器则抛出异常，证明rootWebApplicationContext只能有一个。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="string">"Cannot initialize context because there is already a root application context present - "</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                        + <span class="string">"check whether you have multiple ContextLoader* definitions in your web.xml!"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 创建webApplicationContext实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.context == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.context = createWebApplicationContext(servletContext);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class="keyword">this</span>.context;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    ApplicationContext parent = loadParentContext(servletContext);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    cwac.setParent(parent);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// 配置WebApplicationContext</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                configureAndRefreshWebApplicationContext(cwac, servletContext);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 把生成的webApplicationContext设置成root</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * WebApplicationContext。保存在ServletContext上下文中。 下一步初始化MVC</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * ApplicationContext时需要从ServletContext取出根上下文作为其父上下文。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         **/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.context);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (ccl == ContextLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()) </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            currentContext = <span class="keyword">this</span>.context;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ccl != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            currentContextPerThread.put(ccl, <span class="keyword">this</span>.context);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.context;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> ex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>以上代码主要完成两个功能：创建实例WebApplicationContext实例、把所创建的WebApplicationContext设置为根上下文，也就是设置成为ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE的值。</p>
<h3 id="MVC容器初始化"><a href="#MVC容器初始化" class="headerlink" title="MVC容器初始化"></a>MVC容器初始化</h3><p>大家知道Servlet生命周期都是从init方法开始，desctory方法结束，由jvm负责垃圾回收。而DispatcherServlet也是一个普通的Servlet，先看一下DispatcherServlet的继承关系图，对整个继承关系有个了解。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829153351-f1d00.jpeg" alt="1946613-f6892f5c658de75c.jpg"></p>
<p>既然说起Servlet，那就从Servlet的初始化（init）方法入手</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HttpServletBean.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            bw.registerCustomEditor(Resource<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">ResourceEditor</span>(<span class="title">resourceLoader</span>, <span class="title">getEnvironment</span>()))</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            initBeanWrapper(bw);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> ex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 交给子类重写</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    initServletBean();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//FrameworkServlet.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        initFrameworkServlet();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">catch</span> (ServletException | RuntimeException ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> ex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//FrameworkServlet.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化MVC容器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 从ServletContext取出根上下文</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    WebApplicationContext wac = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wac = <span class="keyword">this</span>.webApplicationContext;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    cwac.setParent(rootContext);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                configureAndRefreshWebApplicationContext(cwac);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wac = findWebApplicationContext();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果还没有webApplicatioinContext，创建webApplicationContext</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wac = createWebApplicationContext(rootContext);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 子类自定义对servlet子上下文后续操作，在DispatcherServlet中实现</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.onRefreshMonitor) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 执行子类扩展方法onRefresh，在DispatcherServlet内初始化所有web相关组件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            onRefresh(wac);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 发布servlet子上下文到ServletContext</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String attrName = getServletContextAttributeName();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 将servlet子上下文以org.springframework.web.servlet.FrameworkServlet.CONTEXT.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// + servletName的属性名称注册到ServletContext中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        getServletContext().setAttribute(attrName, wac);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> wac;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(@Nullable WebApplicationContext parent)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> createWebApplicationContext((ApplicationContext) parent);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(@Nullable ApplicationContext parent)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 获取WebApplicationContext实现类，此处其实就是XmlWebApplicationContext</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Class&lt;?&gt; contextClass = getContextClass();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!ConfigurableWebApplicationContext<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">contextClass</span>)) </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Fatal initialization error in servlet with name '"</span> + getServletName()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                + <span class="string">"': custom WebApplicationContext class ["</span> + contextClass.getName()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                + <span class="string">"] is not of type ConfigurableWebApplicationContext"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 生成XmlWebApplicationContext实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ConfigurableWebApplicationContext wac = (ConfigurableWebApplicationContext) BeanUtils</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .instantiateClass(contextClass);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    wac.setEnvironment(getEnvironment());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 设置根容器为父容器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    wac.setParent(parent);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    String configLocation = getContextConfigLocation();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (configLocation != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 设置配置文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        wac.setConfigLocation(configLocation);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 配置webApplicationContext</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    configureAndRefreshWebApplicationContext(wac);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> wac;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureAndRefreshWebApplicationContext</span><span class="params">(ConfigurableWebApplicationContext wac)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.contextId != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            wac.setId(<span class="keyword">this</span>.contextId);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    + ObjectUtils.getDisplayString(getServletContext().getContextPath()) + <span class="string">'/'</span> + getServletName());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    wac.setServletContext(getServletContext());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    wac.setServletConfig(getServletConfig());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    wac.setNamespace(getNamespace());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    wac.addApplicationListener(<span class="keyword">new</span> SourceFilteringListener(wac, <span class="keyword">new</span> ContextRefreshListener()));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ConfigurableEnvironment env = wac.getEnvironment();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (env <span class="keyword">instanceof</span> ConfigurableWebEnvironment) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    postProcessWebApplicationContext(wac);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    applyInitializers(wac);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 开始处理bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    wac.refresh();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面的关键代码都在FrameworkServlet类中，有几个关键点：取除根上下文，创建子上下文并设置父上下文，完成刷新，把子上下文发布到ServletContext中。 到这里可以说子容器（子上下文）已经创建完成。 并把其他初始化web组件的相关工作交给onRefresh方法完成，由DispatcherServlet来重写onRefresh方法，这就又回到了我们熟悉的initStrategies方法。</p>
<h3 id="web组件初始化"><a href="#web组件初始化" class="headerlink" title="web组件初始化"></a>web组件初始化</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">protected void on<span class="constructor">Refresh(ApplicationContext <span class="params">context</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">Strategies(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">protected void init<span class="constructor">Strategies(ApplicationContext <span class="params">context</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//文件上传解析器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">MultipartResolver(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//本地化解析器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">LocaleResolver(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//主题解析器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">ThemeResolver(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//处理器映射器(url和Controller方法的映射)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">HandlerMappings(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//处理器适配器(实际执行Controller方法)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">HandlerAdapters(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//处理器异常解析器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">HandlerExceptionResolvers(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//RequestToViewName解析器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">RequestToViewNameTranslator(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//视图解析器(视图的匹配和渲染)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">ViewResolvers(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//FlashMap管理者</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init<span class="constructor">FlashMapManager(<span class="params">context</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里我们主要关注一下三个重要组件：HandlerMapping、HandlerAdapter、ViewResolver。分析这3个组件之前，我们先看一下我们的springMVC-conf.xml配置文件，mvc的配置文件中，我们配置了两行代码：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">&lt;<span class="symbol">context:</span>component-scan base-package=<span class="string">"com.zhangfei"</span>/&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;<span class="symbol">mvc:</span><span class="keyword">annotation</span>-<span class="title">driven</span>&gt;</span></pre></td></tr></table></figure>

<p>第二行代码主要是添加了默认的HandleMapping,ViewResolver,HandleAdapter。我们看看annotation-driven的源码定义，根据spring自定义schema定义，我们找到如下代码，如图所示：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829153351-eab5e.jpeg" alt="QQ截图20190822131726.jpg"></p>
<p>该文件就一行代码：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">http:<span class="type"></span>//www.springframework.org/schema/mvc=org.springframework.web.servlet.config.MvcNamespaceHandler</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//MVC所有的标签解析器都定义在此</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcNamespaceHandler</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">NamespaceHandlerSupport</span></span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> void init() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"annotation-driven"</span>, <span class="keyword">new</span> <span class="type">AnnotationDrivenBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"default-servlet-handler"</span>, <span class="keyword">new</span> <span class="type">DefaultServletHandlerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"interceptors"</span>, <span class="keyword">new</span> <span class="type">InterceptorsBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"resources"</span>, <span class="keyword">new</span> <span class="type">ResourcesBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"view-controller"</span>, <span class="keyword">new</span> <span class="type">ViewControllerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"redirect-view-controller"</span>, <span class="keyword">new</span> <span class="type">ViewControllerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"status-controller"</span>, <span class="keyword">new</span> <span class="type">ViewControllerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"view-resolvers"</span>, <span class="keyword">new</span> <span class="type">ViewResolversBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"tiles-configurer"</span>, <span class="keyword">new</span> <span class="type">TilesConfigurerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"freemarker-configurer"</span>, <span class="keyword">new</span> <span class="type">FreeMarkerConfigurerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"groovy-configurer"</span>, <span class="keyword">new</span> <span class="type">GroovyMarkupConfigurerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"script-template-configurer"</span>, <span class="keyword">new</span> <span class="type">ScriptTemplateConfigurerBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registerBeanDefinitionParser(<span class="string">"cors"</span>, <span class="keyword">new</span> <span class="type">CorsBeanDefinitionParser</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>那么通过分析AnnotationDrivenBeanDefinitionParser类，主要完成以下三大组件的装配工作：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829153351-7caf6.jpeg" alt="QQ截图20190822132044.jpg"></p>
<h4 id="初始化处理器映射器"><a href="#初始化处理器映射器" class="headerlink" title="初始化处理器映射器"></a>初始化处理器映射器</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void initHandlerMappings(ApplicationContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">this</span>.handlerMappings = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 这里detectAllHandlerMappings默认值为true，可以通过配置文件设置为false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerMappings) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 从上下文(包含父上下文)中查找所有HandlerMapping实现类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Map&lt;String, HandlerMapping&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                HandlerMapping<span class="class">.<span class="keyword">class</span>, <span class="type">true</span>, <span class="type">false);</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.handlerMappings = new ArrayList&lt;&gt;(matchingBeans.values());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerMappings);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 这里只取固定的bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping<span class="class">.<span class="keyword">class</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.handlerMappings = Collections.singletonList(hm);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/***</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 确保至少有一个HandlerMapping，如果没能找到，注册一个默认的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 默认规则在DispatcherServlet.properties中，这里也就是取BeanNameUrlHandlerMapping、</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * RequestMappingHandlerMapping</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     ***/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="literal">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping<span class="class">.<span class="keyword">class</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="初始化处理器适配器"><a href="#初始化处理器适配器" class="headerlink" title="初始化处理器适配器"></a>初始化处理器适配器</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void initHandlerAdapters(ApplicationContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">this</span>.handlerAdapters = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerAdapters) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 从上下文（包括父上下文）中查找所有HandlerAdapter实现类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Map&lt;String, HandlerAdapter&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                HandlerAdapter<span class="class">.<span class="keyword">class</span>, <span class="type">true</span>, <span class="type">false);</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.handlerAdapters = new ArrayList&lt;&gt;(matchingBeans.values());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerAdapters);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 这里取bean名字为handlerAdapter，类型为HandlerAdapter的处理器适配器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            HandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter<span class="class">.<span class="keyword">class</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.handlerAdapters = Collections.singletonList(ha);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 如果没找到，则从默认规则里取出指定的三个实现类：HttpRequestHandlerAdapter、</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * SimpleControllerHandlerAdapter、RequestMappingHandlerAdapter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     **/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerAdapters == <span class="literal">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.handlerAdapters = getDefaultStrategies(context, HandlerAdapter<span class="class">.<span class="keyword">class</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="初始化试图解析器"><a href="#初始化试图解析器" class="headerlink" title="初始化试图解析器"></a>初始化试图解析器</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void initViewResolvers(ApplicationContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">this</span>.viewResolvers = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.detectAllViewResolvers) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 从上下文（包括父上下文）中查找所有ViewResolver实现类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Map&lt;String, ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ViewResolver<span class="class">.<span class="keyword">class</span>, <span class="type">true</span>, <span class="type">false);</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.viewResolvers = new ArrayList&lt;&gt;(matchingBeans.values());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.viewResolvers);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ViewResolver vr = context.getBean(VIEW_RESOLVER_BEAN_NAME, ViewResolver<span class="class">.<span class="keyword">class</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.viewResolvers = Collections.singletonList(vr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 如果没找到，则从默认规则里取出指定的实现类：InternalResourceViewResolver</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     **/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.viewResolvers == <span class="literal">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.viewResolvers = getDefaultStrategies(context, ViewResolver<span class="class">.<span class="keyword">class</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>三大组件的初始化最后判断为NULL时都会调用getDefaultStrategies方法，也就是从DispatcherServlet.properties中取出指定默认值。</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; List&lt;T&gt; getDefaultStrategies(ApplicationContext context, Class&lt;T&gt; strategyInterface) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">String</span> <span class="built_in">key</span> = strategyInterface.getName();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">String</span> value = defaultStrategies.getProperty(<span class="built_in">key</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">String</span>[] classNames = StringUtils.commaDelimitedListToStringArray(value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;T&gt; strategies = <span class="keyword">new</span> ArrayList&lt;&gt;(classNames.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">String</span> className : classNames) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Class&lt;?&gt; clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">Object</span> strategy = createDefaultStrategy(context, clazz);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                strategies.<span class="built_in">add</span>((T) strategy);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">"Could not find DispatcherServlet's default strategy class ["</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                        + className + <span class="string">"] for interface ["</span> + <span class="built_in">key</span> + <span class="string">"]"</span>, ex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">catch</span> (LinkageError err) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="string">"Unresolvable class definition for DispatcherServlet's default strategy class ["</span> + className</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                + <span class="string">"] for interface ["</span> + <span class="built_in">key</span> + <span class="string">"]"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        err);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> strategies;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="DispatcherServlet请求处理过程"><a href="#DispatcherServlet请求处理过程" class="headerlink" title="DispatcherServlet请求处理过程"></a>DispatcherServlet请求处理过程</h2><p>提到请求处理过程，我们再来回顾一下Servlet生命周期，处理请求都放在service方法中处理，那么也从DispatcherServlet的service方法入手。DispatcherServlet继承FrameworkServlet，在FrameworkServlet中重写了service、doGet、doPost、doPut、doDelete方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FrameworkServlet.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (httpMethod == HttpMethod.PATCH || httpMethod == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        processRequest(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">super</span>.service(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    processRequest(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    processRequest(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPut</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    processRequest(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    processRequest(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Throwable failureCause = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LocaleContext localeContext = buildLocaleContext(request);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    asyncManager.registerCallableInterceptor(FrameworkServlet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">new</span> <span class="title">RequestBindingInterceptor</span>())</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 把新构造的LocaleContext对象和ServletRequestAttributes对象和当前请求线程绑定（后面要解除绑定）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    initContextHolders(request, localeContext, requestAttributes);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 抽象方法，交给DispatcherServlet方法实现</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        doService(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (ServletException | IOException ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        failureCause = ex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> ex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        failureCause = ex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NestedServletException(<span class="string">"Request processing failed"</span>, ex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 重置LocaleContext和RequestAttributes对象，也就是解除LocaleContext对象和ServletRequestAttributes对象和当前请求线程的绑定</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        resetContextHolders(request, previousLocaleContext, previousAttributes);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (requestAttributes != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            requestAttributes.requestCompleted();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 发布ServletRequestHandledEvent事件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        publishRequestHandledEvent(request, response, startTime, failureCause);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// DispatcherServlet.java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        attributesSnapshot = <span class="keyword">new</span> HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            String attrName = (String) attrNames.nextElement();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                attributesSnapshot.put(attrName, request.getAttribute(attrName));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 在当前request对象中填充4个属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.flashMapManager != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 主要处理分发请求</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        doDispatch(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (attributesSnapshot != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                restoreAttributesAfterInclude(request, attributesSnapshot);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    HttpServletRequest processedRequest = request;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            processedRequest = checkMultipart(request);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            multipartRequestParsed = (processedRequest != request);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 调用handlerMapping获取handlerChain</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            mappedHandler = getHandler(processedRequest);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                noHandlerFound(processedRequest, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 获取支持该handler解析的HandlerAdapter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            String method = request.getMethod();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 使用HandlerAdapter完成handler处理</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 视图处理(页面渲染)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            applyDefaultViewName(processedRequest, mv);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            dispatchException = ex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable err) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Throwable err) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                cleanupMultipart(processedRequest);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>DispatcherServlet的doDispatch方法概括起来大致就是以下几点：首先根据当前请求路径找到对应的HandlerMethod，一个HandlerMethod和若干个拦截器构造一个<strong>HandlerExecutionChain.通过HandlerExecutionChain</strong>得到<strong>HandlerAdapter</strong>对象<strong>，</strong>通过执行<strong>HandlerAdapter</strong>的handle方法得到<strong>ModelAndView</strong>对象，调用ModelAndView解析视图，渲染视图，Response结束。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5cb89dae6fb9a0686b47306d" target="_blank" rel="noopener">juejin.im/post/5cb89d…</a> <a href="https://juejin.im/post/5cbc10b46fb9a0689f4c2c22" target="_blank" rel="noopener">juejin.im/post/5cbc10…</a> <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Ffangjian0423%2Fp%2FspringMVC-dispatcherServlet.html">www.cnblogs.com/fangjian042…</a></p>
<blockquote>
<p>作者：garfieldzf8</p>
<p>来源：<a href="https://juejin.im/post/5d5e3e70e51d453b5d4d8d75" target="_blank" rel="noopener">https://juejin.im/post/5d5e3e70e51d453b5d4d8d75</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring MVC</category>
      </categories>
  </entry>
  <entry>
    <title>Spring AOP使用讲解</title>
    <url>/2019/12/26/Spring%20AOP%E4%BD%BF%E7%94%A8%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="1-什么是AOP"><a href="#1-什么是AOP" class="headerlink" title="1. 什么是AOP?"></a>1. 什么是AOP?</h2><p>AOP是Aspect Oriented Programming的缩写，意思是：面向切面编程，它是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。<br>可以认为AOP是对OOP(Object Oriented Programming 面向对象编程)的补充，主要使用在日志记录，性能统计，安全控制等场景，使用AOP可以使得业务逻辑各部分之间的耦合度降低，只专注于各自的业务逻辑实现，从而提高程序的可读性及维护性。<br>比如，我们需要记录项目中所有对外接口的入参和出参，以便出现问题时定位原因，在每一个对外接口的代码中添加代码记录入参和出参当然也可以达到目的，但是这种硬编码的方式非常不友好，也不够灵活，而且记录日志本身和接口要实现的核心功能没有任何关系。</p>
<a id="more"></a>

<p>此时，我们可以将记录日志的功能定义到1个切面中，然后通过声明的方式定义要在何时何地使用这个切面，而不用修改任何1个外部接口。<br>在讲解具体的实现方式之前，我们先了解几个AOP中的术语。</p>
<h3 id="1-1-通知-Advice"><a href="#1-1-通知-Advice" class="headerlink" title="1.1 通知(Advice)"></a>1.1 通知(Advice)</h3><p>在AOP术语中，切面要完成的工作被称为通知，通知定义了切面是什么以及何时使用。<br>Spring切面有5种类型的通知，分别是：</p>
<ul>
<li>前置通知(Before)：在目标方法被调用之前调用通知功能</li>
<li>后置通知(After)：在目标方法完成之后调用通知，此时不关心方法的输出结果是什么</li>
<li>返回通知(After-returning)：在目标方法成功执行之后调用通知</li>
<li>异常通知(After-throwing)：在目标方法抛出异常后调用通知</li>
<li>环绕通知(Around)：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为</li>
</ul>
<h3 id="1-2-连接点-Join-point"><a href="#1-2-连接点-Join-point" class="headerlink" title="1.2 连接点(Join point)"></a>1.2 连接点(Join point)</h3><p>连接点是在应用执行过程中能够插入切面的一个点，这个点可以是调用方法时、抛出异常时、修改某个字段时。</p>
<h3 id="1-3-切点-Pointcut"><a href="#1-3-切点-Pointcut" class="headerlink" title="1.3 切点(Pointcut)"></a>1.3 切点(Pointcut)</h3><p>切点是为了缩小切面所通知的连接点的范围，即切面在何处执行。我们通常使用明确的类和方法名称，或者利用正则表达式定义所匹配的类和方法名称来指定切点。</p>
<h3 id="1-4-切面-Aspect"><a href="#1-4-切面-Aspect" class="headerlink" title="1.4 切面(Aspect)"></a>1.4 切面(Aspect)</h3><p>切面是通知和切点的结合。通知和切点共同定义了切面的全部内容：它是什么，在何时和何处完成其功能。</p>
<h3 id="1-5-引入-Introduction"><a href="#1-5-引入-Introduction" class="headerlink" title="1.5 引入(Introduction)"></a>1.5 引入(Introduction)</h3><p>引入允许我们在不修改现有类的基础上，向现有类添加新方法或属性。</p>
<h3 id="1-6-织入-Weaving"><a href="#1-6-织入-Weaving" class="headerlink" title="1.6 织入(Weaving)"></a>1.6 织入(Weaving)</h3><p>织入是把切面应用到目标对象并创建新的代理对象的过程。<br>切面在指定的连接点被织入到目标对象中，在目标对象的生命周期里，有以下几个点可以进行织入：</p>
<ul>
<li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li>
<li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器(ClassLoader)，它可以在目标类被引入应用之前增强该目标类的字节码。</li>
<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。</li>
</ul>
<h2 id="2-Spring-对AOP的支持"><a href="#2-Spring-对AOP的支持" class="headerlink" title="2. Spring 对AOP的支持"></a>2. Spring 对AOP的支持</h2><h3 id="2-1-动态代理"><a href="#2-1-动态代理" class="headerlink" title="2.1 动态代理"></a>2.1 动态代理</h3><p><strong>Spring AOP构建在动态代理之上</strong>，也就是说，Spring运行时会为目标对象动态创建代理对象。<br>代理类封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。<br>当代理类拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829154615-53d0a.png" alt="img"></p>
<h3 id="2-2-织入切面时机"><a href="#2-2-织入切面时机" class="headerlink" title="2.2 织入切面时机"></a>2.2 织入切面时机</h3><p>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring 管理的bean中，也就是说，直到应用需要被代理的bean时，Spring才会创建代理对象。<br>因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入Spring AOP切面。</p>
<h3 id="2-3-连接点限制"><a href="#2-3-连接点限制" class="headerlink" title="2.3 连接点限制"></a>2.3 连接点限制</h3><p>Spring只支持方法级别的连接点，如果需要字段级别或者构造器级别的连接点，可以利用AspectJ来补充Spring AOP的功能。</p>
<h2 id="3-Spring-AOP使用"><a href="#3-Spring-AOP使用" class="headerlink" title="3. Spring AOP使用"></a>3. Spring AOP使用</h2><p>假设我们有个现场表演的接口Performance和它的实现类SleepNoMore：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package chapter04.concert;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 现场表演,如舞台剧,电影,音乐会</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> interface Performance &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="type">void</span> <span class="keyword">perform</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">package chapter04.concert;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 戏剧:《不眠之夜Sleep No More》</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Component</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> SleepNoMore implements Performance &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">public</span> <span class="type">void</span> <span class="keyword">perform</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("戏剧《不眠之夜Sleep No More》");</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>既然是演出，就需要观众，假设我们的需求是：在看演出之前，观众先入座并将手机调整至静音，在观看演出之后观众鼓掌，如果演出失败观众退票，我们当然可以把这些逻辑写在上面的perform()方法中，但不推荐这么做，因为这些逻辑理论上和演出的核心无关，就算观众不将手机调整至静音或者看完演出不鼓掌，都不影响演出的进行。<br>针对这个需求，我们可以使用AOP来实现。</p>
<h3 id="3-1-定义切面"><a href="#3-1-定义切面" class="headerlink" title="3.1 定义切面"></a>3.1 定义切面</h3><p>首先，在pom.xml文件中添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring aop支持--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--aspectj支持--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure>

<p>然后，定义一个观众的切面如下：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">package chapter04.concert;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.aspectj.lang.<span class="keyword">annotation</span>.<span class="title">Aspect</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">/**</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * 观众</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * 使用@Aspect注解定义为切面</span></pre></td></tr><tr><td class="code"><pre><span class="line"> *<span class="regexp">/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">@Aspect</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">public class Audience &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">&#125;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：<code>@Aspect</code>注解表明Audience类是一个切面。</p>
</blockquote>
<h3 id="3-2-定义前置通知"><a href="#3-2-定义前置通知" class="headerlink" title="3.2 定义前置通知"></a>3.2 定义前置通知</h3><p>在Audience切面中定义前置通知如下所示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演之前,观众就座</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="keyword">Before</span>("execution(* chapter04.concert.Performance.perform(..))")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> takeSeats() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("Taking seats");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演之前,将手机调至静音</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="keyword">Before</span>("execution(* chapter04.concert.Performance.perform(..))")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> silenceCellPhones() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("Silencing cell phones");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里的重点代码是<code>@Before(&quot;execution(* chapter04.concert.Performance.perform(..))&quot;)</code>，它定义了1个前置通知，其中<code>execution(* chapter04.concert.Performance.perform(..))</code>被称为AspectJ切点表达式，每一部分的讲解如下：</p>
<ul>
<li>@Before：该注解用来定义前置通知，通知方法会在目标方法调用之前执行</li>
<li>execution：在方法执行时触发</li>
<li>*：表明我们不关心方法返回值的类型，即可以是任意类型</li>
<li>chapter04.concert.Performance.perform：使用全限定类名和方法名指定要添加前置通知的方法</li>
<li>(..)：方法的参数列表使用(..)，表明我们不关心方法的入参是什么，即可以是任意类型</li>
</ul>
<h3 id="3-3-定义后置通知"><a href="#3-3-定义后置通知" class="headerlink" title="3.3 定义后置通知"></a>3.3 定义后置通知</h3><p>在Audience切面中定义后置通知如下所示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演结束,不管表演成功或者失败</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="keyword">After</span>("execution(* chapter04.concert.Performance.perform(..))")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> finish() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("perform finish");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：@After注解用来定义后置通知，通知方法会在目标方法返回或者抛出异常后调用</p>
</blockquote>
<h3 id="3-4-定义返回通知"><a href="#3-4-定义返回通知" class="headerlink" title="3.4 定义返回通知"></a>3.4 定义返回通知</h3><p>在Audience切面中定义返回通知如下所示：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演之后,鼓掌</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@AfterReturning(<span class="string">"execution(* chapter04.concert.Performance.perform(..))"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"CLAP CLAP CLAP!!!"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：@AfterReturning注解用来定义返回通知，通知方法会在目标方法返回后调用</p>
</blockquote>
<h3 id="3-5-定义异常通知"><a href="#3-5-定义异常通知" class="headerlink" title="3.5 定义异常通知"></a>3.5 定义异常通知</h3><p>在Audience切面中定义异常通知如下所示：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演失败之后,观众要求退款</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@AfterThrowing(<span class="string">"execution(* chapter04.concert.Performance.perform(..))"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demandRefund</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Demanding a refund"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：@AfterThrowing注解用来定义异常通知，通知方法会在目标方法抛出异常后调用</p>
</blockquote>
<h3 id="3-6-定义可复用的切点表达式"><a href="#3-6-定义可复用的切点表达式" class="headerlink" title="3.6 定义可复用的切点表达式"></a>3.6 定义可复用的切点表达式</h3><p>细心的你可能会发现，我们上面定义的5个切点中，切点表达式都是一样的，这显然是不好的，好在我们可以使用<code>@Pointcut</code>注解来定义可重复使用的切点表达式：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 可复用的切点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Pointcut("execution(* chapter04.concert.Performance.perform(..))")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> <span class="keyword">perform</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后之前定义的5个切点都可以引用这个切点表达式：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演之前,观众就座</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="keyword">Before</span>("perform()")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> takeSeats() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("Taking seats");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演之前,将手机调至静音</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="keyword">Before</span>("perform()")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> silenceCellPhones() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("Silencing cell phones");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演结束,不管表演成功或者失败</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="keyword">After</span>("perform()")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> finish() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("perform finish");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演之后,鼓掌</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@AfterReturning("perform()")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> applause() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("CLAP CLAP CLAP!!!");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 表演失败之后,观众要求退款</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@AfterThrowing("perform()")</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> demandRefund() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("Demanding a refund");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="3-7-单元测试"><a href="#3-7-单元测试" class="headerlink" title="3.7 单元测试"></a>3.7 单元测试</h3><p>新建配置类ConcertConfig如下所示：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">package chapter04.concert;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">Bean</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">ComponentScan</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">Configuration</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">EnableAspectJAutoProxy</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableAspectJAutoProxy</span></pre></td></tr><tr><td class="code"><pre><span class="line">@ComponentScan</span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcertConfig</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Audience audience() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> new Audience();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：和以往不同的是，我们使用了<code>@EnableAspectJAutoProxy</code>注解，该注解用来启用自动代理功能。</p>
</blockquote>
<p>新建Main类，在其main()方法中添加如下测试代码：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package chapter04.concert;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Main &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        AnnotationConfigApplicationContext context = <span class="built_in">new</span> AnnotationConfigApplicationContext(ConcertConfig.<span class="keyword">class</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Performance performance = context.getBean(Performance.<span class="keyword">class</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        performance.<span class="keyword">perform</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        context.<span class="keyword">close</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>运行代码，输出结果如下所示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Silencing cell phones</span></pre></td></tr><tr><td class="code"><pre><span class="line">Taking seats</span></pre></td></tr><tr><td class="code"><pre><span class="line">戏剧《不眠之夜Sleep <span class="keyword">No</span> More》</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">perform</span> finish</span></pre></td></tr><tr><td class="code"><pre><span class="line">CLAP CLAP CLAP!!!</span></pre></td></tr></table></figure>

<p>稍微修改下SleepNoMore类的perform()方法，让它抛出一个异常：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@Override</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> <span class="keyword">perform</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="type">int</span> number = <span class="number">3</span> / <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("戏剧《不眠之夜Sleep No More》");</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>再次运行代码，输出结果如下所示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Silencing cell phones</span></pre></td></tr><tr><td class="code"><pre><span class="line">Taking seats</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">perform</span> finish</span></pre></td></tr><tr><td class="code"><pre><span class="line">Demanding a refund</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Exception</span> <span class="keyword">in</span> thread "main" java.lang.ArithmeticException: / <span class="keyword">by</span> zero</span></pre></td></tr></table></figure>

<p><img src="http://image.winrains.cn/2019/08/20190829154615-ecdb8.png" alt="img"></p>
<p>由此也可以说明，不管目标方法是否执行成功，@After注解都会执行，但@AfterReturning注解只会在目标方法执行成功时执行。<br>值得注意的是，使用<code>@Aspect</code>注解的切面类必须是一个bean(不管以何种方式声明)，否则切面不会生效，因为AspectJ自动代理只会为使用<code>@Aspect</code>注解的bean创建代理类。<br>也就是说，如果我们将ConcertConfig配置类中的以下代码删除或者注释掉：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">Audience <span class="title">audience</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Audience();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>运行结果将变为：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">戏剧《不眠之夜<span class="keyword">Sleep</span> <span class="keyword">No</span> <span class="keyword">More</span>》</span></pre></td></tr></table></figure>

<h3 id="3-8-创建环绕通知"><a href="#3-8-创建环绕通知" class="headerlink" title="3.8 创建环绕通知"></a>3.8 创建环绕通知</h3><p>我们可以使用<code>@Around</code>注解创建环绕通知，该注解能够让你在调用目标方法前后，自定义自己的逻辑。<br>因此，我们之前定义的5个切点，现在可以定义在一个切点中，为不影响之前的切面，我们新建切面AroundAudience，如下所示：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">package chapter04.concert;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.aspectj.lang.<span class="keyword">annotation</span>.<span class="title">Around</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.aspectj.lang.<span class="keyword">annotation</span>.<span class="title">Aspect</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.aspectj.lang.<span class="keyword">annotation</span>.<span class="title">Pointcut</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Aspect</span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AroundAudience</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    /**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 可重用的切点</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *<span class="regexp">/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    @Pointcut("execution(* chapter04.concert.Performance.perform(..))")</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    public void perform() &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    @Around("perform()")</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    public void watchPerform(ProceedingJoinPoint joinPoint) &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">        try &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">            System.out.println("Taking seats");</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">            System.out.println("Silencing cell phones");</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">            joinPoint.proceed();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">            System.out.println("CLAP CLAP CLAP!!!");</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">        &#125; catch (Throwable throwable) &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">            System.out.println("Demanding a refund");</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">        &#125; finally &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">            System.out.println("perform finish");</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">        &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">&#125;</span></span></pre></td></tr></table></figure>

<p>这里要注意的是，该方法有个ProceedingJoinPoint类型的参数，在方法中可以通过调用它的proceed()方法来调用目标方法。<br>然后修改下ConcertConfig类的代码：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">package chapter04.concert;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">Bean</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">ComponentScan</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">Configuration</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">EnableAspectJAutoProxy</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableAspectJAutoProxy</span></pre></td></tr><tr><td class="code"><pre><span class="line">@ComponentScan</span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcertConfig</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    /*@Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Audience audience() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> new Audience();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;*<span class="regexp">/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    @Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    public AroundAudience aroundAudience() &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">        return new AroundAudience();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">    &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="regexp">&#125;</span></span></pre></td></tr></table></figure>

<p>运行结果如下所示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Taking seats</span></pre></td></tr><tr><td class="code"><pre><span class="line">Silencing cell phones</span></pre></td></tr><tr><td class="code"><pre><span class="line">戏剧《不眠之夜Sleep <span class="keyword">No</span> More》</span></pre></td></tr><tr><td class="code"><pre><span class="line">CLAP CLAP CLAP!!!</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">perform</span> finish</span></pre></td></tr></table></figure>

<h2 id="4-源码及参考"><a href="#4-源码及参考" class="headerlink" title="4. 源码及参考"></a>4. 源码及参考</h2><p>源码地址：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fzwwhnly%2Fspring-action.git">github.com/zwwhnly/spr…</a>，欢迎下载。<br>Craig Walls 《Spring实战（第4版）》<br><a href="https://link.juejin.im?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2FAOP%2F1332219">AOP（面向切面编程）_百度百科</a></p>
<blockquote>
<p>作者：申城异乡人</p>
<p>来源：<a href="https://juejin.im/post/5d648403f265da03f564f291" target="_blank" rel="noopener">https://juejin.im/post/5d648403f265da03f564f291</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring技术</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引数据结构详解与索引优化</title>
    <url>/2019/12/26/MySQL%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>本篇文章主要学习了MySQL的索引的数据结构的认识，做一个大概的了解即可。</p>
<h2 id="一、索引"><a href="#一、索引" class="headerlink" title="一、索引"></a>一、索引</h2><p>在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行<strong>排序</strong>的一种存储<strong>数据结构</strong>，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑<a href="https://link.juejin.im?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E6%8C%87%E9%92%88%2F2878304">指针</a>清单。索引的作用相当于图书的目录，可以根据目录中的页码快速查找到所需的内容。<br>在MySQL中，存储引擎用类似的方法使用索引，先在索引中找到对应值，然后根据匹配的索引记录找到对应的行。<br>首先说明下MySQL的索引主要是基于Hash表或者B+树。</p>
<a id="more"></a>

<h2 id="二、索引数据结构"><a href="#二、索引数据结构" class="headerlink" title="二、索引数据结构"></a>二、索引数据结构</h2><p>了解索引就需要从索引常见的数据结构开始了解学习，这里有集中常见的的索引数据结构。</p>
<h3 id="二叉树（Binary-Trees）"><a href="#二叉树（Binary-Trees）" class="headerlink" title="二叉树（Binary Trees）"></a>二叉树（Binary Trees）</h3><p>二叉树是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常被称之为“左子树”和“右子树”</p>
<p><img src="http://image.winrains.cn/2019/08/20190829160230-5df25.jpeg" alt="http://image.winrains.cn/2019/08/20190829160230-5df25.jpeg"></p>
<p><strong>左子树&lt;父节点&lt;=右子树</strong><br>二叉树的第i层至多有有2^(i-1)个节点，<br>深度为K的二叉树至多总共有个2^k-1节点（定义根节点所在深度 k0=0），而总计拥有节点数符合的，称为“满二叉树”；<br>二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现<a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9">二叉搜索树</a>和<a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E4%BA%8C%E5%85%83%E5%A0%86%E7%A9%8D">二叉堆</a>，并应用于高效率的搜索和排序。<br>同时学习数据结构，这里还推荐<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cs.usfca.edu%2F~galles%2Fvisualization%2FAlgorithms.html">Data Structure Visualizations</a>进行学习，可以非常直观的看到数据结构允许的过程，一步一步的怎么走的都可以很清晰看得到。<br>找到其中的<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cs.usfca.edu%2F~galles%2Fvisualization%2FBST.html">Binary Search Trees</a>二叉树</p>
<p><img src="http://image.winrains.cn/2019/08/20190829160230-b696d.png" alt="http://image.winrains.cn/2019/08/20190829160230-b696d.png"></p>
<p>可以直观的看到二叉树的数据插入过程，如下：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829160232-1b122.gif" alt="http://image.winrains.cn/2019/08/20190829160232-1b122.gif"></p>
<p>可以看到二叉树不适合用作当作索引的，数据量庞大的话，二叉树的层数会很大，查找效率固然也很慢了。<br>推荐阅读：<a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E4%BA%8C%E5%8F%89%E6%A0%91">维基百科-二叉树</a></p>
<h3 id="红黑树（Red-Black-Trees）"><a href="#红黑树（Red-Black-Trees）" class="headerlink" title="红黑树（Red-Black Trees）"></a>红黑树（Red-Black Trees）</h3><p>是一种自平衡二叉查找树，典型用途是实现关联数组。<br>红黑树的结构复杂，但它的操作有着良好的最坏情况<a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90">运行时间</a>，并且在实践中高效：它可以在O(log n)时间内完成查找，插入和删除，这里的n是树中元素的数目。<br>红黑树遵行以下原则：</p>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有<a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E9%81%93%E8%B7%AF_(%E5%9B%BE%E8%AE%BA)">简单路径</a>都包含相同数目的黑色节点。</li>
</ol>
<p>下面是一个具体的红黑树的图例：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829160233-a9fa9.png" alt="http://image.winrains.cn/2019/08/20190829160233-a9fa9.png"></p>
<p>这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的<a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">二叉查找树</a>。<br>要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。<br>同样在<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cs.usfca.edu%2F~galles%2Fvisualization%2FAlgorithms.html">Data Structure Visualizations</a>中选择<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cs.usfca.edu%2F~galles%2Fvisualization%2FRedBlack.html">Red-Black Trees</a>红黑树进行插入操作可以直观的看到红黑树的插入过程</p>
<p><img src="http://image.winrains.cn/2019/08/20190829160233-7ea03.gif" alt="http://image.winrains.cn/2019/08/20190829160233-7ea03.gif"></p>
<p>同样红黑树也不适用于MySQL的索引，数据量庞大之后，数层也会变大。<br>推荐阅读：<br><a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E7%BA%A2%E9%BB%91%E6%A0%91">维基百科-红黑树</a><br><a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fjz1ajDUygZ7sXLQFHyfjWA">程序员小灰-红黑树</a></p>
<h3 id="其他结构的问题"><a href="#其他结构的问题" class="headerlink" title="其他结构的问题"></a>其他结构的问题</h3><p>由于无法装入内存，则必然依赖磁盘（或SSD）存储。而内存的读写速度是磁盘的成千上万倍（与具体实现有关），因此，核心问题是“如何减少磁盘读写次数”。<br>首先不考虑页表机制，假设每次读、写都直接穿透到磁盘，那么：</p>
<ul>
<li>线性结构：读/写平均O(n)次</li>
<li>二叉搜索树（<code>BST</code>）：读/写平均O(log2(n))次；如果树不平衡，则最差读/写O(n)次</li>
<li>自平衡二叉搜索树（<code>AVL</code>）：在BST的基础上加入了自平衡算法，读/写最大O(log2(n))次</li>
<li>红黑树（<code>RBT</code>）：另一种自平衡的查找树，读/写最大O(log2(n))次</li>
</ul>
<p><code>BST</code>、<code>AVL</code>、<code>RBT</code>很好的将读写次数从O(n)优化到O(log2(n))；其中，<code>AVL</code>和<code>RBT</code>都比<code>BST</code>多了自平衡的功能，将读写次数降到最大O(log2(n))。<br>假设使用自增主键，则主键本身是有序的，树结构的读写次数能够优化到树高，树高越低读写次数越少；自平衡保证了树结构的稳定。如果想进一步优化，可以引入<code>B树</code>和<code>B+树</code>。</p>
<h3 id="B树（B-Trees）"><a href="#B树（B-Trees）" class="headerlink" title="B树（B-Trees）"></a>B树（B-Trees）</h3><p>又称：多路平衡查找树。大多数存储引擎都支持B树索引。b树通常意味着所有的值都是按顺序存储的，并且每一个叶子节点到根的距离相同。B树索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取数据。下图就是一颗简单的B树。<br>在B树中，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）。当数据被插入或从一个节点中移除，它的子节点数量发生变化。为了维持在预先设定的数量范围内，内部节点可能会被合并或者分离。<br>如下图所示：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829160234-35182.png" alt="http://image.winrains.cn/2019/08/20190829160234-35182.png"></p>
<ul>
<li>叶节点具有相同的深度，叶节点的指针为空</li>
<li>所有索引元素不重复</li>
<li>节点中的数据索引从左到右递增排列</li>
<li>无论中间节点还是叶子节点都带有卫星数据data（索引元素所指向的数据记录）</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829160235-9e2bd.gif" alt="http://image.winrains.cn/2019/08/20190829160235-9e2bd.gif"></p>
<p>只演示了插入的过程，其中可以通过delete、find执行删除和查找操作。直观的感受到B树的执行过程。<br>每个节点存储了多个Key和子树，子树与Key按顺序排列。</p>
<blockquote>
<p>同二叉搜索树类似，每个节点存储了多个key和子树，子树与key按顺序排列。<br>页表的目录是扩展外存+加速磁盘读写，一个页（Page）通常4K（等于磁盘数据块block的大小，见inode与block的分析），操作系统每次以页为单位将内容从磁盘加载到内存（以摊分寻道成本），修改页后，再择期将该页写回磁盘。考虑到页表的良好性质，可以使每个节点的大小约等于一个页（使m非常大），这每次加载的一个页就能完整覆盖一个节点，以便选择下一层子树；对子树同理。对于页表来说，AVL（或RBT）相当于1个key+2个子树的B树，由于逻辑上相邻的节点，物理上通常不相邻，因此，读入一个4k页，页面内绝大部分空间都将是无效数据。</p>
</blockquote>
<p>假设key、子树节点指针均占用4B，则B树节点最大<code>m * (4 + 4) = 8m B</code>；页面大小4KB。则<code>m = 4 * 1024 / 8m = 512</code>，一个512叉的B树，1000w的数据，深度最大 <code>log(512/2)(10^7) = 3.02 ~= 4</code>。对比二叉树如AVL的深度为<code>log(2)(10^7) = 23.25 ~= 24</code>，相差了5倍以上。震惊！B树索引深度竟然如此！<br>那为什么B数这么厉害了，还有B+树的出现呢，必然是解决B树存在的问题<br>1、为定位行数<br>2、无法处理范围查询<br><strong>问题1：为定位行数</strong><br>数据表的记录有多个字段，仅仅定位到主键是不够的，还需要定位到数据行。有3个方案解决：</p>
<ol>
<li>直接将key对应的数据行（可能对应多行）存储子节点中。</li>
<li>数据行单独存储；节点中增加一个字段，定位key对应数据行的位置。</li>
<li>修改key与子树的判断逻辑，使子树大于等于上一key小于下一key，最终所有访问都将落于叶子节点；叶子节点中直接存储数据行或数据行的位置。</li>
</ol>
<p>方案1直接pass，存储数据行将减少页面中的子树个数，m减小树高增大。<br>方案2的节点中增加了一个字段，假设是4B的指针，则新的<code>m = 4 * 1024 / 12m = 341.33 ~= 341</code>，深度最大 <code>log(341/2)(10^7) = 3.14 ~= 4</code>。<br>方案3的节点m与深度不变，但时间复杂度变为稳定的O(logm(n))。<br>方案3可以考虑。<br><strong>问题2：无法处理范围查询</strong><br>实际业务中，范围查询的频率非常高，B树只能定位到一个索引位置（可能对应多行），很难处理范围查询。改动较小的是2个方案：</p>
<ol>
<li>不改动；查询的时候先查到左界，再查到右界，然后DFS（或BFS）遍历左界、右界之间的节点。</li>
<li>在“问题1-方案3”的基础上，由于所有数据行都存储在叶子节点，B树的叶子节点本身也是有序的，可以增加一个指针，指向当前叶子节点按主键顺序的下一叶子节点；查询时先查到左界，再查到右界，然后从左界到有界线性遍历。</li>
</ol>
<p>乍一看感觉方案1比方案2好——时间复杂度和常数项都一样，方案1还不需要改动。但是别忘了局部性原理，不管节点中存储的是数据行还是数据行位置，方案2的好处在于，依然可以利用页表和缓存预读下一节点的信息。而方案1则面临节点逻辑相邻、物理分离的缺点。 推荐阅读：<br><a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FB%E6%A0%91">维基百科-B树</a><br><a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FrDCEFzoKHIjyHfI_bsz5Rw">程序员小灰-B树</a></p>
<h3 id="B-树（B-Trees）"><a href="#B-树（B-Trees）" class="headerlink" title="B+树（B+Trees）"></a>B+树（B+Trees）</h3><p>主要变动如上所述：</p>
<ul>
<li>修改key与子树的组织逻辑，将索引访问都落到叶子节点</li>
<li>按顺序将叶子节点串起来（方便范围查询）</li>
</ul>
<p>回顾上一个B树，<strong>一个m阶的B树具有如下几个特征：</strong><br>1.根结点至少有两个子女。<br>2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m<br>3.每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m<br>4.所有的叶子结点都位于同一层。<br>5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。<br><strong>一个m阶的B+树具有如下几个特征：</strong><br>1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。<br>2.所有的叶子结点包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。<br>3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。<br><strong>B+树特性总结</strong><br><strong>B+树是B树的升级版</strong>，其有如下特性</p>
<ul>
<li>非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引</li>
<li>叶子节点包含所有索引字段</li>
<li>叶子节点用指针连接，提高区间访问的性能</li>
<li>只有叶子节点带有卫星数据data（索引元素所指向的数据记录）</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829160236-e80c3.png" alt="http://image.winrains.cn/2019/08/20190829160236-e80c3.png"></p>
<p>同样在<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cs.usfca.edu%2F~galles%2Fvisualization%2FAlgorithms.html">Data Structure Visualizations</a>中选择<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cs.usfca.edu%2F~galles%2Fvisualization%2FBPlusTree.html">B+ Trees</a>B+树进行插入操作可以直观的看到插入过程</p>
<p><img src="http://image.winrains.cn/2019/08/20190829160237-38799.gif" alt="http://image.winrains.cn/2019/08/20190829160237-38799.gif"></p>
<p>在动图中可以看出，B+树的每一个叶子节点都有一个指针指向下一个节点，把所有的叶子节点串在一起。索引数据都存储在叶子节点中。<br>B+树相比于B树，有什么优势呢：<br>1.单一节点存储更多的元素，使得查询的IO次数更少。<br>2.所有查询都要查找到叶子节点，查询性能稳定。<br>3.所有叶子节点形成有序链表，便于范围查询。<br>总结，B+树相比B树的优势有三：1.IO次数更少；2.查询性能稳定；3.范围查询简便。<br>推荐阅读：<br><a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FB%2B%E6%A0%91">维基百科-B+树</a><br><a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FjRZMMONW3QP43dsDKIV9VQ">程序员小灰-B+树</a></p>
<h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p>hash索引基于hash表实现，<strong>Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中</strong>。只有精准匹配索引所有列的查询才有效。索引的检索可以一次定位，不像B-Tree索引需要从根节点出发到目标节点。虽然Hash索引很快，远高于B-tree索引，但是也有其弊端。</p>
<ol>
<li>Hash索引仅仅能满足’=’,’IN’,’&lt;=&gt;’查询，也就是等值查询，不能使用范围查询。很受限<ol>
<li>由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。</li>
</ol>
</li>
<li>由于Hash索引是通过hash表实现，其本身是没有排序的。<ol>
<li>由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；</li>
</ol>
</li>
<li>Hash索引不能利用部分索引键查询<ol>
<li>对于组合索引，Hash索引在计算hash值的时候是组合索引键合并后再一起计算hash值，而不是单独计算hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。</li>
</ol>
</li>
<li>Hash 索引在任何时候都不能避免表扫描<ol>
<li>前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。</li>
</ol>
</li>
<li>Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。<ol>
<li>对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。</li>
</ol>
</li>
</ol>
<h2 id="三、MySQL数据库引擎"><a href="#三、MySQL数据库引擎" class="headerlink" title="三、MySQL数据库引擎"></a>三、MySQL数据库引擎</h2><p>通过navicat工具查看表设计选项中，从引擎中可以看到MySQL又这么多引擎。具体细分到每个表，不同的表引擎可以不一样。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155930-985f7.png" alt="MySQL数据库引擎"></p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>新建一张表t_test_myisam，引擎使用MyISAM，查看原文件可以看到有3个文件</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155931-943cb.png" alt="MyISAM索引结构原文件"></p>
<p>可以看到索引和数据是分开的，其中索引文件仅仅保存数据记录的地址，故属于<strong>非聚簇索引</strong>。</p>
<h4 id="主键索引（Primary-Index）"><a href="#主键索引（Primary-Index）" class="headerlink" title="主键索引（Primary Index）"></a>主键索引（Primary Index）</h4><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data存放的是数据记录的地址。如下图是MyISAM主键索引的原理图。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155931-a8365.png" alt="MyISAM主键索引"></p>
<p>其中Col1为主键，可以看出看出MyISAM的索引文件仅保存数据记录的地址。</p>
<h4 id="辅助索引（Secondary-Index）"><a href="#辅助索引（Secondary-Index）" class="headerlink" title="辅助索引（Secondary Index）"></a>辅助索引（Secondary Index）</h4><p>在Col2上建立一个辅助索引，如下图辅助索引原理图。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155932-6e0c5.png" alt="MyISAM辅助索引"></p>
<p>可以看到与主键索引没有任何区别，只不过主键索引的key是唯一的，而辅助索引的key可以重复。<br><strong>MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</strong></p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>新建一张表t_test_innodb，引擎使用InnoDB，查看原文件可以看到有2个文件</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155932-cea23.png" alt="InnoDB索引结构原文件"></p>
<h4 id="主键索引（Primary-Index）-1"><a href="#主键索引（Primary-Index）-1" class="headerlink" title="主键索引（Primary Index）"></a>主键索引（Primary Index）</h4><p>InnoDB的索引和数据在一个文件当中。<br>按照B+Tree组织的一个索引结构。<br>叶节点保存了完整的数据记录和索引。这种索引就叫做<strong>聚簇索引</strong>。<br>索引的Key是数据的主键，因此InnoDB表数据文件本身就是主索引。<br>如下图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155932-35591.png" alt="InnoDB主键索引"></p>
<p>可以看到叶节点包含了完整的数据记录。<br>因为InnoDB的数据文件本身要按照主键聚集，所以InnoDB要求<strong>必须有主键</strong>。如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段rowid作为主键，这个字段长度为6个字节，类型为长整形。</p>
<h4 id="辅助索引（Secondary-Index）-1"><a href="#辅助索引（Secondary-Index）-1" class="headerlink" title="辅助索引（Secondary Index）"></a>辅助索引（Secondary Index）</h4><p>辅助索引，将途中的第二行name，作为索引如图</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155932-4d106.png" alt="InnoDB辅助索引"></p>
<p>聚簇索引这种实现方式使得按照主键的搜索十分高效，但是<strong>首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录</strong>。<br>由于InnoDB索引的实现特性，推荐使用整形的自增主键。<br>有三点好处：</p>
<ol>
<li>自增key一般为int等整数型，key比较紧凑，这样m可以非常大，而且索引占用空间小。最极端的例子，如果使用50B的varchar（包括长度），那么<code>m = 4 * 1024 / 54m = 75.85 ~= 76</code>，深度最大<code>log(76/2)(10^7) = 4.43 ~= 5</code>，再加上cache缺失、字符串比较的成本，时间成本增加较大。同时，key由4B增长到50B，整棵索引树的空间占用增长也是极为恐怖的（如果二级索引使用主键定位数据行，则空间增长更加严重）。</li>
<li>MySQL索引底层的数据比较都是整数型比较，如果主键时字符串类型的，里面还有英文，还得转换ASCII码进行比较。所以不建议使用uuid作为主键。</li>
<li>自增的主键使得数据行的插入比如落到索引数的最右侧，发生节点分裂的频率较低。<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cs.usfca.edu%2F~galles%2Fvisualization%2FBPlusTree.html">B+Tree</a>实际操作插入过程。如果不是非单调主键，插入过程很大程度会发生节点重排，不利于索引优化的初衷。</li>
</ol>
<h3 id="InnoDB索引和MyISAM索引的区别"><a href="#InnoDB索引和MyISAM索引的区别" class="headerlink" title="InnoDB索引和MyISAM索引的区别"></a>InnoDB索引和MyISAM索引的区别</h3><p>一是主索引的区别：InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。<br>二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。</p>
<h2 id="四、覆盖索引"><a href="#四、覆盖索引" class="headerlink" title="四、覆盖索引"></a>四、覆盖索引</h2><p>InnoDB存储引擎支持覆盖索引，即从辅助索引中就可以得到查询的记录，不需要查询聚簇索引中的记录了。可以减少大量的IO操作。<br>如果要查询辅助索引中不含有的字段，得先遍历辅助索引，再遍历聚集索引，而如果要查询的字段值在辅助索引上就有，就不用再查聚集索引了，这显然会减少IO操作。</p>
<h2 id="五、联合索引"><a href="#五、联合索引" class="headerlink" title="五、联合索引"></a>五、联合索引</h2><p>两个或以上的列上的索引。如下图联合索引的原理图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829155933-ebb18.png" alt="联合索引原理图"></p>
<p>上图中的联合索引有三个，从上到下，严格按照排序。</p>
<h2 id="六、优化建议"><a href="#六、优化建议" class="headerlink" title="六、优化建议"></a>六、优化建议</h2><h3 id="最左前缀匹配"><a href="#最左前缀匹配" class="headerlink" title="最左前缀匹配"></a>最左前缀匹配</h3><p>索引可以简单如一个列(a)，也可以复杂如多个列(a, b, c, d)，即<code>联合索引</code>。如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否存在（相等），遇到范围查询(&gt;、&lt;、between、like左匹配)等就不能进一步匹配了，后续退化为线性查找。因此，列的排列顺序决定了可命中索引的列数。<br>如有索引(a, b, c, d)，查询条件<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>，则会在每个节点依次命中a、b、c，无法命中d。也就是最左前缀匹配原则。</p>
<h3 id="、in自动优化顺序"><a href="#、in自动优化顺序" class="headerlink" title="=、in自动优化顺序"></a>=、in自动优化顺序</h3><p>不需要考虑=、in等的顺序，mysql会自动优化这些条件的顺序，以匹配尽可能多的索引列。<br>如有索引(a, b, c, d)，查询条件<code>c &gt; 3 and b = 2 and a = 1 and d &lt; 4</code>与<code>a = 1 and c &gt; 3 and b = 2 and d &lt; 4</code>等顺序都是可以的，MySQL会自动优化为<code>a = 1 and b = 2 and c &gt; 3 and d &lt; 4</code>，依次命中a、b、c。</p>
<h3 id="索引列不能参与计算"><a href="#索引列不能参与计算" class="headerlink" title="索引列不能参与计算"></a>索引列不能参与计算</h3><p>有索引列参与计算的查询条件对索引不友好（甚至无法使用索引），如<code>from_unixtime(create_time) = &#39;2014-05-29&#39;</code>。<br>原因很简单，如何在节点中查找到对应key？如果线性扫描，则每次都需要重新计算，成本太高；如果二分查找，则需要针对from_unixtime方法确定大小关系。<br>因此，索引列不能参与计算。上述<code>from_unixtime(create_time) = &#39;2014-05-29&#39;</code>语句应该写成<code>create_time = unix_timestamp(&#39;2014-05-29&#39;)</code>。</p>
<h3 id="能扩展就不要新建索引"><a href="#能扩展就不要新建索引" class="headerlink" title="能扩展就不要新建索引"></a>能扩展就不要新建索引</h3><p>如果已有索引(a)，想建立索引(a, b)，尽量选择修改索引(a)为索引(a, b)。<br>新建索引的成本很容易理解。而基于索引(a)修改为索引(a, b)的话，MySQL可以直接在索引a的B+树上，经过分裂、合并等修改为索引(a, b)。</p>
<h3 id="不需要建立前缀有包含关系的索引"><a href="#不需要建立前缀有包含关系的索引" class="headerlink" title="不需要建立前缀有包含关系的索引"></a>不需要建立前缀有包含关系的索引</h3><p>如果已有索引(a, b)，则不需要再建立索引(a)，但是如果有必要，则仍然需考虑建立索引(b)。</p>
<blockquote>
<p>作者：鸟不拉屎</p>
<p>来源：<a href="https://juejin.im/post/5d63348ae51d453b1e478ae3" target="_blank" rel="noopener">https://juejin.im/post/5d63348ae51d453b1e478ae3</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>理解JVM虚拟机</title>
    <url>/2019/12/26/%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="一-JVM内存区域的划分"><a href="#一-JVM内存区域的划分" class="headerlink" title="一. JVM内存区域的划分"></a>一. JVM内存区域的划分</h2><h3 id="1-1-java虚拟机运行时数据区"><a href="#1-1-java虚拟机运行时数据区" class="headerlink" title="1.1 java虚拟机运行时数据区"></a>1.1 java虚拟机运行时数据区</h3><p><strong>java虚拟机运行时数据区分布图：</strong></p>
<p><img src="http://image.winrains.cn/2019/08/20190829183219-8c64b.png" alt="img"></p>
<a id="more"></a>

<ul>
<li><strong>JVM栈（Java Virtual Machine Stacks）：</strong> Java中一个线程就会相应有一个线程栈与之对应，因为不同的线程执行逻辑有所不同，因此需要一个独立的线程栈，因此栈存储的信息都是跟当前线程（或程序）相关信息的，包括<strong>局部变量</strong>、<strong>程序运行状态</strong>、<strong>方法返回值</strong>、<strong>方法出口</strong>等等。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
<li><strong>堆（Heap）：</strong> 堆是所有线程共享的，主要是存放对象实例和数组。处于<strong>物理上不连续</strong>的内存空间，只要<strong>逻辑连续</strong>即可</li>
<li><strong>方法区（Method Area）：</strong> 属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</li>
<li><strong>常量池（Runtime Constant Pool）：</strong> 它是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。</li>
<li><strong>本地方法栈（Native Method Stacks）：</strong></li>
</ul>
<p>其中，<strong>堆(Heap)和JVM栈</strong>是<strong>程序运行的关键</strong>,因为：</p>
<ol>
<li>栈是运行时的单位（解决程序的运行问题，即程序如何执行，或者说如何处理数据），而堆是存储的单位（解决的是数据存储的问题，即数据怎么放、放在哪儿）。</li>
<li>堆存储的是对象。栈存储的是基本数据类型和堆中对象的引用；（参数传递的值传递和引用传递）</li>
</ol>
<p><strong>那为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？</strong></p>
<ol>
<li>从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据，分工明确，处理逻辑更为清晰体现了“分而治之”以及“隔离”的思想。</li>
<li>堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这样共享的方式有很多收益：提供了一种有效的数据交互方式(如：共享内存)；堆中的共享常量和缓存可以被所有栈访问，节省了空间。</li>
<li>栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。</li>
<li>堆和栈的结合完美体现了面向对象的设计。当我们将对象拆开，你会发现，对象的属性即是数据，存放在堆中；而对象的行为（方法）即是运行逻辑，放在栈中。因此编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。</li>
</ol>
<h3 id="1-2-堆-Heap-和JVM栈："><a href="#1-2-堆-Heap-和JVM栈：" class="headerlink" title="1.2 堆(Heap)和JVM栈："></a>1.2 堆(Heap)和JVM栈：</h3><h4 id="1-2-1-堆-Heap"><a href="#1-2-1-堆-Heap" class="headerlink" title="1.2.1 堆(Heap)"></a>1.2.1 堆(Heap)</h4><p><strong>Java堆</strong>是java虚拟机所管理内存中<strong>最大的一块内存空间</strong>，处于<strong>物理上不连续</strong>的内存空间，只要<strong>逻辑连续</strong>即可，主要用于存放各种类的实例对象。该区域被所有线程共享，在虚拟机启动时创建，用来存放对象的实例，几乎所有的对象以及数组都在这里分配内存（栈上分配、标量替换优化技术的例外）。<br>在 Java 中，堆被划分成两个不同的区域：<strong>新生代 ( Young )</strong>、<strong>老年代 ( Old )</strong>。<strong>新生代 ( Young )</strong> 又被划分为三个区域：<strong>Eden</strong>、<strong>From Survivor(S0)</strong>、<strong>To Survivor(S1)</strong>。如图所示：<br><strong>堆的内存布局:</strong></p>
<p><img src="http://image.winrains.cn/2019/08/20190829183221-9ca8c.png" alt="img"></p>
<p>这样划分的目的是为了使jvm能够更好的管理内存中的对象，包括内存的分配以及回收。 而新生代按eden和两个survivor的分法，是为了</p>
<ul>
<li>有效空间增大，eden+1个survivor；</li>
<li>有利于对象代的计算，当一个对象在S0/S1中达到设置的XX:MaxTenuringThreshold值后，会将其挪到老年代中，即只需扫描其中一个survivor。如果没有S0/S1,直接分成两个区，该如何计算对象经过了多少次GC还没被释放。</li>
<li>两个Survivor区可解决内存碎片化</li>
</ul>
<h4 id="1-2-2-堆栈相关的参数"><a href="#1-2-2-堆栈相关的参数" class="headerlink" title="1.2.2 堆栈相关的参数"></a>1.2.2 堆栈相关的参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms</td>
<td>堆内存初始大小，单位m、g</td>
</tr>
<tr>
<td>-Xmx</td>
<td>堆内存最大允许大小，一般不要大于物理内存的80%</td>
</tr>
<tr>
<td>-Xmn</td>
<td>年轻代内存初始大小</td>
</tr>
<tr>
<td>-Xss</td>
<td>每个线程的堆栈大小，即JVM栈的大小</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>年轻代(包括Eden和两个Survivor区)与年老代的比值</td>
</tr>
<tr>
<td>-XX:NewSzie(-Xns)</td>
<td>年轻代内存初始大小,可以缩写-Xns</td>
</tr>
<tr>
<td>-XX:MaxNewSize(-Xmx)</td>
<td>年轻代内存最大允许大小，可以缩写-Xmx</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>年轻代中Eden区与Survivor区的容量比例值，默认为8，即8:1</td>
</tr>
<tr>
<td>-XX:MinHeapFreeRatio</td>
<td>GC后，如果发现空闲堆内存占到整个预估堆内存的40%，则放大堆内存的预估最大值，但不超过固定最大值。</td>
</tr>
<tr>
<td>-XX:MaxHeapFreeRatio</td>
<td>预估堆内存是堆大小动态调控的重要选项之一。堆内存预估最大值一定小于或等于固定最大值(-Xmx指定的数值)。前者会根据使用情况动态调大或缩小，以提高GC回收的效率，默认70%</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>垃圾最大年龄，设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代。对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率</td>
</tr>
<tr>
<td>-XX:InitialTenuringThreshold</td>
<td>可以设定老年代阀值的初始值</td>
</tr>
<tr>
<td>-XX:+PrintTenuringDistribution</td>
<td>查看每次minor GC后新的存活周期的阈值</td>
</tr>
</tbody></table>
<p><strong>Note：</strong> 每次GC 后会调整堆的大小，为了<strong>防止动态调整带来的性能损耗</strong>，一般设置-<strong>Xms、-Xmx 相等</strong>。<br>新生代的三个设置参数：-Xmn，-XX:NewSize，-XX:NewRatio的优先级：<br>（1）.最高优先级： -XX:NewSize=1024m和-XX:MaxNewSize=1024m<br>（2）.次高优先级： -Xmn1024m （默认等效效果是：-XX:NewSize==-XX:MaxNewSize==1024m）<br>（3）.最低优先级：-XX:NewRatio=2<br>推荐使用的是-Xmn参数，原因是这个参数很简洁，相当于一次性设定NewSize和MaxNewSIze，而且两者相等。</p>
<h3 id="1-3-jvm对象"><a href="#1-3-jvm对象" class="headerlink" title="1.3 jvm对象"></a>1.3 jvm对象</h3><h4 id="1-3-1-创建对象的方式"><a href="#1-3-1-创建对象的方式" class="headerlink" title="1.3.1 创建对象的方式"></a>1.3.1 创建对象的方式</h4><p><img src="http://image.winrains.cn/2019/08/20190829183222-b1608.png" alt="img"></p>
<p>各个方式的实质操作如下：</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>实质</th>
</tr>
</thead>
<tbody><tr>
<td>使用new关键</td>
<td>调用无参或有参构造器函数创建</td>
</tr>
<tr>
<td>使用Class的newInstance方法</td>
<td>调用无参或有参构造器函数创建，且需要是public的构造函数</td>
</tr>
<tr>
<td>使用Constructor类的newInstance方法</td>
<td>调用有参和私有private构造器函数创建，实用性更广</td>
</tr>
<tr>
<td>使用Clone方法</td>
<td>不调用任何参构造器函数，且对象需要实现Cloneable接口并实现其定义的clone方法，且默认为浅复制</td>
</tr>
<tr>
<td>第三方库Objenesis</td>
<td>利用了asm字节码技术，动态生成Constructor对象</td>
</tr>
</tbody></table>
<h4 id="1-3-2-jvm对象分配"><a href="#1-3-2-jvm对象分配" class="headerlink" title="1.3.2 jvm对象分配"></a>1.3.2 jvm对象分配</h4><p>在虚拟机层面上创建对象的步骤：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829183222-54375.png" alt="img"></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>解析</th>
</tr>
</thead>
<tbody><tr>
<td>1、判断对象对应的类是否加载、链接、初始化</td>
<td>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。如果没有，那么必须先执行类的加载、解释、初始化（类的clinit方法）。</td>
</tr>
<tr>
<td>2、为对象分配内存</td>
<td>类加载检查通过后，虚拟机为新生对象分配内存。对象所需内存大小在类加载完成后便可以完全确定，为对象分配空间无非就是从Java堆中划分出一块确定大小的内存而已。</td>
</tr>
<tr>
<td>3、处理并发安全问题</td>
<td>另外一个问题及时保证new对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发问题。 虚拟机采用了两种方式解决并发问题: （1）CAS配上失败重试的方式保证指针更新操作的原子性; （2）TLAB 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区，（TLAB ，Thread Local Allocation Buffer）虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。</td>
</tr>
<tr>
<td>4、初始化分配到的空间</td>
<td>内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值</td>
</tr>
<tr>
<td>5、设置对象的对象头</td>
<td>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC分代年龄等数据存储在对象的对象头中</td>
</tr>
<tr>
<td>6、执行init方法进行初始化</td>
<td>在Java程序的视角看来，初始化才正式开始，开始调用方法完成初始赋值和构造函数，所有的字段都为零值。因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执 行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。</td>
</tr>
</tbody></table>
<h4 id="1-3-3-对象分配内存方式"><a href="#1-3-3-对象分配内存方式" class="headerlink" title="1.3.3 对象分配内存方式"></a>1.3.3 对象分配内存方式</h4><p><strong>分配对象内存</strong>，<strong>有两种分配方式</strong>，<strong>指针碰撞</strong>和<strong>空闲列表</strong>：<br>（1）如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Pointer）来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。 如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。 一般使用带有compact（整理）过程的收集器时，使用指针碰撞。<br>（2）如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为“空闲列表（Free List）”。<br><strong>Note：</strong> 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<h4 id="1-3-4-那什么样的对象能够进入老年代-Old"><a href="#1-3-4-那什么样的对象能够进入老年代-Old" class="headerlink" title="1.3.4 那什么样的对象能够进入老年代(Old)"></a>1.3.4 那什么样的对象能够进入老年代(Old)</h4><p><strong>那什么样的对象能够进入老年代(Old)？</strong></p>
<p><img src="http://image.winrains.cn/2019/08/20190829183223-9dcb9.png" alt="img"></p>
<h3 id="1-4-内存分配与回收策略"><a href="#1-4-内存分配与回收策略" class="headerlink" title="1.4 内存分配与回收策略"></a>1.4 内存分配与回收策略</h3><table>
<thead>
<tr>
<th>情况</th>
<th>解析</th>
</tr>
</thead>
<tbody><tr>
<td>1.对象优先在Eden分配</td>
<td>大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC；虚拟机提供了-XX:PrintGCDetails参数，发生垃圾回收时打印内存回收日志，并且在进程退出时输出当前内存各区域的分配情况。</td>
</tr>
<tr>
<td>2.大对象直接进入老年代</td>
<td>所谓的大对象就是指，需要大量连续内存空间的java对象，最典型的大对象就是那种很长的字符串及数组。虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值得对象直接在老年代中分配（这样做的目的是避免在Eden区及两个Survivor之间发生大量的内存拷贝）</td>
</tr>
<tr>
<td>3.长期存活的对象将直接进入老年代</td>
<td>对象年龄计数器。-XX:MaxTenuringThreshold</td>
</tr>
<tr>
<td>4、动态对象年龄判定</td>
<td>虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。</td>
</tr>
<tr>
<td>5、空间分配担保</td>
<td>在发生Minor GC时（前），虚拟机会检测之前每次晋升到老年代的平均大小（因为当次会有多少对象会存活是无法确定的，所以取之前的平均值/经验值）是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于，则查看HandlePromotionFailure设置是否允许担保失败；如果允许，那只会进行Minor GC；如果不允许，则也要改为进行一次Full GC。取平均值进行比较其实仍然是一种动态概率手段，也就是说如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure），这样会触发Full GC。</td>
</tr>
</tbody></table>
<h2 id="二-垃圾回收算法分类"><a href="#二-垃圾回收算法分类" class="headerlink" title="二 垃圾回收算法分类"></a>二 垃圾回收算法分类</h2><h3 id="2-1-引用"><a href="#2-1-引用" class="headerlink" title="2.1 引用"></a>2.1 引用</h3><p><img src="http://image.winrains.cn/2019/08/20190829183224-a964f.png" alt="img"></p>
<h3 id="2-2-GC-Root的对象"><a href="#2-2-GC-Root的对象" class="headerlink" title="2.2 GC Root的对象"></a>2.2 GC Root的对象</h3><p><img src="http://image.winrains.cn/2019/08/20190829183225-a0343.png" alt="img"></p>
<h3 id="2-3-标记-清除（Mark—Sweep）"><a href="#2-3-标记-清除（Mark—Sweep）" class="headerlink" title="2.3 标记-清除（Mark—Sweep）"></a>2.3 标记-清除（Mark—Sweep）</h3><p>被誉为现代垃圾回收算法的思想基础。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829183225-8ae9d.png" alt="img"></p>
<p><strong>标记-清除算法</strong>采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。</p>
<h3 id="2-4-复制算法（Copying）"><a href="#2-4-复制算法（Copying）" class="headerlink" title="2.4 复制算法（Copying）"></a>2.4 复制算法（Copying）</h3><p>该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。建立在存活对象少，垃圾对象多的前提下。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去后还能进行相应的内存整理，不会出现碎片问题。但缺点也是很明显，就是需要两倍内存空间。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829183226-687ca.png" alt="img"></p>
<p>它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象面和空闲区域面，在对象面与空闲区域面的切换过程中，程序暂停执行。</p>
<h3 id="2-5-标记-整理（或标记-压缩算法，Mark-Compact，又或者叫标记清除压缩MarkSweepCompact）"><a href="#2-5-标记-整理（或标记-压缩算法，Mark-Compact，又或者叫标记清除压缩MarkSweepCompact）" class="headerlink" title="2.5 标记-整理（或标记-压缩算法，Mark-Compact，又或者叫标记清除压缩MarkSweepCompact）"></a>2.5 标记-整理（或标记-压缩算法，Mark-Compact，又或者叫标记清除压缩MarkSweepCompact）</h3><p>此算法是结合了“标记-清除”和“复制算法”两个算法的优点。避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829183226-4c3a5.png" alt="img"></p>
<p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。</p>
<h3 id="2-6-分代回收策略（Generational-Collecting）"><a href="#2-6-分代回收策略（Generational-Collecting）" class="headerlink" title="2.6 分代回收策略（Generational Collecting）"></a>2.6 分代回收策略（Generational Collecting）</h3><p>基于这样的事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。<br>新生代由于其对象存活时间短，且需要经常gc，因此采用效率较高的复制算法，其将内存区分为一个eden区和两个suvivor区，默认eden区和survivor区的比例是8:1，分配内存时先分配eden区，当eden区满时，使用复制算法进行gc，将存活对象复制到一个survivor区，当一个survivor区满时，将其存活对象复制到另一个区中，当对象存活时间大于某一阈值时，将其放入老年代。老年代和永久代因为其存活对象时间长，因此使用标记清除或标记整理算法<br><strong>总结：</strong></p>
<ul>
<li>新生代：复制算法（新生代回收的频率很高，每次回收的耗时很短，为了支持高频率的新生代回收，虚拟机可能使用一种叫做卡表（Card Table）的数据结构，卡表为一个比特位集合，每个比特位可以用来表示老年代的某一区域中的所有对象是否持有新生代对,</li>
</ul>
<h3 id="2-7-垃圾回收器"><a href="#2-7-垃圾回收器" class="headerlink" title="2.7 垃圾回收器"></a>2.7 垃圾回收器</h3><p><img src="http://image.winrains.cn/2019/08/20190829183227-3e6e1.png" alt="img"></p>
<p><strong>垃圾回收器</strong>的任务是识别和回收垃圾对象进行内存清理，不同代可使用不同的收集器：</p>
<ul>
<li><strong>新生代收集器</strong>使用的收集器：<strong>Serial、ParNew、Parallel Scavenge</strong>；</li>
<li><strong>老年代收集器</strong>使用的收集器：<strong>Serial Old（MSC）、Parallel Old、CMS。</strong></li>
</ul>
<p><strong>总结：</strong></p>
<ol>
<li><strong>Serial old和新生代的所有回收器都能搭配；也可以作为CMS回收器的备用回收器；</strong></li>
<li><strong>CMS只能和新生代的Serial和ParNew搭配，而且ParNew是CMS默认的新生代回收器；</strong></li>
<li><strong>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态</strong></li>
<li><strong>并发（Concurrent）：指用户线程和垃圾收集线程同时执行（但不一定是并行的，可能是交替执行），用户程序继续运行，而垃圾收集程序运行在另外的CPU上。</strong></li>
</ol>
<h2 id="三-GC的执行机制"><a href="#三-GC的执行机制" class="headerlink" title="三. GC的执行机制"></a>三. GC的执行机制</h2><p>Java 中的<strong>堆(deap)</strong> 也是 GC 收集垃圾的主要区域。 由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：<strong>Scavenge GC（Minor GC）和Full GC（Major GC）</strong>。</p>
<ul>
<li><strong>Scavenge GC(Minor GC):</strong> 一般情况下，当新对象生成（age=0），并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区（age+1）。然后整理（其实是复制过去就顺便整理了）Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法（即复制-清理算法），使Eden去能尽快空闲出来。Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。</li>
<li><strong>Full GC:</strong> 对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。</li>
</ul>
<h3 id="3-1-触发Full-GC执行的场景"><a href="#3-1-触发Full-GC执行的场景" class="headerlink" title="3.1 触发Full GC执行的场景"></a>3.1 触发Full GC执行的场景</h3><p><img src="http://image.winrains.cn/2019/08/20190829183228-85964.png" alt="img"></p>
<h3 id="3-2-Young-GC触发条件"><a href="#3-2-Young-GC触发条件" class="headerlink" title="3.2 Young GC触发条件"></a>3.2 Young GC触发条件</h3><p><img src="http://image.winrains.cn/2019/08/20190829183229-c67c1.png" alt="img"></p>
<h3 id="3-3-新生对象GC收回流程"><a href="#3-3-新生对象GC收回流程" class="headerlink" title="3.3 新生对象GC收回流程"></a>3.3 新生对象GC收回流程</h3><p>基于大多数新生对象都会在GC中被收回的假设。新生代的GC 使用复制算法，（将年轻代分为3部分，主要是为了生命周期短的对象尽量留在年轻代。老年代主要存放生命周期比较长的对象，比如缓存）。可能经历过程：</p>
<ol>
<li><strong>对象创建时，一般在Eden区完成内存分配（有特殊）；</strong></li>
<li><strong>当Eden区满了，再创建对象，会因为申请不到空间，触发minorGC，进行young(eden+1survivor)区的垃圾回收；</strong></li>
<li><strong>minorGC时，Eden和survivor A不能被GC回收且年龄没有达到阈值（tenuring threshold）的对象，会被放入survivor B，始终保证一个survivor是空的；</strong></li>
<li><strong>当做第3步的时候，如果发现survivor满了，将这些对象copy到old区（分配担保机制）；或者survivor并没有满，但是有些对象已经足够Old，也被放入Old区 XX:MaxTenuringThreshold；（回顾下对象进入老年代的情况）</strong></li>
<li><strong>直接清空eden和survivor A；</strong></li>
<li><strong>当Old区被放满的之后，进行fullGC。</strong></li>
</ol>
<h3 id="3-4-GC日志"><a href="#3-4-GC日志" class="headerlink" title="3.4 GC日志"></a>3.4 GC日志</h3><p><strong>GC日志相关参数:</strong></p>
<ul>
<li>-XX:+PrintGC：输出GC日志</li>
<li>-XX:+PrintGCDetails：输出GC的详细日志</li>
<li>-XX:+PrintGCTimeStamps：输出GC的时间戳（以基准时间的形式）</li>
<li>-XX:+PrintGCApplicationStoppedTime：打印垃圾回收期间程序暂停的时间</li>
<li>-XX:+PrintGCApplicationConcurrentTime：打印每次垃圾回收前，程序未中断的执行时间</li>
<li>-XX:+PrintHeapAtGC：在进行GC的前后打印出堆的信息</li>
<li>-XX:+PrintTLAB：查看TLAB空间的使用情况</li>
<li>-XX:PrintTenuingDistribution：查看每次minor GC后新的存活周期的阈值</li>
<li>-XX:PrintReferenceFC：用来跟踪系统内的(softReference)软引用，(weadReference)弱引用,(phantomReference)虚引用，显示引用过程</li>
</ul>
<p>案例分析：-XX:+PrintGCApplicationStoppedTime -XX:+PrintGCApplicationConcurrentTime一起使用</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Application <span class="built_in">time</span>: <span class="number">0.3440086</span> <span class="built_in">seconds</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which application threads were stopped: <span class="number">0.0620105</span> <span class="built_in">seconds</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Application <span class="built_in">time</span>: <span class="number">0.2100691</span> <span class="built_in">seconds</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which application threads were stopped: <span class="number">0.0890223</span> <span class="built_in">seconds</span></span></pre></td></tr></table></figure>

<p>得知应用程序在前344毫秒中是在处理实际工作的，然后将所有线程暂停了62毫秒，紧接着又工作了210ms，然后又暂停了89ms。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2796146</span>K-&gt;<span class="number">2049</span>K(<span class="number">1784832</span>K)] <span class="number">4171400</span>K-&gt;<span class="number">2049</span>K(<span class="number">3171840</span>K), [Metaspace: <span class="number">3134</span>K-&gt;<span class="number">3134</span>K(<span class="number">1056768</span>K)], <span class="number">0.0571841</span> secs] [Times: user=<span class="number">0.02</span> sys=<span class="number">0.04</span>, real=<span class="number">0.06</span> secs]</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total time <span class="keyword">for</span> which application threads were stopped: <span class="number">0.0572646</span> seconds, Stopping threads took: <span class="number">0.0000088</span> seconds</span></pre></td></tr></table></figure>

<p>应用线程被强制暂停了57ms来进行垃圾回收。其中又有8ms是用来等待所有的应用线程都到达安全点。<br>只要设置-XX:+PrintGCDetails 就会自动带上-verbose:gc和-XX:+PrintGC</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">33.125</span>: [GC [DefNew: <span class="number">3324</span>K-&gt;<span class="number">152</span>K(<span class="number">3712</span>K), <span class="number">0.0025925</span> secs] <span class="number">3324</span>K-&gt;<span class="number">152</span>K(<span class="number">11904</span>K), <span class="number">0.0031680</span> secs]</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">100.667</span>: [Full GC [Tenured: <span class="number">0</span>K-&gt;<span class="number">210</span>K(<span class="number">10240</span>K), <span class="number">0.0149142</span> secs] <span class="number">4603</span>K-&gt;<span class="number">210</span>K(<span class="number">19456</span>K), [Perm : <span class="number">2999</span>K-&gt;<span class="number">2999</span>K(<span class="number">21248</span>K)], <span class="number">0.0150007</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs]</span></pre></td></tr></table></figure>

<ol>
<li>最前面的数字“33.125：”和“100.667：”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。</li>
<li>GC日志开头的“［GC”和“［Full GC”说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有“Full”，说明这次GC是发生了Stop-The-World的。</li>
<li>接下来的“［DefNew”、“［Tenured”、“［Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的，例如上面样例所使用的Serial收集器中的新生代名为“Default New Generation”，所以显示的是“［DefNew”。如果是ParNew收集器，新生代名称就会变为“［ParNew”，意为“Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代称为“PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。</li>
<li>后面方括号内部的“3324K-&gt;152K(3712K)”含义是“GC前该内存区域已使用容量-&gt; GC后该内存区域已使用容量 (该内存区域总容量)”。而在方括号之外的“3324K-&gt;152K(11904K)”表示“GC前Java堆已使用容量 -&gt; GC后Java堆已使用容量 (Java堆总容量)”。</li>
<li>再往后，“0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据</li>
<li>[Full GC 283.736: [ParNew: 261599K-&gt;261599K(261952K), 0.0000288 secs] 新生代收集器ParNew的日志也会出现“［Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc()方法所触发的收集，那么在这里将显示“［Full GC (System)”。</li>
</ol>
<h3 id="3-5-减少GC开销的措施"><a href="#3-5-减少GC开销的措施" class="headerlink" title="3.5 减少GC开销的措施"></a>3.5 减少GC开销的措施</h3><p>从代码上：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829183230-18b22.png" alt="img"></p>
<p>从JVM参数上调优上：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829183231-7f999.png" alt="img"></p>
<h3 id="3-6-内存溢出分类"><a href="#3-6-内存溢出分类" class="headerlink" title="3.6 内存溢出分类"></a>3.6 内存溢出分类</h3><p><img src="http://image.winrains.cn/2019/08/20190829183232-a9393.png" alt="img"></p>
<h2 id="四-总结-JVM调优相关"><a href="#四-总结-JVM调优相关" class="headerlink" title="四. 总结-JVM调优相关"></a>四. 总结-JVM调优相关</h2><h3 id="4-1-调优目的"><a href="#4-1-调优目的" class="headerlink" title="4.1 调优目的"></a>4.1 调优目的</h3><p><img src="http://image.winrains.cn/2019/08/20190829183233-1dbfb.png" alt="img"></p>
<h3 id="4-2-JVM性能调优所处的层次"><a href="#4-2-JVM性能调优所处的层次" class="headerlink" title="4.2 JVM性能调优所处的层次"></a>4.2 JVM性能调优所处的层次</h3><p><img src="http://image.winrains.cn/2019/08/20190829183233-87064.png" alt="img"></p>
<h3 id="4-3-JVM调优流程"><a href="#4-3-JVM调优流程" class="headerlink" title="4.3 JVM调优流程"></a>4.3 JVM调优流程</h3><p><img src="http://image.winrains.cn/2019/08/20190829183234-4caaa.png" alt="img"></p>
<h3 id="4-4-性能监控工具"><a href="#4-4-性能监控工具" class="headerlink" title="4.4 性能监控工具"></a>4.4 性能监控工具</h3><p><img src="http://image.winrains.cn/2019/08/20190829183234-b5031.png" alt="img"></p>
<p>调优的最终目的都是为了令应用程序使用最小的硬件消耗来承载更大的吞吐。jvm的调优也不例外，jvm调优主要是针对垃圾收集器的收集性能优化，令运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量。</p>
<blockquote>
<p>作者：Ccww</p>
<p>来源：<a href="https://juejin.im/post/5d200b54f265da1bac40384a" target="_blank" rel="noopener">https://juejin.im/post/5d200b54f265da1bac40384a</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>小而美的Shiro安全框架</title>
    <url>/2019/12/26/%E5%B0%8F%E8%80%8C%E7%BE%8E%E7%9A%84Shiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在一款应用的整个生命周期，我们都会谈及该应用的数据安全问题。用户的合法性与数据的可见性是数据安全中非常重要的一部分。但是，一方面，不同的应用对于数据的合法性和可见性要求的维度与粒度都有所区别；另一方面，以当前微服务、多服务的架构方式，如何共享Session，如何缓存认证和授权数据应对高并发访问都迫切需要我们解决。Shiro的出现让我们可以快速和简单的应对我们应用的数据安全问题。</p>
<a id="more"></a>

<h2 id="Shiro介绍"><a href="#Shiro介绍" class="headerlink" title="Shiro介绍"></a>Shiro介绍</h2><h3 id="Shiro简介"><a href="#Shiro简介" class="headerlink" title="Shiro简介"></a>Shiro简介</h3><p>这个官网解释不抽象，所以直接用官网解释：Apache Shiro™是一个强大且易用的 Java 安全框架，可以执行身份验证、授权、加密和会话管理等。基于 Shiro 的易于理解的API，您可以快速、轻松地使任何应用程序变得安全（从最小的移动应用到最大的网络和企业应用）。<br>谈及安全，多数 Java 开发人员都离不开 Spring 框架的支持，自然也就会先想到 Spring Security，那我们先来看二者的差别</p>
<table>
<thead>
<tr>
<th>Shiro</th>
<th>Spring Security</th>
</tr>
</thead>
<tbody><tr>
<td>简单、灵活</td>
<td>复杂、笨重</td>
</tr>
<tr>
<td>可脱离Spring</td>
<td>不可脱离Spring</td>
</tr>
<tr>
<td>粒度较粗</td>
<td>粒度较细</td>
</tr>
</tbody></table>
<p>虽然 Spring Security 属于名震中外 Spring 家族的一部分，但是了解 Shiro 之后，你不会想 “嫁入豪门”，而是选择追求「诗和远方」冲动。<br>横看成岭侧成峰，远近高低各不同 (依旧是先了解概念就好)</p>
<h3 id="远看-Shiro-看轮廓"><a href="#远看-Shiro-看轮廓" class="headerlink" title="远看 Shiro 看轮廓"></a>远看 Shiro 看轮廓</h3><p><img src="http://image.winrains.cn/2019/08/20190829192223-d2934.png" alt="img"></p>
<h4 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h4><p>它是一个主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者</p>
<h4 id="SecurityManager"><a href="#SecurityManager" class="headerlink" title="SecurityManager"></a>SecurityManager</h4><p>安全管理器；即所有与安全有关的操作都会与 SecurityManager 交互；且它管理着所有 Subject；可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet前端控制器</p>
<h4 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h4><p>域，Shiro 从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。</p>
<h3 id="近看-Shiro-看细节"><a href="#近看-Shiro-看细节" class="headerlink" title="近看 Shiro 看细节"></a>近看 Shiro 看细节</h3><p>看图瞬间懵逼？别慌，会为你拆解来看，结合着图看下面的解释，这不是啥大问题，且看:</p>
<p><img src="http://image.winrains.cn/2019/08/20190829192224-bcb0d.png" alt="img"></p>
<h4 id="Subject-1"><a href="#Subject-1" class="headerlink" title="Subject"></a>Subject</h4><p>主体，可以看到主体可以是任何可以与应用交互的 “用户”</p>
<h4 id="SecurityManager-1"><a href="#SecurityManager-1" class="headerlink" title="SecurityManager"></a>SecurityManager</h4><p>相当于 SpringMVC 中的 DispatcherServlet；是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理</p>
<h4 id="Authenticator"><a href="#Authenticator" class="headerlink" title="Authenticator"></a>Authenticator</h4><p>认证器，负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；需要自定义认证策略（Authentication Strategy），即什么情况下算用户认证通过了</p>
<h4 id="Authrizer"><a href="#Authrizer" class="headerlink" title="Authrizer"></a>Authrizer</h4><p>授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能</p>
<h4 id="Realm-1"><a href="#Realm-1" class="headerlink" title="Realm"></a>Realm</h4><p>可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC实现，也可以是LDAP实现，或者内存实现等等；由用户提供；注意：Shiro 不知道你的用户/权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的Realm</p>
<h4 id="SessionManager"><a href="#SessionManager" class="headerlink" title="SessionManager"></a>SessionManager</h4><p>如果写过 Servlet 就应该知道 Session 的概念，Session 需要有人去管理它的生命周期，这个组件就是 SessionManager；而Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境、EJB等环境；所以，Shiro 就抽象了一个自己的Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台Web服务器；接着又上了台EJB 服务器；这时又想把两台服务器的会话数据放到一个地方，我们就可以实现自己的分布式会话（如把数据放到Memcached 服务器）</p>
<h4 id="SessionDAO"><a href="#SessionDAO" class="headerlink" title="SessionDAO"></a>SessionDAO</h4><p>DAO大家都用过，数据访问对象，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的SessionDAO，通过如JDBC写到数据库；比如想把 Session 放到 Memcached 中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能；</p>
<h4 id="CacheManager"><a href="#CacheManager" class="headerlink" title="CacheManager"></a>CacheManager</h4><p>缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能</p>
<h4 id="Cryptography"><a href="#Cryptography" class="headerlink" title="Cryptography"></a>Cryptography</h4><p>密码模块，Shiro提高了一些常见的加密组件用于如密码「加密/解密」的<br><strong>注意上图的结构，我们会根据这张图来逐步拆分讲解，记住这张图也更有助于我们理解 Shiro 的工作原理</strong>，所以依旧是打开两个网页一起看就好喽</p>
<h2 id="搭建概览"><a href="#搭建概览" class="headerlink" title="搭建概览"></a>搭建概览</h2><p>多数小伙伴都在使用 Spring Boot， Shiro 也很应景的定义了 starter，做了更好的封装，对于我们来说使用起来也就更加方便，来看选型概览</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Springboot</td>
<td>2.0.4</td>
</tr>
<tr>
<td>2</td>
<td>JPA</td>
<td>2.0.4</td>
</tr>
<tr>
<td>3</td>
<td>Mysql</td>
<td>8.0.12</td>
</tr>
<tr>
<td>4</td>
<td>Redis</td>
<td>2.0.4</td>
</tr>
<tr>
<td>5</td>
<td>Lombok</td>
<td>1.16.22</td>
</tr>
<tr>
<td>6</td>
<td>Guava</td>
<td>26.0-jre</td>
</tr>
<tr>
<td>7</td>
<td>Shiro</td>
<td>1.4.0</td>
</tr>
</tbody></table>
<p>使用 Spring Boot，大多都是通过添加 starter 依赖，会自动解决依赖包版本，所以自己尝试的时候用最新版本不会有什么问题，比如 Shiro 现在的版本是 1.5.0 了，整体问题不大，大家自行尝试就好</p>
<h3 id="添加-Gradle-依赖管理"><a href="#添加-Gradle-依赖管理" class="headerlink" title="添加 Gradle 依赖管理"></a>添加 Gradle 依赖管理</h3><p><img src="http://image.winrains.cn/2019/10/20191025224019-68039.png" alt="img"></p>
<h3 id="大体目录结构"><a href="#大体目录结构" class="headerlink" title="大体目录结构"></a>大体目录结构</h3><p><img src="http://image.winrains.cn/2019/10/20191025224022-423fe.png" alt="img"></p>
<h3 id="application-yml-配置"><a href="#application-yml-配置" class="headerlink" title="application.yml 配置"></a>application.yml 配置</h3><p><img src="http://image.winrains.cn/2019/10/20191025224023-262fc.png" alt="img"></p>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p><img src="http://image.winrains.cn/2019/10/20191025224025-d9011.png" alt="img"></p>
<p>你就让我看这？这只是一个概览，先做到心中有数，我们来看具体配置，逐步完成搭建<br>其中 shiroFilter bean 部分指定了拦截路径和相应的过滤器，”/user/login”, ”/user”, ”/user/loginout” 可以匿名访问，其他路径都需要授权访问，shiro 提供和多个默认的过滤器，我们可以用这些过滤器来配置控制指定url的权限(先了解个大概即可)：</p>
<table>
<thead>
<tr>
<th>配置缩写</th>
<th>对应的过滤器</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>anon</td>
<td>AnonymousFilter</td>
<td>指定url可以匿名访问</td>
</tr>
<tr>
<td>authc</td>
<td>FormAuthenticationFilter</td>
<td>指定url需要form表单登录，默认会从请求中获取username、password,rememberMe等参数并尝试登录，如果登录不了就会跳转到loginUrl配置的路径。我们也可以用这个过滤器做默认的登录逻辑，但是一般都是我们自己在控制器写登录逻辑的，自己写的话出错返回的信息都可以定制嘛。</td>
</tr>
<tr>
<td>authcBasic</td>
<td>BasicHttpAuthenticationFilter</td>
<td>指定url需要basic登录</td>
</tr>
<tr>
<td>Logout</td>
<td>LogoutFilter</td>
<td>登出过滤器，配置指定url就可以实现退出功能，非常方便</td>
</tr>
<tr>
<td>noSessionCreation</td>
<td>NoSessionCreationFilter</td>
<td>禁止创建会话</td>
</tr>
<tr>
<td>perms</td>
<td>PermissionsAuthorizationFilter</td>
<td>需要指定权限才能访问</td>
</tr>
<tr>
<td>port</td>
<td>PortFilter</td>
<td>需要指定端口才能访问</td>
</tr>
<tr>
<td>rest</td>
<td>HttpMethodPermissionFilter</td>
<td>将http请求方法转化成相应的动词来构造一个权限字符串，这个感觉意义不大，有兴趣自己看源码的注释</td>
</tr>
<tr>
<td>roles</td>
<td>RolesAuthorizationFilter</td>
<td>需要指定角色才能访问</td>
</tr>
<tr>
<td>ssl</td>
<td>SslFilter</td>
<td>需要https请求才能访问</td>
</tr>
<tr>
<td>user</td>
<td>UserFilter</td>
<td>需要已登录或“记住我”的用户才能访问</td>
</tr>
</tbody></table>
<h3 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h3><p>数据库表设计请参考 entity package下的 bean，通过@Entity 注解与 JPA 的设置自动生成表结构 (你需要简单的了解一下 JPA 的功能)。<br>我们要说重点啦～～～</p>
<h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><p>身份认证是一个证明 “李雷是李雷，韩梅梅是韩梅梅” 的过程，回看上图，Realm 模块就是用来做这件事的，Shiro 提供了 IniRealm，JdbcReaml，LDAPReam等认证方式，但自定义的 Realm 通常是最适合我们业务需要的，认证通常是校验登录用户是否合法。</p>
<h3 id="新建用户-User"><a href="#新建用户-User" class="headerlink" title="新建用户 User"></a>新建用户 User</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Id</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@GeneratedValue</span>(strategy=GenerationType.AUTO)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Long id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(unique =true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String username;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">String</span> <span class="selector-tag">password</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">String</span> <span class="selector-tag">salt</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="定义-Repository"><a href="#定义-Repository" class="headerlink" title="定义 Repository"></a>定义 Repository</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">@Repository</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">UserRepository</span> <span class="symbol">extends</span> <span class="symbol">JpaRepository</span>&lt;<span class="symbol">User</span>, <span class="symbol">Long</span>&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> User findUserByUsername(String username);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="编写UserController："><a href="#编写UserController：" class="headerlink" title="编写UserController："></a>编写UserController：</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@<span class="constructor">GetMapping(<span class="string">"/login"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public void login(String username, String password) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UsernamePasswordToken token = <span class="keyword">new</span> <span class="constructor">UsernamePasswordToken(<span class="params">username</span>, <span class="params">password</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    token.set<span class="constructor">RememberMe(<span class="params">true</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Subject currentUser = <span class="module-access"><span class="module"><span class="identifier">SecurityUtils</span>.</span></span>get<span class="constructor">Subject()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    currentUser.login(token);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="自定义-Realm"><a href="#自定义-Realm" class="headerlink" title="自定义 Realm"></a>自定义 Realm</h3><p>自定义 Realm，主要是为了重写 doGetAuthenticationInfo(…)方法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">protected AuthenticationInfo <span class="keyword">do</span><span class="constructor">GetAuthenticationInfo(AuthenticationToken <span class="params">authenticationToken</span>)</span> throws AuthenticationException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    String username = token.get<span class="constructor">Username()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    User user = userRepository.find<span class="constructor">UserByUsername(<span class="params">username</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    SimpleAuthenticationInfo simpleAuthenticationInfo = <span class="keyword">new</span> <span class="constructor">SimpleAuthenticationInfo(<span class="params">user</span>, <span class="params">user</span>.<span class="params">getPassword</span>()</span>, get<span class="constructor">Name()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    simpleAuthenticationInfo.set<span class="constructor">CredentialsSalt(ByteSource.Util.<span class="params">bytes</span>(<span class="params">user</span>.<span class="params">getSalt</span>()</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return simpleAuthenticationInfo;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这些代码我需要做一个说明，你可能也满肚子疑惑:</p>
<ol>
<li>这段代码怎么应用了 shiro？</li>
<li>controller 是怎么调用到 custom realm 的？</li>
<li>重写的 doGetAuthenticationInfo(…) 方法目的是什么？</li>
</ol>
<h3 id="认证流程说明"><a href="#认证流程说明" class="headerlink" title="认证流程说明"></a>认证流程说明</h3><p>用户访问<code>/user/login</code> 路径，生成 UsernamePasswordToken, 通过SecurityUtils.getSubject()获取Subject（currentUser），调用 login 方法进行验证，让我们跟踪一下代码，瞧一瞧就知道自定义的CustomRealm怎样起作用的，一起来看源码：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829192228-5bb11.png" alt="img"></p>
<p>到这里我们要停一停了，请回看 Shiro 近景图，将源码追踪路径与其对比，是完全一致的</p>
<h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>身份认证是验证你是谁的问题，而授权是你能干什么的问题，</p>
<blockquote>
<p>产品经理：申购模块只能科室看 程序员：好的 产品经理：科长权限大一些，他也能看申购模块 程序员：好的(黑脸) 产品经理：科长不但能看，还能修改数据 程序员：关公提大刀，拿命来 …</p>
</blockquote>
<p>作为程序员，我们的宗旨是：「能动手就不吵吵」; 硝烟怒火拔地起，耳边响起驼铃声（Shiro）：「放下屠刀，立地成佛」授权没有那么麻烦，大家好商量…<br>整个过程和身份认证基本是一毛一样，你对比看看</p>
<h3 id="角色实体创建"><a href="#角色实体创建" class="headerlink" title="角色实体创建"></a>角色实体创建</h3><p>涉及到授权，自然要和角色相关，所以我们创建 Role 实体:</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class Role &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Id</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@GeneratedValue</span>(strategy=GenerationType.AUTO)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Long id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(unique =true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String roleCode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">String</span> <span class="selector-tag">roleName</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="新建-Role-Repository"><a href="#新建-Role-Repository" class="headerlink" title="新建 Role Repository"></a>新建 Role Repository</h3><figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">@Repository</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RoleRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Role</span>, <span class="title">Long</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Query(value = <span class="string">"select roleId from UserRoleRel ur where ur.userId = ?1"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">List</span>&lt;<span class="keyword">Long</span>&gt; findUserRole(<span class="keyword">Long</span> userId);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">List</span>&lt;Role&gt; findByIdIn(<span class="keyword">List</span>&lt;<span class="keyword">Long</span>&gt; ids);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="定义权限实体-Permission"><a href="#定义权限实体-Permission" class="headerlink" title="定义权限实体 Permission"></a>定义权限实体 Permission</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class Permission &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Id</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@GeneratedValue</span>(strategy=GenerationType.AUTO)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Long id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Column</span>(unique =true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String permCode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">String</span> <span class="selector-tag">permName</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="定义-Permission-Repository"><a href="#定义-Permission-Repository" class="headerlink" title="定义 Permission Repository"></a>定义 Permission Repository</h3><figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">@Repository</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PermissionRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Permission</span>, <span class="title">Long</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Query(value = <span class="string">"select permId from RolePermRel pr where pr.roleId in ?1"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">List</span>&lt;<span class="keyword">Long</span>&gt; findRolePerm(<span class="keyword">List</span>&lt;<span class="keyword">Long</span>&gt; roleIds);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">List</span>&lt;Permission&gt; findByIdIn(<span class="keyword">List</span>&lt;<span class="keyword">Long</span>&gt; ids);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="建立用户与角色关系"><a href="#建立用户与角色关系" class="headerlink" title="建立用户与角色关系"></a>建立用户与角色关系</h3><p>其实可以通过 JPA 注解来制定关系的，这里为了说明问题，以单独外键形式说明</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class UserRoleRel &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Id</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@GeneratedValue</span>(strategy=GenerationType.AUTO)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Long id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">Long</span> <span class="selector-tag">userId</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">Long</span> <span class="selector-tag">roleId</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="建立角色与权限关系"><a href="#建立角色与权限关系" class="headerlink" title="建立角色与权限关系"></a>建立角色与权限关系</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class RolePermRel &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@Id</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="variable">@GeneratedValue</span>(strategy=GenerationType.AUTO)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Long id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">Long</span> <span class="selector-tag">permId</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">Long</span> <span class="selector-tag">roleId</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="编写-UserController"><a href="#编写-UserController" class="headerlink" title="编写 UserController"></a>编写 UserController</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequiresPermissions</span>(<span class="string">"user:list:view"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">getAllUsers</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;User&gt; users = userRepository.findAll();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>@RequiresPermissions(&quot;user:list:view&quot;)</code> 注解说明具有用户：列表：查看权限的才可以访问），官网明确给出权限定义格式，包括通配符等，我希望你自行去查看<br>自定义 CustomRealm (主要重写 doGetAuthorizationInfo) 方法:</p>
<p><img src="http://image.winrains.cn/2019/10/20191025224030-8db56.png" alt="img"></p>
<p>与认证流程如出一辙，只不过多了用户，角色，权限的关系罢了</p>
<h3 id="授权流程说明"><a href="#授权流程说明" class="headerlink" title="授权流程说明"></a>授权流程说明</h3><p>这里通过过滤器（见Shiro配置）和注解二者结合的方式来进行授权，和认证流程一样，最终会走到我们自定义的 CustomRealm 中，同样 Shiro 默认提供了许多注解用来处理不同的授权情况</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>@RequiresGuest</td>
<td>只有游客可以访问</td>
</tr>
<tr>
<td>@RequiresAuthentication</td>
<td>需要登录才能访问</td>
</tr>
<tr>
<td>@RequiresUser</td>
<td>已登录的用户或“记住我”的用户能访问</td>
</tr>
<tr>
<td>@RequiresRoles</td>
<td>已登录的用户需具有指定的角色才能访问</td>
</tr>
<tr>
<td>@RequiresPermissions</td>
<td>已登录的用户需具有指定的权限才能访问（如果不想和产品经理华山论剑，推荐用这个注解）</td>
</tr>
</tbody></table>
<p>授权官网给出明确的授权策略与案例，请查看：<a href="https://link.juejin.im?target=http%3A%2F%2Fshiro.apache.org%2Fpermissions.html">shiro.apache.org/permissions…</a><br>上面的例子我们通过一直在通过访问 Mysql 获取用户认证和授权信息，这中方式明显不符合生产环境的需求</p>
<h2 id="Session会话管理"><a href="#Session会话管理" class="headerlink" title="Session会话管理"></a>Session会话管理</h2><p>做过 Web 开发的同学都知道 Session 的概念，最常用的是 Session 过期时间，数据在 Session 的 CRUD，同样看上图，我们需要关注 SessionManager 和 SessionDAO 模块，Shiro starter 已经提供了基本的 Session配置信息，我们按需在YAML中配置就好（官网<a href="https://shiro.apache.org/spring-boot.html" target="_blank" rel="noopener">https://shiro.apache.org/spring-boot.html</a> 已经明确给出Session的配置信息）</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Default Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>shiro.enabled</td>
<td>true</td>
<td>Enables Shiro’s Spring module</td>
</tr>
<tr>
<td>shiro.web.enabled</td>
<td>true</td>
<td>Enables Shiro’s Spring web module</td>
</tr>
<tr>
<td>shiro.annotations.enabled</td>
<td>true</td>
<td>Enables Spring support for Shiro’s annotations</td>
</tr>
<tr>
<td>shiro.sessionManager.deleteInvalidSessions</td>
<td>true</td>
<td>Remove invalid session from session storage</td>
</tr>
<tr>
<td>shiro.sessionManager.sessionIdCookieEnabled</td>
<td>true</td>
<td>Enable session ID to cookie, for session tracking</td>
</tr>
<tr>
<td>shiro.sessionManager.sessionIdUrlRewritingEnabled</td>
<td>true</td>
<td>Enable session URL rewriting support</td>
</tr>
<tr>
<td>shiro.userNativeSessionManager</td>
<td>false</td>
<td>If enabled Shiro will manage the HTTP sessions instead of the container</td>
</tr>
<tr>
<td>shiro.sessionManager.cookie.name</td>
<td>JSESSIONID</td>
<td>Session cookie name</td>
</tr>
<tr>
<td>shiro.sessionManager.cookie.maxAge</td>
<td>-1</td>
<td>Session cookie max age</td>
</tr>
<tr>
<td>shiro.sessionManager.cookie.domain</td>
<td>null</td>
<td>Session cookie domain</td>
</tr>
<tr>
<td>shiro.sessionManager.cookie.path</td>
<td>null</td>
<td>Session cookie path</td>
</tr>
<tr>
<td>shiro.sessionManager.cookie.secure</td>
<td>false</td>
<td>Session cookie secure flag</td>
</tr>
<tr>
<td>shiro.rememberMeManager.cookie.name</td>
<td>rememberMe</td>
<td>RememberMe cookie name</td>
</tr>
<tr>
<td>shiro.rememberMeManager.cookie.maxAge</td>
<td>one year</td>
<td>RememberMe cookie max age</td>
</tr>
<tr>
<td>shiro.rememberMeManager.cookie.domain</td>
<td>null</td>
<td>RememberMe cookie domain</td>
</tr>
<tr>
<td>shiro.rememberMeManager.cookie.path</td>
<td>null</td>
<td>RememberMe cookie path</td>
</tr>
<tr>
<td>shiro.rememberMeManager.cookie.secure</td>
<td>false</td>
<td>RememberMe cookie secure flag</td>
</tr>
<tr>
<td>shiro.loginUrl</td>
<td>/login.jsp</td>
<td>Login URL used when unauthenticated users are redirected to login page</td>
</tr>
<tr>
<td>shiro.successUrl</td>
<td>/</td>
<td>Default landing page after a user logs in (if alternative cannot be found in the current session)</td>
</tr>
<tr>
<td>shiro.unauthorizedUrl</td>
<td>null</td>
<td>Page to redirect user to if they are unauthorized (403 page)</td>
</tr>
</tbody></table>
<p>分布式服务中，我们通常需要将Session信息放入Redis中来管理，来应对高并发的访问需求，这时只需重写SessionDAO即可完成自定义的Session管理</p>
<h3 id="整合Redis"><a href="#整合Redis" class="headerlink" title="整合Redis"></a>整合Redis</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> RedisConnectionFactory redisConnectionFactory;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;<span class="keyword">String</span>, Object&gt; stringObjectRedisTemplate() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        RedisTemplate&lt;<span class="keyword">String</span>, Object&gt; <span class="keyword">template</span> = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span>.setConnectionFactory(redisConnectionFactory);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span>.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">template</span>.setValueSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">template</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="重写SessionDao"><a href="#重写SessionDao" class="headerlink" title="重写SessionDao"></a>重写SessionDao</h3><p><img src="http://image.winrains.cn/2019/10/20191025224031-5691e.png" alt="img"></p>
<p>查看源码，可以看到调用默认SessionManager的retriveSession方法，我们重写该方法，将Session放入HttpRequest中，进一步提高session访问效率</p>
<p><img src="http://image.winrains.cn/2019/10/20191025224035-220fc.png" alt="img"></p>
<h3 id="向ShiroConfig中添加配置"><a href="#向ShiroConfig中添加配置" class="headerlink" title="向ShiroConfig中添加配置"></a>向ShiroConfig中添加配置</h3><p>其实在概览模块已经给出代码展示，这里单独列出来做说明:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 自定义RedisSessionDao用来管理Session在Redis中的CRUD</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * @return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">Bean(<span class="params">name</span> = <span class="string">"redisSessionDao"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public RedisSessionDao redis<span class="constructor">SessionDao()</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return <span class="keyword">new</span> <span class="constructor">RedisSessionDao()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 自定义SessionManager,应用自定义SessionDao</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * @return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">Bean(<span class="params">name</span> = <span class="string">"customerSessionManager"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public CustomerWebSessionManager customer<span class="constructor">WebSessionManager()</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    CustomerWebSessionManager customerWebSessionManager = <span class="keyword">new</span> <span class="constructor">CustomerWebSessionManager()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    customerWebSessionManager.set<span class="constructor">SessionDAO(<span class="params">redisSessionDao</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return customerWebSessionManager;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 定义Security manager</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * @param customRealm</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * @return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">Bean(<span class="params">name</span> = <span class="string">"securityManager"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public DefaultWebSecurityManager default<span class="constructor">WebSecurityManager(CustomRealm <span class="params">customRealm</span>)</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    DefaultWebSecurityManager  securityManager = <span class="keyword">new</span> DefaultWebSecurityManager <span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    securityManager.set<span class="constructor">Realm(<span class="params">customRealm</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    securityManager.set<span class="constructor">SessionManager(<span class="params">customerWebSessionManager</span>()</span>); <span class="comment">// 可不指定，Shiro会用默认Session manager</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    securityManager.set<span class="constructor">CacheManager(<span class="params">redisCacheManagers</span>()</span>);  <span class="comment">//可不指定，Shiro会用默认CacheManager</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//        securityManager.setSessionManager(defaultWebSessionManager());</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    return securityManager;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 定义session管理器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * @return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">@<span class="constructor">Bean(<span class="params">name</span> = <span class="string">"sessionManager"</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public DefaultWebSessionManager default<span class="constructor">WebSessionManager()</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    DefaultWebSessionManager defaultWebSessionManager = <span class="keyword">new</span> <span class="constructor">DefaultWebSessionManager()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    defaultWebSessionManager.set<span class="constructor">SessionDAO(<span class="params">redisSessionDao</span>()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return defaultWebSessionManager;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>至此，将 session 信息由 redis 管理功能就这样完成了</p>
<h2 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h2><p>应对分布式服务，对于高并发访问数据库权限内容是非常低效的方式，同样我们可以利用Redis来解决这一问题，将授权数据缓存到Redis中</p>
<h3 id="新建-RedisCache"><a href="#新建-RedisCache" class="headerlink" title="新建 RedisCache"></a>新建 RedisCache</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Cache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SHIRO_PREFIX = <span class="string">"shiro-cache:"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Resource</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; stringObjectRedisTemplate;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getKey</span><span class="params">(K key)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (key <span class="keyword">instanceof</span> String)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> (SHIRO_PREFIX + key);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> key.toString();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        log.info(<span class="string">"read from redis..."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        V v = (V) stringObjectRedisTemplate.opsForValue().get(getKey(k));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K k, V v)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        stringObjectRedisTemplate.opsForValue().set(getKey(k), v);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        stringObjectRedisTemplate.expire(getKey(k), <span class="number">100</span>, TimeUnit.SECONDS);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K k)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        V v = (V) stringObjectRedisTemplate.opsForValue().get(getKey(k));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        stringObjectRedisTemplate.delete((String) get(k));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> <span class="keyword">throws</span> CacheException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//不要重写，如果只保存shiro数据无所谓</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="新建-RedisCacheManager"><a href="#新建-RedisCacheManager" class="headerlink" title="新建 RedisCacheManager"></a>新建 RedisCacheManager</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheManager</span> <span class="keyword">implements</span> <span class="title">CacheManager</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Resource</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> &lt;K, V&gt; <span class="function">Cache&lt;K, V&gt; <span class="title">getCache</span><span class="params">(String s)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> redisCache;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>至此，我们不用每次访问 Mysql DB 来获取认证和授权信息，而是通过 Redis 来缓存这些信息，大大提升了效率，也满足分布式系统的设计需求</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回复公众号 「demo」获取 demo 代码。这里只是梳理了Springboot整合Shiro的流程，以及应用Redis最大化利用Shiro，Shiro的使用细节还很多，官网说的也很明确，带着上面的架构图来理解Shiro会事半功倍，感觉这里面的代码挺多挺头大的？那是你没有自己动手去尝试，结合官网与 demo 相信你会对 Shiro 有更好的理解，另外你可以理解 Shiro 是 mini 版本的 Spring Security，我希望以小见大，当需要更细粒度的认证授权时，也会对理解 Spring Security 有很大帮助，点击文末「阅读原文」，效果更好<br>落霞与孤鹜齐飞 秋水共长天一色，产品经理和程序员一片祥和…</p>
<h2 id="灵魂追问"><a href="#灵魂追问" class="headerlink" title="灵魂追问"></a>灵魂追问</h2><ol>
<li>都说 Redis 是单线程，但是很快，你知道为什么吗？</li>
<li>你们项目中是怎样控制认证授权的呢？当授权有变化，对于程序员来说，这个修改是灾难吗？</li>
</ol>
<blockquote>
<p>作者：日拱一兵</p>
<p>来源：<a href="https://juejin.im/post/5d4b7425e51d4561bb33fafd" target="_blank" rel="noopener">https://juejin.im/post/5d4b7425e51d4561bb33fafd</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
        <category>Shiro</category>
      </categories>
  </entry>
  <entry>
    <title>如何设计好的RESTful API</title>
    <url>/2019/12/26/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%A5%BD%E7%9A%84RESTful-API/</url>
    <content><![CDATA[<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>现阶段的开发模式多以前后端分离形式存在，前后端开发人员需要通过大量 API 来进行数据交互，如果在交互过程中前后端人员经常遭遇如下问题：</p>
<ul>
<li>前端人员不能快速理解接口字段含义及接口字段变化</li>
<li>后端人员想复用某些接口，但是不能快速从接口 URL 的定义中明确该接口的含义，需要进一步读代码确认</li>
<li>URL中的英文单词使用五花八门，搜索某个接口不知道具体的关键字</li>
<li>请求方法动词如 POST GET 随意使用</li>
<li>完成当前业务接口对接，前端人员经常会询问下一步业务流程的接口定义在哪里，对接形式是什么样的</li>
</ul>
<a id="more"></a>

<p>以上只是前后端人员通过接口交互的一小部分问题，这些问题就好比”牙痛”，不致命，但是在整个软件开发的生命周期内，天天”牙痛”是很要命的, 需要解决上述的问题，需要前后端人员都能认识与了解接口设计规范的重要性。</p>
<h2 id="什么是REST"><a href="#什么是REST" class="headerlink" title="什么是REST"></a>什么是REST</h2><p>在 2000 年，Roy Fielding 提出 Representational State Transfer (REST) 的概念，中文翻译过来”表述性状态传递”，感兴趣的朋友可以去维基百科看看原始概念，乍一看是一个挺抽象的概念，但其实，这个概念就像交通灯规则一样简单，就看如何看待相关规范. 当我们谈及 RESTful 设计规范，多数人能了解设计的大原则，但是不了解小细节，而对这些细节的了解与否，是能否治好”牙痛病”的关键</p>
<h2 id="REST术语介绍"><a href="#REST术语介绍" class="headerlink" title="REST术语介绍"></a>REST术语介绍</h2><p>现实世界交通灯有红绿黄，REST相关的概念也是三个：资源，集合，URL</p>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>资源是某种东西的对象或表示，它具有一些与之相关的数据，并且可以有一组方法对其进行操作。 例如, 动物，学校和员工是资源; 删除，添加，更新是对这些资源执行的相关操作</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合是资源集合，例如，公司是公司资源的集合</p>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>URL（统一资源定位符）是可以通过其定位资源的路径，并且可以对其执行某些操作<br>了解到以上内容， 那REST 世界的”交通灯”规则是什么样的？我们来了解一下</p>
<h2 id="如何设计和开发一个高可用的-REST-APIs"><a href="#如何设计和开发一个高可用的-REST-APIs" class="headerlink" title="如何设计和开发一个高可用的 REST APIs"></a>如何设计和开发一个高可用的 REST APIs</h2><blockquote>
<p>网上一直有关于”最好的Restful API的设计”争论，何为最好，至今没有一个官方的指导。本文总结 RESTful 的设计细节，介绍如何设计出易于理解和使用的 API。在 Restful API 设计标准之上，我们可以为我们的设计增加一些弹性（团队都认可的方式），每个项目的情况不同，最重要的是项目组成员达成一致的Restful API 设计规则，达到高可用即可</p>
</blockquote>
<h3 id="URL-设计"><a href="#URL-设计" class="headerlink" title="URL 设计"></a>URL 设计</h3><p>学英语，名词（car/animal/teacher）都很好记忆，但是如何用动词和这些名词组合来准确的表达特定的含义却很困难，庆幸的是在 REST 的世界，动词寥寥无几，并且含义单一 ，RESTful 的核心思想也是通过这些<strong>动词 + 名词</strong>完成对资源的操作与访问，但我们经常看到这样的动词与名词的 URL 组合：</p>
<ul>
<li>/getAllUsers</li>
<li>/createNewCompany</li>
<li>/updateUserInfo</li>
<li>/deleteUser?name=zhangsan</li>
</ul>
<p>这些 URL 的设计会导致文章开头所说的很多问题，我们进一步来了解如何应用所谓的<strong>动词 + 名词</strong></p>
<h4 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h4><p>动词通常就是 5 种 HTTP 方法，对应我们常见的 CRUD 操作：</p>
<ul>
<li>POST：新建（Create）</li>
<li>GET：读取（Read）</li>
<li>PUT：更新（Update）</li>
<li>PATCH：更新（Update），通常不分更新，也很少用到</li>
<li>DELETE：删除（Delete）</li>
</ul>
<p>根据 HTTP 规范，动词一律大写，另外根据RESTful 幂等性（多次调用是否会对资源产生影响）原则，我们不能乱用动词，GET/PUT/DELETE 是幂等的，POST/PATCH 不是幂等的<br>有些客户端只能使用 <code>GET</code>和 <code>POST</code>这两种方法。服务器必须接受 <code>POST</code>模拟其他三个方法（ <code>PUT</code>、 <code>PATCH</code>、 <code>DELETE</code>）。<br>这时，客户端发出的 HTTP 请求，要加上 <code>X-HTTP-Method-Override</code>属性，告诉服务器应该使用哪一个动词，覆盖 <code>POST</code>方法。</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">POST /users/<span class="number">12</span> HTTP/<span class="number">1.1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">X-HTTP-<span class="function"><span class="keyword">Method</span>-<span class="title">Override</span>:</span> PUT</span></pre></td></tr></table></figure>

<p>上面代码中， <code>X-HTTP-Method-Override</code>指定本次请求的方法是 <code>PUT</code>，而不是 <code>POST</code></p>
<h4 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h4><p>名词就是表示一个资源或者服务，如 /users，/teachers，这里看到我用名词复数的形式描述某一资源，至于用单数还是复数每个人都有自己的见解，我在这里推荐使用复数，因为在现实世界中，资源多数是以集合的形式存在的</p>
<h4 id="动词-名词"><a href="#动词-名词" class="headerlink" title="动词 + 名词"></a>动词 + 名词</h4><p><img src="http://image.winrains.cn/2019/08/20190829193552-61f08.jpeg" alt="http://image.winrains.cn/2019/08/20190829193552-61f08.jpeg"></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">POST /users</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /users</span></pre></td></tr><tr><td class="code"><pre><span class="line">PUT /users</span></pre></td></tr><tr><td class="code"><pre><span class="line">DELETE /users</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /users/12</span></pre></td></tr><tr><td class="code"><pre><span class="line">PUT /users/12</span></pre></td></tr><tr><td class="code"><pre><span class="line">DELETE /users/12</span></pre></td></tr></table></figure>

<p>上述<strong>动词 + 名词</strong>的组合是不是清晰多了，没有杂乱的动词在 URL 中，大家的理解含义相同</p>
<h4 id="URL-层级"><a href="#URL-层级" class="headerlink" title="URL 层级"></a>URL 层级</h4><p>现实中哪有这么简单的 CRUD，资源的相互关联与嵌套很常见，查找 id 是 12 的用户的所有帖子， 如何设计这个 URL，下面两种设计也会有争论：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /users/12/posts</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /posts?<span class="attribute">userId</span>=12</span></pre></td></tr></table></figure>

<p>第一种出现两个名词主题（users/posts），会让人有几秒钟的猜想，这到底请求的是用户资源还是帖子资源，当存在更深浅套的时候也不容易扩展，所以我推荐第二种方式，主体名词 posts 资源明显，其他过滤条件也更容易扩展，比如 /posts?userName=zhangsan，我们可以复用同样的接口</p>
<h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>我们看到过很多如下 URL 设计，用来区分 API 版本：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">POST /v2/users</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /V1/users/12</span></pre></td></tr></table></figure>

<p>我们都指向同样的资源 users，URL 中为什么要加版本号呢？ 针对这个问题，答案依旧没有统一标准，如果多个版本的API版本返回数据结果结构一样，那没必要区分版本，如果结构已经发生变化，而且要向下兼容，那版本号是很好的区分方式，而且通过 URL 加版本的方式可以更好的发现资源</p>
<h4 id="过滤-分页-排序"><a href="#过滤-分页-排序" class="headerlink" title="过滤/分页/排序"></a>过滤/分页/排序</h4><p>实际的业务场景中会经常对请求资源做条件筛选，分页显示，以及排序，我们不要为这些业务要求创建不同步的 API，我们应该尽量保持 URL 的信息简单，只需添加查询条件参数来实现上述功能，同时符合”望 URL 知意”的原则</p>
<h5 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h5><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /users/12/posts?<span class="attribute">state</span>=published</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /users/12/posts?<span class="attribute">published</span>=<span class="literal">true</span></span></pre></td></tr></table></figure>

<p>上述两种方式都可以实现资源的过滤</p>
<h5 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h5><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /users?<span class="attribute">pageNo</span>=1&amp;pageSize=20</span></pre></td></tr></table></figure>

<p>以分页方式查询用户列表，显示第 2 页内容，每页显示 20 条信息</p>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /users?<span class="attribute">sort</span>=score_desc</span></pre></td></tr></table></figure>

<p>按照学生分数降序进行排序<br>上述所有的方式我们都可以做到”望 URL 知意”，这就是好的设计</p>
<h3 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h3><p>RESTful API 的返回结果也是设计环节中重要的一环</p>
<h4 id="响应数据格式"><a href="#响应数据格式" class="headerlink" title="响应数据格式"></a>响应数据格式</h4><p>API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的 <code>Content-Type</code>属性要设为 <code>application/json</code>。同时客户端也应作出相应的配合，客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的 <code>ACCEPT</code>属性也要设成 <code>application/json</code>，多渠道调用可能会存在相同资源需要有不同的 producer 类型的情况存在</p>
<h4 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h4><p>很多后端开发人员可能受开发框架所限，或者返回数据封装形式不够好，经常会给前端人员不是很友好的 HTTP 状态码，比如 response 有 error，却给出 <code>200HTTP.OK</code> 的状态码 (明明吃了三碗粉，却给两碗粉的钱)</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span></pre></td></tr><tr><td class="code"><pre><span class="line">Content-<span class="keyword">Type</span>: application/<span class="type">json</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    "status": "-1",</span></pre></td></tr><tr><td class="code"><pre><span class="line">    "result": &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        "error": "分数应小于150"</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>有人说，我已经标记返回内容 status 是 -1（表示failure）, 用 200 作为状态码也无妨吧？这是一个很错误的观念，RESTful 的设计理念之一是简单直观，试想一下，前端开发人员打开开发者工具，所有请求都是200的状态码，但是页面数据就是没有显示出来，难道前端开发人员还要每个接口调用点开看一看，是哪个 status 是 -1 导致的吗？ 很显然我们不希望这样的情况发生，正确的做法应该类似这样的：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">400</span> Bad Request</span></pre></td></tr><tr><td class="code"><pre><span class="line">Content-<span class="keyword">Type</span>: application/<span class="type">json</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    "status": "-1",</span></pre></td></tr><tr><td class="code"><pre><span class="line">    "result": &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        "error": "分数应小于150"</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>下面页列举出来常用的状态码以及表示的含义：</p>
<h5 id="2xx-状态码"><a href="#2xx-状态码" class="headerlink" title="2xx 状态码"></a>2xx 状态码</h5><p>200表示成功，同时我们可以表示的更加精确</p>
<blockquote>
<ul>
<li><code>GET:200OK</code> 请求成功</li>
<li><code>POST:201Created</code> 创建成功</li>
<li><code>PUT:200OK</code> 更新成功</li>
<li><code>DELETE:204NoContent</code> 找不到要删除的内容</li>
</ul>
</blockquote>
<p>使用状态码 202 有时候会比 使用状态啊吗 201 是更好的选择，状态码 202 的意思是：服务端已接收到了请求，但是还没有创建任何资源，但结果一切正常。 比如：</p>
<blockquote>
<ul>
<li>异步操作：服务器已接收到请求，但是还未处理，但是会在未来处理</li>
<li>资源已经存在，没有创建新的资源 （有些业务可能会返回错误信息”您创建的数据已存在”，所以这种情景没有明确的规定，符合自己的业务需求即可）</li>
</ul>
</blockquote>
<h5 id="4xx-状态码"><a href="#4xx-状态码" class="headerlink" title="4xx 状态码"></a>4xx 状态码</h5><p>4xx 状态码表示客户端的错误，主要有以下几种：</p>
<blockquote>
<ul>
<li><code>400BadRequest</code>：服务器不理解客户端的请求，未做任何处理</li>
<li><code>401Unauthorized</code>：用户未提供身份验证凭据，或者没有通过身份验证</li>
<li><code>403Forbidden</code>：用户通过了身份验证，但是不具有访问资源所需的权限</li>
<li><code>404NotFound</code>：所请求的资源不存在，或不可用</li>
<li><code>415UnsupportedMediaType</code>：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式</li>
</ul>
</blockquote>
<p>这里要注意状态码 401 和 403 的区别</p>
<h5 id="5xx-状态码"><a href="#5xx-状态码" class="headerlink" title="5xx 状态码"></a>5xx 状态码</h5><p>5xx 状态码表示服务端错误，通常只会用到两个：</p>
<blockquote>
<ul>
<li><code>500InternalServerError</code>：客户端请求有效，服务器处理时发生了意外</li>
<li><code>503ServiceUnavailable</code>：服务器无法处理请求，一般用于网站维护状态</li>
</ul>
</blockquote>
<h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>过去开发人员通常会将活动的用户信息存储在服务端的 session 中， 这种形式很显然不适用于现在分布式微服务架构的模式，我们可以使用 JWT (JSON Web Token) 如 OAuth2 来实现，这样每次在 Httpheader 中添加 token 来做验证即可</p>
<h4 id="API-文档"><a href="#API-文档" class="headerlink" title="API 文档"></a>API 文档</h4><p>Swagger是一种广泛使用的工具来用来记录与呈现 REST API，它提供了一种探索特定 API 使用的方法，因此允许开发人员理解底层的语义行为。 这是一种使用注释添加文档的声明性方法，它进一步生成描述 API 及其用法的 JSON，可以实时应对 API 的更新，具体请参考 Swagger 官网 , 同时使用 Spring Boot 的小伙伴也可以很轻松的集成 Swagger，只需引入Swagger Starter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spring4all<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure>

<h4 id="HATEOAS"><a href="#HATEOAS" class="headerlink" title="HATEOAS"></a>HATEOAS</h4><p>HATEOAS (Hypermedia As Transfer Engine Of Application State), API 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做 HATEOAS , 举个例子，列表页数据通常会有查看操作，这样我们在返回列表页的数据的时候同样返回如何操作查看具体数据详情的 API 接口：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">"status"</span>: <span class="string">"-1"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">"result"</span>: [&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">"id"</span>: <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">"name"</span>: <span class="string">"zhangsan"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">"links"</span>:[</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="attr">"href"</span>: <span class="string">"http://localhost:8080/user/&#123;id&#125;"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用 Spring 框架的小伙伴可以快速的体验一下这种方式，Spring 官网项目 Spring HATEOAS , 会快速的将参数都做替换, 将查看 API URL 中的 id 直接替换成 1。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">"status"</span>: <span class="string">"-1"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">"result"</span>: [&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">"id"</span>: <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">"name"</span>: <span class="string">"zhangsan"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">"links"</span>:[</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="attr">"href"</span>: <span class="string">"http://localhost:8080/user/1"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="提升效率工具"><a href="#提升效率工具" class="headerlink" title="提升效率工具"></a>提升效率工具</h2><h3 id="RestfulToolkit"><a href="#RestfulToolkit" class="headerlink" title="RestfulToolkit"></a>RestfulToolkit</h3><p>后端开发人员可以安装 IntellJ idea 插件 RestfulToolkit, Mac 环境使用快捷键 <code>CMD+\</code> 输入关键字快速定位到 API 位置<br><img src="http://image.winrains.cn/2019/08/20190829193553-5ae2b.jpeg" alt="http://image.winrains.cn/2019/08/20190829193553-5ae2b.jpeg"><br>同时在右侧工具栏打开 API，会自动生成 demoData 请求参数，实现快速调用测试：<br><img src="http://image.winrains.cn/2019/08/20190829193553-64b76.png" alt="http://image.winrains.cn/2019/08/20190829193553-64b76.png"><br>JSON-Viewer<br>JSON-Viewer 是 Chrome 浏览器的插件，用于快速解析及格式化 json 内容，在 Chrome omnibox（多功能输入框）输入 <code>json-viewer+TAB</code> ，将 json 内容拷贝进去，然后输入回车键，将看到结构清晰的 json 数据，同时可以自定义主题<br><img src="http://image.winrains.cn/2019/08/20190829193553-d6f5d.jpeg" alt="http://image.winrains.cn/2019/08/20190829193553-d6f5d.jpeg"><br>另外，前端人员打开开发者工具，双击请求链接，会自动将 response 中的 json 数据解析出来，非常方便</p>
<h3 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h3><p>Postman 功能十分强大， 搜索 <code>Postman自定义环境变量</code>，会打开新世界的大门</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>如何设计出最好的 RESTful API 永远不会有结论，设计出高可用，团队认可，简单清晰明了的 RESTful API 就是好的。</p>
<blockquote>
<p>作者：日拱一兵</p>
<p>来源：<a href="https://mp.weixin.qq.com/s/hR1TqkVzwZ_T8fuMnsM4hQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/hR1TqkVzwZ_T8fuMnsM4hQ</a></p>
</blockquote>
]]></content>
      <categories>
        <category>其它技术</category>
        <category>Restful</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL锁机制</title>
    <url>/2019/12/26/MySQL%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="一、锁的类型"><a href="#一、锁的类型" class="headerlink" title="一、锁的类型"></a>一、锁的类型</h2><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><ul>
<li>共享锁（S Lock）允许事务读一行数据</li>
<li>排它锁 （X Lock） 允许事务读一行数据</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829194616-b39aa.jpeg" alt="img"></p>
<a id="more"></a>

<h3 id="表锁-意向锁"><a href="#表锁-意向锁" class="headerlink" title="表锁(意向锁)"></a>表锁(意向锁)</h3><p>锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式</p>
<ul>
<li>意向共享锁（IS Lock）事务想要获得一张表中某几行的共享锁</li>
<li>意向排他锁（IX Lock）事务想要获得一张表中某几行的排他锁</li>
</ul>
<p>由于InnoDB存储引擎支持的是行级别的锁，因此意向锁其实不会阻塞除全表扫以外的任何请求。故表级意向锁与行级锁的兼容性如下所示</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194616-95e79.jpeg" alt="img"></p>
<p><img src="http://image.winrains.cn/2019/08/20190829194616-bdd47.jpeg" alt="img"></p>
<p>若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。例上图，如果需要对页上的记录r进行上X锁，那么分别需要对数据库A、表、页上意向锁IX，最后对记录r上X锁。若其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成。举例来说，在对记录r加X锁之前，已经有事务对表1进行了S表锁，那么表1上已存在S锁，之后事务需要对记录r在表1上加上IX，由于不兼容，所以该事务需要等待表锁操作的完成。</p>
<h3 id="意向锁到底有什么作用？"><a href="#意向锁到底有什么作用？" class="headerlink" title="意向锁到底有什么作用？"></a>意向锁到底有什么作用？</h3><p>innodb的意向锁主要用户多粒度的锁并存的情况。比如事务A要在一个表上加S锁，如果表中的一行已被事务B加了X锁，那么该锁的申请也应被阻塞。如果表中的数据很多，逐行检查锁标志的开销将很大，系统的性能将会受到影响。为了解决这个问题，可以在表级上引入新的锁类型来表示其所属行的加锁情况，这就引出了“意向锁”的概念。<br>举个例子，如果表中记录1亿，事务A把其中有几条记录上了行锁了，这时事务B需要给这个表加表级锁，如果没有意向锁的话，那就要去表中查找这一亿条记录是否上锁了。如果存在意向锁，那么假如事务Ａ在更新一条记录之前，先加意向锁，再加Ｘ锁，事务B先检查该表上是否存在意向锁，存在的意向锁是否与自己准备加的锁冲突，如果有冲突，则等待直到事务Ａ释放，而无须逐条记录去检测。事务Ｂ更新表时，其实无须知道到底哪一行被锁了，它只要知道反正有一行被锁了就行了。<br><strong>主要作用是处理行锁和表锁之间的矛盾，能够显示“某个事务正在某一行上持有了锁，或者准备去持有锁”</strong></p>
<h2 id="二、锁的算法"><a href="#二、锁的算法" class="headerlink" title="二、锁的算法"></a>二、锁的算法</h2><ul>
<li>Record Lock：单个行记录上的锁</li>
<li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身</li>
<li>Next-Key Lock∶Gap Lock+Record Lock，锁定一个范围、索引之间的间隙，并且锁定记录本身；目的是为了防止幻读</li>
</ul>
<h2 id="三、mysql如何做到读写并行（多版本控制）？"><a href="#三、mysql如何做到读写并行（多版本控制）？" class="headerlink" title="三、mysql如何做到读写并行（多版本控制）？"></a>三、mysql如何做到读写并行（多版本控制）？</h2><p>多版本并发控制 MVCC，是行级锁的一个变种，通过保存数据在某个时间节点的快照(snapshot)，类似实现了行级锁。由此不同事务对同一表，同一时刻看到的数据可能是不一样的。 实现上通过在不同的数据行后增加创建日期版本号和删除日期版本号，且版本号不断递增，进而实现了数据快照</p>
<h3 id="读的类型"><a href="#读的类型" class="headerlink" title="读的类型"></a>读的类型</h3><ul>
<li>一致性非锁定读（快照读）<ul>
<li>在事务隔离级别提交读（RC）和可重复读（RR）下，InnoDB存储引擎使用非锁定的一致性读<ul>
<li>RC模式下，读取最新的快照</li>
<li>RR模式下，读取事务开始时的快照</li>
</ul>
</li>
</ul>
</li>
<li>一致性锁定读 （当前读）<ul>
<li>隔离级别为未提交读(RN）时读取都是当前读</li>
<li>SELECT…FOR UPDATE （加写锁）</li>
<li>SELECT…LOCK IN SHARE MODE （加读锁）</li>
</ul>
</li>
</ul>
<h2 id="四、加锁处理分析"><a href="#四、加锁处理分析" class="headerlink" title="四、加锁处理分析"></a>四、加锁处理分析</h2><p>下面两条简单的SQL，他们加什么锁？<br><strong>select * from t1 where id = 10</strong><br><strong>delete from t1 where id = 10</strong><br>如果要分析加锁情况，必须还要知道以下的一些前提，前提不同，加锁处理的方式也不同</p>
<ul>
<li><strong>前提一</strong>:id列是不是主键？</li>
<li><strong>前提二</strong>:当前系统的隔离级别是什么？</li>
<li><strong>前提三</strong>:id列如果不是主键，那么id列上有索引吗？</li>
<li><strong>前提四</strong>:id列上如果有二级索引，那么这个索引是唯一索引吗？</li>
<li><strong>前提五</strong>:两个SQL的执行计划是什么？索引扫描？全表扫描？</li>
</ul>
<p>根据上述情况，有以下几种组合</p>
<ul>
<li><strong>组合一</strong>:id列是主键，RC隔离级别</li>
<li><strong>组合二</strong>:id列是二级唯一索引，RC隔离级别</li>
<li><strong>组合三</strong>:id列是二级非唯一索引，RC隔离级别</li>
<li><strong>组合四</strong>:id列上没有索引，RC隔离级别</li>
<li><strong>组合五</strong>:id列是主键，RR隔离级别</li>
<li><strong>组合六</strong>:id列是二级唯一索引，RR隔离级别</li>
<li><strong>组合七</strong>:id列是二级非唯一索引，RR隔离级别</li>
<li><strong>组合八</strong>:id列上没有索引，RR隔离级别</li>
<li><strong>组合九</strong>:Serializable隔离级别</li>
</ul>
<p>排列组合还没有列举完全，但是看起来，已经很多了。真的有必要这么复杂吗？事实上，要分析加锁，就是需要这么复杂。但是从另一个角度来说，只要你选定了一种组合，SQL需要加哪些锁，其实也就确定了。接下来挑几个比较经典的组合</p>
<h3 id="组合一：id主键-RC"><a href="#组合一：id主键-RC" class="headerlink" title="组合一：id主键+RC"></a>组合一：id主键+RC</h3><p>这个组合，是最简单，最容易分析的组合。id是主键，Read Committed隔离级别，给定SQL：delete from t1 where id = 10; 只需要将主键上，id = 10的记录加上X锁即可。如下图所示：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194616-d6aa4.jpeg" alt="img"></p>
<p><strong>结论：id是主键时，此SQL只需要在id=10这条记录上加X锁即可。</strong></p>
<h3 id="组合二：id唯一索引-RC"><a href="#组合二：id唯一索引-RC" class="headerlink" title="组合二：id唯一索引+RC"></a>组合二：id唯一索引+RC</h3><p>这个组合，id不是主键，而是一个Unique的二级索引键值。那么在RC隔离级别下，delete from t1 where id = 10; 需要加什么锁呢？见下图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194617-c3318.jpeg" alt="img"></p>
<p>此组合中，id是unique索引，而主键是name列。此时，加锁的情况由于组合一有所不同。由于id是unique索引，因此delete语句会选择走id列的索引进行where条件的过滤，在找到id=10的记录后，首先会将unique索引上的id=10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name = ‘d’ 对应的主键索引项加X锁。为什么聚簇索引上的记录也要加锁？试想一下，如果并发的一个SQL，是通过主键索引来更新：update t1 set id = 100 where name = ‘d’; 此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新/删除需要串行执行的约束。<br><strong>结论：若id列是unique列，其上有unique索引。那么SQL需要加两个X锁，一个对应于id unique索引上的id = 10的记录，另一把锁对应于聚簇索引上的[name=’d’,id=10]的记录。</strong></p>
<h3 id="组合三：id非唯一索引-RC"><a href="#组合三：id非唯一索引-RC" class="headerlink" title="组合三：id非唯一索引+RC"></a>组合三：id非唯一索引+RC</h3><p><strong>相对于组合一、二，组合三又发生了变化，隔离级别仍旧是RC不变，但是id列上的约束又降低了，id列不再唯一，只有一个普通的索引。假设delete from t1 where id = 10; 语句，仍旧选择id列上的索引进行过滤where条件，那么此时会持有哪些锁？同样见下图：</strong></p>
<p><img src="http://image.winrains.cn/2019/08/20190829194617-bf55f.jpeg" alt="img"></p>
<p>根据此图，可以看到，首先，id列索引上，满足id = 10查询条件的记录，均已加锁。同时，这些记录对应的主键索引上的记录也都加上了锁。与组合二唯一的区别在于，组合二最多只有一个满足等值查询的记录，而组合三会将所有满足查询条件的记录都加锁。<br><strong>结论：若id列上有非唯一索引，那么对应的所有满足SQL查询条件的记录，都会被加锁。同时，这些记录在主键索引上的记录，也会被加锁。</strong></p>
<h3 id="组合四：id无索引-RC"><a href="#组合四：id无索引-RC" class="headerlink" title="组合四：id无索引+RC"></a>组合四：id无索引+RC</h3><p><strong>相对于前面三个组合，这是一个比较特殊的情况。id列上没有索引，where id = 10;这个过滤条件，没法通过索引进行过滤，那么只能走全表扫描做过滤。对应于这个组合，SQL会加什么锁？或者是换句话说，全表扫描时，会加什么锁？这个答案也有很多：有人说会在表上加X锁；有人说会将聚簇索引上，选择出来的id = 10;的记录加上X锁。那么实际情况呢？请看下图：</strong></p>
<p><img src="http://image.winrains.cn/2019/08/20190829194617-e2541.jpeg" alt="img"></p>
<p>由于id列上没有索引，因此只能走聚簇索引，进行全部扫描。从图中可以看到，满足删除条件的记录有两条，但是，聚簇索引上所有的记录，都被加上了X锁。无论记录是否满足条件，全部被加上X锁。既不是加表锁，也不是在满足条件的记录上加行锁。<br>有人可能会问？为什么不是只在满足条件的记录上加锁呢？这是由于MySQL的实现决定的。如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由MySQL Server层进行过滤。因此也就把所有的记录，都锁上了。<br>注：在实际的实现中，MySQL有一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁 (违背了2PL的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。<br><strong>结论：若id列上没有索引，SQL会走聚簇索引的全扫描进行过滤，由于过滤是由MySQL Server层面进行的。因此每条记录，无论是否满足条件，都会被加上X锁。但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁/放锁动作不会省略。同时，优化也违背了2PL的约束。</strong></p>
<h3 id="组合五：id主键-RR"><a href="#组合五：id主键-RR" class="headerlink" title="组合五：id主键+RR"></a>组合五：id主键+RR</h3><p>上面的四个组合，都是在Read Committed隔离级别下的加锁行为，接下来的四个组合，是在Repeatable Read隔离级别下的加锁行为。<br>组合五，id列是主键列，Repeatable Read隔离级别，针对delete from t1 where id = 10; 这条SQL，加锁与组合一：[<a href="https://link.juejin.im?target=http%3A%2F%2Fhedengcheng.com%2F%3Fp%3D771%23_%E7%BB%84%E5%90%88%E4%B8%80%EF%BC%9Aid%E4%B8%BB%E9%94%AE%2BRC">id主键，Read Committed</a>]一致。</p>
<h3 id="组合六：id唯一索引-RR"><a href="#组合六：id唯一索引-RR" class="headerlink" title="组合六：id唯一索引+RR"></a>组合六：id唯一索引+RR</h3><p><strong>与组合五类似，组合六的加锁，与组合二：[id唯一索引，Read Committed]一致。两个X锁，id唯一索引满足条件的记录上一个，对应的聚簇索引上的记录一个。</strong></p>
<h3 id="组合七：id非唯一索引-RR"><a href="#组合七：id非唯一索引-RR" class="headerlink" title="组合七：id非唯一索引+RR"></a>组合七：id非唯一索引+RR</h3><p>还记得前面提到的MySQL的四种隔离级别的区别吗？RC隔离级别允许幻读，而RR隔离级别，不允许存在幻读。但是在组合五、组合六中，加锁行为又是与RC下的加锁行为完全一致。那么RR隔离级别下，<br>组合七，Repeatable Read隔离级别，id上有一个非唯一索引，执行delete from t1 where id = 10; 假设选择id列上的索引进行条件过滤，最后的加锁行为，是怎么样的呢？同样看下面这幅图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194617-a6c84.jpeg" alt="img"></p>
<p>此图，相对于组合三：[<a href="https://link.juejin.im?target=http%3A%2F%2Fhedengcheng.com%2F%3Fp%3D771%23_%E7%BB%84%E5%90%88%E4%B8%89%EF%BC%9Aid%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%2BRC">id列上非唯一锁，Read Committed</a>]看似相同，其实却有很大的区别。最大的区别在于，这幅图中多了一个GAP锁，而且GAP锁看起来也不是加在记录上的，倒像是加载两条记录之间的位置，GAP锁有何用？<br>其实这个多出来的GAP锁，就是RR隔离级别，相对于RC隔离级别，不会出现幻读的关键。确实，GAP锁锁住的位置，也不是记录本身，而是两条记录之间的GAP。<br>如何保证两次当前读返回一致的记录，那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交。为了实现这个功能，GAP锁应运而生。<br>如图中所示，有哪些位置可以插入新的满足条件的项 (id = 10)，考虑到B+树索引的有序性，满足条件的项一定是连续存放的。记录[6,c]之前，不会插入id=10的记录；[6,c]与[10,b]间可以插入[10, aa]；[10,b]与[10,d]间，可以插入新的[10,bb],[10,c]等；[10,d]与[11,f]间可以插入满足条件的[10,e],[10,z]等；而[11,f]之后也不会插入满足条件的记录。因此，为了保证[6,c]与[10,b]间，[10,b]与[10,d]间，[10,d]与[11,f]不会插入新的满足条件的记录，MySQL选择了用GAP锁，将这三个GAP给锁起来。<br>Insert操作，如insert [10,aa]，首先会定位到[6,c]与[10,b]间，然后在插入前，会检查这个GAP是否已经被锁上，如果被锁上，则Insert不能插入记录。因此，通过第一遍的当前读，不仅将满足条件的记录锁上 (X锁)，与组合三类似。同时还是增加3把GAP锁，将可能插入满足条件记录的3个GAP给锁上，保证后续的Insert不能插入新的id=10的记录，也就杜绝了同一事务的第二次当前读，出现幻象的情况。<br>有心的朋友看到这儿，可以会问：既然防止幻读，需要靠GAP锁的保护，为什么组合五、组合六，也是RR隔离级别，却不需要加GAP锁呢？<br>首先，这是一个好问题。其次，回答这个问题，也很简单。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。而组合五，id是主键；组合六，id是unique键，都能够保证唯一性。一个等值查询，最多只能返回一条记录，而且新的相同取值的记录，一定不会在新插入进来，因此也就避免了GAP锁的使用。其实，针对此问题，还有一个更深入的问题：如果组合五、组合六下，针对SQL：select * from t1 where id = 10 for update; 第一次查询，没有找到满足查询条件的记录，那么GAP锁是否还能够省略？此问题留给大家思考。<br><strong>结论：Repeatable Read隔离级别下，id列上有一个非唯一索引，对应SQL：delete from t1 where id = 10; 首先，通过id索引定位到第一条满足查询条件的记录，加记录上的X锁，加GAP上的GAP锁，然后加主键聚簇索引上的记录X锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录X锁，但是仍旧需要加GAP锁，最后返回结束。</strong><br><strong>什么时候会取得gap lock或nextkey lock 这和隔离级别有关,只在REPEATABLE READ或以上的隔离级别下的特定操作才会取得gap lock或nextkey lock。</strong></p>
<h3 id="组合八：id无索引-RR"><a href="#组合八：id无索引-RR" class="headerlink" title="组合八：id无索引+RR"></a>组合八：id无索引+RR</h3><p>组合八，Repeatable Read隔离级别下的最后一种情况，id列上没有索引。此时SQL：delete from t1 where id = 10; 没有其他的路径可以选择，只能进行全表扫描。最终的加锁情况，如下图所示：</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194618-de6cf.jpeg" alt="img"></p>
<p>如图，这是一个很恐怖的现象。首先，聚簇索引上的所有记录，都被加上了X锁。其次，聚簇索引每条记录间的间隙(GAP)，也同时被加上了GAP锁。这个示例表，只有6条记录，一共需要6个记录锁，7个GAP锁。试想，如果表上有1000万条记录呢？<br>在这种情况下，这个表上，除了不加锁的快照度，其他任何加锁的并发SQL，均不能执行，不能更新，不能删除，不能插入，全表被锁死。<br>当然，跟组合四：[<a href="https://link.juejin.im?target=http%3A%2F%2Fhedengcheng.com%2F%3Fp%3D771%23_%E7%BB%84%E5%90%88%E5%9B%9B%EF%BC%9Aid%E6%97%A0%E7%B4%A2%E5%BC%95%2BRC">id无索引, Read Committed</a>]类似，这个情况下，MySQL也做了一些优化，就是所谓的semi-consistent read。semi-consistent read开启的情况下，对于不满足查询条件的记录，MySQL会提前放锁。针对上面的这个用例，就是除了记录[d,10]，[g,10]之外，所有的记录锁都会被释放，同时不加GAP锁。semi-consistent read如何触发：要么是read committed隔离级别；要么是Repeatable Read隔离级别，同时设置了<a href="https://link.juejin.im?target=http%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.5%2Fen%2Finnodb-parameters.html">innodb_locks_unsafe_for_binlog</a> 参数。更详细的关于semi-consistent read的介绍，可参考我之前的一篇博客：<a href="https://link.juejin.im?target=http%3A%2F%2Fhedengcheng.com%2F%3Fp%3D220">MySQL+InnoDB semi-consitent read原理及实现分析</a> 。<br><strong>结论：在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新/删除/插入 操作。当然，也可以通过触发semi-consistent read，来缓解加锁开销与并发影响，但是semi-consistent read本身也会带来其他问题，不建议使用。</strong></p>
<h3 id="组合九：Serializable"><a href="#组合九：Serializable" class="headerlink" title="组合九：Serializable"></a>组合九：Serializable</h3><p>针对前面提到的简单的SQL，最后一个情况：Serializable隔离级别。对于SQL2：delete from t1 where id = 10; 来说，Serializable隔离级别与Repeatable Read隔离级别完全一致，因此不做介绍。<br>Serializable隔离级别，影响的是SQL1：select * from t1 where id = 10; 这条SQL，在RC，RR隔离级别下，都是快照读，不加锁。但是在Serializable隔离级别，SQL1会加读锁，也就是说快照读不复存在，MVCC并发控制降级为Lock-Based CC。<br><strong>结论：在MySQL/InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读。</strong></p>
<h2 id="五、死锁案例"><a href="#五、死锁案例" class="headerlink" title="五、死锁案例"></a>五、死锁案例</h2><h3 id="1-不同表相同记录行锁冲突"><a href="#1-不同表相同记录行锁冲突" class="headerlink" title="1. 不同表相同记录行锁冲突"></a>1. 不同表相同记录行锁冲突</h3><p>这种情况很好理解，事务A和事务B操作两张表，但出现循环等待锁情况。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194618-5c095.png" alt="img"></p>
<h3 id="2-相同表记录行锁冲突"><a href="#2-相同表记录行锁冲突" class="headerlink" title="2. 相同表记录行锁冲突"></a>2. 相同表记录行锁冲突</h3><p>这种情况比较常见，之前遇到两个job在执行数据批量更新时，jobA处理的的id列表为[1,2,3,4]，而job处理的id列表为[8,9,10,4,2]，这样就造成了死锁。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194618-a8e69.png" alt="img"></p>
<h3 id="3-不同索引锁冲突"><a href="#3-不同索引锁冲突" class="headerlink" title="3. 不同索引锁冲突"></a>3. 不同索引锁冲突</h3><p>这种情况比较隐晦，事务A在执行时，除了在二级索引加锁外，还会在聚簇索引上加锁，在聚簇索引上加锁的顺序是[1,4,2,3,5]，而事务B执行时，只在聚簇索引上加锁，加锁顺序是[1,2,3,4,5]，这样就造成了死锁的可能性。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194619-b0144.png" alt="img"></p>
<h3 id="4-gap锁冲突"><a href="#4-gap锁冲突" class="headerlink" title="4. gap锁冲突"></a>4. gap锁冲突</h3><p>innodb在RR级别下，如下的情况也会产生死锁，比较隐晦。不清楚的同学可以自行根据上节的gap锁原理分析下。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194619-5e115.png" alt="img"></p>
<h2 id="六、如何尽可能避免死锁"><a href="#六、如何尽可能避免死锁" class="headerlink" title="六、如何尽可能避免死锁"></a>六、如何尽可能避免死锁</h2><ol>
<li>以固定的顺序访问表和行。比如对第2节两个job批量更新的情形，简单方法是对id列表先排序，后执行，这样就避免了交叉等待锁的情形；又比如对于3.1节的情形，将两个事务的sql顺序调整为一致，也能避免死锁。</li>
<li>大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。</li>
<li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。</li>
<li>降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。</li>
<li>为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。=</li>
</ol>
<h2 id="七、如何查看锁"><a href="#七、如何查看锁" class="headerlink" title="七、如何查看锁"></a>七、如何查看锁</h2><p>从InnoDB1.0开始，在INFORMATION_SCHEMA架构下添加了表INNODB_TRX、INNODB_LOCKS、INNODB_LOCK_WAITS。（详情见附录）通过这三张表，用户可以更简单地监控当前事务并分析可能存在的锁问题。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#全局分析系统上中行锁的争夺情况</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'innodb_row_lock%'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#查看事务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.INNODB_TRX;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#查看锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.INNODB_LOCKS;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#查看锁等待情况</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.INNODB_LOCK_WAITS;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#通过联合查询可以比较直观的查看哪个事务阻塞了哪个事务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> r.trx_id              <span class="string">'等待事务ID'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       r.trx_mysql_thread_id <span class="string">'等待线程ID'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       r.trx_query           <span class="string">'等待事务运行语句'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       b.trx_id              <span class="string">'阻塞事务ID'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       b.trx_mysql_thread_id <span class="string">'阻塞线程ID'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       b.trx_query           <span class="string">'阻塞事务运行语句'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> information_schema.innodb_lock_waits w</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">INNER</span> <span class="keyword">JOIN</span> information_schema.innodb_trx b</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">ON</span> b.trx_id = w.blocking_trx_id</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">INNER</span> <span class="keyword">JOIN</span> information_schema.innodb_trx r</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">ON</span> r.trx_id = w.requesting_trx_id;</span></pre></td></tr></table></figure>

<h2 id="八、mysql是如何预防死锁的？"><a href="#八、mysql是如何预防死锁的？" class="headerlink" title="八、mysql是如何预防死锁的？"></a>八、mysql是如何预防死锁的？</h2><h3 id="innodb-lock-wait-timeout-等待锁超时回滚事务"><a href="#innodb-lock-wait-timeout-等待锁超时回滚事务" class="headerlink" title="innodb_lock_wait_timeout 等待锁超时回滚事务"></a>innodb_lock_wait_timeout 等待锁超时回滚事务</h3><p>直观方法是在两个事务相互等待时，当一个等待时间超过设置的某一阀值时，对其中一个事务进行回滚，另一个事务就能继续执行。</p>
<h3 id="wait-for-graph算法来主动进行死锁检测"><a href="#wait-for-graph算法来主动进行死锁检测" class="headerlink" title="wait-for graph算法来主动进行死锁检测"></a>wait-for graph算法来主动进行死锁检测</h3><p>每当加锁请求无法立即满足需要并进入等待时，wait-for graph算法都会被触发。<br>wait-for graph要求数据库保存以下两种信息：</p>
<ul>
<li>锁的信息链表</li>
<li>事务等待链表</li>
</ul>
<p>通过上述链表可以构造出一张图，而在这个图中若存在回路，就代表存在死锁，因此资源间相互发生等待。在wait-for graph中，事务为图中的节点。而在图中，事务T1指向T2边的定义为：</p>
<ul>
<li>事务T1等待事务T2所占用的资源</li>
<li>事务T1最终等待T2所占用的资源，也就是事务之间在等待相同的资源，而事务T1发生在事务T2的后面</li>
</ul>
<p><img src="http://image.winrains.cn/2019/08/20190829194619-3a057.jpeg" alt="img"></p>
<p>示例事务状态和锁的信息<br>在Transaction Wait Lists中可以看到共有4个事务t1、t2、t3、t4，故在wait-for graph中应有4个节点。而事务t2对row1占用x锁，事务t1对row2占用s锁。事务t1需要等待事务t2中row1的资源，因此在wait-for graph中有条边从节点t1指向节点t2。事务t2需要等待事务t1、t4所占用的row2对象，故而存在节点t2到节点t1、t4的边。同样，存在节点t3到节点t1、t2、t4的边，因此最终的wait-for graph如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829194619-bc75d.jpeg" alt="img"></p>
<p>ps:若存在则有死锁，通常来说InnoDB存储引擎选择回滚undo量最小的事务并从新开始</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="INNODB-ROW-LOCK"><a href="#INNODB-ROW-LOCK" class="headerlink" title="INNODB_ROW_LOCK"></a>INNODB_ROW_LOCK</h3><table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>innodb_row_lock_current_waits</td>
<td>当前正在等待锁定的数量</td>
</tr>
<tr>
<td><strong>innodb_row_lock_time</strong></td>
<td>从系统启动到现在锁定总时间长度</td>
</tr>
<tr>
<td><strong>innodb_row_lock_time_avg</strong></td>
<td>每次等待所花平均时间</td>
</tr>
<tr>
<td>innodb_row_lock_time_max</td>
<td>从系统启动到现在等待最常的一次所花的时间</td>
</tr>
<tr>
<td><strong>innodb_row_lock_waits</strong></td>
<td>系统启动后到现在总共等待的次数；直接决定优化的方向和策略</td>
</tr>
</tbody></table>
<h3 id="INNODB-TRX"><a href="#INNODB-TRX" class="headerlink" title="INNODB_TRX"></a>INNODB_TRX</h3><p>提供有关当前正在内部执行的每个事务的信息 InnoDB，包括事务是否在等待锁定，事务何时启动以及事务正在执行的SQL语句（如果有）。详见<a href="https://link.juejin.im?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Finnodb-trx-table.html">dev.mysql.com/doc/refman/…</a></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>TRX_ID</strong></td>
<td><a href="https://link.juejin.im?target=http%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Finnodb-performance-ro-txn.html">事务Id</a></td>
</tr>
<tr>
<td><strong>TRX_WEIGHT</strong></td>
<td>事务的权重，反映（但不一定是确切的计数）更改的行数和事务锁定的行数。要解决死锁，请 InnoDB``选择权重最小的事务作为回滚的“ 受害者 ”。无论更改和锁定行的数量如何，已更改非事务表的事务都被认为比其他事务更重。</td>
</tr>
<tr>
<td><strong>TRX_STATE</strong></td>
<td>事务执行状态。允许值是 RUNNING<code>，LOCK WAIT</code>， ROLLING BACK<code>，和 COMMITTING</code>。</td>
</tr>
<tr>
<td>TRX_STARTED</td>
<td>交易开始时间。</td>
</tr>
<tr>
<td><strong>TRX_REQUESTED_LOCK_ID</strong></td>
<td>事务当前正在等待的锁的ID，如果TRX_STATE<code>是LOCK WAIT</code>; 否则NULL``。</td>
</tr>
<tr>
<td><strong>TRX_WAIT_STARTED</strong></td>
<td>交易开始等待锁定的时间，如果 TRX_STATE<code>是LOCK WAIT</code>; 否则NULL``。</td>
</tr>
<tr>
<td><strong>TRX_MYSQL_THREAD_ID</strong></td>
<td>MySQL线程ID，与show processlist中的ID值相对应</td>
</tr>
<tr>
<td><strong>TRX_QUERY</strong></td>
<td>事务正在执行的SQL语句</td>
</tr>
<tr>
<td>TRX_OPERATION_STATE</td>
<td>交易的当前操作，如果有的话; 否则 NULL``。</td>
</tr>
<tr>
<td>TRX_TABLES_IN_USE</td>
<td>InnoDB``处理此事务的当前SQL语句时使用 的表数。</td>
</tr>
<tr>
<td>TRX_TABLES_LOCKED</td>
<td>InnoDB``当前SQL语句具有行锁定 的表的数量。（因为这些是行锁，而不是表锁，所以通常仍可以通过多个事务读取和写入表，尽管某些行被锁定。）</td>
</tr>
<tr>
<td>TRX_LOCK_STRUCTS</td>
<td>事务保留的锁数。</td>
</tr>
<tr>
<td>TRX_LOCK_MEMORY_BYTES</td>
<td>内存中此事务的锁结构占用的总大小</td>
</tr>
<tr>
<td>TRX_ROWS_LOCKED</td>
<td>此交易锁定的大致数字或行数。该值可能包括实际存在但对事务不可见的删除标记行</td>
</tr>
<tr>
<td>TRX_ROWS_MODIFIED</td>
<td>此事务中已修改和插入的行数。</td>
</tr>
<tr>
<td>TRX_CONCURRENCY_TICKETS</td>
<td>一个值，指示当前事务在被换出之前可以执行多少工作</td>
</tr>
<tr>
<td>TRX_ISOLATION_LEVEL</td>
<td>当前事务的隔离级别。</td>
</tr>
<tr>
<td>TRX_UNIQUE_CHECKS</td>
<td>是否为当前事务打开或关闭唯一检查。例如，在批量数据加载期间可能会关闭它们</td>
</tr>
<tr>
<td>TRX_FOREIGN_KEY_CHECKS</td>
<td>是否为当前事务打开或关闭外键检查。例如，在批量数据加载期间可能会关闭它们</td>
</tr>
<tr>
<td>TRX_LAST_FOREIGN_KEY_ERROR</td>
<td>最后一个外键错误的详细错误消息（如果有）; 否则NULL``</td>
</tr>
<tr>
<td>TRX_ADAPTIVE_HASH_LATCHED</td>
<td>自适应哈希索引是否被当前事务锁定。当自适应哈希索引搜索系统被分区时，单个事务不会锁定整个自适应哈希索引。自适应哈希索引分区由<a href="https://link.juejin.im?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Finnodb-parameters.html%23sysvar_innodb_adaptive_hash_index_parts">innodb_adaptive_hash_index_parts``</a>，默认设置为8。</td>
</tr>
<tr>
<td>TRX_ADAPTIVE_HASH_TIMEOUT</td>
<td>是否立即为自适应哈希索引放弃搜索锁存器，或者在MySQL的调用之间保留它。当没有自适应哈希索引争用时，该值保持为零，语句保留锁存器直到它们完成。在争用期间，它倒计时到零，并且语句在每次行查找后立即释放锁存器。当自适应散列索引搜索系统被分区（受控制 <a href="https://link.juejin.im?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Finnodb-parameters.html%23sysvar_innodb_adaptive_hash_index_parts">innodb_adaptive_hash_index_parts``</a>）时，该值保持为0。</td>
</tr>
<tr>
<td>TRX_IS_READ_ONLY</td>
<td>值为1表示事务是只读的。</td>
</tr>
<tr>
<td>TRX_AUTOCOMMIT_NON_LOCKING</td>
<td>值为1表示事务是 <a href="https://link.juejin.im?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Fserver-system-variables.html%23sysvar_autocommit">SELECT<code>](https://dev.mysql.com/doc/refman/5.7/en/select.html)不使用FOR UPDATE</code>or或 LOCK IN SHARED MODE<code>子句的语句，并且正在执行， [autocommit</code></a>因此事务将仅包含此一个语句。当此列和TRX_IS_READ_ONLY<code>都为1时，InnoDB</code>优化事务以减少与更改表数据的事务关联的开销</td>
</tr>
</tbody></table>
<h3 id="INNODB-LOCKS"><a href="#INNODB-LOCKS" class="headerlink" title="INNODB_LOCKS"></a>INNODB_LOCKS</h3><p>提供有关InnoDB 事务已请求但尚未获取的每个锁的信息，以及事务持有的阻止另一个事务的每个锁。详见<a href="https://link.juejin.im?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Finnodb-locks-table.html">dev.mysql.com/doc/refman/…</a></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>LOCK_ID</td>
<td>一个唯一的锁ID号，内部为 InnoDB``。</td>
</tr>
<tr>
<td>LOCK_TRX_ID</td>
<td>持有锁的交易的ID</td>
</tr>
<tr>
<td>LOCK_MODE</td>
<td>如何请求锁定。允许锁定模式描述符 S<code>，X</code>， IS<code>，IX</code>， GAP<code>，AUTO_INC</code>，和 UNKNOWN``。锁定模式描述符可以组合使用以识别特定的锁定模式。</td>
</tr>
<tr>
<td>LOCK_TYPE</td>
<td>锁的类型</td>
</tr>
<tr>
<td>LOCK_TABLE</td>
<td>已锁定或包含锁定记录的表的名称</td>
</tr>
<tr>
<td>LOCK_INDEX</td>
<td>索引的名称，如果LOCK_TYPE是 RECORD; 否则NULL</td>
</tr>
<tr>
<td>LOCK_SPACE</td>
<td>锁定记录的表空间ID，如果 LOCK_TYPE<code>是RECORD</code>; 否则NULL``</td>
</tr>
<tr>
<td>LOCK_PAGE</td>
<td>锁定记录的页码，如果 LOCK_TYPE<code>是RECORD</code>; 否则NULL``。</td>
</tr>
<tr>
<td>LOCK_REC</td>
<td>页面内锁定记录的堆号，如果 LOCK_TYPE<code>是RECORD</code>; 否则NULL``。</td>
</tr>
<tr>
<td>LOCK_DATA</td>
<td>与锁相关的数据（如果有）。如果 LOCK_TYPE<code>是RECORD</code>，是锁定的记录的主键值，否则NULL<code>。此列包含锁定行中主键列的值，格式为有效的SQL字符串。如果没有主键，LOCK_DATA</code>则是唯一的InnoDB<code>内部行ID号。如果对键值或范围高于索引中的最大值的间隙锁定，则LOCK_DATA</code> 报告<em>supremum</em> <em>pseudo-record</em>。当包含锁定记录的页面不在缓冲池中时（如果在保持锁定时将其分页到磁盘），InnoDB<code>不从磁盘获取页面，以避免不必要的磁盘操作。相反， LOCK_DATA</code>设置为 NULL``。</td>
</tr>
</tbody></table>
<h3 id="INNODB-LOCK-WAITS"><a href="#INNODB-LOCK-WAITS" class="headerlink" title="INNODB_LOCK_WAITS"></a>INNODB_LOCK_WAITS</h3><p>包含每个被阻止InnoDB 事务的一个或多个行，指示它已请求的锁以及阻止该请求的任何锁。详见<a href="https://link.juejin.im?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Finnodb-lock-waits-table.html">dev.mysql.com/doc/refman/…</a></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>REQUESTING_TRX_ID</td>
<td>请求（阻止）事务的ID。</td>
</tr>
<tr>
<td>REQUESTED_LOCK_ID</td>
<td>事务正在等待的锁的ID。</td>
</tr>
<tr>
<td>BLOCKING_TRX_ID</td>
<td>阻止事务的ID。</td>
</tr>
<tr>
<td>BLOCKING_LOCK_ID</td>
<td>由阻止另一个事务继续进行的事务所持有的锁的ID</td>
</tr>
</tbody></table>
<h2 id="引用文献"><a href="#引用文献" class="headerlink" title="引用文献"></a>引用文献</h2><p>《MySQL技术内幕：InnoDB存储引擎》<br><a href="https://link.juejin.im?target=http%3A%2F%2Fhedengcheng.com%2F%3Fp%3D771">何登成MySQL 加锁处理分析</a><br><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fcrazylqy%2Fp%2F7611069.html">Mysql加锁过程详解</a><br><a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fyuyinghua0302%2Farticle%2Fdetails%2F82318408">数据库事务和锁（三）</a><br><a href="https://juejin.im/post/5d04b33e6fb9a07ee1692653#heading-7" target="_blank" rel="noopener">针对MySQL死锁问题的思路分析</a></p>
<blockquote>
<p>作者：白山丶</p>
<p>来源：<a href="https://juejin.im/post/5d3e8b63f265da1bce3e1988" target="_blank" rel="noopener">https://juejin.im/post/5d3e8b63f265da1bce3e1988</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>git操作（13）：remote</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%8813%EF%BC%89%EF%BC%9Aremote/</url>
    <content><![CDATA[<p>git是分布式版本管理工具，它没有中央仓库。但多人协作时，我们依然需要一个集散地，让协作成员之间统一往集散地推送和拉取更新。否则，点对点的沟通，效率会很低。<br>所以就引出了git中远端仓库的概念。</p>
<a id="more"></a>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>我们之前所有的操作都是在本地仓库完成的，和本地仓库对应的是远端仓库。那么本地有若干分支，远端仓库是不是也有对应的若干分支呢？<br>当然。<br>我们探讨一个问题，在离线状态下，git是不是无从知道远端仓库的任何状态？<br>我让网络下线，查询从github克隆下来的本地仓库的状态，结果它告诉我本地仓库的master分支是<code>up to date with &#39;origin/master&#39;</code>。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Your branch <span class="keyword">is</span> up <span class="keyword">to</span> <span class="type">date</span> <span class="keyword">with</span> <span class="string">'origin/master'</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">nothing</span> <span class="keyword">to</span> <span class="keyword">commit</span>, working tree clean</span></pre></td></tr></table></figure>

<p>实际上，git的分支有三种：</p>
<ul>
<li>本地分支，我们可以通过``写法访问它。</li>
<li>远端分支，我们可以通过``写法访问它。</li>
<li>远端分支引用，我们可以通过``写法访问它。实际上它也是本地分支，只不过我们无法操作它，只有git的网络操作才可以更新它。离线状态下，git给的状态就是本地分支和远端分支引用的比较结果。</li>
</ul>
<blockquote>
<p>git官方把我所说的<code>远端分支引用</code>称为<code>远端分支</code>。知道谁是谁就行了，名字不重要🤔<br>我是马蹄疾</p>
</blockquote>
<p>我们看一下本地的远端分支引用。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">.git/</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git<span class="meta-keyword">/refs/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">.git<span class="meta-keyword">/refs/</span>remotes/</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git<span class="meta-keyword">/refs/</span>remotes<span class="meta-keyword">/origin/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">.git<span class="meta-keyword">/refs/</span>remotes<span class="meta-keyword">/origin/</span>HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git<span class="meta-keyword">/refs/</span>remotes<span class="meta-keyword">/origin/</span>master</span></pre></td></tr></table></figure>

<p>默认的远端仓库名就叫<code>origin</code>。它也有master分支指针，也有HEAD指针。</p>
<h2 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h2><p>如果远端仓库有新的提交或者新的分支，我们需要运行<code>git fetch</code>命令来拉取更新。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git fetch</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Enumerating objects: <span class="number">5</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Counting objects: <span class="number">100</span>% (<span class="number">5</span>/<span class="number">5</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>), pack-reused <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Unpacking objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">From github.com:veedrin/git</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">3893459.</span><span class="number">.0f</span>80eeb  master     -&gt; origin/master</span></pre></td></tr></table></figure>

<p>这个命令是<code>git fetch origin</code>的缩写。因为<code>origin</code>是远端仓库的默认名称，所以可以省略。如果有手动添加的远端仓库，那就必须指定远端仓库的名称了。<br>这个命令做了什么呢？<br>它会把新的提交和新的分支拉取到本地，然后更新本地的远端分支引用到最新的提交。<br><code>git fetch</code>仅仅是将远端的更新拉取下来，同步本地的远端分支引用，不会对本地分支有任何影响。我们需要手动执行合并操作才能更新本地分支。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">merge</span> origin/<span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Your branch <span class="keyword">is</span> up <span class="keyword">to</span> <span class="built_in">date</span> <span class="keyword">with</span> <span class="string">'origin/master'</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">nothing</span> <span class="keyword">to</span> <span class="keyword">commit</span>, working tree clean</span></pre></td></tr></table></figure>

<p>当然，有一个更简单的操作。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git pull</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Enumerating objects: <span class="number">5</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Counting objects: <span class="number">100</span>% (<span class="number">5</span>/<span class="number">5</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Unpacking objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>), pack-reused <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">From github.com:veedrin/git</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">4f</span>bd1d4..d9785d7  master     -&gt; origin/master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Updating <span class="number">4f</span>bd1d4..d9785d7</span></pre></td></tr><tr><td class="code"><pre><span class="line">Fast-forward</span></pre></td></tr><tr><td class="code"><pre><span class="line"> README.md | <span class="number">2</span> ++</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">2</span> insertions(+)</span></pre></td></tr></table></figure>

<p><code>git pull</code>就是<code>git fetch</code>和<code>git merge</code>的一键操作。</p>
<h2 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h2><p>推送到远端的命令是<code>git push</code>。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Counting objects: <span class="number">3</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="number">261</span> bytes | <span class="number">261.00</span> KiB/s, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">To github.com:veedrin/git.git</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">3</span>eaa1ae.<span class="number">.2</span>bd3c9d  master -&gt; master</span></pre></td></tr></table></figure>

<p>如果当前分支对远端分支设置了追踪的话，也可以省略分支名。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git push</span></pre></td></tr><tr><td class="code"><pre><span class="line">Counting objects: <span class="number">3</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="number">261</span> bytes | <span class="number">261.00</span> KiB/s, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">To github.com:veedrin/git.git</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">3</span>eaa1ae.<span class="number">.2</span>bd3c9d  master -&gt; master</span></pre></td></tr></table></figure>

<p>有时候本地分支和远端分支同时有新的提交，直接<code>push</code>是不行的。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git push</span></pre></td></tr><tr><td class="code"><pre><span class="line">To github.<span class="keyword">com</span>:veedrin/git.git</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ! [rejected]        master -&gt; master (fetch <span class="keyword">first</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">error: failed <span class="keyword">to</span> push some refs <span class="keyword">to</span> <span class="string">'git@github.com:veedrin/git.git'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">hin<span class="variable">t:</span> Updates were rejected because the remote contains work that you <span class="keyword">do</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">hin<span class="variable">t:</span> not have locally. This <span class="keyword">is</span> usually caused by another repository pushing</span></pre></td></tr><tr><td class="code"><pre><span class="line">hin<span class="variable">t:</span> <span class="keyword">to</span> the same ref. You may want <span class="keyword">to</span> <span class="keyword">first</span> integrate the remote <span class="keyword">changes</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">hin<span class="variable">t:</span> (<span class="keyword">e</span>.g., <span class="string">'git pull ...'</span>) before pushing again.</span></pre></td></tr><tr><td class="code"><pre><span class="line">hin<span class="variable">t:</span> See the <span class="string">'Note about fast-forwards'</span> in <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span></pre></td></tr></table></figure>

<p>有两种方式解决。<br>第一是先把远端的更新拉下来，有冲突则解决冲突，没冲突则再推送。<br>第二是强推。有时候我们就是想覆盖远端对吧，也不是不行，但是必须十分谨慎。而且不要在公共分支上强制推送。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git push -f</span></pre></td></tr><tr><td class="code"><pre><span class="line">Counting objects: <span class="number">24</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Delta compression using up to <span class="number">4</span> threads.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">8</span>/<span class="number">8</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">24</span>/<span class="number">24</span>), <span class="number">3.72</span> KiB | <span class="number">1.24</span> MiB/s, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="number">24</span> (delta <span class="number">0</span>), reused <span class="number">3</span> (delta <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">To github.com:veedrin/git.git</span></pre></td></tr><tr><td class="code"><pre><span class="line"> + <span class="number">54</span>d741b..<span class="number">.2</span>db10e0 master -&gt; master (forced update)</span></pre></td></tr></table></figure>

<p>实际开发时我们会建很多特性分支，推送到远端，通过测试后再合入主分支。使用<code>git push</code>每次都要指定远端分支名，如果会有多次推送，我们可以在推送时设置本地分支追踪远端分支，这样下次就可以直接推送了。<br>也可以简写成<code>git push -u</code>。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git push --<span class="keyword">set</span>-upstream origin dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Counting object<span class="variable">s:</span> <span class="number">3</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Delta compression using <span class="keyword">up</span> <span class="keyword">to</span> <span class="number">4</span> threads.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Compressing object<span class="variable">s:</span> <span class="number">100</span>% (<span class="number">2</span>/<span class="number">2</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Writing object<span class="variable">s:</span> <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="number">255</span> bytes | <span class="number">255.00</span> KiB/s, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote:</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Create <span class="keyword">a</span> pull request <span class="keyword">for</span> <span class="string">'dev'</span> <span class="keyword">on</span> GitHub by visitin<span class="variable">g:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">remote:      http<span class="variable">s:</span>//github.<span class="keyword">com</span>/veedrin/git/pull/<span class="keyword">new</span>/dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote:</span></pre></td></tr><tr><td class="code"><pre><span class="line">To github.<span class="keyword">com</span>:veedrin/git.git</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * [<span class="keyword">new</span> branch]      dev -&gt; dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Branch <span class="string">'dev'</span> <span class="keyword">set</span> <span class="keyword">up</span> <span class="keyword">to</span> track remote branch <span class="string">'dev'</span> from <span class="string">'origin'</span>.</span></pre></td></tr></table></figure>

<p>然后我们在<code>.git/config</code>文件中能看到多了一条配置。</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">[branch <span class="string">"dev"</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">remote</span> = origin</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">merge</span> = refs/heads/dev</span></pre></td></tr></table></figure>

<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>查看远端仓库的命令是<code>git remote</code>。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote</span></pre></td></tr><tr><td class="code"><pre><span class="line">origin</span></pre></td></tr></table></figure>

<p>加<code>-v</code>参数可以查看更为详细的信息，<code>-v</code>是<code>--verbose</code>的缩写。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span></pre></td></tr><tr><td class="code"><pre><span class="line">origin	git<span class="meta">@github</span>.<span class="string">com:</span>veedrin/git.git (fetch)</span></pre></td></tr><tr><td class="code"><pre><span class="line">origin	git<span class="meta">@github</span>.<span class="string">com:</span>veedrin/git.git (push)</span></pre></td></tr></table></figure>

<p>查看某个远端仓库的信息，可以使用命令<code>git remote show</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git remote <span class="keyword">show</span> origin</span></pre></td></tr><tr><td class="code"><pre><span class="line">* remote origin</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">Fetch</span> <span class="keyword">URL</span>: git@github.com:veedrin/git<span class="number">-1.</span>git</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Push  <span class="keyword">URL</span>: git@github.com:veedrin/git<span class="number">-1.</span>git</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">HEAD</span> branch: <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Remote branches:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dev    tracked</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">master</span> tracked</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">Local</span> branches configured <span class="keyword">for</span> <span class="string">'git pull'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dev    merges <span class="keyword">with</span> remote dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">master</span> merges <span class="keyword">with</span> remote <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">Local</span> refs configured <span class="keyword">for</span> <span class="string">'git push'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">master</span> pushes <span class="keyword">to</span> <span class="keyword">master</span> (up <span class="keyword">to</span> <span class="built_in">date</span>)</span></pre></td></tr></table></figure>

<h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><p>添加新的远端仓库，使用<code>git remote add</code>命令。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git remote <span class="built_in">add</span> horseshoe http<span class="variable">s:</span>//github.<span class="keyword">com</span>/veedrin/horseshoe</span></pre></td></tr></table></figure>

<p>然后本地就多了一个远端仓库。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote</span></pre></td></tr><tr><td class="code"><pre><span class="line">horseshoe</span></pre></td></tr><tr><td class="code"><pre><span class="line">origin</span></pre></td></tr></table></figure>

<p>除了添加远端仓库，我们还可以添加本地分支对远端分支的追踪。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Branch <span class="string">'dev'</span> <span class="built_in">set</span> up <span class="built_in">to</span> track remote branch <span class="string">'dev'</span> <span class="built_in">from</span> <span class="string">'origin'</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched <span class="built_in">to</span> <span class="keyword">a</span> <span class="built_in">new</span> branch <span class="string">'dev'</span></span></pre></td></tr></table></figure>

<p>创建dev分支的同时，也设置了对远端分支dev的追踪，这样下次推送的时候就不需要指定了。<br>当然，远端分支引用必须得存在才行。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">fatal: <span class="string">'origin/dev'</span> is <span class="keyword">not</span> <span class="keyword">a</span> commit <span class="keyword">and</span> <span class="keyword">a</span> branch <span class="string">'dev'</span> cannot be created <span class="built_in">from</span> <span class="keyword">it</span></span></pre></td></tr></table></figure>

<p>git也提供了快捷方式。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git checkout <span class="comment">--track origin/dev</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Branch <span class="string">'dev'</span> <span class="built_in">set</span> up <span class="built_in">to</span> track remote branch <span class="string">'dev'</span> <span class="built_in">from</span> <span class="string">'origin'</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched <span class="built_in">to</span> <span class="keyword">a</span> <span class="built_in">new</span> branch <span class="string">'dev'</span></span></pre></td></tr></table></figure>

<h2 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h2><p>有时候你想修改远端仓库的简写名。比如你将女朋友的名字命名为远端仓库的简写名，然后你们分手了。这真是一个令人悲伤(欣喜)的故事。</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">$ git remote <span class="built_in">rename</span> nvpengyou gaoyuanyuan</span></pre></td></tr></table></figure>

<p>查看远端仓库列表。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote</span></pre></td></tr><tr><td class="code"><pre><span class="line">gaoyuanyuan</span></pre></td></tr><tr><td class="code"><pre><span class="line">origin</span></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>一般来说，一个git项目有一个远端仓库就行了，其余的大多是临时性的。所以总有一天要删除它。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote rm horseshoe</span></pre></td></tr></table></figure>

<p>查看远端仓库列表。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote</span></pre></td></tr><tr><td class="code"><pre><span class="line">origin</span></pre></td></tr></table></figure>

<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/remote.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/remote.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（12）：tag</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%8812%EF%BC%89%EF%BC%9Atag/</url>
    <content><![CDATA[<p>git是一个版本管理工具，但在众多版本中，肯定有一些版本是比较重要的，这时候我们希望给这些特定的版本打上标签。比如发布一年以后，程序的各项功能都趋于稳定，可以在圣诞节发布<code>v1.0</code>版本。这个<code>v1.0</code>在git中就可以通过标签实现。<br>而git标签又分为两种，轻量级标签和含附注标签。</p>
<a id="more"></a>

<p>轻量级标签和分支的表现形式是一样的，仅仅是一个指向commit的指针而已。只不过它不能切换，一旦贴上就无法再挪动了。<br>含附注标签才是我们理解的那种标签，它是一个独立的git对象。包含标签的名字，电子邮件地址和日期，以及标签说明。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>创建轻量级标签的命令很简单，运行<code>git tag</code>。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">v0</span>.<span class="number">3</span></span></pre></td></tr></table></figure>

<p>在<code>.git</code>目录中就多了一个指针文件。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/<span class="built_in">ref</span>s/tags/v0<span class="number">.3</span></span></pre></td></tr></table></figure>

<p>创建含附注标签要加一个参数<code>-a</code>，它是<code>--annotated</code>的缩写。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> v1.<span class="number">0</span></span></pre></td></tr></table></figure>

<p>和<code>git commit</code>一样，如果不加<code>-m</code>参数，则会弹出默认或者自定义的编辑器，要求你写标签说明。<br>不写呢？</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">fatal: no <span class="keyword">tag</span> <span class="title">message</span>?</span></pre></td></tr></table></figure>

<p>创建完含附注标签后，<code>.git</code>目录会多出两个文件。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/<span class="built_in">ref</span>s/tags/v0<span class="number">.3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">80</span>/e79e91ce192e22a9fd860182da6649c4614ba1</span></pre></td></tr></table></figure>

<p>含附注标签不仅会创建一个指针，还会创建一个tag对象。<br>我们了解过git有四种对象类型，tag类型是我们认识的最后一种。<br>我们看看该对象的类型。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">cat</span>-<span class="keyword">file</span> -t <span class="number">80</span>e79e9</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">tag</span></span></pre></td></tr></table></figure>

<p>再来看看该对象的内容。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ git cat-file -p 80e79e9</span></pre></td></tr><tr><td class="code"><pre><span class="line">object 359fd95229532cd352aec43aada8e6cea68d87a9</span></pre></td></tr><tr><td class="code"><pre><span class="line">type commit</span></pre></td></tr><tr><td class="code"><pre><span class="line">tag v1.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">tagger veedrin &lt;veedrin@qq.com&gt; 1545878480 +0800</span></pre></td></tr><tr><td class="code"><pre><span class="line">版本 v1.0</span></pre></td></tr></table></figure>

<p>它关联的是一个commit对象，包含标签的名称，打标签的人，打标签的时间以及标签说明。<br>我可不可以给历史commit打标签呢？当然可以。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> v1.<span class="number">0</span> <span class="number">36</span>ff0f5</span></pre></td></tr></table></figure>

<p>只需在后面加上commit的校验和。</p>
<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>查看当前git项目的标签列表，运行<code>git tag</code>命令不带任何参数即可。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">v0.<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">v1.<span class="number">0</span></span></pre></td></tr></table></figure>

<p>注意git标签是按字母顺序排列的，而不是按时间顺序排列。<br>而且我并没有找到分别查看轻量级标签和含附注标签的方法。<br>查看标签详情可以使用<code>git show</code>。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git show v0<span class="number">.3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">36f</span>f0f58c8e6b6a441733e909dc95a6136a4f91b (tag: v0<span class="number">.3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Thu Dec <span class="number">27</span> <span class="number">11</span>:<span class="number">08</span>:<span class="number">09</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    add a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/a.md b/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">new file mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">0000000.</span>.e69de29</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git show v1<span class="number">.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">tag v1<span class="number">.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Tagger: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Thu Dec <span class="number">27</span> <span class="number">11</span>:<span class="number">08</span>:<span class="number">39</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">版本 v1<span class="number">.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">6</span>dfdb65ce65b782a6cb57566bcc1141923059d2b (HEAD -&gt; master, tag: v1<span class="number">.0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Thu Dec <span class="number">27</span> <span class="number">11</span>:<span class="number">08</span>:<span class="number">33</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    add b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/b.md b/b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">new file mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">0000000.</span>.e69de29</span></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>虽然git标签不能移动对吧，但我们可以删除它呀。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-d</span> v0.<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Deleted <span class="keyword">tag</span> <span class="title">'v0</span>.<span class="number">3</span>' (was <span class="number">36</span>ff0f5)</span></pre></td></tr><tr><td class="code"><pre><span class="line">如果标签已经推送到了远端，也是可以删除的。$ git push origin -d v0.<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">To github.com:veedrin/git.git</span></pre></td></tr><tr><td class="code"><pre><span class="line"> - [deleted]         v0.<span class="number">3</span></span></pre></td></tr></table></figure>

<h2 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h2><p>默认情况下，<code>git push</code>推送到远端仓库并不会将标签也推送上去。如果想将标签推送到远端与别人共享，我们得显式的运行命令<code>git push origin</code>。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git push origin v1<span class="number">.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Counting objects: <span class="number">1</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">1</span>/<span class="number">1</span>), <span class="number">160</span> bytes | <span class="number">160.00</span> KiB/s, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="number">1</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">To github.com:veedrin/git.git</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * [new tag]         v1<span class="number">.0</span> -&gt; v1<span class="number">.0</span></span></pre></td></tr></table></figure>

<p>这里并不区分轻量级标签和含附注标签。<br>一次性将本地标签推送到远端仓库也是可以的。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> --tags</span></pre></td></tr></table></figure>

<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/tag.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/tag.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（11）：position</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%8811%EF%BC%89%EF%BC%9Aposition/</url>
    <content><![CDATA[<p>程序遇到bug的时候，我们需要快速定位。<br>定位有两种，第一种是定位bug在哪个提交上，第二种是定位特定文件的某一行是谁最近提交的。</p>
<a id="more"></a>

<h2 id="bisect"><a href="#bisect" class="headerlink" title="bisect"></a>bisect</h2><p>有时候我们发现程序有bug，但是回退几个版本都不解决问题。说明这个bug是一次很老的提交导致的，也不知道当时怎么就没察觉。<br>那怎么办呢？继续一个一个版本的回退？<br>估计<code>Linus Torvalds</code>会鄙视你吧。<br>为了专注于工作，不分心来鄙视你，<code>Linus Torvalds</code>在git中内置了一套定位bug的命令。<br>大家都玩过猜数字游戏吧。主持人悄悄写下一个数，给大家一个数字区间，然后大家轮流开始切割，谁切到主持人写的那个数就要自罚三杯了。<br>对，这就是二分法。git利用二分法定位bug的命令是<code>git bisect</code>。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>假设目前的git项目历史是这样的。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span> -- <span class="built_in">C3</span> -- <span class="built_in">C4</span> -- <span class="built_in">C5</span> -- <span class="built_in">C6</span> -- <span class="built_in">C7</span> -- <span class="built_in">C8</span> -- <span class="built_in">C9</span>(HEAD -&gt; master)</span></pre></td></tr></table></figure>

<p>这里面有一次commit藏了一个bug，但幸运的是，你不知道是哪一次。<br>运行<code>git bisect start</code>命令，后跟你要定位的区间中最新的commit和最老的commit。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git bisect <span class="keyword">start</span> <span class="keyword">HEAD</span> C0</span></pre></td></tr><tr><td class="code"><pre><span class="line">Bisecting: <span class="number">4</span> revisions <span class="keyword">left</span> <span class="keyword">to</span> <span class="keyword">test</span> <span class="keyword">after</span> this (roughly <span class="number">2</span> steps)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[ee27077fdfc6c0c9281c1b7f6957ea2b59a461dd] C4</span></pre></td></tr></table></figure>

<p>然后你就发现HEAD指针自动的指向了<code>C4</code>commit。如果范围是奇数位，那取中间就行了，如果范围是偶数位，则取中间更偏老的那个commit，就比如这里的<code>C4</code>commit。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git bisect good</span></pre></td></tr><tr><td class="code"><pre><span class="line">Bisecting: <span class="number">2</span> revisions left to test after <span class="keyword">this</span> (roughly <span class="number">1</span> step)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">97</span>cc0e879dc09796bd56cfd7c3a54deb41e447f6] C6</span></pre></td></tr></table></figure>

<p>HEAD指针指向<code>C4</code>commit后，你应该运行一下程序，如果没问题，那说明有bug的提交在它之后。我们只需要告诉git当前commit以及更老的commit都是好的。<br>然后HEAD指针就自动指向<code>C6</code>commit。<br>继续在<code>C6</code>commit运行程序，结果复现了bug。说明问题就出在<code>C6</code>commit和<code>C4</code>commit之间。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">bisect </span><span class="keyword">bad</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Bisecting: </span><span class="number">0</span> <span class="keyword">revisions </span>left to test after this (roughly <span class="number">0</span> steps)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[a7e09bd3eab7d1e824c0338233f358cafa682af0] <span class="built_in">C5</span></span></pre></td></tr></table></figure>

<p>将<code>C6</code>commit标记为<code>bad</code>之后，HEAD指针自动指向<code>C5</code>commit。再次运行程序，依然能复现bug。话不多说，标记<code>C5</code>commit为<code>bad</code>。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git bisect <span class="keyword">bad</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">a7e09bd3eab7d1e824c0338233f358cafa682af0 <span class="keyword">is</span> the <span class="keyword">first</span> <span class="keyword">bad</span> commit</span></pre></td></tr></table></figure>

<p>因为<code>C4</code>commit和<code>C5</code>commit之间已经不需要二分了，git会告诉你，<code>C5</code>commit是你标记为<code>bad</code>的最早的commit。问题就应该出在<code>C5</code>commit上。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git bisect <span class="keyword">reset</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Previous <span class="keyword">HEAD</span> <span class="keyword">position</span> was a7e09bd... C5</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched <span class="keyword">to</span> branch <span class="string">'master'</span></span></pre></td></tr></table></figure>

<p>既然找到问题了，那就可以退出<code>git bisect</code>工具了。<br>另外，<code>git bisect old</code>和<code>git bisect good</code>的效果相同，<code>git bisect new</code>和<code>git bisect bad</code>的效果相同，这是因为git考虑到，有时候开发者并不是想定位bug，只是想定位某个commit，这时候用<code>good bad</code>就会有点别扭。</p>
<h3 id="后悔"><a href="#后悔" class="headerlink" title="后悔"></a>后悔</h3><p><code>git bisect</code>确实很强大，但如果我已经<code>bisect</code>若干次，结果不小心把一个<code>good</code>commit标记为<code>bad</code>，或者相反，难道我要<code>reset</code>重来么？<br><code>git bisect</code>还有一个<code>log</code>命令，我们只需要保存<code>bisect</code>日志到一个文件，然后擦除文件中标记错误的日志，然后按新的日志重新开始<code>bisect</code>就好了。</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">git bisect <span class="built_in">log</span> &gt; <span class="built_in">log</span>.txt</span></pre></td></tr></table></figure>

<p>该命令的作用是将日志保存到<code>log.txt</code>文件中。<br>看看<code>log.txt</code>文件中的内容。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"># bad: [<span class="number">4</span>d<span class="number">5e75</span><span class="keyword">c</span><span class="number">7</span>a<span class="number">9e6</span>e<span class="number">65</span>a<span class="number">168</span>d<span class="number">6</span>a<span class="number">2663e95</span>b<span class="number">19</span>da<span class="number">1e2</span>b<span class="number">21</span>] C<span class="number">9</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"># good: [<span class="keyword">c</span><span class="number">2</span>fa<span class="number">7</span>ca<span class="number">426</span>cac<span class="number">9990</span>ba<span class="number">27466520677</span>bf<span class="number">1780</span>af<span class="number">97</span>] <span class="keyword">add</span> a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">git bisect start 'HEAD' '<span class="keyword">c</span><span class="number">2</span>fa<span class="number">7</span>ca<span class="number">426</span>cac<span class="number">9990</span>ba<span class="number">27466520677</span>bf<span class="number">1780</span>af<span class="number">97</span>'</span></pre></td></tr><tr><td class="code"><pre><span class="line"># good: [ee<span class="number">27077</span>fdfc<span class="number">6</span><span class="keyword">c</span><span class="number">0</span><span class="keyword">c</span><span class="number">9281</span><span class="keyword">c</span><span class="number">1</span>b<span class="number">7</span>f<span class="number">6957</span>ea<span class="number">2</span>b<span class="number">59</span>a<span class="number">461</span>dd] C<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">git bisect good ee<span class="number">27077</span>fdfc<span class="number">6</span><span class="keyword">c</span><span class="number">0</span><span class="keyword">c</span><span class="number">9281</span><span class="keyword">c</span><span class="number">1</span>b<span class="number">7</span>f<span class="number">6957</span>ea<span class="number">2</span>b<span class="number">59</span>a<span class="number">461</span>dd</span></pre></td></tr><tr><td class="code"><pre><span class="line"># good: [<span class="number">97</span><span class="keyword">cc</span><span class="number">0e879</span>dc<span class="number">09796</span>bd<span class="number">56</span>cfd<span class="number">7</span><span class="keyword">c</span><span class="number">3</span>a<span class="number">54</span>deb<span class="number">41e447</span>f<span class="number">6</span>] C<span class="number">6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">git bisect good <span class="number">97</span><span class="keyword">cc</span><span class="number">0e879</span>dc<span class="number">09796</span>bd<span class="number">56</span>cfd<span class="number">7</span><span class="keyword">c</span><span class="number">3</span>a<span class="number">54</span>deb<span class="number">41e447</span>f<span class="number">6</span></span></pre></td></tr></table></figure>

<p>将标记错误的内容去掉。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"># bad: [<span class="number">4</span>d<span class="number">5e75</span><span class="keyword">c</span><span class="number">7</span>a<span class="number">9e6</span>e<span class="number">65</span>a<span class="number">168</span>d<span class="number">6</span>a<span class="number">2663e95</span>b<span class="number">19</span>da<span class="number">1e2</span>b<span class="number">21</span>] C<span class="number">9</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"># good: [<span class="keyword">c</span><span class="number">2</span>fa<span class="number">7</span>ca<span class="number">426</span>cac<span class="number">9990</span>ba<span class="number">27466520677</span>bf<span class="number">1780</span>af<span class="number">97</span>] <span class="keyword">add</span> a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">git bisect start 'HEAD' '<span class="keyword">c</span><span class="number">2</span>fa<span class="number">7</span>ca<span class="number">426</span>cac<span class="number">9990</span>ba<span class="number">27466520677</span>bf<span class="number">1780</span>af<span class="number">97</span>'</span></pre></td></tr><tr><td class="code"><pre><span class="line"># good: [ee<span class="number">27077</span>fdfc<span class="number">6</span><span class="keyword">c</span><span class="number">0</span><span class="keyword">c</span><span class="number">9281</span><span class="keyword">c</span><span class="number">1</span>b<span class="number">7</span>f<span class="number">6957</span>ea<span class="number">2</span>b<span class="number">59</span>a<span class="number">461</span>dd] C<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">git bisect good ee<span class="number">27077</span>fdfc<span class="number">6</span><span class="keyword">c</span><span class="number">0</span><span class="keyword">c</span><span class="number">9281</span><span class="keyword">c</span><span class="number">1</span>b<span class="number">7</span>f<span class="number">6957</span>ea<span class="number">2</span>b<span class="number">59</span>a<span class="number">461</span>dd</span></pre></td></tr></table></figure>

<p>然后运行<code>git bisect replay log.txt</code>命令。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">bisect </span>replay log.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">Previous</span> HEAD position was ad95ae3... <span class="built_in">C8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Switched </span>to <span class="keyword">branch </span><span class="string">'master'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Bisecting: </span><span class="number">4</span> <span class="keyword">revisions </span>left to test after this (roughly <span class="number">2</span> steps)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[ee27077fdfc6c0c9281c1b7f6957ea2b59a461dd] <span class="built_in">C4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Bisecting: </span><span class="number">2</span> <span class="keyword">revisions </span>left to test after this (roughly <span class="number">1</span> step)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">97</span>cc0e879dc09796bd56cfd7c3a54deb41e447f6] <span class="built_in">C6</span></span></pre></td></tr></table></figure>

<p>git会根据log从头开始重新<code>bisect</code>，错误的标记就被擦除了。<br>然后就是重新做人啦。</p>
<h2 id="blame"><a href="#blame" class="headerlink" title="blame"></a>blame</h2><p>一个充分协作的项目，每个文件可能都被多个人改动过。当出现问题的时候，大家希望快速的知道，某个文件的某一行是谁最后改动的，以便厘清责任。<br><code>git blame</code>就是这样一个命令。<code>blame</code>翻译成中文是<code>归咎于</code>，这个命令就是用来甩锅的。<br><code>git blame</code>只能作用于单个文件。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git blame a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">705</span>d9622 (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">09</span>:<span class="number">04</span> +<span class="number">0800</span> <span class="number">1</span>) 第一行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">74</span>eff2ee (abby <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">44</span> +<span class="number">0800</span> <span class="number">2</span>) 第二行</span></pre></td></tr><tr><td class="code"><pre><span class="line">a65b29bd (bob <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">17</span>:<span class="number">02</span> +<span class="number">0800</span> <span class="number">3</span>) 第三行</span></pre></td></tr><tr><td class="code"><pre><span class="line">ee27077f (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">05</span> +<span class="number">0800</span> <span class="number">4</span>) 第四行</span></pre></td></tr><tr><td class="code"><pre><span class="line">a7e09bd3 (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">19</span> +<span class="number">0800</span> <span class="number">5</span>) 第五行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">97</span>cc0e87 (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">21</span>:<span class="number">55</span> +<span class="number">0800</span> <span class="number">6</span>) 第六行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">67029</span>a81 (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">22</span>:<span class="number">15</span> +<span class="number">0800</span> <span class="number">7</span>) 第七行</span></pre></td></tr><tr><td class="code"><pre><span class="line">ad95ae3f (zhangsan <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">23</span>:<span class="number">20</span> +<span class="number">0800</span> <span class="number">8</span>) 第八行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span>d5e75c7 (lisi <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">23</span>:<span class="number">37</span> +<span class="number">0800</span> <span class="number">9</span>) 第九行</span></pre></td></tr></table></figure>

<p>它会把每一行的修改者信息都列出来。<br>第一部分是commit哈希值，表示这一行的最近一次修改属于该次提交。<br>第二部分是作者以及修改时间。<br>第三部分是行的内容。<br>如果文件太长，我们可以截取部分行。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git blame -L <span class="number">1</span>,<span class="number">5</span> a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">705</span>d9622 (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">09</span>:<span class="number">04</span> +<span class="number">0800</span> <span class="number">1</span>) 第一行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">74</span>eff2ee (abby <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">44</span> +<span class="number">0800</span> <span class="number">2</span>) 第二行</span></pre></td></tr><tr><td class="code"><pre><span class="line">a65b29bd (bob <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">17</span>:<span class="number">02</span> +<span class="number">0800</span> <span class="number">3</span>) 第三行</span></pre></td></tr><tr><td class="code"><pre><span class="line">ee27077f (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">05</span> +<span class="number">0800</span> <span class="number">4</span>) 第四行</span></pre></td></tr><tr><td class="code"><pre><span class="line">a7e09bd3 (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">19</span> +<span class="number">0800</span> <span class="number">5</span>) 第五行</span></pre></td></tr></table></figure>

<p>或者这样写。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git blame -L <span class="number">1</span>,+<span class="number">4</span> a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">705</span>d9622 (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">09</span>:<span class="number">04</span> +<span class="number">0800</span> <span class="number">1</span>) 第一行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">74</span>eff2ee (abby <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">44</span> +<span class="number">0800</span> <span class="number">2</span>) 第二行</span></pre></td></tr><tr><td class="code"><pre><span class="line">a65b29bd (bob <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">17</span>:<span class="number">02</span> +<span class="number">0800</span> <span class="number">3</span>) 第三行</span></pre></td></tr><tr><td class="code"><pre><span class="line">ee27077f (veedrin <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">05</span> +<span class="number">0800</span> <span class="number">4</span>) 第四行</span></pre></td></tr></table></figure>

<p>但是结果不是你预期的那样是吧。<code>1,+4</code>的确切意思是从1开始，显示4行。<br>如果有人重名，可以显示邮箱来区分。添加参数<code>-e</code>或者<code>--show-email</code>即可。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git blame -e a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">705</span>d9622 (<span class="symbol">veedrin@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">09</span>:<span class="number">04</span> +<span class="number">0800</span> <span class="number">1</span>) 第一行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">74</span>eff2ee (<span class="symbol">abby@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">44</span> +<span class="number">0800</span> <span class="number">2</span>) 第二行</span></pre></td></tr><tr><td class="code"><pre><span class="line">a65b29bd (<span class="symbol">bob@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">17</span>:<span class="number">02</span> +<span class="number">0800</span> <span class="number">3</span>) 第三行</span></pre></td></tr><tr><td class="code"><pre><span class="line">ee27077f (<span class="symbol">veedrin@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">05</span> +<span class="number">0800</span> <span class="number">4</span>) 第四行</span></pre></td></tr><tr><td class="code"><pre><span class="line">a7e09bd3 (<span class="symbol">veedrin@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">19</span> +<span class="number">0800</span> <span class="number">5</span>) 第五行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">97</span>cc0e87 (<span class="symbol">veedrin@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">21</span>:<span class="number">55</span> +<span class="number">0800</span> <span class="number">6</span>) 第六行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">67029</span>a81 (<span class="symbol">veedrin@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">22</span>:<span class="number">15</span> +<span class="number">0800</span> <span class="number">7</span>) 第七行</span></pre></td></tr><tr><td class="code"><pre><span class="line">ad95ae3f (<span class="symbol">zhangsan@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">23</span>:<span class="number">20</span> +<span class="number">0800</span> <span class="number">8</span>) 第八行</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span>d5e75c7 (<span class="symbol">lisi@</span>qq.com <span class="number">2018</span><span class="number">-12</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">23</span>:<span class="number">37</span> +<span class="number">0800</span> <span class="number">9</span>) 第九行</span></pre></td></tr></table></figure>

<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/position.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/position.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（10）：view</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%8810%EF%BC%89%EF%BC%9Aview/</url>
    <content><![CDATA[<p>有四个git命令可以用来查看git仓库相关信息。</p>
<a id="more"></a>

<h2 id="status"><a href="#status" class="headerlink" title="status"></a>status</h2><p><code>git status</code>命令的作用是同时展示工作区和暂存区的diff、暂存区和当前版本的diff、以及没有被git追踪的文件。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   <span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes not staged <span class="keyword">for</span> commi<span class="variable">t:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will <span class="keyword">be</span> committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard <span class="keyword">changes</span> in working directory)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   <span class="keyword">b</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked <span class="keyword">file</span><span class="variable">s:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> include in what will <span class="keyword">be</span> committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">c</span>.md</span></pre></td></tr></table></figure>

<p>这个命令应该是最常用的git命令之一了，每次提交之前都要看一下。<br><code>git status -v</code>命令相当于<code>git status</code>命令和<code>git diff --staged</code>之和。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status -v</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked files:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">include</span> <span class="keyword">in</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">index</span> <span class="number">5646</span>a65.<span class="number">.4</span>c479de <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-1</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">-apple</span></pre></td></tr><tr><td class="code"><pre><span class="line">+banana</span></pre></td></tr></table></figure>

<p><code>git status -vv</code>命令相当于<code>git status</code>命令和<code>git diff</code>之和。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status -vv</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked files:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">include</span> <span class="keyword">in</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">to</span> be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git c/a.md i/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">index</span> <span class="number">5646</span>a65.<span class="number">.4</span>c479de <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- c/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ i/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-1</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">-apple</span></pre></td></tr><tr><td class="code"><pre><span class="line">+banana</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--------------------------------------------------</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git i/b.md w/b.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">index</span> e69de29.<span class="number">.637</span>a09b <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- i/b.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ w/b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-0</span>,<span class="number">0</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">+<span class="comment">## git is awesome</span></span></pre></td></tr></table></figure>

<p>还有一个<code>-s</code>参数，给出的结果很有意思。</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">$ git status -s</span></pre></td></tr><tr><td class="code"><pre><span class="line">M  a.<span class="built_in">md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> M b.<span class="built_in">md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">?? c.<span class="built_in">md</span></span></pre></td></tr></table></figure>

<p>注意看，前面的字母位置是不一样的。<br>第一个位置是该文件在暂存区的状态，第二个位置是该文件在工作区的状态。比如，以下信息显示<code>a.md</code>文件在暂存区有改动待提交，在工作区也有改动待暂存。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">MM</span> <span class="selector-tag">a</span><span class="selector-class">.md</span></span></pre></td></tr></table></figure>

<p>缩写的状态码主要有这么几种：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>M</td>
<td>文件内容有改动</td>
</tr>
<tr>
<td>A</td>
<td>文件被添加</td>
</tr>
<tr>
<td>D</td>
<td>文件被删除</td>
</tr>
<tr>
<td>R</td>
<td>文件被重命名</td>
</tr>
<tr>
<td>C</td>
<td>文件被复制</td>
</tr>
<tr>
<td>U</td>
<td>文件冲突未解决</td>
</tr>
<tr>
<td>?</td>
<td>文件未被git追踪</td>
</tr>
<tr>
<td>!</td>
<td>文件被git忽略</td>
</tr>
</tbody></table>
<blockquote>
<p><code>?</code>和<code>!</code>所代表的状态因为没有进入git版本系统，所以任何时候两个位置都是一样的。就像<code>??</code>或者<code>!!</code>这样。</p>
</blockquote>
<h2 id="show"><a href="#show" class="headerlink" title="show"></a>show</h2><p><code>git show</code>命令<code>show</code>的是什么呢？git对象。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git show</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">2</span>bd3c9d7de54cec10f0896db9af04c90a41a8160</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Fri Dec <span class="number">28</span> <span class="number">11</span>:<span class="number">23</span>:<span class="number">27</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    update</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/README.md b/README.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">index e8ab145.<span class="number">.75625</span>ce <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">--- a/README.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/README.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-5</span>,<span class="number">3</span> +<span class="number">5</span>,<span class="number">5</span> @@ one</span></pre></td></tr><tr><td class="code"><pre><span class="line"> two</span></pre></td></tr><tr><td class="code"><pre><span class="line"> three</span></pre></td></tr><tr><td class="code"><pre><span class="line">+</span></pre></td></tr><tr><td class="code"><pre><span class="line">+four</span></pre></td></tr></table></figure>

<p><code>git show</code>相当于<code>git show HEAD</code>，显示当前HEAD指向的commit对象的信息。<br>当然，你也可以查看某个git对象的信息，后面跟上git对象的校验和就行。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git show <span class="number">38728</span>d8</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree <span class="number">38728</span>d8</span></pre></td></tr><tr><td class="code"><pre><span class="line">README.md</span></pre></td></tr></table></figure>

<h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p><code>git diff</code>命令可以显示两个主体之间的差异。</p>
<h3 id="工作区与暂存区的差异"><a href="#工作区与暂存区的差异" class="headerlink" title="工作区与暂存区的差异"></a>工作区与暂存区的差异</h3><p>单纯的<code>git diff</code>命令显示工作区与暂存区之间的差异。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git diff</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index e69de29.<span class="number">.5646</span>a65 <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/<span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-0</span>,<span class="number">0</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">+<span class="comment">## git is awesome</span></span></pre></td></tr></table></figure>

<p>因为是两个主体之间的比较，git永远将两个主体分别命名为<code>a</code>和<code>b</code>。<br>也可以只查看某个文件的diff。当然这里依然是工作区与暂存区之间的差异。</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">$ git diff a.<span class="built_in">md</span></span></pre></td></tr></table></figure>

<h3 id="暂存区与当前commit的差异"><a href="#暂存区与当前commit的差异" class="headerlink" title="暂存区与当前commit的差异"></a>暂存区与当前commit的差异</h3><p><code>git diff --staged</code>命令显示暂存区与当前commit的差异。<br><code>git diff --cached</code>也可以达到相同的效果，它比较老，不如<code>--staged</code>语义化。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ git diff --staged</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/<span class="selector-tag">b</span><span class="selector-class">.md</span> b/<span class="selector-tag">b</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">index e69de29..<span class="number">4</span>c479de <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">--- a/<span class="selector-tag">b</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/<span class="selector-tag">b</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ -<span class="number">0</span>,<span class="number">0</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">+apple</span></pre></td></tr></table></figure>

<p>同样，显示某个文件暂存区与当前commit的差异。</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">$ git diff <span class="comment">--staged a.md</span></span></pre></td></tr></table></figure>

<h3 id="两个commit之间的差异"><a href="#两个commit之间的差异" class="headerlink" title="两个commit之间的差异"></a>两个commit之间的差异</h3><p>我们还可以用<code>git diff</code>查看两个commit之间的差异。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git diff C1 C2</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index e69de29.<span class="number">.5646</span>a65 <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/<span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-0</span>,<span class="number">0</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">+<span class="comment">## git is awesome</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/b.md b/b.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">new</span> <span class="built_in">file</span> mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">0000000.</span>.e69de29</span></pre></td></tr></table></figure>

<p>注意先后顺序很重要，假如我改一下顺序。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git diff C2 C1</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">5646</span>a65..e69de29 <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/<span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-1</span> +<span class="number">0</span>,<span class="number">0</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">-<span class="comment">## git is awesome</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/b.md b/b.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">deleted <span class="built_in">file</span> mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index e69de29.<span class="number">.0000000</span></span></pre></td></tr></table></figure>

<p>比较两个commit之间某个文件的差异。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git diff C1:<span class="keyword">a</span>.md C2:<span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index e69de29.<span class="number">.5646</span>a65 <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/<span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-0</span>,<span class="number">0</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">+<span class="comment">## git is awesome</span></span></pre></td></tr></table></figure>

<h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p><code>git log</code>命令显示提交历史。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git log</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">7e2514419</span>ec0f75d1557d3d8165a7e7969f08349</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">53</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">4</span>d346773212b208380f71885979f93da65f07ea6</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">41</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit cde34665b49033d7b8aed3a334c3e2db2200b4dd</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">54</span>:<span class="number">59</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    a.md</span></pre></td></tr></table></figure>

<p>如果要查看每个commit具体的改动，添加<code>-p</code>参数，它是<code>--patch</code>的缩写。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git log -p</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">7e2514419</span>ec0f75d1557d3d8165a7e7969f08349</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">53</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/c.md b/c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">new file mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">0000000.</span>.e69de29</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">4</span>d346773212b208380f71885979f93da65f07ea6</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">41</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/b.md b/b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">new file mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">0000000.</span>.e69de29</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit cde34665b49033d7b8aed3a334c3e2db2200b4dd</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">54</span>:<span class="number">59</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/a.md b/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">new file mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">0000000.</span>.e69de29</span></pre></td></tr></table></figure>

<p>你还可以控制显示最近几条。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git log -p <span class="number">-1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">7e2514419</span>ec0f75d1557d3d8165a7e7969f08349</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">53</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a/c.md b/c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">new file mode <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">index <span class="number">0000000.</span>.e69de29</span></pre></td></tr></table></figure>

<p><code>-p</code>有点过于冗余，只是想查看文件修改的统计信息的话，可以使用<code>--stat</code>参数。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git log --stat</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">7e2514419</span>ec0f75d1557d3d8165a7e7969f08349</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">53</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"> c.md | <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">4</span>d346773212b208380f71885979f93da65f07ea6</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">41</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"> b.md | <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit cde34665b49033d7b8aed3a334c3e2db2200b4dd</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">54</span>:<span class="number">59</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"> a.md | <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr></table></figure>

<p>还觉得冗余？只想看提交说明，有一个<code>--oneline</code>可以帮到你。</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">$ git log --oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span>ad50f6 (HEAD -&gt; master) 添加c.<span class="built_in">md</span>文件</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span>d34677 添加b.<span class="built_in">md</span>文件</span></pre></td></tr><tr><td class="code"><pre><span class="line">cde3466 添加a.<span class="built_in">md</span>文件</span></pre></td></tr></table></figure>

<p>想在命令行工具看git提交历史的树形图表，用<code>--graph</code>参数。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git log --graph</span></pre></td></tr><tr><td class="code"><pre><span class="line">* commit <span class="number">7e2514419</span>ec0f75d1557d3d8165a7e7969f08349 (HEAD -&gt; master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">| Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">| Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">53</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|     c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">* commit <span class="number">4</span>d346773212b208380f71885979f93da65f07ea6</span></pre></td></tr><tr><td class="code"><pre><span class="line">| Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">| Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">56</span>:<span class="number">41</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|     b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">* commit cde34665b49033d7b8aed3a334c3e2db2200b4dd</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Author: veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Date:   Sat Dec <span class="number">29</span> <span class="number">11</span>:<span class="number">54</span>:<span class="number">59</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      a.md</span></pre></td></tr></table></figure>

<p>我知道你们肯定又觉得冗余，<code>--graph</code>和<code>--oneline</code>食用更佳哟。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span> --graph --oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* 7e25144 (HEAD -&gt; master) c.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* 4d34677 b.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* cde3466 a.md</span></span></pre></td></tr></table></figure>

<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/view.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/view.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（9）：stash</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%889%EF%BC%89%EF%BC%9Astash/</url>
    <content><![CDATA[<p>你在一个分支上开展了一半的工作，突然有一件急事要你去处理。这时候你得切换到一个新的分支，可是手头上的工作你又不想立即提交。<br>这种场景就需要用到git的储藏功能。</p>
<a id="more"></a>

<h2 id="储藏"><a href="#储藏" class="headerlink" title="储藏"></a>储藏</h2><p>想要储藏手头的工作，只需运行<code>git stash</code>命令。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked files:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">include</span> <span class="keyword">in</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git stash</span></pre></td></tr><tr><td class="code"><pre><span class="line">Saved working <span class="keyword">directory</span> <span class="keyword">and</span> <span class="keyword">index</span> state WIP <span class="keyword">on</span> <span class="keyword">master</span>: <span class="number">974</span>a2f2 <span class="keyword">update</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">WIP是<span class="keyword">work</span> <span class="keyword">in</span> progress的缩写，指的是进行中的工作。$ git <span class="keyword">status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked files:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">include</span> <span class="keyword">in</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">nothing</span> added <span class="keyword">to</span> <span class="keyword">commit</span> but untracked files <span class="keyword">present</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">to</span> track)</span></pre></td></tr></table></figure>

<p>可以看到，除了未被git跟踪的文件之外，工作区和暂存区的内容都会被储藏起来。现在你可以切换到其他分支进行下一步工作了。</p>
<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>我们看一下储藏列表。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git stash list</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">stash@</span>&#123;<span class="number">0</span>&#125;: WIP on master: <span class="number">974</span>a2f2 apple</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">stash@</span>&#123;<span class="number">1</span>&#125;: WIP on master: c27b351 banana</span></pre></td></tr></table></figure>

<h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>等我们完成其他工作，肯定要回到这里，继续进行中断的任务。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git stash apply</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes not staged for <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   b.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked files:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">include</span> <span class="keyword">in</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span></pre></td></tr></table></figure>

<p>诶，等等。怎么<code>a.md</code>的变更也跑到工作区了？是的，<code>git stash</code>默认会将暂存区和工作区的储藏全部恢复到工作区。如果我就是想原样恢复呢？</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git stash apply --<span class="built_in">index</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   <span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes not staged <span class="keyword">for</span> commi<span class="variable">t:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will <span class="keyword">be</span> committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard <span class="keyword">changes</span> in working directory)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   <span class="keyword">b</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked <span class="keyword">file</span><span class="variable">s:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> include in what will <span class="keyword">be</span> committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">c</span>.md</span></pre></td></tr></table></figure>

<p>加一个参数<code>--index</code>就会让工作区的归工作区，让暂存区的归暂存区。<br>还有一点需要注意，恢复储藏的操作可以应用在任何分支，它也不关心即将恢复储藏的分支上，工作区和暂存区是否干净。如果有冲突，自行解决就是了。<br>我们浏览过储藏列表，说明<code>git stash apply</code>仅仅是恢复了最新的那一次储藏。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git stash apply <span class="symbol">stash@</span>&#123;<span class="number">1</span>&#125;</span></pre></td></tr></table></figure>

<p>指定储藏的名字，我们就可以恢复列表中的任意储藏了。<br>这个时候我们再看一下储藏列表。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git stash list</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">stash@</span>&#123;<span class="number">0</span>&#125;: WIP on master: <span class="number">974</span>a2f2 apple</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">stash@</span>&#123;<span class="number">1</span>&#125;: WIP on master: c27b351 banana</span></pre></td></tr></table></figure>

<p>诶，发现还是两条。我不是已经恢复了一条么？<br><code>apply</code>这个词很巧妙，它只是应用，它可不会清理。</p>
<h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><p>想要清理储藏列表，咱们得显式的运行<code>git stash drop</code>命令。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git stash drop <span class="symbol">stash@</span>&#123;<span class="number">1</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git stash list</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">stash@</span>&#123;<span class="number">0</span>&#125;: WIP on master: <span class="number">974</span>a2f2 apple</span></pre></td></tr></table></figure>

<p>现在就真的没有了。希望你没有喝酒🙃。<br>git还给我们提供了一个快捷操作，运行<code>git stash pop</code>命令，同时恢复储藏和清理储藏。</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">$ git stash <span class="keyword">pop</span></span></pre></td></tr></table></figure>

<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/stash.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/stash.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（8）：revert</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%888%EF%BC%89%EF%BC%9Arevert/</url>
    <content><![CDATA[<p>有时候我们想撤回一个commit，但是这个commit已经在公共的分支上。如果直接修改分支历史，可能会引起一些不必要的混乱。这个时候，<code>git revert</code>命令就派上用场了。<br><code>revert</code>翻译成中文是<code>还原</code>。我觉得称它为对冲更合理。对冲指的是同时进行两笔行情相关、方向相反、数量相当、盈亏相抵的交易，这么理解<code>git revert</code>命令一针见血。<br>因为它的作用就是生成一个新的、完全相反的commit。</p>
<a id="more"></a>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><code>git revert</code>后跟你想要对冲的commit即可。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git revert HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line">Revert <span class="string">"add c.md"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">This reverts commit <span class="number">8a23</span>dad059b60ba847a621b6058fb32fa531b20a.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Please enter the commit message for your changes. Lines starting</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># with '#' will be ignored, and an empty message aborts the commit.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># On branch master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Changes to be committed:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#	deleted:    c.md</span></span></pre></td></tr></table></figure>

<p>git会弹出默认或者自定义的编辑器要求你输入commit信息。然后一个新的commit就生成了。</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">[master a8c4205] Revert <span class="string">"add c.md"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file <span class="section">changed</span>, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> delete mode <span class="number">100644</span> c.md</span></pre></td></tr></table></figure>

<p>可以看到，原本我添加了一个文件<code>a.md</code>，<code>revert</code>操作就会执行删除命令。在工作目录看起来就像添加文件操作被撤销了一样，其实是被对冲了。<br>它不会改变commit历史，只会增加一个新的对冲commit。这是它最大的优点。</p>
<h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>反向操作也会有冲突？你逗我的吧。<br>如果你操作的是最新的commit，那当然不会有冲突了。<br>那要操作的是以前的commit呢？</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span>(HEAD -&gt; master)</span></pre></td></tr></table></figure>

<p>比如<code>a.md</code>在<code>C0</code>内容为空，<code>C1</code>修改文件内容为<code>apple</code>，<code>C2</code>修改文件内容为<code>banana</code>。这时候你想撤销<code>C1</code>的修改。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">revert</span> HEAD~</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">error</span>: could <span class="keyword">not</span> <span class="built_in">revert</span> <span class="number">483b537</span>... apple</span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: after resolving the conflicts, mark the corrected paths</span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: with 'git add &lt;paths&gt;' <span class="keyword">or</span> 'git rm &lt;paths&gt;'</span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: <span class="keyword">and</span> commit the result with 'git commit'</span></pre></td></tr></table></figure>

<p>我们看一下文件内容。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line">banana</span></pre></td></tr><tr><td class="code"><pre><span class="line">=======</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; parent of 483b537... apple</span></pre></td></tr></table></figure>

<p>手动解决冲突，执行<code>git add</code>命令然后执行<code>git revert --continue</code>命令完成对冲操作。<br>取消<code>revert</code>操作只需要执行<code>git revert --abort</code>即可。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/revert.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/revert.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（7）：reset</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%887%EF%BC%89%EF%BC%9Areset/</url>
    <content><![CDATA[<p><code>git checkout</code>命令可以在版本之间随意切换，它的本质是移动HEAD指针。<br>那git有没有办法移动分支指针呢？<br>当然有，这就是<code>git reset</code>命令。</p>
<a id="more"></a>

<h2 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h2><p><code>git reset</code>命令与<code>git checkout</code>命令的区别在于，它会把HEAD指针和分支指针一起移动，如果HEAD指针指向的是一个分支指针的话。<br>我们前面说过使用<code>git checkout</code>命令从有分支指向的commit切换到一个没有分支指向的commit上，这个时候的HEAD指针被称为<code>detached HEAD</code>。这是非常危险的。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span>(HEAD -&gt; master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout <span class="built_in">C1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span>(HEAD) -- <span class="built_in">C2</span>(master)</span></pre></td></tr></table></figure>

<p>但是<code>git reset</code>命令没有这个问题，因为它会把当前的分支指针也带过去。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span>(HEAD -&gt; master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git reset <span class="built_in">C1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span>(HEAD -&gt; master) -- <span class="built_in">C2</span></span></pre></td></tr></table></figure>

<p>这就是<code>重置</code>的含义所在。它可以重置分支。<br>看另一种情况。如果是从一个没有分支指向的commit切换到另一个没有分支指向的commit上，那它们就是两个韩国妹子，傻傻分不清楚了。<br>这是<code>git checkout</code>命令的效果。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span>(HEAD) -- <span class="built_in">C3</span>(master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout <span class="built_in">C1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span>(HEAD) -- <span class="built_in">C2</span> -- <span class="built_in">C3</span>(master)</span></pre></td></tr></table></figure>

<p>这是<code>git reset</code>命令的效果。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span>(HEAD) -- <span class="built_in">C3</span>(master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git reset <span class="built_in">C1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span>(HEAD) -- <span class="built_in">C2</span> -- <span class="built_in">C3</span>(master)</span></pre></td></tr></table></figure>

<h2 id="同时重置暂存区和工作区的改动"><a href="#同时重置暂存区和工作区的改动" class="headerlink" title="同时重置暂存区和工作区的改动"></a>同时重置暂存区和工作区的改动</h2><p>当你在 <code>git reset</code> 命令后面加 <code>--hard</code> 参数时，暂存区和工作区的内容都会重置为重置后的commit内容。也就是说暂存区和工作区的改动都会清空，相当于撤销暂存区和工作区的改动。<br>而且是没有确认操作的哟。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--hard HEAD^</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">HEAD</span> <span class="keyword">is</span> <span class="keyword">now</span> <span class="keyword">at</span> <span class="number">58</span>b0040 <span class="keyword">commit</span> <span class="keyword">for</span> <span class="keyword">nothing</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">nothing</span> <span class="keyword">to</span> <span class="keyword">commit</span>, working tree clean</span></pre></td></tr></table></figure>

<h2 id="仅重置暂存区的改动"><a href="#仅重置暂存区的改动" class="headerlink" title="仅重置暂存区的改动"></a>仅重置暂存区的改动</h2><p><code>git reset</code> 命令后面加 <code>--mixed</code> 参数，或者不加参数，因为<code>--mixed</code>参数是默认值，暂存区的内容会重置为重置后的commit内容，工作区的改动不会清空，相当于撤销暂存区的改动。<br>同样也是没有确认操作的哟。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="keyword">HEAD</span>^</span></pre></td></tr><tr><td class="code"><pre><span class="line">Unstaged changes <span class="keyword">after</span> <span class="keyword">reset</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">M	a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span></pre></td></tr></table></figure>

<p>打个趣，如果<code>git reset</code>命令什么都不加会怎样呢？<br>你可以脑补一下，<code>git reset</code>命令不加参数默认就是<code>--mixed</code>，不加操作对象默认就是<code>HEAD</code>，所以单纯的<code>git reset</code>命令相当于<code>git reset --mixed HEAD</code>命令。<br>那这又意味着什么呢？<br>这意味着从当前commit重置到当前commit，没有变化对吧？但是<code>--mixed</code>参数会撤销暂存区的改动对不对，这就是它的效果。</p>
<h2 id="同时保留暂存区和工作区的改动"><a href="#同时保留暂存区和工作区的改动" class="headerlink" title="同时保留暂存区和工作区的改动"></a>同时保留暂存区和工作区的改动</h2><p>如果 <code>git reset</code> 命令后面加 <code>--soft</code> 参数，钢铁直男的温柔，你懂的。仅仅是重置commit而已，暂存区和工作区的改动都会保留下来。<br>更温柔的是，重置前的commit内容与重置后的commit内容的diff也会放入暂存区。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git diff <span class="comment">--staged</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">index</span> <span class="number">4</span>a77268..fde8dcd <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-1</span>,<span class="number">2</span> +<span class="number">1</span>,<span class="number">3</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line"> apple</span></pre></td></tr><tr><td class="code"><pre><span class="line"> banana</span></pre></td></tr><tr><td class="code"><pre><span class="line">+cherry</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--soft HEAD^</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">to</span> be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git diff <span class="comment">--staged</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">index</span> <span class="number">4</span>a77268..fde8dcd <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-1</span> +<span class="number">1</span>,<span class="number">3</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line"> apple</span></pre></td></tr><tr><td class="code"><pre><span class="line">+banana</span></pre></td></tr><tr><td class="code"><pre><span class="line">+cherry</span></pre></td></tr></table></figure>

<p><code>banana</code>就是重置前的commit内容与重置后的commit内容的diff，可以看到，它已经在暂存区了。</p>
<h2 id="文件暂存区内容撤回工作区"><a href="#文件暂存区内容撤回工作区" class="headerlink" title="文件暂存区内容撤回工作区"></a>文件暂存区内容撤回工作区</h2><p><code>git reset</code>命令后面也可以跟文件名，它的作用是将暂存区的内容重置为工作区的内容，是<code>git add --</code>的反向操作。<br><code>git reset --</code>命令是<code>git reset HEAD --mixed --</code>的简写。在操作文件时，参数只有默认的<code>--mixed</code>一种。<br>它并不会撤销工作区原有的改动。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="comment">-- a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Unstaged changes <span class="keyword">after</span> <span class="keyword">reset</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">M	a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span></pre></td></tr></table></figure>

<p><code>git checkout</code>命令后面也可以跟文件名，它的作用是撤销工作区的改动，需要注意区分。</p>
<h2 id="文件若干commit版本撤回工作区"><a href="#文件若干commit版本撤回工作区" class="headerlink" title="文件若干commit版本撤回工作区"></a>文件若干commit版本撤回工作区</h2><p>如果<code>git reset</code>命令后跟一个commit校验和，它会把该commit与所有后代commit的diff重置到工作区。<br>意思就是将该文件重置回你指定的commit版本，但是在你指定的commit之后的改动我也给你留着，就放到工作区里吧。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git diff <span class="comment">--staged</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 空</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="keyword">HEAD</span>~<span class="number">4</span> <span class="comment">-- a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Unstaged changes <span class="keyword">after</span> <span class="keyword">reset</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">M	a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git diff <span class="comment">--staged</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">diff <span class="comment">--git a/a.md b/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">index</span> <span class="number">6</span>f195b4.<span class="number">.72943</span>a1 <span class="number">100644</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--- a/a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ <span class="number">-1</span>,<span class="number">5</span> +<span class="number">1</span> @@</span></pre></td></tr><tr><td class="code"><pre><span class="line"> aaa</span></pre></td></tr><tr><td class="code"><pre><span class="line">-bbb</span></pre></td></tr><tr><td class="code"><pre><span class="line">-ccc</span></pre></td></tr><tr><td class="code"><pre><span class="line">-ddd</span></pre></td></tr><tr><td class="code"><pre><span class="line">-eee</span></pre></td></tr></table></figure>

<p><code>git diff --staged</code>命令比较工作区和暂存区的内容。可以看到初始工作区和暂存区是一致的，重置文件到4个版本之前，发现工作区比暂存区多了很多改动，这些都是指定commit之后的提交被重置到工作区了。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/reset.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/reset.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（6）：rebase</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%886%EF%BC%89%EF%BC%9Arebase/</url>
    <content><![CDATA[<p><code>git merge</code>命令会生成一个新的合并commit。如果你有强迫症，不喜欢这个新的合并commit，git也有更加清爽的方案可以满足你，它就是<code>git rebase</code>命令。<br>git就是哆啦A梦的口袋。<br><code>rebase</code>翻译过来是<code>变基</code>。意思就是将所有要合并进来的commit在新的基础上重新提交一次。</p>
<a id="more"></a>

<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p><code>git rebase</code>会计算当前分支和目标分支的最近共同祖先，然后将最近共同祖先与当前分支之间的所有commit都变基到目标分支上，使得提交历史变成一条直线。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span> -- <span class="built_in">C3</span>(master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">C4</span> -- <span class="built_in">C5</span> -- <span class="built_in">C6</span>(HEAD -&gt; dev)</span></pre></td></tr></table></figure>

<p><code>merge</code>与<code>rebase</code>后跟的分支名是不一样的。合并是合并进来，变基是变基过去，你们感受一下。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git rebase master</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">First</span>, rewinding head to replay your work on top of <span class="keyword">it...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Applying: </span><span class="built_in">C4</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">Applying</span>: <span class="built_in">C5</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">Applying</span>: <span class="built_in">C6</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span> -- <span class="built_in">C3</span>(master) -- <span class="built_in">C4</span><span class="string">' -- C5'</span> -- <span class="built_in">C6</span><span class="string">'(HEAD -&gt; dev)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">       \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">        C4 -- C5 -- C6</span></span></pre></td></tr></table></figure>

<p>现在最近共同祖先与当前分支之间的所有commit都被复制到master分支之后，并且将HEAD指针与当前分支指针切换过去。这招移花接木玩的很溜啊，如果你置身其中根本分不出区别。<br>原来的commit还在吗？还在，如果你记得它的commit校验和，仍然可以切换过去，git会提示你当前处于<code>detached HEAD</code>状态下。只不过没有任何分支指针指向它们，它们已经被抛弃了，剩余的时光就是等待git垃圾回收命令清理它们。<br>好在，还有人记得它们，不是么？<br><code>git rebase</code>完并没有结束，因为我变基的目标分支是master，而当前分支是dev。我需要切换到master分支上，然后再合并一次。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git checkout <span class="literal">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git merge dev</span></pre></td></tr></table></figure>

<p>诶，说来说去，还是要合并啊？<br>别急，这种合并是<code>Fast forward</code>的，并不会生成一个新的合并commit。<br>如果我要变基的本体分支不是当前分支行不行？也是可以的。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git rebase <span class="keyword">master</span> <span class="title">dev</span></span></pre></td></tr></table></figure>

<p>你在任何一个分支上，这种写法都可以将dev分支变基到master分支上，变基完成当前分支会变成dev分支。</p>
<h2 id="裁剪commit变基"><a href="#裁剪commit变基" class="headerlink" title="裁剪commit变基"></a>裁剪commit变基</h2><p>变基有点像基因编辑，git有更精确的工具达到你想要的效果。</p>
<blockquote>
<p>有了精确的基因编辑技术，妈妈再也不用担心你长的<strong>丑</strong>啦。</p>
</blockquote>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span> -- <span class="built_in">C3</span>(master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">C4</span> -- <span class="built_in">C5</span> -- <span class="built_in">C6</span>(dev)</span></pre></td></tr><tr><td class="code"><pre><span class="line">         \</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="built_in">C7</span> -- <span class="built_in">C8</span>(HEAD -&gt; hotfix)</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git rebase --onto master dev hotfix</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">First</span>, rewinding head to replay your work on top of <span class="keyword">it...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Applying: </span><span class="built_in">C7</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">Applying</span>: <span class="built_in">C8</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span> -- <span class="built_in">C3</span>(master) -- <span class="built_in">C7</span><span class="string">' -- C8'</span>(HEAD -&gt; hotfix)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">C4</span> -- <span class="built_in">C5</span> -- <span class="built_in">C6</span>(dev)</span></pre></td></tr><tr><td class="code"><pre><span class="line">         \</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="built_in">C7</span> -- <span class="built_in">C8</span></span></pre></td></tr></table></figure>

<p><code>--onto</code>参数就是那把基因编辑的剪刀。<br>它会把<code>hotfix分支</code>到<code>hotfix分支与dev分支的最近共同祖先</code>之间的commit裁剪下来，复制到目标基础点上。注意，所谓的之间指的都是不包括<code>最近共同祖先commit</code>的范围，比如这里就不会复制<code>C4</code>commit。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ git rebase <span class="comment">--onto master dev</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">First, rewinding head <span class="keyword">to</span> replay your work <span class="keyword">on</span> top <span class="keyword">of</span> <span class="keyword">it</span>...</span></pre></td></tr><tr><td class="code"><pre><span class="line">Applying: C7.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Applying: C8.md</span></pre></td></tr></table></figure>

<p>如果<code>--onto</code>后面只写两个分支(或者commit)名，第三个分支(或者commit)默认就是HEAD指针指向的分支(或者commit)。</p>
<h2 id="变基冲突解决"><a href="#变基冲突解决" class="headerlink" title="变基冲突解决"></a>变基冲突解决</h2><p>变基也会存在冲突的情况，我们看看冲突怎么解决。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">C0 <span class="comment">-- C1 -- C2(HEAD -&gt; master)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        C3 <span class="comment">-- C4(dev)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git rebase master dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">First, rewinding head to replay your work on top of it...</span></pre></td></tr><tr><td class="code"><pre><span class="line">Applying: c.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Applying: a.md add banana</span></pre></td></tr><tr><td class="code"><pre><span class="line">Using index info to reconstruct a base tree...</span></pre></td></tr><tr><td class="code"><pre><span class="line">M	a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Falling back to patching base and 3-way merge...</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Auto</span>-merging a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">CONFLICT (<span class="keyword">content</span>): <span class="keyword">Merge</span> conflict <span class="keyword">in</span> a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">error</span>: <span class="keyword">Failed</span> <span class="keyword">to</span> <span class="keyword">merge</span> <span class="keyword">in</span> the changes.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">Patch</span> <span class="keyword">failed</span> <span class="keyword">at</span> <span class="number">0002</span> a.md dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">The copy <span class="keyword">of</span> the <span class="keyword">patch</span> that <span class="keyword">failed</span> <span class="keyword">is</span> <span class="keyword">found</span> <span class="keyword">in</span>: .git/rebase-<span class="keyword">apply</span>/<span class="keyword">patch</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Resolve <span class="keyword">all</span> conflicts manually, mark them <span class="keyword">as</span> resolved <span class="keyword">with</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">"git add/rm &lt;conflicted_files&gt;"</span>, <span class="keyword">then</span> run <span class="string">"git rebase --continue"</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">You can instead <span class="keyword">skip</span> this <span class="keyword">commit</span>: run <span class="string">"git rebase --skip"</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">To</span> <span class="keyword">abort</span> <span class="keyword">and</span> <span class="keyword">get</span> back <span class="keyword">to</span> the state <span class="keyword">before</span> <span class="string">"git rebase"</span>, run <span class="string">"git rebase --abort"</span>.</span></pre></td></tr></table></figure>

<p>C2和C4同时修改了<code>a.md</code>的某一行，引发冲突。git已经给我们提示了，大体上和<code>merge</code>的操作一致。<br>我们可以手动解决冲突，然后执行<code>git add</code>和<code>git rebase --continue</code>来完成变基。<br>如果你不想覆盖目标commit的内容，也可以跳过这个commit，执行<code>git rebase --skip</code>。但是注意，这会跳过有冲突的整个commit，而不仅仅是有冲突的部分。<br>后悔药也是有的，执行<code>git rebase --abort</code>，干脆就放弃变基了。</p>
<h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><p><code>git rebase --onto</code>命令可以裁剪分支以变基到另一个分支上。但它依然是挑选连续的一段commit，只是允许你指定头和尾罢了。<br>别急，<code>git cherry-pick</code>命令虽然是一个独立的git命令，它的效果却还是变基，而且是commit级别的变基。<br><code>git cherry-pick</code>命令可以挑选任意commit变基到目标commit上。你负责挑，它负责基。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>只需要在<code>git cherry-pick</code>命令后跟commit校验和，就可以将它应用到目标commit上。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span>(HEAD -&gt; master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">C3</span> -- <span class="built_in">C4</span> -- <span class="built_in">C5</span>(dev)</span></pre></td></tr><tr><td class="code"><pre><span class="line">               \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">C6</span> -- <span class="built_in">C7</span>(hotfix)</span></pre></td></tr></table></figure>

<p>将当前分支切换到master分支。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">git</span> <span class="string">cherry-pick</span> <span class="string">C6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[master</span> <span class="string">dc342e0]</span> <span class="string">c6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="attr">Date:</span> <span class="string">Mon</span> <span class="string">Dec</span> <span class="number">24</span> <span class="number">09</span><span class="string">:13:57</span> <span class="number">2018</span> <span class="string">+0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="string">file</span> <span class="string">changed,</span> <span class="number">0</span> <span class="string">insertions(+),</span> <span class="number">0</span> <span class="string">deletions(-)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="string">create</span> <span class="string">mode</span> <span class="number">100644</span> <span class="string">c6.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">C0</span> <span class="string">--</span> <span class="string">C1</span> <span class="string">--</span> <span class="string">C2</span> <span class="string">--</span> <span class="string">C6'(HEAD</span> <span class="string">-&gt;</span> <span class="string">master)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="string">\</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">C3</span> <span class="string">--</span> <span class="string">C4</span> <span class="string">--</span> <span class="string">C5(dev)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="string">\</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="string">C6</span> <span class="string">--</span> <span class="string">C7(hotfix)</span></span></pre></td></tr></table></figure>

<p><code>C6</code>commit就按原样重新提交到master分支上了。<code>cherry-pick</code>并不会修改原有的commit。<br>同时挑选多个commit也很方便，往后面叠加就行。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick C4 C7</span></pre></td></tr><tr><td class="code"><pre><span class="line">[master ab1e7c7] c4</span></pre></td></tr><tr><td class="code"><pre><span class="line"> Date: Mon Dec <span class="number">24</span> <span class="number">09</span>:<span class="number">12</span>:<span class="number">58</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode <span class="number">100644</span> c4.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">[master <span class="number">161</span>d993] c7</span></pre></td></tr><tr><td class="code"><pre><span class="line"> Date: Mon Dec <span class="number">24</span> <span class="number">09</span>:<span class="number">14</span>:<span class="number">12</span> <span class="number">2018</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode <span class="number">100644</span> c7.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">C0 -- C1 -- C2 -- C4<span class="string">' -- C7'</span>(HEAD -&gt; master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        C3 -- C4 -- C5(dev)</span></pre></td></tr><tr><td class="code"><pre><span class="line">               \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                C6 -- C7(hotfix)</span></pre></td></tr></table></figure>

<p>如果这多个commit正好是连续的呢？</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">git</span> <span class="string">cherry-pick</span> <span class="string">C3...C7</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[master</span> <span class="string">d16c42e]</span> <span class="string">c4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="attr">Date:</span> <span class="string">Mon</span> <span class="string">Dec</span> <span class="number">24</span> <span class="number">09</span><span class="string">:12:58</span> <span class="number">2018</span> <span class="string">+0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="string">file</span> <span class="string">changed,</span> <span class="number">0</span> <span class="string">insertions(+),</span> <span class="number">0</span> <span class="string">deletions(-)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="string">create</span> <span class="string">mode</span> <span class="number">100644</span> <span class="string">c4.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[master</span> <span class="string">d16c42e]</span> <span class="string">c6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="attr">Date:</span> <span class="string">Mon</span> <span class="string">Dec</span> <span class="number">24</span> <span class="number">09</span><span class="string">:13:57</span> <span class="number">2018</span> <span class="string">+0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="string">file</span> <span class="string">changed,</span> <span class="number">0</span> <span class="string">insertions(+),</span> <span class="number">0</span> <span class="string">deletions(-)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="string">create</span> <span class="string">mode</span> <span class="number">100644</span> <span class="string">c6.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">[master</span> <span class="string">a4d5976]</span> <span class="string">c7</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="attr">Date:</span> <span class="string">Mon</span> <span class="string">Dec</span> <span class="number">24</span> <span class="number">09</span><span class="string">:14:12</span> <span class="number">2018</span> <span class="string">+0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="string">file</span> <span class="string">changed,</span> <span class="number">0</span> <span class="string">insertions(+),</span> <span class="number">0</span> <span class="string">deletions(-)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="string">create</span> <span class="string">mode</span> <span class="number">100644</span> <span class="string">c7.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">C0</span> <span class="string">--</span> <span class="string">C1</span> <span class="string">--</span> <span class="string">C2</span> <span class="string">--</span> <span class="string">C4'</span> <span class="string">--</span> <span class="string">C6'</span> <span class="string">--</span> <span class="string">C7'(HEAD</span> <span class="string">-&gt;</span> <span class="string">master)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="string">\</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">C3</span> <span class="string">--</span> <span class="string">C4</span> <span class="string">--</span> <span class="string">C5(dev)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="string">\</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="string">C6</span> <span class="string">--</span> <span class="string">C7(hotfix)</span></span></pre></td></tr></table></figure>

<p>需要注意，git所谓的从某某开始，一般都是不包括某某的，这里也一样。<br>有没有发现操作连续commit的<code>git cherry-pick</code>和<code>git rebase</code>的功能已经非常接近了？所以呀，<code>git cherry-pick</code>也是变基，只不过一边变基一边喂樱桃给你吃。</p>
<h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>git各种命令解决冲突的方法都大同小异。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">C0 <span class="comment">-- C1(HEAD -&gt; master)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> \</span></pre></td></tr><tr><td class="code"><pre><span class="line">  C2(dev)</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git cherry-pick C2</span></pre></td></tr><tr><td class="code"><pre><span class="line">error: could <span class="keyword">not</span> apply <span class="number">051</span>c24c... banana</span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: <span class="keyword">after</span> resolving <span class="keyword">the</span> conflicts, mark <span class="keyword">the</span> corrected paths</span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: <span class="keyword">with</span> <span class="string">'git add &lt;paths&gt;'</span> <span class="keyword">or</span> <span class="string">'git rm &lt;paths&gt;'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: <span class="keyword">and</span> commit <span class="keyword">the</span> <span class="built_in">result</span> <span class="keyword">with</span> <span class="string">'git commit'</span></span></pre></td></tr></table></figure>

<p>手动解决冲突，执行<code>git add</code>命令然后执行<code>git cherry-pick --continue</code>命令。<br>如果被唬住了想还原，执行<code>git cherry-pick --abort</code>即可。</p>
<h2 id="变基还是合并"><a href="#变基还是合并" class="headerlink" title="变基还是合并"></a>变基还是合并</h2><p>这是一个哲学问题。<br>有一种观点认为，仓库的commit历史应该记录<code>实际发生过什么</code>。所以如果你将一个分支合并进另一个分支，commit历史中就应该有这一次合并的痕迹，因为它是实实在在发生过的。<br>另一种观点则认为，仓库的commit历史应该记录<code>项目过程中发生过什么</code>。合并不是项目开发本身带来的，它是一种额外的操作，会使commit历史变的冗长。<br>我是一个极简主义者，所以我支持首选变基。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/rebase.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/rebase.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（5）：merge</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%885%EF%BC%89%EF%BC%9Amerge/</url>
    <content><![CDATA[<p>可以方便的创建分支是git如此受欢迎的重要原因，利用<code>git checkout</code>也让开发者在分支之间穿梭自如。然而百川终入海，其他分支上完成的工作终究是要合并到主分支上去的。<br>所以我们来看看git中的合并操作。</p>
<a id="more"></a>

<p>首先说明，执行<code>git merge</code>命令之前需要一些准备工作。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">merge</span> dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">error: Your <span class="built_in">local</span> changes <span class="built_in">to</span> <span class="keyword">the</span> following <span class="built_in">files</span> would be overwritten <span class="keyword">by</span> <span class="built_in">merge</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Please commit your changes <span class="keyword">or</span> stash them <span class="keyword">before</span> you <span class="built_in">merge</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Aborting</span></pre></td></tr></table></figure>

<p>合并操作之前必须保证暂存区内没有待提交内容，否则git会阻止合并。这是因为合并之后，git会将合并后的版本覆盖暂存区。所以会有丢失工作成果的危险。<br>至于工作区有待添加到暂存区的内容，git倒不会阻止你。可能git觉得它不重要吧。<br>不过最好还是保持一个干净的工作区再执行合并操作。</p>
<h2 id="不同分支的合并"><a href="#不同分支的合并" class="headerlink" title="不同分支的合并"></a>不同分支的合并</h2><p>不同分支指的是要合并的两个commit在某个祖先commit之后开始分叉。</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">C0</span> -- <span class="variable">C1</span> -- <span class="function"><span class="title">C2</span>(<span class="variable">HEAD</span> -&gt; <span class="variable">master</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="title">C3</span>(<span class="variable">dev</span>)</span></span></pre></td></tr></table></figure>

<p><code>git merge</code>后跟合并客体，表示要将它合并进来。</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">merge</span> dev</span></pre></td></tr></table></figure>

<p>进行到这里，如果没有冲突，git会弹出默认或者自定义的编辑器，让你填写commit说明。当然它会给你填写一个默认的commit说明。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Merge</span> branch <span class="string">'dev'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Please enter a commit message to explain why this merge is necessary,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># especially if it merges an updated upstream into a topic branch.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Lines starting with '#' will be ignored, and an empty message aborts</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># the commit.</span></span></pre></td></tr></table></figure>

<p>为什么要你填写commit说明？因为这种情况的<code>git merge</code>实际上会创建一个新的commit对象，记录此次合并的信息，并将当前分支指针移动到它上面来。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">C0</span> -- <span class="built_in">C1</span> -- <span class="built_in">C2</span> -- <span class="built_in">C4</span>(HEAD -&gt; master)(merge commit)</span></pre></td></tr><tr><td class="code"><pre><span class="line">       \          /</span></pre></td></tr><tr><td class="code"><pre><span class="line">        \        /</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="built_in">C3</span>(dev)</span></pre></td></tr></table></figure>

<p>大家常说不同分支的<code>git merge</code>操作是一个三方合并，这里的三方指的是<code>合并主体commit</code>、<code>合并客体commit</code>以及<code>合并主客体的共同祖先commit</code>。<br>所谓的三方和并到底是什么意思呢？<br>git会提取出<code>合并主体commit</code>相对于<code>合并主客体的共同祖先commit</code>的diff与<code>合并客体commit</code>相对于<code>合并主客体的共同祖先commit</code>的diff，再去比较这两份diff有没有修改同一个地方，这里同一个地方的单位是文件的行。如果没有，那就将这两份diff合并生成一个新的commit，当前分支指针向右移。如果有那就要求开发者自行解决。<br>所以在三方合并中，<code>合并主客体的共同祖先commit</code>只是一个参照物。</p>
<h2 id="合并主体在合并客体的上游"><a href="#合并主体在合并客体的上游" class="headerlink" title="合并主体在合并客体的上游"></a>合并主体在合并客体的上游</h2><p>它指的是开发者当前在一个commit节点上，要将同一个分支上更新的commit节点合并进来。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">C0 -- C1 -- C2(<span class="name">HEAD</span> -&gt; master) -- C3(<span class="name">dev</span>)</span></pre></td></tr></table></figure>

<p>这时候会发生什么呢？<br>这相当于更新当前分支指针，所以只需要将当前分支指针向下游移动，让合并主体与合并客体指向同一个commit即可。这时并不会产生一个新的commit。<br>用三方合并的概念来理解，<code>合并主体commit</code>与<code>合并主客体的共同祖先commit</code>是同一个commit，<code>合并主体commit</code>相对于<code>合并主客体的共同祖先commit</code>的diff为空，<code>合并客体commit</code>相对于<code>合并主客体的共同祖先commit</code>的diff与空diff合并还是它自己，所以移动过去就行了，并不需要生成一个新的commit。</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">$ git merge dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Updating <span class="number">9242078.</span><span class="number">.631</span>ef3a</span></pre></td></tr><tr><td class="code"><pre><span class="line">Fast-forward</span></pre></td></tr><tr><td class="code"><pre><span class="line"> a.md | <span class="number">2</span> ++</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file <span class="section">changed</span>, <span class="number">2</span> insertions(+)</span></pre></td></tr><tr><td class="code"><pre><span class="line">C0 -- C1 -- C2 -- C3(HEAD -&gt; master, dev)</span></pre></td></tr></table></figure>

<p>这种操作在git中有一个专有名词，叫<code>Fast forward</code>。<br>比如说<code>git pull</code>的时候经常发生这种情况。通常因为远端有更新的commit我们才需要执行<code>git pull</code>命令，这时远端就是合并客体，本地就是合并主体，远端的分支指针在下游，也会触发<code>Fast forward</code>。</p>
<h2 id="合并主体在合并客体的下游"><a href="#合并主体在合并客体的下游" class="headerlink" title="合并主体在合并客体的下游"></a>合并主体在合并客体的下游</h2><p>如果合并主体在合并客体的下游，那合并主体本身就包含合并客体，合并操作并不会产生任何效果。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">C0 -- C1 -- <span class="constructor">C2(<span class="params">dev</span>)</span> -- <span class="constructor">C3(HEAD -&gt; <span class="params">master</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git merge dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Already up <span class="keyword">to</span> date.</span></pre></td></tr><tr><td class="code"><pre><span class="line">C0 -- C1 -- <span class="constructor">C2(<span class="params">dev</span>)</span> -- <span class="constructor">C3(HEAD -&gt; <span class="params">master</span>)</span></span></pre></td></tr></table></figure>

<p>依然用三方合并的概念来理解，这时<code>合并客体commit</code>与<code>合并主客体的共同祖先commit</code>是同一个commit，<code>合并客体commit</code>相对于<code>合并主客体的共同祖先commit</code>的diff为空，<code>合并主体commit</code>相对于<code>合并主客体的共同祖先commit</code>的diff与空diff合并还是它自己。但是这回它都不用移动，因为合并后的diff就是它自己原有的diff。<br>注意，这时候dev分支指针会不会动呢？<br>当然不会，<code>git merge</code>操作对合并客体是没有任何影响的。</p>
<h2 id="同时合并多个客体"><a href="#同时合并多个客体" class="headerlink" title="同时合并多个客体"></a>同时合并多个客体</h2><p>如果你在<code>git merge</code>后面跟不止一个分支，这意味着你想同时将它们合并进当前分支。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ git merge<span class="built_in"> aaa </span>bbb ccc</span></pre></td></tr><tr><td class="code"><pre><span class="line">Fast-forwarding <span class="keyword">to</span>: aaa</span></pre></td></tr><tr><td class="code"><pre><span class="line">Trying<span class="built_in"> simple </span>merge with bbb</span></pre></td></tr><tr><td class="code"><pre><span class="line">Trying<span class="built_in"> simple </span>merge with ccc</span></pre></td></tr><tr><td class="code"><pre><span class="line">Merge made by the <span class="string">'octopus'</span> strategy.</span></pre></td></tr><tr><td class="code"><pre><span class="line"> aaa.md | 0</span></pre></td></tr><tr><td class="code"><pre><span class="line"> bbb.md | 0</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ccc.md | 0</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 3 files changed, 0 insertions(+), 0 deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode 100644 aaa.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode 100644 bbb.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode 100644 ccc.md</span></pre></td></tr></table></figure>

<p>git合并有多种策略，上面使用的是<code>&#39;octopus&#39; strategy</code>章鱼策略，因为同时合并的多个分支最终都会指向新的commit，看起来像章鱼的触手。</p>
<h2 id="合并有冲突"><a href="#合并有冲突" class="headerlink" title="合并有冲突"></a>合并有冲突</h2><p><code>git merge</code>操作并不总是如此顺利的。因为有时候要合并的两个分支不是同一个人的，就会有很大的概率遇到两人同时修改文件某一行的情况。git不知道该用谁的版本，它认为两个分支遇到了冲突。<br>这时就需要开发者手动的解决冲突，才能让git继续合并。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git merge dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Auto-merging a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">CONFLICT</span> (content): Merge <span class="keyword">conflict</span> <span class="keyword">in</span> a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Automatic merge failed; fix conflicts <span class="keyword">and</span> <span class="keyword">then</span> <span class="keyword">commit</span> the result.</span></pre></td></tr></table></figure>

<p>我们来看一下有冲突的文件是什么样的。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line">apple</span></pre></td></tr><tr><td class="code"><pre><span class="line">=======</span></pre></td></tr><tr><td class="code"><pre><span class="line">banana</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</span></pre></td></tr></table></figure>

<p>运行<code>git status</code>命令。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">You have unmerged paths.</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (fix conflicts and run "git <span class="keyword">commit</span><span class="string">")</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">  (use "</span>git <span class="keyword">merge</span> <span class="comment">--abort" to abort the merge)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Unmerged paths:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> mark resolution)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">both</span> modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span></pre></td></tr></table></figure>

<p>解决完冲突之后，你需要再提交，告诉git可以完成合并了。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> -m "fix merge conflict"</span></pre></td></tr><tr><td class="code"><pre><span class="line">U	a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">error: Committing <span class="keyword">is</span> <span class="keyword">not</span> possible because you have unmerged files.</span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: Fix them up <span class="keyword">in</span> the <span class="keyword">work</span> tree, <span class="keyword">and</span> <span class="keyword">then</span> use <span class="string">'git add/rm &lt;file&gt;'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">hint: <span class="keyword">as</span> appropriate <span class="keyword">to</span> mark resolution <span class="keyword">and</span> make a <span class="keyword">commit</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">fatal: Exiting because <span class="keyword">of</span> an unresolved <span class="keyword">conflict</span>.</span></pre></td></tr></table></figure>

<p>诶，被拒绝了。是不是想起了自己的情场故事？<br>当我们解决冲突的时候，工作区已经有改动，所以需要先提交到暂存区。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span> a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> -m "fix merge conflict"</span></pre></td></tr><tr><td class="code"><pre><span class="line">[master <span class="number">9</span>b32d4d] fix merge <span class="keyword">conflict</span></span></pre></td></tr></table></figure>

<p>运行<code>git add</code>命令之后你也可以用<code>git merge --continue</code>来替代<code>git commit</code>命令。它会让后面的行为跟没有冲突时的行为表现的一样。<br>如果你遇到冲突以后不知道如何解决，因为你要去询问你的合作伙伴为什么这样改。这时你肯定想回到合并以前的状态。<br>这对git来说很容易。只需要运行<code>git merge --abort</code>命令即可。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git merge --<span class="keyword">abort</span></span></pre></td></tr></table></figure>

<p>该命令无法保证恢复工作区的修改，所以最好是在合并之前先让工作区保持干净。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/merge.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/merge.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（4）：checkout</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%884%EF%BC%89%EF%BC%9Acheckout/</url>
    <content><![CDATA[<p>在git中，暂存区里有若干备份，版本库里有若干版本。留着这些东西肯定是拿来用的对吧，怎么用呢？当我需要哪一份的时候我就切换到哪一份。<br><code>git checkout</code>命令就是用来干这个的，官方术语叫做<code>签出</code>。<br>怎么理解<code>checkout</code>这个词呢？<code>checkout</code>原本指的是消费结束服务员要与你核对一下账单，结完账之后你就可以走了。在git中核对指的是diff，比较两份版本的差异，如果发现没有冲突那就可以切换过来了。</p>
<a id="more"></a>

<h2 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h2><p>我们知道HEAD指针指向当前版本，而<code>git checkout</code>命令的作用是切换版本，它们肯定有所关联。<br>目前HEAD指针指向master分支。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ cat .git/HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">ref</span>: <span class="built_in">ref</span>s/heads/master</span></pre></td></tr></table></figure>

<p>如果我切换到另一个分支，会发生什么？</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git checkout dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched to branch <span class="string">'dev'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>cat .git/HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">ref:</span> refs/heads/dev</span></pre></td></tr></table></figure>

<p>果然，<code>git checkout</code>命令的原理就是改变了HEAD指针。而一旦HEAD指针改变，git就会取出HEAD指针指向的版本作为当前工作目录的版本。签出到一个没有分支引用的commit也是一样的。</p>
<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>在进入正题之前，我们要先聊聊git中的两个符号<code>~</code>和<code>^</code>。<br>如果我们要从一个分支切换到另一个分支，那还好说，足够语义化。但是如果我们要切换到某个commit，除了兢兢业业的找到它的SHA-1值，还有什么办法快速的引用到它呢？<br>比如说我们可以根据commit之间的谱系关系快速定位。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span> --graph --oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* 4e76510 (HEAD -&gt; master) c4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*   2ec8374 c3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|\</span></pre></td></tr><tr><td class="code"><pre><span class="line">| * <span class="number">7</span>c0a8e3 c2</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* | fb60f51 c1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|/</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* dc96a29 c0</span></span></pre></td></tr></table></figure>

<blockquote>
<p><code>~</code>的作用是在纵向上定位。它可以一直追溯到最早的祖先commit。如果commit历史有分叉，那它就选第一个，也就是主干上的那个。<br><code>^</code>的作用是在横向上定位。它无法向上追溯，但是如果commit历史有分叉，它能定位所有分叉中的任意一支。</p>
</blockquote>
<h3 id="HEAD不加任何符号、加-0-符号或者加-0符号时，定位的都是当前版本"><a href="#HEAD不加任何符号、加-0-符号或者加-0符号时，定位的都是当前版本" class="headerlink" title="HEAD不加任何符号、加~0 符号或者加^0符号时，定位的都是当前版本"></a>HEAD不加任何符号、加<code>~0</code> 符号或者加<code>^0</code>符号时，定位的都是当前版本</h3><p>这个不用说，定位当前commit。</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4e76510</span>fe8bb3c69de12068ab354ef37bba6da9d</span></pre></td></tr></table></figure>

<p>它表示定位第零代父commit，也就是当前commit。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD~<span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4e76510f</span>e8bb3c69de12068ab354ef37bba6da9d</span></pre></td></tr></table></figure>

<p>它表示定位当前commit的第零个父commit，也就是当前commit。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD^<span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4e76510f</span>e8bb3c69de12068ab354ef37bba6da9d</span></pre></td></tr></table></figure>

<h3 id="用-符号数量的堆砌或者-数量的写法定位第几代父commit"><a href="#用-符号数量的堆砌或者-数量的写法定位第几代父commit" class="headerlink" title="用~符号数量的堆砌或者~数量的写法定位第几代父commit"></a>用<code>~</code>符号数量的堆砌或者<code>~数量</code>的写法定位第几代父commit</h3><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD~~</span></pre></td></tr><tr><td class="code"><pre><span class="line">fb60f519a59e9ceeef039f7efd2a8439aa7efd4b</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD~<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">fb60f519a59e9ceeef039f7efd2a8439aa7efd4b</span></pre></td></tr></table></figure>

<h3 id="用-数量的写法定位第几个父commit"><a href="#用-数量的写法定位第几个父commit" class="headerlink" title="用^数量的写法定位第几个父commit"></a>用<code>^数量</code>的写法定位第几个父commit</h3><p>注意，<code>^</code>定位的是当前基础的父commit。</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD^</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span>ec837440051af433677f786e502d1f6cdeb0a4a</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD^<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span>ec837440051af433677f786e502d1f6cdeb0a4a</span></pre></td></tr></table></figure>

<p>因为当前commit只有一个父commit，所以定位第二个父commit会失败。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD^<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HEAD^<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">fata<span class="variable">l:</span> ambiguous <span class="keyword">argument</span> <span class="string">'HEAD^2'</span>: unknown revision <span class="built_in">or</span> path not in the working tree.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Use <span class="string">'--'</span> <span class="keyword">to</span> separate paths from revisions, like thi<span class="variable">s:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]'</span></span></pre></td></tr></table></figure>

<h3 id="用-数量-数量的写法或者-数量-数量的写法定位第几代父commit的第几个父commit"><a href="#用-数量-数量的写法或者-数量-数量的写法定位第几代父commit的第几个父commit" class="headerlink" title="用~数量^数量的写法或者^数量^数量的写法定位第几代父commit的第几个父commit"></a>用<code>~数量^数量</code>的写法或者<code>^数量^数量</code>的写法定位第几代父commit的第几个父commit</h3><p>当前commit的第一代父commit的第零个父commit，意思就是第一代父commit咯。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD~^<span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span>ec837440051af433677f786e502d1f6cdeb0a4a</span></pre></td></tr></table></figure>

<p>比如这里定位的是当前commit的第一代父commit的第一个父commit。再次注意，<code>^</code>定位的是当前基础的父commit。</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD~^<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">fb60f519a59e9ceeef039f7efd2a8439aa7efd4b</span></pre></td></tr></table></figure>

<p>这里定位的是当前commit的第一代父commit的第二个父commit。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD~^<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">7</span><span class="keyword">c</span><span class="number">0</span>a<span class="number">8e3</span>a<span class="number">325</span>ce<span class="number">1</span>b<span class="number">5</span>a<span class="number">1</span>cdeb<span class="number">8</span><span class="keyword">c</span><span class="number">89</span>bef<span class="number">1</span>ecf<span class="number">17</span><span class="keyword">c</span><span class="number">10</span><span class="keyword">c</span><span class="number">9</span></span></pre></td></tr></table></figure>

<p>同样，定位到一个不存在的commit会失败。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD~^<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HEAD~^<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">fata<span class="variable">l:</span> ambiguous <span class="keyword">argument</span> <span class="string">'HEAD~^3'</span>: unknown revision <span class="built_in">or</span> path not in the working tree.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Use <span class="string">'--'</span> <span class="keyword">to</span> separate paths from revisions, like thi<span class="variable">s:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]'</span></span></pre></td></tr></table></figure>

<p>和<code>~</code>不同，<code>^2</code>和<code>^^</code>的效果是不一样的。<code>^2</code>指的是第二个父commit，<code>^^</code>指的是第一个父commit的第一个父commit。</p>
<h2 id="切换到HEAD"><a href="#切换到HEAD" class="headerlink" title="切换到HEAD"></a>切换到HEAD</h2><p><code>git checkout</code>命令如果不带任何参数，默认会加上HEAD参数。而HEAD指针指向的就是当前commit。所以它并不会有任何签出动作。<br>前面没有提到的是，<code>git checkout</code>命令会有一个顺带效果：比较签出后的版本和暂存区之间的差异。<br>所以<code>git checkout</code>命令不带任何参数，意思就是比较当前commit和暂存区之间的差异。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ git checkout</span></pre></td></tr><tr><td class="code"><pre><span class="line">A	<span class="selector-tag">b</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line">A	<span class="selector-tag">b</span>.md</span></pre></td></tr></table></figure>

<h2 id="切换到commit"><a href="#切换到commit" class="headerlink" title="切换到commit"></a>切换到commit</h2><p>开发者用的最多的当然是切换分支。其实<code>checkout</code>后面不仅可以跟分支名，也可以跟commit的校验和，还可以用符号定位commit。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git checkout dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched to branch 'dev'</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout acb71fe</span></pre></td></tr><tr><td class="code"><pre><span class="line">Note: checking out 'acb71fe11f78d230b860692ea6648906153f3d27'.</span></pre></td></tr><tr><td class="code"><pre><span class="line">You are in 'detached HEAD' state. You can look around, make experimental</span></pre></td></tr><tr><td class="code"><pre><span class="line">changes and <span class="keyword">commit</span> them, <span class="keyword">and</span> you can discard <span class="keyword">any</span> commits you make <span class="keyword">in</span> this</span></pre></td></tr><tr><td class="code"><pre><span class="line">state <span class="keyword">without</span> impacting <span class="keyword">any</span> branches <span class="keyword">by</span> performing another checkout.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">If</span> you want <span class="keyword">to</span> <span class="keyword">create</span> a <span class="keyword">new</span> branch <span class="keyword">to</span> retain commits you <span class="keyword">create</span>, you may</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> so (<span class="keyword">now</span> <span class="keyword">or</span> later) <span class="keyword">by</span> <span class="keyword">using</span> -b <span class="keyword">with</span> the checkout command again. Example:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  git checkout -b &lt;<span class="keyword">new</span>-branch-<span class="keyword">name</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">HEAD</span> <span class="keyword">is</span> <span class="keyword">now</span> <span class="keyword">at</span> acb71fe... <span class="literal">null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout <span class="keyword">HEAD</span>~<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Note: checking <span class="keyword">out</span> <span class="string">'acb71fe11f78d230b860692ea6648906153f3d27'</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">You <span class="keyword">are</span> <span class="keyword">in</span> <span class="string">'detached HEAD'</span> state. You can look around, make experimental</span></pre></td></tr><tr><td class="code"><pre><span class="line">changes <span class="keyword">and</span> <span class="keyword">commit</span> them, <span class="keyword">and</span> you can discard <span class="keyword">any</span> commits you make <span class="keyword">in</span> this</span></pre></td></tr><tr><td class="code"><pre><span class="line">state <span class="keyword">without</span> impacting <span class="keyword">any</span> branches <span class="keyword">by</span> performing another checkout.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">If</span> you want <span class="keyword">to</span> <span class="keyword">create</span> a <span class="keyword">new</span> branch <span class="keyword">to</span> retain commits you <span class="keyword">create</span>, you may</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> so (<span class="keyword">now</span> <span class="keyword">or</span> later) <span class="keyword">by</span> <span class="keyword">using</span> -b <span class="keyword">with</span> the checkout command again. Example:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  git checkout -b &lt;<span class="keyword">new</span>-branch-<span class="keyword">name</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">HEAD</span> <span class="keyword">is</span> <span class="keyword">now</span> <span class="keyword">at</span> acb71fe... <span class="literal">null</span></span></pre></td></tr></table></figure>

<h2 id="创建分支并切换"><a href="#创建分支并切换" class="headerlink" title="创建分支并切换"></a>创建分支并切换</h2><p>有时候我们在创建分支时希望同时切换到创建后的分支，仅仅<code>git branch</code>是做不到的。这时<code>git checkout</code>命令可以提供一个快捷操作，创建分支和切换分支一步到位。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched <span class="built_in">to</span> <span class="keyword">a</span> <span class="built_in">new</span> branch <span class="string">'dev'</span></span></pre></td></tr></table></figure>

<h2 id="暂存区文件覆盖工作区文件"><a href="#暂存区文件覆盖工作区文件" class="headerlink" title="暂存区文件覆盖工作区文件"></a>暂存区文件覆盖工作区文件</h2><p><code>git checkout</code>不仅可以执行切换commit这种全量切换，它还能以文件为单位执行微观切换。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">No commits yet</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git rm --cached &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">new</span> <span class="keyword">file</span>:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout <span class="comment">-- a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">No</span> commits yet</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">to</span> be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git rm --cached &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">new</span> <span class="keyword">file</span>:   a.md</span></pre></td></tr></table></figure>

<p>因为暂存区覆盖了工作区，所以工作区的改动就被撤销了，现在只剩下暂存区的改动等待提交。其实相当于撤销文件在工作区的改动，只不过它的语义是覆盖。这个命令没有任何提示，直接撤销工作区改动，要谨慎使用。<br>我们看到git提示语中有一个<code>git checkout --</code>命令，这又是干嘛用的呢？<br>提醒一下，这个参数的写法不是<code>git checkout --</code>，而是<code>git checkout --</code>。<br>其实它和<code>git checkout</code>的效果是一样的。但是别急，我是说这两个命令<strong>想要</strong>达到的效果是一样的，但<strong>实际</strong>效果却有略微的差别。<br>独立的<code>--</code>参数在Linux命令行中指的是：视后面的参数为文件名。当后面跟的是文件名的时候，最好加上独立的<code>--</code>参数，以免有歧义。<br>也就是说，如果该项目正好有一个分支名为<code>a.md</code>(皮一下也不是不行对吧)，那加独立的<code>--</code>参数就不会操作分支，而是操作文件。<br>如果你觉得仅仅撤销一个文件在工作区的改动不过瘾，你不是针对谁，你是觉得工作区的改动都是垃圾。那么还有一个更危险的命令。</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">$ git checkout <span class="comment">-- .</span></span></pre></td></tr></table></figure>

<p><code>.</code>代表当前目录下的所有文件和子目录。这条命令会撤销所有工作区的改动。</p>
<h2 id="当前commit文件覆盖暂存区文件和工作区文件"><a href="#当前commit文件覆盖暂存区文件和工作区文件" class="headerlink" title="当前commit文件覆盖暂存区文件和工作区文件"></a>当前commit文件覆盖暂存区文件和工作区文件</h2><p>如果执行<code>git checkout --</code>的时候加上一个分支名或者commit的校验和，效果就是该文件的当前版本会同时覆盖暂存区和工作区。相当于同时撤销文件在暂存区和工作区的改动。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout <span class="keyword">HEAD</span> <span class="comment">-- a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">nothing</span> <span class="keyword">to</span> <span class="keyword">commit</span>, working tree clean</span></pre></td></tr></table></figure>

<p>最后再提醒一下，运行<code>git checkout</code>命令作用于文件时，即便覆盖内容与被覆盖内容有冲突，也会直接覆盖，所以这真的是闷声打雷式的git命令，一定要抽自己几个耳刮子方可放心食用。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/checkout.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/checkout.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（3）：branch</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%883%EF%BC%89%EF%BC%9Abranch/</url>
    <content><![CDATA[<p>分支是使得git如此灵活的强大武器，正是因为有巧妙的分支设计，众多的git工作流才成为可能。<br>现在我们已经知道commit对象其实就是git中的版本。那我们要在版本之间切换难道只能通过指定commit对象毫无意义的SHA-1值吗？<br>当然不是。<br>在git中，我们可以通过将一些指针指向commit对象来方便操作，这些指针便是分支。</p>
<a id="more"></a>

<blockquote>
<p>分支在git中是一个模棱两可的概念。<br>你可以认为它仅仅是一个指针，指向一个commit对象节点。<br>你也可以认为它是指针指向的commit对象节点追溯到某个交叉节点之间的commit历史。</p>
</blockquote>
<p>严格的来说，一种叫分支指针，一种叫分支历史。不过实际使用中，它们在名字上常常不作区分。<br>所以我们需要意会文字背后的意思，它究竟说的是分支指针还是分支历史。<br>大多数时候，它指的都是分支指针。</p>
<h2 id="master分支"><a href="#master分支" class="headerlink" title="master分支"></a>master分支</h2><p>刚刚初始化的git仓库，会发现<code>.git/refs/heads</code>目录下面是空的。这是因为目前版本库里还没有任何commit对象，而分支一定是指向commit对象的。<br>一旦版本库里有了第一个commit对象，git都会在<code>.git/refs/heads</code>目录下面自动生成一个<code>master</code>文件，它就是git的默认分支。不过它并不特殊，只是它充当的是一个默认角色而已。<br>刚刚初始化的git仓库会显示目前在master分支上，其实这个master分支是假的，<code>.git/refs/heads</code>目录下根本没有这个文件。只有等提交历史不为空时才有会真正的默认分支。<br>我们看一下<code>master</code>文件到底有什么。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ cat .git/refs/heads/<span class="literal">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">6</span>b5a94158cc141286ac98f30bb189b8a83d61347</span></pre></td></tr></table></figure>

<p>40个字符，明显是某个git对象的引用。再识别一下它的类型，发现是一个commit对象。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git cat-<span class="keyword">file</span> -t <span class="number">6</span>b5a941</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit</span></pre></td></tr></table></figure>

<p>就这么简单，所谓的分支(分支指针)就是一个指向某个commit对象的指针。</p>
<h2 id="HEAD指针"><a href="#HEAD指针" class="headerlink" title="HEAD指针"></a>HEAD指针</h2><p>形象的讲，HEAD就是景区地图上标注你当前在哪里的一个图标。<br>你当前在哪里，HEAD就在哪里。它一般指向某个分支，因为一般我们都会在某个分支之上。<br>因为HEAD是用来标注当前位置的，所以一旦HEAD的位置被改变，工作目录就会切换到HEAD指向的分支。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">log</span> <span class="comment">--oneline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">f53aaa7 (HEAD -&gt; master) <span class="keyword">commit</span> <span class="keyword">for</span> <span class="keyword">nothing</span></span></pre></td></tr></table></figure>

<p>但是也有例外，比如我直接签出到某个没有分支引用的commit。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> <span class="comment">--oneline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cb64064 (HEAD -&gt; master) commit <span class="keyword">for</span> nothing again</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">324</span>a3c0 commit <span class="keyword">for</span> nothing</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout <span class="number">324</span>a3c0</span></pre></td></tr><tr><td class="code"><pre><span class="line">Note: checking out <span class="string">'324a3c0'</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">You are <span class="keyword">in</span> <span class="string">'detached HEAD'</span> state. You can look around, make experimental</span></pre></td></tr><tr><td class="code"><pre><span class="line">changes <span class="keyword">and</span> commit them, <span class="keyword">and</span> you can discard <span class="keyword">any</span> commits you make <span class="keyword">in</span> this</span></pre></td></tr><tr><td class="code"><pre><span class="line">state <span class="keyword">without</span> impacting <span class="keyword">any</span> branches <span class="keyword">by</span> performing another checkout.</span></pre></td></tr><tr><td class="code"><pre><span class="line">If you want <span class="built_in">to</span> <span class="built_in">create</span> <span class="keyword">a</span> <span class="built_in">new</span> branch <span class="built_in">to</span> retain commits you <span class="built_in">create</span>, you may</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">do</span> so (now <span class="keyword">or</span> later) <span class="keyword">by</span> <span class="keyword">using</span> -b <span class="keyword">with</span> <span class="keyword">the</span> checkout <span class="keyword">command</span> <span class="title">again</span>. <span class="title">Example</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  git checkout -b &lt;<span class="built_in">new</span>-branch-name&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">HEAD is now <span class="keyword">at</span> <span class="number">324</span>a3c0... commit <span class="keyword">for</span> nothing</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> <span class="comment">--oneline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">324</span>a3c0 commit <span class="keyword">for</span> nothing</span></pre></td></tr></table></figure>

<p>这个时候的HEAD就叫做<code>detached HEAD</code>。<br>要知道，只有在初始提交和某个分支之间的commit才是有效的。当你的HEAD处于<code>detached HEAD</code>状态时，在它之上新建的commit没有被任何分支包裹。一旦你切换到别的分支，这个commit(可能)再也不会被引用到，最终会被垃圾回收机制删除。因此这是很危险的操作。</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="number">324</span><span class="variable">a3c0</span> -- <span class="function"><span class="title">cb64064</span>(<span class="variable">master</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   \</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">3899</span><span class="function"><span class="title">a24</span>(<span class="variable">HEAD</span>)</span></span></pre></td></tr></table></figure>

<p>如果不小心这么做了，要么在原地新建一个分支，要么将已有的分支强行移动过来。确保它不会被遗忘。</p>
<blockquote>
<p>死亡不是终结，遗忘才是。——寻梦环游记</p>
</blockquote>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>除了默认的<code>master</code>分支，我们可以随意创建新的分支。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>dev</span></pre></td></tr></table></figure>

<p>一个dev分支就创建好了。</p>
<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>或许有时我们也想要查看本地仓库有多少个分支，因为在git中新建分支实在是太容易了。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git branch</span></pre></td></tr><tr><td class="code"><pre><span class="line">  dev</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* master</span></span></pre></td></tr></table></figure>

<p>当前分支的前面会有一个<code>*</code>号标注。<br>同时查看本地分支和远端分支引用，添加<code>-a</code>参数。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git branch -a</span></pre></td></tr><tr><td class="code"><pre><span class="line">* <span class="literal">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  remotes/origin/HEAD -&gt; origin/<span class="literal">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  remotes/origin/<span class="literal">master</span></span></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>一般分支合并完之后就不再需要了，这时就要将它删除。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-d dev</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">Deleted</span> <span class="keyword">branch </span>dev (was <span class="number">657142</span>d).</span></pre></td></tr></table></figure>

<p>有时候我们会得到不一样的提示。</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">$ git branch -d dev</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">error: </span>The branch 'dev' is not fully merged.</span></pre></td></tr><tr><td class="code"><pre><span class="line">If you are sure you want to delete it, run 'git branch -D dev'.</span></pre></td></tr></table></figure>

<p>这是git的一种保护措施。<code>is not fully merged</code>是针对当前分支来说的，意思是你要删除的分支还有内容没有合并进<strong>当前分支</strong>，你确定要删除它吗？<br>大多数时候，当然是要的。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-D dev</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">Deleted</span> <span class="keyword">branch </span>dev (was <span class="number">657142</span>d).</span></pre></td></tr></table></figure>

<p><code>-D</code>是<code>--delete --force</code>的缩写，你也可以写成<code>-df</code>。<br>需要注意的是，删除分支仅仅是删除一个指针而已，并不会删除对应的commit对象。不过有可能删除分支以后，这一串commit对象就无法再被引用了，从而被垃圾回收机制删除。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/branch.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/branch.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（2）：commit</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%882%EF%BC%89%EF%BC%9Acommit/</url>
    <content><![CDATA[<p>git是一个版本管理系统。它的终极目的就是将项目特定时间的信息保留成一个版本，以便将来的回退和查阅。<br>我们已经介绍了暂存区，暂存区的下一步就是版本库，而促成这一步操作的是<code>git commit</code>命令。</p>
<a id="more"></a>

<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>暂存区有待提交内容的情况下，如果直接运行<code>git commit</code>命令，git会跳往默认编辑器要求你输入提交说明，你也可以自定义要跳往的编辑器。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Please enter the commit message for your changes. Lines starting</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># with '#' will be ignored, and an empty message aborts the commit.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># On branch master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Initial commit</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Changes to be committed:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#	new file:   a.md</span></span></pre></td></tr></table></figure>

<p>提交之后我们就看到这样的信息。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">[master (root-commit) <span class="number">99558b4</span>] commit <span class="keyword">for</span> nothing</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode <span class="number">100644</span> a.md</span></pre></td></tr></table></figure>

<p>如果我就是不写提交说明呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Aborting <span class="keyword">commit</span> due <span class="keyword">to</span> <span class="keyword">empty</span> <span class="keyword">commit</span> message.</span></pre></td></tr></table></figure>

<p>看到没有，提交信息在git中时必填的。<br>如果提交说明不多，可以加参数<code>-m</code>直接在命令后面填写提交说明。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git commit -m <span class="string">"commit for nothing"</span></span></pre></td></tr></table></figure>

<p>你甚至可以将加入暂存区和提交一并做了。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git commit -am <span class="string">"commit for nothing"</span></span></pre></td></tr></table></figure>

<p>但是要注意，和<code>git add -u</code>命令一样，未跟踪的文件是无法提交上去的。</p>
<h2 id="重写提交"><a href="#重写提交" class="headerlink" title="重写提交"></a>重写提交</h2><p><code>amend</code>翻译成中文是<code>修改</code>的意思。<code>git commit --amend</code>命令允许你修改最近的一次commit。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">log</span> <span class="comment">--oneline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">8274473</span> (HEAD -&gt; master) <span class="keyword">commit</span> <span class="keyword">for</span> <span class="keyword">nothing</span></span></pre></td></tr></table></figure>

<p>目前项目提交历史中只有一个commit。我突然想起来这次提交中有一个笔误，我把<code>高圆圆</code>写成了<code>高晓松</code>(真的是笔误)。但是呢，我又不想为了这个笔误增加一个commit，毕竟它仅仅是一个小小的笔误而已。最重要的是我想悄无声息的改正它，以免被别人笑话。<br>这时我就可以使用<code>git commit --amend</code>命令。<br>首先修改<code>高晓松</code>成<code>高圆圆</code>。<br>然后执行<code>git add a.md</code>命令。<br>最后重写提交。git会跳往默认或者自定义编辑器提示你修改commit说明。当然你也可以不改。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> <span class="comment">--amend</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">commit</span> <span class="keyword">for</span> <span class="keyword">nothing</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Please enter the commit message for your changes. Lines starting</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># with '#' will be ignored, and an empty message aborts the commit.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Date:      Thu Jan 3 09:33:56 2019 +0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># On branch master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Initial commit</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Changes to be committed:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#	new file:   a.md</span></span></pre></td></tr></table></figure>

<p>我们再来看提交历史。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">log</span> <span class="comment">--oneline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">8</span>a71ae1 (HEAD -&gt; master) <span class="keyword">commit</span> <span class="keyword">for</span> <span class="keyword">nothing</span></span></pre></td></tr></table></figure>

<p>提交历史中同样只有一个commit。但是注意哟，commit已经不是之前的那个commit了，它们的校验和是不一样的。这就是所谓的重写。</p>
<h2 id="tree对象和commit对象"><a href="#tree对象和commit对象" class="headerlink" title="tree对象和commit对象"></a>tree对象和commit对象</h2><p>commit操作涉及到两个git对象。<br>第一是tree对象。<br>它存储子目录和子文件的引用。如果只有blob对象，那版本库将是一团散沙。正因为有tree对象将它们的关系登记在册，才能构成一个有结构的版本库。<br>添加到暂存区操作并不会生成tree对象，这时项目的结构信息存储在<code>index</code>文件中，直到提交版本库操作，才会为每一个目录分别生成tree对象。<br>第二是commit对象。<br>它存储每个提交的信息，包括当前提交的根tree对象的引用，父commit对象的引用，作者和提交者，还有提交信息。所谓的版本，其实指的就是这个commit对象。<br>作者和提交者通常是一个人，但也存在不同人的情况。</p>
<h2 id="objects"><a href="#objects" class="headerlink" title="objects"></a>objects</h2><p>初始化一个git项目，新建一些文件和目录。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">src/</span></pre></td></tr><tr><td class="code"><pre><span class="line">src/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">lib</span>/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">lib</span>/<span class="title">b</span>.<span class="title">md</span></span></span></pre></td></tr></table></figure>

<p>首先运行<code>git add</code>命令。我们清楚，这会在<code>.git/objects</code>目录下生成一个blob对象，因为目前两个文件都是空文件，共享一个blob对象。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/info/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/pack/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391</span></span></pre></td></tr></table></figure>

<p>现在我们运行<code>git commit</code>命令，看看有什么变化。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/objects/info/</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/pack/</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/e6/<span class="number">9</span>de29bb2d1d6434b8b29ae775ad8c2e48c5391</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">93</span>/<span class="number">810</span>bbde0f994d41ef550324a2c1ad5f9278e19</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">52</span>/<span class="number">0</span>c9f9f61657ca1e65a288ea77d229a27a8171b</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">0</span>b/<span class="number">785f</span>a11cd93f95b1cab8b9cbab188edc7e04df</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">49</span>/<span class="number">11f</span>f67189d8d5cc2f94904fdd398fc16410d56</span></pre></td></tr></table></figure>

<p>有意思。刚刚只有一个blob对象，怎么突然蹦出来这么多git对象呢？想一想之前说的<code>commit操作涉及到两个git对象</code>这句话，有没有可能多出来的几个，分别是tree对象和commit对象？<br>我们使用git底层命令<code>git cat-file -t</code>查看这些对象的类型发现，其中有一个blob对象，三个tree对象，一个commit对象。<br>这是第一个tree对象。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git cat-<span class="keyword">file</span> -t <span class="number">93810</span>bb</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git cat-<span class="keyword">file</span> -p <span class="number">93810</span>bb</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">100644</span> blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391	b.md</span></pre></td></tr></table></figure>

<p>这是第二个tree对象。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git cat-<span class="keyword">file</span> -t <span class="number">520</span>c9f9</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git cat-<span class="keyword">file</span> -p <span class="number">520</span>c9f9</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">100644</span> blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391	a.md</span></pre></td></tr></table></figure>

<p>这是第三个tree对象。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">$ git cat-file -t <span class="number">0</span>b785fa</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git cat-file -p <span class="number">0</span>b785fa</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0</span>40000 tree <span class="number">93810</span>bbde0f994d41ef550324a2c1ad5f9278e19	<span class="class"><span class="keyword">lib</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0</span>40000 tree <span class="number">520</span>c9f9f61657ca1e65a288ea77d229a27a8171b	src</span></pre></td></tr></table></figure>

<p>可以看到，提交时每个目录都会生成对应的tree对象。<br>然后我们再来看commit对象。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git cat-file -t <span class="number">4911f</span>f6</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git cat-file -p <span class="number">4911f</span>f6</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree <span class="number">0</span>b785fa11cd93f95b1cab8b9cbab188edc7e04df</span></pre></td></tr><tr><td class="code"><pre><span class="line">parent c4731cfab38f036c04de93facf07cae496a124a2</span></pre></td></tr><tr><td class="code"><pre><span class="line">author veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt; <span class="number">1546395770</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">committer veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt; <span class="number">1546395770</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="keyword">for</span> nothing</span></pre></td></tr></table></figure>

<p>可以看到，commit会关联根目录的tree对象，因为关联它就可以关联到所有的项目结构信息，所谓擒贼先擒王嘛。它也要关联父commit，也就是它的上一个commit，这样才能组成版本历史。当然，如果是第一个commit那就没有父commit了。然后就是commit说明和一些参与者信息。<br>我们总结一下，<code>git add</code>命令会为加入暂存区的内容或文件生成blob对象，<code>git commit</code>命令会为加入版本库的内容或文件生成tree对象和commit对象。至此，四种git对象我们见识了三种。<br>为啥不在<code>git add</code>的时候就生成tree对象呢？<br>所谓暂存区，就是不一定会保存为版本的信息，只是一个准备的临时场所。git认为在<code>git add</code>的时候生成tree对象是不够高效的，完全可以等版本定型时再生成。而版本定型之前的结构信息存在<code>index</code>文件中就好了。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/commit.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/commit.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（1）：add</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%881%EF%BC%89%EF%BC%9Aadd/</url>
    <content><![CDATA[<p>git是一个数据库系统，git是一个内容寻址文件系统，git是一个版本管理系统。<br>没错，它都是。<br>不过我们不纠结于git是什么，我们单刀直入，介绍git命令。<br>要将未跟踪的文件和已跟踪文件的改动加入暂存区，我们可以使用<code>git add</code>命令。<br>不过很多人嫌<code>git add</code>命令不够语义化，毕竟这一步操作是加入暂存区呀。所以git又增加了另外一个命令<code>git stage</code>，它们的效果是一模一样的。</p>
<a id="more"></a>

<h2 id="git仓库、工作区和暂存区"><a href="#git仓库、工作区和暂存区" class="headerlink" title="git仓库、工作区和暂存区"></a>git仓库、工作区和暂存区</h2><p>进入主题之前，我们先要介绍一下git仓库、工作区和暂存区的概念。</p>
<h3 id="git仓库"><a href="#git仓库" class="headerlink" title="git仓库"></a>git仓库</h3><p>所谓的git仓库就是一个有<code>.git</code>目录的文件夹。它是和git有关的一切故事开始的地方。<br>可以使用<code>git init</code>命令初始化一个git仓库。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git init</span></pre></td></tr></table></figure>

<p>也可以使用<code>git clone</code>命令从服务器上克隆仓库到本地。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">git</span>@github.com:veedrin/horseshoe.git</span></pre></td></tr></table></figure>

<p>然后你的本地就有了一个和服务器上一模一样的git仓库。<br>这里要说明的是，<code>clone</code>操作并不是将整个仓库下载下来，而是只下载<code>.git</code>目录。因为关于git的一切秘密都在这个目录里面，只要有了它，git就能复原到仓库的任意版本。</p>
<h3 id="工作区-working-directory"><a href="#工作区-working-directory" class="headerlink" title="工作区(working directory)"></a>工作区(working directory)</h3><p>工作区，又叫工作目录，就是不包括<code>.git</code>目录的项目根目录。我们要在这个目录下进行手头的工作，它就是版本管理的素材库。你甚至可以称任何与工作有关的目录为工作区，只不过没有<code>.git</code>目录git是不认的。</p>
<h3 id="暂存区-stage或者index"><a href="#暂存区-stage或者index" class="headerlink" title="暂存区(stage或者index)"></a>暂存区(stage或者index)</h3><p><code>stage</code>在英文中除了有<code>舞台、阶段</code>之意外，还有作为动词的<code>准备、筹划</code>之意，所谓的暂存区就是一个为提交到版本库做准备的地方。<br>那它为什么又被称作<code>index</code>呢？因为暂存区在物理上仅仅是<code>.git</code>目录下的<code>index</code>二进制文件。它就是一个索引文件，将工作区中的文件和暂存区中的备份一一对应起来。<br><code>stage</code>是表意的，<code>index</code>是表形的。<br>你可以把暂存区理解为一个猪猪储钱罐。我们还是孩子的时候，手里有一毛钱就会丢进储钱罐里。等到储钱罐摇晃的声音变的浑厚时，或者我们有一个心愿急需用钱时，我们就砸开储钱罐，一次性花完。<br>类比到软件开发，每当我们写完一个小模块，就可以将它放入暂存区。等到一个完整的功能开发完，我们就可以从暂存区一次性提交到版本库里。<br>这样做的好处是明显的：</p>
<ul>
<li>它可以实现更小颗粒度的撤销。</li>
<li>它可以实现批量提交到版本库。</li>
</ul>
<p>另外，添加到暂存区其实包含两种操作。一种是将还未被git跟踪过的文件放入暂存区；一种是已经被git跟踪的文件，将有改动的内容放入暂存区。</p>
<h2 id="放入暂存区"><a href="#放入暂存区" class="headerlink" title="放入暂存区"></a>放入暂存区</h2><p>git默认是不会把工作区的文件放入暂存区的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">No commits yet</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked files:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">include</span> <span class="keyword">in</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">nothing</span> added <span class="keyword">to</span> <span class="keyword">commit</span> but untracked files <span class="keyword">present</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">to</span> track)</span></pre></td></tr></table></figure>

<p>我们看到文件现在被标注为<code>Untracked files</code>。表示git目前还无法追踪它们的变化，也就是说它们还不在暂存区里。<br>那么我们如何手动将文件或文件夹放入暂存区呢？</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> .</span></span></pre></td></tr></table></figure>

<p>上面的命令表示将工作目录所有未放入暂存区的文件都放入暂存区。这时文件的状态已经变成了<code>Changes to be committed</code>，表示文件已经放入暂存区，等待下一步提交。每一次add操作其实就是为加入的文件或内容生成一份备份。<br>下面的命令也能达到相同的效果。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> -A</span></span></pre></td></tr></table></figure>

<p>假如我只想暂存单个文件呢？后跟相对于当前目录的文件名即可。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> README.md</span></span></pre></td></tr></table></figure>

<p>暂存整个文件夹也是一样的道理。因为git会递归暂存文件夹下的所有文件。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> src</span></span></pre></td></tr></table></figure>

<p>把从来没有被标记过的文件放入暂存区的命令是<code>git add</code>，暂存区中的文件有改动也需要使用<code>git add</code>命令将改动放入暂存区。<br>这时状态变成了<code>Changes not staged for commit</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes not staged for <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span></pre></td></tr></table></figure>

<p>针对已经加入暂存区的文件，要将文件改动加入暂存区，还有一个命令。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> -u</span></span></pre></td></tr></table></figure>

<p>它和<code>git add -A</code>命令的区别在于，它只能将已加入暂存区文件的改动放入暂存区，而<code>git add -A</code>通吃两种情况。</p>
<h2 id="跟踪内容"><a href="#跟踪内容" class="headerlink" title="跟踪内容"></a>跟踪内容</h2><p>假设我们已经将文件加入暂存区，现在我们往文件中添加内容，再次放入暂存区，然后查看状态。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">No commits yet</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git rm --cached &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">new</span> <span class="keyword">file</span>:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr></table></figure>

<p>哎，突然变的有意思了。为什么一个文件会同时存在两种状态，它是薛定谔的猫么？<br>想象一下，我想在一个文件中先修复一个bug然后增加一个feather，我肯定希望分两次放入暂存区，这样可以实现颗粒度更细的撤销和提交。但是如果git是基于文件做版本管理的，它就无法做到。<br>所以git只能是基于内容做版本管理，而不是基于文件。版本管理的最小单位叫做hunk，所谓的hunk就是一段连续的改动。一个文件同时有两种状态也就不稀奇了。</p>
<h2 id="objects"><a href="#objects" class="headerlink" title="objects"></a>objects</h2><p>git项目的<code>.git</code>目录下面有一个目录<code>objects</code>，一开始这个目录下面只有两个空目录：<code>info</code>和<code>pack</code>。<br>一旦我们执行了<code>git add</code>命令，<code>objects</code>目录下面就会多出一些东西。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="title">.git/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/e6/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391</span></span></pre></td></tr></table></figure>

<p>它多出了一个2个字符命名的目录和一个38个字符命名的文件。加起来正好是40个字符。增加一个2个字符的目录是为了提高检索效率。<br>SHA-1是一种哈希加密算法，它的特点是只要加密的内容相同，得到的校验和也相同。当然这种说法是不准确的，但是碰撞的概率极低。<br>git除了用内容来计算校验和之外，还加入了一些其他信息，目的也是为了进一步降低碰撞的概率。<br>重点是，SHA-1算法是根据内容来计算校验和的，跟前面讲的git跟踪内容相呼应。git被称为一个内容寻址文件系统不是没有道理的。<br>我们可以做个实验。初始化本地仓库两次，每次都新建一个markdown文件，里面写<code>## git is awesome</code>，记下完整的40个字符的校验和，看看它们是否一样。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">56</span>/<span class="number">46</span>a656f6331e1b30988472fefd48686a99e10f</span></pre></td></tr></table></figure>

<p>如果你真的做了实验，你会发现即便两个文件的文件名和文件格式都不一样，只要内容一样，它们的校验和就是一样的，并且就是上面列出的校验和。<br>现在大家应该对<code>git跟踪内容</code>这句话有更深的理解了。</p>
<h3 id="相同内容引用一个对象"><a href="#相同内容引用一个对象" class="headerlink" title="相同内容引用一个对象"></a>相同内容引用一个对象</h3><p>虽然开发者要极力避免这种情况，但是如果一个仓库有多个内容相同的文件，git会如何处理呢？<br>我们初始化一个本地仓库，新建两个不同名的文件，但文件内容都是<code>## git is awesome</code>。运行<code>git add .</code>命令之后看看神秘的<code>objects</code>目录下会发生什么？</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">56</span>/<span class="number">46</span>a656f6331e1b30988472fefd48686a99e10f</span></pre></td></tr></table></figure>

<p>只有一个目录，而且校验和跟之前一模一样。<br>其实大家肯定早就想到了，git这么优秀的工具，怎么可能会让浪费磁盘空间的事情发生呢？既然多个文件的内容相同，肯定只保存一个对象，让它们引用到这里来就好了。</p>
<h3 id="文件改动对应新对象"><a href="#文件改动对应新对象" class="headerlink" title="文件改动对应新对象"></a>文件改动对应新对象</h3><p>现在我们猜测工作区的文件和<code>objects</code>目录中的对象是一一对应起来的。但事实真的是这样吗？<br>我们初始化一个本地仓库，新建一个markdown文件，运行<code>git add .</code>命令。现在<code>objects</code>目录中已经有了一个对象。然后往文件中添加内容<code>## git is awesome</code>。再次运行<code>git add .</code>命令。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/objects/e6/<span class="number">9</span>de29bb2d1d6434b8b29ae775ad8c2e48c5391</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">56</span>/<span class="number">46</span>a656f6331e1b30988472fefd48686a99e10f</span></pre></td></tr></table></figure>

<p>哎，<code>objects</code>目录中出现了两个对象。第一个对象肯定对应空文件。第二个对象我们太熟悉了，对应的是添加内容后的文件。<br>再次强调，git是一个版本管理系统，文件在它这里不是主角，版本才是。刚才我们暂存了两次，可以认为暂存区现在已经有了两个版本(暂存区的版本实际上是内容备份，并不是真正的版本)。当然就需要两个对象来保存。</p>
<h3 id="文件改动全量保存"><a href="#文件改动全量保存" class="headerlink" title="文件改动全量保存"></a>文件改动全量保存</h3><p>初始化一个本地仓库，往工作区添加<code>lodash.js</code>未压缩版本，版本号是<code>4.17.11</code>，体积大约是<code>540KB</code>。运行<code>git add .</code>命令后<code>objects</code>目录下面出现一个对象，体积大约是<code>96KB</code>。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/objects/cb/<span class="number">139</span>dd81ebee6f6ed5f5a9198471f5cdc876d70</span></pre></td></tr></table></figure>

<p>我们对<code>lodash.js</code>文件内容作一个小小的改动，将版本号从<code>4.17.11</code>改为<code>4.17.10</code>，再次运行<code>git add .</code>命令。然后大家会惊奇的发现<code>objects</code>目录下有两个对象了。惊奇的不是这个，而是第二个对象的体积也是大约<code>96KB</code>。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/cb/139dd81ebee6f6ed5f5a9198471f5cdc876d70</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/bf/c087eec7e61f106df8f5149091b8790e6f3636</span></span></pre></td></tr></table></figure>

<p>明明只改了一个数字而已，第二个对象却还是这么大。<br>前面刚夸git会精打细算，怎么到这里就不知深浅了？这是因为多个文件内容相同的情况，引用到同一个对象并不会造成查询效率的降低，而暂存区的多个对象之间如果只保存增量的话，版本之间的查询和切换需要花费额外的时间，这样做是不划算的。<br>但是全量保存也不是个办法吧。然而git鱼和熊掌想兼得，它也做到了。后面会讲到。</p>
<h3 id="重命名会拆分成删除和新建两个动作"><a href="#重命名会拆分成删除和新建两个动作" class="headerlink" title="重命名会拆分成删除和新建两个动作"></a>重命名会拆分成删除和新建两个动作</h3><p>初始化一个本地仓库，新建一个文件，运行<code>git add .</code>命令。然后重命名该文件，查看状态信息。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">No commits yet</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git rm --cached &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">new</span> <span class="keyword">file</span>:   <span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes not staged <span class="keyword">for</span> commi<span class="variable">t:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git add/rm &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will <span class="keyword">be</span> committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard <span class="keyword">changes</span> in working directory)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  deleted:    <span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked <span class="keyword">file</span><span class="variable">s:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> include in what will <span class="keyword">be</span> committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">b</span>.md</span></pre></td></tr></table></figure>

<p>这是由于git的内部机制导致的。生成对象的时候，它发现仓库中叫这个名字的文件不见了，于是标记为已删除，又发现有一个新的文件名是之前没有标记过的，于是标记为未跟踪。因为它只是重命名而已，文件内容并没有改变，所以可以共享对象，并不会影响效率。</p>
<h2 id="blob对象"><a href="#blob对象" class="headerlink" title="blob对象"></a>blob对象</h2><p>git的一切秘密都在<code>.git</code>目录里。因为它拥有项目的完整信息，所以git一定是把备份存在了某个地方。git把它们存在了哪里，又是如何存储它们的呢？<br>这些备份信息，git统一称它们为对象。git总共有四种对象类型，都存在<code>.git/objects</code>目录下。<br>这一次我们只介绍blob对象。<br>它存储文件的内容和大小。当开发者把未跟踪的文件或跟踪文件的改动加入暂存区，就会生成若干blob对象。git会对blob对象进行<code>zlib</code>压缩，以减少空间占用。<br>因为它只存储内容和大小，所以两个文件即便文件名和格式完全不一样，只要内容相同，就可以共享一个blob对象。<br>注意blob对象和工作目录的文件并不是一一对应的，因为工作目录的文件几乎会被多次添加到暂存区，这时一个文件会对应多个blob对象。</p>
<h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><p>仓库的<code>.git</code>目录下面有一个文件，它就是大名鼎鼎的暂存区。<br>是的，暂存区并不是一块区域，只是一个文件，确切的说，是一个索引文件。<br>它保存了项目结构、文件名、时间戳以及blob对象的引用。<br>工作区的文件和blob对象之间就是通过这个索引文件关联起来的。</p>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>还记得我们在<code>文件改动全量保存</code>小节里讲到，git鱼和熊掌想兼得么？<br>又想全量保存，不降低检索和切换速度，又想尽可能压榨体积。git是怎么做到的呢？<br>git会定期或者在推送到远端之前对git对象进行打包处理。<br>打包的时候保存文件最新的全量版本，基于该文件的历史版本的改动则只保存diff信息。因为开发者很少会切换到较早的版本中，所以这时候效率就可以部分牺牲。<br>需要注意的是，所有的git对象都会被打包，而不仅仅是blob对象。<br>git也有一个<code>git gc</code>命令可以手动执行打包。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git gc</span></pre></td></tr><tr><td class="code"><pre><span class="line">Counting objects: <span class="number">11</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Delta compression using up to <span class="number">4</span> threads.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">9</span>/<span class="number">9</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">11</span>/<span class="number">11</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="number">11</span> (delta <span class="number">3</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span></pre></td></tr></table></figure>

<p>之前的git对象文件都不见了，<code>pack</code>文件夹多了两个文件。其中 <code>.pack</code> 后缀文件存储的就是打包前git对象文件的实际内容。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/info/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/info/packs</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/pack/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/pack/pack-99b4704a207ea3cc4924c9f0febb6ea45d4cdfd2.idx</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/pack/pack-99b4704a207ea3cc4924c9f0febb6ea45d4cdfd2.pack</span></span></pre></td></tr></table></figure>

<p>只能说，<code>git gc</code>的语义化不够好。它的功能不仅仅是垃圾回收，还有打包。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/add.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/add.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>动态代理（AOP）使用及实现原理分析</title>
    <url>/2019/12/26/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%88AOP%EF%BC%89%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="一、什么是代理？"><a href="#一、什么是代理？" class="headerlink" title="一、什么是代理？"></a>一、什么是代理？</h1><p>代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。</p>
<a id="more"></a>

<p>代理模式UML图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190830132920-220f2.png" alt="img"></p>
<p>简单结构示意图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190830132921-94ede.png" alt="img"></p>
<p>为了保持行为的一致性，代理类和委托类通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。通过代理类这中间一层，能有效控制对委托类对象的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。Java 动态代理机制以巧妙的方式近乎完美地实践了代理模式的设计理念。</p>
<h1 id="二、Java-动态代理类"><a href="#二、Java-动态代理类" class="headerlink" title="二、Java 动态代理类"></a>二、Java 动态代理类</h1><p>Java动态代理类位于java.lang.reflect包下，一般主要涉及到以下两个类：<br>(1)Interface InvocationHandler：该接口中仅定义了一个方法</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> object invoke(Object obj,<span class="function"><span class="keyword">Method</span> <span class="title">method</span>, <span class="title">Object</span>[] <span class="title">args</span>)</span></span></pre></td></tr></table></figure>

<p>在实际使用时，第一个参数obj一般是指代理类，method是被代理的方法，如上例中的request()，args为该方法的参数数组。这个抽象方法在代理类中动态实现。<br>(2)Proxy：该类即为动态代理类，其中主要包含以下内容：<br>protected Proxy(InvocationHandler h)：构造函数，用于给内部的h赋值。<br>static Class getProxyClass(<br>ClassLoader loader,<br>Class[] interfaces)：获得一个代理类，其中loader是类装载器，interfaces是真实类所拥有的全部接口的数组。<br>static Object newProxyInstance(ClassLoaderloader, Class[] interfaces,InvocationHandler h)：返回代理类的一个实例，返回后的代理类可以当作被代理类使用(可使用被代理类的在Subject接口中声明过的方法)<br>所谓DynamicProxy是这样一种class：它是在运行时生成的class，在生成它时你必须提供一组interface给它，然后该class就宣称它实现了这些interface。你当然可以把该class的实例当作这些interface中的任何一个来用。当然，这个DynamicProxy其实就是一个Proxy，它不会替你作实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工作。<br>在使用动态代理类时，我们必须实现InvocationHandler接口<br>通过这种方式，被代理的对象(RealSubject)可以在运行时动态改变，需要控制的接口(Subject接口)可以在运行时改变，控制的方式(DynamicSubject类)也可以动态改变，从而实现了非常灵活的动态代理关系。<br>动态代理步骤：</p>
<ol>
<li>创建一个实现接口InvocationHandler的类，它必须实现invoke方法</li>
<li>创建被代理的类以及接口</li>
<li>通过Proxy的静态方法</li>
</ol>
<p>newProxyInstance(ClassLoaderloader,Class[]interfaces,InvocationHandler h)创建一个代理</p>
<ol>
<li>通过代理调用方法</li>
</ol>
<h1 id="三、JDK的动态代理怎么使用？"><a href="#三、JDK的动态代理怎么使用？" class="headerlink" title="三、JDK的动态代理怎么使用？"></a>三、JDK的动态代理怎么使用？</h1><p>1、需要动态代理的接口：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jiankunking;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 需要动态代理的接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 你好</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * @param name</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * @return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> SayHello(<span class="keyword">String</span> name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 再见</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * @return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> SayGoodBye();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>2、需要代理的实际对象</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">package jiankunking;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>实际对象</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> */</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>你好</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param name</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public <span class="built_in">String</span> SayHello(<span class="built_in">String</span> name) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>再见</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public <span class="built_in">String</span> SayGoodBye() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">" good bye "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>3、调用处理器实现类（有木有感觉这里就是传说中的AOP啊）</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">package jiankunking;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>调用处理器实现类</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>每次生成动态代理类对象时都需要指定一个实现了该接口的调用处理器对象</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> */</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">InvocationHandlerImpl</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>这个就是我们要代理的真实对象</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    private <span class="built_in">Object</span> subject;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>构造方法，给我们要代理的真实对象赋初值</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param subject</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public InvocationHandlerImpl(<span class="built_in">Object</span> subject) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.subject = subject;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>该方法负责集中处理动态代理类上的所有方法调用。</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param proxy  代理类实例</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param method 被调用的方法对象</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param args   调用参数</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@throws Throwable</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public <span class="built_in">Object</span> invoke(<span class="built_in">Object</span> proxy, Method method, <span class="built_in">Object</span>[] args) throws Throwable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//在代理真实对象前我们可以添加一些自己的操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"在调用之前，我要干点啥呢？"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Method:"</span> + method);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">Object</span> returnValue = method.invoke(subject, args);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//在代理真实对象后我们也可以添加一些自己的操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"在调用之后，我要干点啥呢？"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> returnValue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>4、测试</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package jiankunking;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.lang.reflect.Proxy;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 动态代理演示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> DynamicProxyDemonstration &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//代理的真实对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Subject realSubject = <span class="keyword">new</span> <span class="constructor">RealSubject()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 即：要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        InvocationHandler handler = <span class="keyword">new</span> <span class="constructor">InvocationHandlerImpl(<span class="params">realSubject</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ClassLoader loader = handler.get<span class="constructor">Class()</span>.get<span class="constructor">ClassLoader()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Class&lt;?&gt;<span class="literal">[]</span> interfaces = realSubject.get<span class="constructor">Class()</span>.get<span class="constructor">Interfaces()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Subject subject = (Subject) <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(<span class="params">loader</span>, <span class="params">interfaces</span>, <span class="params">handler</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"动态代理对象的类型："</span> + subject.get<span class="constructor">Class()</span>.get<span class="constructor">Name()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String hello = subject.<span class="constructor">SayHello(<span class="string">"jiankunking"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(hello);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//        String goodbye = subject.SayGoodBye();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//        System.out.println(goodbye);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>5、输出结果如下：</p>
<p><img src="http://image.winrains.cn/2019/08/20190830132921-616a4.png" alt="img"></p>
<h1 id="四、动态代理怎么实现的？"><a href="#四、动态代理怎么实现的？" class="headerlink" title="四、动态代理怎么实现的？"></a>四、动态代理怎么实现的？</h1><p>从使用代码中可以看出，关键点在：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Subject subject = (Subject) <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(<span class="params">loader</span>, <span class="params">interfaces</span>, <span class="params">handler</span>)</span>;</span></pre></td></tr></table></figure>

<p>通过跟踪提示代码可以看出：当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用。<br>也就是说，当代码执行到：subject.SayHello(“jiankunking”)这句话时，会自动调用InvocationHandlerImpl的invoke方法。这是为啥呢？</p>
<blockquote>
<p>下面是代码跟分析的过程，不想看的朋友可以直接看结论</p>
</blockquote>
<p>以下代码来自:JDK1.8.0_92<br>既然生成代理对象是用的Proxy类的静态方newProxyInstance，那么我们就去它的源码里看一下它到底都做了些什么？</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Returns </span>an<span class="markdown"> instance of </span>a<span class="markdown"> proxy class for </span>the<span class="markdown"> specified interfaces</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>that dispatches method invocations to </span>the<span class="markdown"> specified invocation</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>handler.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> *</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>&#123;@code Proxy.newProxyInstance&#125; throws</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#123;@code IllegalArgumentException&#125; for </span>the<span class="markdown"> same reasons that</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#123;@code Proxy.getProxyClass&#125; does.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> *</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param   loader </span>the<span class="markdown"> class loader to define </span>the<span class="markdown"> proxy class</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param   interfaces </span>the<span class="markdown"> list of interfaces for </span>the<span class="markdown"> proxy class</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>to implement</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param   h </span>the<span class="markdown"> invocation handler to dispatch method invocations to</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@return  </span>a<span class="markdown"> proxy instance with </span>the<span class="markdown"> specified invocation handler of </span>a</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>proxy class that is defined by </span>the<span class="markdown"> specified class loader</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>and that implements </span>the<span class="markdown"> specified interfaces</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@throws  IllegalArgumentException if any of </span>the<span class="markdown"> restrictions on </span>the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>parameters that may be passed to &#123;@code getProxyClass&#125;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span></span>are<span class="markdown"> violated</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@throws  SecurityException if </span>a<span class="markdown"> security manager, <span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span></span>s<span class="xml"><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span>, is present</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>and any of </span>the<span class="markdown"> following conditions is met:</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span> </span>the<span class="markdown"> given &#123;@code loader&#125; is &#123;@code null&#125; and</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span></span>the<span class="markdown"> caller's class loader is not &#123;@code null&#125; and </span>the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>invocation of &#123;@link SecurityManager#checkPermission</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>s.checkPermission&#125; with</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>&#123;@code RuntimePermission("getClassLoader")&#125; permission</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>denies access;<span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span> for each proxy interface, &#123;@code intf&#125;,</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span></span>the<span class="markdown"> caller's class loader is not </span>the<span class="markdown"> same as or </span>an</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>ancestor of </span>the<span class="markdown"> class loader for &#123;@code intf&#125; and</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>invocation of &#123;@link SecurityManager#checkPackageAccess</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>s.checkPackageAccess()&#125; denies access to &#123;@code intf&#125;;<span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span> any of </span>the<span class="markdown"> given proxy interfaces is non-public and </span>the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>caller class is not in </span>the<span class="markdown"> same &#123;@linkplain Package runtime package&#125;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>as </span>the<span class="markdown"> non-public interface and </span>the<span class="markdown"> invocation of</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>&#123;@link SecurityManager#checkPermission s.checkPermission&#125; with</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>&#123;@code ReflectPermission("newProxyInPackage.&#123;package name&#125;")&#125;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>permission denies access.<span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@throws  NullPointerException if </span>the<span class="markdown"> &#123;@code interfaces&#125; array</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>argument or any of its elements </span>are<span class="markdown"> &#123;@code null&#125;, or</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>if </span>the<span class="markdown"> invocation handler, &#123;@code h&#125;, is</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>&#123;@code null&#125;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> */</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="built_in">Object</span> newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throws IllegalArgumentException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 检查h 不为空，否则抛异常</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Objects.requireNonNull(h);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 获得与指定类装载器和一组接口相关的代理类类型对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 通过反射获取构造函数对象并生成代理类实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 获取代理对象的构造方法（也就是$Proxy0(InvocationHandler h)）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                public Void run() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    cons.setAccessible(<span class="keyword">true</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 生成代理类的实例并把InvocationHandlerImpl的实例传给它的构造方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="built_in">Object</span>[] &#123; h &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Throwable t = e.getCause();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (t instanceof RuntimeException) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们再进去getProxyClass0方法看一下：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Generate a proxy class. Must call the checkProxyAccess method to perform</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * permission checks before calling this.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">Class</span>&lt;?&gt; getProxyClass0(ClassLoader loader, <span class="keyword">Class</span>&lt;?&gt;... interfaces) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// If the proxy class defined by the given loader implementing</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>真相还是没有来到，继续，看一下 proxyClassCache</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * a cache of proxy classes</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, <span class="keyword">Class</span>&lt;?&gt;[], <span class="keyword">Class</span>&lt;?&gt;&gt; proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span></pre></td></tr></table></figure>

<p>奥，原来用了一下缓存啊<br>那么它对应的get方法啥样呢？</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Look-up </span>the<span class="markdown"> value through </span>the<span class="markdown"> cache. This always evaluates </span>the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#123;@code subKeyFactory&#125; function and optionally evaluates</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#123;@code valueFactory&#125; function if there is no entry in </span>the<span class="markdown"> cache for given</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>pair of (key, subKey) or </span>the<span class="markdown"> entry has already been cleared.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> *</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param key</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *            </span>possibly null key</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param parameter</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *            </span>parameter used together with key to create sub-key and value</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *            </span>(</span>should<span class="markdown"> not be null)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@return </span>the<span class="markdown"> cached value (never null)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@throws NullPointerException</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *             </span>if &#123;@code parameter&#125; passed in or &#123;@code sub-key&#125; calculated</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *             </span>by &#123;@code subKeyFactory&#125; or &#123;@code value&#125; calculated by</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *             </span>&#123;@code valueFactory&#125; is null.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> */</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public V <span class="keyword">get</span>(K key, P parameter) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Objects.requireNonNull(parameter);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    expungeStaleEntries();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">Object</span> cacheKey = CacheKey.valueOf(key, refQueue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// lazily install the 2nd level valuesMap for the particular cacheKey</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ConcurrentMap&lt;<span class="built_in">Object</span>, Supplier&lt;V&gt;&gt; valuesMap = map.<span class="keyword">get</span>(cacheKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (valuesMap == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// putIfAbsent这个方法在key不存在的时候加入一个值,如果key存在就不放入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ConcurrentMap&lt;<span class="built_in">Object</span>, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                valuesMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (oldValuesMap != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            valuesMap = oldValuesMap;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// subKey from valuesMap</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">Object</span> subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.<span class="keyword">get</span>(subKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Factory <span class="keyword">factory</span> = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// supplier might be a Factory or a CacheValue&lt;V&gt; instance</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            V value = supplier.<span class="keyword">get</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// else no supplier in cache</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// or a supplier that returned null (could be a cleared CacheValue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// or a Factory that wasn't successful in installing the CacheValue)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// lazily construct a Factory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">factory</span> == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">factory</span> = <span class="keyword">new</span> Factory(key, parameter, subKey, valuesMap);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            supplier = valuesMap.putIfAbsent(subKey, <span class="keyword">factory</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// successfully installed Factory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                supplier = <span class="keyword">factory</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// else retry with winning supplier</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (valuesMap.replace(subKey, supplier, <span class="keyword">factory</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// successfully replaced</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// cleared CacheEntry / unsuccessful Factory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// with our Factory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                supplier = <span class="keyword">factory</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// retry with current supplier</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                supplier = valuesMap.<span class="keyword">get</span>(subKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们可以看到它调用了 supplier.get(); 获取动态代理类，其中supplier是Factory,这个类定义在WeakCach的内部。<br>来瞅瞅，get里面又做了什么？</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> synchronized V <span class="title">get</span>(<span class="params"></span>)</span> &#123; <span class="comment">// serialize access</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// re-check</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.<span class="keyword">get</span>(subKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (supplier != <span class="keyword">this</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// something changed while we were waiting:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// might be that we were replaced by a CacheValue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// or were removed because of failure -&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// return null to signal WeakCache.get() to retry</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// the loop</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// else still us (supplier == this)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// create new value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    V <span class="keyword">value</span> = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">value</span> = Objects.requireNonNull(valueFactory.apply(key, parameter));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="literal">null</span>) &#123; <span class="comment">// remove us on failure</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            valuesMap.<span class="keyword">remove</span>(subKey, <span class="keyword">this</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// the only path to reach here is with non-null value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    assert <span class="keyword">value</span> != <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// wrap value with CacheValue (WeakReference)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    CacheValue&lt;V&gt; cacheValue = <span class="keyword">new</span> CacheValue&lt;&gt;(<span class="keyword">value</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// try replacing us with CacheValue (this should always succeed)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (valuesMap.replace(subKey, <span class="keyword">this</span>, cacheValue)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// put also in reverseMap</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        reverseMap.put(cacheValue, Boolean.TRUE);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Should not reach here"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// successfully replaced us with new CacheValue -&gt; return the value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// wrapped by it</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">value</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>发现重点还是木有出现，但我们可以看到它调用了valueFactory.apply(key, parameter)方法：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * A factory function that generates, defines and returns the proxy class</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * given the ClassLoader and array of interfaces.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> ProxyClassFactory <span class="keyword">implements</span> BiFunction&lt;ClassLoader, <span class="keyword">Class</span>&lt;?&gt;[], <span class="keyword">Class</span>&lt;?&gt;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// prefix for all proxy class names</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// next number to use for generation of unique proxy class names</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">Class</span>&lt;?&gt; apply(ClassLoader loader, <span class="keyword">Class</span>&lt;?&gt;[] interfaces) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Map&lt;<span class="keyword">Class</span>&lt;?&gt;, <span class="keyword">Boolean</span>&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">Class</span>&lt;?&gt; intf : interfaces) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * Verify that the class loader resolves the name of this</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * interface to the same Class object.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">Class</span>&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                interfaceClass = <span class="keyword">Class</span>.forName(intf.getName(), <span class="keyword">false</span>, loader);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (interfaceClass != intf) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(intf + <span class="string">" is not visible from class loader"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * Verify that the Class object actually represents an</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * interface.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * Verify that this interface is not a duplicate.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (interfaceSet.put(interfaceClass, <span class="keyword">Boolean</span>.<span class="keyword">TRUE</span>) != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"repeated interface: "</span> + interfaceClass.getName());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String proxyPkg = <span class="keyword">null</span>; <span class="comment">// package to define proxy class in</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> accessFlags = Modifier.<span class="keyword">PUBLIC</span> | Modifier.<span class="keyword">FINAL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * Record the package of a non-public proxy interface so that the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * proxy class will be defined in the same package. Verify that all</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * non-public proxy interfaces are in the same package.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">Class</span>&lt;?&gt; intf : interfaces) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> flags = intf.getModifiers();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                accessFlags = Modifier.<span class="keyword">FINAL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                String name = intf.getName();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    proxyPkg = pkg;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"non-public interfaces from different packages"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * Choose a name for the proxy class to generate.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String proxyName = proxyPkg + proxyClassNamePrefix + num;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * Generate the specified proxy class.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> defineClass0(loader, proxyName, proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * A ClassFormatError here means that (barring bugs in the proxy</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * class generation code) there was some other invalid aspect of</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * the arguments supplied to the proxy class creation (such as</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * virtual machine limitations exceeded).</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过看代码终于找到了重点：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成字节码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">byte<span class="literal">[]</span> proxyClassFile = <span class="module-access"><span class="module"><span class="identifier">ProxyGenerator</span>.</span></span>generate<span class="constructor">ProxyClass(<span class="params">proxyName</span>, <span class="params">interfaces</span>, <span class="params">accessFlags</span>)</span>;</span></pre></td></tr></table></figure>

<p>那么接下来我们也使用测试一下，使用这个方法生成的字节码是个什么样子：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package jiankunking;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import sun.misc.ProxyGenerator;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.File;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.FileNotFoundException;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.FileOutputStream;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.IOException;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.lang.reflect.Proxy;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 动态代理演示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> DynamicProxyDemonstration &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//代理的真实对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Subject realSubject = <span class="keyword">new</span> <span class="constructor">RealSubject()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 即：要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        InvocationHandler handler = <span class="keyword">new</span> <span class="constructor">InvocationHandlerImpl(<span class="params">realSubject</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ClassLoader loader = handler.get<span class="constructor">Class()</span>.get<span class="constructor">ClassLoader()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Class<span class="literal">[]</span> interfaces = realSubject.get<span class="constructor">Class()</span>.get<span class="constructor">Interfaces()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Subject subject = (Subject) <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(<span class="params">loader</span>, <span class="params">interfaces</span>, <span class="params">handler</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"动态代理对象的类型："</span>+subject.get<span class="constructor">Class()</span>.get<span class="constructor">Name()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String hello = subject.<span class="constructor">SayHello(<span class="string">"jiankunking"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(hello);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 将生成的字节码保存到本地，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        create<span class="constructor">ProxyClassFile()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> static void create<span class="constructor">ProxyClassFile()</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String name = <span class="string">"ProxySubject"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        byte<span class="literal">[]</span> data = <span class="module-access"><span class="module"><span class="identifier">ProxyGenerator</span>.</span></span>generate<span class="constructor">ProxyClass(<span class="params">name</span>,<span class="params">new</span> Class[]&#123;Subject.<span class="params">class</span>&#125;)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        FileOutputStream out =null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            out = <span class="keyword">new</span> <span class="constructor">FileOutputStream(<span class="params">name</span>+<span class="string">".class"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println((<span class="keyword">new</span> <span class="constructor">File(<span class="string">"hello"</span>)</span>).get<span class="constructor">AbsolutePath()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            out.write(data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.print<span class="constructor">StackTrace()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; catch (IOException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.print<span class="constructor">StackTrace()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;finally &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(null!=out) <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                out.close<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; catch (IOException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                e.print<span class="constructor">StackTrace()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看一下这里代理对象的类型：</p>
<p><img src="http://image.winrains.cn/2019/08/20190830132922-3ea54.png" alt="img"></p>
<p>我们用jd-jui 工具将生成的字节码反编译：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jiankunking.Subject;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> final <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">Proxy</span></span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Subject</span></span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> ProxySubject(InvocationHandler paramInvocationHandler) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">super</span>(paramInvocationHandler);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> final boolean equals(Object paramObject) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> ((Boolean) <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="type">Object</span>[] &#123; paramObject &#125;)).booleanValue();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Error | RuntimeException localError) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> localError;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> final <span class="keyword">String</span> SayGoodBye() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> (<span class="keyword">String</span>) <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Error | RuntimeException localError) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> localError;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> final <span class="keyword">String</span> SayHello(<span class="keyword">String</span> paramString) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> (<span class="keyword">String</span>) <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m4, <span class="keyword">new</span> <span class="type">Object</span>[] &#123; paramString &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Error | RuntimeException localError) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> localError;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> final <span class="keyword">String</span> toString() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> (<span class="keyword">String</span>) <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m2, <span class="literal">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Error | RuntimeException localError) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> localError;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> final int hashCode() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> ((Integer) <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m0, <span class="literal">null</span>)).intValue();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Error | RuntimeException localError) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> localError;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">new</span> <span class="type">Class</span>[] &#123; Class.forName(<span class="string">"java.lang.Object"</span>) &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m3 = Class.forName(<span class="string">"jiankunking.Subject"</span>).getMethod(<span class="string">"SayGoodBye"</span>, <span class="keyword">new</span> <span class="type">Class</span>[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m4 = Class.forName(<span class="string">"jiankunking.Subject"</span>).getMethod(<span class="string">"SayHello"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">new</span> <span class="type">Class</span>[] &#123; Class.forName(<span class="string">"java.lang.String"</span>) &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> <span class="type">Class</span>[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> <span class="type">Class</span>[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException localNoSuchMethodException) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchMethodError</span>(localNoSuchMethodException.getMessage());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException localClassNotFoundException) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoClassDefFoundError</span>(localClassNotFoundException.getMessage());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这就是最终真正的代理类，它继承自Proxy并实现了我们定义的Subject接口，也就是说：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Subject subject = (Subject) <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(<span class="params">loader</span>, <span class="params">interfaces</span>, <span class="params">handler</span>)</span>;</span></pre></td></tr></table></figure>

<p>这里的subject实际是这个类的一个实例，那么我们调用它的：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">String</span> SayHello(<span class="keyword">String</span> paramString)</span></pre></td></tr></table></figure>

<p>就是调用我们定义的InvocationHandlerImpl的 invoke方法：</p>
<p><img src="http://image.winrains.cn/2019/08/20190830132923-38112.png" alt="img"></p>
<blockquote>
<p>上面是代码跟分析的过程，不想看的朋友可以直接看结论</p>
</blockquote>
<h1 id="五、结论"><a href="#五、结论" class="headerlink" title="五、结论"></a>五、结论</h1><p>到了这里，终于解答了：<br>subject.SayHello(“jiankunking”)这句话时，为什么会自动调用InvocationHandlerImpl的invoke方法？<br>因为JDK生成的最终真正的代理类，它继承自Proxy并实现了我们定义的Subject接口，在实现Subject接口方法的内部，通过反射调用了InvocationHandlerImpl的invoke方法。<br>通过分析代码可以看出Java 动态代理，具体有如下四步骤：</p>
<ol>
<li>通过实现 InvocationHandler 接口创建自己的调用处理器；</li>
<li>通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；</li>
<li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li>
<li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li>
</ol>
<p>演示代码下载： <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fjiankunking%2FDynamicProxyDemo">github.com/jiankunking…</a></p>
<blockquote>
<p>作者：衣舞晨风</p>
<p>来源：<a href="https://juejin.im/post/5d31c1b7f265da1b9421845d" target="_blank" rel="noopener">https://juejin.im/post/5d31c1b7f265da1b9421845d</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL探索（8）：InnoDB的事务</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%888%EF%BC%89%EF%BC%9AInnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>事务是数据库最为重要的机制之一，凡是使用过数据库的人，都了解数据库的事务机制，也对ACID四个基本特性如数家珍。但是聊起事务或者ACID的底层实现原理，往往言之不详，不明所以。所以，今天我们就一起来分析和探讨InnoDB的事务机制，希望能建立起对事务底层实现原理的具体了解。</p>
<a id="more"></a>

<p><img src="http://image.winrains.cn/2019/10/20191031175432-e26fb.jpeg" alt="img"></p>
<p>事务的四大特性</p>
<p>数据库事务具有ACID四大特性。ACID是以下4个词的缩写：</p>
<ul>
<li>原子性(atomicity) ：事务最小工作单元，要么全成功，要么全失败 。</li>
<li>一致性(consistency)： 事务开始和结束后，数据库的完整性不会被破坏 。</li>
<li>隔离性(isolation) ：不同事务之间互不影响，四种隔离级别为RU（读未提交）、RC（读已提交）、RR（可重复读）、SERIALIZABLE （串行化）。</li>
<li>持久性(durability) ：事务提交后，对数据的修改是永久性的，即使系统故障也不会丢失 。</li>
</ul>
<p>下面，我们就以一个具体实例来介绍数据库事务的原理，并介绍InnoDB是如何实现ACID四大特性的。</p>
<h2 id="示例介绍"><a href="#示例介绍" class="headerlink" title="示例介绍"></a>示例介绍</h2><p>我们首先来看一下具体的示例。大家可以自己亲自试验一下，这样理解和记忆都会更加深刻。<br>首先，使用如下的SQL语句创建两张表，分别是goods和trade，代表货物和交易。并向goods表中插入一条记录，id为1的货物数量为10。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> goods (<span class="keyword">id</span> <span class="built_in">INT</span>, <span class="keyword">num</span> <span class="built_in">INT</span>, PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> trade (<span class="keyword">id</span> <span class="built_in">INT</span>, goods_id <span class="built_in">INT</span>, user_id <span class="built_in">INT</span>, PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> goods <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">10</span>);</span></pre></td></tr></table></figure>

<p>然后打开终端，连接数据库，开启会话一，先用BEGIN显示开启一个事务。会话一先将goods表中id为1的货物的数量减一，然后向trade表中添加一笔交易的记录，最后使用COMMIT显示提交事务。<br>而会话二则先查询goods表中id为1的货物数量，然后向trade表中添加一笔交易记录，接着更新goods表中id为1的货物的数量，最后使用ROLLBACK进行事务的回滚。其中，两个会话中执行的具体语句和先后顺序如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175433-821a1.jpeg" alt="img"></p>
<p>示例具体语句和执行顺序</p>
<p>这个示例可以体现数据库事务的很多特性，我们一一来介绍。首先会话一的操作2更新了id为1的货物的数量，但是会话二的操作5读出来的数量仍然是10，这体现了事务的隔离性，使用InnoDB的<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483698&idx=1&sn=3654042755c7ea0922e5d5b462930946&chksm=fc04c552cb734c443f771eb2075cd4d4ce85df85105805667cc4cf51a67ceed2f9ebdf1a8cde&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">多版本控制机制</a>实现。<br>会话二的操作7也要更新同种货物的数量，此时因为会话一的操作2已经更新了该货物的数量，InnoDB已经锁住了该记录的行锁，所以操作7会被阻塞，直到会话一COMMIT。但是会话一的操作4和会话二的操作7都是向trade表中插入记录，后者却不会因为前者而阻塞，因为二者插入的不是同一行记录。锁机制是一种常见的并发控制机制，它和多版本控制机制一起实现了InnoDB事务的隔离性，关于InnoDB锁相关的具体内容可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483694&idx=1&sn=671ad369f67441c7d1572110066d5695&chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB锁的类型和状态查询</a>和<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483702&idx=1&sn=669fb9f413db0cc744bdb5b9ec8f725e&chksm=fc04c556cb734c40b3c90a55868619b8ca1f3e1f8763be2d6e7f0568d7c992409937c33b7e10&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB行锁算法</a>。</p>
<p>会话一事务最终使用COMMIT提交了事务而会话二事务则使用ROLLBACK回滚了整个事务，这体现了事务的原子性。即事务的一系列操作要么全部执行(COMMIT)，要么就全部不执行(ROLLBACK)，不存在只执行一部分的情况。InnoDB使用事务日志系统来实现事务的原子性。这里有的同学就会问了，如果中途连接断开或者Server Crash会怎么样。能怎么样，直接自动回滚呗。</p>
<p>一旦会话一使用COMMIT操作提交事务成功后，那么数据一定会被写入到数据库中并持久的存储起来，这体现了事务的持久性。InnoDB使用<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483683&idx=1&sn=5225ab3481c38bb57297a36df8e62bce&chksm=fc04c543cb734c556574f9e5331ab70f0c8239d70197f70015f58d4ac3f5c4d0b1260f0478e3&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">redo log机制</a>来实现事务的持久性。</p>
<p>而事务的一致性比较难以理解，简单的讲在事务开始时，此时数据库有一种状态，这个状态是所有的MySQL对象处于一致的状态，例如数据库完整性约束正确，日志状态一致等。当事务提交后，这时数据库又有了一个新的状态，不同的数据，不同的索引，不同的日志等。但此时，约束，数据，索引，日志等MySQL各种状态还是要保持一致性。 也就是说数据库从一个一致性的状态，变到另一个一致性的状态。事务执行后，并没有破坏数据库的完整性约束。</p>
<p>下面我们就来详细讲解一下上述示例涉及的事务的ACID特性的具体实现原理。<strong>总结来说，事务的隔离性由多版本控制机制和锁实现，而原子性、一致性和持久性通过InnoDB的redo log、undo log和Force Log at Commit机制来实现</strong>。</p>
<h2 id="原子性，持久性和一致性"><a href="#原子性，持久性和一致性" class="headerlink" title="原子性，持久性和一致性"></a>原子性，持久性和一致性</h2><p>原子性，持久性和一致性主要是通过redo log、undo log和Force Log at Commit机制机制来完成的。redo log用于在崩溃时恢复数据，undo log用于对事务的影响进行撤销，也可以用于多版本控制。而Force Log at Commit机制保证事务提交后redo log日志都已经持久化。<br>开启一个事务后，用户可以使用COMMIT来提交，也可以用ROLLBACK来回滚。其中COMMIT或者ROLLBACK执行成功之后，数据一定是会被全部保存或者全部回滚到最初状态的，这也体现了事务的原子性。但是也会有很多的异常情况，比如说事务执行中途连接断开，或者是执行COMMIT或者ROLLBACK时发生错误，Server Crash等，此时数据库会自动进行回滚或者重启之后进行恢复。</p>
<p>我们先来看一下redo log的原理，redo log顾名思义，就是重做日志，每次数据库的SQL操作导致的数据变化它都会记录一下，<strong>具体来说，redo log是物理日志，记录的是数据库页的物理修改操作</strong>。如果数据发生了丢失，数据库可以根据redo log进行数据恢复。</p>
<p>InnoDB通过Force Log at Commit机制实现事务的持久性，即当事务COMMIT时，必须先将该事务的所有日志都写入到redo log文件进行持久化之后，COMMIT操作才算完成。<br>当事务的各种SQL操作执行时，即会在缓冲区中修改数据，也会将对应的redo log写入它所属的缓存。当事务执行COMMIT时，与该事务相关的redo log缓冲必须都全部刷新到磁盘中之后COMMIT才算执行成功。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175433-e6413.png" alt="img"></p>
<p>数据库日志和数据落盘机制</p>
<p>redo log写入磁盘时，必须进行一次操作系统的fsync操作，防止redo log只是写入了操作系统的磁盘缓存中。参数innodb_flush_log_at_trx_commit可以控制redo log日志刷新到磁盘的策略，它的具体作用可以查阅<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483683&idx=1&sn=5225ab3481c38bb57297a36df8e62bce&chksm=fc04c543cb734c556574f9e5331ab70f0c8239d70197f70015f58d4ac3f5c4d0b1260f0478e3&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB的磁盘文件及落盘机制</a></p>
<p>redo log全部写入磁盘后事务就算COMMIT成功了，但是此时事务修改的数据还在内存的缓冲区中，称其为脏页，这些数据会依据检查点(CheckPoint)机制择时刷新到磁盘中，然后删除相应的redo log，但是如果在这个过程中数据库Crash了，那么数据库重启时，会依据redo log file将那些还在内存中未更新到磁盘上的数据进行恢复。</p>
<p>数据库为了提高性能，数据页在内存修改后并不是每次都会刷到磁盘上。而是引入checkpoint机制，择时将数据页落盘，checkpoint记录之前的数据页保证一定落盘了，这样相关的redo log就没有用了(由于InnoDB redo log file循环使用，这时这部分日志就可以被覆盖)，checkpoint之后的数据页有可能落盘，也有可能没有落盘，所以checkpoint之后的redo log file在崩溃恢复的时候还是需要被使用的。InnoDB会依据脏页的刷新情况，定期推进checkpoint，从而减少数据库崩溃恢复的时间。检查点的信息在第一个日志文件的头部。</p>
<p>数据库崩溃重启后需要从redo log中把未落盘的脏页数据恢复出来，重新写入磁盘，保证用户的数据不丢失。当然，在崩溃恢复中还需要回滚没有提交的事务。由于回滚操作需要undo日志的支持，undo日志的完整性和可靠性需要redo日志来保证，所以崩溃恢复先做redo恢复数据，然后做undo回滚。</p>
<p>在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175434-53e31.jpeg" alt="img"></p>
<p>数据和回滚日志的逻辑存储结构.jpg</p>
<p>undo log的存储不同于redo log，它存放在数据库内部的一个特殊的段(segment)中，这个段称为回滚段。回滚段位于共享表空间中。undo段中的以undo page为更小的组织单位。undo page和存储数据库数据和索引的页类似。因为redo log是物理日志，记录的是数据库页的物理修改操作。所以undo log的写入也会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。如上图所示，表空间中有回滚段和叶节点段和非叶节点段，而三者都有对应的页结构。</p>
<p>我们再来总结一下数据库事务的整个流程，如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175434-1e1c3.jpeg" alt="img"></p>
<p>事务的相关流程</p>
<p>事务进行过程中，每次sql语句执行，都会记录undo log和redo log，然后更新数据形成脏页，然后redo log按照时间或者空间等条件进行落盘，undo log和脏页按照checkpoint进行落盘，落盘后相应的redo log就可以删除了。此时，事务还未COMMIT，如果发生崩溃，则首先检查checkpoint记录，使用相应的redo log进行数据和undo log的恢复，然后查看undo log的状态发现事务尚未提交，然后就使用undo log进行事务回滚。事务执行COMMIT操作时，会将本事务相关的所有redo log都进行落盘，只有所有redo log落盘成功，才算COMMIT成功。然后内存中的数据脏页继续按照checkpoint进行落盘。如果此时发生了崩溃，则只使用redo log恢复数据。</p>
<h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>InnoDB事务的隔离性主要通过多版本控制机制和锁机制实现，具体可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483698&idx=1&sn=3654042755c7ea0922e5d5b462930946&chksm=fc04c552cb734c443f771eb2075cd4d4ce85df85105805667cc4cf51a67ceed2f9ebdf1a8cde&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">多版本控制</a>，<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483694&idx=1&sn=671ad369f67441c7d1572110066d5695&chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB锁的类型和状态查询</a>和<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483702&idx=1&sn=669fb9f413db0cc744bdb5b9ec8f725e&chksm=fc04c556cb734c40b3c90a55868619b8ca1f3e1f8763be2d6e7f0568d7c992409937c33b7e10&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB行锁算法</a>三篇文章。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本来想一篇文章将MySQL的事务机制讲明白，写完自己读了一遍，还是发现内容有些晦涩难懂，复杂的知识本来就是很难讲明白的，夫夷以近，则游者众；险以远，则至者少，希望读者以本文作为一篇指引性的文章，自己再去更加深入的地方去探秘。不过，能将复杂知识讲解的通俗简单也是一项很大的本领，文字和讲解能力还是需要提示的。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/42d4385c32bb" target="_blank" rel="noopener">https://www.jianshu.com/p/42d4385c32bb</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（7）：InnoDB行锁算法</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%887%EF%BC%89%EF%BC%9AInnoDB%E8%A1%8C%E9%94%81%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>在上一篇<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483698&idx=1&sn=3654042755c7ea0922e5d5b462930946&chksm=fc04c552cb734c443f771eb2075cd4d4ce85df85105805667cc4cf51a67ceed2f9ebdf1a8cde&token=731065842&lang=zh_CN#rd" target="_blank" rel="noopener">《InnoDB一致性非锁定读》</a>中，我们了解到InnoDB使用一致性非锁定读来避免在一般的查询操作(SELECT FOR UPDATE等除外)时使用锁。然而锁这个事情是无法避免的，数据的写入，修改和删除都需要加锁。今天我们就继续学习InnoDB锁相关的知识。</p>
<a id="more"></a>

<p>由于文章涉及的概念比较多，害怕大家看完后会骂人，有一种字我都认识，就不太懂的感觉，文章会给出一些实例和试验，依据具体案例来讲解这些概念。毕竟，实践才能出真知。</p>
<p>InnoDB存储引擎支持表锁和行锁。顾名思义，表锁是锁住整张表，行锁只是锁住某些行。InnoDB通过给索引项加锁来实现行锁，如果没有索引，则通过隐藏的聚簇索引来对记录加锁。如果操作不通过索引条件检索数据，InnoDB 则对表中的所有记录加锁，实际效果就和表锁一样。InnoDB存储引擎有3种行锁的算法，分别是：</p>
<ul>
<li>Record Lock: 单个记录上的锁</li>
<li>Gap Lock: 间隙锁，锁定一个范围，但不包括记录本上</li>
<li>Next-Key Lock: Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身</li>
</ul>
<p>如下图所示，</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175010-58b28.jpeg" alt="img"></p>
<p>三种锁算法</p>
<p>例如一个索引有10,11,13,20这四个值。InnoDB可以根据需要使用Record Lock将10，11，13，20四个索引锁住，也可以使用Gap Lock将(-∞,10)，(10,11)，(11,13)，(13,20)，(20, +∞)五个范围区间锁住。Next-Key Locking类似于上述两种锁的结合，它可以锁住的区间有为(-∞,10]，(10,11]，(11,13]，(13,20]，(20, +∞)，可以看出它即锁定了一个范围，也会锁定记录本身。</p>
<p>InnoDB存储引擎的锁算法的一些规则如下所示，后续章节会给出对应的实验案例和详细讲解。</p>
<ul>
<li>在不通过索引条件查询时，InnoDB 会锁定表中的所有记录。所以，如果考虑性能，WHERE语句中的条件查询的字段都应该加上索引。</li>
<li>InnoDB通过索引来实现行锁，而不是通过锁住记录。因此，当操作的两条不同记录拥有相同的索引时，也会因为行锁被锁而发生等待。</li>
<li>由于InnoDB的索引机制，数据库操作使用了主键索引，InnoDB会锁住主键索引；使用非主键索引时，InnoDB会先锁住非主键索引，再锁定主键索引。</li>
<li>当查询的索引是唯一索引(不存在两个数据行具有完全相同的键值)时，InnoDB存储引擎会将Next-Key Lock降级为Record Lock，即只锁住索引本身，而不是范围。</li>
<li>InnoDB对于辅助索引有特殊的处理，不仅会锁住辅助索引值所在的范围，还会将其下一键值加上Gap LOCK。</li>
<li>InnoDB使用Next-Key Lock机制来避免Phantom Problem（幻读问题）。</li>
</ul>
<h2 id="真的了解本质吗"><a href="#真的了解本质吗" class="headerlink" title="真的了解本质吗?"></a>真的了解本质吗?</h2><p>在不通过索引条件查询时，InnoDB 会锁定表中的所有记录。大家可以登录上自己的MySQL服务器，亲自试验一下。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175011-8d9fc.jpeg" alt="img"></p>
<p>示例一</p>
<p>试验发现，会话二的查询操作真的是会发生等待。那么，这句话真的是对的吗？我们可以使用<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483694&idx=1&sn=671ad369f67441c7d1572110066d5695&chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&token=731065842&lang=zh_CN#rd" target="_blank" rel="noopener">《InnoDB锁的类型和状态查询》</a>中查询数据锁的方法查询一下，<strong>注意必须在会话二操作还在等待时进行查询，否则查询不到</strong>。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175011-a2fad.png" alt="img"></p>
<p>查询锁信息</p>
<p>其中lock_trx_id为1851的事务是会话二的事务，另一个是会话一的事务。我们可以看到两个锁都要对值为1的主键索引加锁。<em>需要注意的是，这里是对主键进行加锁</em>。二者之间的关系是怎么确定的呢?我们可以通过<code>information_schema.INNODB_LOCK_WAITS</code>中的数据确定。</p>
<p>奇怪，不是说好的锁定表中的所有记录嘛？查找了很多资料，发现<code>INNODB_LOCKS</code>的定义如下：</p>
<blockquote>
<p>The INNODB_LOCKS table contains information about each lock that an InnoDB transaction has requested but not yet acquired, and each lock that a transaction holds that is blocking another transaction.</p>
</blockquote>
<p>也就是说，这张表并不会显示所有锁的信息，而是只显示要申请却没有申请到，和已经持有锁并且阻塞其他线程的锁信息。怪不得必须在会话二进行等待时进行查询才能查得到数据。</p>
<p>因为两个会话的操作都要锁住所有的行，所以发现每次在第一行记录上就发生了锁等待。那我们使用插入语句试试。表e1的主键a的值为1-4，我们分别插入主键为1-4(当然会有主键重复问题，但是由于有锁，一直等待)的新记录，分别查询锁信息，就能看到会话一的事务对所有的主键都加了锁，也就是对所有的记录都加了锁。</p>
<h2 id="是索引，而不是记录"><a href="#是索引，而不是记录" class="headerlink" title="是索引，而不是记录"></a>是索引，而不是记录</h2><p>InnoDB存储引擎的行锁是通过锁住索引实现的，而不是记录。这是理解很多数据库锁问题的关键。</p>
<p>由于InnoDB特殊的索引机制，数据库操作使用主键索引时，InnoDB会锁住主键索引；使用非主键索引时，InnoDB会先锁住非主键索引，再锁定主键索引。不了解InnoDB索引机制的可以参考这篇<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483664&idx=1&sn=a4aea45edf13b367ee17539eaff4874b&chksm=fc04c570cb734c66447aec4344288025bfe6ba7d715af31dc6d60d65411cd90a05d9b02e749d&token=731065842&lang=zh_CN#rd" target="_blank" rel="noopener">文章</a></p>
<p>如下图所示，当InnoDB锁定非主键索引b时，它也会锁住其对应的主键索引，所以锁住b值为2和3的非主键索引，那么与其相关的a值为6,5的主键索引也需要被锁住。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175013-450b9.jpeg" alt="img"></p>
<p>非主键索引的加锁</p>
<p>比如说，一种常见的死锁情况一般出现在如下图所示的操作场景中。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175013-1ca41.jpeg" alt="img"></p>
<p>示例2</p>
<p>会话一的语句使用了b上的索引，因为它是非主键索引，所以会先在b索引上添加锁，再去a索引上加锁。而会话二的语句恰恰相反，会先在索引a上加锁，再去索引b加锁。这种情况下，就可能出现死锁。</p>
<h2 id="Next-Key-Lock锁到底有什么用？"><a href="#Next-Key-Lock锁到底有什么用？" class="headerlink" title="Next-Key Lock锁到底有什么用？"></a>Next-Key Lock锁到底有什么用？</h2><p>默认隔离级别REPEATABLE-READ下，InnoDB中行锁默认使用算法Next-Key Lock，只有当查询的索引是唯一索引或主键时，InnoDB会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围。当查询的索引为辅助索引时，InnoDB则会使用Next-Key Lock进行加锁。InnoDB对于辅助索引有特殊的处理，不仅会锁住辅助索引值所在的范围，还会将其下一键值加上Gap LOCK。</p>
<p>废话不多说，我们来看一下相关的实验，先做一下准备。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> e4 (a <span class="built_in">INT</span>, b <span class="built_in">INT</span>, PRIMARY <span class="keyword">KEY</span>(a), <span class="keyword">KEY</span>(b));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">1</span>,<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">3</span>,<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">5</span>,<span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">7</span>,<span class="number">6</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">10</span>,<span class="number">8</span>;</span></pre></td></tr></table></figure>

<p>然后开启一个会话执行下面的语句。</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> e4 <span class="keyword">WHERE</span> b=<span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span></pre></td></tr></table></figure>

<p>因为通过索引b来进行查询，所以InnoDB会使用Next-Key Lock进行加锁，并且索引b是非主键索引，所以还会对主键索引a进行加锁。对于主键索引a，仅仅对值为5的索引加上Record Lock（因为之前的规则）。而对于索引b，需要加上Next-Key Lock索引，锁定的范围是(1,3]。除此之外，还会对其下一个键值加上Gap Lock，即还有一个范围为(3,6)的锁。<br>大家可以再新开一个会话，执行下面的SQL语句，会发现都会被阻塞。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> e4 <span class="keyword">WHERE</span> a = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;  <span class="comment"># 主键a被锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">4</span>,<span class="number">2</span>;   <span class="comment"># 插入行b的值为2，在锁定的(1,3]范围内</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">6</span>,<span class="number">5</span>; <span class="comment"># 插入行b的值为5，在锁定的(3,6)范围内</span></span></pre></td></tr></table></figure>

<p>InnoDB引擎采用Next-Key Lock来解决幻读问题。因为Next-Key Lock是锁住一个范围，所以就不会产生幻读问题。但是需要注意的是，InnoDB只在Repeatable Read隔离级别下使用该机制。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/7d050498d9da" target="_blank" rel="noopener">https://www.jianshu.com/p/7d050498d9da</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（6）：InnoDB一致性非锁定读</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%886%EF%BC%89%EF%BC%9AInnoDB%E4%B8%80%E8%87%B4%E6%80%A7%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB/</url>
    <content><![CDATA[<p>一致性非锁定读(consistent nonlocking read)是指InnoDB存储引擎通过多版本控制(MVVC)读取当前数据库中行数据的方式。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB会去读取行的一个快照。</p>
<a id="more"></a>

<p><img src="http://image.winrains.cn/2019/10/20191031174517-7a2e1.jpeg" alt="img"></p>
<p>一致性非锁定读示意图</p>
<p>上图直观地展现了InnoDB一致性非锁定读的机制。之所以称其为非锁定读，是因为不需要等待行上排他锁的释放。快照数据是指该行的之前版本的数据，每行记录可能有多个版本，一般称这种技术为行多版本技术。由此带来的并发控制，称之为多版本并发控制(Multi Version Concurrency Control, MVVC)。InnoDB是通过undo log来实现MVVC。undo log本身用来在事务中回滚数据，因此快照数据本身是没有额外开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。</p>
<p>一致性非锁定读是InnoDB默认的读取方式，即读取不会占用和等待行上的锁。但是并不是在每个事务隔离级别下都是采用此种方式。此外，即使都是使用一致性非锁定读，但是对于快照数据的定义也各不相同。</p>
<p>在事务隔离级别READ COMMITTED和REPEATABLE READ下，InnoDB使用一致性非锁定读。然而，对于快照数据的定义却不同。在READ COMMITTED事务隔离级别下，一致性非锁定读总是读取被锁定行的最新一份快照数据。而在REPEATABLE READ事务隔离级别下，则读取事务开始时的行数据版本。</p>
<p>我们下面举个例子来详细说明一下上述的情况。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">session</span> A</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">BEGIN</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> id = <span class="number">1</span>;</span></pre></td></tr></table></figure>

<p>我们首先在会话A中显示地开启一个事务，然后读取test表中的id为1的数据，但是事务并没有结束。于此同时，用户在开启另一个会话B，这样可以模拟并发的操作，然后对会话B做出如下的操作：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">session</span> B</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">BEGIN</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">UPDATE</span> test <span class="keyword">SET</span> id = <span class="number">3</span> <span class="keyword">WHERE</span> id = <span class="number">1</span>;</span></pre></td></tr></table></figure>

<p>在会话B的事务中，将test表中id为1的记录修改为id=3，但是事务同样也没有提交，这样id=1的行其实加了一个排他锁。由于InnoDB在READ COMMITTED和REPEATABLE READ事务隔离级别下使用一致性非锁定读，这时如果会话A再次读取id为1的记录，仍然能够读取到相同的数据。此时，READ COMMITTED和REPEATABLE READ事务隔离级别没有任何区别。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174517-65081.jpeg" alt="img"></p>
<p>会话A和会话B示意图</p>
<p>如上图所示，当会话B提交事务后，会话A再次运行<code>SELECT * FROM test WHERE id = 1</code>的SQL语句时，两个事务隔离级别下得到的结果就不一样了。<br>对于READ COMMITTED的事务隔离级别，它总是读取行的最新版本，如果行被锁定了，则读取该行版本的最新一个快照。因为会话B的事务已经提交，所以在该隔离级别下上述SQL语句的结果集是空的。<br>对于REPEATABLE READ的事务隔离级别，总是读取事务开始时的行数据，因此，在该隔离级别下，上述SQL语句仍然会获得相同的数据。</p>
<h2 id="MVVC"><a href="#MVVC" class="headerlink" title="MVVC"></a>MVVC</h2><p>我们首先来看一下wiki上对MVVC的定义：</p>
<blockquote>
<p>Multiversion concurrency control (MCC or MVCC), is a concurrency control method commonly used by database management systems to provide concurrent access to the database and in programming languages to implement transactional memory.</p>
</blockquote>
<p>由定义可知，MVVC是用于数据库提供并发访问控制的并发控制技术。<br>数据库的并发控制机制有很多，最为常见的就是锁机制。锁机制一般会给竞争资源加锁，阻塞读或者写操作来解决事务之间的竞争条件，最终保证事务的可串行化。而MVVC则引入了另外一种并发控制，它让读写操作互不阻塞，每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回，由此解决了事务的竞争条件。<br>考虑一个现实场景。管理者要查询所有用户的存款总额，假设除了用户A和用户B之外，其他用户的存款总额都为0，A、B用户各有存款1000，所以所有用户的存款总额为2000。但是在查询过程中，用户A会向用户B进行转账操作。转账操作和查询总额操作的时序图如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174517-1fed0.jpeg" alt="img"></p>
<p>转账和查询的时序图</p>
<p>如果没有任何的并发控制机制，查询总额事务先读取了用户A的账户存款，然后转账事务改变了用户A和用户B的账户存款，最后查询总额事务继续读取了转账后的用户B的账号存款，导致最终统计的存款总额多了100元，发生错误。</p>
<p>使用锁机制可以解决上述的问题。查询总额事务会对读取的行加锁，等到操作结束后再释放所有行上的锁。因为用户A的存款被锁，导致转账操作被阻塞，直到查询总额事务提交并将所有锁都释放。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174518-4a989.jpeg" alt="img"></p>
<p>使用锁机制</p>
<p>但是这时可能会引入新的问题，当转账操作是从用户B向用户A进行转账时会导致死锁。转账事务会先锁住用户B的数据，等待用户A数据上的锁，但是查询总额的事务却先锁住了用户A数据，等待用户B的数据上的锁。</p>
<p>使用MVVC机制也可以解决这个问题。查询总额事务先读取了用户A的账户存款，然后转账事务会修改用户A和用户B账户存款，查询总额事务读取用户B存款时不会读取转账事务修改后的数据，而是读取本事务开始时的数据副本(在REPEATABLE READ隔离等级下)。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174518-c3ba9.jpeg" alt="img"></p>
<p>使用MVVC机制</p>
<p>MVCC使得数据库读不会对数据加锁，普通的SELECT请求不会加锁，提高了数据库的并发处理能力。借助MVCC，数据库可以实现READ COMMITTED，REPEATABLE READ等隔离级别，用户可以查看当前数据的前一个或者前几个历史版本，保证了ACID中的I特性（隔离性)</p>
<h2 id="InnoDB的MVVC实现"><a href="#InnoDB的MVVC实现" class="headerlink" title="InnoDB的MVVC实现"></a>InnoDB的MVVC实现</h2><p>多版本并发控制仅仅是一种技术概念，并没有统一的实现标准， 其的核心理念就是数据快照，不同的事务访问不同版本的数据快照，从而实现不同的事务隔离级别。虽然字面上是说具有多个版本的数据快照，但这并不意味着数据库必须拷贝数据，保存多份数据文件，这样会浪费大量的存储空间。InnoDB通过事务的undo日志巧妙地实现了多版本的数据快照。<br>数据库的事务有时需要进行回滚操作，这时就需要对之前的操作进行undo。因此，在对数据进行修改时，InnoDB会产生undo log。当事务需要进行回滚时，InnoDB可以利用这些undo log将数据回滚到修改之前的样子。<br>根据行为的不同 undo log 分为两种 insert undo log和update undo log。<br>insert undo log 是在 insert 操作中产生的 undo log。因为 insert 操作的记录只对事务本身可见，对于其它事务此记录是不可见的，所以 insert undo log 可以在事务提交后直接删除而不需要进行 purge 操作。<br>update undo log 是 update 或 delete 操作中产生的 undo log，因为会对已经存在的记录产生影响，为了提供 MVCC机制，因此 update undo log 不能在事务提交时就进行删除，而是将事务提交时放到入 history list 上，等待 purge 线程进行最后的删除操作。<br>为了保证事务并发操作时，在写各自的undo log时不产生冲突，InnoDB采用回滚段的方式来维护undo log的并发写入和持久化。回滚段实际上是一种 Undo 文件组织方式。<br>InnoDB行记录有三个隐藏字段：分别对应该行的rowid、事务号db_trx_id和回滚指针db_roll_ptr，其中db_trx_id表示最近修改的事务的id，db_roll_ptr指向回滚段中的undo log。如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174518-74ed7.jpeg" alt="img"></p>
<p>初始状态</p>
<p>当事务2使用UPDATE语句修改该行数据时，会首先使用排他锁锁定改行，将该行当前的值复制到undo log中，然后再真正地修改当前行的值，最后填写事务ID，使用回滚指针指向undo log中修改前的行。如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174519-e14b3.jpeg" alt="img"></p>
<p>第一次修改</p>
<p>当事务3进行修改与事务2的处理过程类似，如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174519-a9e7e.jpeg" alt="img"></p>
<p>第二次修改</p>
<p>REPEATABLE READ隔离级别下事务开始后使用MVVC机制进行读取时，会将当时活动的事务id记录下来，记录到Read View中。READ COMMITTED隔离级别下则是每次读取时都创建一个新的Read View。<br>Read View是InnoDB中用于判断记录可见性的数据结构，记录了一些用于判断可见性的属性。</p>
<ul>
<li>low_limit_id：某行记录的db_trx_id &lt; 该值，则该行对于当前Read View是一定可见的</li>
<li>up_limit_id：某行记录的db_trx_id &gt;= 该值，则该行对于当前read view是一定不可见的</li>
<li>low_limit_no：用于purge操作的判断</li>
<li>rw_trx_ids：读写事务数组</li>
</ul>
<p>Read View创建后，事务再次进行读操作时比较记录的db_trx_id和Read View中的low_limit_id，up_limit_id和读写事务数组来判断可见性。</p>
<p>如果该行中的db_trx_id等于当前事务id，说明是事务内部发生的更改，直接返回该行数据。否则的话，如果db_trx_id小于up_limit_id，说明是事务开始前的修改，则该记录对当前Read View是可见的，直接返回该行数据。</p>
<p>如果db_trx_id大于或者等于low_limit_id，则该记录对于该Read View一定是不可见的。如果db_trx_id位于[up_limit_id, low_limit_id)范围内，需要在活跃读写事务数组(rw_trx_ids)中查找db_trx_id是否存在，如果存在，记录对于当前Read View是不可见的。<br>如果记录对于Read View不可见，需要通过记录的DB_ROLL_PTR指针遍历undo log，构造对当前Read View可见版本数据。<br>简单来说，Read View记录读开始时及其之后，所有的活动事务，这些事务所做的修改对于Read View是不可见的。除此之外，所有其他的小于创建Read View的事务号的所有记录均可见。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/f6d4d5c37d66" target="_blank" rel="noopener">https://www.jianshu.com/p/f6d4d5c37d66</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（5）：InnoDB锁的类型和状态查询</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%885%EF%BC%89%EF%BC%9AInnoDB%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%8A%B6%E6%80%81%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>锁是数据库系统区分于文件系统的一个关键特性。数据库使用锁来支持对共享资源进行并发访问，提供数据的完整性和一致性。此外，数据库事务的隔离性也是通过锁实现的。InnoDB在此方面一直优于其他数据库引擎。InnoDB会在行级别上对表数据上锁，而MyISAM只能在表级别上锁，二者性能差异可想而知。</p>
<a id="more"></a>

<h2 id="InnoDB存储引擎中的锁"><a href="#InnoDB存储引擎中的锁" class="headerlink" title="InnoDB存储引擎中的锁"></a>InnoDB存储引擎中的锁</h2><p>InnoDB存储引擎实现了如下两种标准的行级锁：</p>
<ul>
<li>共享锁(S Lock)，允许事务读取一行</li>
<li>排他锁(X Lock)，允许事务删除或更新一行数据</li>
</ul>
<p>如果一个事务T1已经获取了行r的共享锁，那么另外一个事务T2可以立刻获得行r的共享锁，因为读取并不会改变数据，可以进行并发的读取操作；但若其他的事务T3想要获取行r的排他锁，则必须等待事务T1和T2释放行r上的共享锁之后才能继续，因为获取排他锁一般是为了改变数据，所以不能同时进行读取或则其他写入操作。</p>
<table>
<thead>
<tr>
<th></th>
<th>X</th>
<th>S</th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>S</td>
<td>不兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p>InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种称为意向锁的锁方式。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。</p>
<p>InnoDB存储引擎的意向锁即为表级别的锁。设计目的主要是为了在一个事务中揭示下一行将被请求的锁类型。其支持两种意向锁：</p>
<ul>
<li>意向共享锁(IS Lock)，事务想要获得一张表中某几行的共享锁</li>
<li>意向排他锁(IX Lock)，事务想要获得一张表中某几行的排他锁</li>
</ul>
<p>需要注意的是意向锁是表级别的锁，它不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。故表级别的意向锁和表级别的锁的兼容性如下表所示。</p>
<table>
<thead>
<tr>
<th></th>
<th>IS</th>
<th>IX</th>
<th>S</th>
<th>X</th>
</tr>
</thead>
<tbody><tr>
<td>IS</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>IX</td>
<td>兼容</td>
<td>兼容</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>S</td>
<td>兼容</td>
<td>不兼容</td>
<td>兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>X</td>
<td>不兼容</td>
<td>不兼容</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
</tbody></table>
<p>向一个表添加表级X锁的时候(执行ALTER TABLE, DROP TABLE, LOCK TABLES等操作)，如果没有意向锁的话，则需要遍历所有整个表判断是否有行锁的存在，以免发生冲突。如果有了意向锁，只需要判断该意向锁与即将添加的表级锁是否兼容即可。因为意向锁的存在代表了，有行级锁的存在或者即将有行级锁的存在，因而无需遍历整个表，即可获取结果。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174021-c0450.jpeg" alt="img"></p>
<p>层次结构.jpg</p>
<p>如果将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。如上图所示，如果需要对表1的记录m行上X锁，那么需要先对表1加意向IX锁，然后对记录m上X锁。如果其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成。</p>
<h2 id="InnoDB锁相关状态查询"><a href="#InnoDB锁相关状态查询" class="headerlink" title="InnoDB锁相关状态查询"></a>InnoDB锁相关状态查询</h2><p>用户可以使用INFOMATION_SCHEMA库下的INNODB_TRX、INNODB_LOCKS和INNODB_LOCK_WAITS表来监控当前事务并分析可能出现的锁问题。INNODB_TRX的定义如下表所示，其由8个字段组成。</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>trx_id</td>
<td>InnoDB存储引擎内部唯一的事务ID</td>
</tr>
<tr>
<td>trx_state</td>
<td>当前事务的状态</td>
</tr>
<tr>
<td>trx_started</td>
<td>事务的开始时间</td>
</tr>
<tr>
<td>trx_request_lock_id</td>
<td>等待事务的锁ID。如果trx_state的状态为LOCK WAIT,那么该字段代表当前事务等待之前事务占用的锁资源ID</td>
</tr>
<tr>
<td>trx_wait_started</td>
<td>事务等待的时间</td>
</tr>
<tr>
<td>trx_weight</td>
<td>事务的权重，反映了一个事务修改和锁住的行数，当发生死锁需要回滚时，会选择该数值最小的进行回滚</td>
</tr>
<tr>
<td>trx_mysql_thread_id</td>
<td>线程ID，SHOW PROCESSLIST 显示的结果</td>
</tr>
<tr>
<td>trx_query</td>
<td>事务运行的SQL语句</td>
</tr>
</tbody></table>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM information_schema.INNODB_TRX\G;</span></pre></td></tr><tr><td class="code"><pre><span class="line">************************************* <span class="number">1.</span>row *********************************************</span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_id:  <span class="number">7311</span>F4</span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_state: LOCK WAIT</span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_started: <span class="number">2010</span><span class="number">-01</span><span class="number">-04</span> <span class="number">10</span>:<span class="number">49</span>:<span class="number">33</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_requested_lock_id: <span class="number">7311</span>F4:<span class="number">96</span>:<span class="number">3</span>:<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_wait_started: <span class="number">2010</span><span class="number">-01</span><span class="number">-04</span> <span class="number">10</span>:<span class="number">49</span>:<span class="number">33</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_weight: <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_mysql_thread_id: <span class="number">471719</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_query: select * <span class="keyword">from</span> parent lock <span class="keyword">in</span> share mode</span></pre></td></tr></table></figure>

<p>INNODB_TRX表只能显示当前运行的InnoDB事务，并不能直接判断锁的一些情况。如果需要查看锁，则还需要访问表INNODB_LOCKS，该表的字段组成如下表所示。</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock_id</td>
<td>锁的ID</td>
</tr>
<tr>
<td>lock_trx_id</td>
<td>事务的ID</td>
</tr>
<tr>
<td>lock_mode</td>
<td>锁的模式</td>
</tr>
<tr>
<td>lock_type</td>
<td>锁的类型，表锁还是行锁</td>
</tr>
<tr>
<td>lock_table</td>
<td>要加锁的表</td>
</tr>
<tr>
<td>lock_index</td>
<td>锁住的索引</td>
</tr>
<tr>
<td>lock_space</td>
<td>锁住的space id</td>
</tr>
<tr>
<td>lock_page</td>
<td>事务锁定页的数量，若是表锁，则该值为NULL</td>
</tr>
<tr>
<td>lock_rec</td>
<td>事务锁定行的数量，如果是表锁，则该值为NULL</td>
</tr>
<tr>
<td>lock_data</td>
<td>事务锁住记录的主键值，如果是表锁，则该值为NULL</td>
</tr>
</tbody></table>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM information<span class="emphasis">_schema.INNODB_</span>LOCKS\G;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">**** 1.row **</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_id: 7311F4:96:3:2</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock<span class="emphasis">_trx_</span>id: 7311F4</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_mode: S</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_type: RECORD</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_type: 'mytest'.'parent'</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_index: 'PRIMARY'</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_space: 96</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_page: 3</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_rec: 2</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_data: 1</span></pre></td></tr></table></figure>

<p>通过表INNODB_LOCKS查看每张表上锁的情况后，用户就可以来判断由此引发的等待情况。当时当事务量非常大，其中锁和等待也时常发生，这个时候就不那么容易判断。但是通过表INNODB_LOCK_WAITS，可以很直观的反应当前事务的等待。表INNODB_LOCK_WAITS由四个字段组成，如下表所示。</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>requesting_trx_id</td>
<td>申请锁资源的事务ID</td>
</tr>
<tr>
<td>requesting_lock_id</td>
<td>申请的锁的ID</td>
</tr>
<tr>
<td>blocking_trx_id</td>
<td>阻塞的事务ID</td>
</tr>
<tr>
<td>blocking_lock_id</td>
<td>阻塞的锁的ID</td>
</tr>
</tbody></table>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM information<span class="emphasis">_schema.INNODB_</span>LOCK_WAITS\G;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">***1.row**</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span>*</span></pre></td></tr><tr><td class="code"><pre><span class="line">requesting<span class="emphasis">_trx_</span>id: 7311F4</span></pre></td></tr><tr><td class="code"><pre><span class="line">requesting<span class="emphasis">_lock_</span>id: 7311F4:96:3:2</span></pre></td></tr><tr><td class="code"><pre><span class="line">blocking<span class="emphasis">_trx_</span>id: 730FEE</span></pre></td></tr><tr><td class="code"><pre><span class="line">blocking<span class="emphasis">_lock_</span>id: 730FEE:96:3:2</span></pre></td></tr></table></figure>

<p>通过上述的SQL语句，用户可以清楚直观地看到哪个事务阻塞了另一个事务，然后使用上述的事务ID和锁ID，去INNODB_TRX和INNDOB_LOCKS表中查看更加详细的信息。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/160371211b10" target="_blank" rel="noopener">https://www.jianshu.com/p/160371211b10</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（4）：InnoDB的磁盘文件及落盘机制</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%884%EF%BC%89%EF%BC%9AInnoDB%E7%9A%84%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E5%8F%8A%E8%90%BD%E7%9B%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>任何一个技术都有其底层的关键基础技术，这些关键技术很有可能也是其他技术的关键技术，学习这些底层技术，就可以一通百通，让你很快的掌握其他技术。如何在磁盘上存储数据，如何使用日志文件保证数据不丢失以及如何落盘，不仅是MySQL等数据库的关键技术，也是MQ消息队列或者其他中间件的关键技术之一。</p>
<a id="more"></a>

<p><img src="http://image.winrains.cn/2019/10/20191031173512-1a975.png" alt="img"></p>
<p>InnoDB整体架构</p>
<p>上图详细显示了InnoDB存储引擎的体系架构，从图中可见，InnoDB存储引擎由内存池，后台线程和磁盘文件三大部分组成。接下来我们就来简单了解一下磁盘文件相关的概念和原理。</p>
<p>InnoDB的主要的磁盘文件主要分为三大块：一是系统表空间，二是用户表空间，三是redo日志文件和归档文件。二进制文件(binlog)等文件是MySQL Server层维护的文件，所以未列入InnoDB的磁盘文件中。</p>
<h2 id="系统表空间和用户表空间"><a href="#系统表空间和用户表空间" class="headerlink" title="系统表空间和用户表空间"></a>系统表空间和用户表空间</h2><p>InnoDB系统表空间包含InnoDB数据字典(元数据以及相关对象)并且doublewrite buffer,change buffer,undo logs的存储区域。系统表空间也默认包含任何用户在系统表空间创建的表数据和索引数据。系统表空间是一个共享的表空间因为它是被多个表共享的</p>
<p>系统表空间是由一个或者多个数据文件组成。默认情况下,1个初始大小为10MB，名为ibdata1的系统数据文件在MySQL的data目录下被创建。用户可以使用innodb_data_file_path对数据文件的大小和数量进行配置。</p>
<p>innodb_data_file_path的格式如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">innodb_data_file_path</span>=datafile1[,datafile2]<span class="built_in">..</span>.</span></pre></td></tr></table></figure>

<p>用户可以通过多个文件组成一个表空间，同时制定文件的属性：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">innodb_data_file_path = <span class="regexp">/db/</span><span class="string">ibdata1:</span><span class="number">1000</span>M;<span class="regexp">/dr2/</span>db/<span class="string">ibdata2:</span><span class="number">1000</span><span class="string">M:</span>autoextend</span></pre></td></tr></table></figure>

<p>这里讲/db/ibdata1和/dr2/db/ibdata2两个文件组成系统表空间。如果这两个文件位于不同的磁盘上，磁盘的负载可能被平均，因此可以提高数据库的整体性能。两个文件的文件名之后都跟了属性，表示文件ibdata1的大小为1000MB，文件ibdata2的大小为1000MB，而且用完空间之后可以自动增长(autoextend)。</p>
<p>设置innodb_data_file_path参数之后，所以基于InnoDB存储引擎的表的数据都会记录到该系统表空间中，如果设置了参数innodb_file_per_table，则用户可以将每个基于InnoDB存储引擎的表产生一个独立的用户表空间。用户表空间的命名规则为：表名.ibd。<br>通过这种方式，用户不用将所有数据都存放于默认的系统表空间中，但是用户表空只存储该表的数据、索引和插入缓冲BITMAP等信息，其余信息还是存放在默认的表空间中。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031173513-39774.png" alt="img"></p>
<p>InnoDB表存储引擎文件</p>
<p>上图显示InnoDB存储引擎对于文件的存储方式，其中frm文件是表结构定义文件，记录每个表的表结构定义。</p>
<h2 id="重做日志文件和归档文件"><a href="#重做日志文件和归档文件" class="headerlink" title="重做日志文件和归档文件"></a>重做日志文件和归档文件</h2><p>默认情况下，在InnoDB存储引擎的数据目录下会有两个名为ib_logfile0和ib_logfile1的文件，这就是InnoDB的重做日志文件(redo log fiel)，它记录了对于InnoDB存储引擎的事务日志。<br>当InnoDB的数据存储文件发生错误时，重做日志文件就能派上用场。InnoDB存储引擎可以使用重做日志文件将数据恢复为正确状态，以此来保证数据的正确性和完整性。</p>
<p>每个InnoDB存储引擎至少有1个重做日志文件组(group)，每个文件组下至少有2个重做日志文件，如默认的ib_logfile0和ib_logfile1。<br>为了得到更高的可靠性，用户可以设置多个镜像日志组，将不同的文件组放在不同的磁盘上，以此来提高重做日志的高可用性。</p>
<p>在日志组中每个重做日志文件的大小一致，并以循环写入的方式运行。InnoDB存储引擎先写入重做日志文件1，当文件被写满时，会切换到重做日志文件2，再当重做日志文件2也被写满时，再切换到重做日志文件1。</p>
<p>用户可以使用innodb_log_file_size来设置重做日志文件的大小，这对InnoDB存储引擎的性能有着非常大的影响。</p>
<p>如果重做日志文件设置的太大，数据丢失时，恢复时可能需要很长的时间；另一方面，如果设置的太小，重做日志文件太小会导致依据checkpoint的检查需要频繁刷新脏页到磁盘中，导致性能的抖动。<br>重做日志相关和Checkpoint的机制可以阅读我之前文章的相应章节。<a href="https://mp.weixin.qq.com/s/JCXdP59OUvQEB3q1V9YrCA" target="_blank" rel="noopener">MySQL探秘(三):InnoDB的内存结构和特性
</a></p>
<h2 id="重做日志的落盘机制"><a href="#重做日志的落盘机制" class="headerlink" title="重做日志的落盘机制"></a>重做日志的落盘机制</h2><p>InnoDB对于数据文件和日志文件的刷盘遵守WAL(Write ahead redo log) 和Force-log-at-commit两种规则，二者保证了事务的持久性。WAL要求数据的变更写入到磁盘前，首先必须将内存中的日志写入到磁盘；Force-log-at-commit要求当一个事务提交时，所有产生的日志都必须刷新到磁盘上，如果日志刷新成功后，缓冲池中的数据刷新到磁盘前数据库发生了宕机，那么重启时，数据库可以从日志中恢复数据。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031173514-36d2a.jpeg" alt="img"></p>
<h3 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h3><p>如上图所示，InnoDB在缓冲池中变更数据时，会首先将相关变更写入重做日志缓冲中，然后再按时或者当事务提交时写入磁盘，这符合Force-log-at-commit原则；当重做日志写入磁盘后，缓冲池中的变更数据才会依据checkpoint机制择时写入到磁盘中，这符合WAL原则。<br>在checkpoint择时机制中，就有重做日志文件写满的判断，所以，如前文所述，如果重做日志文件太小，经常被写满，就会频繁导致checkpoint将更改的数据写入磁盘，导致性能抖动。</p>
<p>操作系统的文件系统是带有缓存的，当InnoDB向磁盘写入数据时，有可能只是写入到了文件系统的缓存中，没有真正的“落袋为安”。<br>InnoDB的innodb_flush_log_at_trx_commit属性可以控制每次事务提交时InnoDB的行为。当属性值为0时，事务提交时，不会对重做日志进行写入操作，而是等待主线程按时写入；当属性值为1时，事务提交时，会将重做日志写入文件系统缓存，并且调用文件系统的fsync，将文件系统缓冲中的数据真正写入磁盘存储，确保不会出现数据丢失；当属性值为2时，事务提交时，也会将日志文件写入文件系统缓存，但是不会调用fsync，而是让文件系统自己去判断何时将缓存写入磁盘。日志的刷盘机制如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031173514-227a0.png" alt="img"></p>
<h3 id="log刷盘机制"><a href="#log刷盘机制" class="headerlink" title="log刷盘机制"></a>log刷盘机制</h3><p>innodb_flush_log_at_commit是InnoDB性能调优的一个基础参数，涉及InnoDB的写入效率和数据安全。当参数值为0时，写入效率最高，但是数据安全最低；参数值为1时，写入效率最低，但是数据安全最高；参数值为2时，二者都是中等水平。一般建议将该属性值设置为1，以获得较高的数据安全性，而且也只有设置为1，才能保证事务的持久性。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/e546ea1fc067" target="_blank" rel="noopener">https://www.jianshu.com/p/e546ea1fc067</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（3）：InnoDB的内存结构和特性</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%883%EF%BC%89%EF%BC%9AInnoDB%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%92%8C%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>常言说得好，每个成功男人背后都有一个为他默默付出的女人，而对于MySQL来说，这个“人”就是InnoDB存储引擎。<br>MySQL区别于其他数据库的最为重要的特点就是其插件式的表存储引擎。而在众多存储引擎中，InnoDB是最为常用的存储引擎。从MySQL5.5.8版本开始，InnoDB存储引擎是默认的存储引擎。<br>InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理(OLTP)的应用。其特点是行锁设计、支持外键，并支持非锁定读，即默认读操作不会产生锁。</p>
<a id="more"></a>

<p>InnoDB通过使用多版本并发控制(MVCC)来获取高并发性，并且实现了SQL标准的4中隔离级别，默认为REPEATABLE级别。同时，使用一种被称为next-key-locking的策略来避免幻读现象的产生。除此之外，InnoDB存储引擎还提供了插入缓冲(insert buffer)、二次写(double write)、自适应哈希索引(adaptive hash index)、预读(read ahead)等高性能和高可用的功能。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031172740-361a4.png" alt="img"></p>
<p>InnoDB整体架构.png</p>
<p>上图详细显示了InnoDB存储引擎的体系架构，从图中可见，InnoDB存储引擎由内存池，后台线程和磁盘文件三大部分组成。接下来我们就来简单了解一下内存相关的概念和原理。</p>
<h2 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h2><p>InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。但是由于CPU速度和磁盘速度之间的鸿沟，基于磁盘的数据库系统通常使用缓冲池记录来提高数据库的的整体性能。</p>
<p>在数据库中进行读取操作，首先将从磁盘中读到的页放在缓冲池中，下次再读相同的页中时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取该页。否则，读取磁盘上的页。</p>
<p>对于数据库中页的修改操作，则首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是通过一种称为CheckPoint的机制刷新回磁盘。</p>
<p>所以，缓冲池的大小直接影响着数据库的整体性能，可以通过配置参数innodb_buffer_pool_size来设置。</p>
<p>具体来看，缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲(insert buffer)、自适应哈希索引(adaptive hash index)、InnoDB存储的锁信息(lock info)和数据字典信息(data dictionary)。</p>
<p>在架构图上可以看到，InnoDB存储引擎的内存区域除了有缓冲池之外，还有重做日志缓冲和额外内存池。InnoDB存储引擎首先将重做日志信息先放到这个缓冲区中，然后按照一定频率将其刷新到重做日志文件中。重做日志缓冲一般不需要设置的很大，该值可由配置参数innodb_log_buffer_size控制。</p>
<h2 id="数据页和索引页"><a href="#数据页和索引页" class="headerlink" title="数据页和索引页"></a>数据页和索引页</h2><p>Page是Innodb存储的最基本结构，也是Innodb磁盘管理的最小单位，与数据库相关的所有内容都存储在Page结构里。Page分为几种类型，数据页和索引页就是其中最为重要的两种类型。</p>
<h2 id="插入缓冲-Insert-Buffer"><a href="#插入缓冲-Insert-Buffer" class="headerlink" title="插入缓冲(Insert Buffer)"></a>插入缓冲(Insert Buffer)</h2><p>我们都知道，在InnoDB引擎上进行插入操作时，一般需要按照主键顺序进行插入，这样才能获得较高的插入性能。当一张表中存在非聚簇的且不唯一的索引时，在插入时，数据页的存放还是按照主键进行顺序存放，但是对于非聚簇索引叶节点的插入不再是顺序的了，这时就需要离散的访问非聚簇索引页，由于随机读取的存在导致插入操作性能下降。</p>
<p>InnoDB为此设计了Insert Buffer来进行插入优化。对于非聚簇索引的插入或者更新操作，不是每一次都直接插入到索引页中，而是先判断插入的非聚集索引是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer中。看似数据库这个非聚集的索引已经查到叶节点，而实际没有，这时存放在另外一个位置。然后再以一定的频率和情况进行Insert Buffer和非聚簇索引页子节点的合并操作。这时通常能够将多个插入合并到一个操作中，这样就大大提高了对于非聚簇索引的插入性能。</p>
<h2 id="两次写-Double-Write"><a href="#两次写-Double-Write" class="headerlink" title="两次写(Double Write)"></a>两次写(Double Write)</h2><p>如果说Insert Buffer给InnoDB存储引擎带来了性能上的提升，那么Double Write带给InnoDB存储引擎的是数据页的可靠性。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031172743-bdca7.jpeg" alt="img"></p>
<p>doublewrite示意图</p>
<p>如上图所示，Double Write由两部分组成，一部分是内存中的double write buffer，大小为2MB，另一部分是物理磁盘上共享表空间连续的128个页，大小也为2MB。在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是通过memcpy函数将脏页先复制到内存中的该区域，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免操作系统缓冲写带来的问题。在完成doublewrite页的写入后，再讲doublewirite buffer中的页写入各个表空间文件中。</p>
<p>如果操作系统在将页写入磁盘的过程中发生了崩溃，在恢复过程中，InnoDB存储引擎可以从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件中，再应用重做日志。</p>
<h2 id="重做日志-Redo-Log-Buffer"><a href="#重做日志-Redo-Log-Buffer" class="headerlink" title="重做日志(Redo Log Buffer)"></a>重做日志(Redo Log Buffer)</h2><p>当缓冲池中的页的版本比磁盘要新时，数据库需要将新版本的页从缓冲池刷新到磁盘。但是如果每次一个页发送变化，就进行刷新，那么性能开发是非常大的，于是InnoDB采用了Write Ahead Log策略，即当事务提交时，先写重做日志，然后再择时将脏页写入磁盘。如果发生宕机导致数据丢失，就通过重做日志进行数据恢复。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031172743-45863.jpeg" alt="img"></p>
<p>InnoDB数据写入示意图</p>
<p>InnoDB存储引擎会首先将重做日志信息先放入重做日志缓冲中，然后再按照一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置得很大，因为一般情况每一秒钟都会讲重做日志缓冲刷新到日志文件中。可通过配置参数innodb_log_buffer_size控制，默认为8MB。</p>
<p>除了每秒刷新机制之外，每次事务提交时重做日志缓冲也会刷新到日志中。InnoDB是事务的存储引擎，其通过Force Log at Commit机制实现事务的持久性，即当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，然后事务的提交操作完成才算完成。InnoDB的写入机制大致入下图所示。</p>
<p>为了确保每次日志都写入到重做日志文件，在每次讲重做日志缓冲写入重做日志后，必须调用一次fsync操作，将缓冲文件从文件系统缓存中真正写入磁盘。</p>
<p>可以通过innodb_flush_log_at_trx_commit来控制重做日志刷新到磁盘的策略。该参数默认值为1，表示事务提交必须进行一次fsync操作，还可以设置为0和2。0表示事务提交时不进行写入重做日志操作，该操作只在主线程中完成，2表示提交时写入重做日志，但是只写入文件系统缓存，不进行fsync操作。由此可见，设置为0时，性能最高，但是丧失了事务的一致性。</p>
<h2 id="自适应哈希索引-Adaptive-Hash-Index"><a href="#自适应哈希索引-Adaptive-Hash-Index" class="headerlink" title="自适应哈希索引(Adaptive Hash Index)"></a>自适应哈希索引(Adaptive Hash Index)</h2><p>InnoDB会根据访问的频率和模式，为热点页建立哈希索引，来提高查询效率。InnoDB存储引擎会监控对表上各个索引页的查询，如果观察到建立哈希索引可以带来速度上的提升，则建立哈希索引，所以叫做自适应哈希索引。</p>
<p>自适应哈希索引是通过缓冲池的B+树页构建而来，因此建立速度很快，而且不需要对整张数据表建立哈希索引。其有一个要求，即对这个页的连续访问模式必须是一样的，也就是说其查询的条件(WHERE)必须完全一样，而且必须是连续的。</p>
<h2 id="锁信息-lock-info"><a href="#锁信息-lock-info" class="headerlink" title="锁信息(lock info)"></a>锁信息(lock info)</h2><p>我们都知道，InnoDB存储引擎会在行级别上对表数据进行上锁。不过InnoDB也会在数据库内部其他很多地方使用锁，从而允许对多种不同资源提供并发访问。数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。关于锁的具体知识我们之后再进行详细学习。</p>
<h2 id="数据字典信息-Data-Dictionary"><a href="#数据字典信息-Data-Dictionary" class="headerlink" title="数据字典信息(Data Dictionary)"></a>数据字典信息(Data Dictionary)</h2><p>InnoDB有自己的表缓存，可以称为表定义缓存或者数据字典。当InnoDB打开一张表，就增加一个对应的对象到数据字典。</p>
<p>数据字典是对数据库中的数据、库对象、表对象等的元信息的集合。在MySQL中，数据字典信息内容就包括表结构、数据库名或表名、字段的数据类型、视图、索引、表字段信息、存储过程、触发器等内容。MySQL INFORMATION_SCHEMA库提供了对数据局元数据、统计信息、以及有关MySQL server的访问信息（例如：数据库名或表名，字段的数据类型和访问权限等）。该库中保存的信息也可以称为MySQL的数据字典。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/1c1f83d0bb72" target="_blank" rel="noopener">https://www.jianshu.com/p/1c1f83d0bb72</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（2）：SQL语句执行过程详解</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%882%EF%BC%89%EF%BC%9ASQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>昔日庖丁解牛，未见全牛，所赖者是其对牛内部骨架结构的了解，对于MySQL亦是如此，只有更加全面地了解SQL语句执行的每个过程，才能更好的进行SQL的设计和优化。<br>当希望MySQL能够以更高的性能运行查询时，最好的办法就是弄清楚MySQL是如何优化和执行查询的。一旦理解了这一点，很多查询优化工作实际上就是遵循一些原则能够按照预想的合理的方式运行。</p>
<a id="more"></a>

<p>如下图所示，当向MySQL发送一个请求的时候，MySQL到底做了什么：</p>
<ol>
<li>客户端发送一条查询给服务器。</li>
<li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</li>
<li>服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。</li>
<li>MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询。</li>
<li>将结果返回给客户端。</li>
</ol>
<p><img src="http://image.winrains.cn/2019/10/20191031172218-253a8.png" alt="img"></p>
<p>SQL语句执行过程</p>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>MySQL查询缓存保存查询返回的完整结构。当查询命中该缓存时，MySQL会立刻返回结果，跳过了解析、优化和执行阶段。<br>查询缓存系统会跟踪查询中涉及的每个表，如果这些表发生了变化，那么和这个表相关的所有缓存数据都将失效。<br>MySQL将缓存存放在一个引用表中，通过一个哈希值引用，这个哈希值包括了以下因素，即查询本身、当前要查询的数据库、客户端协议的版本等一些其他可能影响返回结果的信息。<br>当判断缓存是否命中时，MySQL不会进行解析查询语句，而是直接使用SQL语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。<br>当查询语句中有一些不确定的数据时，则不会被缓存。例如包含函数NOW()或者CURRENT_DATE()的查询不会缓存。包含任何用户自定义函数，存储函数，用户变量，临时表，mysql数据库中的系统表或者包含任何列级别权限的表，都不会被缓存。<br>有一点需要注意，MySQL并不是会因为查询中包含一个不确定的函数而不检查查询缓存，因为检查查询缓存之前，MySQL不会解析查询语句，所以也无法知道语句中是否有不确定的函数。<br>事实则是，如果查询语句中包含任何的不确定的函数，那么其查询结果不会被缓存，因为查询缓存中也无法找到对应的缓存结果。<br>有关查询缓存的配置如下所示。</p>
<ul>
<li>query_cache_type:是否打开查询缓存。可以设置为OFF、ON和DEMAND。DEMAND表示只有在查询语句中明确写明SQL_CACHE的语句才会放入查询缓存。</li>
<li>query_cache_size:查询缓存使用的总内存空间。</li>
<li>query_cache_min_res_unit:在查询缓存中分配内存块时的最小单元。较小的该值可以减少碎片导致的内存空间浪费，但是会导致更频繁的内存块操作。</li>
<li>query_cache_limit:MySQL能够查询的最大查询结果。如果查询结果大于这个值，则不会被缓存。因为查询缓存在数据生成的时候就开始尝试缓存数据，所以当结果全部返回后，MySQL才知道查询结果是否超出限制。超出之后，才会将结果从查询缓存中删除。</li>
</ul>
<p>对查询缓存的优化是数据库性能优化的重要一环。判断流程大致如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031172218-253a8.png" alt="img"></p>
<p>查询缓存判断流程图</p>
<p>缓存命中率可以通过如下公式计算：Qcache_hits/(Qcache_hits + Com_select)来计算。</p>
<h2 id="解析和预处理"><a href="#解析和预处理" class="headerlink" title="解析和预处理"></a>解析和预处理</h2><p>解析器通过关键字将SQL语句进行解析，并生成对应的解析树。MySQL解析器将使用MySQL语法规则验证和解析查询。<br>预处理器则根据一些MySQL规则进行进一步检查解析书是否合法，例如检查数据表和数据列是否存在，还会解析名字和别名，看看它们是否有歧义。</p>
<h2 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h2><p>查询优化器会将解析树转化成执行计划。一条查询可以有多种执行方法，最后都是返回相同结果。优化器的作用就是找到这其中最好的执行计划。<br>生成执行计划的过程会消耗较多的时间，特别是存在许多可选的执行计划时。如果在一条SQL语句执行的过程中将该语句对应的最终执行计划进行缓存，当相似的语句再次被输入服务器时，就可以直接使用已缓存的执行计划，从而跳过SQL语句生成执行计划的整个过程，进而可以提高语句的执行速度。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031172220-78b8b.png" alt="img"></p>
<p>执行计划缓存</p>
<p>MySQL使用基于成本的查询优化器(Cost-Based Optimizer，CBO)。它会尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最少的一个。<br>优化器会根据优化规则对关系表达式进行转换，这里的转换是说一个关系表达式经过优化规则后会生成另外一个关系表达式，同时原有表达式也会保留，经过一系列转换后会生成多个执行计划，然后CBO会根据统计信息和代价模型(Cost Model)计算每个执行计划的Cost，从中挑选Cost最小的执行计划。由上可知，CBO中有两个依赖：统计信息和代价模型。统计信息的准确与否、代价模型的合理与否都会影响CBO选择最优计划。<br>有关优化器的原理十分复杂，这里就不进行详细讲解了，大家可以自行学习。</p>
<h2 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h2><p>在解析和优化阶段，MySQL将生成查询对应的执行计划，MySQL的查询执行引擎根据这个执行计划来完成整个查询。这里执行计划是一个数据结构，而不是和其他的关系型数据库那样生成对应的字节码。</p>
<h2 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h2><p>如果查询可以被缓存，那么MySQL在这个阶段页会将结果存放到查询缓存中。<br>MySQL将结果集返回给客户端是一个增量、逐步返回的过程。在查询生成第一条结果时，MySQL就可以开始向客户端逐步返回结果集了。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/56fe9bf91448" target="_blank" rel="noopener">https://www.jianshu.com/p/56fe9bf91448</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（1）：B-Tree索引</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%881%EF%BC%89%EF%BC%9AB-Tree%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>MySQL是目前业界最为流行的关系型数据库之一，而索引的优化也是数据库性能优化的关键之一。所以，充分地了解MySQL索引有助于提升开发人员对MySQL数据库的使用优化能力。<br>MySQL的索引有很多种类型，可以为不同的场景提供更好的性能。而B-Tree索引是最为常见的MySQL索引类型，一般谈论MySQL索引时，如果没有特别说明，就是指B-Tree索引。本文就详细讲解一下B-Tree索引的的底层结构，使用原则和特性。</p>
<a id="more"></a>

<p>为了节约你的时间，本文的主要内容如下：</p>
<ul>
<li>B-Tree索引的底层结构</li>
<li>B-Tree索引的使用规则</li>
<li>聚簇索引</li>
<li>InnoDB和MyISAM引擎索引的差异</li>
<li>松散索引</li>
<li>覆盖索引</li>
</ul>
<h2 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h2><p>B-Tree索引使用B-Tree来存储数据，当然不同存储引擎的实现方式不同。B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同，图1展示了B-Tree索引的抽象表示，由此可以看出MySQL的B-Tree索引的大致工作机制。<br>B-Tree索引的底层数据结构一般是B+树，其具体数据结构和优势这里就不作详细描述，图1展示了B-树索引的抽象表示，大致反应了MyISAM索引是如何工作的，而InnoDB使用的结构有所不同。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031171835-cd3fe.png" alt="img"></p>
<p>图1 B-Tree索引的底层结构示意图</p>
<p>MySQL可以在单独一列上添加B-Tree索引，也可以在多列数据上添加B-Tree索引，多列的数据按照添加索引声明的顺序组合起来，存储在B-Tree的页中。假设有如下数据表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People (</span></pre></td></tr><tr><td class="code"><pre><span class="line">      last_name    <span class="built_in">varchar</span>(<span class="number">50</span>)    <span class="keyword">not</span> <span class="literal">null</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      first_name   <span class="built_in">varchar</span>(<span class="number">50</span>)    <span class="keyword">not</span> <span class="literal">null</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      birthday     <span class="built_in">date</span>           <span class="keyword">not</span> <span class="literal">null</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      gender       enum(<span class="string">'m'</span>,<span class="string">'f'</span>)  <span class="keyword">not</span> <span class="literal">null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">key</span>(last_name, first_name, birthday)</span></pre></td></tr><tr><td class="code"><pre><span class="line">);</span></pre></td></tr></table></figure>

<p>对于表中的每一行数据，索引中包含了last_name，first_name和birthday列的值，图2展示了该索引是如何组织数据的存储的。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031171836-50d95.png" alt="img"></p>
<p>图2 多列索引</p>
<p>B-Tree索引使用B-Tree作为其存储数据的数据结构，其使用的查询规则也由此决定。一般来说，B-Tree索引适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于根据最左前缀查找。B-Tree索引支持的查询原则如下所示：</p>
<ul>
<li>全值匹配：全值匹配指的是和索引中的所有列进行匹配，</li>
<li>匹配最左前缀：前边提到的索引可以用于查找所有姓Allen的人，即只使用索引中的第一列。</li>
<li>匹配列前缀：也可以只匹配某一列的值的开头部分。例如前面提到的索引可用于查找所有以J开头的姓的人。这里也只用到了索引的第一列。</li>
<li>匹配范围值：例如前边提到的索引可用于查找姓在Allen和Barrymore之间的人。这里也只使用了索引的第一列。</li>
<li>精确匹配某一列并范围匹配另外一列：前边提到的索引也可用于查找所有姓为Allen，并且名字是字母K开头(比如Kim,Karl等)的人。即第一列last_name全匹配，第二列first_name范围匹配。</li>
</ul>
<p>因为索引树的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的ORDER BY操作(按顺序查找)，如果ORDER BY子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。<br>下面是一些关于B-Tree索引的限制：</p>
<ul>
<li>如果不是按照索引的最左列开始查找，则无法使用索引。例如上面例子中的索引无法查找名字为Bill的人，也无法查找某个特定生日的日，因为这两列都不是最左数据列。</li>
<li>如果查询中有某个列的范围查询，则其右侧所有列都无法使用索引优化查找。</li>
</ul>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于其实现方式，但是InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。<br>当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中，这也就是说数据行和相邻的键值紧凑地存储在一起。<br>图3展示了聚簇索引中的记录是如何存放的。注意到，叶子页包含了行的全部数据行，但是节点页只包含了索引列。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031171836-2a3fb.png" alt="img"></p>
<p>图3 聚簇索引</p>
<p>聚簇索引可能对性能有帮助，但也可能导致严重的性能问题。聚簇的数据是有一些重要的优点：</p>
<ul>
<li>数据访问更快，聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li>
</ul>
<p>如果在设计表和查询时能充分利用上面的优点，那么就能极大地提升性能。同时，聚簇索引也有一些缺点：</p>
<ul>
<li>插入顺序严重依赖插入顺序。按照主键的顺序插入是向InnoDB表中插入数据速度最快的方式，需要避免主键键值随机的(不连续且值得分布范围非常大)聚簇索引，比如使用UUID作为主键，而应该使用类似AUTO_INCREMENT的自增列。</li>
<li>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动位置到新的位置。</li>
<li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行时，可能面临“页分裂”的问题。当行的主键值要求必须将这行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间</li>
<li>二级索引可能比想象的更大，因为在二级索引中的叶节点包含了引用行的主键列</li>
<li>二级索引访问需要两次索引查找，而不是一次。</li>
</ul>
<h2 id="InnoDB和MyISAM的索引区别"><a href="#InnoDB和MyISAM的索引区别" class="headerlink" title="InnoDB和MyISAM的索引区别"></a>InnoDB和MyISAM的索引区别</h2><p>聚簇索引和非聚簇索引的数据分布有区别，以及对应的主键索引和二级索引的数据分布也有区别，通常会让人感到困惑和意外。图4展示了MyISAM和InnoDB的不同索引和数据存储方式。<br>MyISAM的数据分布非常简单，按照数据插入的顺序存储在磁盘上，主键索引和二级索引的叶节点存储着指针，指向对应的数据行。<br>InnoDB中，聚簇索引“就是”表，所以不会像MyISAM那样需要独立的行存储。聚簇索引的每个叶节点都包含了主键值和所有的剩余列(在此例中是col2)。<br>InnoDB的二级索引和聚簇索引很不同。InnoDB二级索引的叶节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031171837-1e9a0.png" alt="img"></p>
<p>图4 InnoDB和MyISAM的区别</p>
<h2 id="松散索引扫描"><a href="#松散索引扫描" class="headerlink" title="松散索引扫描"></a>松散索引扫描</h2><p>MySQL并不支持松散索引扫描，也就是无法按照不连续的方式扫描一个索引。通常，MySQL的索引扫描需要先定义一个起点和终点，即使需要的数据只是这段索引中很少数的几个，MySQL仍然需要扫描这段索引中的每个条目。<br>下面，我们通过一个示例说明这点，假设我们有如下索引(a,b)，有下面的查询：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">mysql&gt;<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb1 <span class="keyword">WHERE</span> b <span class="keyword">BETWEEN</span> <span class="number">2</span> <span class="keyword">AND</span> <span class="number">3</span>;</span></pre></td></tr></table></figure>

<p>因为索引的前导字段是列a，但是在查询中只指定了字段b，MySQL无法使用这个索引，从而只能通过全表扫描找到匹配的行，如图5所示。<br><img src="http://image.winrains.cn/2019/10/20191031171837-a11d6.png" alt="img"></p>
<p>图5 全表扫描</p>
<p>了解索引的物理结构的话，不难发现还可以有一个更快的办法执行上面的查询。索引的物理结构(不是存储引擎的API)是的可以先扫描a列第一个值对应的b列的范围，然后再跳到a列第二个不不同值扫描对应的b列的范围。图6展示了如果由MySQL来实现这个过程会怎样。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031171838-b59f9.png" alt="img"></p>
<p>图6 松散索引</p>
<p>注意到，这时就无须再使用WHERE子句过滤，因为松散索引扫描已经跳过了所有不需要的记录。<br>MySQL 5.0之后的版本，在某些特殊的场景下是可以使用松散索引扫描的，例如，在一个分组查询中需要找到分组的最大值和最小值：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT actor_id, MAX(film_id)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        -&gt; <span class="keyword">FROM</span> sakila.film.film_actor</span></pre></td></tr><tr><td class="code"><pre><span class="line">        -&gt;<span class="built_in"> GROUP </span>BY actor_id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">********************************************* 1. row ***********************************</span></pre></td></tr><tr><td class="code"><pre><span class="line">id: 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">select_type: SIMPLE</span></pre></td></tr><tr><td class="code"><pre><span class="line">table: film_actor</span></pre></td></tr><tr><td class="code"><pre><span class="line">type: range</span></pre></td></tr><tr><td class="code"><pre><span class="line">possible_keys: <span class="literal">NULL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">key: PRIMARY</span></pre></td></tr><tr><td class="code"><pre><span class="line">key_len: 2</span></pre></td></tr><tr><td class="code"><pre><span class="line">ref: <span class="literal">NULL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">rows: 396</span></pre></td></tr><tr><td class="code"><pre><span class="line">Extra: Using index <span class="keyword">for</span> group-by</span></pre></td></tr></table></figure>

<p>在EXPLAIN中的Extra字段显示”Using index for group-by”，表示这里将使用松散索引扫描。</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>索引除了是一种查找数据的高效方式之外，也是一种列数据的直接获取方式。MySQL可以使用索引来直接获取列的数据，这样就不需要读取数据行。如果一个索引包含所有需要查询的字段的值，我们就称之为“覆盖索引”。<br>覆盖索引是非常有用的工具，能够极大地提高性能。SQL查询只需要扫描索引而无需回表，会带来很多好处：</p>
<ul>
<li>索引条目数量和大小通常远小于数据行的条目和大小，所以如果只需要读取索引，那么MySQL就会极大地减少数据访问量。</li>
<li>因为索引是按照列顺序存储的，所以对于I/O密集型的范围查找会比随机从磁盘读取每一行数据的I/O要少的多。</li>
<li>由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键，索引如果二级主键能够覆盖查询，则避免对主键索引的第二次查询。</li>
</ul>
<p>当发起一个被覆盖索引的查询(也叫索引覆盖查询)时，在EXPLAIN的Extra列可以看到”Using Index”的信息。例如，表sakila.inventory有一个多列索引(store_id, film_id)。MySQL如果只需要访问这两列，就可以使用这个索引做覆盖索引，如下所示：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT store<span class="emphasis">_id, film_</span>id FROM sakila.inventory</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">***1.row**</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**</span></pre></td></tr><tr><td class="code"><pre><span class="line">id:1</span></pre></td></tr><tr><td class="code"><pre><span class="line">select_type:SIMPLE</span></pre></td></tr><tr><td class="code"><pre><span class="line">table:inventory</span></pre></td></tr><tr><td class="code"><pre><span class="line">type:index</span></pre></td></tr><tr><td class="code"><pre><span class="line">possible_keys:NULL</span></pre></td></tr><tr><td class="code"><pre><span class="line">key:idx<span class="emphasis">_store_</span>id<span class="emphasis">_film_</span>id</span></pre></td></tr><tr><td class="code"><pre><span class="line">key_len:3</span></pre></td></tr><tr><td class="code"><pre><span class="line">ref:NULL</span></pre></td></tr><tr><td class="code"><pre><span class="line">rows:4673</span></pre></td></tr><tr><td class="code"><pre><span class="line">Extra:Using Index</span></pre></td></tr></table></figure>

<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/9e00633958e6" target="_blank" rel="noopener">https://www.jianshu.com/p/9e00633958e6</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Redis使用方法</title>
    <url>/2019/12/26/Redis%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本文将从Redis的基本特性入手，通过讲述Redis的数据结构和主要命令对Redis的基本能力进行直观介绍。</p>
<p>然后概览Redis提供的高级能力，并在部署、维护、性能调优等多个方面进行更深入的介绍和指导。</p>
<p>本文适合使用Redis的普通开发人员，以及对Redis进行选型、架构设计和性能调优的架构设计人员。</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h1><p>Redis是一个开源的，基于内存的结构化数据存储媒介，可以作为数据库、缓存服务或消息服务使用。<br>Redis支持多种数据结构，包括字符串、哈希表、链表、集合、有序集合、位图、Hyperloglogs等。<br>Redis具备LRU淘汰、事务实现、以及不同级别的硬盘持久化等能力，并且支持副本集和通过Redis Sentinel实现的高可用方案，同时还支持通过Redis Cluster实现的数据自动分片能力。<br>Redis的主要功能都基于单线程模型实现，也就是说Redis使用一个线程来服务所有的客户端请求<br>同时Redis采用了非阻塞式IO，并精细地优化各种命令的算法时间复杂度，这些信息意味着：</p>
<ul>
<li>Redis是线程安全的（因为只有一个线程），其所有操作都是原子的，不会因并发产生数据异常</li>
<li>Redis的速度非常快（因为使用非阻塞式IO，且大部分命令的算法时间复杂度都是O(1))</li>
<li>使用高耗时的Redis命令是很危险的，会占用唯一的一个线程的大量处理时间，导致所有的请求都被拖慢。（例如时间复杂度为O(N)的KEYS命令，严格禁止在生产环境中使用）</li>
</ul>
<h1 id="Redis的数据结构和相关常用命令"><a href="#Redis的数据结构和相关常用命令" class="headerlink" title="Redis的数据结构和相关常用命令"></a><strong>Redis的数据结构和相关常用命令</strong></h1><p>本节将介绍Redis支持的主要数据结构，以及相关的常用Redis命令</p>
<h2 id="Key"><a href="#Key" class="headerlink" title="Key"></a><strong>Key</strong></h2><p>Redis采用Key-Value型的基本数据结构，任何二进制序列都可以作为Redis的Key使用（例如普通的字符串或一张JPEG图片）<br>关于Key的一些注意事项：</p>
<ul>
<li><strong>不要使用过长的Key</strong>。例如使用一个1024字节的key就不是一个好主意，不仅会消耗更多的内存，还会导致查找的效率降低</li>
<li><strong>Key短到缺失了可读性也是不好的</strong>，例如”u1000flw”比起”user:1000:followers”来说，节省了寥寥的存储空间，却引发了可读性和可维护性上的麻烦</li>
<li><strong>最好使用统一的规范来设计Key</strong>，比如”object-type:id:attr”，以这一规范设计出的Key可能是”user:1000”或”comment:1234:reply-to”</li>
<li><strong>Redis允许的最大Key长度是512MB</strong>（对Value的长度限制也是512MB）</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a><strong>String</strong></h2><p>String是Redis的基础数据类型，Redis没有Int、Float、Boolean等数据类型的概念，所有的基本类型在Redis中都以String体现。<br>与String相关的常用命令：</p>
<ul>
<li><strong>SET</strong>：为一个key设置value，可以配合EX/PX参数指定key的有效期，通过NX/XX参数针对key是否存在的情况进行区别操作，时间复杂度O(1)</li>
<li><strong>GET</strong>：获取某个key对应的value，时间复杂度O(1)</li>
<li><strong>GETSET</strong>：为一个key设置value，并返回该key的原value，时间复杂度O(1)</li>
<li><strong>MSET</strong>：为多个key设置value，时间复杂度O(N)</li>
<li><strong>MSETNX</strong>：同MSET，如果指定的key中有任意一个已存在，则不进行任何操作，时间复杂度O(N)</li>
<li><strong>MGET</strong>：获取多个key对应的value，时间复杂度O(N)</li>
</ul>
<p>上文提到过，Redis的基本数据类型只有String，但Redis可以把String作为整型或浮点型数字来使用，主要体现在INCR、DECR类的命令上：</p>
<ul>
<li><strong>INCR</strong>：将key对应的value值自增1，并返回自增后的值。只对可以转换为整型的String数据起作用。时间复杂度O(1)</li>
<li><strong>INCRBY</strong>：将key对应的value值自增指定的整型数值，并返回自增后的值。只对可以转换为整型的String数据起作用。时间复杂度O(1)</li>
<li><strong>DECR/DECRBY</strong>：同INCR/INCRBY，自增改为自减。</li>
</ul>
<p>INCR/DECR系列命令要求操作的value类型为String，并可以转换为64位带符号的整型数字，否则会返回错误。<br>也就是说，进行INCR/DECR系列命令的value，必须在[-2^63 ~ 2^63 - 1]范围内。<br>前文提到过，Redis采用单线程模型，天然是线程安全的，这使得INCR/DECR命令可以非常便利的实现高并发场景下的精确控制。</p>
<h3 id="例1：库存控制"><a href="#例1：库存控制" class="headerlink" title="例1：库存控制"></a><strong>例1：库存控制</strong></h3><p>在高并发场景下实现库存余量的精准校验，确保不出现超卖的情况。<br>设置库存总量：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> inv:remain <span class="comment">"100"</span></span></pre></td></tr></table></figure>

<p>库存扣减+余量校验：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">DECR</span> <span class="selector-tag">inv</span><span class="selector-pseudo">:remain</span></span></pre></td></tr></table></figure>

<p>当DECR命令返回值大于等于0时，说明库存余量校验通过，如果返回小于0的值，则说明库存已耗尽。<br>假设同时有300个并发请求进行库存扣减，Redis能够确保这300个请求分别得到99到-200的返回值，每个请求得到的返回值都是唯一的，绝对不会找出现两个请求得到一样的返回值的情况。</p>
<h3 id="例2：自增序列生成"><a href="#例2：自增序列生成" class="headerlink" title="例2：自增序列生成"></a><strong>例2：自增序列生成</strong></h3><p>实现类似于RDBMS的Sequence功能，生成一系列唯一的序列号<br>设置序列起始值：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> sequence <span class="comment">"10000"</span></span></pre></td></tr></table></figure>

<p>获取一个序列值：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">INCR sequence</span></span></pre></td></tr></table></figure>

<p>直接将返回值作为序列使用即可。<br>获取一批（如100个）序列值：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">INCRBY sequence <span class="number">100</span></span></pre></td></tr></table></figure>

<p>假设返回值为N，那么[N - 99 ~ N]的数值都是可用的序列值。<br>当多个客户端同时向Redis申请自增序列时，Redis能够确保每个客户端得到的序列值或序列范围都是全局唯一的，绝对不会出现不同客户端得到了重复的序列值的情况。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a><strong>List</strong></h2><p>Redis的List是链表型的数据结构，可以使用LPUSH/RPUSH/LPOP/RPOP等命令在List的两端执行插入元素和弹出元素的操作。<br>虽然List也支持在特定index上插入和读取元素的功能，但其时间复杂度较高（O(N)），应小心使用。<br>与List相关的常用命令：</p>
<ul>
<li><strong>LPUSH</strong>：向指定List的左侧（即头部）插入1个或多个元素，返回插入后的List长度。时间复杂度O(N)，N为插入元素的数量</li>
<li><strong>RPUSH</strong>：同LPUSH，向指定List的右侧（即尾部）插入1或多个元素</li>
<li><strong>LPOP</strong>：从指定List的左侧（即头部）移除一个元素并返回，时间复杂度O(1)</li>
<li><strong>RPOP</strong>：同LPOP，从指定List的右侧（即尾部）移除1个元素并返回</li>
<li><strong>LPUSHX/RPUSHX</strong>：与LPUSH/RPUSH类似，区别在于，LPUSHX/RPUSHX操作的key如果不存在，则不会进行任何操作</li>
<li><strong>LLEN</strong>：返回指定List的长度，时间复杂度O(1)</li>
<li><strong>LRANGE</strong>：返回指定List中指定范围的元素（双端包含，即LRANGE key 0 10会返回11个元素），时间复杂度O(N)。</li>
</ul>
<p>注意：应尽可能控制一次获取的元素数量，一次获取过大范围的List元素会导致延迟，同时对长度不可预知的List，避免使用LRANGE key 0 -1这样的完整遍历操作。</p>
<p>应谨慎使用的List相关命令：</p>
<ul>
<li><strong>LINDEX</strong>：返回指定List指定index上的元素，如果index越界，返回nil。index数值是回环的，即-1代表List最后一个位置，-2代表List倒数第二个位置。时间复杂度O(N)</li>
<li><strong>LSET</strong>：将指定List指定index上的元素设置为value，如果index越界则返回错误，时间复杂度O(N)，如果操作的是头/尾部的元素，则时间复杂度为O(1)</li>
<li><strong>LINSERT</strong>：向指定List中指定元素之前/之后插入一个新元素，并返回操作后的List长度。如果指定的元素不存在，返回-1。如果指定key不存在，不会进行任何操作，时间复杂度O(N)</li>
</ul>
<p>由于Redis的List是链表结构的，上述的三个命令的算法效率较低，需要对List进行遍历，命令的耗时无法预估，在List长度大的情况下耗时会明显增加，应谨慎使用。<br>换句话说，Redis的List实际是设计来用于实现队列，而不是用于实现类似ArrayList这样的列表的。<br>如果你不是想要实现一个双端出入的队列，那么请尽量不要使用Redis的List数据结构。<br>为了更好支持队列的特性，Redis还提供了一系列阻塞式的操作命令，如BLPOP/BRPOP等，能够实现类似于BlockingQueue的能力，即在List为空时，阻塞该连接，直到List中有对象可以出队时再返回。</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a><strong>Hash</strong></h2><p>Hash即哈希表，Redis的Hash和传统的哈希表一样，是一种field-value型的数据结构，可以理解成将HashMap搬入Redis。<br>Hash非常适合用于表现对象类型的数据，用Hash中的field对应对象的field即可。<br>Hash的优点包括：</p>
<ul>
<li>可以实现二元查找，如”查找ID为1000的用户的年龄”</li>
<li>比起将整个对象序列化后作为String存储的方法，Hash能够有效地减少网络传输的消耗</li>
<li>当使用Hash维护一个集合时，提供了比List效率高得多的随机访问命令</li>
</ul>
<p>与Hash相关的常用命令：</p>
<ul>
<li><p><strong>HSET</strong>：将key对应的Hash中的field设置为value。如果该Hash不存在，会自动创建一个。时间复杂度O(1)</p>
</li>
<li><p><strong>HGET</strong>：返回指定Hash中field字段的值，时间复杂度O(1)</p>
</li>
<li><p><strong>HMSET/HMGET</strong>：同HSET和HGET，可以批量操作同一个key下的多个field，时间复杂度：O(N)，N为一次操作的field数量</p>
</li>
<li><p><strong>HSETNX</strong>：同HSET，但如field已经存在，HSETNX不会进行任何操作，时间复杂度O(1)</p>
</li>
<li><p><strong>HEXISTS</strong>：判断指定Hash中field是否存在，存在返回1，不存在返回0，时间复杂度O(1)</p>
</li>
<li><p><strong>HDEL</strong>：删除指定Hash中的field（1个或多个），时间复杂度：O(N)，N为操作的field数量</p>
</li>
<li><p><strong>HINCRBY</strong>：同INCRBY命令，对指定Hash中的一个field进行INCRBY，时间复杂度O(1)</p>
</li>
</ul>
<p>应谨慎使用的Hash相关命令：</p>
<ul>
<li><strong>HGETALL</strong>：返回指定Hash中所有的field-value对。返回结果为数组，数组中field和value交替出现。时间复杂度O(N)</li>
<li><strong>HKEYS/HVALS</strong>：返回指定Hash中所有的field/value，时间复杂度O(N)</li>
</ul>
<p>上述三个命令都会对Hash进行完整遍历，Hash中的field数量与命令的耗时线性相关<br>对于尺寸不可预知的Hash，应严格避免使用上面三个命令，而改为使用HSCAN命令进行游标式的遍历</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a><strong>Set</strong></h2><p>Redis Set是无序的，不可重复的String集合。<br>与Set相关的常用命令：</p>
<ul>
<li><strong>SADD</strong>：向指定Set中添加1个或多个member，如果指定Set不存在，会自动创建一个。时间复杂度O(N)，N为添加的member个数</li>
<li><strong>SREM</strong>：从指定Set中移除1个或多个member，时间复杂度O(N)，N为移除的member个数</li>
<li><strong>SRANDMEMBER</strong>：从指定Set中随机返回1个或多个member，时间复杂度O(N)，N为返回的member个数</li>
<li><strong>SPOP</strong>：从指定Set中随机移除并返回count个member，时间复杂度O(N)，N为移除的member个数</li>
<li><strong>SCARD</strong>：返回指定Set中的member个数，时间复杂度O(1)</li>
<li><strong>SISMEMBER</strong>：判断指定的value是否存在于指定Set中，时间复杂度O(1)</li>
<li><strong>SMOVE</strong>：将指定member从一个Set移至另一个Set</li>
</ul>
<p>慎用的Set相关命令：</p>
<ul>
<li><strong>SMEMBERS</strong>：返回指定Hash中所有的member，时间复杂度O(N)</li>
<li><strong>SUNION/SUNIONSTORE</strong>：计算多个Set的并集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数</li>
<li><strong>SINTER/SINTERSTORE</strong>：计算多个Set的交集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数</li>
<li><strong>SDIFF/SDIFFSTORE</strong>：计算1个Set与1或多个Set的差集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数</li>
</ul>
<p>上述几个命令涉及的计算量大，应谨慎使用，特别是在参与计算的Set尺寸不可知的情况下，应严格避免使用。</p>
<h2 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a><strong>Sorted Set</strong></h2><p>Redis Sorted Set是有序的、不可重复的String集合。<br>Sorted Set中的每个元素都需要指派一个分数(score)，Sorted Set会根据score对元素进行升序排序。<br>如果多个member拥有相同的score，则以字典序进行升序排序。Sorted Set非常适合用于实现排名。<br>Sorted Set的主要命令：</p>
<ul>
<li><strong>ZADD</strong>：向指定Sorted Set中添加1个或多个member，时间复杂度O(Mlog(N))，M为添加的member数量，N为Sorted Set中的member数量</li>
<li><strong>ZREM</strong>：从指定Sorted Set中删除1个或多个member，时间复杂度O(Mlog(N))，M为删除的member数量，N为Sorted Set中的member数量</li>
<li><strong>ZCOUNT</strong>：返回指定Sorted Set中指定score范围内的member数量，时间复杂度：O(log(N))</li>
<li><strong>ZCARD</strong>：返回指定Sorted Set中的member数量，时间复杂度O(1)</li>
<li><strong>ZSCORE</strong>：返回指定Sorted Set中指定member的score，时间复杂度O(1)</li>
<li><strong>ZRANK/ZREVRANK</strong>：返回指定member在Sorted Set中的排名，ZRANK返回按升序排序的排名，ZREVRANK则返回按降序排序的排名。时间复杂度O(log(N))</li>
<li><strong>ZINCRBY</strong>：同INCRBY，对指定Sorted Set中的指定member的score进行自增，时间复杂度O(log(N))</li>
</ul>
<p>慎用的Sorted Set相关命令：</p>
<ul>
<li><strong>ZRANGE/ZREVRANGE</strong>：返回指定Sorted Set中指定排名范围内的所有member，ZRANGE为按score升序排序，ZREVRANGE为按score降序排序，时间复杂度O(log(N)+M)，M为本次返回的member数</li>
<li><strong>ZRANGEBYSCORE/ZREVRANGEBYSCORE</strong>：返回指定Sorted Set中指定score范围内的所有member，返回结果以升序/降序排序，min和max可以指定为-inf和+inf，代表返回所有的member。时间复杂度O(log(N)+M)</li>
<li><strong>ZREMRANGEBYRANK/ZREMRANGEBYSCORE</strong>：移除Sorted Set中指定排名范围/指定score范围内的所有member。时间复杂度O(log(N)+M)</li>
</ul>
<p>上述几个命令，应尽量避免传递[0 -1]或[-inf +inf]这样的参数，来对Sorted Set做一次性的完整遍历，特别是在Sorted Set的尺寸不可预知的情况下。</p>
<h2 id="Bitmap和HyperLogLog"><a href="#Bitmap和HyperLogLog" class="headerlink" title="Bitmap和HyperLogLog"></a><strong>Bitmap和HyperLogLog</strong></h2><p>Redis的这两种数据结构相较之前的并不常用，在本文中只做简要介绍<br>Bitmap在Redis中不是一种实际的数据类型，而是一种将String作为Bitmap使用的方法。<br>可以理解为将String转换为bit数组。使用Bitmap来存储true/false类型的简单数据极为节省空间。<br>HyperLogLogs是一种主要用于数量统计的数据结构，它和Set类似，维护一个不可重复的String集合<br>但是HyperLogLogs并不维护具体的member内容，只维护member的个数。<br>也就是说，HyperLogLogs只能用于计算一个集合中不重复的元素数量，所以它比Set要节省很多内存空间。</p>
<h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a><strong>其他常用命令</strong></h2><ul>
<li><strong>EXISTS</strong>：判断指定的key是否存在，返回1代表存在，0代表不存在，时间复杂度O(1)</li>
<li><strong>DEL</strong>：删除指定的key及其对应的value，时间复杂度O(N)，N为删除的key数量</li>
<li><strong>EXPIRE/PEXPIRE</strong>：为一个key设置有效期，单位为秒或毫秒，时间复杂度O(1)</li>
<li><strong>TTL/PTTL</strong>：返回一个key剩余的有效时间，单位为秒或毫秒，时间复杂度O(1)</li>
<li><strong>RENAME/RENAMENX</strong>：将key重命名为newkey。使用RENAME时，如果newkey已经存在，其值会被覆盖；使用RENAMENX时，如果newkey已经存在，则不会进行任何操作，时间复杂度O(1)</li>
<li><strong>TYPE</strong>：返回指定key的类型，string, list, set, zset, hash。时间复杂度O(1)</li>
<li><strong>CONFIG GET</strong>：获得Redis某配置项的当前值，可以使用*通配符，时间复杂度O(1)</li>
<li><strong>CONFIG SET</strong>：为Redis某个配置项设置新值，时间复杂度O(1)</li>
<li><strong>CONFIG REWRITE</strong>：让Redis重新加载redis.conf中的配置</li>
</ul>
<h1 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a><strong>数据持久化</strong></h1><p>Redis提供了将数据定期自动持久化至硬盘的能力，包括RDB和AOF两种方案。<br>两种方案分别有其长处和短板，可以配合起来同时运行，确保数据的稳定性。</p>
<h2 id="必须使用数据持久化吗？"><a href="#必须使用数据持久化吗？" class="headerlink" title="必须使用数据持久化吗？"></a><strong>必须使用数据持久化吗？</strong></h2><p>Redis的数据持久化机制是可以关闭的，如果你只把Redis作为缓存服务使用，Redis中存储的所有数据都不是该数据的主体而仅仅是同步过来的备份，那么可以关闭Redis的数据持久化机制。<br>但通常来说，仍然建议至少开启RDB方式的数据持久化，因为：</p>
<ul>
<li>RDB方式的持久化几乎不损耗Redis本身的性能，在进行RDB持久化时，Redis主进程唯一需要做的事情就是fork出一个子进程，所有持久化工作都由子进程完成</li>
<li>Redis无论因为什么原因crash掉之后，重启时能够自动恢复到上一次RDB快照中记录的数据。这省去了手工从其他数据源（如DB）同步数据的过程，而且要比其他任何的数据恢复方式都要快</li>
<li>现在硬盘那么大，真的不缺那一点地方</li>
</ul>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a><strong>RDB</strong></h2><p>采用RDB持久方式，Redis会定期保存数据快照至一个rbd文件中，并在启动时自动加载rdb文件，恢复之前保存的数据。<br>可以在配置文件中配置Redis进行快照保存的时机：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">save</span> <span class="selector-attr">[seconds]</span> <span class="selector-attr">[changes]</span></span></pre></td></tr></table></figure>

<p>意为在[seconds]秒内如果发生了[changes]次数据修改，则进行一次RDB快照保存，例如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">save <span class="number">60</span> <span class="number">100</span></span></pre></td></tr></table></figure>

<p>会让Redis每60秒检查一次数据变更情况，如果发生了100次或以上的数据变更，则进行RDB快照保存。<br>可以配置多条save指令，让Redis执行多级的快照保存策略。<br>Redis默认开启RDB快照，默认的RDB策略如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span>s</span></pre></td></tr><tr><td class="code"><pre><span class="line">save <span class="number">300</span> <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">save <span class="number">60</span> <span class="number">10000</span></span></pre></td></tr></table></figure>

<p>也可以通过<strong>BGSAVE</strong>命令手工触发RDB快照保存。<br><strong>RDB的优点：</strong></p>
<ul>
<li>对性能影响最小。如前文所述，Redis在保存RDB快照时会fork出子进程进行，几乎不影响Redis处理客户端请求的效率。</li>
<li>每次快照会生成一个完整的数据快照文件，所以可以辅以其他手段保存多个时间点的快照（例如把每天0点的快照备份至其他存储媒介中），作为非常可靠的灾难恢复手段。</li>
<li>使用RDB文件进行数据恢复比使用AOF要快很多。</li>
</ul>
<p><strong>RDB的缺点：</strong></p>
<ul>
<li>快照是定期生成的，所以在Redis crash时或多或少会丢失一部分数据。</li>
<li>如果数据集非常大且CPU不够强（比如单核CPU），Redis在fork子进程时可能会消耗相对较长的时间（长至1秒），影响这期间的客户端请求。</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a><strong>AOF</strong></h2><p>采用AOF持久方式时，Redis会把每一个写请求都记录在一个日志文件里。<br>在Redis重启时，会把AOF文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。<br>AOF默认是关闭的，如要开启，进行如下配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">appendonly</span> <span class="literal">yes</span></span></pre></td></tr></table></figure>

<p>AOF提供了三种fsync配置，always/everysec/no，通过配置项[appendfsync]指定：</p>
<ul>
<li><strong>appendfsync no</strong>：不进行fsync，将flush文件的时机交给OS决定，速度最快</li>
<li><strong>appendfsync always</strong>：每写入一条日志就进行一次fsync操作，数据安全性最高，但速度最慢</li>
<li><strong>appendfsync everysec</strong>：折中的做法，交由后台线程每秒fsync一次</li>
</ul>
<p>随着AOF不断地记录写操作日志，必定会出现一些无用的日志<br>例如某个时间点执行了命令<strong>SET key1 “abc”</strong>，在之后某个时间点又执行了<strong>SET key1 “bcd”</strong>，那么第一条命令很显然是没有用的。<br>大量的无用日志会让AOF文件过大，也会让数据恢复的时间过长。<br>所以Redis提供了AOF rewrite功能，可以重写AOF文件，只保留能够把数据恢复到最新状态的最小写操作集。<br>AOF rewrite可以通过<strong>BGREWRITEAOF</strong>命令触发，也可以配置Redis定期自动进行：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">auto</span>-aof-rewrite-percentage <span class="number">100</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">auto</span>-aof-rewrite-min-size <span class="number">64</span>mb</span></pre></td></tr></table></figure>

<p>上面两行配置的含义是，Redis在每次AOF rewrite时，会记录完成rewrite后的AOF日志大小，当AOF日志大小在该基础上增长了100%后，自动进行AOF rewrite。同时如果增长的大小没有达到64mb，则不会进行rewrite。<br><strong>AOF的优点：</strong></p>
<ul>
<li>最安全，在启用appendfsync always时，任何已写入的数据都不会丢失，使用在启用appendfsync everysec也至多只会丢失1秒的数据。</li>
<li>AOF文件在发生断电等问题时也不会损坏，即使出现了某条日志只写入了一半的情况，也可以使用redis-check-aof工具轻松修复。</li>
<li>AOF文件易读，可修改，在进行了某些错误的数据清除操作后，只要AOF文件没有rewrite，就可以把AOF文件备份出来，把错误的命令删除，然后恢复数据。</li>
</ul>
<p><strong>AOF的缺点：</strong></p>
<ul>
<li>AOF文件通常比RDB文件更大</li>
<li>性能消耗比RDB高</li>
<li>数据恢复速度比RDB慢</li>
</ul>
<h1 id="内存管理与数据淘汰机制"><a href="#内存管理与数据淘汰机制" class="headerlink" title="内存管理与数据淘汰机制"></a><strong>内存管理与数据淘汰机制</strong></h1><h2 id="最大内存设置"><a href="#最大内存设置" class="headerlink" title="最大内存设置"></a><strong>最大内存设置</strong></h2><p>默认情况下，在32位OS中，Redis最大使用3GB的内存，在64位OS中则没有限制。<br>在使用Redis时，应该对数据占用的最大空间有一个基本准确的预估，并为Redis设定最大使用的内存。<br>否则在64位OS中Redis会无限制地占用内存（当物理内存被占满后会使用swap空间），容易引发各种各样的问题。<br>通过如下配置控制Redis使用的最大内存：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">maxmemory <span class="number">100</span>mb</span></pre></td></tr></table></figure>

<p>在内存占用达到了maxmemory后，再向Redis写入数据时，Redis会：</p>
<ul>
<li>根据配置的数据淘汰策略尝试淘汰数据，释放空间</li>
<li>如果没有数据可以淘汰，或者没有配置数据淘汰策略，那么Redis会对所有写请求返回错误，但读请求仍然可以正常执行</li>
</ul>
<p>在为Redis设置maxmemory时，需要注意：</p>
<p>如果采用了Redis的主从同步，主节点向从节点同步数据时，会占用掉一部分内存空间</p>
<p>如果maxmemory过于接近主机的可用内存，会导致数据同步时内存不足。</p>
<p>所以设置的maxmemory不要过于接近主机可用的内存，留出一部分预留用作主从同步。</p>
<h2 id="数据淘汰机制"><a href="#数据淘汰机制" class="headerlink" title="数据淘汰机制"></a><strong>数据淘汰机制</strong></h2><p>Redis提供了5种数据淘汰策略：</p>
<ul>
<li><strong>volatile-lru</strong>：使用LRU算法进行数据淘汰（淘汰上次使用时间最早的，且使用次数最少的key），只淘汰设定了有效期的key</li>
<li><strong>allkeys-lru</strong>：使用LRU算法进行数据淘汰，所有的key都可以被淘汰</li>
<li><strong>volatile-random</strong>：随机淘汰数据，只淘汰设定了有效期的key</li>
<li><strong>allkeys-random</strong>：随机淘汰数据，所有的key都可以被淘汰</li>
<li><strong>volatile-ttl</strong>：淘汰剩余有效期最短的key</li>
</ul>
<p>最好为Redis指定一种有效的数据淘汰策略以配合maxmemory设置，避免在内存使用满后发生写入失败的情况。<br>一般来说，推荐使用的策略是volatile-lru，并辨识Redis中保存的数据的重要性。<br>对于那些重要的，绝对不能丢弃的数据（如配置类数据等），应不设置有效期，这样Redis就永远不会淘汰这些数据。<br>对于那些相对不是那么重要的，并且能够热加载的数据（比如缓存最近登录的用户信息，当在Redis中找不到时，程序会去DB中读取），可以设置上有效期，这样在内存不够时Redis就会淘汰这部分数据。<br>配置方法：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">maxmemory-policy <span class="keyword">volatile</span>-lru <span class="meta">#默认是noeviction，即不进行数据淘汰</span></span></pre></td></tr></table></figure>

<h2 id="Pipelining"><a href="#Pipelining" class="headerlink" title="Pipelining"></a><strong>Pipelining</strong></h2><p>Redis提供许多批量操作的命令，如MSET/MGET/HMSET/HMGET等等，这些命令存在的意义是减少维护网络连接和传输数据所消耗的资源和时间。<br>例如连续使用5次SET命令设置5个不同的key，比起使用一次MSET命令设置5个不同的key，效果是一样的<br>但前者会消耗更多的RTT(Round Trip Time)时长，永远应优先使用后者。<br>然而，如果客户端要连续执行的多次操作无法通过Redis命令组合在一起，例如：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> a <span class="comment">"abc"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">INCR <span class="comment">b</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HSET <span class="comment">c name</span> <span class="comment">"hi"</span></span></pre></td></tr></table></figure>

<p>此时便可以使用Redis提供的pipelining功能来实现在一次交互中执行多条命令。<br>使用pipelining时，只需要从客户端一次向Redis发送多条命令（以\r\n）分隔，Redis就会依次执行这些命令，并且把每个命令的返回按顺序组装在一起一次返回，比如：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">$ (printf <span class="string">"PING\r<span class="subst">\n</span>PING\r<span class="subst">\n</span>PING\r<span class="subst">\n</span>"</span>; sleep <span class="number">1</span>) | nc localhost <span class="number">6379</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+PONG</span></pre></td></tr><tr><td class="code"><pre><span class="line">+PONG</span></pre></td></tr><tr><td class="code"><pre><span class="line">+PONG</span></pre></td></tr></table></figure>

<p>大部分的Redis客户端都对Pipelining提供支持，所以开发者通常并不需要自己手工拼装命令列表。</p>
<h3 id="Pipelining的局限性"><a href="#Pipelining的局限性" class="headerlink" title="Pipelining的局限性"></a><strong>Pipelining的局限性</strong></h3><p>Pipelining只能用于执行<strong>连续且无相关性</strong>的命令，当某个命令的生成需要依赖于前一个命令的返回时，就无法使用Pipelining了。<br>通过Scripting功能，可以规避这一局限性</p>
<h2 id="事务与Scripting"><a href="#事务与Scripting" class="headerlink" title="事务与Scripting"></a><strong>事务与Scripting</strong></h2><p>Pipelining能够让Redis在一次交互中处理多条命令，然而在一些场景下，我们可能需要在此基础上确保这一组命令是连续执行的。<br>比如获取当前累计的PV数并将其清0</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt; <span class="builtin-name">GET</span> vCount</span></pre></td></tr><tr><td class="code"><pre><span class="line">12384</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; <span class="builtin-name">SET</span> vCount 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">OK</span></pre></td></tr></table></figure>

<p>如果在GET和SET命令之间插进来一个INCR vCount，就会使客户端拿到的vCount不准确。<br>Redis的事务可以确保复数命令执行时的原子性。<br>也就是说Redis能够保证：一个事务中的一组命令是绝对连续执行的，在这些命令执行完成之前，绝对不会有来自于其他连接的其他命令插进去执行。<br>通过MULTI和EXEC命令来把这两个命令加入一个事务中：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt; MULTI</span></pre></td></tr><tr><td class="code"><pre><span class="line">OK</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; GET vCount</span></pre></td></tr><tr><td class="code"><pre><span class="line">QUEUED</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; SET vCount <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">QUEUED</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; EXEC</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="number">12384</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span>) OK</span></pre></td></tr></table></figure>

<p>Redis在接收到MULTI命令后便会开启一个事务，这之后的所有读写命令都会保存在队列中但并不执行<br>直到接收到EXEC命令后，Redis会把队列中的所有命令连续顺序执行，并以数组形式返回每个命令的返回结果。<br>可以使用DISCARD命令放弃当前的事务，将保存的命令队列清空。<br>需要注意的是，<strong>Redis事务不支持回滚</strong>：如果一个事务中的命令出现了语法错误，大部分客户端驱动会返回错误<br>2.6.5版本以上的Redis也会在执行EXEC时检查队列中的命令是否存在语法错误，如果存在，则会自动放弃事务并返回错误。<br>但如果一个事务中的命令有非语法类的错误（比如对String执行HSET操作），无论客户端驱动还是Redis都无法在真正执行这条命令之前发现，所以事务中的所有命令仍然会被依次执行。<br>在这种情况下，会出现一个事务中部分命令成功部分命令失败的情况，然而与RDBMS不同，Redis不提供事务回滚的功能，所以只能通过其他方法进行数据的回滚。</p>
<h2 id="通过事务实现CAS"><a href="#通过事务实现CAS" class="headerlink" title="通过事务实现CAS"></a><strong>通过事务实现CAS</strong></h2><p>Redis提供了WATCH命令与事务搭配使用，实现CAS乐观锁的机制。<br>假设要实现将某个商品的状态改为已售：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">if(exec(HGET stock:<span class="number">1001</span> <span class="keyword">state</span>) == <span class="string">"in stock"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    exec(HSET stock:<span class="number">1001</span> <span class="keyword">state</span> <span class="string">"sold"</span>);</span></pre></td></tr></table></figure>

<p>这一伪代码执行时，无法确保并发安全性，有可能多个客户端都获取到了”in stock”的状态，导致一个库存被售卖多次。<br>使用WATCH命令和事务可以解决这一问题：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">exec(WATCH stock:<span class="number">1001</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">if(exec(HGET stock:<span class="number">1001</span> <span class="keyword">state</span>) == <span class="string">"in stock"</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    exec(MULTI);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    exec(HSET stock:<span class="number">1001</span> <span class="keyword">state</span> <span class="string">"sold"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    exec(EXEC);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>WATCH的机制是</strong>：在事务EXEC命令执行时，Redis会检查被WATCH的key，只有被WATCH的key从WATCH起始时至今没有发生过变更，EXEC才会被执行。<br>如果WATCH的key在WATCH命令到EXEC命令之间发生过变化，则EXEC命令会返回失败。</p>
<h2 id="Scripting"><a href="#Scripting" class="headerlink" title="Scripting"></a><strong>Scripting</strong></h2><p>通过EVAL与EVALSHA命令，可以让Redis执行LUA脚本。这就类似于RDBMS的存储过程一样，可以把客户端与Redis之间密集的读/写交互放在服务端进行，避免过多的数据交互，提升性能。<br>Scripting功能是作为事务功能的替代者诞生的，事务提供的所有能力Scripting都可以做到。Redis官方推荐使用LUA Script来代替事务，前者的效率和便利性都超过了事务。<br>关于Scripting的具体使用，本文不做详细介绍，请参考官方文档 <a href="https://redis.io/commands/eval" target="_blank" rel="noopener">https://redis.io/commands/eval</a></p>
<h1 id="Redis性能调优"><a href="#Redis性能调优" class="headerlink" title="Redis性能调优"></a><strong>Redis性能调优</strong></h1><p>尽管Redis是一个非常快速的内存数据存储媒介，也并不代表Redis不会产生性能问题。<br>前文中提到过，Redis采用单线程模型，所有的命令都是由一个线程串行执行的<br>所以当某个命令执行耗时较长时，会拖慢其后的所有命令，这使得Redis对每个任务的执行效率更加敏感。<br>针对Redis的性能优化，主要从下面几个层面入手：</p>
<ul>
<li>最初的也是最重要的，确保没有让Redis执行耗时长的命令</li>
<li>使用pipelining将连续执行的命令组合执行</li>
<li>操作系统的Transparent huge pages功能必须关闭：</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">echo never &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/mm/</span>transparent_hugepage<span class="regexp">/enabled</span></span></pre></td></tr></table></figure>

<ul>
<li>如果在虚拟机中运行Redis，可能天然就有虚拟机环境带来的固有延迟。</li>
<li>可以通过./redis-cli –intrinsic-latency 100命令查看固有延迟。同时如果对Redis的性能有较高要求的话，应尽可能在物理机上直接部署Redis。</li>
<li>检查数据持久化策略</li>
<li>考虑引入读写分离机制</li>
</ul>
<h2 id="长耗时命令"><a href="#长耗时命令" class="headerlink" title="长耗时命令"></a><strong>长耗时命令</strong></h2><p>Redis绝大多数读写命令的时间复杂度都在O(1)到O(N)之间，在本文和官方文档中均对每个命令的时间复杂度有说明。<br>通常来说，O(1)的命令是安全的，O(N)命令在使用时需要注意，如果N的数量级不可预知，则应避免使用。<br>例如对一个field数未知的Hash数据执行HGETALL/HKEYS/HVALS命令，通常来说这些命令执行的很快，但如果这个Hash中的field数量极多，耗时就会成倍增长。<br>又如使用SUNION对两个Set执行Union操作，或使用SORT对List/Set执行排序操作等时，都应该严加注意。<br>避免在使用这些O(N)命令时发生问题主要有几个办法：</p>
<ul>
<li>不要把List当做列表使用，仅当做队列来使用</li>
<li>通过机制严格控制Hash、Set、Sorted Set的大小</li>
<li>可能的话，将排序、并集、交集等操作放在客户端执行</li>
<li>绝对禁止使用KEYS命令</li>
<li>避免一次性遍历集合类型的所有成员，而应使用SCAN类的命令进行分批的，游标式的遍历</li>
</ul>
<p>Redis提供了SCAN命令，可以对Redis中存储的所有key进行游标式的遍历，避免使用KEYS命令带来的性能问题。<br>同时还有SSCAN/HSCAN/ZSCAN等命令，分别用于对Set/Hash/Sorted Set中的元素进行游标式遍历。<br>SCAN类命令的使用请参考官方文档：<br><a href="https://redis.io/commands/scan" target="_blank" rel="noopener">https://redis.io/commands/scan</a><br>Redis提供了Slow Log功能，可以自动记录耗时较长的命令。相关的配置参数有两个：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">slowlog-<span class="built_in">log</span>-slower-than xxxms #执行时间慢于xxx毫秒的命令计入Slow <span class="built_in">Log</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">slowlog-<span class="built_in">max</span>-<span class="built_in">len</span> xxx #Slow <span class="built_in">Log</span>的长度，即最大纪录多少条Slow <span class="built_in">Log</span></span></pre></td></tr></table></figure>

<p>使用<strong>SLOWLOG GET [number]</strong>命令，可以输出最近进入Slow Log的number条命令。<br>使用<strong>SLOWLOG RESET</strong>命令，可以重置Slow Log</p>
<h2 id="网络引发的延迟"><a href="#网络引发的延迟" class="headerlink" title="网络引发的延迟"></a><strong>网络引发的延迟</strong></h2><ul>
<li>尽可能使用长连接或连接池，避免频繁创建销毁连接</li>
<li>客户端进行的批量数据操作，应使用Pipeline特性在一次交互中完成。具体请参照本文的Pipelining章节</li>
</ul>
<h2 id="数据持久化引发的延迟"><a href="#数据持久化引发的延迟" class="headerlink" title="数据持久化引发的延迟"></a><strong>数据持久化引发的延迟</strong></h2><p>Redis的数据持久化工作本身就会带来延迟，需要根据数据的安全级别和性能要求制定合理的持久化策略：</p>
<ul>
<li>AOF + fsync always的设置虽然能够绝对确保数据安全，但每个操作都会触发一次fsync，会对Redis的性能有比较明显的影响。</li>
<li>AOF + fsync every second是比较好的折中方案，每秒fsync一次</li>
<li>AOF + fsync never会提供AOF持久化方案下的最优性能</li>
<li>使用RDB持久化通常会提供比使用AOF更高的性能，但需要注意RDB的策略配置</li>
<li>每一次RDB快照和AOF Rewrite都需要Redis主进程进行fork操作。fork操作本身可能会产生较高的耗时，与CPU和Redis占用的内存大小有关。根据具体的情况合理配置RDB快照和AOF Rewrite时机，避免过于频繁的fork带来的延迟</li>
</ul>
<blockquote>
<p>Redis在fork子进程时需要将内存分页表拷贝至子进程以占用了24GB内存的Redis实例为例，共需要拷贝24GB / 4kB * 8 = 48MB的数据。在使用单Xeon 2.27Ghz的物理机上，这一fork操作耗时216ms。可以通过<strong>INFO</strong>命令返回的latest_fork_usec字段查看上一次fork操作的耗时（微秒）</p>
</blockquote>
<h2 id="Swap引发的延迟"><a href="#Swap引发的延迟" class="headerlink" title="Swap引发的延迟"></a><strong>Swap引发的延迟</strong></h2><p>当Linux将Redis所用的内存分页移至swap空间时，将会阻塞Redis进程，导致Redis出现不正常的延迟。<br>Swap通常在物理内存不足或一些进程在进行大量I/O操作时发生，应尽可能避免上述两种情况的出现。<br>/proc//smaps文件中会保存进程的swap记录，通过查看这个文件，能够判断Redis的延迟是否由Swap产生。<br>如果这个文件中记录了较大的Swap size，则说明延迟很有可能是Swap造成的。</p>
<h2 id="数据淘汰引发的延迟"><a href="#数据淘汰引发的延迟" class="headerlink" title="数据淘汰引发的延迟"></a><strong>数据淘汰引发的延迟</strong></h2><p>当同一秒内有大量key过期时，也会引发Redis的延迟。在使用时应尽量将key的失效时间错开。</p>
<h2 id="引入读写分离机制"><a href="#引入读写分离机制" class="headerlink" title="引入读写分离机制"></a><strong>引入读写分离机制</strong></h2><p>Redis的主从复制能力可以实现一主多从的多节点架构，在这一架构下，主节点接收所有写请求，并将数据同步给多个从节点。<br>在这一基础上，我们可以让从节点提供对实时性要求不高的读请求服务，以减小主节点的压力。<br>尤其是针对一些使用了长耗时命令的统计类任务，完全可以指定在一个或多个从节点上执行，避免这些长耗时命令影响其他请求的响应。</p>
<h1 id="主从复制与集群分片"><a href="#主从复制与集群分片" class="headerlink" title="主从复制与集群分片"></a><strong>主从复制与集群分片</strong></h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a><strong>主从复制</strong></h2><p>Redis支持一主多从的主从复制架构。一个Master实例负责处理所有的写请求，Master将写操作同步至所有Slave。<br>借助Redis的主从复制，可以实现读写分离和高可用：</p>
<ul>
<li>实时性要求不是特别高的读请求，可以在Slave上完成，提升效率。特别是一些周期性执行的统计任务，这些任务可能需要执行一些长耗时的Redis命令，可以专门规划出1个或几个Slave用于服务这些统计任务</li>
<li>借助Redis Sentinel可以实现高可用，当Master crash后，Redis Sentinel能够自动将一个Slave晋升为Master，继续提供服务</li>
</ul>
<p>启用主从复制非常简单，只需要配置多个Redis实例，在作为Slave的Redis实例中配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">slaveof</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> <span class="number">6379</span> <span class="comment">#指定Master的IP和端口</span></span></pre></td></tr></table></figure>

<p>当Slave启动后，会从Master进行一次冷启动数据同步<br>由Master触发BGSAVE生成RDB文件推送给Slave进行导入，导入完成后Master再将增量数据通过Redis Protocol同步给Slave<br>之后主从之间的数据便一直以Redis Protocol进行同步</p>
<h2 id="使用Sentinel做自动failover"><a href="#使用Sentinel做自动failover" class="headerlink" title="使用Sentinel做自动failover"></a><strong>使用Sentinel做自动failover</strong></h2><p>Redis的主从复制功能本身只是做数据同步，并不提供监控和自动failover能力<br>要通过主从复制功能来实现Redis的高可用，还需要引入一个组件：Redis Sentinel<br>Redis Sentinel是Redis官方开发的监控组件，可以监控Redis实例的状态，通过Master节点自动发现Slave节点，并在监测到Master节点失效时选举出一个新的Master，并向所有Redis实例推送新的主从配置。<br>Redis Sentinel需要至少部署3个实例才能形成选举关系。<br>关键配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">sentinel</span> <span class="string">monitor</span> <span class="string">mymaster</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> <span class="number">2</span> <span class="comment">#Master实例的IP、端口，以及选举需要的赞成票数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">sentinel</span> <span class="string">down-after-milliseconds</span> <span class="string">mymaster</span> <span class="number">60000</span> <span class="comment">#多长时间没有响应视为Master失效</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">sentinel</span> <span class="string">failover-timeout</span> <span class="string">mymaster</span> <span class="number">180000</span> <span class="comment">#两次failover尝试间的间隔时长</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">sentinel</span> <span class="string">parallel-syncs</span> <span class="string">mymaster</span> <span class="number">1</span> <span class="comment">#如果有多个Slave，可以通过此配置指定同时从新Master进行数据同步的Slave数，避免所有Slave同时进行数据同步导致查询服务也不可用</span></span></pre></td></tr></table></figure>

<p>另外需要注意的是，Redis Sentinel实现的自动failover不是在同一个IP和端口上完成的<br>也就是说自动failover产生的新Master提供服务的IP和端口与之前的Master是不一样的，所以要实现HA，还要求客户端必须支持Sentinel，能够与Sentinel交互获得新Master的信息才行。</p>
<h2 id="集群分片"><a href="#集群分片" class="headerlink" title="集群分片"></a><strong>集群分片</strong></h2><p>为何要做集群分片：</p>
<ul>
<li>Redis中存储的数据量大，一台主机的物理内存已经无法容纳</li>
<li>Redis的写请求并发量大，一个Redis实例以无法承载</li>
</ul>
<p>当上述两个问题出现时，就必须要对Redis进行分片了。<br>Redis的分片方案有很多种，例如很多Redis的客户端都自行实现了分片功能，也有像Twemproxy这样的以代理方式实现的Redis分片方案。<br>然而首选的方案还应该是Redis官方在3.0版本中推出的Redis Cluster分片方案。<br>本文不会对Redis Cluster的具体安装和部署细节进行介绍，重点介绍Redis Cluster带来的好处与弊端。</p>
<h3 id="Redis-Cluster的能力"><a href="#Redis-Cluster的能力" class="headerlink" title="Redis Cluster的能力"></a><strong>Redis Cluster的能力</strong></h3><ul>
<li>能够自动将数据分散在多个节点上</li>
<li>当访问的key不在当前分片上时，能够自动将请求转发至正确的分片</li>
<li>当集群中部分节点失效时仍能提供服务</li>
</ul>
<p>其中第三点是基于主从复制来实现的，Redis Cluster的每个数据分片都采用了主从复制的结构，原理和前文所述的主从复制完全一致<br>唯一的区别是省去了Redis Sentinel这一额外的组件，由Redis Cluster负责进行一个分片内部的节点监控和自动failover。</p>
<h3 id="Redis-Cluster分片原理"><a href="#Redis-Cluster分片原理" class="headerlink" title="Redis Cluster分片原理"></a><strong>Redis Cluster分片原理</strong></h3><p>Redis Cluster中共有16384个hash slot，Redis会计算每个key的CRC16，将结果与16384取模，来决定该key存储在哪一个hash slot中，<br>同时需要指定Redis Cluster中每个数据分片负责的Slot数，Slot的分配在任何时间点都可以进行重新分配。<br>客户端在对key进行读写操作时，可以连接Cluster中的任意一个分片，如果操作的key不在此分片负责的Slot范围内，Redis Cluster会自动将请求重定向到正确的分片上。</p>
<h3 id="hash-tags"><a href="#hash-tags" class="headerlink" title="hash tags"></a><strong>hash tags</strong></h3><p>在基础的分片原则上，Redis还支持hash tags功能，以hash tags要求的格式明明的key，将会确保进入同一个Slot中。<br>例如：{uiv}user:1000和{uiv}user:1001拥有同样的hash tag {uiv}，会保存在同一个Slot中。<br>使用Redis Cluster时，pipelining、事务和LUA Script功能涉及的key必须在同一个数据分片上，否则将会返回错误。<br>如要在Redis Cluster中使用上述功能，就必须通过hash tags来确保一个pipeline或一个事务中操作的所有key都位于同一个Slot中。</p>
<blockquote>
<p>有一些客户端（如Redisson）实现了集群化的pipelining操作，可以自动将一个pipeline里的命令按key所在的分片进行分组，分别发到不同的分片上执行。但是Redis不支持跨分片的事务，事务和LUA Script还是必须遵循所有key在一个分片上的规则要求。</p>
</blockquote>
<h2 id="主从复制-vs-集群分片"><a href="#主从复制-vs-集群分片" class="headerlink" title="主从复制 vs 集群分片"></a><strong>主从复制 vs 集群分片</strong></h2><p>在设计软件架构时，要如何在主从复制和集群分片两种部署方案中取舍呢？<br>从各个方面看，Redis Cluster都是优于主从复制的方案</p>
<ul>
<li>Redis Cluster能够解决单节点上数据量过大的问题</li>
<li>Redis Cluster能够解决单节点访问压力过大的问题</li>
<li>Redis Cluster包含了主从复制的能力</li>
</ul>
<p>那是不是代表Redis Cluster永远是优于主从复制的选择呢？<br>并不是！！！<br>软件架构永远不是越复杂越好，复杂的架构在带来显著好处的同时，一定也会带来相应的弊端。采用Redis Cluster的弊端包括：</p>
<p><strong>1、维护难度增加</strong>。</p>
<p>在使用Redis Cluster时，需要维护的Redis实例数倍增，需要监控的主机数量也相应增加，数据备份/持久化的复杂度也会增加。</p>
<p>同时在进行分片的增减操作时，还需要进行reshard操作，远比主从模式下增加一个Slave的复杂度要高。</p>
<p><strong>2、客户端资源消耗增加</strong></p>
<p>当客户端使用连接池时，需要为每一个数据分片维护一个连接池，客户端同时需要保持的连接数成倍增多，加大了客户端本身和操作系统资源的消耗。</p>
<p><strong>3、性能优化难度增加</strong></p>
<p>你可能需要在多个分片上查看Slow Log和Swap日志才能定位性能问题。</p>
<p><strong>4、事务和LUA Script的使用成本增加</strong></p>
<p>在Redis Cluster中使用事务和LUA Script特性有严格的限制条件</p>
<p>事务和Script中操作的key必须位于同一个分片上，这就使得在开发时必须对相应场景下涉及的key进行额外的规划和规范要求。</p>
<p>如果应用的场景中大量涉及事务和Script的使用，如何在保证这两个功能的正常运作前提下把数据平均分到多个数据分片中就会成为难点。</p>
<p>所以，在主从复制和集群分片两个方案中做出选择时，应该从应用软件的功能特性、数据和访问量级、未来发展规划等方面综合考虑，只在<strong>确实有必要</strong>引入数据分片时再使用Redis Cluster。<br><strong>下面是一些建议：</strong></p>
<ul>
<li>需要在Redis中存储的数据有多大？未来2年内可能发展为多大？这些数据是否都需要长期保存？是否可以使用LRU算法进行非热点数据的淘汰？综合考虑前面几个因素，评估出Redis需要使用的物理内存。</li>
<li>用于部署Redis的主机物理内存有多大？有多少可以分配给Redis使用？对比(1)中的内存需求评估，是否足够用？</li>
<li>Redis面临的并发写压力会有多大？在不使用pipelining时，Redis的写性能可以超过10万次/秒（更多的benchmark可以参考 <a href="https://redis.io/topics/benchmarks" target="_blank" rel="noopener">https://redis.io/topics/benchmarks</a> ）</li>
<li>在使用Redis时，是否会使用到pipelining和事务功能？使用的场景多不多？</li>
</ul>
<p>综合上面几点考虑，如果单台主机的可用物理内存完全足以支撑对Redis的容量需求，且Redis面临的并发写压力距离Benchmark值还尚有距离，建议采用主从复制的架构，可以省去很多不必要的麻烦。<br>同时，如果应用中大量使用pipelining和事务，也建议尽可能选择主从复制架构，可以减少设计和开发时的复杂度。</p>
<h1 id="Redis-Java客户端的选择"><a href="#Redis-Java客户端的选择" class="headerlink" title="Redis Java客户端的选择"></a><strong>Redis Java客户端的选择</strong></h1><p>Redis的Java客户端很多，官方推荐的有三种：Jedis、Redisson和lettuce。<br>在这里对Jedis和Redisson进行对比介绍<br>Jedis：</p>
<ul>
<li>轻量，简洁，便于集成和改造</li>
<li>支持连接池</li>
<li>支持pipelining、事务、LUA Scripting、Redis Sentinel、Redis Cluster</li>
<li>不支持读写分离，需要自己实现</li>
<li>文档差（真的很差，几乎没有……）</li>
</ul>
<p>Redisson：</p>
<ul>
<li>基于Netty实现，采用非阻塞IO，性能高</li>
<li>支持异步请求</li>
<li>支持连接池</li>
<li>支持pipelining、LUA Scripting、Redis Sentinel、Redis Cluster</li>
<li>不支持事务，官方建议以LUA Scripting代替事务</li>
<li>支持在Redis Cluster架构下使用pipelining</li>
<li>支持读写分离，支持读负载均衡，在主从复制和Redis Cluster架构下都可以使用</li>
<li>内建Tomcat Session Manager，为Tomcat 6/7/8提供了会话共享功能</li>
<li>可以与Spring Session集成，实现基于Redis的会话共享</li>
<li>文档较丰富，有中文文档</li>
</ul>
<p>对于Jedis和Redisson的选择，同样应遵循前述的原理，尽管Jedis比起Redisson有各种各样的不足，但也应该在需要使用Redisson的高级特性时再选用Redisson，避免造成不必要的程序复杂度提升。</p>
]]></content>
      <categories>
        <category>Java技术</category>
        <category>Redis</category>
      </categories>
  </entry>
</search>
