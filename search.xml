<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>git操作（4）：checkout</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%884%EF%BC%89%EF%BC%9Acheckout/</url>
    <content><![CDATA[<p>在git中，暂存区里有若干备份，版本库里有若干版本。留着这些东西肯定是拿来用的对吧，怎么用呢？当我需要哪一份的时候我就切换到哪一份。<br><code>git checkout</code>命令就是用来干这个的，官方术语叫做<code>签出</code>。<br>怎么理解<code>checkout</code>这个词呢？<code>checkout</code>原本指的是消费结束服务员要与你核对一下账单，结完账之后你就可以走了。在git中核对指的是diff，比较两份版本的差异，如果发现没有冲突那就可以切换过来了。</p>
<a id="more"></a>

<h2 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h2><p>我们知道HEAD指针指向当前版本，而<code>git checkout</code>命令的作用是切换版本，它们肯定有所关联。<br>目前HEAD指针指向master分支。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ cat .git/HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">ref</span>: <span class="built_in">ref</span>s/heads/master</span></pre></td></tr></table></figure>

<p>如果我切换到另一个分支，会发生什么？</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git checkout dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched to branch <span class="string">'dev'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>cat .git/HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">ref:</span> refs/heads/dev</span></pre></td></tr></table></figure>

<p>果然，<code>git checkout</code>命令的原理就是改变了HEAD指针。而一旦HEAD指针改变，git就会取出HEAD指针指向的版本作为当前工作目录的版本。签出到一个没有分支引用的commit也是一样的。</p>
<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>在进入正题之前，我们要先聊聊git中的两个符号<code>~</code>和<code>^</code>。<br>如果我们要从一个分支切换到另一个分支，那还好说，足够语义化。但是如果我们要切换到某个commit，除了兢兢业业的找到它的SHA-1值，还有什么办法快速的引用到它呢？<br>比如说我们可以根据commit之间的谱系关系快速定位。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span> --graph --oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* 4e76510 (HEAD -&gt; master) c4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*   2ec8374 c3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|\</span></pre></td></tr><tr><td class="code"><pre><span class="line">| * <span class="number">7</span>c0a8e3 c2</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* | fb60f51 c1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">|/</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* dc96a29 c0</span></span></pre></td></tr></table></figure>

<blockquote>
<p><code>~</code>的作用是在纵向上定位。它可以一直追溯到最早的祖先commit。如果commit历史有分叉，那它就选第一个，也就是主干上的那个。<br><code>^</code>的作用是在横向上定位。它无法向上追溯，但是如果commit历史有分叉，它能定位所有分叉中的任意一支。</p>
</blockquote>
<h3 id="HEAD不加任何符号、加-0-符号或者加-0符号时，定位的都是当前版本"><a href="#HEAD不加任何符号、加-0-符号或者加-0符号时，定位的都是当前版本" class="headerlink" title="HEAD不加任何符号、加~0 符号或者加^0符号时，定位的都是当前版本"></a>HEAD不加任何符号、加<code>~0</code> 符号或者加<code>^0</code>符号时，定位的都是当前版本</h3><p>这个不用说，定位当前commit。</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4e76510</span>fe8bb3c69de12068ab354ef37bba6da9d</span></pre></td></tr></table></figure>

<p>它表示定位第零代父commit，也就是当前commit。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD~<span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4e76510f</span>e8bb3c69de12068ab354ef37bba6da9d</span></pre></td></tr></table></figure>

<p>它表示定位当前commit的第零个父commit，也就是当前commit。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD^<span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4e76510f</span>e8bb3c69de12068ab354ef37bba6da9d</span></pre></td></tr></table></figure>

<h3 id="用-符号数量的堆砌或者-数量的写法定位第几代父commit"><a href="#用-符号数量的堆砌或者-数量的写法定位第几代父commit" class="headerlink" title="用~符号数量的堆砌或者~数量的写法定位第几代父commit"></a>用<code>~</code>符号数量的堆砌或者<code>~数量</code>的写法定位第几代父commit</h3><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD~~</span></pre></td></tr><tr><td class="code"><pre><span class="line">fb60f519a59e9ceeef039f7efd2a8439aa7efd4b</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD~<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">fb60f519a59e9ceeef039f7efd2a8439aa7efd4b</span></pre></td></tr></table></figure>

<h3 id="用-数量的写法定位第几个父commit"><a href="#用-数量的写法定位第几个父commit" class="headerlink" title="用^数量的写法定位第几个父commit"></a>用<code>^数量</code>的写法定位第几个父commit</h3><p>注意，<code>^</code>定位的是当前基础的父commit。</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD^</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span>ec837440051af433677f786e502d1f6cdeb0a4a</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD^<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span>ec837440051af433677f786e502d1f6cdeb0a4a</span></pre></td></tr></table></figure>

<p>因为当前commit只有一个父commit，所以定位第二个父commit会失败。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD^<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HEAD^<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">fata<span class="variable">l:</span> ambiguous <span class="keyword">argument</span> <span class="string">'HEAD^2'</span>: unknown revision <span class="built_in">or</span> path not in the working tree.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Use <span class="string">'--'</span> <span class="keyword">to</span> separate paths from revisions, like thi<span class="variable">s:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]'</span></span></pre></td></tr></table></figure>

<h3 id="用-数量-数量的写法或者-数量-数量的写法定位第几代父commit的第几个父commit"><a href="#用-数量-数量的写法或者-数量-数量的写法定位第几代父commit的第几个父commit" class="headerlink" title="用~数量^数量的写法或者^数量^数量的写法定位第几代父commit的第几个父commit"></a>用<code>~数量^数量</code>的写法或者<code>^数量^数量</code>的写法定位第几代父commit的第几个父commit</h3><p>当前commit的第一代父commit的第零个父commit，意思就是第一代父commit咯。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD~^<span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span>ec837440051af433677f786e502d1f6cdeb0a4a</span></pre></td></tr></table></figure>

<p>比如这里定位的是当前commit的第一代父commit的第一个父commit。再次注意，<code>^</code>定位的是当前基础的父commit。</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rev</span>-<span class="built_in">parse</span> HEAD~^<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">fb60f519a59e9ceeef039f7efd2a8439aa7efd4b</span></pre></td></tr></table></figure>

<p>这里定位的是当前commit的第一代父commit的第二个父commit。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD~^<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">7</span><span class="keyword">c</span><span class="number">0</span>a<span class="number">8e3</span>a<span class="number">325</span>ce<span class="number">1</span>b<span class="number">5</span>a<span class="number">1</span>cdeb<span class="number">8</span><span class="keyword">c</span><span class="number">89</span>bef<span class="number">1</span>ecf<span class="number">17</span><span class="keyword">c</span><span class="number">10</span><span class="keyword">c</span><span class="number">9</span></span></pre></td></tr></table></figure>

<p>同样，定位到一个不存在的commit会失败。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git rev-parse HEAD~^<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HEAD~^<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">fata<span class="variable">l:</span> ambiguous <span class="keyword">argument</span> <span class="string">'HEAD~^3'</span>: unknown revision <span class="built_in">or</span> path not in the working tree.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Use <span class="string">'--'</span> <span class="keyword">to</span> separate paths from revisions, like thi<span class="variable">s:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]'</span></span></pre></td></tr></table></figure>

<p>和<code>~</code>不同，<code>^2</code>和<code>^^</code>的效果是不一样的。<code>^2</code>指的是第二个父commit，<code>^^</code>指的是第一个父commit的第一个父commit。</p>
<h2 id="切换到HEAD"><a href="#切换到HEAD" class="headerlink" title="切换到HEAD"></a>切换到HEAD</h2><p><code>git checkout</code>命令如果不带任何参数，默认会加上HEAD参数。而HEAD指针指向的就是当前commit。所以它并不会有任何签出动作。<br>前面没有提到的是，<code>git checkout</code>命令会有一个顺带效果：比较签出后的版本和暂存区之间的差异。<br>所以<code>git checkout</code>命令不带任何参数，意思就是比较当前commit和暂存区之间的差异。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ git checkout</span></pre></td></tr><tr><td class="code"><pre><span class="line">A	<span class="selector-tag">b</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line">A	<span class="selector-tag">b</span>.md</span></pre></td></tr></table></figure>

<h2 id="切换到commit"><a href="#切换到commit" class="headerlink" title="切换到commit"></a>切换到commit</h2><p>开发者用的最多的当然是切换分支。其实<code>checkout</code>后面不仅可以跟分支名，也可以跟commit的校验和，还可以用符号定位commit。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git checkout dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched to branch 'dev'</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout acb71fe</span></pre></td></tr><tr><td class="code"><pre><span class="line">Note: checking out 'acb71fe11f78d230b860692ea6648906153f3d27'.</span></pre></td></tr><tr><td class="code"><pre><span class="line">You are in 'detached HEAD' state. You can look around, make experimental</span></pre></td></tr><tr><td class="code"><pre><span class="line">changes and <span class="keyword">commit</span> them, <span class="keyword">and</span> you can discard <span class="keyword">any</span> commits you make <span class="keyword">in</span> this</span></pre></td></tr><tr><td class="code"><pre><span class="line">state <span class="keyword">without</span> impacting <span class="keyword">any</span> branches <span class="keyword">by</span> performing another checkout.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">If</span> you want <span class="keyword">to</span> <span class="keyword">create</span> a <span class="keyword">new</span> branch <span class="keyword">to</span> retain commits you <span class="keyword">create</span>, you may</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> so (<span class="keyword">now</span> <span class="keyword">or</span> later) <span class="keyword">by</span> <span class="keyword">using</span> -b <span class="keyword">with</span> the checkout command again. Example:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  git checkout -b &lt;<span class="keyword">new</span>-branch-<span class="keyword">name</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">HEAD</span> <span class="keyword">is</span> <span class="keyword">now</span> <span class="keyword">at</span> acb71fe... <span class="literal">null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout <span class="keyword">HEAD</span>~<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Note: checking <span class="keyword">out</span> <span class="string">'acb71fe11f78d230b860692ea6648906153f3d27'</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">You <span class="keyword">are</span> <span class="keyword">in</span> <span class="string">'detached HEAD'</span> state. You can look around, make experimental</span></pre></td></tr><tr><td class="code"><pre><span class="line">changes <span class="keyword">and</span> <span class="keyword">commit</span> them, <span class="keyword">and</span> you can discard <span class="keyword">any</span> commits you make <span class="keyword">in</span> this</span></pre></td></tr><tr><td class="code"><pre><span class="line">state <span class="keyword">without</span> impacting <span class="keyword">any</span> branches <span class="keyword">by</span> performing another checkout.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">If</span> you want <span class="keyword">to</span> <span class="keyword">create</span> a <span class="keyword">new</span> branch <span class="keyword">to</span> retain commits you <span class="keyword">create</span>, you may</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> so (<span class="keyword">now</span> <span class="keyword">or</span> later) <span class="keyword">by</span> <span class="keyword">using</span> -b <span class="keyword">with</span> the checkout command again. Example:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  git checkout -b &lt;<span class="keyword">new</span>-branch-<span class="keyword">name</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">HEAD</span> <span class="keyword">is</span> <span class="keyword">now</span> <span class="keyword">at</span> acb71fe... <span class="literal">null</span></span></pre></td></tr></table></figure>

<h2 id="创建分支并切换"><a href="#创建分支并切换" class="headerlink" title="创建分支并切换"></a>创建分支并切换</h2><p>有时候我们在创建分支时希望同时切换到创建后的分支，仅仅<code>git branch</code>是做不到的。这时<code>git checkout</code>命令可以提供一个快捷操作，创建分支和切换分支一步到位。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched <span class="built_in">to</span> <span class="keyword">a</span> <span class="built_in">new</span> branch <span class="string">'dev'</span></span></pre></td></tr></table></figure>

<h2 id="暂存区文件覆盖工作区文件"><a href="#暂存区文件覆盖工作区文件" class="headerlink" title="暂存区文件覆盖工作区文件"></a>暂存区文件覆盖工作区文件</h2><p><code>git checkout</code>不仅可以执行切换commit这种全量切换，它还能以文件为单位执行微观切换。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">No commits yet</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git rm --cached &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">new</span> <span class="keyword">file</span>:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout <span class="comment">-- a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">No</span> commits yet</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">to</span> be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git rm --cached &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">new</span> <span class="keyword">file</span>:   a.md</span></pre></td></tr></table></figure>

<p>因为暂存区覆盖了工作区，所以工作区的改动就被撤销了，现在只剩下暂存区的改动等待提交。其实相当于撤销文件在工作区的改动，只不过它的语义是覆盖。这个命令没有任何提示，直接撤销工作区改动，要谨慎使用。<br>我们看到git提示语中有一个<code>git checkout --</code>命令，这又是干嘛用的呢？<br>提醒一下，这个参数的写法不是<code>git checkout --</code>，而是<code>git checkout --</code>。<br>其实它和<code>git checkout</code>的效果是一样的。但是别急，我是说这两个命令<strong>想要</strong>达到的效果是一样的，但<strong>实际</strong>效果却有略微的差别。<br>独立的<code>--</code>参数在Linux命令行中指的是：视后面的参数为文件名。当后面跟的是文件名的时候，最好加上独立的<code>--</code>参数，以免有歧义。<br>也就是说，如果该项目正好有一个分支名为<code>a.md</code>(皮一下也不是不行对吧)，那加独立的<code>--</code>参数就不会操作分支，而是操作文件。<br>如果你觉得仅仅撤销一个文件在工作区的改动不过瘾，你不是针对谁，你是觉得工作区的改动都是垃圾。那么还有一个更危险的命令。</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">$ git checkout <span class="comment">-- .</span></span></pre></td></tr></table></figure>

<p><code>.</code>代表当前目录下的所有文件和子目录。这条命令会撤销所有工作区的改动。</p>
<h2 id="当前commit文件覆盖暂存区文件和工作区文件"><a href="#当前commit文件覆盖暂存区文件和工作区文件" class="headerlink" title="当前commit文件覆盖暂存区文件和工作区文件"></a>当前commit文件覆盖暂存区文件和工作区文件</h2><p>如果执行<code>git checkout --</code>的时候加上一个分支名或者commit的校验和，效果就是该文件的当前版本会同时覆盖暂存区和工作区。相当于同时撤销文件在暂存区和工作区的改动。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout <span class="keyword">HEAD</span> <span class="comment">-- a.md</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="keyword">status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">nothing</span> <span class="keyword">to</span> <span class="keyword">commit</span>, working tree clean</span></pre></td></tr></table></figure>

<p>最后再提醒一下，运行<code>git checkout</code>命令作用于文件时，即便覆盖内容与被覆盖内容有冲突，也会直接覆盖，所以这真的是闷声打雷式的git命令，一定要抽自己几个耳刮子方可放心食用。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/checkout.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/checkout.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（3）：branch</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%883%EF%BC%89%EF%BC%9Abranch/</url>
    <content><![CDATA[<p>分支是使得git如此灵活的强大武器，正是因为有巧妙的分支设计，众多的git工作流才成为可能。<br>现在我们已经知道commit对象其实就是git中的版本。那我们要在版本之间切换难道只能通过指定commit对象毫无意义的SHA-1值吗？<br>当然不是。<br>在git中，我们可以通过将一些指针指向commit对象来方便操作，这些指针便是分支。</p>
<a id="more"></a>

<blockquote>
<p>分支在git中是一个模棱两可的概念。<br>你可以认为它仅仅是一个指针，指向一个commit对象节点。<br>你也可以认为它是指针指向的commit对象节点追溯到某个交叉节点之间的commit历史。</p>
</blockquote>
<p>严格的来说，一种叫分支指针，一种叫分支历史。不过实际使用中，它们在名字上常常不作区分。<br>所以我们需要意会文字背后的意思，它究竟说的是分支指针还是分支历史。<br>大多数时候，它指的都是分支指针。</p>
<h2 id="master分支"><a href="#master分支" class="headerlink" title="master分支"></a>master分支</h2><p>刚刚初始化的git仓库，会发现<code>.git/refs/heads</code>目录下面是空的。这是因为目前版本库里还没有任何commit对象，而分支一定是指向commit对象的。<br>一旦版本库里有了第一个commit对象，git都会在<code>.git/refs/heads</code>目录下面自动生成一个<code>master</code>文件，它就是git的默认分支。不过它并不特殊，只是它充当的是一个默认角色而已。<br>刚刚初始化的git仓库会显示目前在master分支上，其实这个master分支是假的，<code>.git/refs/heads</code>目录下根本没有这个文件。只有等提交历史不为空时才有会真正的默认分支。<br>我们看一下<code>master</code>文件到底有什么。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ cat .git/refs/heads/<span class="literal">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">6</span>b5a94158cc141286ac98f30bb189b8a83d61347</span></pre></td></tr></table></figure>

<p>40个字符，明显是某个git对象的引用。再识别一下它的类型，发现是一个commit对象。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git cat-<span class="keyword">file</span> -t <span class="number">6</span>b5a941</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit</span></pre></td></tr></table></figure>

<p>就这么简单，所谓的分支(分支指针)就是一个指向某个commit对象的指针。</p>
<h2 id="HEAD指针"><a href="#HEAD指针" class="headerlink" title="HEAD指针"></a>HEAD指针</h2><p>形象的讲，HEAD就是景区地图上标注你当前在哪里的一个图标。<br>你当前在哪里，HEAD就在哪里。它一般指向某个分支，因为一般我们都会在某个分支之上。<br>因为HEAD是用来标注当前位置的，所以一旦HEAD的位置被改变，工作目录就会切换到HEAD指向的分支。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">log</span> <span class="comment">--oneline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">f53aaa7 (HEAD -&gt; master) <span class="keyword">commit</span> <span class="keyword">for</span> <span class="keyword">nothing</span></span></pre></td></tr></table></figure>

<p>但是也有例外，比如我直接签出到某个没有分支引用的commit。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> <span class="comment">--oneline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cb64064 (HEAD -&gt; master) commit <span class="keyword">for</span> nothing again</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">324</span>a3c0 commit <span class="keyword">for</span> nothing</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout <span class="number">324</span>a3c0</span></pre></td></tr><tr><td class="code"><pre><span class="line">Note: checking out <span class="string">'324a3c0'</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">You are <span class="keyword">in</span> <span class="string">'detached HEAD'</span> state. You can look around, make experimental</span></pre></td></tr><tr><td class="code"><pre><span class="line">changes <span class="keyword">and</span> commit them, <span class="keyword">and</span> you can discard <span class="keyword">any</span> commits you make <span class="keyword">in</span> this</span></pre></td></tr><tr><td class="code"><pre><span class="line">state <span class="keyword">without</span> impacting <span class="keyword">any</span> branches <span class="keyword">by</span> performing another checkout.</span></pre></td></tr><tr><td class="code"><pre><span class="line">If you want <span class="built_in">to</span> <span class="built_in">create</span> <span class="keyword">a</span> <span class="built_in">new</span> branch <span class="built_in">to</span> retain commits you <span class="built_in">create</span>, you may</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">do</span> so (now <span class="keyword">or</span> later) <span class="keyword">by</span> <span class="keyword">using</span> -b <span class="keyword">with</span> <span class="keyword">the</span> checkout <span class="keyword">command</span> <span class="title">again</span>. <span class="title">Example</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  git checkout -b &lt;<span class="built_in">new</span>-branch-name&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">HEAD is now <span class="keyword">at</span> <span class="number">324</span>a3c0... commit <span class="keyword">for</span> nothing</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> <span class="comment">--oneline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">324</span>a3c0 commit <span class="keyword">for</span> nothing</span></pre></td></tr></table></figure>

<p>这个时候的HEAD就叫做<code>detached HEAD</code>。<br>要知道，只有在初始提交和某个分支之间的commit才是有效的。当你的HEAD处于<code>detached HEAD</code>状态时，在它之上新建的commit没有被任何分支包裹。一旦你切换到别的分支，这个commit(可能)再也不会被引用到，最终会被垃圾回收机制删除。因此这是很危险的操作。</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="number">324</span><span class="variable">a3c0</span> -- <span class="function"><span class="title">cb64064</span>(<span class="variable">master</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   \</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">3899</span><span class="function"><span class="title">a24</span>(<span class="variable">HEAD</span>)</span></span></pre></td></tr></table></figure>

<p>如果不小心这么做了，要么在原地新建一个分支，要么将已有的分支强行移动过来。确保它不会被遗忘。</p>
<blockquote>
<p>死亡不是终结，遗忘才是。——寻梦环游记</p>
</blockquote>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>除了默认的<code>master</code>分支，我们可以随意创建新的分支。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>dev</span></pre></td></tr></table></figure>

<p>一个dev分支就创建好了。</p>
<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>或许有时我们也想要查看本地仓库有多少个分支，因为在git中新建分支实在是太容易了。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git branch</span></pre></td></tr><tr><td class="code"><pre><span class="line">  dev</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* master</span></span></pre></td></tr></table></figure>

<p>当前分支的前面会有一个<code>*</code>号标注。<br>同时查看本地分支和远端分支引用，添加<code>-a</code>参数。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git branch -a</span></pre></td></tr><tr><td class="code"><pre><span class="line">* <span class="literal">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  remotes/origin/HEAD -&gt; origin/<span class="literal">master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  remotes/origin/<span class="literal">master</span></span></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>一般分支合并完之后就不再需要了，这时就要将它删除。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-d dev</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">Deleted</span> <span class="keyword">branch </span>dev (was <span class="number">657142</span>d).</span></pre></td></tr></table></figure>

<p>有时候我们会得到不一样的提示。</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">$ git branch -d dev</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">error: </span>The branch 'dev' is not fully merged.</span></pre></td></tr><tr><td class="code"><pre><span class="line">If you are sure you want to delete it, run 'git branch -D dev'.</span></pre></td></tr></table></figure>

<p>这是git的一种保护措施。<code>is not fully merged</code>是针对当前分支来说的，意思是你要删除的分支还有内容没有合并进<strong>当前分支</strong>，你确定要删除它吗？<br>大多数时候，当然是要的。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-D dev</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">Deleted</span> <span class="keyword">branch </span>dev (was <span class="number">657142</span>d).</span></pre></td></tr></table></figure>

<p><code>-D</code>是<code>--delete --force</code>的缩写，你也可以写成<code>-df</code>。<br>需要注意的是，删除分支仅仅是删除一个指针而已，并不会删除对应的commit对象。不过有可能删除分支以后，这一串commit对象就无法再被引用了，从而被垃圾回收机制删除。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/branch.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/branch.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（2）：commit</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%882%EF%BC%89%EF%BC%9Acommit/</url>
    <content><![CDATA[<p>git是一个版本管理系统。它的终极目的就是将项目特定时间的信息保留成一个版本，以便将来的回退和查阅。<br>我们已经介绍了暂存区，暂存区的下一步就是版本库，而促成这一步操作的是<code>git commit</code>命令。</p>
<a id="more"></a>

<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>暂存区有待提交内容的情况下，如果直接运行<code>git commit</code>命令，git会跳往默认编辑器要求你输入提交说明，你也可以自定义要跳往的编辑器。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Please enter the commit message for your changes. Lines starting</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># with '#' will be ignored, and an empty message aborts the commit.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># On branch master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Initial commit</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Changes to be committed:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#	new file:   a.md</span></span></pre></td></tr></table></figure>

<p>提交之后我们就看到这样的信息。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">[master (root-commit) <span class="number">99558b4</span>] commit <span class="keyword">for</span> nothing</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode <span class="number">100644</span> a.md</span></pre></td></tr></table></figure>

<p>如果我就是不写提交说明呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Aborting <span class="keyword">commit</span> due <span class="keyword">to</span> <span class="keyword">empty</span> <span class="keyword">commit</span> message.</span></pre></td></tr></table></figure>

<p>看到没有，提交信息在git中时必填的。<br>如果提交说明不多，可以加参数<code>-m</code>直接在命令后面填写提交说明。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git commit -m <span class="string">"commit for nothing"</span></span></pre></td></tr></table></figure>

<p>你甚至可以将加入暂存区和提交一并做了。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git commit -am <span class="string">"commit for nothing"</span></span></pre></td></tr></table></figure>

<p>但是要注意，和<code>git add -u</code>命令一样，未跟踪的文件是无法提交上去的。</p>
<h2 id="重写提交"><a href="#重写提交" class="headerlink" title="重写提交"></a>重写提交</h2><p><code>amend</code>翻译成中文是<code>修改</code>的意思。<code>git commit --amend</code>命令允许你修改最近的一次commit。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">log</span> <span class="comment">--oneline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">8274473</span> (HEAD -&gt; master) <span class="keyword">commit</span> <span class="keyword">for</span> <span class="keyword">nothing</span></span></pre></td></tr></table></figure>

<p>目前项目提交历史中只有一个commit。我突然想起来这次提交中有一个笔误，我把<code>高圆圆</code>写成了<code>高晓松</code>(真的是笔误)。但是呢，我又不想为了这个笔误增加一个commit，毕竟它仅仅是一个小小的笔误而已。最重要的是我想悄无声息的改正它，以免被别人笑话。<br>这时我就可以使用<code>git commit --amend</code>命令。<br>首先修改<code>高晓松</code>成<code>高圆圆</code>。<br>然后执行<code>git add a.md</code>命令。<br>最后重写提交。git会跳往默认或者自定义编辑器提示你修改commit说明。当然你也可以不改。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> <span class="comment">--amend</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">commit</span> <span class="keyword">for</span> <span class="keyword">nothing</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Please enter the commit message for your changes. Lines starting</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># with '#' will be ignored, and an empty message aborts the commit.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Date:      Thu Jan 3 09:33:56 2019 +0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># On branch master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Initial commit</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Changes to be committed:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#	new file:   a.md</span></span></pre></td></tr></table></figure>

<p>我们再来看提交历史。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">log</span> <span class="comment">--oneline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">8</span>a71ae1 (HEAD -&gt; master) <span class="keyword">commit</span> <span class="keyword">for</span> <span class="keyword">nothing</span></span></pre></td></tr></table></figure>

<p>提交历史中同样只有一个commit。但是注意哟，commit已经不是之前的那个commit了，它们的校验和是不一样的。这就是所谓的重写。</p>
<h2 id="tree对象和commit对象"><a href="#tree对象和commit对象" class="headerlink" title="tree对象和commit对象"></a>tree对象和commit对象</h2><p>commit操作涉及到两个git对象。<br>第一是tree对象。<br>它存储子目录和子文件的引用。如果只有blob对象，那版本库将是一团散沙。正因为有tree对象将它们的关系登记在册，才能构成一个有结构的版本库。<br>添加到暂存区操作并不会生成tree对象，这时项目的结构信息存储在<code>index</code>文件中，直到提交版本库操作，才会为每一个目录分别生成tree对象。<br>第二是commit对象。<br>它存储每个提交的信息，包括当前提交的根tree对象的引用，父commit对象的引用，作者和提交者，还有提交信息。所谓的版本，其实指的就是这个commit对象。<br>作者和提交者通常是一个人，但也存在不同人的情况。</p>
<h2 id="objects"><a href="#objects" class="headerlink" title="objects"></a>objects</h2><p>初始化一个git项目，新建一些文件和目录。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">src/</span></pre></td></tr><tr><td class="code"><pre><span class="line">src/a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">lib</span>/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">lib</span>/<span class="title">b</span>.<span class="title">md</span></span></span></pre></td></tr></table></figure>

<p>首先运行<code>git add</code>命令。我们清楚，这会在<code>.git/objects</code>目录下生成一个blob对象，因为目前两个文件都是空文件，共享一个blob对象。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/info/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/pack/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391</span></span></pre></td></tr></table></figure>

<p>现在我们运行<code>git commit</code>命令，看看有什么变化。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/objects/info/</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/pack/</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/e6/<span class="number">9</span>de29bb2d1d6434b8b29ae775ad8c2e48c5391</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">93</span>/<span class="number">810</span>bbde0f994d41ef550324a2c1ad5f9278e19</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">52</span>/<span class="number">0</span>c9f9f61657ca1e65a288ea77d229a27a8171b</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">0</span>b/<span class="number">785f</span>a11cd93f95b1cab8b9cbab188edc7e04df</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">49</span>/<span class="number">11f</span>f67189d8d5cc2f94904fdd398fc16410d56</span></pre></td></tr></table></figure>

<p>有意思。刚刚只有一个blob对象，怎么突然蹦出来这么多git对象呢？想一想之前说的<code>commit操作涉及到两个git对象</code>这句话，有没有可能多出来的几个，分别是tree对象和commit对象？<br>我们使用git底层命令<code>git cat-file -t</code>查看这些对象的类型发现，其中有一个blob对象，三个tree对象，一个commit对象。<br>这是第一个tree对象。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git cat-<span class="keyword">file</span> -t <span class="number">93810</span>bb</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git cat-<span class="keyword">file</span> -p <span class="number">93810</span>bb</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">100644</span> blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391	b.md</span></pre></td></tr></table></figure>

<p>这是第二个tree对象。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git cat-<span class="keyword">file</span> -t <span class="number">520</span>c9f9</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git cat-<span class="keyword">file</span> -p <span class="number">520</span>c9f9</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">100644</span> blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391	a.md</span></pre></td></tr></table></figure>

<p>这是第三个tree对象。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">$ git cat-file -t <span class="number">0</span>b785fa</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git cat-file -p <span class="number">0</span>b785fa</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0</span>40000 tree <span class="number">93810</span>bbde0f994d41ef550324a2c1ad5f9278e19	<span class="class"><span class="keyword">lib</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0</span>40000 tree <span class="number">520</span>c9f9f61657ca1e65a288ea77d229a27a8171b	src</span></pre></td></tr></table></figure>

<p>可以看到，提交时每个目录都会生成对应的tree对象。<br>然后我们再来看commit对象。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git cat-file -t <span class="number">4911f</span>f6</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git cat-file -p <span class="number">4911f</span>f6</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree <span class="number">0</span>b785fa11cd93f95b1cab8b9cbab188edc7e04df</span></pre></td></tr><tr><td class="code"><pre><span class="line">parent c4731cfab38f036c04de93facf07cae496a124a2</span></pre></td></tr><tr><td class="code"><pre><span class="line">author veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt; <span class="number">1546395770</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">committer veedrin &lt;<span class="symbol">veedrin@</span>qq.com&gt; <span class="number">1546395770</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="keyword">for</span> nothing</span></pre></td></tr></table></figure>

<p>可以看到，commit会关联根目录的tree对象，因为关联它就可以关联到所有的项目结构信息，所谓擒贼先擒王嘛。它也要关联父commit，也就是它的上一个commit，这样才能组成版本历史。当然，如果是第一个commit那就没有父commit了。然后就是commit说明和一些参与者信息。<br>我们总结一下，<code>git add</code>命令会为加入暂存区的内容或文件生成blob对象，<code>git commit</code>命令会为加入版本库的内容或文件生成tree对象和commit对象。至此，四种git对象我们见识了三种。<br>为啥不在<code>git add</code>的时候就生成tree对象呢？<br>所谓暂存区，就是不一定会保存为版本的信息，只是一个准备的临时场所。git认为在<code>git add</code>的时候生成tree对象是不够高效的，完全可以等版本定型时再生成。而版本定型之前的结构信息存在<code>index</code>文件中就好了。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/commit.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/commit.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>git操作（1）：add</title>
    <url>/2019/12/26/git%E6%93%8D%E4%BD%9C%EF%BC%881%EF%BC%89%EF%BC%9Aadd/</url>
    <content><![CDATA[<p>git是一个数据库系统，git是一个内容寻址文件系统，git是一个版本管理系统。<br>没错，它都是。<br>不过我们不纠结于git是什么，我们单刀直入，介绍git命令。<br>要将未跟踪的文件和已跟踪文件的改动加入暂存区，我们可以使用<code>git add</code>命令。<br>不过很多人嫌<code>git add</code>命令不够语义化，毕竟这一步操作是加入暂存区呀。所以git又增加了另外一个命令<code>git stage</code>，它们的效果是一模一样的。</p>
<a id="more"></a>

<h2 id="git仓库、工作区和暂存区"><a href="#git仓库、工作区和暂存区" class="headerlink" title="git仓库、工作区和暂存区"></a>git仓库、工作区和暂存区</h2><p>进入主题之前，我们先要介绍一下git仓库、工作区和暂存区的概念。</p>
<h3 id="git仓库"><a href="#git仓库" class="headerlink" title="git仓库"></a>git仓库</h3><p>所谓的git仓库就是一个有<code>.git</code>目录的文件夹。它是和git有关的一切故事开始的地方。<br>可以使用<code>git init</code>命令初始化一个git仓库。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git init</span></pre></td></tr></table></figure>

<p>也可以使用<code>git clone</code>命令从服务器上克隆仓库到本地。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">git</span>@github.com:veedrin/horseshoe.git</span></pre></td></tr></table></figure>

<p>然后你的本地就有了一个和服务器上一模一样的git仓库。<br>这里要说明的是，<code>clone</code>操作并不是将整个仓库下载下来，而是只下载<code>.git</code>目录。因为关于git的一切秘密都在这个目录里面，只要有了它，git就能复原到仓库的任意版本。</p>
<h3 id="工作区-working-directory"><a href="#工作区-working-directory" class="headerlink" title="工作区(working directory)"></a>工作区(working directory)</h3><p>工作区，又叫工作目录，就是不包括<code>.git</code>目录的项目根目录。我们要在这个目录下进行手头的工作，它就是版本管理的素材库。你甚至可以称任何与工作有关的目录为工作区，只不过没有<code>.git</code>目录git是不认的。</p>
<h3 id="暂存区-stage或者index"><a href="#暂存区-stage或者index" class="headerlink" title="暂存区(stage或者index)"></a>暂存区(stage或者index)</h3><p><code>stage</code>在英文中除了有<code>舞台、阶段</code>之意外，还有作为动词的<code>准备、筹划</code>之意，所谓的暂存区就是一个为提交到版本库做准备的地方。<br>那它为什么又被称作<code>index</code>呢？因为暂存区在物理上仅仅是<code>.git</code>目录下的<code>index</code>二进制文件。它就是一个索引文件，将工作区中的文件和暂存区中的备份一一对应起来。<br><code>stage</code>是表意的，<code>index</code>是表形的。<br>你可以把暂存区理解为一个猪猪储钱罐。我们还是孩子的时候，手里有一毛钱就会丢进储钱罐里。等到储钱罐摇晃的声音变的浑厚时，或者我们有一个心愿急需用钱时，我们就砸开储钱罐，一次性花完。<br>类比到软件开发，每当我们写完一个小模块，就可以将它放入暂存区。等到一个完整的功能开发完，我们就可以从暂存区一次性提交到版本库里。<br>这样做的好处是明显的：</p>
<ul>
<li>它可以实现更小颗粒度的撤销。</li>
<li>它可以实现批量提交到版本库。</li>
</ul>
<p>另外，添加到暂存区其实包含两种操作。一种是将还未被git跟踪过的文件放入暂存区；一种是已经被git跟踪的文件，将有改动的内容放入暂存区。</p>
<h2 id="放入暂存区"><a href="#放入暂存区" class="headerlink" title="放入暂存区"></a>放入暂存区</h2><p>git默认是不会把工作区的文件放入暂存区的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">No commits yet</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked files:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">include</span> <span class="keyword">in</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">nothing</span> added <span class="keyword">to</span> <span class="keyword">commit</span> but untracked files <span class="keyword">present</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">to</span> track)</span></pre></td></tr></table></figure>

<p>我们看到文件现在被标注为<code>Untracked files</code>。表示git目前还无法追踪它们的变化，也就是说它们还不在暂存区里。<br>那么我们如何手动将文件或文件夹放入暂存区呢？</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> .</span></span></pre></td></tr></table></figure>

<p>上面的命令表示将工作目录所有未放入暂存区的文件都放入暂存区。这时文件的状态已经变成了<code>Changes to be committed</code>，表示文件已经放入暂存区，等待下一步提交。每一次add操作其实就是为加入的文件或内容生成一份备份。<br>下面的命令也能达到相同的效果。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> -A</span></span></pre></td></tr></table></figure>

<p>假如我只想暂存单个文件呢？后跟相对于当前目录的文件名即可。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> README.md</span></span></pre></td></tr></table></figure>

<p>暂存整个文件夹也是一样的道理。因为git会递归暂存文件夹下的所有文件。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> src</span></span></pre></td></tr></table></figure>

<p>把从来没有被标记过的文件放入暂存区的命令是<code>git add</code>，暂存区中的文件有改动也需要使用<code>git add</code>命令将改动放入暂存区。<br>这时状态变成了<code>Changes not staged for commit</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes not staged for <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span></pre></td></tr></table></figure>

<p>针对已经加入暂存区的文件，要将文件改动加入暂存区，还有一个命令。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> -u</span></span></pre></td></tr></table></figure>

<p>它和<code>git add -A</code>命令的区别在于，它只能将已加入暂存区文件的改动放入暂存区，而<code>git add -A</code>通吃两种情况。</p>
<h2 id="跟踪内容"><a href="#跟踪内容" class="headerlink" title="跟踪内容"></a>跟踪内容</h2><p>假设我们已经将文件加入暂存区，现在我们往文件中添加内容，再次放入暂存区，然后查看状态。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">No commits yet</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git rm --cached &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">new</span> <span class="keyword">file</span>:   a.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  modified:   a.md</span></pre></td></tr></table></figure>

<p>哎，突然变的有意思了。为什么一个文件会同时存在两种状态，它是薛定谔的猫么？<br>想象一下，我想在一个文件中先修复一个bug然后增加一个feather，我肯定希望分两次放入暂存区，这样可以实现颗粒度更细的撤销和提交。但是如果git是基于文件做版本管理的，它就无法做到。<br>所以git只能是基于内容做版本管理，而不是基于文件。版本管理的最小单位叫做hunk，所谓的hunk就是一段连续的改动。一个文件同时有两种状态也就不稀奇了。</p>
<h2 id="objects"><a href="#objects" class="headerlink" title="objects"></a>objects</h2><p>git项目的<code>.git</code>目录下面有一个目录<code>objects</code>，一开始这个目录下面只有两个空目录：<code>info</code>和<code>pack</code>。<br>一旦我们执行了<code>git add</code>命令，<code>objects</code>目录下面就会多出一些东西。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="title">.git/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/e6/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391</span></span></pre></td></tr></table></figure>

<p>它多出了一个2个字符命名的目录和一个38个字符命名的文件。加起来正好是40个字符。增加一个2个字符的目录是为了提高检索效率。<br>SHA-1是一种哈希加密算法，它的特点是只要加密的内容相同，得到的校验和也相同。当然这种说法是不准确的，但是碰撞的概率极低。<br>git除了用内容来计算校验和之外，还加入了一些其他信息，目的也是为了进一步降低碰撞的概率。<br>重点是，SHA-1算法是根据内容来计算校验和的，跟前面讲的git跟踪内容相呼应。git被称为一个内容寻址文件系统不是没有道理的。<br>我们可以做个实验。初始化本地仓库两次，每次都新建一个markdown文件，里面写<code>## git is awesome</code>，记下完整的40个字符的校验和，看看它们是否一样。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">56</span>/<span class="number">46</span>a656f6331e1b30988472fefd48686a99e10f</span></pre></td></tr></table></figure>

<p>如果你真的做了实验，你会发现即便两个文件的文件名和文件格式都不一样，只要内容一样，它们的校验和就是一样的，并且就是上面列出的校验和。<br>现在大家应该对<code>git跟踪内容</code>这句话有更深的理解了。</p>
<h3 id="相同内容引用一个对象"><a href="#相同内容引用一个对象" class="headerlink" title="相同内容引用一个对象"></a>相同内容引用一个对象</h3><p>虽然开发者要极力避免这种情况，但是如果一个仓库有多个内容相同的文件，git会如何处理呢？<br>我们初始化一个本地仓库，新建两个不同名的文件，但文件内容都是<code>## git is awesome</code>。运行<code>git add .</code>命令之后看看神秘的<code>objects</code>目录下会发生什么？</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">56</span>/<span class="number">46</span>a656f6331e1b30988472fefd48686a99e10f</span></pre></td></tr></table></figure>

<p>只有一个目录，而且校验和跟之前一模一样。<br>其实大家肯定早就想到了，git这么优秀的工具，怎么可能会让浪费磁盘空间的事情发生呢？既然多个文件的内容相同，肯定只保存一个对象，让它们引用到这里来就好了。</p>
<h3 id="文件改动对应新对象"><a href="#文件改动对应新对象" class="headerlink" title="文件改动对应新对象"></a>文件改动对应新对象</h3><p>现在我们猜测工作区的文件和<code>objects</code>目录中的对象是一一对应起来的。但事实真的是这样吗？<br>我们初始化一个本地仓库，新建一个markdown文件，运行<code>git add .</code>命令。现在<code>objects</code>目录中已经有了一个对象。然后往文件中添加内容<code>## git is awesome</code>。再次运行<code>git add .</code>命令。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/objects/e6/<span class="number">9</span>de29bb2d1d6434b8b29ae775ad8c2e48c5391</span></pre></td></tr><tr><td class="code"><pre><span class="line">.git/objects/<span class="number">56</span>/<span class="number">46</span>a656f6331e1b30988472fefd48686a99e10f</span></pre></td></tr></table></figure>

<p>哎，<code>objects</code>目录中出现了两个对象。第一个对象肯定对应空文件。第二个对象我们太熟悉了，对应的是添加内容后的文件。<br>再次强调，git是一个版本管理系统，文件在它这里不是主角，版本才是。刚才我们暂存了两次，可以认为暂存区现在已经有了两个版本(暂存区的版本实际上是内容备份，并不是真正的版本)。当然就需要两个对象来保存。</p>
<h3 id="文件改动全量保存"><a href="#文件改动全量保存" class="headerlink" title="文件改动全量保存"></a>文件改动全量保存</h3><p>初始化一个本地仓库，往工作区添加<code>lodash.js</code>未压缩版本，版本号是<code>4.17.11</code>，体积大约是<code>540KB</code>。运行<code>git add .</code>命令后<code>objects</code>目录下面出现一个对象，体积大约是<code>96KB</code>。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.git/objects/cb/<span class="number">139</span>dd81ebee6f6ed5f5a9198471f5cdc876d70</span></pre></td></tr></table></figure>

<p>我们对<code>lodash.js</code>文件内容作一个小小的改动，将版本号从<code>4.17.11</code>改为<code>4.17.10</code>，再次运行<code>git add .</code>命令。然后大家会惊奇的发现<code>objects</code>目录下有两个对象了。惊奇的不是这个，而是第二个对象的体积也是大约<code>96KB</code>。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/cb/139dd81ebee6f6ed5f5a9198471f5cdc876d70</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/bf/c087eec7e61f106df8f5149091b8790e6f3636</span></span></pre></td></tr></table></figure>

<p>明明只改了一个数字而已，第二个对象却还是这么大。<br>前面刚夸git会精打细算，怎么到这里就不知深浅了？这是因为多个文件内容相同的情况，引用到同一个对象并不会造成查询效率的降低，而暂存区的多个对象之间如果只保存增量的话，版本之间的查询和切换需要花费额外的时间，这样做是不划算的。<br>但是全量保存也不是个办法吧。然而git鱼和熊掌想兼得，它也做到了。后面会讲到。</p>
<h3 id="重命名会拆分成删除和新建两个动作"><a href="#重命名会拆分成删除和新建两个动作" class="headerlink" title="重命名会拆分成删除和新建两个动作"></a>重命名会拆分成删除和新建两个动作</h3><p>初始化一个本地仓库，新建一个文件，运行<code>git add .</code>命令。然后重命名该文件，查看状态信息。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">No commits yet</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git rm --cached &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">new</span> <span class="keyword">file</span>:   <span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes not staged <span class="keyword">for</span> commi<span class="variable">t:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git add/rm &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will <span class="keyword">be</span> committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard <span class="keyword">changes</span> in working directory)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  deleted:    <span class="keyword">a</span>.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked <span class="keyword">file</span><span class="variable">s:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> include in what will <span class="keyword">be</span> committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">b</span>.md</span></pre></td></tr></table></figure>

<p>这是由于git的内部机制导致的。生成对象的时候，它发现仓库中叫这个名字的文件不见了，于是标记为已删除，又发现有一个新的文件名是之前没有标记过的，于是标记为未跟踪。因为它只是重命名而已，文件内容并没有改变，所以可以共享对象，并不会影响效率。</p>
<h2 id="blob对象"><a href="#blob对象" class="headerlink" title="blob对象"></a>blob对象</h2><p>git的一切秘密都在<code>.git</code>目录里。因为它拥有项目的完整信息，所以git一定是把备份存在了某个地方。git把它们存在了哪里，又是如何存储它们的呢？<br>这些备份信息，git统一称它们为对象。git总共有四种对象类型，都存在<code>.git/objects</code>目录下。<br>这一次我们只介绍blob对象。<br>它存储文件的内容和大小。当开发者把未跟踪的文件或跟踪文件的改动加入暂存区，就会生成若干blob对象。git会对blob对象进行<code>zlib</code>压缩，以减少空间占用。<br>因为它只存储内容和大小，所以两个文件即便文件名和格式完全不一样，只要内容相同，就可以共享一个blob对象。<br>注意blob对象和工作目录的文件并不是一一对应的，因为工作目录的文件几乎会被多次添加到暂存区，这时一个文件会对应多个blob对象。</p>
<h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><p>仓库的<code>.git</code>目录下面有一个文件，它就是大名鼎鼎的暂存区。<br>是的，暂存区并不是一块区域，只是一个文件，确切的说，是一个索引文件。<br>它保存了项目结构、文件名、时间戳以及blob对象的引用。<br>工作区的文件和blob对象之间就是通过这个索引文件关联起来的。</p>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>还记得我们在<code>文件改动全量保存</code>小节里讲到，git鱼和熊掌想兼得么？<br>又想全量保存，不降低检索和切换速度，又想尽可能压榨体积。git是怎么做到的呢？<br>git会定期或者在推送到远端之前对git对象进行打包处理。<br>打包的时候保存文件最新的全量版本，基于该文件的历史版本的改动则只保存diff信息。因为开发者很少会切换到较早的版本中，所以这时候效率就可以部分牺牲。<br>需要注意的是，所有的git对象都会被打包，而不仅仅是blob对象。<br>git也有一个<code>git gc</code>命令可以手动执行打包。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git gc</span></pre></td></tr><tr><td class="code"><pre><span class="line">Counting objects: <span class="number">11</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Delta compression using up to <span class="number">4</span> threads.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">9</span>/<span class="number">9</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">11</span>/<span class="number">11</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="number">11</span> (delta <span class="number">3</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span></pre></td></tr></table></figure>

<p>之前的git对象文件都不见了，<code>pack</code>文件夹多了两个文件。其中 <code>.pack</code> 后缀文件存储的就是打包前git对象文件的实际内容。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/info/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/info/packs</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/pack/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/pack/pack-99b4704a207ea3cc4924c9f0febb6ea45d4cdfd2.idx</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="title">.git/objects/pack/pack-99b4704a207ea3cc4924c9f0febb6ea45d4cdfd2.pack</span></span></pre></td></tr></table></figure>

<p>只能说，<code>git gc</code>的语义化不够好。它的功能不仅仅是垃圾回收，还有打包。</p>
<blockquote>
<p>作者：veedrin</p>
<p>来源：<a href="https://github.com/veedrin/horseshoe/blob/master/git/add.md" target="_blank" rel="noopener">https://github.com/veedrin/horseshoe/blob/master/git/add.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>动态代理（AOP）使用及实现原理分析</title>
    <url>/2019/12/26/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%88AOP%EF%BC%89%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="一、什么是代理？"><a href="#一、什么是代理？" class="headerlink" title="一、什么是代理？"></a>一、什么是代理？</h1><p>代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。</p>
<a id="more"></a>

<p>代理模式UML图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190830132920-220f2.png" alt="img"></p>
<p>简单结构示意图：</p>
<p><img src="http://image.winrains.cn/2019/08/20190830132921-94ede.png" alt="img"></p>
<p>为了保持行为的一致性，代理类和委托类通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。通过代理类这中间一层，能有效控制对委托类对象的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。Java 动态代理机制以巧妙的方式近乎完美地实践了代理模式的设计理念。</p>
<h1 id="二、Java-动态代理类"><a href="#二、Java-动态代理类" class="headerlink" title="二、Java 动态代理类"></a>二、Java 动态代理类</h1><p>Java动态代理类位于java.lang.reflect包下，一般主要涉及到以下两个类：<br>(1)Interface InvocationHandler：该接口中仅定义了一个方法</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> object invoke(Object obj,<span class="function"><span class="keyword">Method</span> <span class="title">method</span>, <span class="title">Object</span>[] <span class="title">args</span>)</span></span></pre></td></tr></table></figure>

<p>在实际使用时，第一个参数obj一般是指代理类，method是被代理的方法，如上例中的request()，args为该方法的参数数组。这个抽象方法在代理类中动态实现。<br>(2)Proxy：该类即为动态代理类，其中主要包含以下内容：<br>protected Proxy(InvocationHandler h)：构造函数，用于给内部的h赋值。<br>static Class getProxyClass(<br>ClassLoader loader,<br>Class[] interfaces)：获得一个代理类，其中loader是类装载器，interfaces是真实类所拥有的全部接口的数组。<br>static Object newProxyInstance(ClassLoaderloader, Class[] interfaces,InvocationHandler h)：返回代理类的一个实例，返回后的代理类可以当作被代理类使用(可使用被代理类的在Subject接口中声明过的方法)<br>所谓DynamicProxy是这样一种class：它是在运行时生成的class，在生成它时你必须提供一组interface给它，然后该class就宣称它实现了这些interface。你当然可以把该class的实例当作这些interface中的任何一个来用。当然，这个DynamicProxy其实就是一个Proxy，它不会替你作实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工作。<br>在使用动态代理类时，我们必须实现InvocationHandler接口<br>通过这种方式，被代理的对象(RealSubject)可以在运行时动态改变，需要控制的接口(Subject接口)可以在运行时改变，控制的方式(DynamicSubject类)也可以动态改变，从而实现了非常灵活的动态代理关系。<br>动态代理步骤：</p>
<ol>
<li>创建一个实现接口InvocationHandler的类，它必须实现invoke方法</li>
<li>创建被代理的类以及接口</li>
<li>通过Proxy的静态方法</li>
</ol>
<p>newProxyInstance(ClassLoaderloader,Class[]interfaces,InvocationHandler h)创建一个代理</p>
<ol>
<li>通过代理调用方法</li>
</ol>
<h1 id="三、JDK的动态代理怎么使用？"><a href="#三、JDK的动态代理怎么使用？" class="headerlink" title="三、JDK的动态代理怎么使用？"></a>三、JDK的动态代理怎么使用？</h1><p>1、需要动态代理的接口：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jiankunking;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 需要动态代理的接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 你好</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * @param name</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * @return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> SayHello(<span class="keyword">String</span> name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 再见</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * @return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> SayGoodBye();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>2、需要代理的实际对象</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">package jiankunking;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>实际对象</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> */</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>你好</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param name</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public <span class="built_in">String</span> SayHello(<span class="built_in">String</span> name) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>再见</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public <span class="built_in">String</span> SayGoodBye() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">" good bye "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>3、调用处理器实现类（有木有感觉这里就是传说中的AOP啊）</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">package jiankunking;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>调用处理器实现类</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>每次生成动态代理类对象时都需要指定一个实现了该接口的调用处理器对象</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> */</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">InvocationHandlerImpl</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>这个就是我们要代理的真实对象</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    private <span class="built_in">Object</span> subject;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>构造方法，给我们要代理的真实对象赋初值</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param subject</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public InvocationHandlerImpl(<span class="built_in">Object</span> subject) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.subject = subject;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>该方法负责集中处理动态代理类上的所有方法调用。</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param proxy  代理类实例</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param method 被调用的方法对象</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param args   调用参数</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@throws Throwable</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public <span class="built_in">Object</span> invoke(<span class="built_in">Object</span> proxy, Method method, <span class="built_in">Object</span>[] args) throws Throwable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//在代理真实对象前我们可以添加一些自己的操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"在调用之前，我要干点啥呢？"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Method:"</span> + method);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">Object</span> returnValue = method.invoke(subject, args);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//在代理真实对象后我们也可以添加一些自己的操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"在调用之后，我要干点啥呢？"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> returnValue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>4、测试</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package jiankunking;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.lang.reflect.Proxy;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 动态代理演示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> DynamicProxyDemonstration &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//代理的真实对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Subject realSubject = <span class="keyword">new</span> <span class="constructor">RealSubject()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 即：要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        InvocationHandler handler = <span class="keyword">new</span> <span class="constructor">InvocationHandlerImpl(<span class="params">realSubject</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ClassLoader loader = handler.get<span class="constructor">Class()</span>.get<span class="constructor">ClassLoader()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Class&lt;?&gt;<span class="literal">[]</span> interfaces = realSubject.get<span class="constructor">Class()</span>.get<span class="constructor">Interfaces()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Subject subject = (Subject) <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(<span class="params">loader</span>, <span class="params">interfaces</span>, <span class="params">handler</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"动态代理对象的类型："</span> + subject.get<span class="constructor">Class()</span>.get<span class="constructor">Name()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String hello = subject.<span class="constructor">SayHello(<span class="string">"jiankunking"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(hello);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//        String goodbye = subject.SayGoodBye();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//        System.out.println(goodbye);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>5、输出结果如下：</p>
<p><img src="http://image.winrains.cn/2019/08/20190830132921-616a4.png" alt="img"></p>
<h1 id="四、动态代理怎么实现的？"><a href="#四、动态代理怎么实现的？" class="headerlink" title="四、动态代理怎么实现的？"></a>四、动态代理怎么实现的？</h1><p>从使用代码中可以看出，关键点在：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Subject subject = (Subject) <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(<span class="params">loader</span>, <span class="params">interfaces</span>, <span class="params">handler</span>)</span>;</span></pre></td></tr></table></figure>

<p>通过跟踪提示代码可以看出：当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用。<br>也就是说，当代码执行到：subject.SayHello(“jiankunking”)这句话时，会自动调用InvocationHandlerImpl的invoke方法。这是为啥呢？</p>
<blockquote>
<p>下面是代码跟分析的过程，不想看的朋友可以直接看结论</p>
</blockquote>
<p>以下代码来自:JDK1.8.0_92<br>既然生成代理对象是用的Proxy类的静态方newProxyInstance，那么我们就去它的源码里看一下它到底都做了些什么？</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Returns </span>an<span class="markdown"> instance of </span>a<span class="markdown"> proxy class for </span>the<span class="markdown"> specified interfaces</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>that dispatches method invocations to </span>the<span class="markdown"> specified invocation</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>handler.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> *</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>&#123;@code Proxy.newProxyInstance&#125; throws</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#123;@code IllegalArgumentException&#125; for </span>the<span class="markdown"> same reasons that</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#123;@code Proxy.getProxyClass&#125; does.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> *</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param   loader </span>the<span class="markdown"> class loader to define </span>the<span class="markdown"> proxy class</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param   interfaces </span>the<span class="markdown"> list of interfaces for </span>the<span class="markdown"> proxy class</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>to implement</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param   h </span>the<span class="markdown"> invocation handler to dispatch method invocations to</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@return  </span>a<span class="markdown"> proxy instance with </span>the<span class="markdown"> specified invocation handler of </span>a</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>proxy class that is defined by </span>the<span class="markdown"> specified class loader</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>and that implements </span>the<span class="markdown"> specified interfaces</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@throws  IllegalArgumentException if any of </span>the<span class="markdown"> restrictions on </span>the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>parameters that may be passed to &#123;@code getProxyClass&#125;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span></span>are<span class="markdown"> violated</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@throws  SecurityException if </span>a<span class="markdown"> security manager, <span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span></span>s<span class="xml"><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span>, is present</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>and any of </span>the<span class="markdown"> following conditions is met:</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span> </span>the<span class="markdown"> given &#123;@code loader&#125; is &#123;@code null&#125; and</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span></span>the<span class="markdown"> caller's class loader is not &#123;@code null&#125; and </span>the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>invocation of &#123;@link SecurityManager#checkPermission</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>s.checkPermission&#125; with</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>&#123;@code RuntimePermission("getClassLoader")&#125; permission</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>denies access;<span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span> for each proxy interface, &#123;@code intf&#125;,</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span></span>the<span class="markdown"> caller's class loader is not </span>the<span class="markdown"> same as or </span>an</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>ancestor of </span>the<span class="markdown"> class loader for &#123;@code intf&#125; and</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>invocation of &#123;@link SecurityManager#checkPackageAccess</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>s.checkPackageAccess()&#125; denies access to &#123;@code intf&#125;;<span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span> any of </span>the<span class="markdown"> given proxy interfaces is non-public and </span>the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>caller class is not in </span>the<span class="markdown"> same &#123;@linkplain Package runtime package&#125;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>as </span>the<span class="markdown"> non-public interface and </span>the<span class="markdown"> invocation of</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>&#123;@link SecurityManager#checkPermission s.checkPermission&#125; with</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>&#123;@code ReflectPermission("newProxyInPackage.&#123;package name&#125;")&#125;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *               </span>permission denies access.<span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@throws  NullPointerException if </span>the<span class="markdown"> &#123;@code interfaces&#125; array</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>argument or any of its elements </span>are<span class="markdown"> &#123;@code null&#125;, or</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>if </span>the<span class="markdown"> invocation handler, &#123;@code h&#125;, is</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *          </span>&#123;@code null&#125;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> */</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="built_in">Object</span> newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throws IllegalArgumentException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 检查h 不为空，否则抛异常</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Objects.requireNonNull(h);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 获得与指定类装载器和一组接口相关的代理类类型对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 通过反射获取构造函数对象并生成代理类实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 获取代理对象的构造方法（也就是$Proxy0(InvocationHandler h)）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                public Void run() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    cons.setAccessible(<span class="keyword">true</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 生成代理类的实例并把InvocationHandlerImpl的实例传给它的构造方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="built_in">Object</span>[] &#123; h &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Throwable t = e.getCause();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (t instanceof RuntimeException) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们再进去getProxyClass0方法看一下：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Generate a proxy class. Must call the checkProxyAccess method to perform</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * permission checks before calling this.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">Class</span>&lt;?&gt; getProxyClass0(ClassLoader loader, <span class="keyword">Class</span>&lt;?&gt;... interfaces) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// If the proxy class defined by the given loader implementing</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>真相还是没有来到，继续，看一下 proxyClassCache</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * a cache of proxy classes</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, <span class="keyword">Class</span>&lt;?&gt;[], <span class="keyword">Class</span>&lt;?&gt;&gt; proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span></pre></td></tr></table></figure>

<p>奥，原来用了一下缓存啊<br>那么它对应的get方法啥样呢？</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Look-up </span>the<span class="markdown"> value through </span>the<span class="markdown"> cache. This always evaluates </span>the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#123;@code subKeyFactory&#125; function and optionally evaluates</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#123;@code valueFactory&#125; function if there is no entry in </span>the<span class="markdown"> cache for given</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>pair of (key, subKey) or </span>the<span class="markdown"> entry has already been cleared.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> *</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param key</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *            </span>possibly null key</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param parameter</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *            </span>parameter used together with key to create sub-key and value</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *            </span>(</span>should<span class="markdown"> not be null)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@return </span>the<span class="markdown"> cached value (never null)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@throws NullPointerException</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *             </span>if &#123;@code parameter&#125; passed in or &#123;@code sub-key&#125; calculated</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *             </span>by &#123;@code subKeyFactory&#125; or &#123;@code value&#125; calculated by</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *             </span>&#123;@code valueFactory&#125; is null.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> */</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public V <span class="keyword">get</span>(K key, P parameter) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Objects.requireNonNull(parameter);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    expungeStaleEntries();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">Object</span> cacheKey = CacheKey.valueOf(key, refQueue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// lazily install the 2nd level valuesMap for the particular cacheKey</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ConcurrentMap&lt;<span class="built_in">Object</span>, Supplier&lt;V&gt;&gt; valuesMap = map.<span class="keyword">get</span>(cacheKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (valuesMap == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// putIfAbsent这个方法在key不存在的时候加入一个值,如果key存在就不放入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ConcurrentMap&lt;<span class="built_in">Object</span>, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                valuesMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (oldValuesMap != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            valuesMap = oldValuesMap;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// subKey from valuesMap</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">Object</span> subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.<span class="keyword">get</span>(subKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Factory <span class="keyword">factory</span> = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// supplier might be a Factory or a CacheValue&lt;V&gt; instance</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            V value = supplier.<span class="keyword">get</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// else no supplier in cache</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// or a supplier that returned null (could be a cleared CacheValue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// or a Factory that wasn't successful in installing the CacheValue)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// lazily construct a Factory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">factory</span> == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">factory</span> = <span class="keyword">new</span> Factory(key, parameter, subKey, valuesMap);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            supplier = valuesMap.putIfAbsent(subKey, <span class="keyword">factory</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// successfully installed Factory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                supplier = <span class="keyword">factory</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// else retry with winning supplier</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (valuesMap.replace(subKey, supplier, <span class="keyword">factory</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// successfully replaced</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// cleared CacheEntry / unsuccessful Factory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// with our Factory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                supplier = <span class="keyword">factory</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// retry with current supplier</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                supplier = valuesMap.<span class="keyword">get</span>(subKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们可以看到它调用了 supplier.get(); 获取动态代理类，其中supplier是Factory,这个类定义在WeakCach的内部。<br>来瞅瞅，get里面又做了什么？</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> synchronized V <span class="title">get</span>(<span class="params"></span>)</span> &#123; <span class="comment">// serialize access</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// re-check</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.<span class="keyword">get</span>(subKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (supplier != <span class="keyword">this</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// something changed while we were waiting:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// might be that we were replaced by a CacheValue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// or were removed because of failure -&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// return null to signal WeakCache.get() to retry</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// the loop</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// else still us (supplier == this)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// create new value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    V <span class="keyword">value</span> = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">value</span> = Objects.requireNonNull(valueFactory.apply(key, parameter));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="literal">null</span>) &#123; <span class="comment">// remove us on failure</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            valuesMap.<span class="keyword">remove</span>(subKey, <span class="keyword">this</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// the only path to reach here is with non-null value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    assert <span class="keyword">value</span> != <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// wrap value with CacheValue (WeakReference)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    CacheValue&lt;V&gt; cacheValue = <span class="keyword">new</span> CacheValue&lt;&gt;(<span class="keyword">value</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// try replacing us with CacheValue (this should always succeed)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (valuesMap.replace(subKey, <span class="keyword">this</span>, cacheValue)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// put also in reverseMap</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        reverseMap.put(cacheValue, Boolean.TRUE);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Should not reach here"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// successfully replaced us with new CacheValue -&gt; return the value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// wrapped by it</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">value</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>发现重点还是木有出现，但我们可以看到它调用了valueFactory.apply(key, parameter)方法：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * A factory function that generates, defines and returns the proxy class</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * given the ClassLoader and array of interfaces.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> ProxyClassFactory <span class="keyword">implements</span> BiFunction&lt;ClassLoader, <span class="keyword">Class</span>&lt;?&gt;[], <span class="keyword">Class</span>&lt;?&gt;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// prefix for all proxy class names</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// next number to use for generation of unique proxy class names</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">Class</span>&lt;?&gt; apply(ClassLoader loader, <span class="keyword">Class</span>&lt;?&gt;[] interfaces) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Map&lt;<span class="keyword">Class</span>&lt;?&gt;, <span class="keyword">Boolean</span>&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">Class</span>&lt;?&gt; intf : interfaces) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * Verify that the class loader resolves the name of this</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * interface to the same Class object.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">Class</span>&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                interfaceClass = <span class="keyword">Class</span>.forName(intf.getName(), <span class="keyword">false</span>, loader);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (interfaceClass != intf) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(intf + <span class="string">" is not visible from class loader"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * Verify that the Class object actually represents an</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * interface.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * Verify that this interface is not a duplicate.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (interfaceSet.put(interfaceClass, <span class="keyword">Boolean</span>.<span class="keyword">TRUE</span>) != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"repeated interface: "</span> + interfaceClass.getName());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String proxyPkg = <span class="keyword">null</span>; <span class="comment">// package to define proxy class in</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> accessFlags = Modifier.<span class="keyword">PUBLIC</span> | Modifier.<span class="keyword">FINAL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * Record the package of a non-public proxy interface so that the</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * proxy class will be defined in the same package. Verify that all</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * non-public proxy interfaces are in the same package.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">Class</span>&lt;?&gt; intf : interfaces) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> flags = intf.getModifiers();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                accessFlags = Modifier.<span class="keyword">FINAL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                String name = intf.getName();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    proxyPkg = pkg;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"non-public interfaces from different packages"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * Choose a name for the proxy class to generate.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String proxyName = proxyPkg + proxyClassNamePrefix + num;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * Generate the specified proxy class.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> defineClass0(loader, proxyName, proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * A ClassFormatError here means that (barring bugs in the proxy</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * class generation code) there was some other invalid aspect of</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * the arguments supplied to the proxy class creation (such as</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             * virtual machine limitations exceeded).</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过看代码终于找到了重点：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成字节码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">byte<span class="literal">[]</span> proxyClassFile = <span class="module-access"><span class="module"><span class="identifier">ProxyGenerator</span>.</span></span>generate<span class="constructor">ProxyClass(<span class="params">proxyName</span>, <span class="params">interfaces</span>, <span class="params">accessFlags</span>)</span>;</span></pre></td></tr></table></figure>

<p>那么接下来我们也使用测试一下，使用这个方法生成的字节码是个什么样子：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package jiankunking;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import sun.misc.ProxyGenerator;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.File;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.FileNotFoundException;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.FileOutputStream;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.io.IOException;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.lang.reflect.Proxy;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 动态代理演示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> DynamicProxyDemonstration &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//代理的真实对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Subject realSubject = <span class="keyword">new</span> <span class="constructor">RealSubject()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 即：要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        InvocationHandler handler = <span class="keyword">new</span> <span class="constructor">InvocationHandlerImpl(<span class="params">realSubject</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ClassLoader loader = handler.get<span class="constructor">Class()</span>.get<span class="constructor">ClassLoader()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Class<span class="literal">[]</span> interfaces = realSubject.get<span class="constructor">Class()</span>.get<span class="constructor">Interfaces()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         * 该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Subject subject = (Subject) <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(<span class="params">loader</span>, <span class="params">interfaces</span>, <span class="params">handler</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"动态代理对象的类型："</span>+subject.get<span class="constructor">Class()</span>.get<span class="constructor">Name()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String hello = subject.<span class="constructor">SayHello(<span class="string">"jiankunking"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(hello);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 将生成的字节码保存到本地，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        create<span class="constructor">ProxyClassFile()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> static void create<span class="constructor">ProxyClassFile()</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String name = <span class="string">"ProxySubject"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        byte<span class="literal">[]</span> data = <span class="module-access"><span class="module"><span class="identifier">ProxyGenerator</span>.</span></span>generate<span class="constructor">ProxyClass(<span class="params">name</span>,<span class="params">new</span> Class[]&#123;Subject.<span class="params">class</span>&#125;)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        FileOutputStream out =null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            out = <span class="keyword">new</span> <span class="constructor">FileOutputStream(<span class="params">name</span>+<span class="string">".class"</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println((<span class="keyword">new</span> <span class="constructor">File(<span class="string">"hello"</span>)</span>).get<span class="constructor">AbsolutePath()</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            out.write(data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.print<span class="constructor">StackTrace()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; catch (IOException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e.print<span class="constructor">StackTrace()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;finally &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(null!=out) <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                out.close<span class="literal">()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; catch (IOException e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                e.print<span class="constructor">StackTrace()</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看一下这里代理对象的类型：</p>
<p><img src="http://image.winrains.cn/2019/08/20190830132922-3ea54.png" alt="img"></p>
<p>我们用jd-jui 工具将生成的字节码反编译：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jiankunking.Subject;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> final <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">Proxy</span></span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Subject</span></span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> ProxySubject(InvocationHandler paramInvocationHandler) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">super</span>(paramInvocationHandler);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> final boolean equals(Object paramObject) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> ((Boolean) <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="type">Object</span>[] &#123; paramObject &#125;)).booleanValue();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Error | RuntimeException localError) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> localError;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> final <span class="keyword">String</span> SayGoodBye() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> (<span class="keyword">String</span>) <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Error | RuntimeException localError) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> localError;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> final <span class="keyword">String</span> SayHello(<span class="keyword">String</span> paramString) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> (<span class="keyword">String</span>) <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m4, <span class="keyword">new</span> <span class="type">Object</span>[] &#123; paramString &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Error | RuntimeException localError) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> localError;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> final <span class="keyword">String</span> toString() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> (<span class="keyword">String</span>) <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m2, <span class="literal">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Error | RuntimeException localError) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> localError;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> final int hashCode() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> ((Integer) <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m0, <span class="literal">null</span>)).intValue();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Error | RuntimeException localError) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> localError;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UndeclaredThrowableException</span>(localThrowable);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">new</span> <span class="type">Class</span>[] &#123; Class.forName(<span class="string">"java.lang.Object"</span>) &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m3 = Class.forName(<span class="string">"jiankunking.Subject"</span>).getMethod(<span class="string">"SayGoodBye"</span>, <span class="keyword">new</span> <span class="type">Class</span>[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m4 = Class.forName(<span class="string">"jiankunking.Subject"</span>).getMethod(<span class="string">"SayHello"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">new</span> <span class="type">Class</span>[] &#123; Class.forName(<span class="string">"java.lang.String"</span>) &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> <span class="type">Class</span>[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> <span class="type">Class</span>[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException localNoSuchMethodException) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchMethodError</span>(localNoSuchMethodException.getMessage());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException localClassNotFoundException) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoClassDefFoundError</span>(localClassNotFoundException.getMessage());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这就是最终真正的代理类，它继承自Proxy并实现了我们定义的Subject接口，也就是说：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Subject subject = (Subject) <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(<span class="params">loader</span>, <span class="params">interfaces</span>, <span class="params">handler</span>)</span>;</span></pre></td></tr></table></figure>

<p>这里的subject实际是这个类的一个实例，那么我们调用它的：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">String</span> SayHello(<span class="keyword">String</span> paramString)</span></pre></td></tr></table></figure>

<p>就是调用我们定义的InvocationHandlerImpl的 invoke方法：</p>
<p><img src="http://image.winrains.cn/2019/08/20190830132923-38112.png" alt="img"></p>
<blockquote>
<p>上面是代码跟分析的过程，不想看的朋友可以直接看结论</p>
</blockquote>
<h1 id="五、结论"><a href="#五、结论" class="headerlink" title="五、结论"></a>五、结论</h1><p>到了这里，终于解答了：<br>subject.SayHello(“jiankunking”)这句话时，为什么会自动调用InvocationHandlerImpl的invoke方法？<br>因为JDK生成的最终真正的代理类，它继承自Proxy并实现了我们定义的Subject接口，在实现Subject接口方法的内部，通过反射调用了InvocationHandlerImpl的invoke方法。<br>通过分析代码可以看出Java 动态代理，具体有如下四步骤：</p>
<ol>
<li>通过实现 InvocationHandler 接口创建自己的调用处理器；</li>
<li>通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；</li>
<li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li>
<li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li>
</ol>
<p>演示代码下载： <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fjiankunking%2FDynamicProxyDemo">github.com/jiankunking…</a></p>
<blockquote>
<p>作者：衣舞晨风</p>
<p>来源：<a href="https://juejin.im/post/5d31c1b7f265da1b9421845d" target="_blank" rel="noopener">https://juejin.im/post/5d31c1b7f265da1b9421845d</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL探索（8）：InnoDB的事务</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%888%EF%BC%89%EF%BC%9AInnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>事务是数据库最为重要的机制之一，凡是使用过数据库的人，都了解数据库的事务机制，也对ACID四个基本特性如数家珍。但是聊起事务或者ACID的底层实现原理，往往言之不详，不明所以。所以，今天我们就一起来分析和探讨InnoDB的事务机制，希望能建立起对事务底层实现原理的具体了解。</p>
<a id="more"></a>

<p><img src="http://image.winrains.cn/2019/10/20191031175432-e26fb.jpeg" alt="img"></p>
<p>事务的四大特性</p>
<p>数据库事务具有ACID四大特性。ACID是以下4个词的缩写：</p>
<ul>
<li>原子性(atomicity) ：事务最小工作单元，要么全成功，要么全失败 。</li>
<li>一致性(consistency)： 事务开始和结束后，数据库的完整性不会被破坏 。</li>
<li>隔离性(isolation) ：不同事务之间互不影响，四种隔离级别为RU（读未提交）、RC（读已提交）、RR（可重复读）、SERIALIZABLE （串行化）。</li>
<li>持久性(durability) ：事务提交后，对数据的修改是永久性的，即使系统故障也不会丢失 。</li>
</ul>
<p>下面，我们就以一个具体实例来介绍数据库事务的原理，并介绍InnoDB是如何实现ACID四大特性的。</p>
<h2 id="示例介绍"><a href="#示例介绍" class="headerlink" title="示例介绍"></a>示例介绍</h2><p>我们首先来看一下具体的示例。大家可以自己亲自试验一下，这样理解和记忆都会更加深刻。<br>首先，使用如下的SQL语句创建两张表，分别是goods和trade，代表货物和交易。并向goods表中插入一条记录，id为1的货物数量为10。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> goods (<span class="keyword">id</span> <span class="built_in">INT</span>, <span class="keyword">num</span> <span class="built_in">INT</span>, PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> trade (<span class="keyword">id</span> <span class="built_in">INT</span>, goods_id <span class="built_in">INT</span>, user_id <span class="built_in">INT</span>, PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> goods <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">10</span>);</span></pre></td></tr></table></figure>

<p>然后打开终端，连接数据库，开启会话一，先用BEGIN显示开启一个事务。会话一先将goods表中id为1的货物的数量减一，然后向trade表中添加一笔交易的记录，最后使用COMMIT显示提交事务。<br>而会话二则先查询goods表中id为1的货物数量，然后向trade表中添加一笔交易记录，接着更新goods表中id为1的货物的数量，最后使用ROLLBACK进行事务的回滚。其中，两个会话中执行的具体语句和先后顺序如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175433-821a1.jpeg" alt="img"></p>
<p>示例具体语句和执行顺序</p>
<p>这个示例可以体现数据库事务的很多特性，我们一一来介绍。首先会话一的操作2更新了id为1的货物的数量，但是会话二的操作5读出来的数量仍然是10，这体现了事务的隔离性，使用InnoDB的<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483698&idx=1&sn=3654042755c7ea0922e5d5b462930946&chksm=fc04c552cb734c443f771eb2075cd4d4ce85df85105805667cc4cf51a67ceed2f9ebdf1a8cde&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">多版本控制机制</a>实现。<br>会话二的操作7也要更新同种货物的数量，此时因为会话一的操作2已经更新了该货物的数量，InnoDB已经锁住了该记录的行锁，所以操作7会被阻塞，直到会话一COMMIT。但是会话一的操作4和会话二的操作7都是向trade表中插入记录，后者却不会因为前者而阻塞，因为二者插入的不是同一行记录。锁机制是一种常见的并发控制机制，它和多版本控制机制一起实现了InnoDB事务的隔离性，关于InnoDB锁相关的具体内容可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483694&idx=1&sn=671ad369f67441c7d1572110066d5695&chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB锁的类型和状态查询</a>和<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483702&idx=1&sn=669fb9f413db0cc744bdb5b9ec8f725e&chksm=fc04c556cb734c40b3c90a55868619b8ca1f3e1f8763be2d6e7f0568d7c992409937c33b7e10&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB行锁算法</a>。</p>
<p>会话一事务最终使用COMMIT提交了事务而会话二事务则使用ROLLBACK回滚了整个事务，这体现了事务的原子性。即事务的一系列操作要么全部执行(COMMIT)，要么就全部不执行(ROLLBACK)，不存在只执行一部分的情况。InnoDB使用事务日志系统来实现事务的原子性。这里有的同学就会问了，如果中途连接断开或者Server Crash会怎么样。能怎么样，直接自动回滚呗。</p>
<p>一旦会话一使用COMMIT操作提交事务成功后，那么数据一定会被写入到数据库中并持久的存储起来，这体现了事务的持久性。InnoDB使用<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483683&idx=1&sn=5225ab3481c38bb57297a36df8e62bce&chksm=fc04c543cb734c556574f9e5331ab70f0c8239d70197f70015f58d4ac3f5c4d0b1260f0478e3&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">redo log机制</a>来实现事务的持久性。</p>
<p>而事务的一致性比较难以理解，简单的讲在事务开始时，此时数据库有一种状态，这个状态是所有的MySQL对象处于一致的状态，例如数据库完整性约束正确，日志状态一致等。当事务提交后，这时数据库又有了一个新的状态，不同的数据，不同的索引，不同的日志等。但此时，约束，数据，索引，日志等MySQL各种状态还是要保持一致性。 也就是说数据库从一个一致性的状态，变到另一个一致性的状态。事务执行后，并没有破坏数据库的完整性约束。</p>
<p>下面我们就来详细讲解一下上述示例涉及的事务的ACID特性的具体实现原理。<strong>总结来说，事务的隔离性由多版本控制机制和锁实现，而原子性、一致性和持久性通过InnoDB的redo log、undo log和Force Log at Commit机制来实现</strong>。</p>
<h2 id="原子性，持久性和一致性"><a href="#原子性，持久性和一致性" class="headerlink" title="原子性，持久性和一致性"></a>原子性，持久性和一致性</h2><p>原子性，持久性和一致性主要是通过redo log、undo log和Force Log at Commit机制机制来完成的。redo log用于在崩溃时恢复数据，undo log用于对事务的影响进行撤销，也可以用于多版本控制。而Force Log at Commit机制保证事务提交后redo log日志都已经持久化。<br>开启一个事务后，用户可以使用COMMIT来提交，也可以用ROLLBACK来回滚。其中COMMIT或者ROLLBACK执行成功之后，数据一定是会被全部保存或者全部回滚到最初状态的，这也体现了事务的原子性。但是也会有很多的异常情况，比如说事务执行中途连接断开，或者是执行COMMIT或者ROLLBACK时发生错误，Server Crash等，此时数据库会自动进行回滚或者重启之后进行恢复。</p>
<p>我们先来看一下redo log的原理，redo log顾名思义，就是重做日志，每次数据库的SQL操作导致的数据变化它都会记录一下，<strong>具体来说，redo log是物理日志，记录的是数据库页的物理修改操作</strong>。如果数据发生了丢失，数据库可以根据redo log进行数据恢复。</p>
<p>InnoDB通过Force Log at Commit机制实现事务的持久性，即当事务COMMIT时，必须先将该事务的所有日志都写入到redo log文件进行持久化之后，COMMIT操作才算完成。<br>当事务的各种SQL操作执行时，即会在缓冲区中修改数据，也会将对应的redo log写入它所属的缓存。当事务执行COMMIT时，与该事务相关的redo log缓冲必须都全部刷新到磁盘中之后COMMIT才算执行成功。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175433-e6413.png" alt="img"></p>
<p>数据库日志和数据落盘机制</p>
<p>redo log写入磁盘时，必须进行一次操作系统的fsync操作，防止redo log只是写入了操作系统的磁盘缓存中。参数innodb_flush_log_at_trx_commit可以控制redo log日志刷新到磁盘的策略，它的具体作用可以查阅<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483683&idx=1&sn=5225ab3481c38bb57297a36df8e62bce&chksm=fc04c543cb734c556574f9e5331ab70f0c8239d70197f70015f58d4ac3f5c4d0b1260f0478e3&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB的磁盘文件及落盘机制</a></p>
<p>redo log全部写入磁盘后事务就算COMMIT成功了，但是此时事务修改的数据还在内存的缓冲区中，称其为脏页，这些数据会依据检查点(CheckPoint)机制择时刷新到磁盘中，然后删除相应的redo log，但是如果在这个过程中数据库Crash了，那么数据库重启时，会依据redo log file将那些还在内存中未更新到磁盘上的数据进行恢复。</p>
<p>数据库为了提高性能，数据页在内存修改后并不是每次都会刷到磁盘上。而是引入checkpoint机制，择时将数据页落盘，checkpoint记录之前的数据页保证一定落盘了，这样相关的redo log就没有用了(由于InnoDB redo log file循环使用，这时这部分日志就可以被覆盖)，checkpoint之后的数据页有可能落盘，也有可能没有落盘，所以checkpoint之后的redo log file在崩溃恢复的时候还是需要被使用的。InnoDB会依据脏页的刷新情况，定期推进checkpoint，从而减少数据库崩溃恢复的时间。检查点的信息在第一个日志文件的头部。</p>
<p>数据库崩溃重启后需要从redo log中把未落盘的脏页数据恢复出来，重新写入磁盘，保证用户的数据不丢失。当然，在崩溃恢复中还需要回滚没有提交的事务。由于回滚操作需要undo日志的支持，undo日志的完整性和可靠性需要redo日志来保证，所以崩溃恢复先做redo恢复数据，然后做undo回滚。</p>
<p>在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175434-53e31.jpeg" alt="img"></p>
<p>数据和回滚日志的逻辑存储结构.jpg</p>
<p>undo log的存储不同于redo log，它存放在数据库内部的一个特殊的段(segment)中，这个段称为回滚段。回滚段位于共享表空间中。undo段中的以undo page为更小的组织单位。undo page和存储数据库数据和索引的页类似。因为redo log是物理日志，记录的是数据库页的物理修改操作。所以undo log的写入也会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。如上图所示，表空间中有回滚段和叶节点段和非叶节点段，而三者都有对应的页结构。</p>
<p>我们再来总结一下数据库事务的整个流程，如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175434-1e1c3.jpeg" alt="img"></p>
<p>事务的相关流程</p>
<p>事务进行过程中，每次sql语句执行，都会记录undo log和redo log，然后更新数据形成脏页，然后redo log按照时间或者空间等条件进行落盘，undo log和脏页按照checkpoint进行落盘，落盘后相应的redo log就可以删除了。此时，事务还未COMMIT，如果发生崩溃，则首先检查checkpoint记录，使用相应的redo log进行数据和undo log的恢复，然后查看undo log的状态发现事务尚未提交，然后就使用undo log进行事务回滚。事务执行COMMIT操作时，会将本事务相关的所有redo log都进行落盘，只有所有redo log落盘成功，才算COMMIT成功。然后内存中的数据脏页继续按照checkpoint进行落盘。如果此时发生了崩溃，则只使用redo log恢复数据。</p>
<h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>InnoDB事务的隔离性主要通过多版本控制机制和锁机制实现，具体可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483698&idx=1&sn=3654042755c7ea0922e5d5b462930946&chksm=fc04c552cb734c443f771eb2075cd4d4ce85df85105805667cc4cf51a67ceed2f9ebdf1a8cde&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">多版本控制</a>，<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483694&idx=1&sn=671ad369f67441c7d1572110066d5695&chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB锁的类型和状态查询</a>和<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483702&idx=1&sn=669fb9f413db0cc744bdb5b9ec8f725e&chksm=fc04c556cb734c40b3c90a55868619b8ca1f3e1f8763be2d6e7f0568d7c992409937c33b7e10&token=1535405475&lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB行锁算法</a>三篇文章。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本来想一篇文章将MySQL的事务机制讲明白，写完自己读了一遍，还是发现内容有些晦涩难懂，复杂的知识本来就是很难讲明白的，夫夷以近，则游者众；险以远，则至者少，希望读者以本文作为一篇指引性的文章，自己再去更加深入的地方去探秘。不过，能将复杂知识讲解的通俗简单也是一项很大的本领，文字和讲解能力还是需要提示的。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/42d4385c32bb" target="_blank" rel="noopener">https://www.jianshu.com/p/42d4385c32bb</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（7）：InnoDB行锁算法</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%887%EF%BC%89%EF%BC%9AInnoDB%E8%A1%8C%E9%94%81%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>在上一篇<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483698&idx=1&sn=3654042755c7ea0922e5d5b462930946&chksm=fc04c552cb734c443f771eb2075cd4d4ce85df85105805667cc4cf51a67ceed2f9ebdf1a8cde&token=731065842&lang=zh_CN#rd" target="_blank" rel="noopener">《InnoDB一致性非锁定读》</a>中，我们了解到InnoDB使用一致性非锁定读来避免在一般的查询操作(SELECT FOR UPDATE等除外)时使用锁。然而锁这个事情是无法避免的，数据的写入，修改和删除都需要加锁。今天我们就继续学习InnoDB锁相关的知识。</p>
<a id="more"></a>

<p>由于文章涉及的概念比较多，害怕大家看完后会骂人，有一种字我都认识，就不太懂的感觉，文章会给出一些实例和试验，依据具体案例来讲解这些概念。毕竟，实践才能出真知。</p>
<p>InnoDB存储引擎支持表锁和行锁。顾名思义，表锁是锁住整张表，行锁只是锁住某些行。InnoDB通过给索引项加锁来实现行锁，如果没有索引，则通过隐藏的聚簇索引来对记录加锁。如果操作不通过索引条件检索数据，InnoDB 则对表中的所有记录加锁，实际效果就和表锁一样。InnoDB存储引擎有3种行锁的算法，分别是：</p>
<ul>
<li>Record Lock: 单个记录上的锁</li>
<li>Gap Lock: 间隙锁，锁定一个范围，但不包括记录本上</li>
<li>Next-Key Lock: Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身</li>
</ul>
<p>如下图所示，</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175010-58b28.jpeg" alt="img"></p>
<p>三种锁算法</p>
<p>例如一个索引有10,11,13,20这四个值。InnoDB可以根据需要使用Record Lock将10，11，13，20四个索引锁住，也可以使用Gap Lock将(-∞,10)，(10,11)，(11,13)，(13,20)，(20, +∞)五个范围区间锁住。Next-Key Locking类似于上述两种锁的结合，它可以锁住的区间有为(-∞,10]，(10,11]，(11,13]，(13,20]，(20, +∞)，可以看出它即锁定了一个范围，也会锁定记录本身。</p>
<p>InnoDB存储引擎的锁算法的一些规则如下所示，后续章节会给出对应的实验案例和详细讲解。</p>
<ul>
<li>在不通过索引条件查询时，InnoDB 会锁定表中的所有记录。所以，如果考虑性能，WHERE语句中的条件查询的字段都应该加上索引。</li>
<li>InnoDB通过索引来实现行锁，而不是通过锁住记录。因此，当操作的两条不同记录拥有相同的索引时，也会因为行锁被锁而发生等待。</li>
<li>由于InnoDB的索引机制，数据库操作使用了主键索引，InnoDB会锁住主键索引；使用非主键索引时，InnoDB会先锁住非主键索引，再锁定主键索引。</li>
<li>当查询的索引是唯一索引(不存在两个数据行具有完全相同的键值)时，InnoDB存储引擎会将Next-Key Lock降级为Record Lock，即只锁住索引本身，而不是范围。</li>
<li>InnoDB对于辅助索引有特殊的处理，不仅会锁住辅助索引值所在的范围，还会将其下一键值加上Gap LOCK。</li>
<li>InnoDB使用Next-Key Lock机制来避免Phantom Problem（幻读问题）。</li>
</ul>
<h2 id="真的了解本质吗"><a href="#真的了解本质吗" class="headerlink" title="真的了解本质吗?"></a>真的了解本质吗?</h2><p>在不通过索引条件查询时，InnoDB 会锁定表中的所有记录。大家可以登录上自己的MySQL服务器，亲自试验一下。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175011-8d9fc.jpeg" alt="img"></p>
<p>示例一</p>
<p>试验发现，会话二的查询操作真的是会发生等待。那么，这句话真的是对的吗？我们可以使用<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483694&idx=1&sn=671ad369f67441c7d1572110066d5695&chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&token=731065842&lang=zh_CN#rd" target="_blank" rel="noopener">《InnoDB锁的类型和状态查询》</a>中查询数据锁的方法查询一下，<strong>注意必须在会话二操作还在等待时进行查询，否则查询不到</strong>。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175011-a2fad.png" alt="img"></p>
<p>查询锁信息</p>
<p>其中lock_trx_id为1851的事务是会话二的事务，另一个是会话一的事务。我们可以看到两个锁都要对值为1的主键索引加锁。<em>需要注意的是，这里是对主键进行加锁</em>。二者之间的关系是怎么确定的呢?我们可以通过<code>information_schema.INNODB_LOCK_WAITS</code>中的数据确定。</p>
<p>奇怪，不是说好的锁定表中的所有记录嘛？查找了很多资料，发现<code>INNODB_LOCKS</code>的定义如下：</p>
<blockquote>
<p>The INNODB_LOCKS table contains information about each lock that an InnoDB transaction has requested but not yet acquired, and each lock that a transaction holds that is blocking another transaction.</p>
</blockquote>
<p>也就是说，这张表并不会显示所有锁的信息，而是只显示要申请却没有申请到，和已经持有锁并且阻塞其他线程的锁信息。怪不得必须在会话二进行等待时进行查询才能查得到数据。</p>
<p>因为两个会话的操作都要锁住所有的行，所以发现每次在第一行记录上就发生了锁等待。那我们使用插入语句试试。表e1的主键a的值为1-4，我们分别插入主键为1-4(当然会有主键重复问题，但是由于有锁，一直等待)的新记录，分别查询锁信息，就能看到会话一的事务对所有的主键都加了锁，也就是对所有的记录都加了锁。</p>
<h2 id="是索引，而不是记录"><a href="#是索引，而不是记录" class="headerlink" title="是索引，而不是记录"></a>是索引，而不是记录</h2><p>InnoDB存储引擎的行锁是通过锁住索引实现的，而不是记录。这是理解很多数据库锁问题的关键。</p>
<p>由于InnoDB特殊的索引机制，数据库操作使用主键索引时，InnoDB会锁住主键索引；使用非主键索引时，InnoDB会先锁住非主键索引，再锁定主键索引。不了解InnoDB索引机制的可以参考这篇<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&mid=2247483664&idx=1&sn=a4aea45edf13b367ee17539eaff4874b&chksm=fc04c570cb734c66447aec4344288025bfe6ba7d715af31dc6d60d65411cd90a05d9b02e749d&token=731065842&lang=zh_CN#rd" target="_blank" rel="noopener">文章</a></p>
<p>如下图所示，当InnoDB锁定非主键索引b时，它也会锁住其对应的主键索引，所以锁住b值为2和3的非主键索引，那么与其相关的a值为6,5的主键索引也需要被锁住。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175013-450b9.jpeg" alt="img"></p>
<p>非主键索引的加锁</p>
<p>比如说，一种常见的死锁情况一般出现在如下图所示的操作场景中。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031175013-1ca41.jpeg" alt="img"></p>
<p>示例2</p>
<p>会话一的语句使用了b上的索引，因为它是非主键索引，所以会先在b索引上添加锁，再去a索引上加锁。而会话二的语句恰恰相反，会先在索引a上加锁，再去索引b加锁。这种情况下，就可能出现死锁。</p>
<h2 id="Next-Key-Lock锁到底有什么用？"><a href="#Next-Key-Lock锁到底有什么用？" class="headerlink" title="Next-Key Lock锁到底有什么用？"></a>Next-Key Lock锁到底有什么用？</h2><p>默认隔离级别REPEATABLE-READ下，InnoDB中行锁默认使用算法Next-Key Lock，只有当查询的索引是唯一索引或主键时，InnoDB会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围。当查询的索引为辅助索引时，InnoDB则会使用Next-Key Lock进行加锁。InnoDB对于辅助索引有特殊的处理，不仅会锁住辅助索引值所在的范围，还会将其下一键值加上Gap LOCK。</p>
<p>废话不多说，我们来看一下相关的实验，先做一下准备。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> e4 (a <span class="built_in">INT</span>, b <span class="built_in">INT</span>, PRIMARY <span class="keyword">KEY</span>(a), <span class="keyword">KEY</span>(b));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">1</span>,<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">3</span>,<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">5</span>,<span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">7</span>,<span class="number">6</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">10</span>,<span class="number">8</span>;</span></pre></td></tr></table></figure>

<p>然后开启一个会话执行下面的语句。</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> e4 <span class="keyword">WHERE</span> b=<span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span></pre></td></tr></table></figure>

<p>因为通过索引b来进行查询，所以InnoDB会使用Next-Key Lock进行加锁，并且索引b是非主键索引，所以还会对主键索引a进行加锁。对于主键索引a，仅仅对值为5的索引加上Record Lock（因为之前的规则）。而对于索引b，需要加上Next-Key Lock索引，锁定的范围是(1,3]。除此之外，还会对其下一个键值加上Gap Lock，即还有一个范围为(3,6)的锁。<br>大家可以再新开一个会话，执行下面的SQL语句，会发现都会被阻塞。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> e4 <span class="keyword">WHERE</span> a = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;  <span class="comment"># 主键a被锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">4</span>,<span class="number">2</span>;   <span class="comment"># 插入行b的值为2，在锁定的(1,3]范围内</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> e4 <span class="keyword">SELECT</span> <span class="number">6</span>,<span class="number">5</span>; <span class="comment"># 插入行b的值为5，在锁定的(3,6)范围内</span></span></pre></td></tr></table></figure>

<p>InnoDB引擎采用Next-Key Lock来解决幻读问题。因为Next-Key Lock是锁住一个范围，所以就不会产生幻读问题。但是需要注意的是，InnoDB只在Repeatable Read隔离级别下使用该机制。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/7d050498d9da" target="_blank" rel="noopener">https://www.jianshu.com/p/7d050498d9da</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（6）：InnoDB一致性非锁定读</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%886%EF%BC%89%EF%BC%9AInnoDB%E4%B8%80%E8%87%B4%E6%80%A7%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB/</url>
    <content><![CDATA[<p>一致性非锁定读(consistent nonlocking read)是指InnoDB存储引擎通过多版本控制(MVVC)读取当前数据库中行数据的方式。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB会去读取行的一个快照。</p>
<a id="more"></a>

<p><img src="http://image.winrains.cn/2019/10/20191031174517-7a2e1.jpeg" alt="img"></p>
<p>一致性非锁定读示意图</p>
<p>上图直观地展现了InnoDB一致性非锁定读的机制。之所以称其为非锁定读，是因为不需要等待行上排他锁的释放。快照数据是指该行的之前版本的数据，每行记录可能有多个版本，一般称这种技术为行多版本技术。由此带来的并发控制，称之为多版本并发控制(Multi Version Concurrency Control, MVVC)。InnoDB是通过undo log来实现MVVC。undo log本身用来在事务中回滚数据，因此快照数据本身是没有额外开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。</p>
<p>一致性非锁定读是InnoDB默认的读取方式，即读取不会占用和等待行上的锁。但是并不是在每个事务隔离级别下都是采用此种方式。此外，即使都是使用一致性非锁定读，但是对于快照数据的定义也各不相同。</p>
<p>在事务隔离级别READ COMMITTED和REPEATABLE READ下，InnoDB使用一致性非锁定读。然而，对于快照数据的定义却不同。在READ COMMITTED事务隔离级别下，一致性非锁定读总是读取被锁定行的最新一份快照数据。而在REPEATABLE READ事务隔离级别下，则读取事务开始时的行数据版本。</p>
<p>我们下面举个例子来详细说明一下上述的情况。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">session</span> A</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">BEGIN</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> id = <span class="number">1</span>;</span></pre></td></tr></table></figure>

<p>我们首先在会话A中显示地开启一个事务，然后读取test表中的id为1的数据，但是事务并没有结束。于此同时，用户在开启另一个会话B，这样可以模拟并发的操作，然后对会话B做出如下的操作：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">session</span> B</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">BEGIN</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">UPDATE</span> test <span class="keyword">SET</span> id = <span class="number">3</span> <span class="keyword">WHERE</span> id = <span class="number">1</span>;</span></pre></td></tr></table></figure>

<p>在会话B的事务中，将test表中id为1的记录修改为id=3，但是事务同样也没有提交，这样id=1的行其实加了一个排他锁。由于InnoDB在READ COMMITTED和REPEATABLE READ事务隔离级别下使用一致性非锁定读，这时如果会话A再次读取id为1的记录，仍然能够读取到相同的数据。此时，READ COMMITTED和REPEATABLE READ事务隔离级别没有任何区别。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174517-65081.jpeg" alt="img"></p>
<p>会话A和会话B示意图</p>
<p>如上图所示，当会话B提交事务后，会话A再次运行<code>SELECT * FROM test WHERE id = 1</code>的SQL语句时，两个事务隔离级别下得到的结果就不一样了。<br>对于READ COMMITTED的事务隔离级别，它总是读取行的最新版本，如果行被锁定了，则读取该行版本的最新一个快照。因为会话B的事务已经提交，所以在该隔离级别下上述SQL语句的结果集是空的。<br>对于REPEATABLE READ的事务隔离级别，总是读取事务开始时的行数据，因此，在该隔离级别下，上述SQL语句仍然会获得相同的数据。</p>
<h2 id="MVVC"><a href="#MVVC" class="headerlink" title="MVVC"></a>MVVC</h2><p>我们首先来看一下wiki上对MVVC的定义：</p>
<blockquote>
<p>Multiversion concurrency control (MCC or MVCC), is a concurrency control method commonly used by database management systems to provide concurrent access to the database and in programming languages to implement transactional memory.</p>
</blockquote>
<p>由定义可知，MVVC是用于数据库提供并发访问控制的并发控制技术。<br>数据库的并发控制机制有很多，最为常见的就是锁机制。锁机制一般会给竞争资源加锁，阻塞读或者写操作来解决事务之间的竞争条件，最终保证事务的可串行化。而MVVC则引入了另外一种并发控制，它让读写操作互不阻塞，每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回，由此解决了事务的竞争条件。<br>考虑一个现实场景。管理者要查询所有用户的存款总额，假设除了用户A和用户B之外，其他用户的存款总额都为0，A、B用户各有存款1000，所以所有用户的存款总额为2000。但是在查询过程中，用户A会向用户B进行转账操作。转账操作和查询总额操作的时序图如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174517-1fed0.jpeg" alt="img"></p>
<p>转账和查询的时序图</p>
<p>如果没有任何的并发控制机制，查询总额事务先读取了用户A的账户存款，然后转账事务改变了用户A和用户B的账户存款，最后查询总额事务继续读取了转账后的用户B的账号存款，导致最终统计的存款总额多了100元，发生错误。</p>
<p>使用锁机制可以解决上述的问题。查询总额事务会对读取的行加锁，等到操作结束后再释放所有行上的锁。因为用户A的存款被锁，导致转账操作被阻塞，直到查询总额事务提交并将所有锁都释放。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174518-4a989.jpeg" alt="img"></p>
<p>使用锁机制</p>
<p>但是这时可能会引入新的问题，当转账操作是从用户B向用户A进行转账时会导致死锁。转账事务会先锁住用户B的数据，等待用户A数据上的锁，但是查询总额的事务却先锁住了用户A数据，等待用户B的数据上的锁。</p>
<p>使用MVVC机制也可以解决这个问题。查询总额事务先读取了用户A的账户存款，然后转账事务会修改用户A和用户B账户存款，查询总额事务读取用户B存款时不会读取转账事务修改后的数据，而是读取本事务开始时的数据副本(在REPEATABLE READ隔离等级下)。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174518-c3ba9.jpeg" alt="img"></p>
<p>使用MVVC机制</p>
<p>MVCC使得数据库读不会对数据加锁，普通的SELECT请求不会加锁，提高了数据库的并发处理能力。借助MVCC，数据库可以实现READ COMMITTED，REPEATABLE READ等隔离级别，用户可以查看当前数据的前一个或者前几个历史版本，保证了ACID中的I特性（隔离性)</p>
<h2 id="InnoDB的MVVC实现"><a href="#InnoDB的MVVC实现" class="headerlink" title="InnoDB的MVVC实现"></a>InnoDB的MVVC实现</h2><p>多版本并发控制仅仅是一种技术概念，并没有统一的实现标准， 其的核心理念就是数据快照，不同的事务访问不同版本的数据快照，从而实现不同的事务隔离级别。虽然字面上是说具有多个版本的数据快照，但这并不意味着数据库必须拷贝数据，保存多份数据文件，这样会浪费大量的存储空间。InnoDB通过事务的undo日志巧妙地实现了多版本的数据快照。<br>数据库的事务有时需要进行回滚操作，这时就需要对之前的操作进行undo。因此，在对数据进行修改时，InnoDB会产生undo log。当事务需要进行回滚时，InnoDB可以利用这些undo log将数据回滚到修改之前的样子。<br>根据行为的不同 undo log 分为两种 insert undo log和update undo log。<br>insert undo log 是在 insert 操作中产生的 undo log。因为 insert 操作的记录只对事务本身可见，对于其它事务此记录是不可见的，所以 insert undo log 可以在事务提交后直接删除而不需要进行 purge 操作。<br>update undo log 是 update 或 delete 操作中产生的 undo log，因为会对已经存在的记录产生影响，为了提供 MVCC机制，因此 update undo log 不能在事务提交时就进行删除，而是将事务提交时放到入 history list 上，等待 purge 线程进行最后的删除操作。<br>为了保证事务并发操作时，在写各自的undo log时不产生冲突，InnoDB采用回滚段的方式来维护undo log的并发写入和持久化。回滚段实际上是一种 Undo 文件组织方式。<br>InnoDB行记录有三个隐藏字段：分别对应该行的rowid、事务号db_trx_id和回滚指针db_roll_ptr，其中db_trx_id表示最近修改的事务的id，db_roll_ptr指向回滚段中的undo log。如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174518-74ed7.jpeg" alt="img"></p>
<p>初始状态</p>
<p>当事务2使用UPDATE语句修改该行数据时，会首先使用排他锁锁定改行，将该行当前的值复制到undo log中，然后再真正地修改当前行的值，最后填写事务ID，使用回滚指针指向undo log中修改前的行。如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174519-e14b3.jpeg" alt="img"></p>
<p>第一次修改</p>
<p>当事务3进行修改与事务2的处理过程类似，如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174519-a9e7e.jpeg" alt="img"></p>
<p>第二次修改</p>
<p>REPEATABLE READ隔离级别下事务开始后使用MVVC机制进行读取时，会将当时活动的事务id记录下来，记录到Read View中。READ COMMITTED隔离级别下则是每次读取时都创建一个新的Read View。<br>Read View是InnoDB中用于判断记录可见性的数据结构，记录了一些用于判断可见性的属性。</p>
<ul>
<li>low_limit_id：某行记录的db_trx_id &lt; 该值，则该行对于当前Read View是一定可见的</li>
<li>up_limit_id：某行记录的db_trx_id &gt;= 该值，则该行对于当前read view是一定不可见的</li>
<li>low_limit_no：用于purge操作的判断</li>
<li>rw_trx_ids：读写事务数组</li>
</ul>
<p>Read View创建后，事务再次进行读操作时比较记录的db_trx_id和Read View中的low_limit_id，up_limit_id和读写事务数组来判断可见性。</p>
<p>如果该行中的db_trx_id等于当前事务id，说明是事务内部发生的更改，直接返回该行数据。否则的话，如果db_trx_id小于up_limit_id，说明是事务开始前的修改，则该记录对当前Read View是可见的，直接返回该行数据。</p>
<p>如果db_trx_id大于或者等于low_limit_id，则该记录对于该Read View一定是不可见的。如果db_trx_id位于[up_limit_id, low_limit_id)范围内，需要在活跃读写事务数组(rw_trx_ids)中查找db_trx_id是否存在，如果存在，记录对于当前Read View是不可见的。<br>如果记录对于Read View不可见，需要通过记录的DB_ROLL_PTR指针遍历undo log，构造对当前Read View可见版本数据。<br>简单来说，Read View记录读开始时及其之后，所有的活动事务，这些事务所做的修改对于Read View是不可见的。除此之外，所有其他的小于创建Read View的事务号的所有记录均可见。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/f6d4d5c37d66" target="_blank" rel="noopener">https://www.jianshu.com/p/f6d4d5c37d66</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（5）：InnoDB锁的类型和状态查询</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%885%EF%BC%89%EF%BC%9AInnoDB%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%8A%B6%E6%80%81%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>锁是数据库系统区分于文件系统的一个关键特性。数据库使用锁来支持对共享资源进行并发访问，提供数据的完整性和一致性。此外，数据库事务的隔离性也是通过锁实现的。InnoDB在此方面一直优于其他数据库引擎。InnoDB会在行级别上对表数据上锁，而MyISAM只能在表级别上锁，二者性能差异可想而知。</p>
<a id="more"></a>

<h2 id="InnoDB存储引擎中的锁"><a href="#InnoDB存储引擎中的锁" class="headerlink" title="InnoDB存储引擎中的锁"></a>InnoDB存储引擎中的锁</h2><p>InnoDB存储引擎实现了如下两种标准的行级锁：</p>
<ul>
<li>共享锁(S Lock)，允许事务读取一行</li>
<li>排他锁(X Lock)，允许事务删除或更新一行数据</li>
</ul>
<p>如果一个事务T1已经获取了行r的共享锁，那么另外一个事务T2可以立刻获得行r的共享锁，因为读取并不会改变数据，可以进行并发的读取操作；但若其他的事务T3想要获取行r的排他锁，则必须等待事务T1和T2释放行r上的共享锁之后才能继续，因为获取排他锁一般是为了改变数据，所以不能同时进行读取或则其他写入操作。</p>
<table>
<thead>
<tr>
<th></th>
<th>X</th>
<th>S</th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>S</td>
<td>不兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p>InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种称为意向锁的锁方式。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。</p>
<p>InnoDB存储引擎的意向锁即为表级别的锁。设计目的主要是为了在一个事务中揭示下一行将被请求的锁类型。其支持两种意向锁：</p>
<ul>
<li>意向共享锁(IS Lock)，事务想要获得一张表中某几行的共享锁</li>
<li>意向排他锁(IX Lock)，事务想要获得一张表中某几行的排他锁</li>
</ul>
<p>需要注意的是意向锁是表级别的锁，它不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。故表级别的意向锁和表级别的锁的兼容性如下表所示。</p>
<table>
<thead>
<tr>
<th></th>
<th>IS</th>
<th>IX</th>
<th>S</th>
<th>X</th>
</tr>
</thead>
<tbody><tr>
<td>IS</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>IX</td>
<td>兼容</td>
<td>兼容</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>S</td>
<td>兼容</td>
<td>不兼容</td>
<td>兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>X</td>
<td>不兼容</td>
<td>不兼容</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
</tbody></table>
<p>向一个表添加表级X锁的时候(执行ALTER TABLE, DROP TABLE, LOCK TABLES等操作)，如果没有意向锁的话，则需要遍历所有整个表判断是否有行锁的存在，以免发生冲突。如果有了意向锁，只需要判断该意向锁与即将添加的表级锁是否兼容即可。因为意向锁的存在代表了，有行级锁的存在或者即将有行级锁的存在，因而无需遍历整个表，即可获取结果。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031174021-c0450.jpeg" alt="img"></p>
<p>层次结构.jpg</p>
<p>如果将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。如上图所示，如果需要对表1的记录m行上X锁，那么需要先对表1加意向IX锁，然后对记录m上X锁。如果其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成。</p>
<h2 id="InnoDB锁相关状态查询"><a href="#InnoDB锁相关状态查询" class="headerlink" title="InnoDB锁相关状态查询"></a>InnoDB锁相关状态查询</h2><p>用户可以使用INFOMATION_SCHEMA库下的INNODB_TRX、INNODB_LOCKS和INNODB_LOCK_WAITS表来监控当前事务并分析可能出现的锁问题。INNODB_TRX的定义如下表所示，其由8个字段组成。</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>trx_id</td>
<td>InnoDB存储引擎内部唯一的事务ID</td>
</tr>
<tr>
<td>trx_state</td>
<td>当前事务的状态</td>
</tr>
<tr>
<td>trx_started</td>
<td>事务的开始时间</td>
</tr>
<tr>
<td>trx_request_lock_id</td>
<td>等待事务的锁ID。如果trx_state的状态为LOCK WAIT,那么该字段代表当前事务等待之前事务占用的锁资源ID</td>
</tr>
<tr>
<td>trx_wait_started</td>
<td>事务等待的时间</td>
</tr>
<tr>
<td>trx_weight</td>
<td>事务的权重，反映了一个事务修改和锁住的行数，当发生死锁需要回滚时，会选择该数值最小的进行回滚</td>
</tr>
<tr>
<td>trx_mysql_thread_id</td>
<td>线程ID，SHOW PROCESSLIST 显示的结果</td>
</tr>
<tr>
<td>trx_query</td>
<td>事务运行的SQL语句</td>
</tr>
</tbody></table>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM information_schema.INNODB_TRX\G;</span></pre></td></tr><tr><td class="code"><pre><span class="line">************************************* <span class="number">1.</span>row *********************************************</span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_id:  <span class="number">7311</span>F4</span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_state: LOCK WAIT</span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_started: <span class="number">2010</span><span class="number">-01</span><span class="number">-04</span> <span class="number">10</span>:<span class="number">49</span>:<span class="number">33</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_requested_lock_id: <span class="number">7311</span>F4:<span class="number">96</span>:<span class="number">3</span>:<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_wait_started: <span class="number">2010</span><span class="number">-01</span><span class="number">-04</span> <span class="number">10</span>:<span class="number">49</span>:<span class="number">33</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_weight: <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_mysql_thread_id: <span class="number">471719</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">trx_query: select * <span class="keyword">from</span> parent lock <span class="keyword">in</span> share mode</span></pre></td></tr></table></figure>

<p>INNODB_TRX表只能显示当前运行的InnoDB事务，并不能直接判断锁的一些情况。如果需要查看锁，则还需要访问表INNODB_LOCKS，该表的字段组成如下表所示。</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock_id</td>
<td>锁的ID</td>
</tr>
<tr>
<td>lock_trx_id</td>
<td>事务的ID</td>
</tr>
<tr>
<td>lock_mode</td>
<td>锁的模式</td>
</tr>
<tr>
<td>lock_type</td>
<td>锁的类型，表锁还是行锁</td>
</tr>
<tr>
<td>lock_table</td>
<td>要加锁的表</td>
</tr>
<tr>
<td>lock_index</td>
<td>锁住的索引</td>
</tr>
<tr>
<td>lock_space</td>
<td>锁住的space id</td>
</tr>
<tr>
<td>lock_page</td>
<td>事务锁定页的数量，若是表锁，则该值为NULL</td>
</tr>
<tr>
<td>lock_rec</td>
<td>事务锁定行的数量，如果是表锁，则该值为NULL</td>
</tr>
<tr>
<td>lock_data</td>
<td>事务锁住记录的主键值，如果是表锁，则该值为NULL</td>
</tr>
</tbody></table>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM information<span class="emphasis">_schema.INNODB_</span>LOCKS\G;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">**** 1.row **</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_id: 7311F4:96:3:2</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock<span class="emphasis">_trx_</span>id: 7311F4</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_mode: S</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_type: RECORD</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_type: 'mytest'.'parent'</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_index: 'PRIMARY'</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_space: 96</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_page: 3</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_rec: 2</span></pre></td></tr><tr><td class="code"><pre><span class="line">lock_data: 1</span></pre></td></tr></table></figure>

<p>通过表INNODB_LOCKS查看每张表上锁的情况后，用户就可以来判断由此引发的等待情况。当时当事务量非常大，其中锁和等待也时常发生，这个时候就不那么容易判断。但是通过表INNODB_LOCK_WAITS，可以很直观的反应当前事务的等待。表INNODB_LOCK_WAITS由四个字段组成，如下表所示。</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>requesting_trx_id</td>
<td>申请锁资源的事务ID</td>
</tr>
<tr>
<td>requesting_lock_id</td>
<td>申请的锁的ID</td>
</tr>
<tr>
<td>blocking_trx_id</td>
<td>阻塞的事务ID</td>
</tr>
<tr>
<td>blocking_lock_id</td>
<td>阻塞的锁的ID</td>
</tr>
</tbody></table>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM information<span class="emphasis">_schema.INNODB_</span>LOCK_WAITS\G;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">***1.row**</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span>*</span></pre></td></tr><tr><td class="code"><pre><span class="line">requesting<span class="emphasis">_trx_</span>id: 7311F4</span></pre></td></tr><tr><td class="code"><pre><span class="line">requesting<span class="emphasis">_lock_</span>id: 7311F4:96:3:2</span></pre></td></tr><tr><td class="code"><pre><span class="line">blocking<span class="emphasis">_trx_</span>id: 730FEE</span></pre></td></tr><tr><td class="code"><pre><span class="line">blocking<span class="emphasis">_lock_</span>id: 730FEE:96:3:2</span></pre></td></tr></table></figure>

<p>通过上述的SQL语句，用户可以清楚直观地看到哪个事务阻塞了另一个事务，然后使用上述的事务ID和锁ID，去INNODB_TRX和INNDOB_LOCKS表中查看更加详细的信息。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/160371211b10" target="_blank" rel="noopener">https://www.jianshu.com/p/160371211b10</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（4）：InnoDB的磁盘文件及落盘机制</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%884%EF%BC%89%EF%BC%9AInnoDB%E7%9A%84%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E5%8F%8A%E8%90%BD%E7%9B%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>任何一个技术都有其底层的关键基础技术，这些关键技术很有可能也是其他技术的关键技术，学习这些底层技术，就可以一通百通，让你很快的掌握其他技术。如何在磁盘上存储数据，如何使用日志文件保证数据不丢失以及如何落盘，不仅是MySQL等数据库的关键技术，也是MQ消息队列或者其他中间件的关键技术之一。</p>
<a id="more"></a>

<p><img src="http://image.winrains.cn/2019/10/20191031173512-1a975.png" alt="img"></p>
<p>InnoDB整体架构</p>
<p>上图详细显示了InnoDB存储引擎的体系架构，从图中可见，InnoDB存储引擎由内存池，后台线程和磁盘文件三大部分组成。接下来我们就来简单了解一下磁盘文件相关的概念和原理。</p>
<p>InnoDB的主要的磁盘文件主要分为三大块：一是系统表空间，二是用户表空间，三是redo日志文件和归档文件。二进制文件(binlog)等文件是MySQL Server层维护的文件，所以未列入InnoDB的磁盘文件中。</p>
<h2 id="系统表空间和用户表空间"><a href="#系统表空间和用户表空间" class="headerlink" title="系统表空间和用户表空间"></a>系统表空间和用户表空间</h2><p>InnoDB系统表空间包含InnoDB数据字典(元数据以及相关对象)并且doublewrite buffer,change buffer,undo logs的存储区域。系统表空间也默认包含任何用户在系统表空间创建的表数据和索引数据。系统表空间是一个共享的表空间因为它是被多个表共享的</p>
<p>系统表空间是由一个或者多个数据文件组成。默认情况下,1个初始大小为10MB，名为ibdata1的系统数据文件在MySQL的data目录下被创建。用户可以使用innodb_data_file_path对数据文件的大小和数量进行配置。</p>
<p>innodb_data_file_path的格式如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">innodb_data_file_path</span>=datafile1[,datafile2]<span class="built_in">..</span>.</span></pre></td></tr></table></figure>

<p>用户可以通过多个文件组成一个表空间，同时制定文件的属性：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">innodb_data_file_path = <span class="regexp">/db/</span><span class="string">ibdata1:</span><span class="number">1000</span>M;<span class="regexp">/dr2/</span>db/<span class="string">ibdata2:</span><span class="number">1000</span><span class="string">M:</span>autoextend</span></pre></td></tr></table></figure>

<p>这里讲/db/ibdata1和/dr2/db/ibdata2两个文件组成系统表空间。如果这两个文件位于不同的磁盘上，磁盘的负载可能被平均，因此可以提高数据库的整体性能。两个文件的文件名之后都跟了属性，表示文件ibdata1的大小为1000MB，文件ibdata2的大小为1000MB，而且用完空间之后可以自动增长(autoextend)。</p>
<p>设置innodb_data_file_path参数之后，所以基于InnoDB存储引擎的表的数据都会记录到该系统表空间中，如果设置了参数innodb_file_per_table，则用户可以将每个基于InnoDB存储引擎的表产生一个独立的用户表空间。用户表空间的命名规则为：表名.ibd。<br>通过这种方式，用户不用将所有数据都存放于默认的系统表空间中，但是用户表空只存储该表的数据、索引和插入缓冲BITMAP等信息，其余信息还是存放在默认的表空间中。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031173513-39774.png" alt="img"></p>
<p>InnoDB表存储引擎文件</p>
<p>上图显示InnoDB存储引擎对于文件的存储方式，其中frm文件是表结构定义文件，记录每个表的表结构定义。</p>
<h2 id="重做日志文件和归档文件"><a href="#重做日志文件和归档文件" class="headerlink" title="重做日志文件和归档文件"></a>重做日志文件和归档文件</h2><p>默认情况下，在InnoDB存储引擎的数据目录下会有两个名为ib_logfile0和ib_logfile1的文件，这就是InnoDB的重做日志文件(redo log fiel)，它记录了对于InnoDB存储引擎的事务日志。<br>当InnoDB的数据存储文件发生错误时，重做日志文件就能派上用场。InnoDB存储引擎可以使用重做日志文件将数据恢复为正确状态，以此来保证数据的正确性和完整性。</p>
<p>每个InnoDB存储引擎至少有1个重做日志文件组(group)，每个文件组下至少有2个重做日志文件，如默认的ib_logfile0和ib_logfile1。<br>为了得到更高的可靠性，用户可以设置多个镜像日志组，将不同的文件组放在不同的磁盘上，以此来提高重做日志的高可用性。</p>
<p>在日志组中每个重做日志文件的大小一致，并以循环写入的方式运行。InnoDB存储引擎先写入重做日志文件1，当文件被写满时，会切换到重做日志文件2，再当重做日志文件2也被写满时，再切换到重做日志文件1。</p>
<p>用户可以使用innodb_log_file_size来设置重做日志文件的大小，这对InnoDB存储引擎的性能有着非常大的影响。</p>
<p>如果重做日志文件设置的太大，数据丢失时，恢复时可能需要很长的时间；另一方面，如果设置的太小，重做日志文件太小会导致依据checkpoint的检查需要频繁刷新脏页到磁盘中，导致性能的抖动。<br>重做日志相关和Checkpoint的机制可以阅读我之前文章的相应章节。<a href="https://mp.weixin.qq.com/s/JCXdP59OUvQEB3q1V9YrCA" target="_blank" rel="noopener">MySQL探秘(三):InnoDB的内存结构和特性
</a></p>
<h2 id="重做日志的落盘机制"><a href="#重做日志的落盘机制" class="headerlink" title="重做日志的落盘机制"></a>重做日志的落盘机制</h2><p>InnoDB对于数据文件和日志文件的刷盘遵守WAL(Write ahead redo log) 和Force-log-at-commit两种规则，二者保证了事务的持久性。WAL要求数据的变更写入到磁盘前，首先必须将内存中的日志写入到磁盘；Force-log-at-commit要求当一个事务提交时，所有产生的日志都必须刷新到磁盘上，如果日志刷新成功后，缓冲池中的数据刷新到磁盘前数据库发生了宕机，那么重启时，数据库可以从日志中恢复数据。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031173514-36d2a.jpeg" alt="img"></p>
<h3 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h3><p>如上图所示，InnoDB在缓冲池中变更数据时，会首先将相关变更写入重做日志缓冲中，然后再按时或者当事务提交时写入磁盘，这符合Force-log-at-commit原则；当重做日志写入磁盘后，缓冲池中的变更数据才会依据checkpoint机制择时写入到磁盘中，这符合WAL原则。<br>在checkpoint择时机制中，就有重做日志文件写满的判断，所以，如前文所述，如果重做日志文件太小，经常被写满，就会频繁导致checkpoint将更改的数据写入磁盘，导致性能抖动。</p>
<p>操作系统的文件系统是带有缓存的，当InnoDB向磁盘写入数据时，有可能只是写入到了文件系统的缓存中，没有真正的“落袋为安”。<br>InnoDB的innodb_flush_log_at_trx_commit属性可以控制每次事务提交时InnoDB的行为。当属性值为0时，事务提交时，不会对重做日志进行写入操作，而是等待主线程按时写入；当属性值为1时，事务提交时，会将重做日志写入文件系统缓存，并且调用文件系统的fsync，将文件系统缓冲中的数据真正写入磁盘存储，确保不会出现数据丢失；当属性值为2时，事务提交时，也会将日志文件写入文件系统缓存，但是不会调用fsync，而是让文件系统自己去判断何时将缓存写入磁盘。日志的刷盘机制如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031173514-227a0.png" alt="img"></p>
<h3 id="log刷盘机制"><a href="#log刷盘机制" class="headerlink" title="log刷盘机制"></a>log刷盘机制</h3><p>innodb_flush_log_at_commit是InnoDB性能调优的一个基础参数，涉及InnoDB的写入效率和数据安全。当参数值为0时，写入效率最高，但是数据安全最低；参数值为1时，写入效率最低，但是数据安全最高；参数值为2时，二者都是中等水平。一般建议将该属性值设置为1，以获得较高的数据安全性，而且也只有设置为1，才能保证事务的持久性。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/e546ea1fc067" target="_blank" rel="noopener">https://www.jianshu.com/p/e546ea1fc067</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（3）：InnoDB的内存结构和特性</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%883%EF%BC%89%EF%BC%9AInnoDB%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%92%8C%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>常言说得好，每个成功男人背后都有一个为他默默付出的女人，而对于MySQL来说，这个“人”就是InnoDB存储引擎。<br>MySQL区别于其他数据库的最为重要的特点就是其插件式的表存储引擎。而在众多存储引擎中，InnoDB是最为常用的存储引擎。从MySQL5.5.8版本开始，InnoDB存储引擎是默认的存储引擎。<br>InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理(OLTP)的应用。其特点是行锁设计、支持外键，并支持非锁定读，即默认读操作不会产生锁。</p>
<a id="more"></a>

<p>InnoDB通过使用多版本并发控制(MVCC)来获取高并发性，并且实现了SQL标准的4中隔离级别，默认为REPEATABLE级别。同时，使用一种被称为next-key-locking的策略来避免幻读现象的产生。除此之外，InnoDB存储引擎还提供了插入缓冲(insert buffer)、二次写(double write)、自适应哈希索引(adaptive hash index)、预读(read ahead)等高性能和高可用的功能。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031172740-361a4.png" alt="img"></p>
<p>InnoDB整体架构.png</p>
<p>上图详细显示了InnoDB存储引擎的体系架构，从图中可见，InnoDB存储引擎由内存池，后台线程和磁盘文件三大部分组成。接下来我们就来简单了解一下内存相关的概念和原理。</p>
<h2 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h2><p>InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。但是由于CPU速度和磁盘速度之间的鸿沟，基于磁盘的数据库系统通常使用缓冲池记录来提高数据库的的整体性能。</p>
<p>在数据库中进行读取操作，首先将从磁盘中读到的页放在缓冲池中，下次再读相同的页中时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取该页。否则，读取磁盘上的页。</p>
<p>对于数据库中页的修改操作，则首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是通过一种称为CheckPoint的机制刷新回磁盘。</p>
<p>所以，缓冲池的大小直接影响着数据库的整体性能，可以通过配置参数innodb_buffer_pool_size来设置。</p>
<p>具体来看，缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲(insert buffer)、自适应哈希索引(adaptive hash index)、InnoDB存储的锁信息(lock info)和数据字典信息(data dictionary)。</p>
<p>在架构图上可以看到，InnoDB存储引擎的内存区域除了有缓冲池之外，还有重做日志缓冲和额外内存池。InnoDB存储引擎首先将重做日志信息先放到这个缓冲区中，然后按照一定频率将其刷新到重做日志文件中。重做日志缓冲一般不需要设置的很大，该值可由配置参数innodb_log_buffer_size控制。</p>
<h2 id="数据页和索引页"><a href="#数据页和索引页" class="headerlink" title="数据页和索引页"></a>数据页和索引页</h2><p>Page是Innodb存储的最基本结构，也是Innodb磁盘管理的最小单位，与数据库相关的所有内容都存储在Page结构里。Page分为几种类型，数据页和索引页就是其中最为重要的两种类型。</p>
<h2 id="插入缓冲-Insert-Buffer"><a href="#插入缓冲-Insert-Buffer" class="headerlink" title="插入缓冲(Insert Buffer)"></a>插入缓冲(Insert Buffer)</h2><p>我们都知道，在InnoDB引擎上进行插入操作时，一般需要按照主键顺序进行插入，这样才能获得较高的插入性能。当一张表中存在非聚簇的且不唯一的索引时，在插入时，数据页的存放还是按照主键进行顺序存放，但是对于非聚簇索引叶节点的插入不再是顺序的了，这时就需要离散的访问非聚簇索引页，由于随机读取的存在导致插入操作性能下降。</p>
<p>InnoDB为此设计了Insert Buffer来进行插入优化。对于非聚簇索引的插入或者更新操作，不是每一次都直接插入到索引页中，而是先判断插入的非聚集索引是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer中。看似数据库这个非聚集的索引已经查到叶节点，而实际没有，这时存放在另外一个位置。然后再以一定的频率和情况进行Insert Buffer和非聚簇索引页子节点的合并操作。这时通常能够将多个插入合并到一个操作中，这样就大大提高了对于非聚簇索引的插入性能。</p>
<h2 id="两次写-Double-Write"><a href="#两次写-Double-Write" class="headerlink" title="两次写(Double Write)"></a>两次写(Double Write)</h2><p>如果说Insert Buffer给InnoDB存储引擎带来了性能上的提升，那么Double Write带给InnoDB存储引擎的是数据页的可靠性。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031172743-bdca7.jpeg" alt="img"></p>
<p>doublewrite示意图</p>
<p>如上图所示，Double Write由两部分组成，一部分是内存中的double write buffer，大小为2MB，另一部分是物理磁盘上共享表空间连续的128个页，大小也为2MB。在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是通过memcpy函数将脏页先复制到内存中的该区域，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免操作系统缓冲写带来的问题。在完成doublewrite页的写入后，再讲doublewirite buffer中的页写入各个表空间文件中。</p>
<p>如果操作系统在将页写入磁盘的过程中发生了崩溃，在恢复过程中，InnoDB存储引擎可以从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件中，再应用重做日志。</p>
<h2 id="重做日志-Redo-Log-Buffer"><a href="#重做日志-Redo-Log-Buffer" class="headerlink" title="重做日志(Redo Log Buffer)"></a>重做日志(Redo Log Buffer)</h2><p>当缓冲池中的页的版本比磁盘要新时，数据库需要将新版本的页从缓冲池刷新到磁盘。但是如果每次一个页发送变化，就进行刷新，那么性能开发是非常大的，于是InnoDB采用了Write Ahead Log策略，即当事务提交时，先写重做日志，然后再择时将脏页写入磁盘。如果发生宕机导致数据丢失，就通过重做日志进行数据恢复。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031172743-45863.jpeg" alt="img"></p>
<p>InnoDB数据写入示意图</p>
<p>InnoDB存储引擎会首先将重做日志信息先放入重做日志缓冲中，然后再按照一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置得很大，因为一般情况每一秒钟都会讲重做日志缓冲刷新到日志文件中。可通过配置参数innodb_log_buffer_size控制，默认为8MB。</p>
<p>除了每秒刷新机制之外，每次事务提交时重做日志缓冲也会刷新到日志中。InnoDB是事务的存储引擎，其通过Force Log at Commit机制实现事务的持久性，即当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，然后事务的提交操作完成才算完成。InnoDB的写入机制大致入下图所示。</p>
<p>为了确保每次日志都写入到重做日志文件，在每次讲重做日志缓冲写入重做日志后，必须调用一次fsync操作，将缓冲文件从文件系统缓存中真正写入磁盘。</p>
<p>可以通过innodb_flush_log_at_trx_commit来控制重做日志刷新到磁盘的策略。该参数默认值为1，表示事务提交必须进行一次fsync操作，还可以设置为0和2。0表示事务提交时不进行写入重做日志操作，该操作只在主线程中完成，2表示提交时写入重做日志，但是只写入文件系统缓存，不进行fsync操作。由此可见，设置为0时，性能最高，但是丧失了事务的一致性。</p>
<h2 id="自适应哈希索引-Adaptive-Hash-Index"><a href="#自适应哈希索引-Adaptive-Hash-Index" class="headerlink" title="自适应哈希索引(Adaptive Hash Index)"></a>自适应哈希索引(Adaptive Hash Index)</h2><p>InnoDB会根据访问的频率和模式，为热点页建立哈希索引，来提高查询效率。InnoDB存储引擎会监控对表上各个索引页的查询，如果观察到建立哈希索引可以带来速度上的提升，则建立哈希索引，所以叫做自适应哈希索引。</p>
<p>自适应哈希索引是通过缓冲池的B+树页构建而来，因此建立速度很快，而且不需要对整张数据表建立哈希索引。其有一个要求，即对这个页的连续访问模式必须是一样的，也就是说其查询的条件(WHERE)必须完全一样，而且必须是连续的。</p>
<h2 id="锁信息-lock-info"><a href="#锁信息-lock-info" class="headerlink" title="锁信息(lock info)"></a>锁信息(lock info)</h2><p>我们都知道，InnoDB存储引擎会在行级别上对表数据进行上锁。不过InnoDB也会在数据库内部其他很多地方使用锁，从而允许对多种不同资源提供并发访问。数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。关于锁的具体知识我们之后再进行详细学习。</p>
<h2 id="数据字典信息-Data-Dictionary"><a href="#数据字典信息-Data-Dictionary" class="headerlink" title="数据字典信息(Data Dictionary)"></a>数据字典信息(Data Dictionary)</h2><p>InnoDB有自己的表缓存，可以称为表定义缓存或者数据字典。当InnoDB打开一张表，就增加一个对应的对象到数据字典。</p>
<p>数据字典是对数据库中的数据、库对象、表对象等的元信息的集合。在MySQL中，数据字典信息内容就包括表结构、数据库名或表名、字段的数据类型、视图、索引、表字段信息、存储过程、触发器等内容。MySQL INFORMATION_SCHEMA库提供了对数据局元数据、统计信息、以及有关MySQL server的访问信息（例如：数据库名或表名，字段的数据类型和访问权限等）。该库中保存的信息也可以称为MySQL的数据字典。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/1c1f83d0bb72" target="_blank" rel="noopener">https://www.jianshu.com/p/1c1f83d0bb72</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（2）：SQL语句执行过程详解</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%882%EF%BC%89%EF%BC%9ASQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>昔日庖丁解牛，未见全牛，所赖者是其对牛内部骨架结构的了解，对于MySQL亦是如此，只有更加全面地了解SQL语句执行的每个过程，才能更好的进行SQL的设计和优化。<br>当希望MySQL能够以更高的性能运行查询时，最好的办法就是弄清楚MySQL是如何优化和执行查询的。一旦理解了这一点，很多查询优化工作实际上就是遵循一些原则能够按照预想的合理的方式运行。</p>
<a id="more"></a>

<p>如下图所示，当向MySQL发送一个请求的时候，MySQL到底做了什么：</p>
<ol>
<li>客户端发送一条查询给服务器。</li>
<li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</li>
<li>服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。</li>
<li>MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询。</li>
<li>将结果返回给客户端。</li>
</ol>
<p><img src="http://image.winrains.cn/2019/10/20191031172218-253a8.png" alt="img"></p>
<p>SQL语句执行过程</p>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>MySQL查询缓存保存查询返回的完整结构。当查询命中该缓存时，MySQL会立刻返回结果，跳过了解析、优化和执行阶段。<br>查询缓存系统会跟踪查询中涉及的每个表，如果这些表发生了变化，那么和这个表相关的所有缓存数据都将失效。<br>MySQL将缓存存放在一个引用表中，通过一个哈希值引用，这个哈希值包括了以下因素，即查询本身、当前要查询的数据库、客户端协议的版本等一些其他可能影响返回结果的信息。<br>当判断缓存是否命中时，MySQL不会进行解析查询语句，而是直接使用SQL语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。<br>当查询语句中有一些不确定的数据时，则不会被缓存。例如包含函数NOW()或者CURRENT_DATE()的查询不会缓存。包含任何用户自定义函数，存储函数，用户变量，临时表，mysql数据库中的系统表或者包含任何列级别权限的表，都不会被缓存。<br>有一点需要注意，MySQL并不是会因为查询中包含一个不确定的函数而不检查查询缓存，因为检查查询缓存之前，MySQL不会解析查询语句，所以也无法知道语句中是否有不确定的函数。<br>事实则是，如果查询语句中包含任何的不确定的函数，那么其查询结果不会被缓存，因为查询缓存中也无法找到对应的缓存结果。<br>有关查询缓存的配置如下所示。</p>
<ul>
<li>query_cache_type:是否打开查询缓存。可以设置为OFF、ON和DEMAND。DEMAND表示只有在查询语句中明确写明SQL_CACHE的语句才会放入查询缓存。</li>
<li>query_cache_size:查询缓存使用的总内存空间。</li>
<li>query_cache_min_res_unit:在查询缓存中分配内存块时的最小单元。较小的该值可以减少碎片导致的内存空间浪费，但是会导致更频繁的内存块操作。</li>
<li>query_cache_limit:MySQL能够查询的最大查询结果。如果查询结果大于这个值，则不会被缓存。因为查询缓存在数据生成的时候就开始尝试缓存数据，所以当结果全部返回后，MySQL才知道查询结果是否超出限制。超出之后，才会将结果从查询缓存中删除。</li>
</ul>
<p>对查询缓存的优化是数据库性能优化的重要一环。判断流程大致如下图所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031172218-253a8.png" alt="img"></p>
<p>查询缓存判断流程图</p>
<p>缓存命中率可以通过如下公式计算：Qcache_hits/(Qcache_hits + Com_select)来计算。</p>
<h2 id="解析和预处理"><a href="#解析和预处理" class="headerlink" title="解析和预处理"></a>解析和预处理</h2><p>解析器通过关键字将SQL语句进行解析，并生成对应的解析树。MySQL解析器将使用MySQL语法规则验证和解析查询。<br>预处理器则根据一些MySQL规则进行进一步检查解析书是否合法，例如检查数据表和数据列是否存在，还会解析名字和别名，看看它们是否有歧义。</p>
<h2 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h2><p>查询优化器会将解析树转化成执行计划。一条查询可以有多种执行方法，最后都是返回相同结果。优化器的作用就是找到这其中最好的执行计划。<br>生成执行计划的过程会消耗较多的时间，特别是存在许多可选的执行计划时。如果在一条SQL语句执行的过程中将该语句对应的最终执行计划进行缓存，当相似的语句再次被输入服务器时，就可以直接使用已缓存的执行计划，从而跳过SQL语句生成执行计划的整个过程，进而可以提高语句的执行速度。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031172220-78b8b.png" alt="img"></p>
<p>执行计划缓存</p>
<p>MySQL使用基于成本的查询优化器(Cost-Based Optimizer，CBO)。它会尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最少的一个。<br>优化器会根据优化规则对关系表达式进行转换，这里的转换是说一个关系表达式经过优化规则后会生成另外一个关系表达式，同时原有表达式也会保留，经过一系列转换后会生成多个执行计划，然后CBO会根据统计信息和代价模型(Cost Model)计算每个执行计划的Cost，从中挑选Cost最小的执行计划。由上可知，CBO中有两个依赖：统计信息和代价模型。统计信息的准确与否、代价模型的合理与否都会影响CBO选择最优计划。<br>有关优化器的原理十分复杂，这里就不进行详细讲解了，大家可以自行学习。</p>
<h2 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h2><p>在解析和优化阶段，MySQL将生成查询对应的执行计划，MySQL的查询执行引擎根据这个执行计划来完成整个查询。这里执行计划是一个数据结构，而不是和其他的关系型数据库那样生成对应的字节码。</p>
<h2 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h2><p>如果查询可以被缓存，那么MySQL在这个阶段页会将结果存放到查询缓存中。<br>MySQL将结果集返回给客户端是一个增量、逐步返回的过程。在查询生成第一条结果时，MySQL就可以开始向客户端逐步返回结果集了。</p>
<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/56fe9bf91448" target="_blank" rel="noopener">https://www.jianshu.com/p/56fe9bf91448</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL探索（1）：B-Tree索引</title>
    <url>/2019/12/26/MySQL%E6%8E%A2%E7%B4%A2%EF%BC%881%EF%BC%89%EF%BC%9AB-Tree%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>MySQL是目前业界最为流行的关系型数据库之一，而索引的优化也是数据库性能优化的关键之一。所以，充分地了解MySQL索引有助于提升开发人员对MySQL数据库的使用优化能力。<br>MySQL的索引有很多种类型，可以为不同的场景提供更好的性能。而B-Tree索引是最为常见的MySQL索引类型，一般谈论MySQL索引时，如果没有特别说明，就是指B-Tree索引。本文就详细讲解一下B-Tree索引的的底层结构，使用原则和特性。</p>
<a id="more"></a>

<p>为了节约你的时间，本文的主要内容如下：</p>
<ul>
<li>B-Tree索引的底层结构</li>
<li>B-Tree索引的使用规则</li>
<li>聚簇索引</li>
<li>InnoDB和MyISAM引擎索引的差异</li>
<li>松散索引</li>
<li>覆盖索引</li>
</ul>
<h2 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h2><p>B-Tree索引使用B-Tree来存储数据，当然不同存储引擎的实现方式不同。B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同，图1展示了B-Tree索引的抽象表示，由此可以看出MySQL的B-Tree索引的大致工作机制。<br>B-Tree索引的底层数据结构一般是B+树，其具体数据结构和优势这里就不作详细描述，图1展示了B-树索引的抽象表示，大致反应了MyISAM索引是如何工作的，而InnoDB使用的结构有所不同。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031171835-cd3fe.png" alt="img"></p>
<p>图1 B-Tree索引的底层结构示意图</p>
<p>MySQL可以在单独一列上添加B-Tree索引，也可以在多列数据上添加B-Tree索引，多列的数据按照添加索引声明的顺序组合起来，存储在B-Tree的页中。假设有如下数据表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People (</span></pre></td></tr><tr><td class="code"><pre><span class="line">      last_name    <span class="built_in">varchar</span>(<span class="number">50</span>)    <span class="keyword">not</span> <span class="literal">null</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      first_name   <span class="built_in">varchar</span>(<span class="number">50</span>)    <span class="keyword">not</span> <span class="literal">null</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      birthday     <span class="built_in">date</span>           <span class="keyword">not</span> <span class="literal">null</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      gender       enum(<span class="string">'m'</span>,<span class="string">'f'</span>)  <span class="keyword">not</span> <span class="literal">null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">key</span>(last_name, first_name, birthday)</span></pre></td></tr><tr><td class="code"><pre><span class="line">);</span></pre></td></tr></table></figure>

<p>对于表中的每一行数据，索引中包含了last_name，first_name和birthday列的值，图2展示了该索引是如何组织数据的存储的。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031171836-50d95.png" alt="img"></p>
<p>图2 多列索引</p>
<p>B-Tree索引使用B-Tree作为其存储数据的数据结构，其使用的查询规则也由此决定。一般来说，B-Tree索引适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于根据最左前缀查找。B-Tree索引支持的查询原则如下所示：</p>
<ul>
<li>全值匹配：全值匹配指的是和索引中的所有列进行匹配，</li>
<li>匹配最左前缀：前边提到的索引可以用于查找所有姓Allen的人，即只使用索引中的第一列。</li>
<li>匹配列前缀：也可以只匹配某一列的值的开头部分。例如前面提到的索引可用于查找所有以J开头的姓的人。这里也只用到了索引的第一列。</li>
<li>匹配范围值：例如前边提到的索引可用于查找姓在Allen和Barrymore之间的人。这里也只使用了索引的第一列。</li>
<li>精确匹配某一列并范围匹配另外一列：前边提到的索引也可用于查找所有姓为Allen，并且名字是字母K开头(比如Kim,Karl等)的人。即第一列last_name全匹配，第二列first_name范围匹配。</li>
</ul>
<p>因为索引树的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的ORDER BY操作(按顺序查找)，如果ORDER BY子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。<br>下面是一些关于B-Tree索引的限制：</p>
<ul>
<li>如果不是按照索引的最左列开始查找，则无法使用索引。例如上面例子中的索引无法查找名字为Bill的人，也无法查找某个特定生日的日，因为这两列都不是最左数据列。</li>
<li>如果查询中有某个列的范围查询，则其右侧所有列都无法使用索引优化查找。</li>
</ul>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于其实现方式，但是InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。<br>当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中，这也就是说数据行和相邻的键值紧凑地存储在一起。<br>图3展示了聚簇索引中的记录是如何存放的。注意到，叶子页包含了行的全部数据行，但是节点页只包含了索引列。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031171836-2a3fb.png" alt="img"></p>
<p>图3 聚簇索引</p>
<p>聚簇索引可能对性能有帮助，但也可能导致严重的性能问题。聚簇的数据是有一些重要的优点：</p>
<ul>
<li>数据访问更快，聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li>
</ul>
<p>如果在设计表和查询时能充分利用上面的优点，那么就能极大地提升性能。同时，聚簇索引也有一些缺点：</p>
<ul>
<li>插入顺序严重依赖插入顺序。按照主键的顺序插入是向InnoDB表中插入数据速度最快的方式，需要避免主键键值随机的(不连续且值得分布范围非常大)聚簇索引，比如使用UUID作为主键，而应该使用类似AUTO_INCREMENT的自增列。</li>
<li>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动位置到新的位置。</li>
<li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行时，可能面临“页分裂”的问题。当行的主键值要求必须将这行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间</li>
<li>二级索引可能比想象的更大，因为在二级索引中的叶节点包含了引用行的主键列</li>
<li>二级索引访问需要两次索引查找，而不是一次。</li>
</ul>
<h2 id="InnoDB和MyISAM的索引区别"><a href="#InnoDB和MyISAM的索引区别" class="headerlink" title="InnoDB和MyISAM的索引区别"></a>InnoDB和MyISAM的索引区别</h2><p>聚簇索引和非聚簇索引的数据分布有区别，以及对应的主键索引和二级索引的数据分布也有区别，通常会让人感到困惑和意外。图4展示了MyISAM和InnoDB的不同索引和数据存储方式。<br>MyISAM的数据分布非常简单，按照数据插入的顺序存储在磁盘上，主键索引和二级索引的叶节点存储着指针，指向对应的数据行。<br>InnoDB中，聚簇索引“就是”表，所以不会像MyISAM那样需要独立的行存储。聚簇索引的每个叶节点都包含了主键值和所有的剩余列(在此例中是col2)。<br>InnoDB的二级索引和聚簇索引很不同。InnoDB二级索引的叶节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031171837-1e9a0.png" alt="img"></p>
<p>图4 InnoDB和MyISAM的区别</p>
<h2 id="松散索引扫描"><a href="#松散索引扫描" class="headerlink" title="松散索引扫描"></a>松散索引扫描</h2><p>MySQL并不支持松散索引扫描，也就是无法按照不连续的方式扫描一个索引。通常，MySQL的索引扫描需要先定义一个起点和终点，即使需要的数据只是这段索引中很少数的几个，MySQL仍然需要扫描这段索引中的每个条目。<br>下面，我们通过一个示例说明这点，假设我们有如下索引(a,b)，有下面的查询：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">mysql&gt;<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb1 <span class="keyword">WHERE</span> b <span class="keyword">BETWEEN</span> <span class="number">2</span> <span class="keyword">AND</span> <span class="number">3</span>;</span></pre></td></tr></table></figure>

<p>因为索引的前导字段是列a，但是在查询中只指定了字段b，MySQL无法使用这个索引，从而只能通过全表扫描找到匹配的行，如图5所示。<br><img src="http://image.winrains.cn/2019/10/20191031171837-a11d6.png" alt="img"></p>
<p>图5 全表扫描</p>
<p>了解索引的物理结构的话，不难发现还可以有一个更快的办法执行上面的查询。索引的物理结构(不是存储引擎的API)是的可以先扫描a列第一个值对应的b列的范围，然后再跳到a列第二个不不同值扫描对应的b列的范围。图6展示了如果由MySQL来实现这个过程会怎样。</p>
<p><img src="http://image.winrains.cn/2019/10/20191031171838-b59f9.png" alt="img"></p>
<p>图6 松散索引</p>
<p>注意到，这时就无须再使用WHERE子句过滤，因为松散索引扫描已经跳过了所有不需要的记录。<br>MySQL 5.0之后的版本，在某些特殊的场景下是可以使用松散索引扫描的，例如，在一个分组查询中需要找到分组的最大值和最小值：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT actor_id, MAX(film_id)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        -&gt; <span class="keyword">FROM</span> sakila.film.film_actor</span></pre></td></tr><tr><td class="code"><pre><span class="line">        -&gt;<span class="built_in"> GROUP </span>BY actor_id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">********************************************* 1. row ***********************************</span></pre></td></tr><tr><td class="code"><pre><span class="line">id: 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">select_type: SIMPLE</span></pre></td></tr><tr><td class="code"><pre><span class="line">table: film_actor</span></pre></td></tr><tr><td class="code"><pre><span class="line">type: range</span></pre></td></tr><tr><td class="code"><pre><span class="line">possible_keys: <span class="literal">NULL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">key: PRIMARY</span></pre></td></tr><tr><td class="code"><pre><span class="line">key_len: 2</span></pre></td></tr><tr><td class="code"><pre><span class="line">ref: <span class="literal">NULL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">rows: 396</span></pre></td></tr><tr><td class="code"><pre><span class="line">Extra: Using index <span class="keyword">for</span> group-by</span></pre></td></tr></table></figure>

<p>在EXPLAIN中的Extra字段显示”Using index for group-by”，表示这里将使用松散索引扫描。</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>索引除了是一种查找数据的高效方式之外，也是一种列数据的直接获取方式。MySQL可以使用索引来直接获取列的数据，这样就不需要读取数据行。如果一个索引包含所有需要查询的字段的值，我们就称之为“覆盖索引”。<br>覆盖索引是非常有用的工具，能够极大地提高性能。SQL查询只需要扫描索引而无需回表，会带来很多好处：</p>
<ul>
<li>索引条目数量和大小通常远小于数据行的条目和大小，所以如果只需要读取索引，那么MySQL就会极大地减少数据访问量。</li>
<li>因为索引是按照列顺序存储的，所以对于I/O密集型的范围查找会比随机从磁盘读取每一行数据的I/O要少的多。</li>
<li>由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键，索引如果二级主键能够覆盖查询，则避免对主键索引的第二次查询。</li>
</ul>
<p>当发起一个被覆盖索引的查询(也叫索引覆盖查询)时，在EXPLAIN的Extra列可以看到”Using Index”的信息。例如，表sakila.inventory有一个多列索引(store_id, film_id)。MySQL如果只需要访问这两列，就可以使用这个索引做覆盖索引，如下所示：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT store<span class="emphasis">_id, film_</span>id FROM sakila.inventory</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">***1.row**</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**</span></pre></td></tr><tr><td class="code"><pre><span class="line">id:1</span></pre></td></tr><tr><td class="code"><pre><span class="line">select_type:SIMPLE</span></pre></td></tr><tr><td class="code"><pre><span class="line">table:inventory</span></pre></td></tr><tr><td class="code"><pre><span class="line">type:index</span></pre></td></tr><tr><td class="code"><pre><span class="line">possible_keys:NULL</span></pre></td></tr><tr><td class="code"><pre><span class="line">key:idx<span class="emphasis">_store_</span>id<span class="emphasis">_film_</span>id</span></pre></td></tr><tr><td class="code"><pre><span class="line">key_len:3</span></pre></td></tr><tr><td class="code"><pre><span class="line">ref:NULL</span></pre></td></tr><tr><td class="code"><pre><span class="line">rows:4673</span></pre></td></tr><tr><td class="code"><pre><span class="line">Extra:Using Index</span></pre></td></tr></table></figure>

<blockquote>
<p>作者：程序员历小冰</p>
<p>来源：<a href="https://www.jianshu.com/p/9e00633958e6" target="_blank" rel="noopener">https://www.jianshu.com/p/9e00633958e6</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Redis使用方法</title>
    <url>/2019/12/26/Redis%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本文将从Redis的基本特性入手，通过讲述Redis的数据结构和主要命令对Redis的基本能力进行直观介绍。</p>
<p>然后概览Redis提供的高级能力，并在部署、维护、性能调优等多个方面进行更深入的介绍和指导。</p>
<p>本文适合使用Redis的普通开发人员，以及对Redis进行选型、架构设计和性能调优的架构设计人员。</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h1><p>Redis是一个开源的，基于内存的结构化数据存储媒介，可以作为数据库、缓存服务或消息服务使用。<br>Redis支持多种数据结构，包括字符串、哈希表、链表、集合、有序集合、位图、Hyperloglogs等。<br>Redis具备LRU淘汰、事务实现、以及不同级别的硬盘持久化等能力，并且支持副本集和通过Redis Sentinel实现的高可用方案，同时还支持通过Redis Cluster实现的数据自动分片能力。<br>Redis的主要功能都基于单线程模型实现，也就是说Redis使用一个线程来服务所有的客户端请求<br>同时Redis采用了非阻塞式IO，并精细地优化各种命令的算法时间复杂度，这些信息意味着：</p>
<ul>
<li>Redis是线程安全的（因为只有一个线程），其所有操作都是原子的，不会因并发产生数据异常</li>
<li>Redis的速度非常快（因为使用非阻塞式IO，且大部分命令的算法时间复杂度都是O(1))</li>
<li>使用高耗时的Redis命令是很危险的，会占用唯一的一个线程的大量处理时间，导致所有的请求都被拖慢。（例如时间复杂度为O(N)的KEYS命令，严格禁止在生产环境中使用）</li>
</ul>
<h1 id="Redis的数据结构和相关常用命令"><a href="#Redis的数据结构和相关常用命令" class="headerlink" title="Redis的数据结构和相关常用命令"></a><strong>Redis的数据结构和相关常用命令</strong></h1><p>本节将介绍Redis支持的主要数据结构，以及相关的常用Redis命令</p>
<h2 id="Key"><a href="#Key" class="headerlink" title="Key"></a><strong>Key</strong></h2><p>Redis采用Key-Value型的基本数据结构，任何二进制序列都可以作为Redis的Key使用（例如普通的字符串或一张JPEG图片）<br>关于Key的一些注意事项：</p>
<ul>
<li><strong>不要使用过长的Key</strong>。例如使用一个1024字节的key就不是一个好主意，不仅会消耗更多的内存，还会导致查找的效率降低</li>
<li><strong>Key短到缺失了可读性也是不好的</strong>，例如”u1000flw”比起”user:1000:followers”来说，节省了寥寥的存储空间，却引发了可读性和可维护性上的麻烦</li>
<li><strong>最好使用统一的规范来设计Key</strong>，比如”object-type:id:attr”，以这一规范设计出的Key可能是”user:1000”或”comment:1234:reply-to”</li>
<li><strong>Redis允许的最大Key长度是512MB</strong>（对Value的长度限制也是512MB）</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a><strong>String</strong></h2><p>String是Redis的基础数据类型，Redis没有Int、Float、Boolean等数据类型的概念，所有的基本类型在Redis中都以String体现。<br>与String相关的常用命令：</p>
<ul>
<li><strong>SET</strong>：为一个key设置value，可以配合EX/PX参数指定key的有效期，通过NX/XX参数针对key是否存在的情况进行区别操作，时间复杂度O(1)</li>
<li><strong>GET</strong>：获取某个key对应的value，时间复杂度O(1)</li>
<li><strong>GETSET</strong>：为一个key设置value，并返回该key的原value，时间复杂度O(1)</li>
<li><strong>MSET</strong>：为多个key设置value，时间复杂度O(N)</li>
<li><strong>MSETNX</strong>：同MSET，如果指定的key中有任意一个已存在，则不进行任何操作，时间复杂度O(N)</li>
<li><strong>MGET</strong>：获取多个key对应的value，时间复杂度O(N)</li>
</ul>
<p>上文提到过，Redis的基本数据类型只有String，但Redis可以把String作为整型或浮点型数字来使用，主要体现在INCR、DECR类的命令上：</p>
<ul>
<li><strong>INCR</strong>：将key对应的value值自增1，并返回自增后的值。只对可以转换为整型的String数据起作用。时间复杂度O(1)</li>
<li><strong>INCRBY</strong>：将key对应的value值自增指定的整型数值，并返回自增后的值。只对可以转换为整型的String数据起作用。时间复杂度O(1)</li>
<li><strong>DECR/DECRBY</strong>：同INCR/INCRBY，自增改为自减。</li>
</ul>
<p>INCR/DECR系列命令要求操作的value类型为String，并可以转换为64位带符号的整型数字，否则会返回错误。<br>也就是说，进行INCR/DECR系列命令的value，必须在[-2^63 ~ 2^63 - 1]范围内。<br>前文提到过，Redis采用单线程模型，天然是线程安全的，这使得INCR/DECR命令可以非常便利的实现高并发场景下的精确控制。</p>
<h3 id="例1：库存控制"><a href="#例1：库存控制" class="headerlink" title="例1：库存控制"></a><strong>例1：库存控制</strong></h3><p>在高并发场景下实现库存余量的精准校验，确保不出现超卖的情况。<br>设置库存总量：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> inv:remain <span class="comment">"100"</span></span></pre></td></tr></table></figure>

<p>库存扣减+余量校验：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">DECR</span> <span class="selector-tag">inv</span><span class="selector-pseudo">:remain</span></span></pre></td></tr></table></figure>

<p>当DECR命令返回值大于等于0时，说明库存余量校验通过，如果返回小于0的值，则说明库存已耗尽。<br>假设同时有300个并发请求进行库存扣减，Redis能够确保这300个请求分别得到99到-200的返回值，每个请求得到的返回值都是唯一的，绝对不会找出现两个请求得到一样的返回值的情况。</p>
<h3 id="例2：自增序列生成"><a href="#例2：自增序列生成" class="headerlink" title="例2：自增序列生成"></a><strong>例2：自增序列生成</strong></h3><p>实现类似于RDBMS的Sequence功能，生成一系列唯一的序列号<br>设置序列起始值：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> sequence <span class="comment">"10000"</span></span></pre></td></tr></table></figure>

<p>获取一个序列值：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">INCR sequence</span></span></pre></td></tr></table></figure>

<p>直接将返回值作为序列使用即可。<br>获取一批（如100个）序列值：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">INCRBY sequence <span class="number">100</span></span></pre></td></tr></table></figure>

<p>假设返回值为N，那么[N - 99 ~ N]的数值都是可用的序列值。<br>当多个客户端同时向Redis申请自增序列时，Redis能够确保每个客户端得到的序列值或序列范围都是全局唯一的，绝对不会出现不同客户端得到了重复的序列值的情况。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a><strong>List</strong></h2><p>Redis的List是链表型的数据结构，可以使用LPUSH/RPUSH/LPOP/RPOP等命令在List的两端执行插入元素和弹出元素的操作。<br>虽然List也支持在特定index上插入和读取元素的功能，但其时间复杂度较高（O(N)），应小心使用。<br>与List相关的常用命令：</p>
<ul>
<li><strong>LPUSH</strong>：向指定List的左侧（即头部）插入1个或多个元素，返回插入后的List长度。时间复杂度O(N)，N为插入元素的数量</li>
<li><strong>RPUSH</strong>：同LPUSH，向指定List的右侧（即尾部）插入1或多个元素</li>
<li><strong>LPOP</strong>：从指定List的左侧（即头部）移除一个元素并返回，时间复杂度O(1)</li>
<li><strong>RPOP</strong>：同LPOP，从指定List的右侧（即尾部）移除1个元素并返回</li>
<li><strong>LPUSHX/RPUSHX</strong>：与LPUSH/RPUSH类似，区别在于，LPUSHX/RPUSHX操作的key如果不存在，则不会进行任何操作</li>
<li><strong>LLEN</strong>：返回指定List的长度，时间复杂度O(1)</li>
<li><strong>LRANGE</strong>：返回指定List中指定范围的元素（双端包含，即LRANGE key 0 10会返回11个元素），时间复杂度O(N)。</li>
</ul>
<p>注意：应尽可能控制一次获取的元素数量，一次获取过大范围的List元素会导致延迟，同时对长度不可预知的List，避免使用LRANGE key 0 -1这样的完整遍历操作。</p>
<p>应谨慎使用的List相关命令：</p>
<ul>
<li><strong>LINDEX</strong>：返回指定List指定index上的元素，如果index越界，返回nil。index数值是回环的，即-1代表List最后一个位置，-2代表List倒数第二个位置。时间复杂度O(N)</li>
<li><strong>LSET</strong>：将指定List指定index上的元素设置为value，如果index越界则返回错误，时间复杂度O(N)，如果操作的是头/尾部的元素，则时间复杂度为O(1)</li>
<li><strong>LINSERT</strong>：向指定List中指定元素之前/之后插入一个新元素，并返回操作后的List长度。如果指定的元素不存在，返回-1。如果指定key不存在，不会进行任何操作，时间复杂度O(N)</li>
</ul>
<p>由于Redis的List是链表结构的，上述的三个命令的算法效率较低，需要对List进行遍历，命令的耗时无法预估，在List长度大的情况下耗时会明显增加，应谨慎使用。<br>换句话说，Redis的List实际是设计来用于实现队列，而不是用于实现类似ArrayList这样的列表的。<br>如果你不是想要实现一个双端出入的队列，那么请尽量不要使用Redis的List数据结构。<br>为了更好支持队列的特性，Redis还提供了一系列阻塞式的操作命令，如BLPOP/BRPOP等，能够实现类似于BlockingQueue的能力，即在List为空时，阻塞该连接，直到List中有对象可以出队时再返回。</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a><strong>Hash</strong></h2><p>Hash即哈希表，Redis的Hash和传统的哈希表一样，是一种field-value型的数据结构，可以理解成将HashMap搬入Redis。<br>Hash非常适合用于表现对象类型的数据，用Hash中的field对应对象的field即可。<br>Hash的优点包括：</p>
<ul>
<li>可以实现二元查找，如”查找ID为1000的用户的年龄”</li>
<li>比起将整个对象序列化后作为String存储的方法，Hash能够有效地减少网络传输的消耗</li>
<li>当使用Hash维护一个集合时，提供了比List效率高得多的随机访问命令</li>
</ul>
<p>与Hash相关的常用命令：</p>
<ul>
<li><p><strong>HSET</strong>：将key对应的Hash中的field设置为value。如果该Hash不存在，会自动创建一个。时间复杂度O(1)</p>
</li>
<li><p><strong>HGET</strong>：返回指定Hash中field字段的值，时间复杂度O(1)</p>
</li>
<li><p><strong>HMSET/HMGET</strong>：同HSET和HGET，可以批量操作同一个key下的多个field，时间复杂度：O(N)，N为一次操作的field数量</p>
</li>
<li><p><strong>HSETNX</strong>：同HSET，但如field已经存在，HSETNX不会进行任何操作，时间复杂度O(1)</p>
</li>
<li><p><strong>HEXISTS</strong>：判断指定Hash中field是否存在，存在返回1，不存在返回0，时间复杂度O(1)</p>
</li>
<li><p><strong>HDEL</strong>：删除指定Hash中的field（1个或多个），时间复杂度：O(N)，N为操作的field数量</p>
</li>
<li><p><strong>HINCRBY</strong>：同INCRBY命令，对指定Hash中的一个field进行INCRBY，时间复杂度O(1)</p>
</li>
</ul>
<p>应谨慎使用的Hash相关命令：</p>
<ul>
<li><strong>HGETALL</strong>：返回指定Hash中所有的field-value对。返回结果为数组，数组中field和value交替出现。时间复杂度O(N)</li>
<li><strong>HKEYS/HVALS</strong>：返回指定Hash中所有的field/value，时间复杂度O(N)</li>
</ul>
<p>上述三个命令都会对Hash进行完整遍历，Hash中的field数量与命令的耗时线性相关<br>对于尺寸不可预知的Hash，应严格避免使用上面三个命令，而改为使用HSCAN命令进行游标式的遍历</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a><strong>Set</strong></h2><p>Redis Set是无序的，不可重复的String集合。<br>与Set相关的常用命令：</p>
<ul>
<li><strong>SADD</strong>：向指定Set中添加1个或多个member，如果指定Set不存在，会自动创建一个。时间复杂度O(N)，N为添加的member个数</li>
<li><strong>SREM</strong>：从指定Set中移除1个或多个member，时间复杂度O(N)，N为移除的member个数</li>
<li><strong>SRANDMEMBER</strong>：从指定Set中随机返回1个或多个member，时间复杂度O(N)，N为返回的member个数</li>
<li><strong>SPOP</strong>：从指定Set中随机移除并返回count个member，时间复杂度O(N)，N为移除的member个数</li>
<li><strong>SCARD</strong>：返回指定Set中的member个数，时间复杂度O(1)</li>
<li><strong>SISMEMBER</strong>：判断指定的value是否存在于指定Set中，时间复杂度O(1)</li>
<li><strong>SMOVE</strong>：将指定member从一个Set移至另一个Set</li>
</ul>
<p>慎用的Set相关命令：</p>
<ul>
<li><strong>SMEMBERS</strong>：返回指定Hash中所有的member，时间复杂度O(N)</li>
<li><strong>SUNION/SUNIONSTORE</strong>：计算多个Set的并集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数</li>
<li><strong>SINTER/SINTERSTORE</strong>：计算多个Set的交集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数</li>
<li><strong>SDIFF/SDIFFSTORE</strong>：计算1个Set与1或多个Set的差集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数</li>
</ul>
<p>上述几个命令涉及的计算量大，应谨慎使用，特别是在参与计算的Set尺寸不可知的情况下，应严格避免使用。</p>
<h2 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a><strong>Sorted Set</strong></h2><p>Redis Sorted Set是有序的、不可重复的String集合。<br>Sorted Set中的每个元素都需要指派一个分数(score)，Sorted Set会根据score对元素进行升序排序。<br>如果多个member拥有相同的score，则以字典序进行升序排序。Sorted Set非常适合用于实现排名。<br>Sorted Set的主要命令：</p>
<ul>
<li><strong>ZADD</strong>：向指定Sorted Set中添加1个或多个member，时间复杂度O(Mlog(N))，M为添加的member数量，N为Sorted Set中的member数量</li>
<li><strong>ZREM</strong>：从指定Sorted Set中删除1个或多个member，时间复杂度O(Mlog(N))，M为删除的member数量，N为Sorted Set中的member数量</li>
<li><strong>ZCOUNT</strong>：返回指定Sorted Set中指定score范围内的member数量，时间复杂度：O(log(N))</li>
<li><strong>ZCARD</strong>：返回指定Sorted Set中的member数量，时间复杂度O(1)</li>
<li><strong>ZSCORE</strong>：返回指定Sorted Set中指定member的score，时间复杂度O(1)</li>
<li><strong>ZRANK/ZREVRANK</strong>：返回指定member在Sorted Set中的排名，ZRANK返回按升序排序的排名，ZREVRANK则返回按降序排序的排名。时间复杂度O(log(N))</li>
<li><strong>ZINCRBY</strong>：同INCRBY，对指定Sorted Set中的指定member的score进行自增，时间复杂度O(log(N))</li>
</ul>
<p>慎用的Sorted Set相关命令：</p>
<ul>
<li><strong>ZRANGE/ZREVRANGE</strong>：返回指定Sorted Set中指定排名范围内的所有member，ZRANGE为按score升序排序，ZREVRANGE为按score降序排序，时间复杂度O(log(N)+M)，M为本次返回的member数</li>
<li><strong>ZRANGEBYSCORE/ZREVRANGEBYSCORE</strong>：返回指定Sorted Set中指定score范围内的所有member，返回结果以升序/降序排序，min和max可以指定为-inf和+inf，代表返回所有的member。时间复杂度O(log(N)+M)</li>
<li><strong>ZREMRANGEBYRANK/ZREMRANGEBYSCORE</strong>：移除Sorted Set中指定排名范围/指定score范围内的所有member。时间复杂度O(log(N)+M)</li>
</ul>
<p>上述几个命令，应尽量避免传递[0 -1]或[-inf +inf]这样的参数，来对Sorted Set做一次性的完整遍历，特别是在Sorted Set的尺寸不可预知的情况下。</p>
<h2 id="Bitmap和HyperLogLog"><a href="#Bitmap和HyperLogLog" class="headerlink" title="Bitmap和HyperLogLog"></a><strong>Bitmap和HyperLogLog</strong></h2><p>Redis的这两种数据结构相较之前的并不常用，在本文中只做简要介绍<br>Bitmap在Redis中不是一种实际的数据类型，而是一种将String作为Bitmap使用的方法。<br>可以理解为将String转换为bit数组。使用Bitmap来存储true/false类型的简单数据极为节省空间。<br>HyperLogLogs是一种主要用于数量统计的数据结构，它和Set类似，维护一个不可重复的String集合<br>但是HyperLogLogs并不维护具体的member内容，只维护member的个数。<br>也就是说，HyperLogLogs只能用于计算一个集合中不重复的元素数量，所以它比Set要节省很多内存空间。</p>
<h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a><strong>其他常用命令</strong></h2><ul>
<li><strong>EXISTS</strong>：判断指定的key是否存在，返回1代表存在，0代表不存在，时间复杂度O(1)</li>
<li><strong>DEL</strong>：删除指定的key及其对应的value，时间复杂度O(N)，N为删除的key数量</li>
<li><strong>EXPIRE/PEXPIRE</strong>：为一个key设置有效期，单位为秒或毫秒，时间复杂度O(1)</li>
<li><strong>TTL/PTTL</strong>：返回一个key剩余的有效时间，单位为秒或毫秒，时间复杂度O(1)</li>
<li><strong>RENAME/RENAMENX</strong>：将key重命名为newkey。使用RENAME时，如果newkey已经存在，其值会被覆盖；使用RENAMENX时，如果newkey已经存在，则不会进行任何操作，时间复杂度O(1)</li>
<li><strong>TYPE</strong>：返回指定key的类型，string, list, set, zset, hash。时间复杂度O(1)</li>
<li><strong>CONFIG GET</strong>：获得Redis某配置项的当前值，可以使用*通配符，时间复杂度O(1)</li>
<li><strong>CONFIG SET</strong>：为Redis某个配置项设置新值，时间复杂度O(1)</li>
<li><strong>CONFIG REWRITE</strong>：让Redis重新加载redis.conf中的配置</li>
</ul>
<h1 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a><strong>数据持久化</strong></h1><p>Redis提供了将数据定期自动持久化至硬盘的能力，包括RDB和AOF两种方案。<br>两种方案分别有其长处和短板，可以配合起来同时运行，确保数据的稳定性。</p>
<h2 id="必须使用数据持久化吗？"><a href="#必须使用数据持久化吗？" class="headerlink" title="必须使用数据持久化吗？"></a><strong>必须使用数据持久化吗？</strong></h2><p>Redis的数据持久化机制是可以关闭的，如果你只把Redis作为缓存服务使用，Redis中存储的所有数据都不是该数据的主体而仅仅是同步过来的备份，那么可以关闭Redis的数据持久化机制。<br>但通常来说，仍然建议至少开启RDB方式的数据持久化，因为：</p>
<ul>
<li>RDB方式的持久化几乎不损耗Redis本身的性能，在进行RDB持久化时，Redis主进程唯一需要做的事情就是fork出一个子进程，所有持久化工作都由子进程完成</li>
<li>Redis无论因为什么原因crash掉之后，重启时能够自动恢复到上一次RDB快照中记录的数据。这省去了手工从其他数据源（如DB）同步数据的过程，而且要比其他任何的数据恢复方式都要快</li>
<li>现在硬盘那么大，真的不缺那一点地方</li>
</ul>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a><strong>RDB</strong></h2><p>采用RDB持久方式，Redis会定期保存数据快照至一个rbd文件中，并在启动时自动加载rdb文件，恢复之前保存的数据。<br>可以在配置文件中配置Redis进行快照保存的时机：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">save</span> <span class="selector-attr">[seconds]</span> <span class="selector-attr">[changes]</span></span></pre></td></tr></table></figure>

<p>意为在[seconds]秒内如果发生了[changes]次数据修改，则进行一次RDB快照保存，例如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">save <span class="number">60</span> <span class="number">100</span></span></pre></td></tr></table></figure>

<p>会让Redis每60秒检查一次数据变更情况，如果发生了100次或以上的数据变更，则进行RDB快照保存。<br>可以配置多条save指令，让Redis执行多级的快照保存策略。<br>Redis默认开启RDB快照，默认的RDB策略如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span>s</span></pre></td></tr><tr><td class="code"><pre><span class="line">save <span class="number">300</span> <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">save <span class="number">60</span> <span class="number">10000</span></span></pre></td></tr></table></figure>

<p>也可以通过<strong>BGSAVE</strong>命令手工触发RDB快照保存。<br><strong>RDB的优点：</strong></p>
<ul>
<li>对性能影响最小。如前文所述，Redis在保存RDB快照时会fork出子进程进行，几乎不影响Redis处理客户端请求的效率。</li>
<li>每次快照会生成一个完整的数据快照文件，所以可以辅以其他手段保存多个时间点的快照（例如把每天0点的快照备份至其他存储媒介中），作为非常可靠的灾难恢复手段。</li>
<li>使用RDB文件进行数据恢复比使用AOF要快很多。</li>
</ul>
<p><strong>RDB的缺点：</strong></p>
<ul>
<li>快照是定期生成的，所以在Redis crash时或多或少会丢失一部分数据。</li>
<li>如果数据集非常大且CPU不够强（比如单核CPU），Redis在fork子进程时可能会消耗相对较长的时间（长至1秒），影响这期间的客户端请求。</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a><strong>AOF</strong></h2><p>采用AOF持久方式时，Redis会把每一个写请求都记录在一个日志文件里。<br>在Redis重启时，会把AOF文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。<br>AOF默认是关闭的，如要开启，进行如下配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">appendonly</span> <span class="literal">yes</span></span></pre></td></tr></table></figure>

<p>AOF提供了三种fsync配置，always/everysec/no，通过配置项[appendfsync]指定：</p>
<ul>
<li><strong>appendfsync no</strong>：不进行fsync，将flush文件的时机交给OS决定，速度最快</li>
<li><strong>appendfsync always</strong>：每写入一条日志就进行一次fsync操作，数据安全性最高，但速度最慢</li>
<li><strong>appendfsync everysec</strong>：折中的做法，交由后台线程每秒fsync一次</li>
</ul>
<p>随着AOF不断地记录写操作日志，必定会出现一些无用的日志<br>例如某个时间点执行了命令<strong>SET key1 “abc”</strong>，在之后某个时间点又执行了<strong>SET key1 “bcd”</strong>，那么第一条命令很显然是没有用的。<br>大量的无用日志会让AOF文件过大，也会让数据恢复的时间过长。<br>所以Redis提供了AOF rewrite功能，可以重写AOF文件，只保留能够把数据恢复到最新状态的最小写操作集。<br>AOF rewrite可以通过<strong>BGREWRITEAOF</strong>命令触发，也可以配置Redis定期自动进行：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">auto</span>-aof-rewrite-percentage <span class="number">100</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">auto</span>-aof-rewrite-min-size <span class="number">64</span>mb</span></pre></td></tr></table></figure>

<p>上面两行配置的含义是，Redis在每次AOF rewrite时，会记录完成rewrite后的AOF日志大小，当AOF日志大小在该基础上增长了100%后，自动进行AOF rewrite。同时如果增长的大小没有达到64mb，则不会进行rewrite。<br><strong>AOF的优点：</strong></p>
<ul>
<li>最安全，在启用appendfsync always时，任何已写入的数据都不会丢失，使用在启用appendfsync everysec也至多只会丢失1秒的数据。</li>
<li>AOF文件在发生断电等问题时也不会损坏，即使出现了某条日志只写入了一半的情况，也可以使用redis-check-aof工具轻松修复。</li>
<li>AOF文件易读，可修改，在进行了某些错误的数据清除操作后，只要AOF文件没有rewrite，就可以把AOF文件备份出来，把错误的命令删除，然后恢复数据。</li>
</ul>
<p><strong>AOF的缺点：</strong></p>
<ul>
<li>AOF文件通常比RDB文件更大</li>
<li>性能消耗比RDB高</li>
<li>数据恢复速度比RDB慢</li>
</ul>
<h1 id="内存管理与数据淘汰机制"><a href="#内存管理与数据淘汰机制" class="headerlink" title="内存管理与数据淘汰机制"></a><strong>内存管理与数据淘汰机制</strong></h1><h2 id="最大内存设置"><a href="#最大内存设置" class="headerlink" title="最大内存设置"></a><strong>最大内存设置</strong></h2><p>默认情况下，在32位OS中，Redis最大使用3GB的内存，在64位OS中则没有限制。<br>在使用Redis时，应该对数据占用的最大空间有一个基本准确的预估，并为Redis设定最大使用的内存。<br>否则在64位OS中Redis会无限制地占用内存（当物理内存被占满后会使用swap空间），容易引发各种各样的问题。<br>通过如下配置控制Redis使用的最大内存：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">maxmemory <span class="number">100</span>mb</span></pre></td></tr></table></figure>

<p>在内存占用达到了maxmemory后，再向Redis写入数据时，Redis会：</p>
<ul>
<li>根据配置的数据淘汰策略尝试淘汰数据，释放空间</li>
<li>如果没有数据可以淘汰，或者没有配置数据淘汰策略，那么Redis会对所有写请求返回错误，但读请求仍然可以正常执行</li>
</ul>
<p>在为Redis设置maxmemory时，需要注意：</p>
<p>如果采用了Redis的主从同步，主节点向从节点同步数据时，会占用掉一部分内存空间</p>
<p>如果maxmemory过于接近主机的可用内存，会导致数据同步时内存不足。</p>
<p>所以设置的maxmemory不要过于接近主机可用的内存，留出一部分预留用作主从同步。</p>
<h2 id="数据淘汰机制"><a href="#数据淘汰机制" class="headerlink" title="数据淘汰机制"></a><strong>数据淘汰机制</strong></h2><p>Redis提供了5种数据淘汰策略：</p>
<ul>
<li><strong>volatile-lru</strong>：使用LRU算法进行数据淘汰（淘汰上次使用时间最早的，且使用次数最少的key），只淘汰设定了有效期的key</li>
<li><strong>allkeys-lru</strong>：使用LRU算法进行数据淘汰，所有的key都可以被淘汰</li>
<li><strong>volatile-random</strong>：随机淘汰数据，只淘汰设定了有效期的key</li>
<li><strong>allkeys-random</strong>：随机淘汰数据，所有的key都可以被淘汰</li>
<li><strong>volatile-ttl</strong>：淘汰剩余有效期最短的key</li>
</ul>
<p>最好为Redis指定一种有效的数据淘汰策略以配合maxmemory设置，避免在内存使用满后发生写入失败的情况。<br>一般来说，推荐使用的策略是volatile-lru，并辨识Redis中保存的数据的重要性。<br>对于那些重要的，绝对不能丢弃的数据（如配置类数据等），应不设置有效期，这样Redis就永远不会淘汰这些数据。<br>对于那些相对不是那么重要的，并且能够热加载的数据（比如缓存最近登录的用户信息，当在Redis中找不到时，程序会去DB中读取），可以设置上有效期，这样在内存不够时Redis就会淘汰这部分数据。<br>配置方法：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">maxmemory-policy <span class="keyword">volatile</span>-lru <span class="meta">#默认是noeviction，即不进行数据淘汰</span></span></pre></td></tr></table></figure>

<h2 id="Pipelining"><a href="#Pipelining" class="headerlink" title="Pipelining"></a><strong>Pipelining</strong></h2><p>Redis提供许多批量操作的命令，如MSET/MGET/HMSET/HMGET等等，这些命令存在的意义是减少维护网络连接和传输数据所消耗的资源和时间。<br>例如连续使用5次SET命令设置5个不同的key，比起使用一次MSET命令设置5个不同的key，效果是一样的<br>但前者会消耗更多的RTT(Round Trip Time)时长，永远应优先使用后者。<br>然而，如果客户端要连续执行的多次操作无法通过Redis命令组合在一起，例如：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> a <span class="comment">"abc"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">INCR <span class="comment">b</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HSET <span class="comment">c name</span> <span class="comment">"hi"</span></span></pre></td></tr></table></figure>

<p>此时便可以使用Redis提供的pipelining功能来实现在一次交互中执行多条命令。<br>使用pipelining时，只需要从客户端一次向Redis发送多条命令（以\r\n）分隔，Redis就会依次执行这些命令，并且把每个命令的返回按顺序组装在一起一次返回，比如：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">$ (printf <span class="string">"PING\r<span class="subst">\n</span>PING\r<span class="subst">\n</span>PING\r<span class="subst">\n</span>"</span>; sleep <span class="number">1</span>) | nc localhost <span class="number">6379</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">+PONG</span></pre></td></tr><tr><td class="code"><pre><span class="line">+PONG</span></pre></td></tr><tr><td class="code"><pre><span class="line">+PONG</span></pre></td></tr></table></figure>

<p>大部分的Redis客户端都对Pipelining提供支持，所以开发者通常并不需要自己手工拼装命令列表。</p>
<h3 id="Pipelining的局限性"><a href="#Pipelining的局限性" class="headerlink" title="Pipelining的局限性"></a><strong>Pipelining的局限性</strong></h3><p>Pipelining只能用于执行<strong>连续且无相关性</strong>的命令，当某个命令的生成需要依赖于前一个命令的返回时，就无法使用Pipelining了。<br>通过Scripting功能，可以规避这一局限性</p>
<h2 id="事务与Scripting"><a href="#事务与Scripting" class="headerlink" title="事务与Scripting"></a><strong>事务与Scripting</strong></h2><p>Pipelining能够让Redis在一次交互中处理多条命令，然而在一些场景下，我们可能需要在此基础上确保这一组命令是连续执行的。<br>比如获取当前累计的PV数并将其清0</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt; <span class="builtin-name">GET</span> vCount</span></pre></td></tr><tr><td class="code"><pre><span class="line">12384</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; <span class="builtin-name">SET</span> vCount 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">OK</span></pre></td></tr></table></figure>

<p>如果在GET和SET命令之间插进来一个INCR vCount，就会使客户端拿到的vCount不准确。<br>Redis的事务可以确保复数命令执行时的原子性。<br>也就是说Redis能够保证：一个事务中的一组命令是绝对连续执行的，在这些命令执行完成之前，绝对不会有来自于其他连接的其他命令插进去执行。<br>通过MULTI和EXEC命令来把这两个命令加入一个事务中：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt; MULTI</span></pre></td></tr><tr><td class="code"><pre><span class="line">OK</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; GET vCount</span></pre></td></tr><tr><td class="code"><pre><span class="line">QUEUED</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; SET vCount <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">QUEUED</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; EXEC</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="number">12384</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span>) OK</span></pre></td></tr></table></figure>

<p>Redis在接收到MULTI命令后便会开启一个事务，这之后的所有读写命令都会保存在队列中但并不执行<br>直到接收到EXEC命令后，Redis会把队列中的所有命令连续顺序执行，并以数组形式返回每个命令的返回结果。<br>可以使用DISCARD命令放弃当前的事务，将保存的命令队列清空。<br>需要注意的是，<strong>Redis事务不支持回滚</strong>：如果一个事务中的命令出现了语法错误，大部分客户端驱动会返回错误<br>2.6.5版本以上的Redis也会在执行EXEC时检查队列中的命令是否存在语法错误，如果存在，则会自动放弃事务并返回错误。<br>但如果一个事务中的命令有非语法类的错误（比如对String执行HSET操作），无论客户端驱动还是Redis都无法在真正执行这条命令之前发现，所以事务中的所有命令仍然会被依次执行。<br>在这种情况下，会出现一个事务中部分命令成功部分命令失败的情况，然而与RDBMS不同，Redis不提供事务回滚的功能，所以只能通过其他方法进行数据的回滚。</p>
<h2 id="通过事务实现CAS"><a href="#通过事务实现CAS" class="headerlink" title="通过事务实现CAS"></a><strong>通过事务实现CAS</strong></h2><p>Redis提供了WATCH命令与事务搭配使用，实现CAS乐观锁的机制。<br>假设要实现将某个商品的状态改为已售：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">if(exec(HGET stock:<span class="number">1001</span> <span class="keyword">state</span>) == <span class="string">"in stock"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    exec(HSET stock:<span class="number">1001</span> <span class="keyword">state</span> <span class="string">"sold"</span>);</span></pre></td></tr></table></figure>

<p>这一伪代码执行时，无法确保并发安全性，有可能多个客户端都获取到了”in stock”的状态，导致一个库存被售卖多次。<br>使用WATCH命令和事务可以解决这一问题：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">exec(WATCH stock:<span class="number">1001</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">if(exec(HGET stock:<span class="number">1001</span> <span class="keyword">state</span>) == <span class="string">"in stock"</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    exec(MULTI);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    exec(HSET stock:<span class="number">1001</span> <span class="keyword">state</span> <span class="string">"sold"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    exec(EXEC);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>WATCH的机制是</strong>：在事务EXEC命令执行时，Redis会检查被WATCH的key，只有被WATCH的key从WATCH起始时至今没有发生过变更，EXEC才会被执行。<br>如果WATCH的key在WATCH命令到EXEC命令之间发生过变化，则EXEC命令会返回失败。</p>
<h2 id="Scripting"><a href="#Scripting" class="headerlink" title="Scripting"></a><strong>Scripting</strong></h2><p>通过EVAL与EVALSHA命令，可以让Redis执行LUA脚本。这就类似于RDBMS的存储过程一样，可以把客户端与Redis之间密集的读/写交互放在服务端进行，避免过多的数据交互，提升性能。<br>Scripting功能是作为事务功能的替代者诞生的，事务提供的所有能力Scripting都可以做到。Redis官方推荐使用LUA Script来代替事务，前者的效率和便利性都超过了事务。<br>关于Scripting的具体使用，本文不做详细介绍，请参考官方文档 <a href="https://redis.io/commands/eval" target="_blank" rel="noopener">https://redis.io/commands/eval</a></p>
<h1 id="Redis性能调优"><a href="#Redis性能调优" class="headerlink" title="Redis性能调优"></a><strong>Redis性能调优</strong></h1><p>尽管Redis是一个非常快速的内存数据存储媒介，也并不代表Redis不会产生性能问题。<br>前文中提到过，Redis采用单线程模型，所有的命令都是由一个线程串行执行的<br>所以当某个命令执行耗时较长时，会拖慢其后的所有命令，这使得Redis对每个任务的执行效率更加敏感。<br>针对Redis的性能优化，主要从下面几个层面入手：</p>
<ul>
<li>最初的也是最重要的，确保没有让Redis执行耗时长的命令</li>
<li>使用pipelining将连续执行的命令组合执行</li>
<li>操作系统的Transparent huge pages功能必须关闭：</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">echo never &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/mm/</span>transparent_hugepage<span class="regexp">/enabled</span></span></pre></td></tr></table></figure>

<ul>
<li>如果在虚拟机中运行Redis，可能天然就有虚拟机环境带来的固有延迟。</li>
<li>可以通过./redis-cli –intrinsic-latency 100命令查看固有延迟。同时如果对Redis的性能有较高要求的话，应尽可能在物理机上直接部署Redis。</li>
<li>检查数据持久化策略</li>
<li>考虑引入读写分离机制</li>
</ul>
<h2 id="长耗时命令"><a href="#长耗时命令" class="headerlink" title="长耗时命令"></a><strong>长耗时命令</strong></h2><p>Redis绝大多数读写命令的时间复杂度都在O(1)到O(N)之间，在本文和官方文档中均对每个命令的时间复杂度有说明。<br>通常来说，O(1)的命令是安全的，O(N)命令在使用时需要注意，如果N的数量级不可预知，则应避免使用。<br>例如对一个field数未知的Hash数据执行HGETALL/HKEYS/HVALS命令，通常来说这些命令执行的很快，但如果这个Hash中的field数量极多，耗时就会成倍增长。<br>又如使用SUNION对两个Set执行Union操作，或使用SORT对List/Set执行排序操作等时，都应该严加注意。<br>避免在使用这些O(N)命令时发生问题主要有几个办法：</p>
<ul>
<li>不要把List当做列表使用，仅当做队列来使用</li>
<li>通过机制严格控制Hash、Set、Sorted Set的大小</li>
<li>可能的话，将排序、并集、交集等操作放在客户端执行</li>
<li>绝对禁止使用KEYS命令</li>
<li>避免一次性遍历集合类型的所有成员，而应使用SCAN类的命令进行分批的，游标式的遍历</li>
</ul>
<p>Redis提供了SCAN命令，可以对Redis中存储的所有key进行游标式的遍历，避免使用KEYS命令带来的性能问题。<br>同时还有SSCAN/HSCAN/ZSCAN等命令，分别用于对Set/Hash/Sorted Set中的元素进行游标式遍历。<br>SCAN类命令的使用请参考官方文档：<br><a href="https://redis.io/commands/scan" target="_blank" rel="noopener">https://redis.io/commands/scan</a><br>Redis提供了Slow Log功能，可以自动记录耗时较长的命令。相关的配置参数有两个：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">slowlog-<span class="built_in">log</span>-slower-than xxxms #执行时间慢于xxx毫秒的命令计入Slow <span class="built_in">Log</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">slowlog-<span class="built_in">max</span>-<span class="built_in">len</span> xxx #Slow <span class="built_in">Log</span>的长度，即最大纪录多少条Slow <span class="built_in">Log</span></span></pre></td></tr></table></figure>

<p>使用<strong>SLOWLOG GET [number]</strong>命令，可以输出最近进入Slow Log的number条命令。<br>使用<strong>SLOWLOG RESET</strong>命令，可以重置Slow Log</p>
<h2 id="网络引发的延迟"><a href="#网络引发的延迟" class="headerlink" title="网络引发的延迟"></a><strong>网络引发的延迟</strong></h2><ul>
<li>尽可能使用长连接或连接池，避免频繁创建销毁连接</li>
<li>客户端进行的批量数据操作，应使用Pipeline特性在一次交互中完成。具体请参照本文的Pipelining章节</li>
</ul>
<h2 id="数据持久化引发的延迟"><a href="#数据持久化引发的延迟" class="headerlink" title="数据持久化引发的延迟"></a><strong>数据持久化引发的延迟</strong></h2><p>Redis的数据持久化工作本身就会带来延迟，需要根据数据的安全级别和性能要求制定合理的持久化策略：</p>
<ul>
<li>AOF + fsync always的设置虽然能够绝对确保数据安全，但每个操作都会触发一次fsync，会对Redis的性能有比较明显的影响。</li>
<li>AOF + fsync every second是比较好的折中方案，每秒fsync一次</li>
<li>AOF + fsync never会提供AOF持久化方案下的最优性能</li>
<li>使用RDB持久化通常会提供比使用AOF更高的性能，但需要注意RDB的策略配置</li>
<li>每一次RDB快照和AOF Rewrite都需要Redis主进程进行fork操作。fork操作本身可能会产生较高的耗时，与CPU和Redis占用的内存大小有关。根据具体的情况合理配置RDB快照和AOF Rewrite时机，避免过于频繁的fork带来的延迟</li>
</ul>
<blockquote>
<p>Redis在fork子进程时需要将内存分页表拷贝至子进程以占用了24GB内存的Redis实例为例，共需要拷贝24GB / 4kB * 8 = 48MB的数据。在使用单Xeon 2.27Ghz的物理机上，这一fork操作耗时216ms。可以通过<strong>INFO</strong>命令返回的latest_fork_usec字段查看上一次fork操作的耗时（微秒）</p>
</blockquote>
<h2 id="Swap引发的延迟"><a href="#Swap引发的延迟" class="headerlink" title="Swap引发的延迟"></a><strong>Swap引发的延迟</strong></h2><p>当Linux将Redis所用的内存分页移至swap空间时，将会阻塞Redis进程，导致Redis出现不正常的延迟。<br>Swap通常在物理内存不足或一些进程在进行大量I/O操作时发生，应尽可能避免上述两种情况的出现。<br>/proc//smaps文件中会保存进程的swap记录，通过查看这个文件，能够判断Redis的延迟是否由Swap产生。<br>如果这个文件中记录了较大的Swap size，则说明延迟很有可能是Swap造成的。</p>
<h2 id="数据淘汰引发的延迟"><a href="#数据淘汰引发的延迟" class="headerlink" title="数据淘汰引发的延迟"></a><strong>数据淘汰引发的延迟</strong></h2><p>当同一秒内有大量key过期时，也会引发Redis的延迟。在使用时应尽量将key的失效时间错开。</p>
<h2 id="引入读写分离机制"><a href="#引入读写分离机制" class="headerlink" title="引入读写分离机制"></a><strong>引入读写分离机制</strong></h2><p>Redis的主从复制能力可以实现一主多从的多节点架构，在这一架构下，主节点接收所有写请求，并将数据同步给多个从节点。<br>在这一基础上，我们可以让从节点提供对实时性要求不高的读请求服务，以减小主节点的压力。<br>尤其是针对一些使用了长耗时命令的统计类任务，完全可以指定在一个或多个从节点上执行，避免这些长耗时命令影响其他请求的响应。</p>
<h1 id="主从复制与集群分片"><a href="#主从复制与集群分片" class="headerlink" title="主从复制与集群分片"></a><strong>主从复制与集群分片</strong></h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a><strong>主从复制</strong></h2><p>Redis支持一主多从的主从复制架构。一个Master实例负责处理所有的写请求，Master将写操作同步至所有Slave。<br>借助Redis的主从复制，可以实现读写分离和高可用：</p>
<ul>
<li>实时性要求不是特别高的读请求，可以在Slave上完成，提升效率。特别是一些周期性执行的统计任务，这些任务可能需要执行一些长耗时的Redis命令，可以专门规划出1个或几个Slave用于服务这些统计任务</li>
<li>借助Redis Sentinel可以实现高可用，当Master crash后，Redis Sentinel能够自动将一个Slave晋升为Master，继续提供服务</li>
</ul>
<p>启用主从复制非常简单，只需要配置多个Redis实例，在作为Slave的Redis实例中配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">slaveof</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> <span class="number">6379</span> <span class="comment">#指定Master的IP和端口</span></span></pre></td></tr></table></figure>

<p>当Slave启动后，会从Master进行一次冷启动数据同步<br>由Master触发BGSAVE生成RDB文件推送给Slave进行导入，导入完成后Master再将增量数据通过Redis Protocol同步给Slave<br>之后主从之间的数据便一直以Redis Protocol进行同步</p>
<h2 id="使用Sentinel做自动failover"><a href="#使用Sentinel做自动failover" class="headerlink" title="使用Sentinel做自动failover"></a><strong>使用Sentinel做自动failover</strong></h2><p>Redis的主从复制功能本身只是做数据同步，并不提供监控和自动failover能力<br>要通过主从复制功能来实现Redis的高可用，还需要引入一个组件：Redis Sentinel<br>Redis Sentinel是Redis官方开发的监控组件，可以监控Redis实例的状态，通过Master节点自动发现Slave节点，并在监测到Master节点失效时选举出一个新的Master，并向所有Redis实例推送新的主从配置。<br>Redis Sentinel需要至少部署3个实例才能形成选举关系。<br>关键配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">sentinel</span> <span class="string">monitor</span> <span class="string">mymaster</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> <span class="number">2</span> <span class="comment">#Master实例的IP、端口，以及选举需要的赞成票数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">sentinel</span> <span class="string">down-after-milliseconds</span> <span class="string">mymaster</span> <span class="number">60000</span> <span class="comment">#多长时间没有响应视为Master失效</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">sentinel</span> <span class="string">failover-timeout</span> <span class="string">mymaster</span> <span class="number">180000</span> <span class="comment">#两次failover尝试间的间隔时长</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">sentinel</span> <span class="string">parallel-syncs</span> <span class="string">mymaster</span> <span class="number">1</span> <span class="comment">#如果有多个Slave，可以通过此配置指定同时从新Master进行数据同步的Slave数，避免所有Slave同时进行数据同步导致查询服务也不可用</span></span></pre></td></tr></table></figure>

<p>另外需要注意的是，Redis Sentinel实现的自动failover不是在同一个IP和端口上完成的<br>也就是说自动failover产生的新Master提供服务的IP和端口与之前的Master是不一样的，所以要实现HA，还要求客户端必须支持Sentinel，能够与Sentinel交互获得新Master的信息才行。</p>
<h2 id="集群分片"><a href="#集群分片" class="headerlink" title="集群分片"></a><strong>集群分片</strong></h2><p>为何要做集群分片：</p>
<ul>
<li>Redis中存储的数据量大，一台主机的物理内存已经无法容纳</li>
<li>Redis的写请求并发量大，一个Redis实例以无法承载</li>
</ul>
<p>当上述两个问题出现时，就必须要对Redis进行分片了。<br>Redis的分片方案有很多种，例如很多Redis的客户端都自行实现了分片功能，也有像Twemproxy这样的以代理方式实现的Redis分片方案。<br>然而首选的方案还应该是Redis官方在3.0版本中推出的Redis Cluster分片方案。<br>本文不会对Redis Cluster的具体安装和部署细节进行介绍，重点介绍Redis Cluster带来的好处与弊端。</p>
<h3 id="Redis-Cluster的能力"><a href="#Redis-Cluster的能力" class="headerlink" title="Redis Cluster的能力"></a><strong>Redis Cluster的能力</strong></h3><ul>
<li>能够自动将数据分散在多个节点上</li>
<li>当访问的key不在当前分片上时，能够自动将请求转发至正确的分片</li>
<li>当集群中部分节点失效时仍能提供服务</li>
</ul>
<p>其中第三点是基于主从复制来实现的，Redis Cluster的每个数据分片都采用了主从复制的结构，原理和前文所述的主从复制完全一致<br>唯一的区别是省去了Redis Sentinel这一额外的组件，由Redis Cluster负责进行一个分片内部的节点监控和自动failover。</p>
<h3 id="Redis-Cluster分片原理"><a href="#Redis-Cluster分片原理" class="headerlink" title="Redis Cluster分片原理"></a><strong>Redis Cluster分片原理</strong></h3><p>Redis Cluster中共有16384个hash slot，Redis会计算每个key的CRC16，将结果与16384取模，来决定该key存储在哪一个hash slot中，<br>同时需要指定Redis Cluster中每个数据分片负责的Slot数，Slot的分配在任何时间点都可以进行重新分配。<br>客户端在对key进行读写操作时，可以连接Cluster中的任意一个分片，如果操作的key不在此分片负责的Slot范围内，Redis Cluster会自动将请求重定向到正确的分片上。</p>
<h3 id="hash-tags"><a href="#hash-tags" class="headerlink" title="hash tags"></a><strong>hash tags</strong></h3><p>在基础的分片原则上，Redis还支持hash tags功能，以hash tags要求的格式明明的key，将会确保进入同一个Slot中。<br>例如：{uiv}user:1000和{uiv}user:1001拥有同样的hash tag {uiv}，会保存在同一个Slot中。<br>使用Redis Cluster时，pipelining、事务和LUA Script功能涉及的key必须在同一个数据分片上，否则将会返回错误。<br>如要在Redis Cluster中使用上述功能，就必须通过hash tags来确保一个pipeline或一个事务中操作的所有key都位于同一个Slot中。</p>
<blockquote>
<p>有一些客户端（如Redisson）实现了集群化的pipelining操作，可以自动将一个pipeline里的命令按key所在的分片进行分组，分别发到不同的分片上执行。但是Redis不支持跨分片的事务，事务和LUA Script还是必须遵循所有key在一个分片上的规则要求。</p>
</blockquote>
<h2 id="主从复制-vs-集群分片"><a href="#主从复制-vs-集群分片" class="headerlink" title="主从复制 vs 集群分片"></a><strong>主从复制 vs 集群分片</strong></h2><p>在设计软件架构时，要如何在主从复制和集群分片两种部署方案中取舍呢？<br>从各个方面看，Redis Cluster都是优于主从复制的方案</p>
<ul>
<li>Redis Cluster能够解决单节点上数据量过大的问题</li>
<li>Redis Cluster能够解决单节点访问压力过大的问题</li>
<li>Redis Cluster包含了主从复制的能力</li>
</ul>
<p>那是不是代表Redis Cluster永远是优于主从复制的选择呢？<br>并不是！！！<br>软件架构永远不是越复杂越好，复杂的架构在带来显著好处的同时，一定也会带来相应的弊端。采用Redis Cluster的弊端包括：</p>
<p><strong>1、维护难度增加</strong>。</p>
<p>在使用Redis Cluster时，需要维护的Redis实例数倍增，需要监控的主机数量也相应增加，数据备份/持久化的复杂度也会增加。</p>
<p>同时在进行分片的增减操作时，还需要进行reshard操作，远比主从模式下增加一个Slave的复杂度要高。</p>
<p><strong>2、客户端资源消耗增加</strong></p>
<p>当客户端使用连接池时，需要为每一个数据分片维护一个连接池，客户端同时需要保持的连接数成倍增多，加大了客户端本身和操作系统资源的消耗。</p>
<p><strong>3、性能优化难度增加</strong></p>
<p>你可能需要在多个分片上查看Slow Log和Swap日志才能定位性能问题。</p>
<p><strong>4、事务和LUA Script的使用成本增加</strong></p>
<p>在Redis Cluster中使用事务和LUA Script特性有严格的限制条件</p>
<p>事务和Script中操作的key必须位于同一个分片上，这就使得在开发时必须对相应场景下涉及的key进行额外的规划和规范要求。</p>
<p>如果应用的场景中大量涉及事务和Script的使用，如何在保证这两个功能的正常运作前提下把数据平均分到多个数据分片中就会成为难点。</p>
<p>所以，在主从复制和集群分片两个方案中做出选择时，应该从应用软件的功能特性、数据和访问量级、未来发展规划等方面综合考虑，只在<strong>确实有必要</strong>引入数据分片时再使用Redis Cluster。<br><strong>下面是一些建议：</strong></p>
<ul>
<li>需要在Redis中存储的数据有多大？未来2年内可能发展为多大？这些数据是否都需要长期保存？是否可以使用LRU算法进行非热点数据的淘汰？综合考虑前面几个因素，评估出Redis需要使用的物理内存。</li>
<li>用于部署Redis的主机物理内存有多大？有多少可以分配给Redis使用？对比(1)中的内存需求评估，是否足够用？</li>
<li>Redis面临的并发写压力会有多大？在不使用pipelining时，Redis的写性能可以超过10万次/秒（更多的benchmark可以参考 <a href="https://redis.io/topics/benchmarks" target="_blank" rel="noopener">https://redis.io/topics/benchmarks</a> ）</li>
<li>在使用Redis时，是否会使用到pipelining和事务功能？使用的场景多不多？</li>
</ul>
<p>综合上面几点考虑，如果单台主机的可用物理内存完全足以支撑对Redis的容量需求，且Redis面临的并发写压力距离Benchmark值还尚有距离，建议采用主从复制的架构，可以省去很多不必要的麻烦。<br>同时，如果应用中大量使用pipelining和事务，也建议尽可能选择主从复制架构，可以减少设计和开发时的复杂度。</p>
<h1 id="Redis-Java客户端的选择"><a href="#Redis-Java客户端的选择" class="headerlink" title="Redis Java客户端的选择"></a><strong>Redis Java客户端的选择</strong></h1><p>Redis的Java客户端很多，官方推荐的有三种：Jedis、Redisson和lettuce。<br>在这里对Jedis和Redisson进行对比介绍<br>Jedis：</p>
<ul>
<li>轻量，简洁，便于集成和改造</li>
<li>支持连接池</li>
<li>支持pipelining、事务、LUA Scripting、Redis Sentinel、Redis Cluster</li>
<li>不支持读写分离，需要自己实现</li>
<li>文档差（真的很差，几乎没有……）</li>
</ul>
<p>Redisson：</p>
<ul>
<li>基于Netty实现，采用非阻塞IO，性能高</li>
<li>支持异步请求</li>
<li>支持连接池</li>
<li>支持pipelining、LUA Scripting、Redis Sentinel、Redis Cluster</li>
<li>不支持事务，官方建议以LUA Scripting代替事务</li>
<li>支持在Redis Cluster架构下使用pipelining</li>
<li>支持读写分离，支持读负载均衡，在主从复制和Redis Cluster架构下都可以使用</li>
<li>内建Tomcat Session Manager，为Tomcat 6/7/8提供了会话共享功能</li>
<li>可以与Spring Session集成，实现基于Redis的会话共享</li>
<li>文档较丰富，有中文文档</li>
</ul>
<p>对于Jedis和Redisson的选择，同样应遵循前述的原理，尽管Jedis比起Redisson有各种各样的不足，但也应该在需要使用Redisson的高级特性时再选用Redisson，避免造成不必要的程序复杂度提升。</p>
]]></content>
      <categories>
        <category>Java技术</category>
        <category>Redis</category>
      </categories>
  </entry>
</search>
