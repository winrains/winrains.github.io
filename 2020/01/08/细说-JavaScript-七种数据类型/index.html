<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://congsheng.wang').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="在 JavaScript 规范中，共定义了七种数据类型，分为 “基本类型” 和 “引用类型” 两大类，如下所示：  基本类型：String、Number、Boolean、Symbol、Undefined、Null 引用类型：Object  下面将详细介绍这七种数据类型的一些特性。">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="细说 JavaScript 七种数据类型">
<meta property="og:url" content="http:&#x2F;&#x2F;congsheng.wang&#x2F;2020&#x2F;01&#x2F;08&#x2F;%E7%BB%86%E8%AF%B4-JavaScript-%E4%B8%83%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&#x2F;index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="在 JavaScript 规范中，共定义了七种数据类型，分为 “基本类型” 和 “引用类型” 两大类，如下所示：  基本类型：String、Number、Boolean、Symbol、Undefined、Null 引用类型：Object  下面将详细介绍这七种数据类型的一些特性。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;a689f-849589-20171013113026887-1981568120.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;ee096-849589-20171013112848699-2046443732.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;9bb71-849589-20171013113341277-1573319144.png">
<meta property="og:updated_time" content="2020-01-08T02:23:46.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;a689f-849589-20171013113026887-1981568120.png">

<link rel="canonical" href="http://congsheng.wang/2020/01/08/%E7%BB%86%E8%AF%B4-JavaScript-%E4%B8%83%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>细说 JavaScript 七种数据类型 | 个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">congsheng的博客</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">141</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">91</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">807</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://congsheng.wang/2020/01/08/%E7%BB%86%E8%AF%B4-JavaScript-%E4%B8%83%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="congsheng.wang">
      <meta itemprop="description" content="trouble is a friend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          细说 JavaScript 七种数据类型
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-08 10:23:46" itemprop="dateCreated datePublished" datetime="2020-01-08T10:23:46+08:00">2020-01-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B6%E5%AE%83%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">其它技术</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B6%E5%AE%83%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>在 JavaScript 规范中，共定义了七种数据类型，分为 “基本类型” 和 “引用类型” 两大类，如下所示：</p>
<ul>
<li>基本类型：String、Number、Boolean、Symbol、Undefined、Null</li>
<li>引用类型：Object</li>
</ul>
<p>下面将详细介绍这七种数据类型的一些特性。</p>
<a id="more"></a>

<h2 id="1、String-类型"><a href="#1、String-类型" class="headerlink" title="1、String 类型"></a><strong>1、String 类型</strong></h2><p>String 类型用于表示由零或多个 16 位 Unicode 字符组成的字符序列，即字符串 。</p>
<h3 id="1-1-存储结构"><a href="#1-1-存储结构" class="headerlink" title="1.1 存储结构"></a>1.1 存储结构</h3><p>由于计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。在计算机中，1个字节（byte）由 8个比特（bit）组成，所以 1 个字节能表示的最大整数就是 255，如果想表示更大整数，就必须用更多的字节，比如 2 个字节可以表示的最大整数为 65535 。最早，只有 127 个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为 ASCII 编码，比如大写字母 A 的编码是 65，小写字母 z 的编码是122。<br>但如果要表示中文字符，显然一个字节是不够的，至少需要两个字节。所以，中国制定了 GB2312 编码，用来表示中文字符。基于同样的原因，各个国家都制定了自己的编码规则 。这样就会出现一个问题，即在多语言混合的文本中，不同的编码会出现冲突，导致乱码出现 。<br>为了解决这个问题，Unicode 编码应运而生，它把所有的语言都统一到一套编码中，采用 2 个字节表示一个字符，即最多可以表示 65535 个字符，这样基本上可以覆盖世界上常用的文字，如果要表示更多的文字，也可以采用 4 个字节进行编码，这是一种通用的编码规范 。<br>因此，JavaScript 中的字符也采用 Unicode 来编码 ，也就是说，JavaScript 中的英文字符和中文字符都会占用 2 个字节的空间大小 ，这种多字节字符，通常被称为宽字符。</p>
<h3 id="1-2-基本包装类型"><a href="#1-2-基本包装类型" class="headerlink" title="1.2 基本包装类型"></a>1.2 基本包装类型</h3><p>在 JavaScript 中，字符串是基本数据类型，本身不存任何操作方法 。为了方便的对字符串进行操作，ECMAScript 提供了一个基本包装类型：String 对象 。它是一种特殊的引用类型，JS引擎每当读取一个字符串的时候，就会在内部创建一个对应的 String 对象，该对象提供了很多操作字符的方法，这就是为什么能对字符串调用方法的原因 。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">name</span> = <span class="string">'JavaScript'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="keyword">name</span>.substr(<span class="number">2</span>,<span class="number">1</span>);</span></pre></td></tr></table></figure>



<p>当第二行代码访问变量 str 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，引擎内部会自动完成下列处理：</p>
<ul>
<li>创建 String 类型的一个实例</li>
<li>在实例上调用指定的方法</li>
<li>销毁这个实例</li>
</ul>
<p>用伪代码形象的模拟以上三个步骤：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">var obj</span> = new String(<span class="string">'JavaScript'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">var value</span> = obj.substr(2,1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">name</span> = null;</span></pre></td></tr></table></figure>



<p>可以看出，基本包装类型是一种特殊的引用类型。它和普通引用类型有一个很重要的区别，就是对象的生存期不同 。使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。在 JavaScript 中，类似的基本包装类型还有 Number、Boolean 对象 。</p>
<h3 id="1-3-常用操作方法"><a href="#1-3-常用操作方法" class="headerlink" title="1.3 常用操作方法"></a>1.3 常用操作方法</h3><p>作为字符串的基本包装类型，String 对象提供了以下几类方法，用以操作字符串：</p>
<ul>
<li>字符操作：charAt，charCodeAt，fromCharCode</li>
<li>字符串提取：substr，substring ，slice</li>
<li>位置索引：indexOf ，lastIndexOf</li>
<li>大小写转换：toLowerCase，toUpperCase</li>
<li>模式匹配：match，search，replace，split</li>
<li>其他操作：concat，trim，localeCompare</li>
</ul>
<p>charCodeAt 的作用是获取字符的 Unicode 编码，俗称 “Unicode 码点”。fromCharCode 是 String 对象上的静态方法，作用是根据 Unicode 编码返回对应的字符。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var a = <span class="character">'a'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Unicode编码</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">var code = a.<span class="built_in">char</span><span class="constructor">CodeAt(0)</span>; <span class="comment">// 97</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据Unicode编码获取字符</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>from<span class="constructor">CharCode(<span class="params">code</span>)</span>;  <span class="comment">// a</span></span></pre></td></tr></table></figure>



<p>通过 charCodeAt 获取字符的 Unicode 编码，然后再把这个编码转化成二进制，就可以得到该字符的二进制表示。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var a = <span class="character">'a'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">var code = a.<span class="built_in">char</span><span class="constructor">CodeAt(0)</span>; <span class="comment">// 97</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">code.<span class="keyword">to</span><span class="constructor">String(2)</span>; <span class="comment">// 1100001</span></span></pre></td></tr></table></figure>



<p>对于字符串的提取操作，有三个相类似的方法，分别如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">substr</span><span class="params">(start [, length])</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">substring</span><span class="params">(start [, end])</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">slice</span><span class="params">(start [, end])</span></span></span></pre></td></tr></table></figure>



<p>从定义上看，substring 和 slice 是同类的，参数都是字符串的某个 start 位置到某个 end 位置（但 end 位置的字符不包括在结果中）；而 substr 则是字符串的某个 start 位置起，数 length 个长度的字符才结束。二者的共性是：从 start 开始，如果没有第 2 个参数，都是直到字符串末尾。<br>substring 和 slice 的区别则是：slice 可以接受 “负数”，表示从字符串尾部开始计数； 而 substring 则把负数或其它无效的数当作 0。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="string">'hello world!'</span>.slice(-<span class="number">6</span>, -<span class="number">1</span>) <span class="regexp">//</span> <span class="string">'world'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="string">'hello world!'</span>.substring(<span class="string">"abc"</span>, <span class="number">5</span>) <span class="regexp">//</span> <span class="string">'hello'</span></span></pre></td></tr></table></figure>



<p>substr 的 start 也可接受负数，也表示从字符串尾部计数，这点和 slice 相同；但 substr 的 length 则不能小于 1，否则返回空字符串。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="string">'hello world!'</span>.substr(<span class="number">-6</span>, <span class="number">5</span>) <span class="comment">// 'world'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="string">'hello world!'</span>.substr(<span class="number">0</span>, <span class="number">-1</span>) <span class="comment">// ''</span></span></pre></td></tr></table></figure>



<h2 id="2、Number-类型"><a href="#2、Number-类型" class="headerlink" title="2、Number 类型"></a><strong>2、Number 类型</strong></h2><p>JavaScript 中的数字类型只有 Number 一种，Number 类型采用 IEEE754 标准中的 “双精度浮点数” 来表示一个数字，不区分整数和浮点数 。</p>
<h3 id="2-1-存储结构"><a href="#2-1-存储结构" class="headerlink" title="2.1 存储结构"></a>2.1 存储结构</h3><p>在 IEEE754 中，双精度浮点数采用 64 位存储，即 8 个字节表示一个浮点数 。其存储结构如下图所示：<br><img src="http://image.winrains.cn/2019/10/a689f-849589-20171013113026887-1981568120.png" alt="img"><br>指数位可以通过下面的方法转换为使用的指数值：<br><img src="http://image.winrains.cn/2019/10/ee096-849589-20171013112848699-2046443732.png" alt="img"></p>
<h3 id="2-2-数值范围"><a href="#2-2-数值范围" class="headerlink" title="2.2 数值范围"></a>2.2 数值范围</h3><p>从存储结构中可以看出， 指数部分的长度是11个二进制，即指数部分能表示的最大值是 <code>2047（2``11``-1）</code>，取中间值进行偏移，用来表示负指数，也就是说指数的范围是<code>[-1023,1024]</code> 。因此，这种存储结构能够表示的数值范围为 21024 到 2-1023 ，超出这个范围的数无法表示 。21024 和 2-1023 转换为科学计数法如下所示：</p>
<blockquote>
<p>1.7976931348623157 × 10308 </p>
<p>5 × 10-324</p>
</blockquote>
<p>因此，JavaScript 中能表示的最大值是<code>1.7976931348623157 × 10``308</code>，最小值为<code>5 × 10``-324</code> 。<br>这两个边界值可以分别通过访问 Number 对象的 <code>MAX_VALUE</code> 属性和 <code>MIN_VALUE</code> 属性来获取：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_VALUE; <span class="comment">// 1.7976931348623157e+308</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MIN_VALUE; <span class="comment">// 5e-324</span></span></pre></td></tr></table></figure>



<p>如果数字超过最大值或最小值，JavaScript 将返回一个不正确的值，这称为 “正向溢出(overflow)” 或 “负向溢出(underflow)” 。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_VALUE+<span class="number">1</span> == <span class="built_in">Number</span>.MAX_VALUE; <span class="comment">//true</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_VALUE+<span class="number">1e292</span>; <span class="comment">//Infinity</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MIN_VALUE + <span class="number">1</span>; <span class="comment">//1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MIN_VALUE - <span class="number">3e-324</span>; <span class="comment">//0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MIN_VALUE - <span class="number">2e-324</span>; <span class="comment">//5e-324</span></span></pre></td></tr></table></figure>



<h3 id="2-3-数值精度"><a href="#2-3-数值精度" class="headerlink" title="2.3 数值精度"></a>2.3 数值精度</h3><p>在 64 位的二进制中，符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。<br>IEEE754 规定，有效数字第一位默认总是1 。因此，在表示精度的位数前面，还存在一个 “隐藏位” ，固定为 1 ，但它不保存在 64 位浮点数之中。也就是说，有效数字总是 1.xx…xx 的形式，其中 xx..xx 的部分保存在 64 位浮点数之中，最长为52位 。所以，JavaScript 提供的有效数字最长为 53 个二进制位，其内部实际的表现形式为：<br><code>(-1)^符号位 * 1.xx...xx * 2^指数位</code><br>这意味着，JavaScript 能表示并进行精确算术运算的整数范围为：<code>[-2``53``-1，2``53``-1]</code>，即从最小值 -9007199254740991 到最大值 9007199254740991 之间的范围 。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Math.pow(<span class="number">2</span>, <span class="number">53</span>)<span class="number">-1</span> ; <span class="comment">// 9007199254740991</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-Math.pow(<span class="number">2</span>, <span class="number">53</span>)<span class="number">-1</span> ; <span class="comment">// -9007199254740991</span></span></pre></td></tr></table></figure>



<p>可以通过 <code>Number.MAX_SAFE_INTEGER</code> 和 <code>Number.MIN_SAFE_INTEGER</code> 来分别获取这个最大值和最小值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_SAFE_INTEGER) ; <span class="comment">// 9007199254740991</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MIN_SAFE_INTEGER) ; <span class="comment">// -9007199254740991</span></span></pre></td></tr></table></figure>



<p>对于超过这个范围的整数，JavaScript 依旧可以进行运算，但却不保证运算结果的精度。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Math.pow(<span class="number">2</span>, <span class="number">53</span>) ; <span class="comment">// 9007199254740992</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Math.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span>; <span class="comment">// 9007199254740992</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="number">9007199254740993</span>; <span class="comment">//9007199254740992</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="number">90071992547409921</span>; <span class="comment">//90071992547409920</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="number">0.923456789012345678</span>;<span class="comment">//0.9234567890123456</span></span></pre></td></tr></table></figure>



<h3 id="2-4-精度丢失"><a href="#2-4-精度丢失" class="headerlink" title="2.4 精度丢失"></a>2.4 精度丢失</h3><p>计算机中的数字都是以二进制存储的，如果要计算 0.1 + 0.2 的结果，计算机会先把 0.1 和 0.2 分别转化成二进制，然后相加，最后再把相加得到的结果转为十进制 。<br>但有一些浮点数在转化为二进制时，会出现无限循环 。比如， 十进制的 0.1 转化为二进制，会得到如下结果：</p>
<blockquote>
<p>0.0001 1001 1001 1001 1001 1001 1001 1001 …（1001无限循环）</p>
</blockquote>
<p>而存储结构中的尾数部分最多只能表示 53 位。为了能表示 0.1，只能模仿十进制进行四舍五入了，但二进制只有 0 和 1 ， 于是变为 0 舍 1 入 。 因此，0.1 在计算机里的二进制表示形式如下：</p>
<blockquote>
<p>0.0001100110011001100110011001100110011001100110011001101</p>
</blockquote>
<p>用标准计数法表示如下：</p>
<blockquote>
<p>(−1)0 × 2−4 × (1.1001100110011001100110011001100110011001100110011010)2</p>
</blockquote>
<p>同样，0.2 的二进制也可以表示为：</p>
<blockquote>
<p>(−1)0 × 2−3 × (1.1001100110011001100110011001100110011001100110011010)2 </p>
</blockquote>
<p>在计算浮点数相加时，需要先进行 “对位”，将较小的指数化为较大的指数，并将小数部分相应右移：</p>
<blockquote>
<p>0.1→ (−1)0 × 2−3 × (0.11001100110011001100110011001100110011001100110011010)2<br>0.2→ (−1)0 × 2−3 × (1.1001100110011001100110011001100110011001100110011010)2</p>
</blockquote>
<p>最终，“0.1 + 0.2” 在计算机里的计算过程如下：<br><img src="http://image.winrains.cn/2019/10/9bb71-849589-20171013113341277-1573319144.png" alt="img"><br>经过上面的计算过程，0.1 + 0.2 得到的结果也可以表示为：</p>
<blockquote>
<p>(−1)0 × 2−2 × (1.0011001100110011001100110011001100110011001100110100)2</p>
</blockquote>
<p>然后，通过 JS 将这个二进制结果转化为十进制表示：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">(<span class="number">-1</span>)**<span class="number">0</span> * <span class="number">2</span>**<span class="number">-2</span> * (<span class="number">0</span>b10011001100110011001100110011001100110011001100110100 * <span class="number">2</span>**<span class="number">-52</span>); <span class="comment">//0.30000000000000004</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">console.log(<span class="number">0.1</span> + <span class="number">0.2</span>) ; <span class="comment">// 0.30000000000000004</span></span></pre></td></tr></table></figure>



<p>这是一个典型的精度丢失案例，从上面的计算过程可以看出，0.1 和 0.2 在转换为二进制时就发生了一次精度丢失，而对于计算后的二进制又有一次精度丢失 。因此，得到的结果是不准确的。</p>
<h3 id="2-5-特殊数值"><a href="#2-5-特殊数值" class="headerlink" title="2.5 特殊数值"></a>2.5 特殊数值</h3><p>JavaScript 提供了几个特殊数值，用于判断数字的边界和其他特性 。如下所示：</p>
<ul>
<li>Number.MAX_VALUE：JavaScript 中的最大值</li>
<li>Number.MIN_VALUE：JavaScript 中的最小值</li>
<li>Number.MAX_SAFE_INTEGER：最大安全整数，为 253-1</li>
<li>Number.MIN_SAFE_INTEGER：最小安全整数，为 -(253-1)</li>
<li>Number.POSITIVE_INFINITY：对应 Infinity，代表正无穷</li>
<li>Number.NEGATIVE_INFINITY：对应 -Infinity，代表负无穷</li>
<li>Number.EPSILON：是一个极小的值，用于检测计算结果是否在误差范围内</li>
<li>Number.NaN：表示非数字，NaN与任何值都不相等，包括NaN本身</li>
<li>Infinity：表示无穷大，分 正无穷 Infinity 和 负无穷 -Infinity</li>
</ul>
<h3 id="2-6-数值转换"><a href="#2-6-数值转换" class="headerlink" title="2.6 数值转换"></a>2.6 数值转换</h3><p>有 3 个函数可以把非数值转换为数值，分别如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Number</span><span class="params">(value)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">parseInt</span><span class="params">(string [, radix])</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">parseFloat</span><span class="params">(string)</span></span></span></pre></td></tr></table></figure>



<p>Number() 可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。<br>对于字符串而言，Number() 只能对字符串进行整体转换，而 parseInt() 和 parseFloat() 可以对字符串进行部分转换，即只转换第一个无效字符之前的字符。<br>对于不同数据类型的转换，Number() 的处理也不尽相同，其转换规则如下:<br>【1】如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。<br>【2】如果是数字值，只是简单的传入和返回。<br>【3】如果是 null 值，返回 0。<br>【4】如果是 undefined，返回 NaN。<br>【5】如果是字符串，遵循下列规则：</p>
<ul>
<li>如果字符串中只包含数字(包括前面带正号或负号的情况)，则将其转换为十进制数值;</li>
<li>如果字符串中包含有效的浮点格式，则将其转换为对应的浮点数值;</li>
<li>如果字符串中包含有效的十六进制格式，则将其转换为相同大小的十进制整数值;</li>
<li>如果字符串是空的(不包含任何字符)，则将其转换为 0;</li>
<li>如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。</li>
</ul>
<p>【6】如果是对象，则调用对象的 valueOf() 方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的 toString() 方法，然后再次依照前面的规则转换返回的字符串值。<br>需要注意的是：</p>
<blockquote>
<p>一元加操作符加号 “+” 和 Number() 具有同样的作用。</p>
</blockquote>
<p>在 ECMAScript 2015 规范中，为了实现全局模块化，Number 对象重写了 parseInt 和 parseFloat 方法，但和对应的全局方法并无区别。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Number.<span class="built_in">parseInt</span> === <span class="built_in">parseInt</span>; <span class="comment">// true</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Number.<span class="built_in">parseFloat</span> === <span class="built_in">parseFloat</span>; <span class="comment">// true</span></span></pre></td></tr></table></figure>



<h3 id="2-7-位运算"><a href="#2-7-位运算" class="headerlink" title="2.7 位运算"></a>2.7 位运算</h3><p>位运算作用于最基本的层次上，即按内存中表示数值的位来操作数值。ECMAScript 中的数值以64位双精度浮点数存储，但位运算只能作用于整数，因此要先将 64 位的浮点数转换成 32 位的整数，然后再进行位运算，最后再将计算结果转换成64位浮点数存储。常见的位运算有以下几种：</p>
<ul>
<li>按位非（NOT）：~</li>
<li>按位与（AND）：&amp;</li>
<li>按位或（OR）： |</li>
<li>按位异或（XOR）：^</li>
<li>左移：&lt;&lt;</li>
<li>有符号右移：&gt;&gt;</li>
<li>无符号右移：&gt;&gt;&gt;</li>
</ul>
<p>需要注意的是：</p>
<blockquote>
<p>“有符号右移” 和 “无符号右移” 只在计算负数的情况下存在差异，&gt;&gt; 在符号位的右侧补0，不移动符号位；而 &gt;&gt;&gt; 是在符号位的左侧补0，符号位发生移动和改变。</p>
</blockquote>
<h3 id="2-8-四舍五入"><a href="#2-8-四舍五入" class="headerlink" title="2.8 四舍五入"></a>2.8 四舍五入</h3><p>JavaScript 对数字进行四舍五入操作的 API 有 ceil，floor，round，toFixed，toPrecision 等，详细介绍请参考：<a href="http://www.cnblogs.com/onepixel/p/5141566.html" target="_blank" rel="noopener">JavaScript 中的四舍五入</a></p>
<h2 id="3、Boolean-类型"><a href="#3、Boolean-类型" class="headerlink" title="3、Boolean 类型"></a><strong>3、Boolean 类型</strong></h2><p>Boolean 类型只有两个字面值：true 和 false 。 在 JavaScript 中，所有类型的值都可以转化为与 Boolean 等价的值 。转化规则如下：</p>
<ul>
<li>所有对象都被当作 true</li>
<li>空字符串被当作 false</li>
<li>null 和 undefined 被当作 false</li>
<li>数字 0 和 NaN 被当作 false</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>([]); <span class="comment">//true</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(&#123;&#125;); <span class="comment">//true</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>); <span class="comment">//false</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>); <span class="comment">//false</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="string">''</span>);  <span class="comment">//false</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>);   <span class="comment">//false</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>); <span class="comment">//false</span></span></pre></td></tr></table></figure>

<p>除 Boolean() 方法可以返回布尔值外，以下 4 种类型的操作，也会返回布尔值。</p>
<h3 id="【1】关系操作符：-gt-，-gt-，-lt-，-lt"><a href="#【1】关系操作符：-gt-，-gt-，-lt-，-lt" class="headerlink" title="【1】关系操作符：&gt;，&gt;=，&lt;，&lt;="></a>【1】关系操作符：&gt;，&gt;=，&lt;，&lt;=</h3><p>当关系操作符的操作数使用了非数值时，要进行数据转换或完成某些奇怪的操作。</p>
<ul>
<li>如果两个操作数都是数值，则执行数值比较。</li>
<li>如果两个操作数都是字符串，则逐个比较两者对应的字符编码(charCode)，直到分出大小为止 。</li>
<li>如果操作数是其他基本类型，则调用Number() 将其转化为数值，然后进行比较。</li>
<li>NaN 与任何值比较，均返回 false 。</li>
<li>如果操作数是对象，则调用对象的 valueOf 方法（如果没有 valueOf ，就调用 toString 方法），最后用得到的结果，根据前面的规则执行比较。</li>
</ul>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="string">'a'</span> &gt; <span class="string">'b'</span>; // <span class="literal">false</span>, 即 <span class="string">'a'</span>.charCodeAt(<span class="number">0</span>) &gt; <span class="string">'b'</span>.charCodeAt(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> &gt; <span class="string">'1'</span>;  // <span class="literal">true</span>, 即 <span class="built_in">Number</span>(<span class="string">'1'</span>) = <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> &gt; <span class="number">0</span>; //<span class="literal">true</span>, 即 <span class="built_in">Number</span>(<span class="literal">true</span>) = <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">undefined &gt; <span class="number">0</span>; //<span class="literal">false</span>, <span class="built_in">Number</span>(undefined) = <span class="literal">NaN</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">null &lt; <span class="number">0</span>; //<span class="literal">false</span>, <span class="built_in">Number</span>(null) = <span class="literal">NaN</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">new <span class="built_in">Date</span> &gt; <span class="number">100</span>; //<span class="literal">true</span> , 即 new <span class="built_in">Date</span>().valueOf()</span></pre></td></tr></table></figure>

<h3 id="【2】相等操作符：-，-，-，"><a href="#【2】相等操作符：-，-，-，" class="headerlink" title="【2】相等操作符： ==，!=，===，!=="></a><strong>【2】相等操作符：</strong> ==，!=，===，!==</h3><p>== 和 != 操作符都会先转换操作数，然后再比较它们的相等性。在转换不同的数据类型时，需要遵循下列基本规则：</p>
<ul>
<li>如果有一个操作数是布尔值，则在比较相等性之前，先调用 Number() 将其转换为数值；</li>
<li>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前，先调用 Number() 将字符串转换为数值；</li>
<li>如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法，用得到的基本类型值按照前面的规则进行比较；</li>
<li>null 和 undefined 是相等的。在比较相等性之前，不能将 null 和 undefined 转换成其他任何值。</li>
<li>如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true；</li>
<li>如果两个操作数都是对象，则比较它们的指针地址。如果都指向同一个对象，则相等操作符返回 true；否则，返回 false。</li>
</ul>
<p>=== 和 !== 操作符最大的特点是，在比较之前不转换操作数 。它们的操作规则如下：</p>
<ul>
<li>===： 类型相同，并且值相等，才返回 true ，否则返回 false 。</li>
<li>!== ： 类型不同，或者值不相等，就返回 true，否则返回 false 。</li>
</ul>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span>; <span class="regexp">//</span><span class="literal">false</span>, 类型不同，直接返回 <span class="literal">false</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">[] === []; <span class="regexp">//</span><span class="literal">false</span> ,类型相同，值不相同，指针地址不同</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">a=[],b=a,a===b; <span class="regexp">//</span><span class="literal">true</span>, 类型相同，值也相等</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> !== <span class="string">'1'</span> ; <span class="regexp">//</span> <span class="literal">true</span> , 值相等，但类型不同</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">[] !== [] ;  <span class="regexp">//</span> <span class="literal">true</span>, 类型相同，但值不相等</span></pre></td></tr></table></figure>

<h3 id="【3】布尔操作符："><a href="#【3】布尔操作符：" class="headerlink" title="【3】布尔操作符：!"></a>【3】布尔操作符：!</h3><p>布尔操作符属于一元操作符，即只有一个分项。其求值过程如下：</p>
<ul>
<li>对分项求值，得到一个任意类型值；</li>
<li>使用 Boolean() 把该值转换为布尔值 true 或 false；</li>
<li>对布尔值取反，即 true 变 false，false 变 true</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">!(<span class="number">2</span>+<span class="number">3</span>) ; <span class="comment">// false</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">!(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;&#125;); <span class="comment">//false</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">!([] &amp;&amp; <span class="literal">null</span> &amp;&amp; <span class="string">''</span>); <span class="comment">//true</span></span></pre></td></tr></table></figure>

<p>利用 ! 的取反的特点，使用 !! 可以很方便的将一个任意类型值转换为布尔值：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(!!<span class="number">0</span>); <span class="regexp">//</span><span class="literal">false</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(!!<span class="string">''</span>); <span class="regexp">//</span><span class="literal">false</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(!!(<span class="number">2</span>+<span class="number">3</span>)); <span class="regexp">//</span><span class="literal">true</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(!!([] &amp;&amp; <span class="literal">null</span> &amp;&amp; <span class="string">''</span>)); <span class="regexp">//</span><span class="literal">false</span></span></pre></td></tr></table></figure>

<p>需要注意的是：</p>
<blockquote>
<p>逻辑与 “&amp;&amp;” 和 逻辑或 “||” 返回的不一定是布尔值，而是包含布尔值在内的任意类型值。</p>
</blockquote>
<p>如下所示：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">[] &amp;&amp; <span class="number">1</span>; <span class="comment">//1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> &amp;&amp; undefined; <span class="comment">//null</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">[] || <span class="number">1</span>; <span class="comment">//[]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> || <span class="number">1</span>; <span class="comment">//1</span></span></pre></td></tr></table></figure>



<p>逻辑操作符属于短路操作符 。在进行计算之前，会先通过 Boolean() 方法将两边的分项转换为布尔值，然后分别遵循下列规则进行计算：</p>
<ul>
<li>逻辑与：从左到右检测每一个分项，返回第一个布尔值为 false 的分项，并停止检测 。如果没有检测到 false 项，则返回最后一个分项 。</li>
<li>逻辑或：从左到右检测每一个分项，返回第一个布尔值为 true 的分项，并停止检测 。如果没有检测到 true 项，则返回最后一个分项 。</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">[] &amp;&amp; &#123;&#125; &amp;&amp;  <span class="literal">null</span> &amp;&amp; <span class="number">1</span>; <span class="comment">//null</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">[] &amp;&amp; &#123;&#125; &amp;&amp;  !<span class="literal">null</span>  &amp;&amp;  <span class="number">1</span> ; <span class="comment">//1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> || <span class="literal">undefined</span> || <span class="number">1</span> || <span class="number">0</span>; <span class="comment">//1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> || <span class="number">0</span> || <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;&#125;; <span class="comment">//function()&#123;&#125;</span></span></pre></td></tr></table></figure>

<h3 id="【4】条件语句：if，while，"><a href="#【4】条件语句：if，while，" class="headerlink" title="【4】条件语句：if，while，?"></a>【4】条件语句：if，while，?</h3><p>条件语句通过计算表达式返回一个布尔值，然后再根据布尔值的真假，来执行对应的代码。其计算过程如下：</p>
<ul>
<li>对表达式求值，得到一个任意类型值</li>
<li>使用 Boolean() 将得到的值转换为布尔值 true 或 false</li>
</ul>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">if</span>(arr.<span class="meta">length</span>) &#123; &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">obj <span class="variable">&amp;&amp;</span> obj.name ? <span class="string">'obj.name'</span> : <span class="string">''</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">while</span>(arr.<span class="meta">length</span>)&#123; &#125;</span></pre></td></tr></table></figure>

<h2 id="4、Symbol-类型"><a href="#4、Symbol-类型" class="headerlink" title="4、Symbol 类型"></a>4、Symbol 类型</h2><p>Symbol 是 ES6 新增的一种原始数据类型，它的字面意思是：符号、标记。代表独一无二的值 。<br>在 ES6 之前，对象的属性名只能是字符串，这样会导致一个问题，当通过 mixin 模式为对象注入新属性的时候，就可能会和原来的属性名产生冲突 。而在 ES6 中，Symbol 类型也可以作为对象属性名，凡是属性名是 Symbol 类型的，就都是独一无二的，可以保证不会与其他属性名产生冲突。<br>Symbol 值通过函数生成，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>(); <span class="comment">//s是独一无二的值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> s ; <span class="comment">// symbol</span></span></pre></td></tr></table></figure>



<p>和其他基本类型不同的是，Symbol 作为基本类型，没有对应的包装类型，也就是说 Symbol 本身不是对象，而是一个函数。因此，在生成 Symbol 类型值的时候，不能使用 new 操作符 。<br>Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 值的描述，当有多个 Symbol 值时，比较容易区分。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'s1'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'s2'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(s1,s2); <span class="comment">// Symbol(s1) Symbol(s2)</span></span></pre></td></tr></table></figure>



<p>注意，Symbol 函数的参数只是表示对当前 Symbol 值的描述，因此，相同参数的 Symbol 函数的返回值也是不相等的。<br>用 Symbol 作为对象的属性名时，不能直接通过<strong>点</strong>的方式访问属性和设置属性值。因为正常情况下，引擎会把点后面的属性名解析成字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">Symbol</span>();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">obj.s = <span class="string">'Jack'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;s: "Jack"&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">obj[s] = <span class="string">'Jack'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj) ; <span class="comment">//&#123;Symbol(): "Jack"&#125;</span></span></pre></td></tr></table></figure>



<p>Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 <code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code> 返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols()</code> 方法，专门获取指定对象的所有 Symbol 属性名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'s1'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'s2'</span>)；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">obj[s1] = <span class="string">'Jack'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">obj[s2] = <span class="string">'Tom'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(obj); <span class="comment">//[]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">//无输出</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj); <span class="comment">//[Symbol(s1), Symbol(s2)]</span></span></pre></td></tr></table></figure>



<p>另一个新的API，<code>Reflect.ownKeys</code> 方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'s1'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'s2'</span>)；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">obj[s1] = <span class="string">'Jack'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">obj[s2] = <span class="string">'Tom'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">obj.name = <span class="string">'Nick'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj); <span class="comment">//[Symbol(s1), Symbol(s2),"name"]</span></span></pre></td></tr></table></figure>



<p>有时，我们希望重新使用同一个 Symbol 值，Symbol.for 方法可以做到这一点。它接受一个字符串作为参数，然后全局搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">s1 === s2 <span class="comment">//true</span></span></pre></td></tr></table></figure>



<p><code>Symbol.for()</code> 也可以生成 Symbol 值，它 和 Symbol() 的区别是：</p>
<ul>
<li><code>Symbol.for()</code> 首先会在全局环境中查找给定的 key 是否存在，如果存在就返回，否则就创建一个以 key 为标识的 Symbol 值</li>
<li><code>Symbol.for()</code> 生成的 Symbol 会登记在全局环境中供搜索，而 <code>Symbol()</code> 不会。</li>
</ul>
<p>因此，<code>Symbol.for()</code>  永远搜索不到 用 <code>Symbol()</code> 产生的值。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">s === s1; <span class="comment">// false</span></span></pre></td></tr></table></figure>



<p><code>Symbol.keyFor()</code> 方法返回一个已在全局环境中登记的 Symbol 类型值的 key 。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var s1 = <span class="module-access"><span class="module"><span class="identifier">Symbol</span>.</span></span>for('s1');</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Symbol</span>.</span></span>key<span class="constructor">For(<span class="params">s1</span>)</span>; <span class="comment">//foo</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">var s2 = <span class="constructor">Symbol('<span class="params">s2</span>')</span>; <span class="comment">//未登记的 Symbol 值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Symbol</span>.</span></span>key<span class="constructor">For(<span class="params">s2</span>)</span>; <span class="comment">//undefined</span></span></pre></td></tr></table></figure>



<h2 id="5、Undefined-类型"><a href="#5、Undefined-类型" class="headerlink" title="5、Undefined 类型"></a><strong>5、Undefined 类型</strong></h2><p>Undefined 是 Javascript 中特殊的原始数据类型，它只有一个值，即 undefined，字面意思是：未定义的值 。它的语义是，希望<strong>表示一个变量最原始的状态，而非人为操作的结果 。</strong> 这种原始状态会在以下 4 种场景中出现：</p>
<h3 id="【1】声明了一个变量，但没有赋值"><a href="#【1】声明了一个变量，但没有赋值" class="headerlink" title="【1】声明了一个变量，但没有赋值"></a>【1】<strong>声明了一个变量，但没有赋值</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">//undefined</span></span></pre></td></tr></table></figure>

<p>访问 foo，返回了 undefined，表示这个变量自从声明了以后，就从来没有使用过，也没有定义过任何有效的值，即处于一种原始而不可用的状态。</p>
<h3 id="【2】访问对象上不存在的属性"><a href="#【2】访问对象上不存在的属性" class="headerlink" title="【2】访问对象上不存在的属性"></a>【2】<strong>访问对象上不存在的属性</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.foo); <span class="comment">// undefined</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>]); <span class="comment">// undefined</span></span></pre></td></tr></table></figure>

<p>访问 Object 对象上的 foo 属性，返回 undefined ， 表示Object 上不存在或者没有定义名为 foo 的属性。数组中的元素在内部也属于对象属性，访问下标就等于访问这个属性，返回 undefined ，就表示数组中不存在这个元素。</p>
<h3 id="【3】函数定义了形参，但没有传递实参"><a href="#【3】函数定义了形参，但没有传递实参" class="headerlink" title="【3】函数定义了形参，但没有传递实参"></a>【3】函数定义了形参，但没有传递实参</h3><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义了形参 a</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span><span class="params">(a)</span> <span class="comment">&#123;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="comment">    console.log(a); //undefined</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="comment">&#125;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fn</span><span class="params">()</span>;</span> <span class="comment">// 未传递实参</span></span></pre></td></tr></table></figure>

<p>函数 fn 定义了形参 a， 但 fn 被调用时没有传递参数，因此，fn 运行时的参数 a 就是一个原始的、未被赋值的变量。</p>
<h3 id="【4】使用-void-对表达式求值"><a href="#【4】使用-void-对表达式求值" class="headerlink" title="【4】使用 void 对表达式求值"></a>【4】使用 void 对表达式求值</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="number">0</span> ; <span class="comment">// undefined</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="literal">false</span>; <span class="comment">// undefined</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> []; <span class="comment">// undefined</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="literal">null</span>; <span class="comment">// undefined</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span><span class="params">()</span></span>&#123;&#125; ; <span class="comment">// undefined</span></span></pre></td></tr></table></figure>

<p>ECMAScript 明确规定 void 操作符 对任何表达式求值都返回 undefined ，这和函数执行操作后没有返回值的作用是一样的，JavaScript 中的函数都有返回值，当没有 return 操作时，就默认返回一个原始的状态值，这个值就是 undefined，表明函数的返回值未被定义。<br>因此，undefined 一般都来自于某个表达式最原始的状态值，不是人为操作的结果。当然，你也可以手动给一个变量赋值 undefined，但这样做没有意义，因为一个变量不赋值就是 undefined 。</p>
<h2 id="6、Null-类型"><a href="#6、Null-类型" class="headerlink" title="6、Null 类型"></a><strong>6、Null 类型</strong></h2><p>Null 是 Javascript 中特殊的原始数据类型，它只有一个值，即 null，字面意思是：“空值” 。它的语义是，希望<strong>表示一个对象被人为的重置为空对象，而非一个变量最原始的状态 。</strong> 在内存里的表示就是，栈中的变量没有指向堆中的内存对象。当一个对象被赋值了 null 以后，原来的对象在内存中就处于游离状态，GC 会择机回收该对象并释放内存。因此，如果需要释放某个对象，就将变量设置为 null，即表示该对象已经被清空，目前无效状态。<br>null 是原始数据类型 Null 中的唯一一个值，但 typeof 会将 null 误判为 Object 类型 。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> == <span class="string">'object'</span></span></pre></td></tr></table></figure>



<p>在 JavaScript 中，数据类型在底层都是以二进制形式表示的，<strong>二进制的前三位为 0 会被 typeof 判定为对象类型</strong>，如下所示：</p>
<ul>
<li>000 - 对象，数据是对象的应用</li>
<li>1 - 整型，数据是31位带符号整数</li>
<li>010 - 双精度类型，数据是双精度数字</li>
<li>100 - 字符串，数据是字符串</li>
<li>110 - 布尔类型，数据是布尔值</li>
</ul>
<p>而 null 值的二进制表示全是 0 ，自然前三位当然也是 000，因此，typeof 会误以为是对象类型。如果想要知道 null 的真实数据类型，可以通过下面的方式来获取。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">Object</span>.prototype.toString.<span class="keyword">call</span>(<span class="keyword">null</span>) ; // [<span class="keyword">object</span> <span class="keyword">Null</span>]</span></pre></td></tr></table></figure>



<h2 id="7、Object-类型"><a href="#7、Object-类型" class="headerlink" title="7、Object 类型"></a><strong>7、Object 类型</strong></h2><p>在 ECMAScript 规范中，引用类型除 Object 本身外，Date、Array、RegExp 也属于引用类型 。<br>引用类型也即对象类型，ECMA262 把对象定义为：<strong>无序属性的集合，其属性可以包含基本值、对象或者函数</strong>。 也就是说，对象是一组没有特定顺序的值 。由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度。因此，对象的值存储在堆(heap)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。具备这种存储结构的，都可以称之为引用类型 。</p>
<h3 id="7-1-对象拷贝"><a href="#7-1-对象拷贝" class="headerlink" title="7.1 对象拷贝"></a>7.1 对象拷贝</h3><p>由于引用类型的变量只存指针，而对象本身存储在堆中 。因此，当把一个对象赋值给多个变量时，就相当于把同一个对象地址赋值给了每个变量指针 。这样，每个变量都指向了同一个对象，当通过一个变量修改对象，其他变量也会同步更新。</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var obj = &#123;<span class="built_in">name</span>:<span class="string">'Jack'</span>&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">var obj2 = obj;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">obj2.<span class="built_in">name</span> = <span class="string">'Tom'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(obj.<span class="built_in">name</span>,obj2.<span class="built_in">name</span>); <span class="comment">//Tom,Tom</span></span></pre></td></tr></table></figure>



<p>ES6 提供了一个原生方法用于对象的拷贝，即 <code>Object.assign()</code> 。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="comment">&#123;name:'Jack'&#125;</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">Object</span>.assign(<span class="comment">&#123;&#125;</span>,obj);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">obj2.<span class="keyword">name</span> = <span class="string">'Tom'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">console.log(obj.<span class="keyword">name</span>,obj2.<span class="keyword">name</span>); <span class="comment">//Jack Tom</span></span></pre></td></tr></table></figure>



<p>需要注意的是，<code>Object.assign()</code> 拷贝的是属性值。当属性值是基本类型时，没有什么问题 ，但如果该属性值是一个指向对象的引用，它也只能拷贝那个引用值，而不会拷贝被引用的那个对象。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="keyword">base</span>:&#123;name:<span class="string">'Jack'</span>&#125;&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2 = Object.assign(&#123;&#125;,obj);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">obj2.<span class="keyword">base</span>.name = <span class="string">'Tom'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">console.log(obj.<span class="keyword">base</span>.name,obj2.<span class="keyword">base</span>.name); <span class="comment">//Tom Tom</span></span></pre></td></tr></table></figure>



<p>从结果可以看出，obj 和 obj2 的属性 base 指向了同一个对象的引用。因此，<code>Object.assign</code> 仅仅是拷贝了一份对象指针作为副本 。这种拷贝被称为 “一级拷贝” 或 “浅拷贝” <strong>。</strong><br>如果要彻底的拷贝一个对象作为副本，两者之间的操作相互不受影响，则可以通过 JSON 的序列化和反序列化方法来实现 。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="keyword">base</span>:&#123;name:<span class="string">'Jack'</span>&#125;&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2 = JSON.parse(JSON.stringify(obj))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">obj2.<span class="keyword">base</span>.name = <span class="string">'Tom'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">console.log(obj.<span class="keyword">base</span>.name,obj2.<span class="keyword">base</span>.name); <span class="comment">//Jack Tom</span></span></pre></td></tr></table></figure>



<p>这种拷贝被称为 “多级拷贝” 或 “深拷贝” 。</p>
<h3 id="7-2-属性类型"><a href="#7-2-属性类型" class="headerlink" title="7.2 属性类型"></a>7.2 属性类型</h3><p>ECMA-262 第 5 版定义了一些内部特性（attribute），用以描述对象属性（property）的各种特征。ECMA-262 定义这些特性是为了实现 JavaScript 引擎用的，因此在 JavaScript 中不能直接访问它们。为了表示特性是内部值，该规范把它们放在了两对儿方括号中，例如[[Enumerable]]。 这些内部特性可以分为两种：数据属性 和 访问器属性 。</p>
<h4 id="【1】数据属性"><a href="#【1】数据属性" class="headerlink" title="【1】数据属性"></a><strong>【1】数据属性</strong></h4><p>数据属性包含一个数据值的位置，在这个位置可以读取和写入值 。数据属性有4个描述其行为的内部特性：</p>
<ul>
<li>[[Configurable]]：能否通过 delete 删除属性从而重新定义属性，或者能否把属性修改为访问器属性。该默认值为 true。</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。默认值为 true。</li>
<li>[[Writable]]：能否修改属性的值。默认值为 true。</li>
<li>[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。默认值为 undefined 。</li>
</ul>
<p>要修改属性默认的特性，必须使用 ECMAScript 5 的 <code>Object.defineProperty()</code> 方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable、enumerable、writable 和 value。设置其中的一或多个值，可以修改对应的特性值。例如：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">Object</span>.defineProperty(person, "name", &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    writable: <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">value</span>: "Nicholas"</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">console.log(person.name); //"Nicholas"</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">person.name = "Greg";</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">console.log(person.name); //"Nicholas"</span></pre></td></tr></table></figure>



<p>在调用 <code>Object.defineProperty()</code> 方法时，如果不指定 configurable、enumerable 和 writable 特性，其默认值都是 false 。</p>
<h4 id="【2】访问器属性"><a href="#【2】访问器属性" class="headerlink" title="【2】访问器属性"></a><strong>【2】访问器属性</strong></h4><p>访问器属性不包含数据值，它们包含一对 getter 和 setter 函数（不过，这两个函数都不是必需的）。在读取访问器属性时，会调用getter 函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter 函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4 个特性。</p>
<ul>
<li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，或者能否把属性修改为数据属性。默认值为true 。</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。默认值为 true。</li>
<li>[[Get]]：在读取属性时调用的函数。默认值为 undefined 。</li>
<li>[[Set]]：在写入属性时调用的函数。默认值为 undefined 。</li>
</ul>
<p>访问器属性不能直接定义，也必须使用 <code>Object.defineProperty()</code> 来定义。请看下面的例子：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    _year: <span class="type">2004</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="type"></span>&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Object.defineProperty(book, <span class="string">"year"</span>, &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">get</span>: <span class="type">function </span>() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._year;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">set</span>: <span class="type">function </span>(<span class="keyword">new</span><span class="type">Value</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Value</span> &gt; <span class="number">2004</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">this</span>._year = <span class="keyword">new</span><span class="type">Value</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            console.log(<span class="string">'set new value:'</span>+ <span class="keyword">new</span><span class="type">Value</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">book.year = <span class="number">2005</span>; <span class="comment">//set new value:2005</span></span></pre></td></tr></table></figure>



<h3 id="7-3-Object-新增-API"><a href="#7-3-Object-新增-API" class="headerlink" title="7.3  Object 新增 API"></a>7.3  Object 新增 API</h3><p>ECMA-262 第 5 版对 Object 对象进行了增强，包括 defineProperty 在内，共定义了 9 个新的 API：</p>
<ul>
<li>create(prototype[,descriptors])：用于原型链继承。创建一个对象，并把其 prototype 属性赋值为第一个参数，同时可以设置多个 descriptors 。</li>
<li>defineProperty(O,Prop,descriptor) ：用于定义对象属性的特性。</li>
<li>defineProperties(O,descriptors) ：用于同时定义多个属性的特性。</li>
<li>getOwnPropertyDescriptor(O,property)：获取 defineProperty 方法设置的 property 特性。</li>
<li>getOwnPropertyNames：获取所有的属性名，不包括 prototy 中的属性，返回一个数组。</li>
<li>keys()：和 getOwnPropertyNames 方法类似，但是获取所有的可枚举的属性，返回一个数组。</li>
<li>preventExtensions(O) ：用于锁住对象属性，使其不能够拓展，也就是不能增加新的属性，但是属性的值仍然可以更改，也可以把属性删除。</li>
<li>Object.seal(O) ：把对象密封，也就是让对象既不可以拓展也不可以删除属性（把每个属性的 configurable 设为 false），单数属性值仍然可以修改。</li>
<li>Object.freeze(O) ：完全冻结对象，在 seal 的基础上，属性值也不可以修改（每个属性的 wirtable 也被设为 false）。</li>
</ul>
<blockquote>
<p>作者：一像素</p>
<p>来源：<a href="https://www.cnblogs.com/onepixel/p/5140944.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/p/5140944.html</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/08/JavaScript-%E4%B8%AD%E7%9A%84%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5/" rel="prev" title="JavaScript 中的四舍五入">
      <i class="fa fa-chevron-left"></i> JavaScript 中的四舍五入
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/08/%E6%8E%A2%E7%B4%A2-JavaScript-%E5%BC%95%E6%93%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" rel="next" title="探索 JavaScript 引擎工作原理">
      探索 JavaScript 引擎工作原理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、String-类型"><span class="nav-number">1.</span> <span class="nav-text">1、String 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-存储结构"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-基本包装类型"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 基本包装类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-常用操作方法"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 常用操作方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、Number-类型"><span class="nav-number">2.</span> <span class="nav-text">2、Number 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-存储结构"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-数值范围"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 数值范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-数值精度"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 数值精度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-精度丢失"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 精度丢失</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-特殊数值"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 特殊数值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-数值转换"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 数值转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-位运算"><span class="nav-number">2.7.</span> <span class="nav-text">2.7 位运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-四舍五入"><span class="nav-number">2.8.</span> <span class="nav-text">2.8 四舍五入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、Boolean-类型"><span class="nav-number">3.</span> <span class="nav-text">3、Boolean 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#【1】关系操作符：-gt-，-gt-，-lt-，-lt"><span class="nav-number">3.1.</span> <span class="nav-text">【1】关系操作符：&gt;，&gt;=，&lt;，&lt;=</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【2】相等操作符：-，-，-，"><span class="nav-number">3.2.</span> <span class="nav-text">【2】相等操作符： ==，!=，===，!==</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【3】布尔操作符："><span class="nav-number">3.3.</span> <span class="nav-text">【3】布尔操作符：!</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【4】条件语句：if，while，"><span class="nav-number">3.4.</span> <span class="nav-text">【4】条件语句：if，while，?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、Symbol-类型"><span class="nav-number">4.</span> <span class="nav-text">4、Symbol 类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、Undefined-类型"><span class="nav-number">5.</span> <span class="nav-text">5、Undefined 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#【1】声明了一个变量，但没有赋值"><span class="nav-number">5.1.</span> <span class="nav-text">【1】声明了一个变量，但没有赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【2】访问对象上不存在的属性"><span class="nav-number">5.2.</span> <span class="nav-text">【2】访问对象上不存在的属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【3】函数定义了形参，但没有传递实参"><span class="nav-number">5.3.</span> <span class="nav-text">【3】函数定义了形参，但没有传递实参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【4】使用-void-对表达式求值"><span class="nav-number">5.4.</span> <span class="nav-text">【4】使用 void 对表达式求值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、Null-类型"><span class="nav-number">6.</span> <span class="nav-text">6、Null 类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、Object-类型"><span class="nav-number">7.</span> <span class="nav-text">7、Object 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-对象拷贝"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 对象拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-属性类型"><span class="nav-number">7.2.</span> <span class="nav-text">7.2 属性类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#【1】数据属性"><span class="nav-number">7.2.1.</span> <span class="nav-text">【1】数据属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#【2】访问器属性"><span class="nav-number">7.2.2.</span> <span class="nav-text">【2】访问器属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-Object-新增-API"><span class="nav-number">7.3.</span> <span class="nav-text">7.3  Object 新增 API</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">congsheng.wang</p>
  <div class="site-description" itemprop="description">trouble is a friend</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">807</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">91</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">141</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">congsheng.wang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
