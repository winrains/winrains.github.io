<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://congsheng.wang').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="1. 背景本文承接上文，来继续说说 IOC 和 AOP 的仿写。在上文中，我实现了一个很简单的 IOC 和 AOP 容器。上文实现的 IOC 和 AOP 功能很单一，且 IOC 和 AOP 两个模块没有整合到一起。IOC 在加载 bean 过程中，AOP 不能对 bean 织入通知。在本文中，我们详细说一下升级版 IOC 和 AOP。这个版本的实现包含了在上篇中所说的功能，这里再重述一下，如下：">
<meta name="keywords" content="AOP,IoC">
<meta property="og:type" content="article">
<meta property="og:title" content="自己动手实现的 Spring IOC 和 AOP（下）">
<meta property="og:url" content="http:&#x2F;&#x2F;congsheng.wang&#x2F;2020&#x2F;01&#x2F;08&#x2F;%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%9A%84-Spring-IOC-%E5%92%8C-AOP%EF%BC%88%E4%B8%8B%EF%BC%89&#x2F;index.html">
<meta property="og:site_name" content="congsheng的博客">
<meta property="og:description" content="1. 背景本文承接上文，来继续说说 IOC 和 AOP 的仿写。在上文中，我实现了一个很简单的 IOC 和 AOP 容器。上文实现的 IOC 和 AOP 功能很单一，且 IOC 和 AOP 两个模块没有整合到一起。IOC 在加载 bean 过程中，AOP 不能对 bean 织入通知。在本文中，我们详细说一下升级版 IOC 和 AOP。这个版本的实现包含了在上篇中所说的功能，这里再重述一下，如下：">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;11&#x2F;8ebb5.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;11&#x2F;5ef85.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;11&#x2F;2c018.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;11&#x2F;ed39d.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;11&#x2F;ab082.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;11&#x2F;915b2.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;11&#x2F;e4614.png">
<meta property="og:updated_time" content="2020-01-08T05:40:21.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;11&#x2F;8ebb5.png">

<link rel="canonical" href="http://congsheng.wang/2020/01/08/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%9A%84-Spring-IOC-%E5%92%8C-AOP%EF%BC%88%E4%B8%8B%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>自己动手实现的 Spring IOC 和 AOP（下） | congsheng的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">congsheng的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">欢迎访问：winrains.cn</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">156</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">94</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">984</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://congsheng.wang/2020/01/08/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%9A%84-Spring-IOC-%E5%92%8C-AOP%EF%BC%88%E4%B8%8B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="congsheng.wang">
      <meta itemprop="description" content="trouble is a friend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="congsheng的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          自己动手实现的 Spring IOC 和 AOP（下）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-08 13:40:21" itemprop="dateCreated datePublished" datetime="2020-01-08T13:40:21+08:00">2020-01-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">Spring技术</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring%E6%8A%80%E6%9C%AF/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>本文承接<a href="http://www.coolblog.xyz/2018/01/18/自己动手实现的-Spring-IOC-和-AOP-上篇/" target="_blank" rel="noopener">上文</a>，来继续说说 IOC 和 AOP 的仿写。在上文中，我实现了一个很简单的 IOC 和 AOP 容器。上文实现的 IOC 和 AOP 功能很单一，且 IOC 和 AOP 两个模块没有整合到一起。IOC 在加载 bean 过程中，AOP 不能对 bean 织入通知。在本文中，我们详细说一下升级版 IOC 和 AOP。这个版本的实现包含了在上篇中所说的功能，这里再重述一下，如下：</p>
<ol>
<li>根据 xml 配置文件加载相关 bean</li>
<li>对 BeanPostProcessor 类型的 bean 提供支持</li>
<li>对 BeanFactoryAware 类型的 bean 提供支持</li>
<li>实现了基于 JDK 动态代理的 AOP</li>
<li>整合了 IOC 和 AOP，使得二者可很好的协同工作</li>
</ol>
<p>上面罗列了5个功能点，虽然看起来不多，但是对于新手来说，实现起来还是不很容易的。所以接下来，我将围绕上面的功能点展开详细的描述。如果大家有兴趣，我还是很建议大家跟着写一遍，因为很多时候能看懂，但是写的却不一定能写出来。仿写一遍能够加深对 Spring IOC 和 AOP 原理的理解，多动手是有好处的。<br>另外需要说明的是，黄亿华前辈实现的 <a href="https://github.com/code4craft/tiny-spring" target="_blank" rel="noopener">tiny-spring</a> 项目时间节点是 2014.1，当时应该是参照 Spring 3.x 版本编写的。部分类的设计思想可能会与现在最新稳定版 4.3.10 有一定的出入，由于我暂时没有阅读 Spring 源码的计划，所以这里不能告知大家 <a href="https://github.com/code4craft/tiny-spring" target="_blank" rel="noopener">tiny-spring</a> 哪些类与 Spring 最新的源码有出入，见谅。<br>好了，本章内容先介绍到这，接下来进入正文。</p>
<a id="more"></a>

<h1 id="2-IOC-的实现"><a href="#2-IOC-的实现" class="headerlink" title="2. IOC 的实现"></a>2. IOC 的实现</h1><h2 id="2-1-BeanFactory-的生命流程"><a href="#2-1-BeanFactory-的生命流程" class="headerlink" title="2.1 BeanFactory 的生命流程"></a>2.1 BeanFactory 的生命流程</h2><p>上面简述了 toy-spring 项目的编码背景，接下来，在本节中，我将向大家介绍 toy-spring 项目中 IOC 部分的实现原理。在详细介绍 IOC 的实现原理前，这里先简单说一下 BeanFactory 的生命流程：</p>
<ol>
<li>BeanFactory 加载 Bean 配置文件，将读到的 Bean 配置封装成 BeanDefinition 对象</li>
<li>将封装好的 BeanDefinition 对象注册到 BeanDefinition 容器中</li>
<li>注册 BeanPostProcessor 相关实现类到 BeanPostProcessor 容器中</li>
<li>BeanFactory 进入就绪状态</li>
<li>外部调用 BeanFactory 的 getBean(String name) 方法，BeanFactory 着手实例化相应的 bean</li>
<li>重复步骤 3 和 4，直至程序退出，BeanFactory 被销毁</li>
</ol>
<p>上面简单罗列了 BeanFactory 的生命流程，也就是 IOC 容器的生命流程。接下来就来围绕上面的流程展开讨论。</p>
<h2 id="2-2-BeanDefinition-及其他一些类的介绍"><a href="#2-2-BeanDefinition-及其他一些类的介绍" class="headerlink" title="2.2 BeanDefinition 及其他一些类的介绍"></a>2.2 BeanDefinition 及其他一些类的介绍</h2><p>在详细介绍 IOC 容器的工作原理前，这里先介绍一下实现 IOC 所用到的一些辅助类，包括BeanDefinition、BeanReference、PropertyValues、PropertyValue。这些类与接下来的 2.3 节 xml 的解析紧密相关。按照顺序，先从 BeanDefinition 开始介绍。<br>BeanDefinition，从字面意思上翻译成中文就是 “Bean 的定义”。从翻译结果中就可以猜出这个类的用途，即根据 Bean 配置信息生成相应的 Bean 详情对象。举个例子，如果把 Bean 比作是电脑 💻，那么 BeanDefinition 就是这台电脑的配置清单。我们从外观上无法看出这台电脑里面都有哪些配置，也看不出电脑的性能咋样。但是通过配置清单，我们就可了解这台电脑的详细配置。我们可以知道这台电脑是不是用了牙膏厂的 CPU，BOOM 厂的固态硬盘等。透过配置清单，我们也就可大致评估出这台电脑的性能。<br><img src="http://image.winrains.cn/2019/11/8ebb5.png" alt="img"><br>图1 电脑和配置清单<br>上面那个例子还是比较贴切的，但是只是个例子，和实际还是有差距的。那么在具体实现中，BeanDefinition 和 xml 是怎么对应的呢？答案在下面：<br><img src="http://image.winrains.cn/2019/11/5ef85.png" alt="img"><br>图2 根据 bean 配置生成 BeanDefinition<br>看完上图，我想大家对 BeanDefinition 的用途有了更进一步的认识。接下来我们来说说上图中的 ref 对应的 BeanReference 对象。BeanReference 对象保存的是 bean 配置中 ref 属性对应的值，在后续 BeanFactory 实例化 bean 时，会根据 BeanReference 保存的值去实例化 bean 所依赖的其他 bean。<br>接下来说说 PropertyValues 和 PropertyValue 这两个长的比较像的类，首先是PropertyValue。PropertyValue 中有两个字段 name 和 value，用于记录 bean 配置中的标签的属性值。然后是PropertyValues，PropertyValues 从字面意思上来看，是 PropertyValue 复数形式，在功能上等同于 List。那么为什么 Spring 不直接使用 List，而自己定义一个新类呢？答案是要获得一定的控制权，看下面的代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PropertyValues</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> final List&lt;PropertyValue&gt; propertyValueList = <span class="keyword">new</span> ArrayList&lt;PropertyValue&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPropertyValue</span>(<span class="params">PropertyValue pv</span>)</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 在这里可以对参数值 pv 做一些处理，如果直接使用 List，则就不行了</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.propertyValueList.<span class="keyword">add</span>(pv);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;PropertyValue&gt; <span class="title">getPropertyValues</span>(<span class="params"></span>)</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.propertyValueList;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>好了，辅助类介绍完了，接下来我们继续 BeanFactory 的生命流程探索。</p>
<h2 id="2-3-xml-的解析"><a href="#2-3-xml-的解析" class="headerlink" title="2.3 xml 的解析"></a>2.3 xml 的解析</h2><p>BeanFactory 初始化时，会根据传入的 xml 配置文件路径加载并解析配置文件。但是加载和解析 xml 配置文件这种脏活累活，BeanFactory 可不太愿意干，它只想高冷的管理容器中的 bean。于是 BeanFactory 将加载和解析配置文件的任务委托给专职人员 BeanDefinitionReader 的实现类 XmlBeanDefinitionReader 去做。那么 XmlBeanDefinitionReader 具体是怎么做的呢？XmlBeanDefinitionReader 做了如下几件事情：</p>
<ol>
<li>将 xml 配置文件加载到内存中</li>
<li>获取根标签下所有的标签</li>
<li>遍历获取到的标签列表，并从标签中读取 id，class 属性</li>
<li>创建 BeanDefinition 对象，并将刚刚读取到的 id，class 属性值保存到对象中</li>
<li>遍历标签下的标签，从中读取属性值，并保持在 BeanDefinition 对象中</li>
<li>将 &lt;id, BeanDefinition&gt; 键值对缓存在 Map 中，留作后用</li>
<li>重复3、4、5、6步，直至解析结束</li>
</ol>
<p>上面的解析步骤并不复杂，实现起来也不难，就是解析 xml 而已，这里就不过多叙述了。</p>
<h2 id="2-4-注册-BeanPostProcessor"><a href="#2-4-注册-BeanPostProcessor" class="headerlink" title="2.4 注册 BeanPostProcessor"></a>2.4 注册 BeanPostProcessor</h2><p>BeanPostProcessor 接口是 Spring 对外拓展的接口之一，其主要用途提供一个机会，让开发人员能够插手 bean 的实例化过程。通过实现这个接口，我们就可在 bean 实例化时，对bean 进行一些处理。比如，我们所熟悉的 AOP 就是在这里将切面逻辑织入相关 bean 中的。正是因为有了 BeanPostProcessor 接口作为桥梁，才使得 AOP 可以和 IOC 容器产生联系。关于这一点，我将会在后续章节详细说明。<br>接下来说说 BeanFactory 是怎么注册 BeanPostProcessor 相关实现类的。<br>XmlBeanDefinitionReader 在完成解析工作后，BeanFactory 会将它解析得到的 &lt;id, BeanDefinition&gt; 键值对注册到自己的 beanDefinitionMap 中。BeanFactory 注册好 BeanDefinition 后，就立即开始注册 BeanPostProcessor 相关实现类。这个过程比较简单：</p>
<ol>
<li>根据 BeanDefinition 记录的信息，寻找所有实现了 BeanPostProcessor 接口的类。</li>
<li>实例化 BeanPostProcessor 接口的实现类</li>
<li>将实例化好的对象放入 List中</li>
<li>重复2、3步，直至所有的实现类完成注册</li>
</ol>
<p>上面简述了 BeanPostProcessor 接口的用途以及注册的过程。BeanPostProcessor 是一个比较常用接口，相信大家都很熟悉了，这里就不过多叙述了。</p>
<h2 id="2-5-getBean-过程解析"><a href="#2-5-getBean-过程解析" class="headerlink" title="2.5 getBean 过程解析"></a>2.5 getBean 过程解析</h2><p>在完成了 xml 的解析、BeanDefinition 的注册以及 BeanPostProcessor 的注册过程后。BeanFactory 初始化的工作算是结束了，此时 BeanFactory 处于就绪状态，等待外部程序的调用。<br>外部程序一般都是通过调用 BeanFactory 的 getBean(String name) 方法来获取容器中的 bean。BeanFactory 具有延迟实例化 bean 的特性，也就是等外部程序需要的时候，才实例化相关的 bean。这样做的好处是比较显而易见的，第一是提高了 BeanFactory 的初始化速度，第二是节省了内存资源。下面我们就来详细说说 bean 的实例化过程：<br><img src="http://image.winrains.cn/2019/11/2c018.png" alt="bean实例化过程"><br>图3 Spring bean实例化过程<br>上图是一个完整的 Spring bean 实例化过程图。在我的仿写项目中，没有做的这么复杂，简化了 bean 实例化的过程，如下：<br><img src="http://image.winrains.cn/2019/11/ed39d.png" alt="img"><br>图4 toy-spring bean实例化过程<br>接下来我将按照简化后的 bean 实例化过程介绍，如果想了解完整的 bean 实例化过程，可以参考我的另一篇文章：<a href="https://segmentfault.com/a/1190000010734016" target="_blank" rel="noopener">Spring bean的生命流程</a>。简化后的实例化流程如下：</p>
<ol>
<li>实例化 bean 对象，类似于 new XXObject()</li>
<li>将配置文件中配置的属性填充到刚刚创建的 bean 对象中</li>
<li>检查 bean 对象是否实现了 Aware 一类的接口，如果实现了则把相应的依赖设置到 bean 对象中。toy-spring 目前仅对 BeanFactoryAware 接口实现类提供了支持</li>
<li>调用 BeanPostProcessor 前置处理方法，即 postProcessBeforeInitialization(Object bean, String beanName)</li>
<li>调用 BeanPostProcessor 后置处理方法，即 postProcessAfterInitialization(Object bean, String beanName)</li>
<li>bean 对象处于就绪状态，可以使用了</li>
</ol>
<p>上面 6 步流程并不复杂，源码实现的也较为简单，这里就不在贴代码说明了。大家如果想了解细节，可以去 github 上下载 <a href="https://github.com/code4wt/toy-spring" target="_blank" rel="noopener">toy-spring</a> 源码阅读。</p>
<h1 id="3-实现-AOP"><a href="#3-实现-AOP" class="headerlink" title="3. 实现 AOP"></a>3. 实现 AOP</h1><h2 id="3-1-AOP-原理"><a href="#3-1-AOP-原理" class="headerlink" title="3.1 AOP 原理"></a>3.1 AOP 原理</h2><p>AOP 是基于动态代理模式实现的，具体实现上可以基于 JDK 动态代理或者 Cglib 动态代理。其中 JDK 动态代理只能代理实现了接口的对象，而 Cglib 动态代理则无此限制。所以在为没有实现接口的对象生成代理时，只能使用 Cglib。在 toy-spring 项目中，暂时只实现了基于 JDK 动态代理的代理对象生成器。<br>关于 AOP 原理这里就不多说了，下面说说 toy-spring 中 AOP 的实现步骤。还是像上面一样，先列流程：</p>
<ol>
<li>AOP 逻辑介入 BeanFactory 实例化 bean 的过程</li>
<li>根据 Pointcut 定义的匹配规则，判断当前正在实例化的 bean 是否符合规则</li>
<li>如果符合，代理生成器将切面逻辑 Advice 织入 bean 相关方法中，并为目标 bean 生成代理对象</li>
<li>将生成的 bean 的代理对象返回给 BeanFactory 容器，到此，AOP 逻辑执行结束</li>
</ol>
<p>对于上面的4步流程，熟悉 Spring AOP 的朋友应该能很容易理解。如果有朋友不理解也没关系，在后续章节，我会详细介绍相关流程的具体实现。</p>
<h2 id="3-2-基于-JDK-动态代理的-AOP-实现"><a href="#3-2-基于-JDK-动态代理的-AOP-实现" class="headerlink" title="3.2 基于 JDK 动态代理的 AOP 实现"></a>3.2 基于 JDK 动态代理的 AOP 实现</h2><p>本节说说基于 JDK 动态代理的代理对象生成器具体实现。在 toy-spring 项目中，代理对象生成器的逻辑主要写在了 JdkDynamicAopProxy 类中，这个类的有两个方法，其中 getProxy 方法用于生成代理对象。invoke 方法是 InvocationHandler 接口的具体实现，包含了将通知（Advice）织入相关方法中，是3.1节所列流程中第3步流程的具体实现。好了，接下来，对着源码讲解 JdkDynamicAopProxy：<br>JdkDynamicAopProxy 实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">protected</span> AdvisedSupport advised;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractAopProxy</span><span class="params">(AdvisedSupport advised)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.advised = advised;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 基于 JDK 动态代理的代理对象生成器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Created by code4wt on 17/8/16.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">extends</span> <span class="title">AbstractAopProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkDynamicAopProxy</span><span class="params">(AdvisedSupport advised)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">super</span>(advised);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 为目标 bean 生成代理对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span> bean 的代理对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(getClass().getClassLoader(), advised.getTargetSource().getInterfaces(), <span class="keyword">this</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * InvocationHandler 接口中的 invoke 方法具体实现，封装了具体的代理逻辑</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> method</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理方法或原方法的返回值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        MethodMatcher methodMatcher = advised.getMethodMatcher();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 1. 使用方法匹配器 methodMatcher 测试 bean 中原始方法 method 是否符合匹配规则</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (methodMatcher != <span class="keyword">null</span> &amp;&amp; methodMatcher.matchers(method, advised.getTargetSource().getTargetClass())) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 获取 Advice。MethodInterceptor 的父接口继承了 Advice</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">            MethodInterceptor methodInterceptor = advised.getMethodInterceptor();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">           <span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"><span class="comment">            * 2. 将 bean 的原始方法 method 封装在 MethodInvocation 接口实现类对象中，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"><span class="comment">            * 并把生成的对象作为参数传给 Adivce 实现类对象，执行通知逻辑</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="comment">            */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> methodInterceptor.invoke(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">new</span> ReflectiveMethodInvocation(advised.getTargetSource().getTarget(), method, args));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 2. 当前 method 不符合匹配规则，直接调用 bean 的原始方法 method</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> method.invoke(advised.getTargetSource().getTarget(), args);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面贴的代码，已经对 JdkDynamicAopProxy 实现代码进行了逐行介解释，这里不再多说。下面用个流程图对通知织入逻辑进行总结：<br><img src="http://image.winrains.cn/2019/11/ab082.png" alt="img"><br>图5 toy-spring AOP 通知织入流程图<br>最后对 JdkDynamicAopProxy 进行简单的测试，测试代码及结果如下<br>测试类：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> LogInterceptor implements MethodInterceptor &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">public</span> <span class="keyword">Object</span> invoke(MethodInvocation invocation) throws Throwable &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(invocation.getMethod().getName() + " method start");</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">Object</span> obj= invocation.proceed();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(invocation.getMethod().getName() + " method end");</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> obj;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> JdkDynamicAopProxyTest &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    @Test</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">public</span> <span class="type">void</span> getProxy() throws <span class="keyword">Exception</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("---------- no proxy ----------");</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        HelloService helloService = <span class="built_in">new</span> HelloServiceImpl();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        helloService.sayHelloWorld();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("\n----------- proxy -----------");</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        AdvisedSupport advisedSupport = <span class="built_in">new</span> AdvisedSupport();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        advisedSupport.setMethodInterceptor(<span class="built_in">new</span> LogInterceptor());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        TargetSource targetSource = <span class="built_in">new</span> TargetSource(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                helloService, HelloServiceImpl.<span class="keyword">class</span>, HelloServiceImpl.<span class="keyword">class</span>.getInterfaces());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        advisedSupport.setTargetSource(targetSource);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        advisedSupport.setMethodMatcher((<span class="keyword">Method</span> <span class="keyword">method</span>, <span class="keyword">Class</span> beanClass) -&gt; <span class="keyword">true</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        helloService = (HelloService) <span class="built_in">new</span> JdkDynamicAopProxy(advisedSupport).getProxy();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        helloService.sayHelloWorld();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>测试结果：<br><img src="http://image.winrains.cn/2019/11/915b2.png" alt="img"><br>为了控制文章篇幅，上面代码中用到的其他辅助类，这里就不贴出来了，想看的朋友可以到 github 上下载源码。</p>
<h2 id="3-3-AOP-与-IOC-协作"><a href="#3-3-AOP-与-IOC-协作" class="headerlink" title="3.3 AOP 与 IOC 协作"></a>3.3 AOP 与 IOC 协作</h2><p>上一节介绍了3.1节所列流程中第3步流程的具体实现，这一节则会介绍1、2、4步流程的具体实现。在介绍之前，还要再次提一下 BeanPostProcessor接口。在之前2.4节 注册 BeanPostProcessor 中我已经介绍过 BeanPostProcessor 的作用，也说到了 AOP 是通过 BeanPostProcessor 接口与 IOC 产生联系的。不过2.4节，只是蜻蜓点水提了一下，没有详细展开说明。在本节中，我将详细讲解 toy-spring 项目中 AOP 和 IOC 是怎样被整合到一起的。<br>Spring 从2.0版本开始集成 AspectJ，通过集成 AspectJ，也使得 Spring AOP 的功能得到了很大的增强。我们在平时开发中，很多时候是使用基于 AspectJ 表达式及其他配置来实现切面功能。所以我在编写 toy-spring 项目时，也在项目中简单集成了 AspectJ。通过集成 AspectJ，使得 toy-spring AOP 可以基于 AspectJ 表达式完成复杂的匹配逻辑。接下来就让我们看看袖珍版 Spring AOP 是怎样实现的吧。<br>在 toy-spring 中，AOP 和 IOC 产生联系的具体实现类是 AspectJAwareAdvisorAutoProxyCreator（下面简称 AutoProxyCreator），这个类实现了 BeanPostProcessor 和 BeanFactoryAware 接口。BeanFactory 在注册 BeanPostProcessor 接口相关实现类的阶段，会将其本身注入到 AutoProxyCreator 中，为后面 AOP 给 bean 生成代理对象做准备。BeanFactory 初始化结束后，AOP 与 IOC 桥梁类 AutoProxyCreator 也完成了实例化，并被缓存在 BeanFactory 中，静待 BeanFactory 实例化 bean。当外部产生调用，BeanFactory 开始实例化 bean 时。AutoProxyCreator 就开始悄悄的工作了，工作细节如下：</p>
<ol>
<li>从 BeanFactory 查找实现了 PointcutAdvisor 接口的切面对象，切面对象中包含了实现 Pointcut 和 Advice 接口的对象。</li>
<li>使用 Pointcut 中的表达式对象匹配当前 bean 对象。如果匹配成功，进行下一步。否则终止逻辑，返回 bean。</li>
<li>JdkDynamicAopProxy 对象为匹配到的 bean 生成代理对象，并将代理对象返回给 BeanFactory。</li>
</ol>
<p>经过上面3步，AutoProxyCreator 就悄无声息的把原来的 bean 替换为代理对象了，是不是有种偷天换日的感觉。最后把 toy-spring AOP 剩余的实现代码贴出来：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> AspectJAwareAdvisorAutoProxyCreator implements BeanPostProcessor, BeanFactoryAware &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> XmlBeanFactory xmlBeanFactory;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    public Object post<span class="constructor">ProcessBeforeInitialization(Object <span class="params">bean</span>, String <span class="params">beanName</span>)</span> throws Exception &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        return bean;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    public Object post<span class="constructor">ProcessAfterInitialization(Object <span class="params">bean</span>, String <span class="params">beanName</span>)</span> throws Exception &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* 这里两个 if 判断很有必要，如果删除将会使程序进入死循环状态，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">         * 最终导致 StackOverflowError 错误发生</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (bean instanceof AspectJExpressionPointcutAdvisor) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            return bean;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (bean instanceof MethodInterceptor) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            return bean;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 1.  从 BeanFactory 查找 AspectJExpressionPointcutAdvisor 类型的对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        List&lt;AspectJExpressionPointcutAdvisor&gt; advisors =</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                xmlBeanFactory.get<span class="constructor">BeansForType(AspectJExpressionPointcutAdvisor.<span class="params">class</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        for (AspectJExpressionPointcutAdvisor advisor : advisors) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 2. 使用 Pointcut 对象匹配当前 bean 对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (advisor.get<span class="constructor">Pointcut()</span>.get<span class="constructor">ClassFilter()</span>.matchers(bean.get<span class="constructor">Class()</span>)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                ProxyFactory advisedSupport = <span class="keyword">new</span> <span class="constructor">ProxyFactory()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                advisedSupport.set<span class="constructor">MethodInterceptor((MethodInterceptor)</span> advisor.get<span class="constructor">Advice()</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">                advisedSupport.set<span class="constructor">MethodMatcher(<span class="params">advisor</span>.<span class="params">getPointcut</span>()</span>.get<span class="constructor">MethodMatcher()</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                TargetSource targetSource = <span class="keyword">new</span> <span class="constructor">TargetSource(<span class="params">bean</span>, <span class="params">bean</span>.<span class="params">getClass</span>()</span>, bean.get<span class="constructor">Class()</span>.get<span class="constructor">Interfaces()</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">                advisedSupport.set<span class="constructor">TargetSource(<span class="params">targetSource</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 3. 生成代理对象，并返回</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                return advisedSupport.get<span class="constructor">Proxy()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 2. 匹配失败，返回 bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        return bean;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    public void set<span class="constructor">BeanFactory(BeanFactory <span class="params">beanFactory</span>)</span> throws Exception &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        xmlBeanFactory = (XmlBeanFactory) beanFactory;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>ProxyFactory 实现代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * AopProxy 实现类的工厂类</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">extends</span> <span class="title">AdvisedSupport</span> <span class="title">implements</span> <span class="title">AopProxy</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    public <span class="type">Object</span> getProxy() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> createAopProxy().getProxy();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="type">AopProxy</span> createAopProxy() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">JdkDynamicAopProxy</span>(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> XmlBeanFactoryTest &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    @Test</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    public void get<span class="constructor">Bean()</span> throws Exception &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"--------- AOP test ----------"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        String location = get<span class="constructor">Class()</span>.get<span class="constructor">ClassLoader()</span>.get<span class="constructor">Resource(<span class="string">"spring.xml"</span>)</span>.get<span class="constructor">File()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        XmlBeanFactory bf = <span class="keyword">new</span> <span class="constructor">XmlBeanFactory(<span class="params">location</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        HelloService helloService = (HelloService) bf.get<span class="constructor">Bean(<span class="string">"helloService"</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        helloService.say<span class="constructor">HelloWorld()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>测试结果：<br><img src="http://image.winrains.cn/2019/11/e4614.png" alt="img"></p>
<h1 id="4-写在最后"><a href="#4-写在最后" class="headerlink" title="4. 写在最后"></a>4. 写在最后</h1><p>到此，本文的主要内容写完了。如果你耐心的读完了文章，并感觉不错的话，欢迎猛点赞和收藏按钮。这篇文章花了我一天的时间，写的实在有点累，也深感认真写博客的不易。本篇文章与 <a href="https://segmentfault.com/a/1190000010745705" target="_blank" rel="noopener">仿照 Spring 实现简单的 IOC 和 AOP - 上篇</a>，<a href="https://segmentfault.com/a/1190000010734016" target="_blank" rel="noopener">Spring bean的生命流程</a> 共三篇文章，对 Spring IOC 和 AOP 的实现原理进行了较为详细的结束。也是通过认真编写这三篇文章，使得我对 Spring 框架原理有了更进一步的认识。当然限于我的经验和能力，以上三篇文章中可能存在着一些错误。如果这些错误给大家造成了干扰，我表示很抱歉。所以文章若有疏漏不妥之处，还请指出来，如果能不吝赐教，那就更好了。好了，最后感谢大家耐心读完我的文章，下次再见。</p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li>《Spring揭秘》</li>
<li><a href="https://github.com/code4craft/tiny-spring" target="_blank" rel="noopener">tiny-spring</a></li>
</ul>
<h1 id="附录：Spring-源码分析文章列表"><a href="#附录：Spring-源码分析文章列表" class="headerlink" title="附录：Spring 源码分析文章列表"></a>附录：Spring 源码分析文章列表</h1><h2 id="Ⅰ-IOC"><a href="#Ⅰ-IOC" class="headerlink" title="Ⅰ. IOC"></a>Ⅰ. IOC</h2><table>
<thead>
<tr>
<th>更新时间</th>
<th>标题</th>
</tr>
</thead>
<tbody><tr>
<td>2018-05-30</td>
<td><a href="http://www.coolblog.xyz/2018/05/30/Spring-IOC-容器源码分析系列文章导读/" target="_blank" rel="noopener">Spring IOC 容器源码分析系列文章导读</a></td>
</tr>
<tr>
<td>2018-06-01</td>
<td><a href="http://www.coolblog.xyz/2018/06/01/Spring-IOC-容器源码分析-获取单例-bean/" target="_blank" rel="noopener">Spring IOC 容器源码分析 - 获取单例 bean</a></td>
</tr>
<tr>
<td>2018-06-04</td>
<td><a href="http://www.coolblog.xyz/2018/06/04/Spring-IOC-容器源码分析-创建单例-bean/" target="_blank" rel="noopener">Spring IOC 容器源码分析 - 创建单例 bean 的过程</a></td>
</tr>
<tr>
<td>2018-06-06</td>
<td><a href="http://www.coolblog.xyz/2018/06/06/Spring-IOC-容器源码分析-创建原始-bean-对象/" target="_blank" rel="noopener">Spring IOC 容器源码分析 - 创建原始 bean 对象</a></td>
</tr>
<tr>
<td>2018-06-08</td>
<td><a href="http://www.coolblog.xyz/2018/06/08/Spring-IOC-容器源码分析-循环依赖的解决办法/" target="_blank" rel="noopener">Spring IOC 容器源码分析 - 循环依赖的解决办法</a></td>
</tr>
<tr>
<td>2018-06-11</td>
<td><a href="http://www.coolblog.xyz/2018/06/11/Spring-IOC-容器源码分析-填充属性到-bean-原始对象/" target="_blank" rel="noopener">Spring IOC 容器源码分析 - 填充属性到 bean 原始对象</a></td>
</tr>
<tr>
<td>2018-06-11</td>
<td><a href="http://www.coolblog.xyz/2018/06/11/Spring-IOC-容器源码分析-余下的初始化工作/" target="_blank" rel="noopener">Spring IOC 容器源码分析 - 余下的初始化工作</a></td>
</tr>
</tbody></table>
<h2 id="Ⅱ-AOP"><a href="#Ⅱ-AOP" class="headerlink" title="Ⅱ. AOP"></a>Ⅱ. AOP</h2><table>
<thead>
<tr>
<th>更新时间</th>
<th>标题</th>
</tr>
</thead>
<tbody><tr>
<td>2018-06-17</td>
<td><a href="http://www.coolblog.xyz/2018/06/17/Spring-AOP-源码分析系列文章导读/" target="_blank" rel="noopener">Spring AOP 源码分析系列文章导读</a></td>
</tr>
<tr>
<td>2018-06-20</td>
<td><a href="http://www.coolblog.xyz/2018/06/20/Spring-AOP-源码分析-筛选合适的通知器/" target="_blank" rel="noopener">Spring AOP 源码分析 - 筛选合适的通知器</a></td>
</tr>
<tr>
<td>2018-06-20</td>
<td><a href="http://www.coolblog.xyz/2018/06/20/Spring-AOP-源码分析-筛选合适的通知器/" target="_blank" rel="noopener">Spring AOP 源码分析 - 创建代理对象</a></td>
</tr>
<tr>
<td>2018-06-22</td>
<td><a href="http://www.coolblog.xyz/2018/06/22/Spring-AOP-源码分析-拦截器链的执行过程/" target="_blank" rel="noopener">Spring AOP 源码分析 - 拦截器链的执行过程</a></td>
</tr>
</tbody></table>
<h2 id="Ⅲ-MVC"><a href="#Ⅲ-MVC" class="headerlink" title="Ⅲ. MVC"></a>Ⅲ. MVC</h2><table>
<thead>
<tr>
<th>更新时间</th>
<th>标题</th>
</tr>
</thead>
<tbody><tr>
<td>2018-06-29</td>
<td><a href="http://www.coolblog.xyz/2018/06/29/Spring-MVC-原理探秘-一个请求的旅行过程/" target="_blank" rel="noopener">Spring MVC 原理探秘 - 一个请求的旅行过程</a></td>
</tr>
<tr>
<td>2018-06-30</td>
<td><a href="http://www.coolblog.xyz/2018/06/30/Spring-MVC-原理探秘-容器的创建过程/" target="_blank" rel="noopener">Spring MVC 原理探秘 - 容器的创建过程</a></td>
</tr>
</tbody></table>
<blockquote>
<p>作者：田小波</p>
<p>来源：<a href="https://www.tianxiaobo.com/2018/01/18/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%9A%84-Spring-IOC-%E5%92%8C-AOP-%E4%B8%8B%E7%AF%87/" target="_blank" rel="noopener">https://www.tianxiaobo.com/2018/01/18/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%9A%84-Spring-IOC-%E5%92%8C-AOP-%E4%B8%8B%E7%AF%87/</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/AOP/" rel="tag"># AOP</a>
              <a href="/tags/IoC/" rel="tag"># IoC</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/08/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%9A%84-Spring-IOC-%E5%92%8C-AOP%EF%BC%88%E4%B8%8A%EF%BC%89/" rel="prev" title="自己动手实现的 Spring IOC 和 AOP（上）">
      <i class="fa fa-chevron-left"></i> 自己动手实现的 Spring IOC 和 AOP（上）
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/08/LinkedHashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%EF%BC%88JDK1-8%EF%BC%89/" rel="next" title="LinkedHashMap 源码详细分析（JDK1.8）">
      LinkedHashMap 源码详细分析（JDK1.8） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-背景"><span class="nav-number">1.</span> <span class="nav-text">1. 背景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-IOC-的实现"><span class="nav-number">2.</span> <span class="nav-text">2. IOC 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-BeanFactory-的生命流程"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 BeanFactory 的生命流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-BeanDefinition-及其他一些类的介绍"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 BeanDefinition 及其他一些类的介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-xml-的解析"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 xml 的解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-注册-BeanPostProcessor"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 注册 BeanPostProcessor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-getBean-过程解析"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 getBean 过程解析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-实现-AOP"><span class="nav-number">3.</span> <span class="nav-text">3. 实现 AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-AOP-原理"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 AOP 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-基于-JDK-动态代理的-AOP-实现"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 基于 JDK 动态代理的 AOP 实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-AOP-与-IOC-协作"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 AOP 与 IOC 协作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-写在最后"><span class="nav-number">4.</span> <span class="nav-text">4. 写在最后</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考："><span class="nav-number">5.</span> <span class="nav-text">参考：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#附录：Spring-源码分析文章列表"><span class="nav-number">6.</span> <span class="nav-text">附录：Spring 源码分析文章列表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Ⅰ-IOC"><span class="nav-number">6.1.</span> <span class="nav-text">Ⅰ. IOC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ⅱ-AOP"><span class="nav-number">6.2.</span> <span class="nav-text">Ⅱ. AOP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ⅲ-MVC"><span class="nav-number">6.3.</span> <span class="nav-text">Ⅲ. MVC</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">congsheng.wang</p>
  <div class="site-description" itemprop="description">trouble is a friend</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">984</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">94</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">156</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">congsheng.wang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
