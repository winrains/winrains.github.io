<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://congsheng.wang').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="本文从API角度入手，带你了解SpringMVC启动的原理。">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring MVC启动原理">
<meta property="og:url" content="http:&#x2F;&#x2F;congsheng.wang&#x2F;2020&#x2F;01&#x2F;08&#x2F;Spring-MVC%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86&#x2F;index.html">
<meta property="og:site_name" content="congsheng的博客">
<meta property="og:description" content="本文从API角度入手，带你了解SpringMVC启动的原理。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191022121034-9792d.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191022121035-34016.jpeg">
<meta property="og:updated_time" content="2020-01-08T02:15:29.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191022121034-9792d.png">

<link rel="canonical" href="http://congsheng.wang/2020/01/08/Spring-MVC%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Spring MVC启动原理 | congsheng的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">congsheng的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">欢迎访问：winrains.cn</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">156</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">94</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">984</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://congsheng.wang/2020/01/08/Spring-MVC%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="congsheng.wang">
      <meta itemprop="description" content="trouble is a friend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="congsheng的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring MVC启动原理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-08 10:15:29" itemprop="dateCreated datePublished" datetime="2020-01-08T10:15:29+08:00">2020-01-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">Spring技术</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring%E6%8A%80%E6%9C%AF/Spring-MVC/" itemprop="url" rel="index">
                    <span itemprop="name">Spring MVC</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文从API角度入手，带你了解SpringMVC启动的原理。</p>
<a id="more"></a>

<h2 id="ServletContainerInitializer"><a href="#ServletContainerInitializer" class="headerlink" title="ServletContainerInitializer"></a>ServletContainerInitializer</h2><p>在web容器启动时为提供给第三方组件机会做一些初始化的工作，例如注册<code>servlet</code>或者<code>filtes</code>等，servlet规范中通过<code>ServletContainerInitializer</code>实现此功能。<br>每个框架要使用<code>ServletContainerInitializer</code>就必须在对应的jar包的<code>META-INF/services</code>目录创建一个名为<code>javax.servlet.ServletContainerInitializer</code>的文件，文件内容指定具体的<code>ServletContainerInitializer</code>实现类，那么，当web容器启动时就会运行这个初始化器做一些组件内的初始化工作。<br>一般伴随着<code>ServletContainerInitializer</code>一起使用的还有<code>HandlesTypes</code>注解，通过<code>HandlesTypes</code>可以将感兴趣的一些类注入到<code>ServletContainerInitializerde</code>的<code>onStartup</code>方法作为参数传入。<br>Tomcat容器的<code>ServletContainerInitializer</code>机制的实现，主要交由Context容器和ContextConfig监听器共同实现，<br>ContextConfig监听器负责在容器启动时读取每个web应用的<code>WEB-INF/lib</code>目录下包含的jar包的<code>META-INF/services/javax.servlet.ServletContainerInitializer</code>，以及web根目录下的<code>META-INF/services/javax.servlet.ServletContainerInitializer</code>，<br>通过反射完成这些<code>ServletContainerInitializer</code>的实例化，然后再设置到Context容器中，最后Context容器启动时就会分别调用每个<code>ServletContainerInitializer</code>的<code>onStartup</code>方法，并将感兴趣的类作为参数传入。</p>
<p><img src="http://image.winrains.cn/2019/10/20191022121034-9792d.png" alt="http://image.winrains.cn/2019/10/20191022121034-9792d.png"></p>
<p>基本的实现机制如图，首先通过ContextConfig监听器遍历每个jar包或web根目录的<code>META-INF/services/javax.servlet.ServletContainerInitializer</code>文件，根据读到的类路径实例化每个<code>ServletContainerInitializer</code>；然后再分别将实例化好的<code>ServletContainerInitializer</code>设置进Context容器中；最后Context容器启动时分别调用所有<code>ServletContainerInitializer</code>对象的<code>onStartup</code>方法。<br>假如读出来的内容为<code>com.seaboat.mytomcat.CustomServletContainerInitializer</code>，则通过反射实例化一个<code>CustomServletContainerInitializer</code>对象，这里涉及到一个<code>@HandlesTypes</code>注解的处理，被它标明的类需要作为参数值传入到<code>onStartup</code>方法。<br>如下例子：</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">@HandlesTypes(&#123; HttpServlet<span class="class">.<span class="keyword">class</span>,<span class="title">Filter</span>.<span class="title">class</span> &#125;)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomServletContainerInitializer</span> <span class="keyword">implements</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    ServletContainerInitializer &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> void onStartup(Set&lt;<span class="class"><span class="keyword">Class</span>&lt;?&gt;&gt; <span class="title">classes</span>, <span class="title">ServletContext</span> <span class="title">servletContext</span>)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      throws ServletException &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">for</span>(<span class="class"><span class="keyword">Class</span> <span class="title">c</span> : <span class="title">classes</span>)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">         System.out.println(c.getName());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其中<code>@HandlesTypes</code>标明的<code>HttpServlet</code>和<code>Filter</code>两个class被注入到了<code>onStartup</code>方法。<br>所以<strong>这个注解也是需要在ContextConfig监听器中处理</strong>。<br>前面已经介绍了注解的实现原理，由于有了编译器的协助，我们可以方便地通过<code>ServletContainerInitializer</code>的class对象中获取到<code>HandlesTypes</code>对象，进而再获取到注解声明的类数组，如</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">HandlesTypes ht =servletContainerInitializer.getClass().getAnnotation(HandlesTypes<span class="class">.<span class="keyword">class</span>);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">Class</span>&lt;?&gt;[] <span class="title">types</span> = <span class="title">ht</span>.<span class="title">value</span>();</span></span></pre></td></tr></table></figure>

<p>即可获取到<code>HttpServlet</code>和<code>Filter</code>的class对象数组，后面Context容器调用<code>CustomServletContainerInitializer</code>对象的<code>onStartup</code>方法时作为参数传入。<br>至此，即完成了servlet规范的<code>ServletContainerInitializer</code>初始化器机制。</p>
<h2 id="SpringServletContainerInitializer"><a href="#SpringServletContainerInitializer" class="headerlink" title="SpringServletContainerInitializer"></a>SpringServletContainerInitializer</h2><p>上面提到了<code>META-INF/services/javax.servlet.ServletContainerInitializer</code>，在<code>Springspring-web-4.3.0.RELEASE.jar</code> Jar包中可以找到该文件，内容如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.web</span><span class="selector-class">.SpringServletContainerInitializer</span></span></pre></td></tr></table></figure>

<p>下面，我们就来详细讲解下<code>SpringServletContainerInitializer</code>。</p>
<hr>
<p>首先看下API中的描述：<br><strong>Servlet 3.0</strong> <code>ServletContainerInitializer</code>被设计为使用Spring的<code>WebApplicationInitializer</code>SPI来支持Servlet容器的基于代码的配置，而不是传统的基于web.xml的配置(也可能两者结合使用)。</p>
<h3 id="一、运作机制"><a href="#一、运作机制" class="headerlink" title="一、运作机制"></a>一、运作机制</h3><p>假设类路径中存在spring-web模块的JAR包，<code>SpringServletContainerInitializer</code>将被加载并实例化，并且在容器启动期间由Servlet 3.0容器调用<code>onStartup</code>方法。<br>这是通过<code>JAR Services API ServiceLoader.load(Class)</code>方法(检测Spring-Web模块的<code>META-INF/services/javax.servlet.ServletContainerInitializer</code>配置文件)实现的。</p>
<h3 id="二、与web-xml结合使用"><a href="#二、与web-xml结合使用" class="headerlink" title="二、与web.xml结合使用"></a>二、与web.xml结合使用</h3><p>Web应用程序可以选择通过web.xml中的<code>metadata-complete</code>属性(它控制扫描Servlet注解的行为)<br>或通过web.xml中的``元素(它控制哪些web fragments(i.e. jars)被允许执行扫描<code>ServletContainerInitializer</code>)<br>来限制Servlet容器在启动时扫描的类路径。<br>当使用这个特性时，可以通过添加”spring_web”到web.xml里的<code>web fragments</code>列表来启用<code>SpringServletContainerInitializer</code>，<br>如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">absolute-ordering</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>some_web_fragment<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>spring_web<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">absolute-ordering</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>servlet3.X中的<code>metadata-complete</code>属性<br>在Servlet3.X的web.xml中可以设置<code>metadata-complete</code>属性，例如：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;web-<span class="keyword">app</span> xmlns=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">     xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">     xsi:schemaLocation="http:<span class="comment">//xmlns.jcp.org/xml/ns/javaee</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">                  http:<span class="comment">//xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">     <span class="keyword">version</span>=<span class="string">"3.1"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">     metadata-complete=<span class="string">"true"</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&lt;/web-<span class="keyword">app</span>&gt;</span></pre></td></tr></table></figure>

<p>如果设置<code>metadata-complete=&quot;true&quot;</code>，会在启动时不扫描注解（annotation）。如果不扫描注解的话，用注解进行的配置就无法生效，例如：<code>@WebServlet</code></p>
</blockquote>
<h3 id="三、与Spring的WebApplicationInitializer的关系"><a href="#三、与Spring的WebApplicationInitializer的关系" class="headerlink" title="三、与Spring的WebApplicationInitializer的关系"></a>三、与Spring的WebApplicationInitializer的关系</h3><p>Spring的<code>WebApplicationInitializer</code> SPI仅由一个方法组成：<code>WebApplicationInitializer.onStartup(ServletContext)</code>。声明与<code>ServletContainerInitializer.onStartup(Set, ServletContext)</code>非常相似：简单地说，<code>SpringServletContainerInitializer</code>负责将<code>ServletContext</code>实例化并委托给用户定义的<code>WebApplicationInitializer</code>实现。然后每个<code>WebApplicationInitializer</code>负责完成初始化<code>ServletContext</code>的实际工作。下面的<code>onStartup</code>文档中详细介绍了委托的具体过程。</p>
<h3 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h3><p>一般来说，这个类应该被视为<code>WebApplicationInitializer</code>SPI的支持。利用这个容器初始化器也是完全可选的：虽然这个初始化器在所有的Servlet 3.0+运行环境下被加载和调用，但用户可以选择是否提供<code>WebApplicationInitializer</code>实现。如果未检测到<code>WebApplicationInitializer</code>类型，则此<code>SpringServletContainerInitializer</code>将不起作用。<br>请注意，除了这些类型是在spring-web模块JAR中提供的，使用这个<code>SpringServletContainerInitializer</code>和<code>WebApplicationInitializer</code>与Spring MVC没有任何“捆绑”。相反，它们可以被认为是通用的，以便于简化<code>ServletContext</code>基于代码的配置。换句话说，任何<code>servlet</code>, <code>listener</code>, 或者<code>filter</code>都可以在<code>WebApplicationInitializer</code>中注册，而不仅仅是Spring MVC特定的组件。<br><code>SpringServletContainerInitializer</code>既不是为扩展而设计的。它应该被认为是一个内部类型，<code>WebApplicationInitializer</code>是面向用户的SPI。</p>
<hr>
<p>好啦，现在对<code>SpringServletContainerInitializer</code>有了一个比较透彻的了解，下面我们来看一下唯一的<code>onStartup</code>方法。<br>将<code>ServletContext</code>委托给类路径中的<code>WebApplicationInitializer</code>实现。<br>因为这个类声明了<code>@HandlesTypes(WebApplicationInitializer.class)</code>，所以<br>Servlet 3.0+容器会自动扫描类路径下Spring的<code>WebApplicationInitializer</code>接口的实现，并将所有这些类型的集合提供给这个方法的<code>webAppInitializerClasses</code>参数。<br>如果在类路径下找不到<code>WebApplicationInitializer</code>实现，则此方法不会有任何操作。将发出INFO级别的日志消息，通知用户<code>ServletContainerInitializer</code>确实已被调用，但没有找到<code>WebApplicationInitializer</code>实现。<br>假设检测到一个或多个<code>WebApplicationInitializer</code>类型，它们将被实例化（如果存在<code>@Order</code>注释或实现<code>Ordered</code>接口，则对其进行排序）。然后，将调用每个实例<code>WebApplicationInitializer.onStartup(ServletContext)</code>方法，并委派<code>ServletContext</code>，以便每个实例都可以注册和配置Servlet，例如Spring的<code>DispatcherServlet</code>，<code>listeners</code>（如Spring的<code>ContextLoaderListener</code>），或者其他Servlet API组件（如<code>filters</code>）。</p>
<hr>
<p>下面是<code>SpringServletContainerInitializer</code>的源码：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">@<span class="constructor">HandlesTypes(WebApplicationInitializer.<span class="params">class</span>)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> SpringServletContainerInitializer implements ServletContainerInitializer &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    public void on<span class="constructor">Startup(Set&lt;Class&lt;?&gt;&gt; <span class="params">webAppInitializerClasses</span>, ServletContext <span class="params">servletContext</span>)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            throws ServletException &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// WebApplicationInitializer实现如果存在`@Order`注释或实现`Ordered`接口，则对其进行排序，故这里使用LinkedList</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        List&lt;WebApplicationInitializer&gt; initializers = <span class="keyword">new</span> LinkedList&lt;WebApplicationInitializer&gt;<span class="literal">()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (webAppInitializerClasses != null) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            for (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// Be defensive: Some servlet containers provide us with invalid classes,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// no matter what @HandlesTypes says...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 有时候，Servlet容器提供给我们的可能是无效的webAppInitializerClass</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (!waiClass.is<span class="constructor">Interface()</span><span class="operator"> &amp;&amp; </span>!<span class="module-access"><span class="module"><span class="identifier">Modifier</span>.</span></span>is<span class="constructor">Abstract(<span class="params">waiClass</span>.<span class="params">getModifiers</span>()</span>) &amp;&amp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                        <span class="module-access"><span class="module"><span class="identifier">WebApplicationInitializer</span>.</span></span><span class="keyword">class</span>.is<span class="constructor">AssignableFrom(<span class="params">waiClass</span>)</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                        initializers.add((WebApplicationInitializer) waiClass.<span class="keyword">new</span><span class="constructor">Instance()</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                    catch (Throwable ex) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                        throw <span class="keyword">new</span> <span class="constructor">ServletException(<span class="string">"Failed to instantiate WebApplicationInitializer class"</span>, <span class="params">ex</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (initializers.is<span class="constructor">Empty()</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            servletContext.log(<span class="string">"No Spring WebApplicationInitializer types detected on classpath"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            return;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        servletContext.log(initializers.size<span class="literal">()</span> + <span class="string">" Spring WebApplicationInitializers detected on classpath"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">AnnotationAwareOrderComparator</span>.</span></span>sort(initializers);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        for (WebApplicationInitializer initializer : initializers) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">            initializer.on<span class="constructor">Startup(<span class="params">servletContext</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<hr>
<h2 id="WebApplicationInitializer"><a href="#WebApplicationInitializer" class="headerlink" title="WebApplicationInitializer"></a>WebApplicationInitializer</h2><p>下面我们来看下<code>WebApplicationInitializer API</code>文档的相关介绍。<br>在Servlet 3.0+环境中实现该接口，以便以编程方式配置<code>ServletContext</code>，而不是以传统的基于web.xml的方法。<code>WebApplicationInitializer</code>SPI的实现将被<code>SpringServletContainerInitializer</code>(它本身是由Servlet 3.0容器自动引导的)自动检测到。</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><strong>基于XML的方式</strong><br>大多数Spring用户构建Web应用程序时需要注册Spring的<code>DispatcherServlet</code>。作为参考，通常在<code>WEB-INF/web.xml</code>中按如下方式：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"> <span class="params">&lt;servlet&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="params">&lt;servlet-name&gt;</span>dispatcher<span class="params">&lt;/servlet-name&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="params">&lt;servlet-class&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">      org.springframework.web.servlet.DispatcherServlet</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="params">&lt;/servlet-class&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="params">&lt;init-param&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="params">&lt;param-name&gt;</span>contextConfigLocation<span class="params">&lt;/param-name&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="params">&lt;param-value&gt;</span>/WEB-INF<span class="meta-keyword">/spring/</span>dispatcher-config.xml<span class="params">&lt;/param-value&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="params">&lt;/init-param&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="params">&lt;load-on-startup&gt;</span><span class="number">1</span><span class="params">&lt;/load-on-startup&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;/servlet&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;servlet-mapping&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="params">&lt;servlet-name&gt;</span>dispatcher<span class="params">&lt;/servlet-name&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="params">&lt;url-pattern&gt;</span>/<span class="params">&lt;/url-pattern&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;/servlet-mapping&gt;</span></span></pre></td></tr></table></figure>

<p><strong>基于代码的方式</strong><br><code>DispatcherServlet</code>注册逻辑与上述等效</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> onStartup(ServletContext <span class="keyword">container</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        XmlWebApplicationContext appContext = <span class="keyword">new</span> XmlWebApplicationContext();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        appContext.setConfigLocation(<span class="string">"/WEB-INF/spring/dispatcher-config.xml"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        ServletRegistration.Dynamic dispatcher = <span class="keyword">container</span>.addServlet(<span class="string">"dispatcher"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">new</span> DispatcherServlet(appContext));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        dispatcher.setLoadOnStartup(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        dispatcher.addMapping(<span class="string">"/"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>作为上述的替代方法，您还可以继承自<code>org.springframework.web.servlet.support.AbstractDispatcherServletInitializer</code>。<br>正如您所看到的，使用Servlet 3.0的<code>ServletContext.addServlet</code>方法，我们注册了一个<code>DispatcherServlet</code>的实例。<br>这种风格简单明了。不用关心处理<code>init-params</code>等，只是普通的JavaBean风格的属性和构造函数参数。在将其注入到<code>DispatcherServlet</code>之前，您可以根据需要自由创建和使用Spring应用程序上下文。<br>大多数Spring Web组件已经更新，以支持这种注册方式。你会发现<code>DispatcherServlet</code>，<code>FrameworkServlet</code>，<code>ContextLoaderListener</code>和<code>DelegatingFilterProxy</code>现在都支持构造函数参数。Servlet 3.0 ServletContext API允许以编程方式设置<code>init-params</code>，<code>context-params</code>等。<br><strong>完全基于代码的配置方法</strong><br>在上面的例子中，<code>WEB-INF/web.xml</code>以<code>WebApplicationInitializer</code>形式的代码替换，但<code>dispatcher-config.xml</code>配置仍然是基于XML的。<code>WebApplicationInitializer</code>非常适合与Spring的基于代码的<code>@Configuration</code>类一起使用。以下示例演示了使用Spring的<code>AnnotationConfigWebApplicationContext</code>代替<code>XmlWebApplicationContext</code>进行重构，以及使用用户定义的<code>@Configuration</code>类<code>AppConfig</code>和<code>DispatcherConfig</code>，而不是Spring XML文件。这个例子也超出了上面的例子来演示根应用上下文的典型配置和<code>ContextLoaderListener</code>的注册：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext container)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// Create the 'root' Spring application context</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        AnnotationConfigWebApplicationContext rootContext = <span class="keyword">new</span> AnnotationConfigWebApplicationContext();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        rootContext.register(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// Manage the lifecycle of the root application context</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        container.addListener(<span class="keyword">new</span> ContextLoaderListener(rootContext));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// Create the dispatcher servlet's Spring application context</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        AnnotationConfigWebApplicationContext dispatcherContext = <span class="keyword">new</span> AnnotationConfigWebApplicationContext();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        dispatcherContext.register(DispatcherConfig<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// Register and map the dispatcher servlet</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        ServletRegistration.Dynamic dispatcher = container.addServlet(<span class="string">"dispatcher"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">new</span> DispatcherServlet(dispatcherContext));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        dispatcher.setLoadOnStartup(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        dispatcher.addMapping(<span class="string">"/"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>作为上述的替代方法，您还可以继承自<code>org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer</code>。注意，<code>WebApplicationInitializer</code>的实现类会被自动检测到。<br><strong>Ordering WebApplicationInitializer execution</strong><br><code>WebApplicationInitializer</code>实现类可以有选择地在类上使用Spring的<code>@Order</code>注解，也可以实现Spring的<code>Ordered</code>接口。如果是这样，初始化程序将在调用之前排序。这为用户提供了确保Servlet容器初始化顺序的机制。使用此功能的情况很少，因为典型的应用程序可能会将所有容器初始化集中在一个<code>WebApplicationInitializer</code>中。<br><strong>注意事项</strong><br><strong>web.xml版本</strong><br><code>WEB-INF/web.xml</code>和<code>WebApplicationInitializer</code>的使用不是互斥的; 例如，web.xml可以注册一个servlet，而<code>WebApplicationInitializer</code>可以注册另一个。 Initializer甚至可以通过诸如<code>ServletContext.getServletRegistration(String)</code>之类的方法来修改在web.xml中执行的注册。但是，如果应用程序中存在<code>WEB-INF/web.xml</code>，则其版本属性必须设置为”3.0”或更高，否则Servlet容器将忽略<code>ServletContainerInitializer</code>的引导。</p>
<hr>
<p>下面我们来看一组<code>WebApplicationInitializer</code>的实现类：<br>继承关系如下：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">AbstractAnnotationConfigDispatcherServletInitializer</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">        <span class="string">|</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="string">| —— AbstractDispatcherServletInitializer</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">                    <span class="string">|</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">                    <span class="string">| —— AbstractContextLoaderInitializer</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                                <span class="string">|</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                                <span class="string">| —— WebApplicationInitializer</span></span></pre></td></tr></table></figure>

<h2 id="AbstractAnnotationConfigDispatcherServletInitializer"><a href="#AbstractAnnotationConfigDispatcherServletInitializer" class="headerlink" title="AbstractAnnotationConfigDispatcherServletInitializer"></a>AbstractAnnotationConfigDispatcherServletInitializer</h2><p><code>org.springframework.web.WebApplicationInitializer</code>实现类的基类，用于注册配置了<code>@Configuration/@Component</code>注解标记的配置类的<code>DispatcherServlet</code>。<br>具体的实现类需要实现<code>getRootConfigClasses()</code>和<code>getServletConfigClasses()</code>以及<code>getServletMappings()</code>方法。更多的方法由<code>AbstractDispatcherServletInitializer</code>提供。这是使用基于Java配置应用程序的首选方法。<br>下面是<code>AbstractAnnotationConfigDispatcherServletInitializer</code>的源码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractDispatcherServletInitializer</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>创建要提供给<span class="code">`ContextLoaderListener`</span>的<span class="strong">**根应用程序上下文**</span>。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>返回的上下文委托给<span class="code">`ContextLoaderListener.ContextLoaderListener(WebApplicationContext)`</span>，</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>并将作为<span class="code">`DispatcherServlet`</span>应用程序上下文的父上下文来建立。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>因此，它通常包含中间层服务，数据源等。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>该方法创建一个<span class="code">`AnnotationConfigWebApplicationContext`</span>，并为其提供由<span class="code">`getRootConfigClasses()`</span>返回的配置类。如果<span class="code">`getRootConfigClasses()`</span>返回Null，则不会创建根应用上下文。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    protected WebApplicationContext createRootApplicationContext() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        Class&lt;?&gt;[] configClasses = getRootConfigClasses();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(configClasses)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            AnnotationConfigWebApplicationContext rootAppContext = <span class="keyword">new</span> AnnotationConfigWebApplicationContext();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            rootAppContext.register(configClasses);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> rootAppContext;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>创建一个<span class="strong">**Servlet应用上下文**</span>以提供给<span class="code">`DispatcherServlet`</span>。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>返回的上下文被委托给Spring的<span class="code">`DispatcherServlet.DispatcherServlet(WebApplicationContext)`</span>方法。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>因此，它通常包含控制器，视图解析器，locale解析器和其他Web相关的bean。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>该实现创建一个<span class="code">`AnnotationConfigWebApplicationContext`</span>，为其提供由<span class="code">`getServletConfigClasses()`</span>返回的配置类。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    protected WebApplicationContext createServletApplicationContext() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        AnnotationConfigWebApplicationContext servletAppContext = <span class="keyword">new</span> AnnotationConfigWebApplicationContext();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        Class&lt;?&gt;[] configClasses = getServletConfigClasses();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(configClasses)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">            servletAppContext.register(configClasses);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> servletAppContext;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>指定要提供给根应用上下文的<span class="code">`@Configuration`</span>或<span class="code">`@Component`</span>注解标记的配置类。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    protected <span class="keyword">abstract</span> Class&lt;?&gt;[] getRootConfigClasses();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>指定要提供给Dispatcher Servlet应用上下文的<span class="code">`@Configuration`</span>或<span class="code">`@Component`</span>注解标记的配置类。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    protected <span class="keyword">abstract</span> Class&lt;?&gt;[] getServletConfigClasses();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="AbstractDispatcherServletInitializer"><a href="#AbstractDispatcherServletInitializer" class="headerlink" title="AbstractDispatcherServletInitializer"></a>AbstractDispatcherServletInitializer</h2><p><code>org.springframework.web.WebApplicationInitializer</code>实现的基类，在<code>ServletContext</code>中注册<code>DispatcherServlet</code>。<br>具体的实现类需要实现<code>createServletApplicationContext()</code>和<code>getServletMappings()</code>方法，两者都由<code>registerDispatcherServlet(ServletContext)</code>调用。<br>进一步的自定义可以通过重写<code>customizeRegistration(ServletRegistration.Dynamic)</code>方法来实现。<br>由于此类继承了<code>AbstractContextLoaderInitializer</code>抽象类，具体实现类也需要实现<code>createRootApplicationContext()</code>来设置父级根应用上下文。如果不需要根应用上下文，<code>createRootApplicationContext()</code>返回null即可。<br>下面看下源码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDispatcherServletInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractContextLoaderInitializer</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>The default servlet name. Can be customized by overriding &#123;@link #getServletName&#125;.</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    public <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span> DEFAULT_SERVLET_NAME = <span class="string">"dispatcher"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    public <span class="keyword">void</span> onStartup(ServletContext servletContext) throws ServletException &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">super</span>.onStartup(servletContext);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        registerDispatcherServlet(servletContext);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>针对给定的Servlet上下文注册一个<span class="code">`DispatcherServlet`</span>。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>该方法将创建一个名称为由<span class="code">`getServletName()`</span>指定的<span class="code">`DispatcherServlet`</span>，</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>并使用从<span class="code">`createServletApplicationContext()`</span>返回的Servlet应用上下文对其进行初始化，</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>并将其映射到从<span class="code">`getServletMappings()`</span>返回的<span class="code">`pattern`</span>。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>进一步的自定义可以通过重写<span class="code">`customizeRegistration(ServletRegistration.Dynamic)`</span>或<span class="code">`createDispatcherServlet(WebApplicationContext)`</span>来实现。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param servletContext 注册servlet的上下文</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    protected <span class="keyword">void</span> registerDispatcherServlet(ServletContext servletContext) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// DispatcherServlet被注册的名称</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">String</span> servletName = getServletName();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        Assert.hasLength(servletName, <span class="string">"getServletName() must not return empty or null"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 创建Servlet应用上下文，参见AbstractAnnotationConfigDispatcherServletInitializer的实现</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        WebApplicationContext servletAppContext = createServletApplicationContext();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        Assert.notNull(servletAppContext,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                <span class="string">"createServletApplicationContext() did not return an application "</span> +</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                        <span class="string">"context for servlet ["</span> + servletName + <span class="string">"]"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 将Servlet应用上下文以委托给DispatcherServlet</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        FrameworkServlet dispatcherServlet = createDispatcherServlet(servletAppContext);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        dispatcherServlet.setContextInitializers(getServletApplicationContextInitializers());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        ServletRegistration.Dynamic registration = servletContext.addServlet(servletName, dispatcherServlet);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        Assert.notNull(registration,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">                <span class="string">"Failed to register servlet with name '"</span> + servletName + <span class="string">"'."</span> +</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">                        <span class="string">"Check if there is another servlet registered under the same name."</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        registration.setLoadOnStartup(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        registration.addMapping(getServletMappings());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        registration.setAsyncSupported(isAsyncSupported());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        Filter[] filters = getServletFilters();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(filters)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (Filter filter : filters) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">                registerServletFilter(servletContext, filter);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">        customizeRegistration(registration);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>返回<span class="code">`DispatcherServlet`</span>被注册的名称。 默认值为DEFAULT<span class="emphasis">_SERVLET_</span>NAME。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@see #registerDispatcherServlet(ServletContext)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">    protected <span class="built_in">String</span> getServletName() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> DEFAULT_SERVLET_NAME;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>创建一个Servlet应用上下文以提供给<span class="code">`DispatcherServlet`</span>。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>返回的上下文被委托给Spring的<span class="code">`DispatcherServlet.DispatcherServlet(WebApplicationContext)`</span>。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>因此，它通常包含控制器，视图解析器，locale解析器和其他Web相关的bean。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@see #registerDispatcherServlet(ServletContext)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">    protected <span class="keyword">abstract</span> WebApplicationContext createServletApplicationContext();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>使用指定的<span class="code">`WebApplicationContext`</span>Servlet应用上下文创建<span class="code">`DispatcherServlet`</span>（或由<span class="code">`FrameworkServlet`</span>派生的其他类型的<span class="code">`dispatcher`</span>）。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>注意：从4.2.3开始允许返回任意<span class="code">`FrameworkServlet`</span>的子类。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>以前，它必须要返回一个<span class="code">`DispatcherServlet`</span>或其子类。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">    protected FrameworkServlet createDispatcherServlet(WebApplicationContext servletAppContext) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DispatcherServlet(servletAppContext);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Specify application context initializers to be applied to </span>the<span class="markdown"> servlet-specific</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>application context that </span>the<span class="markdown"> &#123;@code DispatcherServlet&#125; is being created with.</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@see #createServletApplicationContext()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@see DispatcherServlet#setContextInitializers</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@see #getRootApplicationContextInitializers()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@since 4.2</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">    protected ApplicationContextInitializer&lt;?&gt;[] getServletApplicationContextInitializers() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>指定<span class="code">`DispatcherServlet`</span>的servlet映射 - 例如"/", "/app"等</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@see #registerDispatcherServlet(ServletContext)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line">    protected <span class="keyword">abstract</span> <span class="built_in">String</span>[] getServletMappings();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>指定添加到<span class="code">`ServletContext`</span>，并映射到<span class="code">`DispatcherServlet`</span>的过滤器。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return </span>an<span class="markdown"> array of filters or &#123;@code null&#125;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@see #registerServletFilter(ServletContext, Filter)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">98</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">99</span></pre></td><td class="code"><pre><span class="line">    protected Filter[] getServletFilters() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">100</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">101</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">102</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">103</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>将给定的过滤器添加到<span class="code">`ServletContext`</span>并将其映射到<span class="code">`DispatcherServlet`</span>，如下所示：</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">104</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">105</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>1. 根据具体的类型选择默认的过滤器名称;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">106</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>2. 异步支持是根据<span class="code">`asyncSupported`</span>的返回值设置的;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">107</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>3. 使用<span class="code">`dispatcher`</span>类型为REQUEST，FORWARD，INCLUDE和ASYNC(取决于asyncSupported的返回值)创建过滤器映射</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">108</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">109</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">110</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>如果上面的默认值不合适，重写这个方法并直接用<span class="code">`ServletContext`</span>注册过滤器。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">111</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">112</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param servletContext </span>the<span class="markdown"> servlet context to register filters with</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">113</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param filter         </span>the<span class="markdown"> filter to be registered</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">114</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return </span>the<span class="markdown"> filter registration</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">115</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">116</span></pre></td><td class="code"><pre><span class="line">    protected FilterRegistration.Dynamic registerServletFilter(ServletContext servletContext, Filter filter) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">117</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 获取要注册的filter的名称</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">118</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">String</span> filterName = Conventions.getVariableName(filter);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">119</span></pre></td><td class="code"><pre><span class="line">        Dynamic registration = servletContext.addFilter(filterName, filter);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">120</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (registration == <span class="keyword">null</span>) &#123;<span class="comment">// 注册失败，名称追加序号并重试</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">121</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">int</span> counter = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">122</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> (counter == <span class="number">-1</span> || registration == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">123</span></pre></td><td class="code"><pre><span class="line">                counter++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">124</span></pre></td><td class="code"><pre><span class="line">                registration = servletContext.addFilter(filterName + <span class="string">"#"</span> + counter, filter);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">125</span></pre></td><td class="code"><pre><span class="line">                Assert.isTrue(counter &lt; <span class="number">100</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">126</span></pre></td><td class="code"><pre><span class="line">                        <span class="string">"Failed to register filter '"</span> + filter + <span class="string">"'."</span> +</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">127</span></pre></td><td class="code"><pre><span class="line">                                <span class="string">"Could the same Filter instance have been registered already?"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">128</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">129</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">130</span></pre></td><td class="code"><pre><span class="line">        registration.setAsyncSupported(isAsyncSupported());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">131</span></pre></td><td class="code"><pre><span class="line">        registration.addMappingForServletNames(getDispatcherTypes(), <span class="keyword">false</span>, getServletName());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">132</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> registration;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">133</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">134</span></pre></td><td class="code"><pre><span class="line">    private EnumSet&lt;DispatcherType&gt; getDispatcherTypes() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">135</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> (isAsyncSupported() ?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">136</span></pre></td><td class="code"><pre><span class="line">                EnumSet.of(DispatcherType.REQUEST, DispatcherType.FORWARD, DispatcherType.INCLUDE, DispatcherType.ASYNC) :</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">137</span></pre></td><td class="code"><pre><span class="line">                EnumSet.of(DispatcherType.REQUEST, DispatcherType.FORWARD, DispatcherType.INCLUDE));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">138</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">139</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">140</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="code">`DispatcherServlet`</span>和通过<span class="code">`getServletFilters()`</span>添加的所有过滤器的异步支持标记位</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">141</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">142</span></pre></td><td class="code"><pre><span class="line">    protected boolean isAsyncSupported() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">143</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">144</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">145</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">146</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Optionally perform further registration customization once</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">147</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>&#123;@link #registerDispatcherServlet(ServletContext)&#125; has completed.</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">148</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">149</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param registration </span>the<span class="markdown"> &#123;@code DispatcherServlet&#125; registration to be customized</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">150</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@see #registerDispatcherServlet(ServletContext)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">151</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">152</span></pre></td><td class="code"><pre><span class="line">    protected <span class="keyword">void</span> customizeRegistration(ServletRegistration.Dynamic registration) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">153</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">154</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>💡 补充：<code>registration.addMappingForServletNames</code><br>为当前<code>FilterRegistration</code>所代表的<code>Filter</code>添加一个具有指定Servlet名称和dispatcher类型的过滤器映射。过滤器映射按照添加的顺序进行匹配。根据<code>isMatchAfter</code>参数的值，来确定给定的过滤器映射在<code>ServletContext</code>(从中获取当前<code>FilterRegistration</code>)的任何声明的过滤器映射之前或之后匹配。<br>如果这个方法被多次调用，每个连续的调用都会作用于前者。<br><strong>Parameters:</strong><br><code>dispatcherTypes</code> - 过滤器映射的<code>dispatcher</code>类型，如果要使用默认的<code>DispatcherType.REQUEST</code>，则为null<br><code>isMatchAfter</code>- 如果给定的过滤器映射在任何声明的过滤器映射之后匹配，则为true;如果在从中获取此<code>FilterRegistration</code>的<code>ServletContext</code>的任何声明的过滤器映射之前匹配，则为false<br><em>servletNames</em> - 过滤器映射的Servlet名称</p>
</blockquote>
<h2 id="AbstractContextLoaderInitializer"><a href="#AbstractContextLoaderInitializer" class="headerlink" title="AbstractContextLoaderInitializer"></a>AbstractContextLoaderInitializer</h2><p><code>WebApplicationInitializer</code>实现类的基类，在<code>ServletContext</code>中注册<code>ContextLoaderListener</code>。需要由子类实现的唯一方法是<code>createRootApplicationContext()</code>，它在<code>registerContextLoaderListener(ServletContext)</code>中被调用。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractContextLoaderInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** Logger available to subclasses *</span>/</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    protected <span class="keyword">final</span> Log logger = LogFactory.getLog(getClass());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    public <span class="keyword">void</span> onStartup(ServletContext servletContext) throws ServletException &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        registerContextLoaderListener(servletContext);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>针对给定的<span class="code">`ServletContext`</span>注册一个<span class="code">`ContextLoaderListener`</span>。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="code">`ContextLoaderListener`</span>使用从<span class="code">`createRootApplicationContext()`</span>方法返回的根应用上下文进行初始化。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param servletContext </span>the<span class="markdown"> servlet context to register </span>the<span class="markdown"> listener against</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    protected <span class="keyword">void</span> registerContextLoaderListener(ServletContext servletContext) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        WebApplicationContext rootAppContext = createRootApplicationContext();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (rootAppContext != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            ContextLoaderListener listener = <span class="keyword">new</span> ContextLoaderListener(rootAppContext);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            listener.setContextInitializers(getRootApplicationContextInitializers());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            servletContext.addListener(listener);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            logger.debug(<span class="string">"No ContextLoaderListener registered, as "</span> +</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                    <span class="string">"createRootApplicationContext() did not return an application context"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Create </span>the<span class="markdown"> "<span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span></span>root<span class="xml"><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span>" application context to be provided to </span>the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>&#123;@code ContextLoaderListener&#125;.</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>The returned context is delegated to</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>&#123;@link ContextLoaderListener#ContextLoaderListener(WebApplicationContext)&#125; and </span>will</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>be established as </span>the<span class="markdown"> parent context for any &#123;@code DispatcherServlet&#125; application</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>contexts. As </span>such<span class="markdown">, it typically contains middle-tier services, data sources, etc.</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return </span>the<span class="markdown"> root application context, or &#123;@code null&#125; if </span>a<span class="markdown"> root context is not</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>desired</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@see org.springframework.web.servlet.support.AbstractDispatcherServletInitializer</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    protected <span class="keyword">abstract</span> WebApplicationContext createRootApplicationContext();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Specify application context initializers to be applied to </span>the<span class="markdown"> root application</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>context that </span>the<span class="markdown"> &#123;@code ContextLoaderListener&#125; is being created with.</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@since 4.2</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@see #createRootApplicationContext()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@see ContextLoaderListener#setContextInitializers</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    protected ApplicationContextInitializer&lt;?&gt;[] getRootApplicationContextInitializers() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<hr>
<p>上面说了这么多，简单总结下。<br>如图所示：<br><img src="http://image.winrains.cn/2019/10/20191022121035-34016.jpeg" alt="http://image.winrains.cn/2019/10/20191022121035-34016.jpeg"></p>
<hr>
<h2 id="ContextLoaderListener"><a href="#ContextLoaderListener" class="headerlink" title="ContextLoaderListener"></a>ContextLoaderListener</h2><p>上面提到了<code>ContextLoaderListener</code>，下面来说下这个类的作用。</p>
<h3 id="ServletContextListener"><a href="#ServletContextListener" class="headerlink" title="ServletContextListener"></a>ServletContextListener</h3><p>首先看下<code>javax.servlet.ServletContextListener</code><br><code>ServletContextListener</code>为一个接口，声明如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>ServletContextListener extends EventListener &#123;</span></pre></td></tr></table></figure>

<p><code>ServletContextListener</code>接口用于接收有关<code>javax.servlet.ServletContext</code>生命周期改变的通知事件。<br>为了接收这些通知事件，其实现类有如下三种方式声明：</p>
<ul>
<li>Web应用程序的部署描述符<code>(deployment descriptor of the web application，web.xml)</code>中声明<listener></li>
<li>使用<code>javax.servlet.annotation.WebListener</code>进行注释</li>
<li>通过<code>javax.servlet.ServletContext</code>上定义的<code>javax.servlet.ServletContext.addListener</code>方法注册</li>
</ul>
<p>这个接口实现类的<code>contextInitialized</code>方法按照它们的声明顺序被调用， 而<code>contextDestroyed</code>方法则以相反的顺序被调用。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.EventListener;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>用于接收有关&#123;@link javax.servlet.ServletContext&#125;生命周期改变的通知事件的接口。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>为了接收这些通知事件，实现类必须</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>在Web应用程序的部署描述符(deployment descriptor of </span>the<span class="markdown"> web application)中声明、</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>使用&#123;@link javax.servlet.annotation.WebListener&#125;进行注释，</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>或者通过&#123;@link javax.servlet.ServletContext&#125;上定义的&#123;@link javax.servlet.ServletContext#addListener&#125;方法注册。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>这个接口实现类的&#123;@link #contextInitialized&#125;方法按照它们的声明顺序被调用，</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>而&#123;@link #contextDestroyed&#125;方法则以相反的顺序被调用。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> *</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@see ServletContextEvent</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@since Servlet 2.3</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"> */</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">interface</span> <span class="title">ServletContextListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>接收Web应用程序初始化过程正在启动的通知。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>在Web应用程序中的任何一个filter或servlet被初始化之前，所有ServletContextListeners都会收到上下文初始化的通知。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param sce 包含正在初始化的ServletContext的ServletContextEvent</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    public <span class="keyword">void</span> contextInitialized(ServletContextEvent sce);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>接收ServletContext即将关闭的通知。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>在任何ServletContextListeners收到上下文销毁通知之前，所有servlet和filter都将被销毁。</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param sce 包含正在被销毁的ServletContext的ServletContextEvent</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    public <span class="keyword">void</span> contextDestroyed(ServletContextEvent sce);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="ContextLoaderListener-1"><a href="#ContextLoaderListener-1" class="headerlink" title="ContextLoaderListener"></a>ContextLoaderListener</h3><p>然后再看下<code>ContextLoaderListener</code><br>声明如下：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ContextLoaderListener</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">        <span class="symbol">extends</span> <span class="symbol">ContextLoader</span> <span class="symbol">implements</span> <span class="symbol">ServletContextListener</span> &#123;</span></pre></td></tr></table></figure>

<p>引导listener启动和关闭Spring的根<code>WebApplicationContext</code>。它只是<br>简单地委托给<code>ContextLoader</code>(继承)以及<code>ContextCleanupListener</code>(在<code>contextDestroyed</code>方法中调用)。<br>该listener应该在web.xml中的<code>org.springframework.web.util.Log4jConfigListener</code>(该类已标记过时)之后进行注册。<br>从Spring 3.1开始，<code>ContextLoaderListener</code>支持通过<code>ContextLoaderListener(WebApplicationContext)</code>构造函数注入根Web应用程序上下文， 从而允许在Servlet 3.0+环境中进行编程式配置。<br><strong>ContextLoaderListener()</strong><br>创建一个新的<code>ContextLoaderListener</code>， 它将基于”<code>contextClass</code>“和”<code>contextConfigLocation</code>“ Servlet 参数创建一个Web应用程序上下文。<br>当在web.xml中声明<code>ContextLoaderListener</code>为<listener>时，通常使用这个构造函数。<br>创建的应用程序上下文将被注册到<code>ServletContext</code>属性<code>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE下</code>， 并且当在此listener上调用<code>contextDestroyed</code>方法时，Spring应用程序上下文将被关闭。<br><strong>ContextLoaderListener(WebApplicationContext context)</strong><br>用给定的应用程序上下文创建一个新的ContextLoaderListener。 这个构造函数用于Servlet 3.0+，通过<code>javax.servlet.ServletContext.addListener</code> API可以实现基于实例的listeners注册。<br>上下文可能或尚未刷新。 如果</p>
<ul>
<li>(a)是<code>ConfigurableWebApplicationContext</code>的实现.</li>
<li>(b)尚未刷新（推荐的方法）</li>
</ul>
<p>满足上面两个条件，则会发生以下情况：</p>
<ul>
<li>如果给定的上下文还没有被分配一个id，则将被分配一个</li>
<li><code>ServletContext</code>和<code>ServletConfig</code>对象将被委托给应用程序上下文</li>
<li><code>customizeContext</code>将被调用</li>
<li>任何通过”<code>contextInitializerClasses</code>“ <code>init-param</code>指定的<code>ApplicationContextInitializers</code>将被应用。</li>
<li><code>refresh()</code>将被调用</li>
</ul>
<p>如果上下文已经被刷新或者没有实现<code>ConfigurableWebApplicationContext</code>，上述任何一种情况都不会发生。<br>创建的应用程序上下文将被注册到<code>ServletContext</code>属性<code>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>下， 并且当在此listener上调用<code>contextDestroyed</code>方法时，Spring应用程序上下文将被关闭。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">import org.springframework.web.context.ConfigurableWebApplicationContext;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">import org.springframework.web.context.ContextCleanupListener;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">import org.springframework.web.context.ContextLoader;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">import org.springframework.web.context.WebApplicationContext;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">import javax.servlet.ServletContextEvent;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">import javax.servlet.ServletContextListener;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">/<span class="symbol">*</span><span class="symbol">*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"> <span class="symbol">*</span> 引导listener启动和关闭Spring的根&#123;<span class="meta">@link</span> WebApplicationContext&#125;。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"> <span class="symbol">*</span> 简单地委托给&#123;<span class="meta">@link</span> ContextLoader&#125;以及&#123;<span class="meta">@link</span> ContextCleanupListener&#125;。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"> <span class="symbol">*</span> <span class="variable">&lt;p&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"> <span class="symbol">*</span> 该listener应该在&#123;<span class="meta">@code</span> web.xml&#125;中的&#123;<span class="meta">@link</span> org.springframework.web.util.Log4jConfigListener&#125;之后进行注册，如果使用它的话。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"> <span class="symbol">*</span> <span class="variable">&lt;p&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"> <span class="symbol">*</span> 从Spring 3.1开始，&#123;<span class="meta">@code</span> ContextLoaderListener&#125;支持通过&#123;<span class="meta">@link</span> ContextLoaderListener<span class="comment">#ContextLoaderListener(WebApplicationContext)&#125;构造函数注入根Web应用程序上下文，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"> <span class="symbol">*</span> 从而允许在Servlet 3.0+环境中进行编程式配置。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"> <span class="symbol">*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"> <span class="symbol">*</span> <span class="meta">@author</span> Juergen Hoeller</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"> <span class="symbol">*</span> <span class="meta">@author</span> Chris Beams</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"> <span class="symbol">*</span> <span class="meta">@see</span> <span class="comment">#setContextInitializers</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"> <span class="symbol">*</span> <span class="meta">@see</span> org.springframework.web.WebApplicationInitializer</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"> <span class="symbol">*</span> <span class="meta">@see</span> org.springframework.web.util.Log4jConfigListener</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"> <span class="symbol">*</span> <span class="meta">@since</span> 17.02.2003</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"> <span class="symbol">*</span>/</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">public class ContextLoaderListener extends ContextLoader implements ServletContextListener &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    /<span class="symbol">*</span><span class="symbol">*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> 创建一个新的&#123;<span class="meta">@code</span> ContextLoaderListener&#125;，</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> 它将基于<span class="string">"contextClass"</span>和<span class="string">"contextConfigLocation"</span> Servlet &#123;<span class="meta">@code</span> <span class="variable">&lt;context-params&gt;</span>&#125;参数创建一个Web应用程序上下文。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> 请参阅&#123;<span class="meta">@link</span> ContextLoader&#125;父类文档以获取详细信息。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> <span class="variable">&lt;p&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> 当在&#123;<span class="meta">@code</span> web.xml&#125;中声明&#123;<span class="meta">@code</span> ContextLoaderListener&#125;为&#123;<span class="meta">@code</span> <span class="variable">&lt;listener&gt;</span>&#125;时，通常使用这个构造函数。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> <span class="variable">&lt;p&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> 创建的应用程序上下文将被注册到ServletContext属性&#123;<span class="meta">@link</span> WebApplicationContext<span class="comment">#ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE&#125;下，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> 并且当在此listener上调用&#123;<span class="meta">@link</span> <span class="comment">#contextDestroyed&#125;方法时，Spring应用程序上下文将被关闭。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> <span class="meta">@see</span> ContextLoader</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> <span class="meta">@see</span> <span class="comment">#ContextLoaderListener(WebApplicationContext)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> <span class="meta">@see</span> <span class="comment">#contextInitialized(ServletContextEvent)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> <span class="meta">@see</span> <span class="comment">#contextDestroyed(ServletContextEvent)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span>/</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    public ContextLoaderListener() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    /<span class="symbol">*</span><span class="symbol">*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> 用<span class="variable">&lt;strong&gt;</span>给定的应用程序上下文<span class="variable">&lt;/strong&gt;</span>创建一个新的&#123;<span class="meta">@code</span> ContextLoaderListener&#125;。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> 这个构造函数用于Servlet 3.0+，通过&#123;<span class="meta">@link</span> javax.servlet.ServletContext<span class="comment">#addListener&#125; API可以实现基于实例的listeners注册。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> <span class="variable">&lt;p&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> 上下文可能或尚未&#123;<span class="meta">@linkplain</span> org.springframework.context.ConfigurableApplicationContext<span class="comment">#refresh() 刷新&#125;。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> 如果(a)是&#123;<span class="meta">@link</span> ConfigurableWebApplicationContext&#125;的实现，并且(b)<span class="variable">&lt;strong&gt;</span>尚未刷新<span class="variable">&lt;/strong&gt;</span>（推荐的方法），则会发生以下情况：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> <span class="variable">&lt;ul&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> <span class="variable">&lt;li&gt;</span>如果给定的上下文还没有被分配一个&#123;<span class="meta">@linkplain</span> org.springframework.context.ConfigurableApplicationContext<span class="comment">#setId id&#125;，则将被分配一个</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> <span class="variable">&lt;li&gt;</span>&#123;<span class="meta">@code</span> ServletContext&#125;和&#123;<span class="meta">@code</span> ServletConfig&#125;对象将被委托给应用程序上下文</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> <span class="variable">&lt;li&gt;</span>&#123;<span class="meta">@link</span> <span class="comment">#customizeContext&#125;将被调用</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> <span class="variable">&lt;li&gt;</span>任何通过<span class="string">"contextInitializerClasses"</span> init-param指定的&#123;<span class="meta">@link</span> org.springframework.context.ApplicationContextInitializer ApplicationContextInitializer&#125;s将被应用。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> <span class="variable">&lt;li&gt;</span>&#123;<span class="meta">@link</span> org.springframework.context.ConfigurableApplicationContext<span class="comment">#refresh refresh()&#125;将被调用</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> <span class="variable">&lt;/ul&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> <span class="variable">&lt;p&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> 如果上下文已经被刷新或者没有实现&#123;<span class="meta">@code</span> ConfigurableWebApplicationContext&#125;，上述任何一种情况都不会发生。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> <span class="variable">&lt;p&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> 创建的应用程序上下文将被注册到ServletContext属性&#123;<span class="meta">@link</span> WebApplicationContext<span class="comment">#ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE&#125;下，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> 并且当在此listener上调用&#123;<span class="meta">@link</span> <span class="comment">#contextDestroyed&#125;方法时，Spring应用程序上下文将被关闭。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> <span class="meta">@param</span> context the application context to manage</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> <span class="meta">@see</span> <span class="comment">#contextInitialized(ServletContextEvent)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> <span class="meta">@see</span> <span class="comment">#contextDestroyed(ServletContextEvent)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span>/</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">    public ContextLoaderListener(WebApplicationContext context) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">        super(context);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">    /<span class="symbol">*</span><span class="symbol">*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> Initialize the root web application context.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span>/</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">    public void contextInitialized(ServletContextEvent event) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">        initWebApplicationContext(event.getServletContext());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">    /<span class="symbol">*</span><span class="symbol">*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span> Close the root web application context.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">     <span class="symbol">*</span>/</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">    public void contextDestroyed(ServletContextEvent event) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">        closeWebApplicationContext(event.getServletContext());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">        ContextCleanupListener.cleanupAttributes(event.getServletContext());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="ContextLoader"><a href="#ContextLoader" class="headerlink" title="ContextLoader"></a>ContextLoader</h3><p>声明如下：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ContextLoader</span> &#123;</span></pre></td></tr></table></figure>

<p>为给定的servlet上下文初始化Spring的Web应用程序上下文，<br>使用构造时提供的应用程序上下文， 或者根据”<code>contextClass</code>“ 和”<code>contextConfigLocation</code>“ 创建一个新的。<br><strong>方式1 通过web.xml配置</strong><br>在web.xml 中查找”<code>contextClass</code>“参数以指定上下文类型， 如果未找到则使用<code>org.springframework.web.context.support.XmlWebApplicationContext</code>。<br>默认，指定的任何上下文类都需要实现<code>ConfigurableWebApplicationContext</code>接口。<br>处理web.xml 中的”<code>contextConfigLocation</code>“参数， 并将其值传递给上下文实例，其可能为多个配置文件路径（用逗号和空格分隔）。例如，”<code>WEB-INF/applicationContext1.xml</code>, <code>WEB-INF/applicationContext2.xml</code>“。 还支持Ant样式的路径模式，例如，”<code>WEB-INF/Context.xml</code>,<code>WEB-INF/spring.xml</code>“ 或者 “<code>WEB-INF/*/Context.xml</code>“。 如果没有明确指定，上下文实现应该使用默认位置（对于<code>XmlWebApplicationContext</code>，”<code>/WEB-INF/applicationContext.xml</code>“）。<br>注意：在多个配置文件的情况下，后面的bean定义将覆盖之前加载的文件中的定义，至少在使用Spring的默认<code>ApplicationContext</code>实现时是这样。 这可以用来通过一个额外的XML文件重写某些bean定义。<br><strong>方式2 通过Java Config配置</strong><br>从Spring 3.1开始，<code>ContextLoader</code>支持通过<code>ContextLoader(WebApplicationContext)</code>构造函数注入根Web应用程序上下文， 从而允许在Servlet 3.0+环境中进行编程式配置。 有关使用示例，请参阅<code>org.springframework.web.WebApplicationInitializer</code>。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>介绍了这么多类，这里做一个简短的总结。<br>Servlet3.0+规范后，允许Servlet，Filter，Listener不必声明在web.xml中，而是以Java Config的方式编码存在，实现容器的零配置。<br><code>ServletContainerInitializer</code>启动容器时负责加载相关配置。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">package javax.servlet;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">import java.util.Set;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>ServletContainerInitializer &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    void onStartup(Set&lt;Class&lt;?&gt;&gt; var1, ServletContext var2) throws ServletException;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Servlet容器启动时会自动扫描当前服务中<code>ServletContainerInitializer</code>的实现类。并调用其<code>onStartup</code>方法，其参数<code>Set&gt; c</code>可通过在实现类上声明注解<code>javax.servlet.annotation.HandlesTypes(xxx.class)</code>注解自动注入。<br><code>@HandlesTypes</code>会自动扫描项目中所有的xxx.class的实现类，并将其全部注入Set。<br>Spring为其提供了一个实现类：<code>SpringServletContainerInitializer</code>类。通过查看源码可以看出，<code>WebApplicationInitializer</code>才是我们需要关心的接口。<br>我们只需要将相应的Servlet，Filter，Listener等硬编码到该接口的实现类中即可。<br>Spring为我们提供了一些<code>WebApplicationInitializer</code>的抽象类，我们只需要继承并按需修改即可。常见的实现类有：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">AbstractAnnotationConfigDispatcherServletInitializer</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">AbstractDispatcherServletInitializer</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">AbstractContextLoaderInitializer</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">AbstractHttpSessionApplicationInitializer</span></span></pre></td></tr></table></figure>

<p>对于一个web应用，其部署在web容器中，web容器提供其一个全局的上下文环境，这个上下文就是<code>ServletContext</code>，其为后面的Spring IoC容器提供宿主环境；<br>其次，在web.xml中会提供有<code>ContextLoaderListener</code>。<br>在web容器启动时，会触发容器初始化事件，此时<code>ContextLoaderListener</code>会监听到这个事件，其<code>contextInitialized</code>方法会被调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.context;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">(WebApplicationContext context)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">super</span>(context);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.initWebApplicationContext(event.getServletContext());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.closeWebApplicationContext(event.getServletContext());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        ContextCleanupListener.cleanupAttributes(event.getServletContext());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在<code>contextInitialized</code>这个方法中，spring会初始化一个启动上下文，这个上下文被称为根上下文，即<code>WebApplicationContext</code>，这是一个接口类。<br>确切的说，其实现类是<code>XmlWebApplicationContext</code>(基于web.xml配置)或者上面提及的<code>AnnotationConfigWebApplicationContext</code>(基于JavaConfig配置)。<br>这个就是Spring IoC容器，其对应的自定义的配置由web.xml中的``标签指定。<br>在这个IoC容器初始化完毕后，TODO Spring以<code>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>为属性Key，将其存储到<code>ServletContext</code>中，便于获取。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebApplicationContext</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">ApplicationContext</span></span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">String</span> ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE = WebApplicationContext.class.getName() + <span class="string">".ROOT"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoader</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 以`WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE`为属性Key，将根上下文存储到ServletContext中</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="built_in">this</span>.context);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>再次，<code>ContextLoaderListener</code>监听器初始化完毕后，开始初始化web.xml中配置的Servlet，这个servlet可以配置多个，以最常见的<code>DispatcherServlet</code>为例，<br>这个servlet实际上是一个标准的前端控制器，用以转发、匹配、处理每个servlet请求。<br><code>DispatcherServlet</code>上下文在初始化的时候会建立自己的IoC上下文，用以持有spring mvc相关的bean。<br>在建立<code>DispatcherServlet</code>自己的IoC上下文时，TODO 会利用<code>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>先从<code>ServletContext</code>中获取之前的根上下文(即<code>WebApplicationContext</code>)作为自己上下文的parent上下文。<br>有了这个parent上下文之后，再初始化自己持有的上下文。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameworkServlet</span> <span class="keyword">extends</span> <span class="title">HttpServletBean</span> <span class="title">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    public static <span class="keyword">final</span> <span class="type">String</span> <span class="type">SERVLET_CONTEXT_PREFIX</span> = <span class="type">FrameworkServlet</span><span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(<span class="params"></span>) <span class="title">+</span> ".<span class="title">CONTEXT</span>."</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">protected</span> <span class="type">WebApplicationContext</span> initWebApplicationContext() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (cwac.getParent() == <span class="literal">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// the root application context (if any; may be null) as the parent</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            cwac.setParent(rootContext);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个<code>DispatcherServlet</code>初始化自己上下文的工作在其<code>initStrategies</code>方法中可以看到，大概的工作就是初始化处理器映射、视图解析等。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">FrameworkServlet</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">protected</span> void initStrategies(<span class="type">ApplicationContext</span> context) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.initMultipartResolver(context);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.initLocaleResolver(context);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.initThemeResolver(context);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.initHandlerMappings(context);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.initHandlerAdapters(context);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.initHandlerExceptionResolvers(context);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.initRequestToViewNameTranslator(context);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.initViewResolvers(context);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.initFlashMapManager(context);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个servlet自己持有的上下文默认实现类也是<code>XmlWebApplicationContext</code>，当然也可以基于JavaConfig方式配置<code>AnnotationConfigWebApplicationContext</code>。<br>初始化完毕后，TODO spring以与servlet的名字相关(此处不是简单的以servlet名为Key，而是通过一些转换)的属性为属性Key，也将其存到<code>ServletContext</code>中，以便后续使用。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameworkServlet</span> <span class="keyword">extends</span> <span class="title">HttpServletBean</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    public <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span> SERVLET_CONTEXT_PREFIX = FrameworkServlet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>() + ".<span class="title">CONTEXT</span>.";</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="class">    <span class="title">protected</span> <span class="title">WebApplicationContext</span> <span class="title">initWebApplicationContext</span>() </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Publish the context as a servlet context attribute.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">String</span> attrName = getServletContextAttributeName();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            getServletContext().setAttribute(attrName, wac);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Return </span>the<span class="markdown"> ServletContext attribute name for this servlet's WebApplicationContext.</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>The default implementation returns</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>&#123;@code SERVLET<span class="emphasis">_CONTEXT_</span>PREFIX + servlet name&#125;.</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@see #SERVLET<span class="emphasis">_CONTEXT_</span>PREFIX</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@see #getServletName</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    public <span class="built_in">String</span> getServletContextAttributeName() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> SERVLET_CONTEXT_PREFIX + getServletName();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这样每个servlet就持有自己的上下文，即拥有自己独立的bean空间，同时各个servlet共享相同的bean，即根上下文定义的那些bean。</p>
<blockquote>
<p>作者：南桥畂翊</p>
<p>来源：<a href="https://www.jianshu.com/p/57677a2c6ebd" target="_blank" rel="noopener">https://www.jianshu.com/p/57677a2c6ebd</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/08/%E7%A1%AC%E7%9B%98%E7%9A%84%E8%AF%BB%E5%86%99%E5%8E%9F%E7%90%86/" rel="prev" title="硬盘的读写原理">
      <i class="fa fa-chevron-left"></i> 硬盘的读写原理
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/08/Java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%BB%8B%E7%BB%8D/" rel="next" title="Java 字符串常量池介绍">
      Java 字符串常量池介绍 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#ServletContainerInitializer"><span class="nav-number">1.</span> <span class="nav-text">ServletContainerInitializer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringServletContainerInitializer"><span class="nav-number">2.</span> <span class="nav-text">SpringServletContainerInitializer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、运作机制"><span class="nav-number">2.1.</span> <span class="nav-text">一、运作机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、与web-xml结合使用"><span class="nav-number">2.2.</span> <span class="nav-text">二、与web.xml结合使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、与Spring的WebApplicationInitializer的关系"><span class="nav-number">2.3.</span> <span class="nav-text">三、与Spring的WebApplicationInitializer的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、注意事项"><span class="nav-number">2.4.</span> <span class="nav-text">四、注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WebApplicationInitializer"><span class="nav-number">3.</span> <span class="nav-text">WebApplicationInitializer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Example"><span class="nav-number">3.1.</span> <span class="nav-text">Example</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AbstractAnnotationConfigDispatcherServletInitializer"><span class="nav-number">4.</span> <span class="nav-text">AbstractAnnotationConfigDispatcherServletInitializer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AbstractDispatcherServletInitializer"><span class="nav-number">5.</span> <span class="nav-text">AbstractDispatcherServletInitializer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AbstractContextLoaderInitializer"><span class="nav-number">6.</span> <span class="nav-text">AbstractContextLoaderInitializer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ContextLoaderListener"><span class="nav-number">7.</span> <span class="nav-text">ContextLoaderListener</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ServletContextListener"><span class="nav-number">7.1.</span> <span class="nav-text">ServletContextListener</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ContextLoaderListener-1"><span class="nav-number">7.2.</span> <span class="nav-text">ContextLoaderListener</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ContextLoader"><span class="nav-number">7.3.</span> <span class="nav-text">ContextLoader</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">8.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">congsheng.wang</p>
  <div class="site-description" itemprop="description">trouble is a friend</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">984</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">94</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">156</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">congsheng.wang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
