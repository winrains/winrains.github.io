<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://congsheng.wang').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="接着上文《JVM源码分析之新生代DefNewGeneration的实现》，本文对老年代TenuredGeneration的垃圾回收算法进行分析。">
<meta name="keywords" content="源码">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM源码分析（12）：老年代TenuredGeneration的垃圾回收算法实现">
<meta property="og:url" content="http:&#x2F;&#x2F;congsheng.wang&#x2F;2020&#x2F;01&#x2F;08&#x2F;JVM%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%8812%EF%BC%89%EF%BC%9A%E8%80%81%E5%B9%B4%E4%BB%A3TenuredGeneration%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0&#x2F;index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="接着上文《JVM源码分析之新生代DefNewGeneration的实现》，本文对老年代TenuredGeneration的垃圾回收算法进行分析。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-01-08T03:47:11.000Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://congsheng.wang/2020/01/08/JVM%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%8812%EF%BC%89%EF%BC%9A%E8%80%81%E5%B9%B4%E4%BB%A3TenuredGeneration%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>JVM源码分析（12）：老年代TenuredGeneration的垃圾回收算法实现 | 个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">congsheng的博客</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">156</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">94</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">984</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://congsheng.wang/2020/01/08/JVM%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%8812%EF%BC%89%EF%BC%9A%E8%80%81%E5%B9%B4%E4%BB%A3TenuredGeneration%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="congsheng.wang">
      <meta itemprop="description" content="trouble is a friend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM源码分析（12）：老年代TenuredGeneration的垃圾回收算法实现
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-08 11:47:11" itemprop="dateCreated datePublished" datetime="2020-01-08T11:47:11+08:00">2020-01-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>接着上文<a href="https://www.jianshu.com/p/2b64294fa1bd" target="_blank" rel="noopener">《JVM源码分析之新生代DefNewGeneration的实现》</a>，本文对老年代<code>TenuredGeneration</code>的垃圾回收算法进行分析。</p>
<a id="more"></a>

<h2 id="TenuredGeneration"><a href="#TenuredGeneration" class="headerlink" title="TenuredGeneration"></a>TenuredGeneration</h2><p>老年代<code>TenuredGeneration</code>使用标记-压缩-清理算法进行垃圾回收，将标记对象移动到堆的另一端，同时更新对象的引用地址，算法的具体实现位于<code>TenuredGeneration::collect()</code>方法</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TenuredGeneration::collect(<span class="keyword">bool</span> full,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">                                <span class="keyword">bool</span> clear_all_soft_refs,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">                                <span class="keyword">size_t</span> <span class="built_in">size</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">                                <span class="keyword">bool</span> is_tlab) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    retire_alloc_buffers_before_full_gc();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    OneContigSpaceCardGeneration::collect(full, clear_all_soft_refs,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                                        <span class="built_in">size</span>, is_tlab);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>调用父类的<code>OneContigSpaceCardGeneration</code>的<code>collect()</code>方法，实现如下</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> OneContigSpaceCardGeneration::collect(<span class="keyword">bool</span> full,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">                                           <span class="keyword">bool</span> clear_all_soft_refs,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">                                           <span class="keyword">size_t</span> <span class="built_in">size</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">                                           <span class="keyword">bool</span> is_tlab) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    SpecializationStats::<span class="built_in">clear</span>();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Temporarily expand the span of our ref processor, so</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// refs discovery is over the entire heap, not just this generation</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    ReferenceProcessorSpanMutator</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">      x(ref_processor(), GenCollectedHeap::heap()-&gt;reserved_region());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    GenMarkSweep::invoke_at_safepoint(_level, ref_processor(), clear_all_soft_refs);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    SpecializationStats::<span class="built_in">print</span>();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其中<code>GenMarkSweep::invoke_at_safepoint()</code>是垃圾回收算法实现的核心，下面对<code>invoke_at_safepoint</code>方法进行分析。</p>
<h2 id="GC前准备"><a href="#GC前准备" class="headerlink" title="GC前准备"></a>GC前准备</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置引用处理器和引用的处理策略；</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">_ref_processor = rp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">rp</span>-&gt;</span>setup_policy(clear_all_softrefs);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置输出日志；</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">TraceTime t1(<span class="string">"Full GC"</span>, PrintGC &amp;&amp; !PrintGCDetails, <span class="literal">true</span>, gclog_or_tty);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// When collecting the permanent generation methodOops may be moving,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// so we either have to flush all bcp data or convert it into bci.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">CodeCache::gc_prologue();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">Threads::gc_prologue();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加永久代回收的统计次数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Increment the invocation count for the permanent generation, since it is</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// implicitly collected whenever we do a full mark sweep collection.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">gch</span>-&gt;</span><span class="function"><span class="title">perm_gen</span>()-&gt;</span><span class="function"><span class="title">stat_record</span>()-&gt;</span>invocations++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计GC前的内存堆已使用大小</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Capture heap size before collection for printing.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">size_t</span> gch_prev_used = gch-&gt;</span>used();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存当前内存代和更低的内存代、以及永久代的已使用区域</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Capture used regions for each generation that will be</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// subject to collection, so that card table adjustments can</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// be made intelligently (see clear / invalidate further below).</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">gch</span>-&gt;</span>save_used_regions(level, <span class="literal">true</span> <span class="comment">/* perm */</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化遍历栈，用来保存对象和对象头的对应关系</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">allocate_stacks();</span></pre></td></tr></table></figure>

<h2 id="执行GC"><a href="#执行GC" class="headerlink" title="执行GC"></a>执行GC</h2><p>GC使用标记-压缩-清理算法<code>MarkSweepCompact</code>，整个过程一共4阶段，分别对应4个方法的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mark live objects</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mark_sweep_phase1</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">bool</span> clear_all_softrefs)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calculate new addresses</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mark_sweep_phase2</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update pointers</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mark_sweep_phase3</span><span class="params">(<span class="keyword">int</span> level)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Move objects to new positions</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mark_sweep_phase4</span><span class="params">()</span></span>;</span></pre></td></tr></table></figure>

<h3 id="一、mark-sweep-phase1：-标记活跃对象"><a href="#一、mark-sweep-phase1：-标记活跃对象" class="headerlink" title="一、mark_sweep_phase1： 标记活跃对象"></a>一、mark_sweep_phase1： 标记活跃对象</h3><p>1、标记根对象，这部分实现和新生代类似，只是不扫描<code>Younger gens</code>的对象</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">follow_root_closure</span>.set_orig_generation(gch-&gt;</span>get_gen(level));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">gch</span>-&gt;</span>gen_process_strong_roots(level,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">                                <span class="literal">false</span>, <span class="comment">// Younger gens are not roots.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">                                <span class="literal">true</span>,  <span class="comment">// activate StrongRootsScope</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">                                <span class="literal">true</span>,  <span class="comment">// Collecting permanent generation.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                                SharedHeap::SO_SystemClasses,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                                &amp;follow_root_closure,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                                <span class="literal">true</span>,   <span class="comment">// walk code active on stacks</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                                &amp;follow_root_closure);</span></pre></td></tr></table></figure>

<p>其中<code>follow_root_closure</code>负责处理活跃对象，其工作函数如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">void MarkSweep::FollowRootClosure::<span class="keyword">do</span><span class="constructor">_oop(<span class="params">oop</span><span class="operator">*</span> <span class="params">p</span>)</span>       &#123; follow<span class="constructor">_root(<span class="params">p</span>)</span>; &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">void MarkSweep::FollowRootClosure::<span class="keyword">do</span><span class="constructor">_oop(<span class="params">narrowOop</span><span class="operator">*</span> <span class="params">p</span>)</span> &#123; follow<span class="constructor">_root(<span class="params">p</span>)</span>; &#125;</span></pre></td></tr></table></figure>

<p>工作函数接着调用<code>follow_root()</code>方法，完成活跃对象的标记工作，实现如下:</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">template &lt;<span class="keyword">class</span> T&gt; inline void MarkSweep::follow<span class="constructor">_root(T<span class="operator">*</span> <span class="params">p</span>)</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ... 省略一些代码</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  T heap_oop = oopDesc::load<span class="constructor">_heap_oop(<span class="params">p</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (!oopDesc::is<span class="constructor">_null(<span class="params">heap_oop</span>)</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    oop obj = oopDesc::decode<span class="constructor">_heap_oop_not_null(<span class="params">heap_oop</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!obj-&gt;mark<span class="literal">()</span>-&gt;is<span class="constructor">_marked()</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">      mark<span class="constructor">_object(<span class="params">obj</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">      obj-&gt;follow<span class="constructor">_contents()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  follow<span class="constructor">_stack()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如果对象还没有被标记，即<code>obj-&gt;mark()-&gt;is_marked()</code>返回<code>false</code>，通过调用<code>mark_object()</code>方法标记该对象，接着调用<code>follow_contents()</code>和<code>follow_stack()</code>方法处理该对象。<br>1） <code>mark_object()</code>实现对象的标记过程，如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">inline void MarkSweep::mark<span class="constructor">_object(<span class="params">oop</span> <span class="params">obj</span>)</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// some marks may contain information we need to preserve so we store them away</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// and overwrite the mark.  We'll restore it at the end of markSweep.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    markOop mark = obj-&gt;mark<span class="literal">()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    obj-&gt;set<span class="constructor">_mark(<span class="params">markOopDesc</span>::<span class="params">prototype</span>()</span>-&gt;set<span class="constructor">_marked()</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (mark-&gt;must<span class="constructor">_be_preserved(<span class="params">obj</span>)</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        preserve<span class="constructor">_mark(<span class="params">obj</span>, <span class="params">mark</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>设置对象的对象头为被标记状态，有些对象的对象头可能包含一些信息，需要在GC结束之后进行恢复，可以通过调用<code>preserve_mark()</code>方法保存对象和对应的对象头，实现如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">void MarkSweep::preserve<span class="constructor">_mark(<span class="params">oop</span> <span class="params">obj</span>, <span class="params">markOop</span> <span class="params">mark</span>)</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// We try to store preserved marks in the to space of the new generation since</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// this is storage which should be available.  Most of the time this should be</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// sufficient space for the marks we need to preserve but if it isn't we fall</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// back to using Stacks to keep track of the overflow.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (_preserved_count &lt; _preserved_count_max) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        _preserved_marks<span class="literal">[<span class="identifier">_preserved_count</span><span class="operator">++</span>]</span>.init(obj, mark);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">_preserved_mark_stack</span>.</span></span>push(mark);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">_preserved_oop_stack</span>.</span></span>push(obj);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>2）<code>follow_contents()</code>负责处理活跃对象的引用对象，实现如下：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">inline <span class="literal">void</span> oopDesc::follow_contents(<span class="literal">void</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    assert (is_gc_marked(), <span class="string">"should be marked"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    blueprint<span class="function"><span class="params">()</span>-&gt;</span>oop_follow_contents(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其中对象实例<code>instanceKlass</code>的<code>oop_follow_contents()</code>方法实现如下</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> instanceKlass<span class="type">::oop_follow_contents</span>(oop obj) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    assert(obj != <span class="built_in">NULL</span>, <span class="string">"can't follow the content of NULL object"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    obj-&gt;follow_header();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    InstanceKlass_OOP_MAP_ITERATE( \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        obj, \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        MarkSweep<span class="type">::mark_and_push</span>(p), \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        assert_is_in_closed_subset)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="literal">void</span> oopDesc<span class="type">::follow_header</span>() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (UseCompressedOops) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        MarkSweep<span class="type">::mark_and_push</span>(compressed_klass_addr());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        MarkSweep<span class="type">::mark_and_push</span>(klass_addr());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以发现，<code>oop_follow_contents</code>方法最终调用<code>MarkSweep::mark_and_push</code>方法处理引用对象，标记引用对象并插入到<code>_marking_stack</code>栈中</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">template &lt;<span class="keyword">class</span> T&gt; inline void MarkSweep::mark<span class="constructor">_and_push(T<span class="operator">*</span> <span class="params">p</span>)</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//  assert(Universe::heap()-&gt;is_in_reserved(p), "should be in object space");</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    T heap_oop = oopDesc::load<span class="constructor">_heap_oop(<span class="params">p</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!oopDesc::is<span class="constructor">_null(<span class="params">heap_oop</span>)</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        oop obj = oopDesc::decode<span class="constructor">_heap_oop_not_null(<span class="params">heap_oop</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!obj-&gt;mark<span class="literal">()</span>-&gt;is<span class="constructor">_marked()</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            mark<span class="constructor">_object(<span class="params">obj</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="module-access"><span class="module"><span class="identifier">_marking_stack</span>.</span></span>push(obj);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>3）<code>follow_stack()</code>负责处理<code>_marking_stack</code>栈中的对象，并调用对象的<code>follow_contents</code>方法处理其引用对象，直到栈中的对象为空，实现如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">void MarkSweep::follow<span class="constructor">_stack()</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">do</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> (!<span class="module-access"><span class="module"><span class="identifier">_marking_stack</span>.</span></span>is<span class="constructor">_empty()</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            oop obj = <span class="module-access"><span class="module"><span class="identifier">_marking_stack</span>.</span></span>pop<span class="literal">()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">assert</span> (obj-&gt;is<span class="constructor">_gc_marked()</span>, <span class="string">"p must be marked"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            obj-&gt;follow<span class="constructor">_contents()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// Process ObjArrays one at a time to avoid marking stack bloat.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!<span class="module-access"><span class="module"><span class="identifier">_objarray_stack</span>.</span></span>is<span class="constructor">_empty()</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            ObjArrayTask task = <span class="module-access"><span class="module"><span class="identifier">_objarray_stack</span>.</span></span>pop<span class="literal">()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            objArrayKlass* const k = (objArrayKlass*)task.obj<span class="literal">()</span>-&gt;blueprint<span class="literal">()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            k-&gt;oop<span class="constructor">_follow_contents(<span class="params">task</span>.<span class="params">obj</span>()</span>, task.index<span class="literal">()</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">while</span> (!<span class="module-access"><span class="module"><span class="identifier">_marking_stack</span>.</span></span>is<span class="constructor">_empty()</span><span class="operator"> || </span>!<span class="module-access"><span class="module"><span class="identifier">_objarray_stack</span>.</span></span>is<span class="constructor">_empty()</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>除了<code>_marking_stack</code>栈，还有一个<code>_objarray_stack</code>栈，用于处理数组对象，当数组非常大时，如果数组对象的引用全都放在标记栈中的话，就会出现爆栈的可能。<br>到此为止，所有的活跃对象都已经被标记。<br>2、处理在标记过程中发现的引用；</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Process reference objects found during marking</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="selector-tag">ref_processor</span>()<span class="selector-tag">-</span>&gt;<span class="selector-tag">setup_policy</span>(clear_all_softrefs);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="selector-tag">ref_processor</span>()<span class="selector-tag">-</span>&gt;<span class="selector-tag">process_discovered_references</span>(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      &amp;is_alive, &amp;keep_alive, &amp;follow_stack_closure, NULL);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>3、卸载不再使用的类，并清理<code>CodeCache</code>和标记栈；</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Follow system dictionary roots and unload classes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> purged_class = SystemDictionary::<span class="keyword">do</span><span class="constructor">_unloading(&amp;<span class="params">is_alive</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Follow code cache roots</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">CodeCache::<span class="keyword">do</span><span class="constructor">_unloading(&amp;<span class="params">is_alive</span>, &amp;<span class="params">keep_alive</span>, <span class="params">purged_class</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">follow<span class="constructor">_stack()</span>; <span class="comment">// Flush marking stack</span></span></pre></td></tr></table></figure>

<p>4、当有类卸载之后，需要更新存活类的子类、兄弟类、实现类的引用关系，清理未被标记的软引用和弱引用；</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">follow<span class="constructor">_weak_klass_links()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(<span class="module-access"><span class="module"><span class="identifier">_marking_stack</span>.</span></span>is<span class="constructor">_empty()</span>, <span class="string">"just drained"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Visit memoized MDO's and clear any unmarked weak refs</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">follow<span class="constructor">_mdo_weak_refs()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(<span class="module-access"><span class="module"><span class="identifier">_marking_stack</span>.</span></span>is<span class="constructor">_empty()</span>, <span class="string">"just drained"</span>);</span></pre></td></tr></table></figure>

<p>5、清理字符串常量池中没有被标记过的对象；</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Visit interned string tables and delete unmarked oops</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">StringTable::unlink(&amp;is_alive);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">void StringTable::unlink(BoolObjectClosure* is_alive) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Readers of the table are unlocked, so we should only be removing</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// entries at a safepoint.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(SafepointSynchronize::is<span class="constructor">_at_safepoint()</span>, <span class="string">"must be at safepoint"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; the<span class="constructor">_table()</span>-&gt;table<span class="constructor">_size()</span>; ++i) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    for (HashtableEntry&lt;oop&gt;** p = the<span class="constructor">_table()</span>-&gt;bucket<span class="constructor">_addr(<span class="params">i</span>)</span>; *p != NULL; ) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        HashtableEntry&lt;oop&gt;* entry = *p;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (entry-&gt;is<span class="constructor">_shared()</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            break;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">assert</span>(entry-&gt;literal<span class="literal">()</span> != NULL, <span class="string">"just checking"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (is_alive-&gt;<span class="keyword">do</span><span class="constructor">_object_b(<span class="params">entry</span>-&gt;<span class="params">literal</span>()</span>)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            p = entry-&gt;next<span class="constructor">_addr()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            *p = entry-&gt;next<span class="literal">()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            the<span class="constructor">_table()</span>-&gt;free<span class="constructor">_entry(<span class="params">entry</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>6、清理符号表中没有被引用的符号</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Clean up unreferenced symbols in symbol table.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">SymbolTable::unlink();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remove unreferenced symbols from the symbol table</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is done late during GC.  This doesn't use the hash table unlink because</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// it assumes that the literals are oops.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">void SymbolTable::unlink() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    int removed = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    int total = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    size_t memory_total = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="title">for</span> (int i = 0; i &lt; the_table()-&gt;</span>table_size(); ++i) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="title">for</span> (HashtableEntry&lt;Symbol*&gt;** p = the_table()-&gt;</span>bucket_addr(i); *p != NULL; ) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            HashtableEntry&lt;Symbol*&gt;* entry = *p;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="function"><span class="title">if</span> (entry-&gt;</span>is_shared()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                break;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            S<span class="function"><span class="title">ymbol</span>* s = entry-&gt;</span>literal();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            <span class="function"><span class="title">memory_total</span> += s-&gt;</span>object_size();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            total++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            assert(s != NULL, <span class="string">"just checking"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// If reference count is zero, remove.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            <span class="function"><span class="title">if</span> (s-&gt;</span>refcount() == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                delete s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                removed++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                *<span class="function"><span class="title">p</span> = entry-&gt;</span>next();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                <span class="function"><span class="title">the_table</span>()-&gt;</span>free_entry(entry);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                <span class="function"><span class="title">p</span> = entry-&gt;</span>next_addr();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    symbols_removed += removed;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    symbols_counted += total;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Exclude printing for normal PrintGCDetails because people parse</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// this output.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (PrintGCDetails &amp;&amp; Verbose &amp;&amp; WizardMode) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="title">gclog_or_tty</span>-&gt;</span>print(<span class="string">" [Symbols=%d size="</span> SIZE_FORMAT <span class="string">"K] "</span>, total,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">                        (memory_total*HeapWordSize)/<span class="number">1024</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="二、mark-sweep-phase2：-计算活跃对象在压缩完成之后的新地址"><a href="#二、mark-sweep-phase2：-计算活跃对象在压缩完成之后的新地址" class="headerlink" title="二、mark_sweep_phase2： 计算活跃对象在压缩完成之后的新地址"></a>二、mark_sweep_phase2： 计算活跃对象在压缩完成之后的新地址</h3><p>在第一步中，所有的活跃对象都已经被标记完成，接下来就是遍历所有的对象，把活跃对象移动到内存区域的一端，并重新计算新对象的地址，实现如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">void GenMarkSweep::mark<span class="constructor">_sweep_phase2()</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    GenCollectedHeap* gch = GenCollectedHeap::heap<span class="literal">()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    Generation* pg = gch-&gt;perm<span class="constructor">_gen()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">     <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="constructor">VALIDATE_MARK_SWEEP_ONLY(<span class="params">reset_live_oop_tracking</span>(<span class="params">false</span>)</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    gch-&gt;prepare<span class="constructor">_for_compaction()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="constructor">VALIDATE_MARK_SWEEP_ONLY(<span class="params">_live_oops_index_at_perm</span> = <span class="params">_live_oops_index</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    CompactPoint perm<span class="constructor">_cp(<span class="params">pg</span>, NULL, NULL)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    pg-&gt;prepare<span class="constructor">_for_compaction(&amp;<span class="params">perm_cp</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其中<code>prepare_for_compaction()</code>定义在<code>GenCollectedHeap</code>中，实现如下：</p>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">void GenCollectedHeap::prepare_for_compacti<span class="meta">on(</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    Generation<span class="comment">* scanning_gen = _gens[_n_gens-1];</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    // Start <span class="meta">by</span> compacting <span class="meta">into</span> same gen.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    CompactPoint cp(scanning_gen, <span class="meta">NULL</span>, <span class="meta">NULL</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">while</span> (scanning_gen != <span class="meta">NULL</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        scanning_gen-&gt;prepare_for_compacti<span class="meta">on(</span><span class="variable">&amp;cp</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        scanning_gen = prev_g<span class="meta">en(</span>scanning_gen);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>从<code>prepare_for_compaction</code>的方法名定义，可以看出这是进行压缩前的前期工作，在老年代中只有一个<code>ContiguousSpace</code>类型的内存区<code>_the_space</code>，它的<code>prepare_for_compaction()</code>方法实现如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Faster object search.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">void ContiguousSpace::prepare<span class="constructor">_for_compaction(CompactPoint<span class="operator">*</span> <span class="params">cp</span>)</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="constructor">SCAN_AND_FORWARD(<span class="params">cp</span>, <span class="params">top</span>, <span class="params">block_is_always_obj</span>, <span class="params">obj_size</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其中<code>SCAN_AND_FORWARD</code>函数的实现位于<code>space.hpp</code>文件中，为活跃对象计算新地址并保存在对象头，分析过程如下：<br>1、<code>compact_top</code>指针指向压缩目标的内存空间起始地址，在开始之前，指向当前内存区域的起始地址；</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">HeapWord* compact_top; /* This <span class="keyword">is</span> <span class="keyword">where</span> we are currently compacting <span class="keyword">to</span>. */</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">/* We're sure <span class="keyword">to</span> be here <span class="keyword">before</span> any objects are compacted <span class="keyword">into</span> this</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"> * <span class="literal">space</span>, so this <span class="keyword">is</span> a good <span class="built_in">time</span> <span class="keyword">to</span> initialize this:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"> */</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">set_compaction_top(bottom());</span></pre></td></tr></table></figure>

<p>2、初始化<code>CompactPoint</code>，并设置当前要执行压缩的区域的指针<code>compact_top</code>，如果<code>CompactPoint</code>所对应的区域<code>space</code>为空，则初始化<code>CompactPoint</code>的<code>space</code>为内存代的第一块区域，设置<code>compact_top</code>为区域的起始地址；否则设置<code>compact_top</code>为<code>CompactPoint</code>中保存的值，继续该区域的压缩工作；</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span> (cp-&gt;</span>space == NULL) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="title">assert</span>(cp-&gt;</span>gen != NULL, <span class="string">"need a generation"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="title">assert</span>(cp-&gt;</span>threshold == NULL, <span class="string">"just checking"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="title">assert</span>(cp-&gt;</span><span class="function"><span class="title">gen</span>-&gt;</span>first_compaction_space() == this, <span class="string">"just checking"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="title">cp</span>-&gt;</span><span class="function"><span class="title">space</span> = cp-&gt;</span><span class="function"><span class="title">gen</span>-&gt;</span>first_compaction_space();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="title">compact_top</span> = cp-&gt;</span><span class="function"><span class="title">space</span>-&gt;</span>bottom();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="title">cp</span>-&gt;</span><span class="function"><span class="title">space</span>-&gt;</span>set_compaction_top(compact_top);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="title">cp</span>-&gt;</span><span class="function"><span class="title">threshold</span> = cp-&gt;</span><span class="function"><span class="title">space</span>-&gt;</span>initialize_threshold();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="title">compact_top</span> = cp-&gt;</span><span class="function"><span class="title">space</span>-&gt;</span>compaction_top();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>3、在没有明显的压缩效果之前，我们允许一些垃圾对象移动到内存区域的底部，即开始位置，每进行<code>MarkSweepAlwaysCompactCount</code>(默认4次)FGC时，再进行一次完全压缩，实现如下：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We allow some amount of garbage towards the bottom of the space, so</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * we don't start compacting before there is a significant gain to be made.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Occasionally, we want to ensure a full compaction, which is determined</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * by the MarkSweepAlwaysCompactCount parameter.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">int invocations = SharedHeap::heap<span class="function"><span class="params">()</span>-&gt;</span>perm_gen<span class="function"><span class="params">()</span>-&gt;</span>stat_record<span class="function"><span class="params">()</span>-&gt;</span>invocations;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">bool skip_dead = ((invocations % MarkSweepAlwaysCompactCount) != <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">size_t allowed_deadspace = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (skip_dead) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> size_t ratio = allowed_dead_ratio();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    allowed_deadspace = (capacity() * ratio / <span class="number">100</span>) / HeapWordSize;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其中<code>invocations</code>是FGC的总次数，当<code>invocations</code>不是4的倍数时，会在内存区域中留出一块大小为<code>allowed_deadspace</code>的死亡空间，默认为5%，用于后续使用；<br>4、定义一些基本变量：<code>q</code>为遍历指针，<code>t</code>为扫描边界，<code>end_of_live</code>为最后一个活跃对象的地址，<code>LiveRange</code>保存着死亡对象后面活跃对象的地址区间，<code>first_dead</code>为第一个死亡对象的地址，默认是该区域的末端地址；</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">HeapWord* <span class="attr">q</span> = bottom();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">HeapWord* <span class="attr">t</span> = scan_limit();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">HeapWord*  <span class="attr">end_of_live=</span> q;    <span class="comment">/* One byte beyond the last byte of the last</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">                                 live object. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">HeapWord*  <span class="attr">first_dead</span> = end();<span class="comment">/* The first dead object. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">LiveRange* <span class="attr">liveRange</span>  = NULL; <span class="comment">/* The current live range, recorded in the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">                                 first header of preceding free area. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="attr">_first_dead</span> = first_dead;</span></pre></td></tr></table></figure>

<p>5、开始遍历区域中的对象<br>如果指针<code>q</code>所指向位置是一个对象，且被标识过，说明这是一个活跃的对象，则通过<code>cp-&gt;space-&gt;forward()</code>方法计算该对象压缩后的地址；</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (q &lt; t) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> <span class="function"><span class="params">(block_is_obj(q) &amp;&amp; oop(q)-&gt;is_gc_marked())</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function">        /* <span class="title">prefetch</span> <span class="title">beyond</span> <span class="title">q</span> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function">        <span class="title">Prefetch</span>::<span class="title">write</span><span class="params">(q, interval)</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function">        /* <span class="title">size_t</span> <span class="title">size</span> = <span class="title">oop</span><span class="params">(q)</span>-&gt;</span>size();  changing <span class="keyword">this</span> <span class="keyword">for</span> cms <span class="keyword">for</span> perm gen */</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        size_t size = block_size(q);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        compact_top = cp-&gt;space-&gt;forward(oop(q), size, cp, compact_top);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        q += size;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        end_of_live = q;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如果对象在压缩之后位置有变化，则将自己的对象头设置为压缩后地址信息，否则表示该对象不需要移动，设置对象头为默认值，并调用<code>register_live_oop</code>方法把原指针保存在栈<code>_live_oops</code>中</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// store the forwarding pointer into the mark word</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((HeapWord*)q != compact_top) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="title">q</span>-&gt;</span>forward_to(oop(compact_top));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="title">assert</span>(q-&gt;</span>is_gc_marked(), <span class="string">"encoding the pointer should preserve the mark"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// if the object isn't moving we can just set the mark to the default</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// mark and handle it specially later on.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="title">q</span>-&gt;</span>init_mark();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="title">assert</span>(q-&gt;</span>forwardee() == NULL, <span class="string">"should be forwarded to NULL"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">VALIDATE_MARK_SWEEP_ONLY(MarkSweep::register_live_oop(q, size));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">compact_top += size;</span></pre></td></tr></table></figure>

<p>如果指针<code>q</code>所指向位置不是一个对象，或没有被标识过，说明是一个死亡对象，则直接跳过，直到碰到活跃对象为止，实现如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* run over all the contiguous dead objects */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">HeapWord* <span class="built_in">end</span> = q;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* prefetch beyond end */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    Prefetch::<span class="built_in">write</span>(<span class="built_in">end</span>, interval);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">end</span> += block_size(<span class="built_in">end</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">end</span> &lt; t &amp;&amp; (!block_is_obj(<span class="built_in">end</span>) || !oop(<span class="built_in">end</span>)-&gt;is_gc_marked()));</span></pre></td></tr></table></figure>

<p>6、如果死亡空间<code>allowed_deadspace</code>可用，则计算死亡对象的大小总和为<code>sz</code>，则调用<code>insert_deadspace()</code>方法尝试插入一个大小为<code>sz</code>的对象，当做活跃对象进行处理，实现如下</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* see if we might want to pretend this object is alive so that</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * we don't have to compact quite as often.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (allowed_deadspace &gt; <span class="number">0</span> &amp;&amp; q == compact_top) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> sz = pointer_delta(<span class="built_in">end</span>, q);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (insert_deadspace(allowed_deadspace, q, sz)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        compact_top = cp-&gt;space-&gt;forward(oop(q), sz, cp, compact_top);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        q = <span class="built_in">end</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        end_of_live = <span class="built_in">end</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> CompactibleSpace::insert_deadspace(<span class="keyword">size_t</span>&amp; allowed_deadspace_words,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                                        HeapWord* q, <span class="keyword">size_t</span> deadlength) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (allowed_deadspace_words &gt;= deadlength) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        allowed_deadspace_words -= deadlength;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        CollectedHeap::fill_with_object(q, deadlength);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        oop(q)-&gt;set_mark(oop(q)-&gt;mark()-&gt;set_marked());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        assert((<span class="keyword">int</span>) deadlength == oop(q)-&gt;<span class="built_in">size</span>(), <span class="string">"bad filler object size"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// Recall that we required "q == compaction_top".</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        allowed_deadspace_words = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如果死亡空间<code>allowed_deadspace</code>大于等于之前连续死亡对象大小总和，则更新<code>allowed_deadspace</code>值，并生成一个大小为<code>sz</code>且标识过的对象，这时需要更新压缩指针<code>compact_top</code>、遍历指针<code>q</code>和最后的活跃对象<code>end_of_live</code>，因为这里把新对象当成一个活跃对象进行处理，并继续往后遍历对象；<br>否则忽略这些死亡对象，进行以下步骤：<br>7、当执行到这一步时，说明跳过了一系列的死亡对象，遇到了活跃对象，如果<code>liveRange</code>不为空，则设置当前的结束位置为遍历指针<code>q</code>，此时<code>q</code>正指向死亡区域的第一个对象；由于在死亡对象后遇到了一个新的活跃对象，需要重新构造一个<code>LiveRange</code>对象来记录下一片活跃对象的地址范围，并设置开始和结束为止为<code>end</code>，这里直接把死亡区域的第一个对象当作<code>LiveRange</code>对象，实现如下</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* for the previous LiveRange, record the end of the live objects. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (liveRange) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    liveRange-&gt;set<span class="constructor">_end(<span class="params">q</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* record the current LiveRange object.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * liveRange-&gt;start() is overlaid on the mark word.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">liveRange = (LiveRange*)q;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">liveRange-&gt;set<span class="constructor">_start(<span class="params">end</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">liveRange-&gt;set<span class="constructor">_end(<span class="params">end</span>)</span>;</span></pre></td></tr></table></figure>

<p>8、保存第一个死亡对象的地址，并将遍历指针<code>q</code>指向<code>end</code>的位置继续遍历</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">/* see <span class="keyword">if</span> this <span class="keyword">is</span> <span class="keyword">the</span> <span class="keyword">first</span> dead region. */</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (q &lt; first_dead) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    first_dead = q;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">/* move <span class="keyword">on</span> <span class="keyword">to</span> <span class="keyword">the</span> next object */</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">q = <span class="keyword">end</span>;</span></pre></td></tr></table></figure>

<p>9、遍历完成之后，如果当前的<code>liveRange</code>不为空，则设置该<code>liveRange</code>的结束位置为<code>q</code>，设置最后一个活跃对象的位置<code>_end_of_live</code>，根据<code>_end_of_live</code>的值重新设置第一个死亡对象的位置<code>_first_dead</code>；</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">if</span> <span class="string">(liveRange != NULL) &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">liveRange-&gt;set_end(q);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attr">&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="attr">_end_of_live</span> = <span class="string">end_of_live;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="attr">if</span> <span class="string">(end_of_live &lt; first_dead) &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">first_dead</span> = <span class="string">end_of_live;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="attr">&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="attr">_first_dead</span> = <span class="string">first_dead;</span></span></pre></td></tr></table></figure>

<p>10、记录当前区域的压缩位置</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cp</span>-&gt;</span><span class="function"><span class="title">space</span>-&gt;</span>set_compaction_top(compact_top);</span></pre></td></tr></table></figure>

<h3 id="三、mark-sweep-phase3：更新对象的引用地址"><a href="#三、mark-sweep-phase3：更新对象的引用地址" class="headerlink" title="三、mark_sweep_phase3：更新对象的引用地址"></a>三、mark_sweep_phase3：更新对象的引用地址</h3><p>1、调用<code>gen_process_strong_roots()</code>并使用<code>adjust_root_pointer_closure</code>处理函数调整根对象指针的引用地址，<code>adjust_root_pointer_closure</code>的实现如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">void MarkSweep::AdjustPointerClosure::<span class="keyword">do</span><span class="constructor">_oop(<span class="params">oop</span><span class="operator">*</span> <span class="params">p</span>)</span> &#123; adjust<span class="constructor">_pointer(<span class="params">p</span>, <span class="params">_is_root</span>)</span>; &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">void MarkSweep::AdjustPointerClosure::<span class="keyword">do</span><span class="constructor">_oop(<span class="params">narrowOop</span><span class="operator">*</span> <span class="params">p</span>)</span> &#123; adjust<span class="constructor">_pointer(<span class="params">p</span>, <span class="params">_is_root</span>)</span>; &#125;</span></pre></td></tr></table></figure>

<p>其中<code>adjust_pointer()</code>方法定义在<code>markSweep.inline.hpp</code>文件中，通过解析对象的对象头，判断对象头中是否保存着经过压缩后的新地址，实现如下</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">template &lt;<span class="keyword">class</span> T&gt; inline void MarkSweep::adjust<span class="constructor">_pointer(T<span class="operator">*</span> <span class="params">p</span>, <span class="params">bool</span> <span class="params">isroot</span>)</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    T heap_oop = oopDesc::load<span class="constructor">_heap_oop(<span class="params">p</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!oopDesc::is<span class="constructor">_null(<span class="params">heap_oop</span>)</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        oop obj = oopDesc::decode<span class="constructor">_heap_oop_not_null(<span class="params">heap_oop</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        oop new_obj = oop(obj-&gt;mark<span class="literal">()</span>-&gt;decode<span class="constructor">_pointer()</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// ....</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (new_obj != NULL) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            oopDesc::encode<span class="constructor">_store_heap_oop_not_null(<span class="params">p</span>, <span class="params">new_obj</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="constructor">VALIDATE_MARK_SWEEP_ONLY(<span class="params">track_adjusted_pointer</span>(<span class="params">p</span>, <span class="params">isroot</span>)</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>2、<code>adjust_code_pointer_closure()</code>方法调整引用指针的引用地址；</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Now adjust pointers in remaining weak roots.  (All of which should</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// have been cleared if they pointed to non-surviving objects.)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">CodeBlobToOopClosure adjust_code_pointer_closure(<span class="variable">&amp;adjust_pointer_closure</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">                                                   <span class="comment">/*do_marking=*/</span> false);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">gch-&gt;gen_process_weak_roots(<span class="variable">&amp;adjust_root_pointer_closure</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                              <span class="variable">&amp;adjust_code_pointer_closure</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                              <span class="variable">&amp;adjust_pointer_closure</span>);</span></pre></td></tr></table></figure>

<p>3、使用<code>GenAdjustPointersClosure</code>遍历各内存代，以更新引用对象的引用地址；</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">adjust<span class="constructor">_marks()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">GenAdjustPointersClosure blk;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">gch-&gt;generation<span class="constructor">_iterate(&amp;<span class="params">blk</span>, <span class="params">true</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">pg-&gt;adjust<span class="constructor">_pointers()</span>;</span></pre></td></tr></table></figure>

<h3 id="四、mark-sweep-phase4：移动所有活跃对象到新地址"><a href="#四、mark-sweep-phase4：移动所有活跃对象到新地址" class="headerlink" title="四、mark_sweep_phase4：移动所有活跃对象到新地址"></a>四、mark_sweep_phase4：移动所有活跃对象到新地址</h3><p>1、压缩永久代的对象，只有等永久代的对象压缩后，实例对象才能获取正确的类数据地址；<br>2、使用<code>GenCompactClosure</code>遍历堆上的对象</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">GenCompactClosure blk;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">gch-&gt;generation<span class="constructor">_iterate(&amp;<span class="params">blk</span>, <span class="params">true</span>)</span>;</span></pre></td></tr></table></figure>

<p>其中<code>generation_iterate()</code>将调用<code>GenCompactClosure</code>的<code>do_generation()</code>方法遍历各个内存代，实现如下</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">void GenCollectedHeap::generation_iterate(GenClosure* cl,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">                                          bool old_to_young) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (old_to_young) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (int <span class="built_in">i</span> = _n_gens<span class="number">-1</span>; <span class="built_in">i</span> &gt;= <span class="number">0</span>; <span class="built_in">i</span>--) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            cl-&gt;do_generation(_gens[<span class="built_in">i</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; _n_gens; <span class="built_in">i</span>++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            cl-&gt;do_generation(_gens[<span class="built_in">i</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>GenCompactClosure</code>的<code>do_generation()</code>方法负责调用各个内存代的<code>compact()</code>进行压缩工作</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">GenCompactClosure: <span class="symbol">public</span></span> <span class="symbol">GenCollectedHeap::<span class="symbol">GenClosure</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">void</span> do_generation(Generation* gen) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        gen-&gt;compact();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>其中老年代的<code>compact()</code>方法实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CompactibleSpace::compact() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    SCAN_AND_COMPACT(obj_size);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>调用了<code>SCAN_AND_COMPACT</code>函数进行对象的移动<br>1、变量<code>q</code>是遍历指针，默认为内存区域的起始地址，<code>t</code>是最后一个活跃对象的位置，至于为什么要记录最后一个活跃对象的位置，主要是为了避免当GC后的活跃对象较少时，进行不必要的遍历</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#define SCAN_AND_COMPACT(obj_size) &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    /* Copy all live objects <span class="keyword">to</span> their <span class="keyword">new</span> location</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">     * Used <span class="keyword">by</span> MarkSweep::mark_sweep_phase4() */</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    HeapWord*       q = bottom();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    HeapWord* <span class="keyword">const</span> t = _end_of_live;</span></pre></td></tr></table></figure>

<p>2、移动第一个死亡对象之前的活跃对象到新的位置</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="function"><span class="params">(q &lt; t &amp;&amp; _first_dead &gt; q &amp;&amp;  !oop(q)-&gt;is_gc_marked())</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function">    <span class="title">HeapWord</span>* <span class="title">const</span> <span class="title">end</span> = <span class="title">_first_dead</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function">    <span class="title">while</span> <span class="params">(q &lt; end)</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function">        <span class="title">size_t</span> <span class="title">size</span> = <span class="title">obj_size</span><span class="params">(q)</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function">        <span class="title">VALIDATE_MARK_SWEEP_ONLY</span><span class="params">(MarkSweep::live_oop_moved_to(q, size, q))</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function">        <span class="title">q</span> += <span class="title">size</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function">    &#125;</span></span></pre></td></tr></table></figure>

<p>3、当遍历到<code>_first_dead</code>时，即第一个死亡对象的位置，如果<code>_first_dead</code>不等于<code>_end_of_live</code>，说明有连续多个死亡对象，而且在第一个死亡对象的对象头保存着<code>LiveRange</code>，通过<code>LiveRange</code>可以获取下一个活跃对象的地址</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_first_dead == t) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    q = t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* $$$ Funky */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="title">q</span> = <span class="params">(HeapWord*)</span> <span class="title">oop</span><span class="params">(_first_dead)</span>-&gt;</span>mark<span class="function"><span class="params">()</span>-&gt;</span>decode_pointer();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>4、从新的活跃对象开始新的遍历<br>如果是死亡对象，则通过<code>LiveRange</code>获取下一个存活对象的地址</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (q &lt; t) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> <span class="function"><span class="params">(!oop(q)-&gt;is_gc_marked())</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function">        /* <span class="title">mark</span> <span class="title">is</span> <span class="title">pointer</span> <span class="title">to</span> <span class="title">next</span> <span class="title">marked</span> <span class="title">oop</span> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function">        <span class="title">debug_only</span><span class="params">(prev_q = q)</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function">        <span class="title">q</span> = <span class="params">(HeapWord*)</span> <span class="title">oop</span><span class="params">(q)</span>-&gt;</span>mark<span class="function"><span class="params">()</span>-&gt;</span>decode_pointer();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        assert(q &gt; prev_q, <span class="string">"we should be moving forward through memory"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>

<p>5、如果是活跃对象，则调用<code>live_oop_moved_to</code>方法将对象移动到压缩后的新地址，并初始化新对象的对象头，实现如下</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Prefetch::<span class="built_in">read</span>(q, scan_interval);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size and destination */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="built_in">size</span> = obj_size(q);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">HeapWord* compaction_top = (HeapWord*)oop(q)-&gt;forwardee();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* prefetch beyond compaction_top */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">Prefetch::<span class="built_in">write</span>(compaction_top, copy_interval);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* copy object and reinit its mark */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">VALIDATE_MARK_SWEEP_ONLY(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  MarkSweep::live_oop_moved_to(q, <span class="built_in">size</span>, compaction_top)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">Copy::aligned_conjoint_words(q, compaction_top, <span class="built_in">size</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">oop(compaction_top)-&gt;init_mark();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">q += <span class="built_in">size</span>;</span></pre></td></tr></table></figure>

<p>其中<code>live_oop_moved_to()</code>方法实现如下：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> MarkSweep::live_oop_moved_to(HeapWord* q, size_t size,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">                                  HeapWord* compaction_top) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    assert<span class="function"><span class="params">(oop(q)-&gt;forwardee() == NULL || oop(q)-&gt;forwardee() == oop(compaction_top),</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">         <span class="string">"should be moved to forwarded location"</span>)</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(ValidateMarkSweep)</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function">        <span class="title">MarkSweep</span>::<span class="title">validate_live_oop</span><span class="params">(oop(q), size)</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function">        <span class="title">_live_oops_moved_to</span>-&gt;</span>push(oop(compaction_top));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (RecordMarkSweepCompaction) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        _cur_gc_live_oops-&gt;push(q);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        _cur_gc_live_oops_moved_to-&gt;push(compaction_top);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        _cur_gc_live_oops_size-&gt;push(size);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>原对象的指针已经被保存在<code>_live_oops</code>栈中，对应的把压缩后的对象指针保存在<code>_live_oops_moved_to</code>中</p>
<blockquote>
<p>作者：占小狼</p>
<p>来源：<a href="https://www.jianshu.com/p/29c20f0684d0" target="_blank" rel="noopener">https://www.jianshu.com/p/29c20f0684d0</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%BA%90%E7%A0%81/" rel="tag"># 源码</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/08/JVM%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%8811%EF%BC%89%EF%BC%9A%E6%96%B0%E7%94%9F%E4%BB%A3DefNewGeneration%E7%9A%84%E5%AE%9E%E7%8E%B0/" rel="prev" title="JVM源码分析（11）：新生代DefNewGeneration的实现">
      <i class="fa fa-chevron-left"></i> JVM源码分析（11）：新生代DefNewGeneration的实现
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/08/Kafka%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" rel="next" title="Kafka深度解析">
      Kafka深度解析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#TenuredGeneration"><span class="nav-number">1.</span> <span class="nav-text">TenuredGeneration</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC前准备"><span class="nav-number">2.</span> <span class="nav-text">GC前准备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#执行GC"><span class="nav-number">3.</span> <span class="nav-text">执行GC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、mark-sweep-phase1：-标记活跃对象"><span class="nav-number">3.1.</span> <span class="nav-text">一、mark_sweep_phase1： 标记活跃对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、mark-sweep-phase2：-计算活跃对象在压缩完成之后的新地址"><span class="nav-number">3.2.</span> <span class="nav-text">二、mark_sweep_phase2： 计算活跃对象在压缩完成之后的新地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、mark-sweep-phase3：更新对象的引用地址"><span class="nav-number">3.3.</span> <span class="nav-text">三、mark_sweep_phase3：更新对象的引用地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、mark-sweep-phase4：移动所有活跃对象到新地址"><span class="nav-number">3.4.</span> <span class="nav-text">四、mark_sweep_phase4：移动所有活跃对象到新地址</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">congsheng.wang</p>
  <div class="site-description" itemprop="description">trouble is a friend</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">984</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">94</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">156</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">congsheng.wang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
