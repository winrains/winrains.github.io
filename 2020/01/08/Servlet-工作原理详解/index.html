<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://congsheng.wang').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="什么是ServletServlet的作用是为Java程序提供一个统一的web应用的规范，方便程序员统一的使用这种规范来编写程序，应用容器可以使用提供的规范来实现自己的特性。比如tomcat的代码和jetty的代码就不一样，但作为程序员你只需要了解servlet规范就可以从request中取值，你可以操作session等等。不用在意应用服务器底层的实现的差别而影响你的开发。HTTP 协议只是一个规范">
<meta name="keywords" content="Servlet">
<meta property="og:type" content="article">
<meta property="og:title" content="Servlet 工作原理详解">
<meta property="og:url" content="http:&#x2F;&#x2F;congsheng.wang&#x2F;2020&#x2F;01&#x2F;08&#x2F;Servlet-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3&#x2F;index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="什么是ServletServlet的作用是为Java程序提供一个统一的web应用的规范，方便程序员统一的使用这种规范来编写程序，应用容器可以使用提供的规范来实现自己的特性。比如tomcat的代码和jetty的代码就不一样，但作为程序员你只需要了解servlet规范就可以从request中取值，你可以操作session等等。不用在意应用服务器底层的实现的差别而影响你的开发。HTTP 协议只是一个规范">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191022100244-50549.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191022100244-9b25e.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191022100244-9846c.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191022100244-cf39e.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191022100245-e352d.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191022100245-b2327.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;a8502-image025.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191022100246-8e13e.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;9c196-image023.jpg">
<meta property="og:updated_time" content="2020-01-08T01:50:28.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191022100244-50549.png">

<link rel="canonical" href="http://congsheng.wang/2020/01/08/Servlet-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Servlet 工作原理详解 | 个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">congsheng的博客</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">156</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">94</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">984</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://congsheng.wang/2020/01/08/Servlet-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="congsheng.wang">
      <meta itemprop="description" content="trouble is a friend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Servlet 工作原理详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-08 09:50:28" itemprop="dateCreated datePublished" datetime="2020-01-08T09:50:28+08:00">2020-01-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">Java技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="什么是Servlet"><a href="#什么是Servlet" class="headerlink" title="什么是Servlet"></a>什么是Servlet</h2><p>Servlet的作用是<strong>为Java程序提供一个统一的web应用的规范</strong>，方便程序员统一的使用这种规范来编写程序，应用容器可以使用提供的规范来实现自己的特性。比如tomcat的代码和jetty的代码就不一样，但作为程序员你只需要了解servlet规范就可以从request中取值，你可以操作session等等。不用在意应用服务器底层的实现的差别而影响你的开发。<br>HTTP 协议只是一个规范，定义服务请求和响应的大致式样。Java servlet 类<strong>将HTTP中那些低层的结构包装在 Java 类中</strong>，这些类所包含的便利方法使其在 Java 语言环境中更易于处理。</p>
<a id="more"></a>

<blockquote>
<p>正如您正使用的特定 servlet 容器的配置文件中所定义的，当用户通过 URL 发出一个请求时，这些 Java servlet 类就将之转换成一个 HttpServletRequest，并发送给 URL 所指向的目标。当服务器端完成其工作时，Java 运行时环境（Java Runtime Environment）就将结果包装在一个 <code>HttpServletResponse</code> 中，然后将原 HTTP 响应送回给发出该请求的客户机。在与 Web 应用程序进行交互时，通常会发出多个请求并获得多个响应。所有这些都是在一个会话语境中，Java 语言将之包装在一个 <code>HttpSession</code> 对象中。在处理响应时，您可以访问该对象，并在创建响应时向其添加事件。它提供了一些跨请求的语境。</p>
</blockquote>
<p><strong>容器</strong>（如 Tomcat）将为 servlet 管理运行时环境。您可以配置该容器，定制 J2EE 服务器的工作方式，以便将 servlet 暴露给外部世界。正如我们将看到的，通过该容器中的各种配置文件，您在 URL（由用户在浏览器中输入）与服务器端组件之间搭建了一座桥梁，这些组件将处理您需要该 URL 转换的请求。在运行应用程序时，该容器将<strong>加载并初始化 servlet</strong>，<strong>管理其生命周期</strong>。</p>
<h2 id="Servlet体系结构"><a href="#Servlet体系结构" class="headerlink" title="Servlet体系结构"></a>Servlet体系结构</h2><p><img src="http://image.winrains.cn/2019/10/20191022100244-50549.png" alt="http://image.winrains.cn/2019/10/20191022100244-50549.png"><br>Servlet顶级类关联图</p>
<h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a><strong>Servlet</strong></h3><p>Servlet的框架是由两个Java包组成的：<code>javax.servlet</code>与<code>javax.servlet.http</code>。在javax.servlet包中定义了所有的Servlet类都必须实现或者扩展的通用接口和类。在<code>javax.servlet.http</code>包中定义了采用Http协议通信的<code>HttpServlet</code>类。Servlet的框架的核心是<code>javax.servlet.Servlet</code>接口，所有的Servlet都必须实现这个接口。<br><img src="http://image.winrains.cn/2019/10/20191022100244-9b25e.png" alt="http://image.winrains.cn/2019/10/20191022100244-9b25e.png"></p>
<h3 id="Servlet接口"><a href="#Servlet接口" class="headerlink" title="Servlet接口"></a>Servlet接口</h3><p>在Servlet接口中定义了5个方法：</p>
<p>\1. init(ServletConfig)方法：负责初始化Servlet对象，在Servlet的生命周期中，该方法执行一次；该方法执行在单线程的环境下，因此开发者不用考虑线程安全的问题；</p>
<p>\2. service(ServletRequest req,ServletResponse res)方法：负责响应客户的请求；为了提高效率，Servlet规范要求一个Servlet实例必须能够同时服务于多个客户端请求，即<code>service()</code>方法运行在多线程的环境下，Servlet开发者必须保证该方法的线程安全性；</p>
<p>\3. destroy()方法：当Servlet对象退出生命周期时，负责释放占用的资源；</p>
<p>\4. getServletInfo：就是字面意思，返回Servlet的描述；</p>
<p>\5. getServletConfig：这个方法返回由Servlet容器传给<code>init</code>方法的<code>ServletConfig</code>。</p>
<h3 id="ServletRequest-amp-ServletResponse"><a href="#ServletRequest-amp-ServletResponse" class="headerlink" title="ServletRequest &amp; ServletResponse"></a><strong>ServletRequest &amp; ServletResponse</strong></h3><p>对于每一个HTTP请求，servlet容器会创建一个封装了HTTP请求的<code>ServletRequest</code>实例传递给servlet的<code>service</code>方法，<code>ServletResponse</code>则表示一个Servlet响应，其隐藏了将响应发给浏览器的复杂性。通过<code>ServletRequest</code>的方法你可以获取一些请求相关的参数，而<code>ServletResponse</code>则可以将设置一些返回参数信息，并且设置返回内容。</p>
<h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a><strong>ServletConfig</strong></h3><p><code>ServletConfig</code>封装可以通过<code>@WebServlet</code>或者web.xml传给一个Servlet的配置信息，以这种方式传递的每一条信息都称做初始化信息，初始化信息就是一个个K-V键值对。为了从一个Servlet内部获取某个初始参数的值，<code>init</code>方法中调用<code>ServletConfig</code>的<code>getinitParameter</code>方法或<code>getinitParameterNames</code>方法获取，除此之外，还可以通过<code>getServletContext</code>获取<code>ServletContext</code>对象。</p>
<h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a><strong>ServletContext</strong></h3><p><code>ServletContext</code>是代表了Servlet应用程序。每个Web应用程序只有一个context。在分布式环境中，一个应用程序同时部署到多个容器中，并且每台Java虚拟机都有一个<code>ServletContext</code>对象。有了<code>ServletContext</code>对象后，就可以共享能通过应用程序的所有资源访问的信息，促进Web对象的动态注册，共享的信息通过一个内部Map中的对象保存在<code>ServiceContext</code>中来实现。保存在<code>ServletContext</code>中的对象称作属性。操作属性的方法：</p>
<h3 id="GenericServlet"><a href="#GenericServlet" class="headerlink" title="GenericServlet"></a><strong>GenericServlet</strong></h3><p>前面编写的Servlet应用中通过实现Servlet接口来编写Servlet，但是我们每次都必须为Servlet中的所有方法都提供实现，还需要将<code>ServletConfig</code>对象保存到一个类级别的变量中，<code>GenericServlet</code>抽象类就是为了为我们省略一些模板代码，实现了Servlet和<code>ServletConfig</code>，完成了一下几个工作：<br>将<code>init</code>方法中的<code>ServletConfig</code>赋给一个类级变量，使的可以通过<code>getServletConfig</code>来获取。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public void init(ServletConfig config) throws ServletException &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    this.config = config;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    this.init();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>同时为避免覆盖<code>init</code>方法后在子类中必须调用<code>super.init(servletConfig)</code>，<code>GenericServlet</code>还提供了一个不带参数的<code>init</code>方法，当<code>ServletConfig</code>赋值完成就会被第带参数的<code>init</code>方法调用。这样就可以通过覆盖不带参数的<code>init</code>方法编写初始化代码，而<code>ServletConfig</code>实例依然得以保存为Servlet接口中的所有方法提供默认实现。<br>提供方法来包装<code>ServletConfig</code>中的方法。</p>
<h3 id="HTTPServlet"><a href="#HTTPServlet" class="headerlink" title="HTTPServlet"></a><strong>HTTPServlet</strong></h3><p>在编写Servlet应用程序时，大多数都要用到HTTP，也就是说可以利用HTTP提供的特性，<code>javax.servlet.http</code>包含了编写Servlet应用程序的类和接口，其中很多覆盖了<code>javax.servlet</code>中的类型，我们自己在编写应用时大多时候也是继承的<code>HttpServlet</code>。</p>
<h2 id="Servlet工作原理"><a href="#Servlet工作原理" class="headerlink" title="Servlet工作原理"></a>Servlet工作原理</h2><p>当Web服务器接收到一个HTTP请求时，它会先判断请求内容——如果是静态网页数据，Web服务器将会自行处理，然后产生响应信息；如果牵涉到动态数据，Web服务器会将请求转交给Servlet容器。此时Servlet容器会找到对应的处理该请求的Servlet实例来处理，结果会送回Web服务器，再由Web服务器传回用户端。<br>针对同一个Servlet，Servlet容器会在第一次收到http请求时建立一个Servlet实例，然后启动一个线程。第二次收到http请求时，Servlet容器无须建立相同的Servlet实例，而是启动第二个线程来服务客户端请求。所以多线程方式不但可以提高Web应用程序的执行效率，也可以降低Web服务器的系统负担。<br><img src="http://image.winrains.cn/2019/10/20191022100244-9846c.png" alt="http://image.winrains.cn/2019/10/20191022100244-9846c.png"></p>
<h3 id="Web服务器工作流程"><a href="#Web服务器工作流程" class="headerlink" title="Web服务器工作流程"></a>Web服务器工作流程</h3><p>接着我们描述一下Tomcat与Servlet是如何工作的，首先看下面的时序图：<br><img src="http://image.winrains.cn/2019/10/20191022100244-cf39e.png" alt="http://image.winrains.cn/2019/10/20191022100244-cf39e.png"></p>
<h3 id="Servlet工作原理时序图"><a href="#Servlet工作原理时序图" class="headerlink" title="Servlet工作原理时序图"></a>Servlet工作原理时序图</h3><blockquote>
<ol>
<li>Web Client 向Servlet容器（Tomcat）发出Http请求；</li>
<li>Servlet容器接收Web Client的请求；</li>
<li>Servlet容器创建一个<code>HttpRequest</code>对象，将Web Client请求的信息封装到这个对象中；</li>
<li>Servlet容器创建一个<code>HttpResponse</code>对象；</li>
<li>Servlet容器调用<code>HttpServlet</code>对象的<code>service</code>方法，把<code>HttpRequest</code>对象与<code>HttpResponse</code>对象作为参数传给 <code>HttpServlet</code>对象；</li>
<li><code>HttpServlet</code>调用<code>HttpRequest</code>对象的有关方法，获取Http请求信息；</li>
<li><code>HttpServlet</code>调用<code>HttpResponse</code>对象的有关方法，生成响应数据；</li>
<li>Servlet容器把<code>HttpServlet</code>的响应结果传给Web Client；</li>
</ol>
</blockquote>
<h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><p><strong>在Servlet接口中定义了5个方法，其中3个方法代表了Servlet的生命周期：</strong></p>
<p>\1. init(ServletConfig)方法：负责初始化Servlet对象，在Servlet的生命周期中，该方法执行一次；该方法执行在单线程的环境下，因此开发者不用考虑线程安全的问题；</p>
<p>\2. service(ServletRequest req,ServletResponse res)方法：负责响应客户的请求；为了提高效率，Servlet规范要求一个Servlet实例必须能够同时服务于多个客户端请求，即<code>service()</code>方法运行在多线程的环境下，Servlet开发者必须保证该方法的线程安全性；</p>
<p>\3. destroy()方法：当Servlet对象退出生命周期时，负责释放占用的资源；</p>
<p>编程注意事项说明：</p>
<ol>
<li>当Server Thread线程执行Servlet实例的<code>init()</code>方法时，所有的Client Service Thread线程都不能执行该实例的<code>service()</code>方法，更没有线程能够执行该实例的<code>destroy()</code>方法，因此Servlet的<code>init()</code>方法是工作在单线程的环境下，开发者不必考虑任何线程安全的问题。</li>
<li>当服务器接收到来自客户端的多个请求时，服务器会在单独的Client Service Thread线程中执行Servlet实例的<code>service()</code>方法服务于每个客户端。此时会有多个线程同时执行同一个Servlet实例的<code>service()</code>方法，因此必须考虑线程安全的问题。</li>
<li>虽然<code>service()</code>方法运行在多线程的环境下，并不一定要同步该方法。而是要看这个方法在执行过程中访问的资源类型及对资源的访问方式。分析如下：</li>
</ol>
<p>\1. 如果<code>service()</code>方法没有访问Servlet的成员变量也没有访问全局的资源比如静态变量、文件、数据库连接等，而是只使用了当前线程自己的资源，比如非指向全局资源的临时变量、request和response对象等。该方法本身就是线程安全的，不必进行任何的同步控制。</p>
<p>\2. 如果<code>service()</code>方法访问了Servlet的成员变量，但是对该变量的操作是只读操作，该方法本身就是线程安全的，不必进行任何的同步控制。</p>
<p>\3. 如果<code>service()</code>方法访问了Servlet的成员变量，并且对该变量的操作既有读又有写，通常需要加上同步控制语句。</p>
<p>\4. 如果<code>service()</code>方法访问了全局的静态变量，如果同一时刻系统中也可能有其它线程访问该静态变量，如果既有读也有写的操作，通常需要加上同步控制语句。</p>
<p>\5. 如果<code>service()</code>方法访问了全局的资源，比如文件、数据库连接等，通常需要加上同步控制语句。</p>
<p>在创建一个 Java servlet 时，一般需要子类 <code>HttpServlet</code>。该类中的方法允许您访问请求和响应包装器（wrapper），您可以用这个包装器来处理请求和创建响应。Servlet的生命周期，简单的概括这就分为四步：<br><strong>Servlet类加载—&gt;实例化—&gt;服务—&gt;销毁；</strong><br><img src="http://image.winrains.cn/2019/10/20191022100245-e352d.png" alt="http://image.winrains.cn/2019/10/20191022100245-e352d.png"></p>
<h3 id="Servlet生命周期-1"><a href="#Servlet生命周期-1" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h3><p><strong>创建Servlet对象的时机：</strong></p>
<ol>
<li><strong>默认情况下</strong>，在Servlet容器启动后：客户首次向Servlet发出请求，Servlet容器会判断内存中是否存在指定的Servlet对象，如果没有则创建它，然后根据客户的请求创建<code>HttpRequest</code>、<code>HttpResponse</code>对象，从而调用Servlet对象的<code>service</code>方法；</li>
<li><strong>Servlet容器启动时</strong>：当web.xml文件中如果<code>元素中指定了</code>子元素时，Servlet容器在启动web服务器时，将按照顺序创建并初始化Servlet对象；</li>
<li><strong>Servlet的类文件被更新后，重新创建Servlet</strong>。Servlet容器在启动时自动创建Servlet，这是由在web.xml文件中为Servlet设置的``属性决定的。从中我们也能看到同一个类型的Servlet对象在Servlet容器中以单例的形式存在；</li>
</ol>
<blockquote>
<p>注意：在web.xml文件中，某些Servlet只有<code>元素，没有</code>元素，这样我们无法通过url的方式访问这些Servlet，这种Servlet通常会在<code>元素中配置一个</code>子元素，让容器在启动的时候自动加载这些Servlet并调用<code>init(ServletConfig config)</code>方法来初始化该Servlet。其中方法参数<code>config</code>中包含了Servlet的配置信息，比如初始化参数，该对象由服务器创建。</p>
</blockquote>
<h3 id="销毁Servlet对象的时机"><a href="#销毁Servlet对象的时机" class="headerlink" title="销毁Servlet对象的时机"></a><strong>销毁Servlet对象的时机</strong></h3><p><strong>Servlet容器停止或者重新启动</strong>：Servlet容器调用Servlet对象的<code>destroy</code>方法来释放资源。以上所讲的就是Servlet对象的生命周期。那么Servlet容器如何知道创建哪一个Servlet对象？Servlet对象如何配置？实际上这些信息是通过读取web.xml配置文件来实现的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- Servlet对象的名称 --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>action<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- 创建Servlet对象所要调用的类 --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.struts.action.ActionServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- 参数名称 --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>config<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- 参数值 --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/struts-config.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>detail<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- Servlet容器启动时加载Servlet对象的顺序 --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 要与servlet中的servlet-name配置节内容对应 --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>action<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- 客户访问的Servlet的相对URL路径 --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>当Servlet容器启动的时候读取<code>配置节信息，根据</code>配置节信息创建Servlet对象，同时根据<code>配置节信息创建`HttpServletConfig`对象，然后执行Servlet对象的`init`方法，并且根据</code>配置节信息来决定创建Servlet对象的顺序，如果此配置节信息为负数或者没有配置，那么在Servlet容器启动时，将不加载此Servlet对象。当客户访问Servlet容器时，Servlet容器根据客户访问的URL地址，通过<code>配置节中的</code>配置节信息找到指定的Servlet对象，并调用此Servlet对象的<code>service</code>方法。</p>
</blockquote>
<p>在整个Servlet的生命周期过程中，<strong>创建Servlet实例、调用实例的<code>init()</code>和<code>destroy()</code>方法都只进行一次</strong>，当初始化完成后，Servlet容器会将该实例保存在内存中，通过调用它的<code>service()</code>方法，为接收到的请求服务。下面给出Servlet整个生命周期过程的UML序列图，如图所示：<br><img src="http://image.winrains.cn/2019/10/20191022100245-b2327.png" alt="http://image.winrains.cn/2019/10/20191022100245-b2327.png"></p>
<h3 id="Servlet生命周期-2"><a href="#Servlet生命周期-2" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h3><blockquote>
<p>如果需要让Servlet容器在启动时即加载Servlet，可以在web.xml文件中配置``元素。</p>
</blockquote>
<h2 id="Servlet中的Listener"><a href="#Servlet中的Listener" class="headerlink" title="Servlet中的Listener"></a>Servlet中的Listener</h2><p>Listener 使用的非常广泛，它是基于观察者模式设计的，Listener 的设计对开发 Servlet 应用程序提供了一种快捷的手段，能够方便的从另一个纵向维度控制程序和数据。目前 Servlet 中提供了 5 种两类事件的观察者接口，它们分别是：4 个 <code>EventListeners</code> 类型的，<code>ServletContextAttributeListener</code>、<code>ServletRequestAttributeListener</code>、<code>ServletRequestListener</code>、<code>HttpSessionAttributeListener</code> 和 2 个 <code>LifecycleListeners</code> 类型的，<code>ServletContextListener</code>、<code>HttpSessionListener</code>。如下图所示：<br><img src="http://image.winrains.cn/2019/10/a8502-image025.png" alt="http://image.winrains.cn/2019/10/a8502-image025.png"></p>
<h3 id="Servlet中的Listener-1"><a href="#Servlet中的Listener-1" class="headerlink" title="Servlet中的Listener"></a>Servlet中的Listener</h3><p>它们基本上涵盖了整个 Servlet 生命周期中，你感兴趣的每种事件。这些 Listener 的实现类可以配置在 web.xml 中的<code></code> 标签中。当然也可以在应用程序中动态添加 Listener，需要注意的是 <code>ServletContextListener</code> 在容器启动之后就不能再添加新的，因为它所监听的事件已经不会再出现。掌握这些 Listener 的使用，能够让我们的程序设计的更加灵活。</p>
<h1 id="Cookie与Session"><a href="#Cookie与Session" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h1><p>Servlet 能够给我们提供两部分数据，一个是在 Servlet 初始化时调用 <code>init</code> 方法时设置的 <code>ServletConfig</code>，这个类基本上含有了 Servlet 本身和 Servlet 所运行的 Servlet 容器中的基本信息。还有一部分数据是由 <code>ServletRequest</code> 类提供，从提供的方法中发现主要是描述这次请求的 HTTP 协议的信息。关于这一块还有一个让很多人迷惑的 Session 与 Cookie。<br>Session 与 Cookie 的作用都是为了保持访问用户与后端服务器的交互状态。它们有各自的优点也有各自的缺陷。然而具有讽刺意味的是它们优点和它们的使用场景又是矛盾的，例如使用 Cookie 来传递信息时，随着 Cookie 个数的增多和访问量的增加，它占用的网络带宽也也会越来越大。所以大访问量的时候希望用 Session，但是 Session 的致命弱点是不容易在多台服务器之间共享，所以这也限制了 Session 的使用。<br>不管 Session 和 Cookie 有什么不足，我们还是要用它们。下面详细讲一下，Session 如何基于 Cookie 来工作。实际上有三种方式能可以让 Session 正常工作：</p>
<ul>
<li>基于 URL Path Parameter，默认就支持</li>
<li>基于 Cookie，如果你没有修改 Context 容器个 cookies 标识的话，默认也是支持的</li>
<li>基于 SSL，默认不支持，只有<code>connector.getAttribute(&quot;SSLEnabled&quot;)</code> 为 TRUE 时才支持</li>
</ul>
<p>第一种情况下，当浏览器不支持 Cookie 功能时，浏览器会将用户的 <code>SessionCookieName</code> 重写到用户请求的 URL 参数中，它的传递格式如：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">/path/Servlet?name=<span class="keyword">value</span>&amp;name<span class="number">2</span>=<span class="keyword">value</span><span class="number">2</span>&amp;JSESSIONID=<span class="keyword">value</span><span class="number">3</span></span></pre></td></tr></table></figure>

<p>接着 Request 根据这个 <code>JSESSIONID</code> 参数拿到<code>Session ID</code> 并设置到<code>request.setRequestedSessionId</code> 中。</p>
<blockquote>
<p>请注意如果客户端也支持 Cookie 的话，Tomcat 仍然会解析 Cookie 中的 Session ID，并会覆盖 URL 中的 Session ID。</p>
</blockquote>
<p>如果是第三种情况的话将会根据<code>javax.servlet.request.ssl_session</code> 属性值设置 Session ID。<br>有了 Session ID 服务器端就可以创建 <code>HttpSession</code> 对象了，第一次触发是通过<code>request. getSession()</code> 方法，如果当前的 <code>Session ID</code> 还没有对应的 <code>HttpSession</code> 对象那么就创建一个新的，并将这个对象加到<code>org.apache.catalina. Manager</code> 的 sessions 容器中保存，Manager 类将管理所有 Session 的生命周期，Session 过期将被回收，服务器关闭，Session 将被序列化到磁盘等。只要这个 <code>HttpSession</code> 对象存在，用户就可以根据<code>Session ID</code> 来获取到这个对象，也就达到了状态的保持。<br><img src="http://image.winrains.cn/2019/10/20191022100246-8e13e.png" alt="http://image.winrains.cn/2019/10/20191022100246-8e13e.png"></p>
<h3 id="Session相关类图"><a href="#Session相关类图" class="headerlink" title="Session相关类图"></a>Session相关类图</h3><p>上从图中可以看出从<code>request.getSession</code> 中获取的 <code>HttpSession</code> 对象实际上是 <code>StandardSession</code> 对象的门面对象，这与前面的 Request 和 Servlet 是一样的原理。下图是 Session 工作的时序图：<br><img src="http://image.winrains.cn/2019/10/9c196-image023.jpg" alt="http://image.winrains.cn/2019/10/9c196-image023.jpg"></p>
<h3 id="Session工作的时序图"><a href="#Session工作的时序图" class="headerlink" title="Session工作的时序图"></a>Session工作的时序图</h3><p>还有一点与 Session 关联的 Cookie 与其它 Cookie 没有什么不同，这个配置的配置可以通过 web.xml 中的<code>session-config</code> 配置项来指定。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://segmentfault.com/a/1190000009707894" target="_blank" rel="noopener">https://segmentfault.com/a/11…</a><br><a href="https://www.cnblogs.com/hysum/p/7100874.html" target="_blank" rel="noopener">https://www.cnblogs.com/hysum…</a><br><a href="http://c.biancheng.net/view/939.html" target="_blank" rel="noopener">http://c.biancheng.net/view/9…</a><br><a href="https://www.runoob.com/" target="_blank" rel="noopener">https://www.runoob.com/</a><br><a href="https://blog.csdn.net/android_hl/article/details/53228348" target="_blank" rel="noopener">https://blog.csdn.net/android…</a></p>
<blockquote>
<p>作者：Java技术江湖</p>
<p>来源：<a href="https://segmentfault.com/a/1190000020758621" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020758621</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Servlet/" rel="tag"># Servlet</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1-Dubbo-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/" rel="prev" title="微服务 Dubbo 功能介绍">
      <i class="fa fa-chevron-left"></i> 微服务 Dubbo 功能介绍
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/08/%E6%BC%AB%E8%B0%88Spring%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96/" rel="next" title="漫谈Spring的启动与初始化">
      漫谈Spring的启动与初始化 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是Servlet"><span class="nav-number">1.</span> <span class="nav-text">什么是Servlet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Servlet体系结构"><span class="nav-number">2.</span> <span class="nav-text">Servlet体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet"><span class="nav-number">2.1.</span> <span class="nav-text">Servlet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet接口"><span class="nav-number">2.2.</span> <span class="nav-text">Servlet接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ServletRequest-amp-ServletResponse"><span class="nav-number">2.3.</span> <span class="nav-text">ServletRequest &amp; ServletResponse</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ServletConfig"><span class="nav-number">2.4.</span> <span class="nav-text">ServletConfig</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ServletContext"><span class="nav-number">2.5.</span> <span class="nav-text">ServletContext</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GenericServlet"><span class="nav-number">2.6.</span> <span class="nav-text">GenericServlet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPServlet"><span class="nav-number">2.7.</span> <span class="nav-text">HTTPServlet</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Servlet工作原理"><span class="nav-number">3.</span> <span class="nav-text">Servlet工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Web服务器工作流程"><span class="nav-number">3.1.</span> <span class="nav-text">Web服务器工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet工作原理时序图"><span class="nav-number">3.2.</span> <span class="nav-text">Servlet工作原理时序图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Servlet生命周期"><span class="nav-number">4.</span> <span class="nav-text">Servlet生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet生命周期-1"><span class="nav-number">4.1.</span> <span class="nav-text">Servlet生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#销毁Servlet对象的时机"><span class="nav-number">4.2.</span> <span class="nav-text">销毁Servlet对象的时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet生命周期-2"><span class="nav-number">4.3.</span> <span class="nav-text">Servlet生命周期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Servlet中的Listener"><span class="nav-number">5.</span> <span class="nav-text">Servlet中的Listener</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet中的Listener-1"><span class="nav-number">5.1.</span> <span class="nav-text">Servlet中的Listener</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Cookie与Session"><span class="nav-number"></span> <span class="nav-text">Cookie与Session</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Session相关类图"><span class="nav-number">0.1.</span> <span class="nav-text">Session相关类图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Session工作的时序图"><span class="nav-number">0.2.</span> <span class="nav-text">Session工作的时序图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文章"><span class="nav-number">1.</span> <span class="nav-text">参考文章</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">congsheng.wang</p>
  <div class="site-description" itemprop="description">trouble is a friend</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">984</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">94</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">156</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">congsheng.wang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
