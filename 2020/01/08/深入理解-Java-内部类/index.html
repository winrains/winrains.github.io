<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://congsheng.wang').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="可以将一个类定义在另一个类或方法中，这样的类叫做内部类 –《Thinking in Java》说起内部类，大家并不陌生，并且会经常在实例化容器的时候使用到它。但是内部类的具体细节语法，原理以及实现是什么样的可以不少人都还挺陌生，这里作一篇总结，希望通过这篇总结提高对内部类的认识。">
<meta name="keywords" content="内部类">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解 Java 内部类">
<meta property="og:url" content="http:&#x2F;&#x2F;congsheng.wang&#x2F;2020&#x2F;01&#x2F;08&#x2F;%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E5%86%85%E9%83%A8%E7%B1%BB&#x2F;index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="可以将一个类定义在另一个类或方法中，这样的类叫做内部类 –《Thinking in Java》说起内部类，大家并不陌生，并且会经常在实例化容器的时候使用到它。但是内部类的具体细节语法，原理以及实现是什么样的可以不少人都还挺陌生，这里作一篇总结，希望通过这篇总结提高对内部类的认识。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-01-08T02:45:05.000Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://congsheng.wang/2020/01/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E5%86%85%E9%83%A8%E7%B1%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>深入理解 Java 内部类 | 个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">congsheng的博客</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">156</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">94</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">984</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://congsheng.wang/2020/01/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E5%86%85%E9%83%A8%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="congsheng.wang">
      <meta itemprop="description" content="trouble is a friend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入理解 Java 内部类
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-08 10:45:05" itemprop="dateCreated datePublished" datetime="2020-01-08T10:45:05+08:00">2020-01-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">Java技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>可以将一个类定义在另一个类或方法中，这样的类叫做内部类 –《Thinking in Java》<br>说起内部类，大家并不陌生，并且会经常在实例化容器的时候使用到它。但是内部类的具体细节语法，原理以及实现是什么样的可以不少人都还挺陌生，这里作一篇总结，希望通过这篇总结提高对内部类的认识。</p>
<a id="more"></a>

<hr>
<h2 id="内部类是什么？"><a href="#内部类是什么？" class="headerlink" title="内部类是什么？"></a>内部类是什么？</h2><p>由文章开头可知，内部类的定义为：定义在另一个类或方法中的类。而根据使用场景的不同，内部类还可以分为四种：成员内部类，局部内部类，匿名内部类和静态内部类。每一种的特性和注意事项都不同，下面我们一一说明。</p>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>顾名思义，成员内部类是定义在类内部，作为类的成员的类。如下：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Outer</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Inner</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>特点如下：</p>
<ol>
<li>成员内部类可以被权限修饰符(eg. <code>public,private等</code>)所修饰</li>
<li>成员内部类可以访问外部类的所有成员,（包括<code>private</code>）成员</li>
<li>成员内部类是默认包含了一个指向外部类对象的引用</li>
<li>如同使用<code>this</code>一样，当成员名或方法名发生覆盖时，可以使用外部类的名字加.this指定访问外部类成员。如：<code>Outer.this.name</code></li>
<li>成员内部类不可以定义<code>static</code>成员</li>
<li>成员内部类创建语法：</li>
</ol>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">Outer</span> <span class="keyword">outer</span>=<span class="built_in">new</span> <span class="keyword">Outer</span>();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">Outer</span>.<span class="keyword">Inner</span> <span class="keyword">inner</span>=<span class="keyword">outer</span>.<span class="built_in">new</span> <span class="keyword">Inner</span>();</span></pre></td></tr></table></figure>

<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类是定义在方法或者作用域中类，它和成员内部类的区别仅在于访问权限的不同。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Outer</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> test()&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">class</span> <span class="symbol">Inner</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>特点如下：</p>
<ol>
<li><p>局部内部类不能有访问权限修饰符</p>
</li>
<li><p>局部内部类不能被定义为<code>static</code></p>
</li>
<li><p>局部内部类不能定义<code>static</code>成员</p>
</li>
<li><p>局部内部类默认包含了外部类对象的引用</p>
</li>
<li><p>局部内部类也可以使用<code>Outer.this</code>语法制定访问外部类成员</p>
</li>
<li><p>局部内部类想要使用方法或域中的变量,该变量必须是</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span></span></pre></td></tr></table></figure>

<p>的</p>
<blockquote>
<p>在JDK1.8 以后，没有<code>final</code>修饰，<code>effectively final</code>的即可。什么意思呢？就是没有<code>final</code>修饰，但是如果加上<code>final</code>编译器也不会报错即可。</p>
</blockquote>
</li>
</ol>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类是与继承合并在一起的没有名字的内部类</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span>=<span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;()&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            add(<span class="string">"test"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这是我们平时最常用的语法。<br>匿名内部类的特点如下：</p>
<ol>
<li>匿名内部类使用单独的块表示初始化块<code>{}</code></li>
<li>匿名内部类想要使用方法或域中的变量，该变量必须是<code>final</code>修饰的，JDK1.8之后<code>effectively final</code>也可以</li>
<li>匿名内部类默认包含了外部类对象的引用</li>
<li>匿名内部类表示继承所<strong>依赖</strong>的类</li>
</ol>
<h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><p>嵌套类是用<code>static</code>修饰的成员内部类</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Outer</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> static <span class="keyword">class</span> <span class="symbol">Inner</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>特点如下：</p>
<ol>
<li><p>嵌套类是四种类中唯一一个不包含对外部类对象的引用的内部类</p>
</li>
<li><p>嵌套类可以定义<code>static</code>成员</p>
</li>
<li><p>嵌套类能访问外部类任何静态数据成员与方法。</p>
<blockquote>
<p>构造函数可以看作静态方法，因此可以访问。</p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="为什么要有内部类？"><a href="#为什么要有内部类？" class="headerlink" title="为什么要有内部类？"></a>为什么要有内部类？</h2><p>从上面可以看出，内部类的特性和类方差不多，但是内部类有许多繁琐的细节语法。既然内部类有这么多的细节要注意，那为什么Java还要支持内部类呢？</p>
<h3 id="1-完善多重继承"><a href="#1-完善多重继承" class="headerlink" title="1. 完善多重继承"></a>1. 完善多重继承</h3><ol>
<li>在早期C++作为面向对象编程语言的时候，最难处理的也就是多重继承，多重继承对于代码耦合度，代码使用人员的理解来说，并不怎么友好，并且还要比较出名的死亡菱形的多重继承问题。因此Java并不支持多继承。</li>
<li>后来，Java设计者发现，没有多继承，一些代码友好的设计与编程问题变得十分难以解决。于是便产生了内部类。内部类具有：隐式包含外部类对象并且能够与之通信的特点，完美的解决了多重继承的问题。</li>
</ol>
<h3 id="2-解决多次实现-继承问题"><a href="#2-解决多次实现-继承问题" class="headerlink" title="2. 解决多次实现/继承问题"></a>2. 解决多次实现/继承问题</h3><ol>
<li>有时候在一个类中，需要多次通过不同的方式实现同一个接口，如果没有内部类，必须多次定义不同数量的类，但是使用内部类可以很好的解决这个问题，每个内部类都可以实现同一个接口，即实现了代码的封装，又实现了同一接口不同的实现。</li>
<li>内部类可以将组合的实现封装在内部中。</li>
</ol>
<hr>
<h2 id="为什么内部类的语法这么繁杂"><a href="#为什么内部类的语法这么繁杂" class="headerlink" title="为什么内部类的语法这么繁杂"></a>为什么内部类的语法这么繁杂</h2><p>这一点是本文的重点。内部类语法之所以这么繁杂，是因为它是新数据类型加语法糖的结合。想要理解内部类，还得从本质上出发.<br>内部类根据应用场景的不同分为4种。其应用场景完全可以和类方法对比起来。<br>下面我们通过类方法对比的模式一一解答为什么内部类会有这样的特点</p>
<h3 id="成员内部类——-gt-成员方法"><a href="#成员内部类——-gt-成员方法" class="headerlink" title="成员内部类——&gt;成员方法"></a>成员内部类——&gt;成员方法</h3><p>成员内部类的设计完全和成员方法一样。<br>调用成员方法：<code>outer.getName()</code><br>新建内部类对象:<code>outer.new Inner()</code><br>它们都是要依赖对象而被调用。<br>正如《Thinking in Java》所说，<code>outer.getName()</code>正真的形似是<code>Outer.getName(outer)</code>,也就是将调用对象作为参数传递给方法。<br>新建一个内部类也是这样：<code>Outer.new Inner(outer)</code><br>下面，我们用实际情况证明：<br>新建一个包含内部类的类：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Outer</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> m = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Inner</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">private</span> <span class="built_in">void</span> test() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//访问外部类private成员</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            System.<span class="keyword">out</span>.println(m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>编译，会发现会在编译目标目录生成两个.class文件：<code>Outer.class</code>和<code>Outer$Inner.class</code>。</p>
<blockquote>
<p>PS:不知道为什么Java总是和过不去，就连变量命名规则都要比C++多一个能由组成 ：）</p>
</blockquote>
<p>将<code>Outer$Inner.class</code>放入IDEA中打开，会自动反编译，查看结果：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Outer</span>$<span class="symbol">Inner</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> Outer$Inner(Outer <span class="keyword">this</span>$<span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = <span class="keyword">this</span>$<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="built_in">void</span> test() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(Outer.access$<span class="number">000</span>(<span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看见，编译器已经自动生成了一个默认构造器，这个默认构造器是一个带有外部类型引用的参数构造器。<br>可以看到外部类成员对象的引用：Outer是由<code>final</code>修饰的。<br>因此：</p>
<ol>
<li>成员内部类作为类级成员，因此能被访问修饰符所修饰</li>
<li>成员内部类中包含创建内部类时对外部类对象的引用，所以成员内部类能访问外部类的所有成员。</li>
<li>语法规定：因为它作为外部类的一部分成员，所以即使<code>private</code>的对象，内部类也能访问。。通过Outer.access$ 指令访问</li>
<li>如同非静态方法不能访问静态成员一样，非静态内部类也被设计的不能拥有静态变量，因此内部类不能定义<code>static</code>对象和方法。</li>
</ol>
<blockquote>
<p>但是可以定义<code>static final</code>变量，这并不冲突，因为所定义的<code>final</code>字段必须是编译时确定的，而且在编译类时会将对应的变量替换为具体的值，所以在JVM看来，并没有访问内部类。</p>
</blockquote>
<h3 id="局部内部类——-gt-局部代码块"><a href="#局部内部类——-gt-局部代码块" class="headerlink" title="局部内部类——&gt; 局部代码块"></a>局部内部类——&gt; 局部代码块</h3><p>局部内部类可以和局部代码块相理解。它最大的特点就是只能访问外部的<code>final</code>变量。<br>先别着急问为什么。<br>定义一个局部内部类：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Outer</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="built_in">void</span> test() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">int</span>  m= <span class="number">3</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">class</span> <span class="symbol">Inner</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">private</span> <span class="built_in">void</span> print() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                System.<span class="keyword">out</span>.println(m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>编译，发现生成两个.class文件<code>Outer.class</code>和<code>Outer$1Inner.class</code><br>将<code>Outer$1Inner.class</code>放入IDEA中反编译：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Outer</span>$<span class="symbol">1Inner</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    Outer$<span class="number">1</span>Inner(Outer <span class="keyword">this</span>$<span class="number">0</span>, <span class="built_in">int</span> var2) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = <span class="keyword">this</span>$<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.val$m = var2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="built_in">void</span> print() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        System.<span class="keyword">out</span>.println(<span class="keyword">this</span>.val$m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看见，编译器自动生成了带有两个参数的默认构造器。<br>看到这里，也许应该能明了：我们将代码转换下：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> <span class="keyword">Outer</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    private <span class="type">void</span> test() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="type">int</span>  m= <span class="number">3</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">Inner</span> <span class="keyword">inner</span>=<span class="built_in">new</span> <span class="keyword">Outer</span><span class="meta">$1</span><span class="keyword">Inner</span>(this,m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">inner</span>.print();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>也就是在Inner中，其实是将m的值，拷贝到内部类中的。<code>print()</code>方法只是输出了m，如果我们写出了这样的代码：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">void</span> test() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">int</span>  m= <span class="number">3</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">class</span> <span class="symbol">Inner</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">private</span> <span class="built_in">void</span> print() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            m=<span class="number">4</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    System.<span class="keyword">out</span>.println(m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在我们看来,m的值应该被修改为4，但是它真正的效果是：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> m = <span class="number">3</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">print</span>(m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    System.out.<span class="built_in">println</span>(m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    m=<span class="number">4</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>m被作为参数拷贝进了方法中。因此修改它的值其实没有任何效果，所以为了不让程序员随意修改m而却没达到任何效果而迷惑，m必须被<code>final</code>修饰。<br><strong>绕了这么大一圈，为什么编译器要生成这样的效果呢?</strong><br>其实，了解闭包的概念的人应该都知道原因。而Java中各种诡异的语法一般都是由生命周期带来的影响。上面的程序中，m是一个局部变量，它被定义在栈上，而<code>new Outer$1Inner(this,m);</code>所生成的对象，是定义在堆上的。如果不将m作为成员变量拷贝进对象中，那么离开m的作用域，<code>Inner</code>对象所指向的便是一个无效的地址。因此，编译器会自动将局部类所使用的所有参数自动生成成员。</p>
<blockquote>
<p>为什么其他语言没有这种现象呢？<br>这又回到了一个经典的问题上：Java是值传递还是引用传递。由于Java <strong>always pass-by-value</strong>，对于真正的引用，Java是无法传递过去的。而上面的问题核心就在与m如果被改变了，那么其它的m的副本是无法感知到的。而其他语言都通过其他的途径解决了这个问题。<br><em>对于C++就是一个指针问题</em>。</p>
</blockquote>
<p>理解了真正的原因，便也能知道什么时候需要<code>final</code>，什么时候不需要<code>final</code>了。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Outer</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="built_in">void</span> test() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">class</span> <span class="symbol">Inner</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">int</span> m=<span class="number">3</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">private</span> <span class="built_in">void</span> print() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                System.<span class="keyword">out</span>.println(m);<span class="comment">//作为参数传递，本身都已经 pass-by-value。不用final</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                <span class="built_in">int</span> c=m+<span class="number">1</span>; <span class="comment">//直接使用m，需要加final</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>而在Java 8 中，已经放宽政策，允许是<code>effectively final</code>的变量，实际上，就是编译器在编译的过程中，帮你加上<code>final</code>而已。而你应该保证允许编译器加上<code>final</code>后，程序不报错。</p>
<ol>
<li>局部内部类还有个特点就是不能有权限修饰符。就好像局部变量不能有访问修饰符一样</li>
<li>由上面可以看到，外部对象同样是被传入局部类中，因此局部类可以访问外部对象</li>
</ol>
<h3 id="嵌套类——-gt-静态方法"><a href="#嵌套类——-gt-静态方法" class="headerlink" title="嵌套类——&gt;静态方法"></a>嵌套类——&gt;静态方法</h3><p>嵌套类没什么好说的，就好像静态方法一样，他可以被直接访问，他也能定义静态变量。同时不能访问非静态成员。<br>值得注意的是《Think in Java》中说过，可以将构造函数看作为静态方法，因此嵌套类可以访问外部类的构造方法。</p>
<h3 id="匿名类——-gt-局部方法-继承的语法糖"><a href="#匿名类——-gt-局部方法-继承的语法糖" class="headerlink" title="匿名类——&gt;局部方法+继承的语法糖"></a>匿名类——&gt;局部方法+继承的语法糖</h3><p>匿名类可以看作是对前3种类的再次扩展。具体来说匿名类根据应用场景可以看作：</p>
<ul>
<li>成员内部类+继承</li>
<li>局部内部类+继承</li>
<li>嵌套内部类+继承</li>
</ul>
<p>匿名类语法为:</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type"></span>继承类名()&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//Override 重载的方法</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>返回的结果会向上转型为继承类。<br>声明一个匿名类：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span>  List&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span>=<span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;()&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            add(<span class="string">"test"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这便是一个经典的匿名类用法。<br>同样编译上面代码会看到生成了两个.class文件<code>Outer.class</code>,<code>Outer$1.class</code><br>将<code>Outer$1.class</code>放入IDEA中反编译：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer$1</span> <span class="keyword">extends</span> <span class="title">ArrayList&lt;String&gt;</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="type">Outer</span>$<span class="number">1</span>(<span class="type">Outer</span> <span class="keyword">this</span>$<span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = <span class="keyword">this</span>$<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.add(<span class="string">"1"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看到匿名类的完整语法便是继承+内部类。<br>由于匿名类可以申明为成员变量，局部变量，静态成员变量，因此它的组合便是几种内部类加继承的语法糖，这里不一一证明。<br>在这里值得注意的是匿名类由于没有类名，因此不能通过语法糖像正常的类一样声明构造函数，但是编译器可以识别<code>{}</code>,并在编译的时候将代码放入构造函数中。</p>
<blockquote>
<p><code>{}</code>可以有多个，会在生成的构造函数中按顺序执行。</p>
</blockquote>
<hr>
<h2 id="怎么正确的使用内部类"><a href="#怎么正确的使用内部类" class="headerlink" title="怎么正确的使用内部类"></a>怎么正确的使用内部类</h2><p>在第二小节中，我们已经讨论过内部类的应用场景，但是如何优雅，并在正确的应用场景使用它呢？本小节将会详细讨论。</p>
<h3 id="1-注意内存泄露"><a href="#1-注意内存泄露" class="headerlink" title="1.注意内存泄露"></a>1.<strong>注意内存泄露</strong></h3><p>《Effective Java》第二十四小节明确提出过。优先使用静态内部类。这是为什么呢？<br>由上面的分析我们可以知道，除了嵌套类，其他的内部类都隐式包含了外部类对象。这便是Java内存泄露的源头。看代码：<br>定义Outer：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span>  List&lt;<span class="keyword">String</span>&gt; getList(<span class="keyword">String</span> item) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;<span class="keyword">String</span>&gt;() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">                add(item);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用Outer:</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;<span class="keyword">String</span>&gt; getOutersList()&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    Outer outer=<span class="keyword">new</span> Outer();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//do something</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    List&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span>=outer.getList(<span class="string">"test"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">       List&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span>=getOutersList();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">//do something with list</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>相信这样的代码一定有同学写出来，这涉及到一个习惯的问题：<br><strong>不涉及到类成员方法和成员变量的方法，最好定义为static</strong><br>我们先研究上面的代码，最大的问题便是带来的内存泄露：<br>在使用过程中，我们定义<code>Outer</code>对象完成一系列的动作</p>
<ul>
<li>使用<code>outer</code>得到了一个<code>ArraList</code>对象</li>
<li>将<code>ArrayList</code>作为结果返回出去。</li>
</ul>
<p>正常来说，在<code>getOutersList</code>方法中，我们<code>new</code>出来了两个对象：<code>outer</code>和<code>list</code>，而在离开此方法时，我们只将<code>list</code>对象的引用传递出去,<code>outer</code>的引用随着方法栈的退出而被销毁。按道理来说，<code>outer</code>对象此时应该没有作用了，也应该在下一次内存回收中被销毁。<br><strong>然而</strong>,事实并不是这样。按上面所说的，新建的<code>list</code>对象是默认包含对<code>outer</code>对象的引用的，因此只要<code>list</code>不被销毁，<code>outer</code>对象将会一直存在，然而我们并不需要<code>outer</code>对象，这便是内存泄露。<br><strong>怎么避免这种情况呢？</strong><br>很简单：<strong>不涉及到类成员方法和成员变量的方法，最好定义为static</strong></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;<span class="keyword">String</span>&gt; getList(<span class="keyword">String</span> item) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;<span class="keyword">String</span>&gt;() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">                add(item);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这样定义出来的类便是嵌套类+继承，并不包含对外部类的引用。</p>
<h3 id="2-应用于只实现一个接口的实现类"><a href="#2-应用于只实现一个接口的实现类" class="headerlink" title="2.应用于只实现一个接口的实现类"></a>2.应用于只实现一个接口的实现类</h3><ul>
<li>优雅工厂方法模式</li>
</ul>
<p>我们可以看到，在工厂方法模式中，每个实现都会需要实现一个Fractory来实现产生对象的接口，而这样接口其实和原本的类关联性很大的，因此我们可以将Fractory定义在具体的类中，作为内部类存在</p>
<ul>
<li>简单的实现接口</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">new</span> Thread(<span class="built_in">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">public</span> <span class="type">void</span> run() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("test");</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;).<span class="keyword">start</span>();</span></pre></td></tr></table></figure>

<blockquote>
<p>尽量不要直接使用Thread，这里只做演示使用<br>Java 8 的话建议使用lambda代替此类应用</p>
</blockquote>
<ul>
<li>同时实现多个接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">imple</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Eat <span class="title">getDogEat</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EatDog();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Eat <span class="title">getCatEat</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EatCat();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EatDog</span> <span class="keyword">implements</span> <span class="title">Eat</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            System.out.println(<span class="string">"dog eat"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EatCat</span> <span class="keyword">implements</span> <span class="title">Eat</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            System.out.println(<span class="string">"cat eat"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="3-优雅的单例类"><a href="#3-优雅的单例类" class="headerlink" title="3.优雅的单例类"></a>3.<strong>优雅的单例类</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Imple</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Imple <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> ImpleHolder.INSTANCE;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ImpleHolder</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Imple INSTANCE=<span class="keyword">new</span> Imple();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="4-反序列化JSON接受的JavaBean"><a href="#4-反序列化JSON接受的JavaBean" class="headerlink" title="4.反序列化JSON接受的JavaBean"></a>4.反序列化JSON接受的JavaBean</h3><p>有时候需要反序列化嵌套JSON</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"student"</span>:&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"name"</span>:<span class="string">""</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"age"</span>:<span class="string">""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>类似这种。我们可以直接定义嵌套类进行反序列化</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> JsonStr&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> Student student;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Student&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">private</span> <span class="keyword">String</span> name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">private</span> <span class="keyword">String</span> age;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//getter &amp; setter</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//getter &amp; setter</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>但是注意，这里应该使用嵌套类，因为我们不需要和外部类进行数据交换。<br>核心思想：</p>
<ul>
<li>嵌套类能够访问外部类的构造函数</li>
<li>将第一次访问内部类放在方法中，这样只有调用这个方法的时候才会第一次访问内部类，实现了懒加载</li>
</ul>
<p>内部类还有很多用法，这里不一一列举。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>内部类的理解可以按照方法来理解，但是内部类很多特性都必须剥开语法糖和明白为什么需要这么做才能完全理解，明白内部类的所有特性才能更好使用内部类，在内部类的使用过程中，一定记住：能使用嵌套类就使用嵌套类，如果内部类需要和外部类联系，才使用内部类。最后<strong>不涉及到类成员方法和成员变量的方法，最好定义为static</strong>可以防止内部类内存泄露。<br>参考文章：<br><a href="https://www.zhihu.com/question/21373020" target="_blank" rel="noopener">Java 中引入内部类的意义？</a><br><a href="https://bbs.csdn.net/topics/390607261" target="_blank" rel="noopener">成员内部类里面为什么不能有静态成员和方法？</a></p>
<blockquote>
<p>作者：dengchengchao_</p>
<p>来源：<a href="https://www.jianshu.com/p/70cd35ec88be" target="_blank" rel="noopener">https://www.jianshu.com/p/70cd35ec88be</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag"># 内部类</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/08/Java-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8/" rel="prev" title="Java 内部类的作用">
      <i class="fa fa-chevron-left"></i> Java 内部类的作用
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/08/%E6%90%9E%E6%87%82-Java-%E5%86%85%E9%83%A8%E7%B1%BB/" rel="next" title="搞懂 Java 内部类">
      搞懂 Java 内部类 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#内部类是什么？"><span class="nav-number">1.</span> <span class="nav-text">内部类是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#成员内部类"><span class="nav-number">1.1.</span> <span class="nav-text">成员内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#局部内部类"><span class="nav-number">1.2.</span> <span class="nav-text">局部内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匿名内部类"><span class="nav-number">1.3.</span> <span class="nav-text">匿名内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌套类"><span class="nav-number">1.4.</span> <span class="nav-text">嵌套类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要有内部类？"><span class="nav-number">2.</span> <span class="nav-text">为什么要有内部类？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-完善多重继承"><span class="nav-number">2.1.</span> <span class="nav-text">1. 完善多重继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-解决多次实现-继承问题"><span class="nav-number">2.2.</span> <span class="nav-text">2. 解决多次实现/继承问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么内部类的语法这么繁杂"><span class="nav-number">3.</span> <span class="nav-text">为什么内部类的语法这么繁杂</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#成员内部类——-gt-成员方法"><span class="nav-number">3.1.</span> <span class="nav-text">成员内部类——&gt;成员方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#局部内部类——-gt-局部代码块"><span class="nav-number">3.2.</span> <span class="nav-text">局部内部类——&gt; 局部代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌套类——-gt-静态方法"><span class="nav-number">3.3.</span> <span class="nav-text">嵌套类——&gt;静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匿名类——-gt-局部方法-继承的语法糖"><span class="nav-number">3.4.</span> <span class="nav-text">匿名类——&gt;局部方法+继承的语法糖</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么正确的使用内部类"><span class="nav-number">4.</span> <span class="nav-text">怎么正确的使用内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-注意内存泄露"><span class="nav-number">4.1.</span> <span class="nav-text">1.注意内存泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-应用于只实现一个接口的实现类"><span class="nav-number">4.2.</span> <span class="nav-text">2.应用于只实现一个接口的实现类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-优雅的单例类"><span class="nav-number">4.3.</span> <span class="nav-text">3.优雅的单例类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-反序列化JSON接受的JavaBean"><span class="nav-number">4.4.</span> <span class="nav-text">4.反序列化JSON接受的JavaBean</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">congsheng.wang</p>
  <div class="site-description" itemprop="description">trouble is a friend</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">984</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">94</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">156</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">congsheng.wang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
