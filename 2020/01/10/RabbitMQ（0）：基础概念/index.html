<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://congsheng.wang').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="前言说 RabbitMQ 之前先说两个概念：Message Broker 和 AMQPMessage Broker 是一种消息验证、传输、路由的架构模式，其设计目标主要应用于下面这些场景：  消息路由到一个或多个目的地 消息转化为其他的表现方式 执行消息的聚集、消息的分解，并将结果发送到他们的目的地，然后重新组合相应返回给消息用户 调用 Web 服务来检索数据 响应事件或错误 使用发布 - 订阅模">
<meta name="keywords" content="RabbitMQ">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ（0）：基础概念">
<meta property="og:url" content="http:&#x2F;&#x2F;congsheng.wang&#x2F;2020&#x2F;01&#x2F;10&#x2F;RabbitMQ%EF%BC%880%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5&#x2F;index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="前言说 RabbitMQ 之前先说两个概念：Message Broker 和 AMQPMessage Broker 是一种消息验证、传输、路由的架构模式，其设计目标主要应用于下面这些场景：  消息路由到一个或多个目的地 消息转化为其他的表现方式 执行消息的聚集、消息的分解，并将结果发送到他们的目的地，然后重新组合相应返回给消息用户 调用 Web 服务来检索数据 响应事件或错误 使用发布 - 订阅模">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;11&#x2F;50a01-006tNc79ly1fqb11pbpvmj315o0yb7al.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;11&#x2F;c2ef9-006tKfTcly1fq9swsyzwsj303m02j0ol.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;11&#x2F;81e6b-006tNc79ly1fq9t95xao1j30aw01mdfo.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;11&#x2F;30cab-006tNc79ly1fq9tchttwrj3098033746.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;11&#x2F;4d425-006tNc79ly1fq9vpp4wt2j30b0033glj.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;11&#x2F;45907-006tNc79ly1fq9vqnj3afj3098032mx0.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;11&#x2F;4e4dd-006tNc79ly1fq9vs0frsxj308y02i3yd.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;11&#x2F;94b11-006tNc79ly1fq9vsh653mj309504g3yg.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;11&#x2F;5f77e-006tNc79ly1fq9vswvmt0j30br04rjrf.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;11&#x2F;67203-006tNc79ly1fq9vtw1f5sj30bs04raa2.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;11&#x2F;2e8ec-006tNc79ly1fq9vuk7nu2j30g005k3yl.jpg">
<meta property="og:updated_time" content="2020-01-10T14:15:13.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;11&#x2F;50a01-006tNc79ly1fqb11pbpvmj315o0yb7al.jpg">

<link rel="canonical" href="http://congsheng.wang/2020/01/10/RabbitMQ%EF%BC%880%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>RabbitMQ（0）：基础概念 | 个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">congsheng的博客</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">156</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">94</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">984</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://congsheng.wang/2020/01/10/RabbitMQ%EF%BC%880%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="congsheng.wang">
      <meta itemprop="description" content="trouble is a friend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RabbitMQ（0）：基础概念
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-10 22:15:13" itemprop="dateCreated datePublished" datetime="2020-01-10T22:15:13+08:00">2020-01-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B6%E5%AE%83%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">其它技术</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B6%E5%AE%83%E6%8A%80%E6%9C%AF/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index">
                    <span itemprop="name">消息队列</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说 RabbitMQ 之前先说两个概念：Message Broker 和 AMQP<br>Message Broker 是一种消息验证、传输、路由的架构模式，其设计目标主要应用于下面这些场景：</p>
<ul>
<li>消息路由到一个或多个目的地</li>
<li>消息转化为其他的表现方式</li>
<li>执行消息的聚集、消息的分解，并将结果发送到他们的目的地，然后重新组合相应返回给消息用户</li>
<li>调用 Web 服务来检索数据</li>
<li>响应事件或错误</li>
<li>使用发布 - 订阅模式来提供内容或基于主题的消息路由</li>
</ul>
<a id="more"></a>

<p>AMQP 是 Advanced Message Queuing Protocol 的简称，它是一个面向消息中间件的开放式标准应用层协议。AMQP 定义了这些特性：</p>
<ul>
<li>消息方向</li>
<li>消息队列</li>
<li>消息路由（包括：点到点和发布 - 订阅模式）</li>
<li>可靠性</li>
<li>安全性</li>
</ul>
<p>本文要介绍的 RabbitMQ 就是以 AMQP 协议实现的一种中间件产品，服务器端用 Erlang 语言编写，它可以支持多种操作系统，多种编程语言，几乎可以覆盖所有主流的企业级技术平台。本文主要重点介绍 RabbitMQ 中的一些基础概念，了解了这些概念，可以为后边的使用 RabbitMQ 打下良好的基础。<br><a href="http://image.winrains.cn/2019/11/50a01-006tNc79ly1fqb11pbpvmj315o0yb7al.jpg" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/11/50a01-006tNc79ly1fqb11pbpvmj315o0yb7al.jpg" alt="img"></a></p>
<h1 id="ConnectionFactory、Connection、Channel"><a href="#ConnectionFactory、Connection、Channel" class="headerlink" title="ConnectionFactory、Connection、Channel"></a>ConnectionFactory、Connection、Channel</h1><p>ConnectionFactory、Connection、Channel 都是 RabbitMQ 对外提供的 API 中最基本的对象。</p>
<ul>
<li>Connection 是 RabbitMQ 的 socket 链接，它封装了 socket 协议相关部分逻辑。</li>
<li>ConnectionFactory 为 Connection 的制造工厂。</li>
<li>Channel 是我们与 RabbitMQ 打交道的最重要的一个接口，我们大部分的业务操作是在 Channel 这个接口中完成的，包括定义 Queue、定义 Exchange、绑定 Queue 与 Exchange、发布消息等。</li>
</ul>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>Queue（队列）是 RabbitMQ 的内部对象，用于存储消息，用下图表示。<br><a href="http://image.winrains.cn/2019/11/c2ef9-006tKfTcly1fq9swsyzwsj303m02j0ol.jpg" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/11/c2ef9-006tKfTcly1fq9swsyzwsj303m02j0ol.jpg" alt="img"></a><br>RabbitMQ 中的消息都只能存储在 Queue 中，生产者（下图中的 P）生产消息并最终投递到 Queue 中，消费者（下图中的 C）可以从 Queue 中获取消息并消费。<br><a href="http://image.winrains.cn/2019/11/81e6b-006tNc79ly1fq9t95xao1j30aw01mdfo.jpg" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/11/81e6b-006tNc79ly1fq9t95xao1j30aw01mdfo.jpg" alt="img"></a><br>多个消费者可以订阅同一个 Queue，这时 Queue 中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。<br><a href="http://image.winrains.cn/2019/11/30cab-006tNc79ly1fq9tchttwrj3098033746.jpg" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/11/30cab-006tNc79ly1fq9tchttwrj3098033746.jpg" alt="img"></a></p>
<h1 id="Message-acknowledgment"><a href="#Message-acknowledgment" class="headerlink" title="Message acknowledgment"></a>Message acknowledgment</h1><p>在实际应用中，可能会发生消费者收到 Queue 中的消息，但没有处理完成就宕机（或出现其他意外）的情况，这种情况下就可能会导致消息丢失。<br>为了避免这种情况发生，我们可以要求消费者在消费完消息后发送一个回执给 RabbitMQ，RabbitMQ 收到消息回执（Message acknowledgment）后才将该消息从 Queue 中移除；如果 RabbitMQ 没有收到回执并检测到消费者的 RabbitMQ 连接断开，则 RabbitMQ 会将该消息发送给其他消费者（如果存在多个消费者）进行处理。<br>这里不存在 timeout 概念，一个消费者处理消息时间再长也不会导致该消息被发送给其他消费者，除非它的 RabbitMQ 连接断开。<br>这里会产生另外一个问题，如果我们在处理完业务逻辑后，忘记发送回执给 RabbitMQ，这是个常见的低级错误，但是后果却是很严重的 ——Queue 中堆积的消息会越来越多，消费者重启后会重复消费这些消息并重复执行业务逻辑，周而复始。<br>Spring AMQP 通过默认配置避免了忘记 basicACK 这种情况，所以我们并不需要特别关注。<br>另外，pub message 是没有 ack 的。</p>
<h1 id="Message-durability"><a href="#Message-durability" class="headerlink" title="Message durability"></a>Message durability</h1><p>如果我们希望即使在 RabbitMQ 服务重启的情况下，也不会丢失消息，我们可以将 Queue 与 Message 都设置为可持久化的（durable），这样可以保证绝大部分情况下我们的 RabbitMQ 消息不会丢失。<br>但是，请注意，这并不能完全保证就一定丢不了消息，因为 RabbitMQ 不会为每条消息执行 <code>fsync(2)</code>，它可能只是保存到缓存中，并没有真正写入磁盘。如果我们需要对这种小概率事件（比如 RabbitMQ 服务器已经接收到生产者的消息，但还没来得及持久化该消息时 RabbitMQ 服务器就断电了）也要管理起来，那么我们要用到事务。由于这里仅为 RabbitMQ 的简单介绍，所以这里将不讲解 RabbitMQ 相关的事务。<br>Spring AMQP 通过在 MessageProperties 中设置了合理默认值来定义消息的持久性。参考 <a href="https://docs.spring.io/spring-amqp/reference/htmlsingle/#_common_properties" target="_blank" rel="noopener">common properties</a></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>durable</td>
<td>true</td>
<td>当 declareExchange 为 true 时，持久化标志被设置为该值</td>
</tr>
<tr>
<td>deliveryMode</td>
<td>PERSISTENT</td>
<td>PERSISTENT 或 NON_PERSISTENT 来确定 RabbitMQ 是否持久化消息</td>
</tr>
</tbody></table>
<h1 id="Prefetch-count"><a href="#Prefetch-count" class="headerlink" title="Prefetch count"></a>Prefetch count</h1><p>默认情况下，如果有多个消费者同时订阅同一个 Queue 中的消息，Queue 中的消息会被平摊给多个消费者。平均而言，每个消费者将获得相同数量的消息。这种分配消息的方式称为循环调度（Round-robin）。这时如果每个消息的处理时间不同，就有可能会导致某些消费者一直在忙，而另外一些消费者很快就处理完手头工作并一直空闲的情况。我们可以通过设置 prefetchCount 来限制 Queue 每次发送给每个消费者的消息数，比如我们设置 prefetchCount=1，则 Queue 每次给每个消费者发送一条消息；消费者处理完这条消息后 Queue 会再给该消费者发送一条消息。<br><a href="http://image.winrains.cn/2019/11/4d425-006tNc79ly1fq9vpp4wt2j30b0033glj.jpg" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/11/4d425-006tNc79ly1fq9vpp4wt2j30b0033glj.jpg" alt="img"></a><br>至于如果使用 Spring AMQP 的话，RabbitMQ 的<a href="https://www.rabbitmq.com/tutorials/tutorial-two-spring-amqp.html" target="_blank" rel="noopener">文档</a>说公平调度（Fair dispatch）是 Spring AMQP 的默认配置，但是我实验发现默认的好像是循环调度。另外，官方文档里说</p>
<blockquote>
<p>The SimpleMessageListenerContainer defines the value for DEFAULT_PREFETCH_COUNT to be 1. If the DEFAULT_PREFECTH_COUNT were set to 0 the behavior would be round robin messaging as described above.</p>
</blockquote>
<p>但是我只在 <code>AbstractMessageListenerContainer</code> 中找到了 <code>DEFAULT_PREFETCH_COUNT = 250</code>。不知道是不是因为版本的问题，待确认。<br>2018-04-13 Update：<br><strong>经过阅读源码与测试，在我所使用的版本（Spring Boot: 2.0.1.RELEASE）中，<code>DEFAULT_PREFETCH_COUNT</code> 定义在 <code>AbstractMessageListenerContainer</code> 类中，且默认值为 <code>250</code>，默认配置为循环调度。具体详情请看<a href="https://windmt.com/2018/04/12/rabbitmq-2-work-queues/" target="_blank" rel="noopener">工作队列</a> 中的 prefetch 一节</strong></p>
<h1 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h1><p>之前我们看到生产者将消息投递到 Queue 中，实际上这在 RabbitMQ 中这种事情永远都不会发生。实际的情况是，生产者将消息发送到 Exchange（交换器，下图中的 X），由 Exchange 将消息路由到一个或多个 Queue 中（或者丢弃）。<br><a href="http://image.winrains.cn/2019/11/45907-006tNc79ly1fq9vqnj3afj3098032mx0.jpg" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/11/45907-006tNc79ly1fq9vqnj3afj3098032mx0.jpg" alt="img"></a><br>Exchange 是按照什么逻辑将消息路由到 Queue 的？这个将在 Binding 一节介绍。RabbitMQ 中的 Exchange 有四种类型，不同的类型有着不同的路由策略，这将在 Exchange Types 一节介绍。</p>
<h1 id="Routing-key"><a href="#Routing-key" class="headerlink" title="Routing key"></a>Routing key</h1><p>生产者在将消息发送给 Exchange 的时候，一般会指定一个 routing key，来指定这个消息的路由规则，而这个 routing key 需要与 Exchange Type 及 binding key 联合使用才能最终生效。在 Exchange Type 与 binding key 固定的情况下（在正常使用时一般这些内容都是固定配置好的），我们的生产者就可以在发送消息给 Exchange 时，通过指定 routing key 来决定消息流向哪里。RabbitMQ 为 routing key 设定的长度限制为 255 bytes。</p>
<h1 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h1><p>RabbitMQ 中通过 Binding 将 Exchange 与 Queue 关联起来，这样 RabbitMQ 就知道如何正确地将消息路由到指定的 Queue 了。<br><a href="http://image.winrains.cn/2019/11/4e4dd-006tNc79ly1fq9vs0frsxj308y02i3yd.jpg" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/11/4e4dd-006tNc79ly1fq9vs0frsxj308y02i3yd.jpg" alt="img"></a></p>
<h1 id="Binding-key"><a href="#Binding-key" class="headerlink" title="Binding key"></a>Binding key</h1><p>在绑定（Binding）Exchange 与 Queue 的同时，一般会指定一个 binding key；消费者将消息发送给 Exchange 时，一般会指定一个 routing key；当 binding key 与 routing key 相匹配时，消息将会被路由到对应的 Queue 中。这个将在下边 Exchange Types 一节中列举实际的例子加以说明。在绑定多个 Queue 到同一个 Exchange 的时候，这些 Binding 允许使用相同的 binding key。binding key 并不是在所有情况下都生效，它依赖于 Exchange Type，比如 fanout 类型的 Exchange 就会无视 binding key，而是将消息路由到所有绑定到该 Exchange 的 Queue。</p>
<h1 id="Exchange-Types"><a href="#Exchange-Types" class="headerlink" title="Exchange Types"></a>Exchange Types</h1><p>RabbitMQ 常用的 Exchange Type 有 fanout、direct、topic、headers 这四种（AMQP 规范里还提到两种 Exchange Type，分别为 system 与自定义，这里不予以描述），下面分别进行介绍。</p>
<h2 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h2><p>fanout 类型的 Exchange 路由规则非常简单，它会把所有发送到该 Exchange 的消息路由到所有与它绑定的 Queue 中。<br><a href="http://image.winrains.cn/2019/11/94b11-006tNc79ly1fq9vsh653mj309504g3yg.jpg" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/11/94b11-006tNc79ly1fq9vsh653mj309504g3yg.jpg" alt="img"></a><br>上图中，生产者（P）发送到 Exchange（X）的所有消息都会路由到图中的两个 Queue，并最终被两个消费者（C1 与 C2）消费。</p>
<h2 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h2><p>direct 类型的 Exchange 路由规则也很简单，它会把消息路由到那些 binding key 与 routing key 完全匹配的 Queue 中。<br><a href="http://image.winrains.cn/2019/11/5f77e-006tNc79ly1fq9vswvmt0j30br04rjrf.jpg" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/11/5f77e-006tNc79ly1fq9vswvmt0j30br04rjrf.jpg" alt="img"></a><br>以上图的配置为例，我们以 routingKey=”error” 发送消息到 Exchange，则消息会路由到 Queue1（amqp.gen-S9b…，这是由 RabbitMQ 自动生成的 Queue 名称）和 Queue2（amqp.gen-Agl…）；如果我们以 routingKey=”info” 或 routingKey=”warning” 来发送消息，则消息只会路由到 Queue2。如果我们以其他 routingKey 发送消息，则消息不会路由到这两个 Queue 中。</p>
<h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><p>前面讲到 direct 类型的 Exchange 路由规则是完全匹配 binding key 与 routing key，但这种严格的匹配方式在很多情况下不能满足实际业务需求。topic 类型的 Exchange 在匹配规则上进行了扩展，它与 direct 类型的 Exchange 相似，也是将消息路由到 binding key 与 routing key 相匹配的 Queue 中，但这里的匹配规则有些不同，它约定：</p>
<ul>
<li>routing key 为一个句点号<code>.</code> 分隔的字符串（我们将被句点号<code>.</code> 分隔开的每一段独立的字符串称为一个单词），如 “stock.usd.nyse”、”nyse.vmw”、”quick.orange.rabbit”</li>
<li>binding key 与 routing key 一样也是句点号<code>.</code> 分隔的字符串</li>
<li>binding key 中可以存在两种特殊字符 <code>*</code> 与<code>#</code>，用于做模糊匹配，其中 <code>*</code> 用于匹配一个单词，<code>#</code>用于匹配多个单词（可以是零个）</li>
</ul>
<p><a href="http://image.winrains.cn/2019/11/67203-006tNc79ly1fq9vtw1f5sj30bs04raa2.jpg" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/11/67203-006tNc79ly1fq9vtw1f5sj30bs04raa2.jpg" alt="img"></a><br>以上图中的配置为例:<br>routingKey=”quick.orange.rabbit” 的消息会同时路由到 Q1 与 Q2<br>routingKey=”lazy.orange.fox” 的消息会路由到 Q1 与 Q2<br>routingKey=”lazy.brown.fox” 的消息会路由到 Q2<br>routingKey=”lazy.pink.rabbit” 的消息会路由到 Q2（只会投递给 Q2 一次，虽然这个 routingKey 与 Q2 的两个 bindingKey 都匹配）<br>routingKey=”quick.brown.fox”、routingKey=”orange”、routingKey=”quick.orange.male.rabbit” 的消息将会被丢弃，因为它们没有匹配任何 bindingKey</p>
<h2 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h2><p>headers 类型的 Exchange 不依赖于 routing key 与 binding key 的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定 Queue 与 Exchange 时指定一组键值对；当消息发送到 Exchange 时，RabbitMQ 会取到该消息的 headers（也是一个键值对的形式），对比其中的键值对是否完全匹配 Queue 与 Exchange 绑定时指定的键值对；如果完全匹配则消息会路由到该 Queue，否则不会路由到该 Queue。该类型的 Exchange 没有用到过（不过也应该很有用武之地），所以不做介绍。</p>
<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>MQ 本身是基于异步的消息处理，前面的示例中所有的生产者（P）将消息发送到 RabbitMQ 后不会知道消费者（C）处理成功或者失败（甚至连有没有消费者来处理这条消息都不知道）。但实际的应用场景中，我们很可能需要一些同步处理，需要同步等待服务端将我的消息处理完成后再进行下一步处理。这相当于 RPC（Remote Procedure Call，远程过程调用）。在 RabbitMQ 中也支持 RPC。<br><a href="http://image.winrains.cn/2019/11/2e8ec-006tNc79ly1fq9vuk7nu2j30g005k3yl.jpg" target="_blank" rel="noopener"><img src="http://image.winrains.cn/2019/11/2e8ec-006tNc79ly1fq9vuk7nu2j30g005k3yl.jpg" alt="img"></a><br>RabbitMQ 中实现 RPC 的机制是：</p>
<ul>
<li>客户端发送请求（消息）时，在消息的属性（<code>MessageProperties</code>，在 <code>AMQP</code> 协议中定义了 14 中 <code>properties</code>，这些属性会随着消息一起发送）中设置两个值 <code>replyTo</code>（一个 <code>Queue</code> 名称，用于告诉服务器处理完成后将通知我的消息发送到这个 <code>Queue</code> 中）和 <code>correlationId</code>（此次请求的标识号，服务器处理完成后需要将此属性返还，客户端将根据这个 id 了解哪条请求被成功执行了或执行失败）</li>
<li>服务器端收到消息并处理</li>
<li>服务器端处理完消息后，将生成一条应答消息到 <code>replyTo</code> 指定的 <code>Queue</code>，同时带上 <code>correlationId</code> 属性</li>
<li>客户端之前已订阅 <code>replyTo</code> 指定的 <code>Queue</code>，从中收到服务器的应答消息后，根据其中的 <code>correlationId</code> 属性分析哪条请求被执行了，根据执行结果进行后续业务处理</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了 RabbitMQ 中个人认为最重要的概念，之后的文章中也会结合具体代码来说明怎么使用。充分利用 RabbitMQ 提供的这些功能就可以处理我们绝大部分的异步业务了。<br>相关文章：</p>
<ol>
<li><a href="https://windmt.com/2018/04/12/rabbitmq-0-introduction/" target="_blank" rel="noopener">RabbitMQ（零）：基础概念</a></li>
<li><a href="https://windmt.com/2018/04/12/rabbitmq-1-hello-world/" target="_blank" rel="noopener">RabbitMQ（一）：Hello World</a></li>
<li><a href="https://windmt.com/2018/04/12/rabbitmq-2-work-queues/" target="_blank" rel="noopener">RabbitMQ（二）：工作队列（Work queues）</a></li>
<li><a href="https://windmt.com/2018/04/12/rabbitmq-3-pub-sub/" target="_blank" rel="noopener">RabbitMQ（三）：发布订阅（Publish/Subscribe）</a></li>
<li><a href="https://windmt.com/2018/04/13/rabbitmq-4-routing/" target="_blank" rel="noopener">RabbitMQ（四）：路由（Routing）</a></li>
<li><a href="https://windmt.com/2018/04/13/rabbitmq-5-topics/" target="_blank" rel="noopener">RabbitMQ（五）：主题（Topics）</a></li>
<li><a href="https://windmt.com/2018/04/13/rabbitmq-6-rpc/" target="_blank" rel="noopener">RabbitMQ（六）：远程过程调用（RPC）</a></li>
</ol>
<blockquote>
<p>作者：windmt</p>
<p>来源：<a href="https://windmt.com/2018/04/12/rabbitmq-0-introduction/" target="_blank" rel="noopener">https://windmt.com/2018/04/12/rabbitmq-0-introduction/</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/RabbitMQ/" rel="tag"># RabbitMQ</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/10/MyBatis-%E4%B8%AD-%E4%B8%8E-%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="prev" title="MyBatis 中 # 与 $ 的区别">
      <i class="fa fa-chevron-left"></i> MyBatis 中 # 与 $ 的区别
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/10/RabbitMQ%EF%BC%881%EF%BC%89%EF%BC%9AHello-World/" rel="next" title="RabbitMQ（1）：Hello World">
      RabbitMQ（1）：Hello World <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ConnectionFactory、Connection、Channel"><span class="nav-number">2.</span> <span class="nav-text">ConnectionFactory、Connection、Channel</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Queue"><span class="nav-number">3.</span> <span class="nav-text">Queue</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Message-acknowledgment"><span class="nav-number">4.</span> <span class="nav-text">Message acknowledgment</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Message-durability"><span class="nav-number">5.</span> <span class="nav-text">Message durability</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Prefetch-count"><span class="nav-number">6.</span> <span class="nav-text">Prefetch count</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Exchange"><span class="nav-number">7.</span> <span class="nav-text">Exchange</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Routing-key"><span class="nav-number">8.</span> <span class="nav-text">Routing key</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Binding"><span class="nav-number">9.</span> <span class="nav-text">Binding</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Binding-key"><span class="nav-number">10.</span> <span class="nav-text">Binding key</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Exchange-Types"><span class="nav-number">11.</span> <span class="nav-text">Exchange Types</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#fanout"><span class="nav-number">11.1.</span> <span class="nav-text">fanout</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#direct"><span class="nav-number">11.2.</span> <span class="nav-text">direct</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#topic"><span class="nav-number">11.3.</span> <span class="nav-text">topic</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#headers"><span class="nav-number">11.4.</span> <span class="nav-text">headers</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RPC"><span class="nav-number">12.</span> <span class="nav-text">RPC</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">13.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">congsheng.wang</p>
  <div class="site-description" itemprop="description">trouble is a friend</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">984</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">94</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">156</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">congsheng.wang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
