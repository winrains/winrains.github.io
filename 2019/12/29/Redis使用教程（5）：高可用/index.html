<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://congsheng.wang').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="6 reids高可用6.1 持久化Redis 持久化提供了多种不同级别的持久化方式：  RDB持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。 AOF持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以">
<meta name="keywords" content="高可用">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis使用教程（5）：高可用">
<meta property="og:url" content="http:&#x2F;&#x2F;congsheng.wang&#x2F;2019&#x2F;12&#x2F;29&#x2F;Redis%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%885%EF%BC%89%EF%BC%9A%E9%AB%98%E5%8F%AF%E7%94%A8&#x2F;index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="6 reids高可用6.1 持久化Redis 持久化提供了多种不同级别的持久化方式：  RDB持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。 AOF持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;3f0f8-1458310260717024010.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;7ef26-1458310811339051979.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;d8633-1458458929970002365.png">
<meta property="og:updated_time" content="2019-12-29T14:30:58.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;3f0f8-1458310260717024010.png">

<link rel="canonical" href="http://congsheng.wang/2019/12/29/Redis%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%885%EF%BC%89%EF%BC%9A%E9%AB%98%E5%8F%AF%E7%94%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Redis使用教程（5）：高可用 | 个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">congsheng的博客</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">111</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">83</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">503</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://congsheng.wang/2019/12/29/Redis%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%885%EF%BC%89%EF%BC%9A%E9%AB%98%E5%8F%AF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="congsheng.wang">
      <meta itemprop="description" content="trouble is a friend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis使用教程（5）：高可用
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-29 22:30:58" itemprop="dateCreated datePublished" datetime="2019-12-29T22:30:58+08:00">2019-12-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">Java技术</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="6-reids高可用"><a href="#6-reids高可用" class="headerlink" title="6 reids高可用"></a>6 reids高可用</h1><h2 id="6-1-持久化"><a href="#6-1-持久化" class="headerlink" title="6.1 持久化"></a>6.1 持久化</h2><p><strong>Redis 持久化</strong><br>提供了多种不同级别的持久化方式：</p>
<ul>
<li><code>RDB</code>持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。</li>
<li><code>AOF</code>持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</li>
<li>你甚至可以关闭持久化功能，让数据只在服务器运行时存在。了解 RDB 持久化和 AOF 持久化之间的异同是非常重要的， 以下几个小节将详细地介绍这这两种持久化功能， 并对它们的相同和不同之处进行说明。</li>
</ul>
<p>Redis的强劲性能很大程度上是由于其将所有数据都存储在了内存中，为了使Redis在重启之后仍能保证数据不丢失，需要将数据从内存中以某种形式同步到硬盘中，这一过程就是持久化。<br>Redis支持两种方式的持久化，一种是<code>RDB</code>方式，一种是<code>AOF</code>方式。可以单独使用其中一种或将二者结合使用。</p>
<a id="more"></a>

<h3 id="6-1-1-RDB方式"><a href="#6-1-1-RDB方式" class="headerlink" title="6.1.1 RDB方式**"></a>6.1.1 RDB方式**</h3><p>RDB方式的持久化是通过快照（<code>snapshotting</code>）完成的，当符合一定条件时Redis会自动将内存中的所有数据进行快照并存储在硬盘上。进行快照的条件可以由用户在配置文件中自定义，由两个参数构成：时间和改动的键的个数。当在指定的时间内被更改的键的个数大于指定的数值时就会进行快照。RDB是Redis默认采用的持久化方式，在配置文件中已经预置了3个条件：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">save <span class="number">300</span> <span class="number">10</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">save <span class="number">60</span> <span class="number">10000</span></span></pre></td></tr></table></figure>

<p>save参数指定了快照条件，可以存在多个条件，条件之间是“或”的关系。如上所说，save900 1的意思是在15分钟（900秒钟）内有至少一个键被更改则进行快照。如果想要禁用自动快照，只需要将所有的save参数删除即可。<br>Redis默认会将快照文件存储在当前目录的<code>dump.rdb</code>文件中，可以通过配置<code>dir</code>和<code>dbfilename</code>两个参数分别指定快照文件的存储路径和文件名。<br>理清Redis实现快照的过程对我们了解快照文件的特性有很大的帮助。快照的过程如下。<br>（1）Redis使用fork函数复制一份当前进程（父进程）的副本（子进程）；<br>（2）父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件；<br>（3）当子进程写入完所有数据后会用该临时文件替换旧的RDB文件，至此一次快照操作完成。<br>在执行<code>fork</code>的时候操作系统（类Unix操作系统）会使用写时复制（copy-on-write）策略，即fork函数发生的一刻父子进程共享同一内存数据，当父进程要更改其中某片数据时（如执行一个写命令），操作系统会将该片数据复制一份以保证子进程的数据不受影响，所以新的RDB文件存储的是执行fork一刻的内存数据。<br>通过上述过程可以发现Redis在进行快照的过程中不会修改RDB文件，只有快照结束后才会将旧的文件替换成新的，也就是说任何时候RDB文件都是完整的。这使得我们可以通过定时备份RDB文件来实现Redis数据库备份。RDB文件是经过压缩（可以配置rdbcompression参数以禁用压缩节省CPU占用）的二进制格式，所以占用的空间会小于内存中的数据大小，更加利于传输。<br>除了自动快照，还可以手动发送<code>SAVE</code>或<code>BGSAVE</code>命令让Redis执行快照，两个命令的区别在于，前者是由主进程进行快照操作，会阻塞住其他请求，后者会通过fork子进程进行快照操作。<br>Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将一个记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟。<br>通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化。</p>
<h4 id="RDB-的优点"><a href="#RDB-的优点" class="headerlink" title="RDB 的优点"></a><strong>RDB 的优点</strong></h4><p>RDB是一种表示某个即时点的Redis数据的紧凑文件。RDB文件适合用于备份。例如，你可能想要每小时归档最近24小时的RDB文件，每天保存近30天的RDB快照。这允许你很容易的恢复不同版本的数据集以容灾。<br>RDB非常适合于灾难恢复，作为一个紧凑的单一文件，可以被传输到远程的数据中心，或者是Amazon S3(可能得加密)。<br>RDB最大化了Redis的性能，因为Redis父进程持久化时唯一需要做的是启动(fork)一个子进程，由子进程完成所有剩余工作。父进程实例不需要执行像磁盘IO这样的操作。<br>RDB在重启保存了大数据集的实例时比AOF要快。</p>
<h4 id="RDB-的缺点"><a href="#RDB-的缺点" class="headerlink" title="RDB 的缺点"></a><strong>RDB 的缺点</strong></h4><p>当你需要在Redis停止工作(例如停电)时最小化数据丢失，RDB可能不太好。你可以配置不同的保存点(save point)来保存RDB文件(例如，至少5分钟和对数据集100次写之后，但是你可以有多个保存点)。然而，你通常每隔5分钟或更久创建一个RDB快照，所以一旦Redis因为任何原因没有正确关闭而停止工作，你就得做好最近几分钟数据丢失的准备了。<br>RDB需要经常调用fork()子进程来持久化到磁盘。如果数据集很大的话，fork()比较耗时，结果就是，当数据集非常大并且CPU性能不够强大的话，Redis会停止服务客户端几毫秒甚至一秒。AOF也需要fork()，但是你可以调整多久频率重写日志而不会有损(trade-off)持久性(durability)。</p>
<h3 id="6-1-2-AOF方式"><a href="#6-1-2-AOF方式" class="headerlink" title="6.1.2 AOF方式"></a><strong>6.1.2 AOF方式</strong></h3><h4 id="AOF-的优点"><a href="#AOF-的优点" class="headerlink" title="AOF 的优点"></a><strong>AOF 的优点</strong></h4><p>使用AOF Redis会更具有可持久性(durable)：你可以有很多不同的fsync策略：没有fsync，每秒fsync，每次请求时fsync。使用默认的每秒fsync策略，写性能也仍然很不错(fsync是由后台线程完成的，主线程继续努力地执行写请求)，即便你也就仅仅只损失一秒钟的写数据。<br>AOF日志是一个追加文件，所以不需要定位，在断电时也没有损坏问题。即使由于某种原因文件末尾是一个写到一半的命令(磁盘满或者其他原因),redis-check-aof工具也可以很轻易的修复。<br>当AOF文件变得很大时，Redis会自动在后台进行重写。重写是绝对安全的，因为Redis继续往旧的文件中追加，使用创建当前数据集所需的最小操作集合来创建一个全新的文件，一旦第二个文件创建完毕，Redis就会切换这两个文件，并开始往新文件追加。<br>AOF文件里面包含一个接一个的操作，以易于理解和解析的格式存储。你也可以轻易的导出一个AOF文件。例如，即使你不小心错误地使用FLUSHALL命令清空一切，如果此时并没有执行重写，你仍然可以保存你的数据集，你只要停止服务器，删除最后一条命令，然后重启Redis就可以。</p>
<h4 id="AOF-的缺点"><a href="#AOF-的缺点" class="headerlink" title="AOF 的缺点"></a><strong>AOF 的缺点</strong></h4><p>对同样的数据集，AOF文件通常要大于等价的RDB文件。<br>AOF可能比RDB慢，这取决于准确的fsync策略。通常fsync设置为每秒一次的话性能仍然很高，如果关闭fsync，即使在很高的负载下也和RDB一样的快。不过，即使在很大的写负载情况下，RDB还是能提供能好的最大延迟保证。<br>在过去，我们经历了一些针对特殊命令(例如，像BRPOPLPUSH这样的阻塞命令)的罕见bug，导致在数据加载时无法恢复到保存时的样子。这些bug很罕见，我们也在测试套件中进行了测试，自动随机创造复杂的数据集，然后加载它们以检查一切是否正常，但是，这类bug几乎不可能出现在RDB持久化中。为了说得更清楚一点：Redis AOF是通过递增地更新一个已经存在的状态，像MySQL或者MongoDB一样，而RDB快照是一次又一次地从头开始创造一切，概念上更健壮。但是，1)要注意Redis每次重写AOF时都是以当前数据集中的真实数据从头开始，相对于一直追加的AOF文件(或者一次重写读取老的AOF文件而不是读内存中的数据)对bug的免疫力更强。2)我们还没有收到一份用户在真实世界中检测到崩溃的报告。<br>默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过<code>appendonly</code>参数开启：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">appendonly</span> <span class="literal">yes</span></span></pre></td></tr></table></figure>

<p>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过<code>dir</code>参数设置的，默认的文件名是<code>appendonly.aof</code>，可以通过<code>appendfilename</code>参数修改：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">appendfilename</span> <span class="selector-tag">appendonly</span><span class="selector-class">.aof</span></span></pre></td></tr></table></figure>

<p>下面讲解AOF持久化的具体实现，假设在开启AOF持久化的情况下执行了如下4个命令：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">SET</span> foo 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">SET</span> foo 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">SET</span> foo 3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> foo</span></pre></td></tr></table></figure>

<p>Redis会将前3条命令写入AOF文件中，此时AOF文件中的内容如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="number">*2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="variable">$6</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">SELECT</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="variable">$1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="number">*3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="variable">$3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">set</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="variable">$3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">foo</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="variable">$1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="number">*3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="variable">$3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">set</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="variable">$3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">foo</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="variable">$1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="number">*3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="variable">$3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">set</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="variable">$3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">foo</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="variable">$1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">3</span></pre></td></tr></table></figure>

<p>可见AOF文件是纯文本文件，其内容正是Redis客户端向Redis发送的原始通信协议的内容（Redis的通信协议会在7.4节中介绍，为了便于阅读，这里将实际的命令部分以粗体显示），从中可见Redis确实只记录了前3条命令。然而这时有一个问题是前2条命令其实都是冗余的，因为这两条的执行结果会被第三条命令覆盖。随着执行的命令越来越多，AOF文件的大小也会越来越大，即使内存中实际的数据可能并没有多少。很自然地，我们希望Redis可以自动优化AOF文件，就上例而言，就是将前两条无用的记录删除，只保留第三条。实际上Redis也正是这样做的，每当达到一定条件时Redis就会自动重写AOF文件，这个条件可以在配置文件中设置：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto</span>-aof-rewrite-percentage <span class="number">100</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto</span>-aof-rewrite-min-size <span class="number">64</span>mb</span></pre></td></tr></table></figure>

<p><code>auto-aof-rewrite-percentage</code>参数的意义是当目前的AOF文件大小超过上一次重写时的AOF文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动时的AOF文件大小为依据。<code>auto-aof-rewrite-min-size</code>参数限制了允许重写的最小AOF文件大小，通常在AOF文件很小的情况下即使其中有很多冗余的命令我们也并不太关心。除了让Redis自动执行重写外，我们还可以主动使用<code>BGREWRITEAOF</code>命令手动执行AOF重写。<br>上例中的AOF文件重写后的内容为：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">*2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$6</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">SELECT</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$1</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">*3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$3</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">$3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">foo</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">$1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">3</span></pre></td></tr></table></figure>

<p>可见冗余的命令已经被删除了。重写的过程只和内存中的数据有关，和之前的AOF文件无关，这与RDB很相似，只不过二者的文件格式完全不同。<br>在启动时Redis会逐个执行AOF文件中的命令来将硬盘中的数据载入到内存中，载入的速度相较RDB会慢一些。<br>需要注意的是虽然每次执行更改数据库内容的操作时，AOF都会将命令记录在AOF文件中，但是事实上，由于操作系统的缓存机制，数据并没有真正地写入硬盘，而是进入了系统的硬盘缓存。在默认情况下系统每30秒会执行一次同步操作，以便将硬盘缓存中的内容真正地写入硬盘，在这30秒的过程中如果系统异常退出则会导致硬盘缓存中的数据丢失。一般来讲启用AOF持久化的应用都无法容忍这样的损失，这就需要Redis在写入AOF文件后主动要求系统将缓存内容同步到硬盘中。在Redis中我们可以通过<code>appendfsync</code>参数设置同步的时机：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta"># appendfsync always</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">appendfsync everysec</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta"># appendfsync no</span></span></pre></td></tr></table></figure>

<p>默认情况下Redis采用<code>everysec</code> 规则，即每秒执行一次同步操作。<code>always</code>表示每次执行写入都会执行同步，这是最安全也是最慢的方式。no表示不主动进行同步操作，而是完全交由操作系统来做（即每30秒一次），这是最快但最不安全的方式。一般情况下使用默认值everysec就足够了，既兼顾了性能又保证了安全。<br>Redis允许同时开启AOF和RDB，既保证了数据安全又使得进行备份等操作十分容易。此时重新启动Redis后Redis会使用AOF文件来恢复数据，因为AOF方式的持久化可能丢失的数据更少。</p>
<h4 id="RDB-和-AOF-我应该用哪一个？"><a href="#RDB-和-AOF-我应该用哪一个？" class="headerlink" title="RDB 和 AOF ,我应该用哪一个？"></a><strong>RDB 和 AOF ,我应该用哪一个？</strong></h4><p>一般来说,如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。<br>如果你非常关心你的数据,但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。<br>有很多用户单独使用AOF，但是我们并不鼓励这样，因为时常进行RDB快照非常方便于数据库备份，启动速度也较之快，还避免了AOF引擎的bug。<br>注意：基于这些原因，将来我们可能会统一AOF和RDB为一种单一的持久化模型(长远计划)。<br>参考文档<br><a href="http://ifeve.com/redis-persistence/" target="_blank" rel="noopener">http://ifeve.com/redis-persistence/</a></p>
<h2 id="6-2-主从复制"><a href="#6-2-主从复制" class="headerlink" title="6.2 主从复制"></a>6.2 主从复制</h2><p>通过持久化功能，Redis保证了即使在服务器重启的情况下也不会损失（或少量损失）数据。但是由于数据是存储在一台服务器上的，如果这台服务器的硬盘出现故障，也会导致数据丢失。为了避免单点故障，我们希望将数据库复制多个副本以部署在不同的服务器上，即使有一台服务器出现故障其他服务器依然可以继续提供服务。这就要求当一台服务器上的数据库更新后，可以自动将更新的数据同步到其他服务器上，Redis提供了复制（<code>replication</code>）功能可以自动实现同步的过程。</p>
<h3 id="6-2-1-配置"><a href="#6-2-1-配置" class="headerlink" title="6.2.1 配置"></a><strong>6.2.1 配置</strong></h3><p>同步后的数据库分为两类，一类是主数据库（<code>master</code>），一类是从数据库（<code>slave</code>）。主数据库可以进行读写操作，当发生写操作时自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库，如图7-1所示。<br><img src="http://image.winrains.cn/2019/10/3f0f8-1458310260717024010.png" alt="QQ截图20160318221047.png"><br>在Redis中使用复制功能非常容易，只需要在从数据库的配置文件中加入“slaveof主数据库IP主数据库端口”即可，主数据库无需进行任何配置。<br>为了能够更直观地展示复制的流程，下面将进行简单的演示。我们要在一台服务器上启动两个Redis实例，监听不同端口，其中一个作为主数据库，另一个作为从数据库。首先我们不加任何参数来启动一个Redis实例作为主数据库：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$redis</span>-server</span></span></pre></td></tr></table></figure>

<p>该实例默认监听6379端口。然后加上slaveof参数启动另一个Redis实例作为从数据库，并让其监听6380端口：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis-server --port <span class="number">6380</span>--slaveof <span class="number">127.0</span><span class="number">.0</span><span class="number">.16379</span></span></pre></td></tr></table></figure>

<p>此时在主数据库中的任何数据变化都会自动同步到从数据库中。我们打开redis-cli实例A并连接到主数据库：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis-<span class="keyword">cli</span></span></pre></td></tr></table></figure>

<p>再打开redis-cli实例B并连接到从数据库：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis-cli -p <span class="number">6380</span></span></pre></td></tr></table></figure>

<p>在实例A中使用SET命令设置一个键的值：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis A＞<span class="keyword">SET</span> foo <span class="comment">bar</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">OK</span></pre></td></tr></table></figure>

<p>此时在实例B中就可以获得该值了：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis B＞<span class="builtin-name">GET</span> foo</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="string">"bar"</span></span></pre></td></tr></table></figure>

<p>但在默认情况下从数据库是只读的，如果直接修改从数据库的数据会出现错误：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis B＞<span class="keyword">SET</span> foo hi</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">(<span class="keyword">error</span>) <span class="keyword">READONLY</span> You can<span class="comment">'t write against a read only slave.</span></span></pre></td></tr></table></figure>

<p>可以通过设置从数据库的配置文件中的<code>slave-read-only</code>为no以使从数据库可写，但是对从数据库的任何更改都不会同步给任何其他数据库，并且一旦主数据库中更新了对应的数据就会覆盖从数据库中的改动。<br>配置多台从数据库的方法也一样，在所有的从数据库的配置文件中都加上 slaveof参数指向同一个主数据库即可。<br>除了通过配置文件或命令行参数设置slaveof参数，还可以在运行时使用<code>SLAVEOF</code>命令修改：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis＞SLAVEOF <span class="number">127.0</span><span class="number">.0</span><span class="number">.16379</span></span></pre></td></tr></table></figure>

<p>如果该数据库已经是其他主数据库的从数据库了，SLAVEOF命令会停止和原来数据库的同步转而和新数据库同步。还可以使用<code>SLAVEOF NO ONE</code>来使当前数据库停止接收其他数据库的同步转成主数据库。</p>
<h3 id="6-2-2-原理"><a href="#6-2-2-原理" class="headerlink" title="6.2.2 原理"></a><strong>6.2.2 原理</strong></h3><p>了解Redis复制的原理对日后运维有很大的帮助。<br>当一个从数据库启动后，会向主数据库发送<code>SYNC</code>命令，主数据库接收到SYNC命令后会开始在后台保存快照（即RDB持久化的过程），并将保存期间接收到的命令缓存起来。当快照完成后，Redis会将快照文件和所有缓存的命令发送给从数据库。从数据库收到后，会载入快照文件并执行收到的缓存的命令。当主从数据库断开重连后会重新执行上述操作，不支持断点续传。<br>实际的过程略微复杂一些，由于Redis服务器使用TCP协议通信，所以我们可以使用telnet工具伪装成一个从数据库来了解同步的具体过程。首先在命令行中连接主数据库（默认端口为6379，且没有任何从数据库连接）：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">telnet <span class="number">127.0</span><span class="number">.0</span><span class="number">.16379</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Trying127<span class="number">.0</span><span class="number">.0</span><span class="number">.1</span>...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Connected to localhost.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Escape character <span class="keyword">is</span> <span class="string">'^]'</span>.</span></pre></td></tr></table></figure>

<p>然后作为从数据库，我们先要发送PING命令确认主数据库是否可以连接：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">PING</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">+PONG</span></pre></td></tr></table></figure>

<p>主数据库会回复+PONG。如果没有收到主数据库的回复，则向用户提示错误。如果主数据库需要密码才能连接，我们还得发送AUTH命令进行验证（关于Redis的安全设置会在7.3节介绍）。而后向主数据库发送<code>REPLCONF</code>命令说明自己的端口号（这里随便选择了一个）：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">REPLCONF listening-port <span class="number">6381</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">+OK</span></pre></td></tr></table></figure>

<p>这时就可以开始同步的过程了：向主数据库发送SYNC命令开始同步，此时主数据库发送回快照文件和缓存的命令。目前主数据库中只有一个foo键，所以收到的内容如下（快照文件是二进制格式，从第三行开始）：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">SYNC</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$<span class="number">29</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">REDIS0006?foobar?<span class="number">6</span>_?<span class="string">"</span></span></pre></td></tr></table></figure>

<p>从数据库会将收到的内容写入到硬盘上的临时文件中，当写入完成后从数据库会用该临时文件替换RDB快照文件（RDB快照文件的位置就是持久化时配置的位置，由dir和dbfilename两个参数确定），之后的操作就和RDB持久化时启动恢复的过程一样了。需要注意的是在同步的过程中从数据库并不会阻塞，而是可以继续处理客户端发来的命令。默认情况下，从数据库会用同步前的数据对命令进行响应。可以配置slave-serve-stale-data参数为no来使从数据库在同步完成前对所有命令（除了INFO和SLAVEOF）都回复错误：“SYNC with master in progress.”<br>之后主数据库的任何数据变化都会同步给从数据库，同步的内容和Redis通信协议一样，比如我们在主数据库中执行SET foo hi，通过telnet我们收到了：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="number">*3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="variable">$3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">set</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="variable">$3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">foo</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="variable">$2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">hi</span></pre></td></tr></table></figure>

<p>在复制的过程中，快照无论在主数据库还是从数据库中都起了很大的作用，只要执行复制就会进行快照，即使我们关闭了RDB方式的持久化（通过删除所有save参数）。更进一步，无论是否启用了RDB方式的持久化，Redis在启动时都会尝试读取dir和dbfilename两个参数指定的RDB文件来恢复数据库。</p>
<h3 id="6-2-3-图结构"><a href="#6-2-3-图结构" class="headerlink" title="6.2.3 图结构"></a><strong>6.2.3 图结构</strong></h3><p>从数据库不仅可以接收主数据库的同步数据，自己也可以同时作为主数据库存在，形成类似图的结构，如图7-2所示，数据库A的数据会同步到B和C中，而B中的数据会同步到D和E中。向B中写入数据不会同步到A或C中，只会同步到D和E中。<br><img src="http://image.winrains.cn/2019/10/7ef26-1458310811339051979.png" alt="QQ截图20160318221958.png"></p>
<h3 id="6-2-4-读写分离"><a href="#6-2-4-读写分离" class="headerlink" title="6.2.4 读写分离"></a><strong>6.2.4 读写分离</strong></h3><p>通过复制可以实现读写分离以提高服务器的负载能力。在常见的场景中，读的频率大于写，当单机的Redis无法应付大量的读请求时（尤其是较耗资源的请求，比如SORT命令等）可以通过复制功能建立多个从数据库，主数据库只进行写操作，而从数据库负责读操作。</p>
<h3 id="6-2-5-从数据库持久化"><a href="#6-2-5-从数据库持久化" class="headerlink" title="6.2.5 从数据库持久化"></a><strong>6.2.5 从数据库持久化</strong></h3><p>另一个相对耗时的操作是持久化，为了提高性能，可以通过复制功能建立一个（或若干个）从数据库，并在从数据库中启用持久化，同时在主数据库禁用持久化。当从数据库崩溃时重启后主数据库会自动将数据同步过来，所以无需担心数据丢失。而当主数据库崩溃时，需要在从数据库中使用<code>SLAVEOF NO ONE</code>命令将从数据库提升成主数据库继续服务，并在原来的主数据库启动后使用SLAVEOF命令将其设置成新的主数据库的从数据库，即可将数据同步回来。</p>
<h3 id="6-2-6-总结"><a href="#6-2-6-总结" class="headerlink" title="6.2.6 总结"></a><strong>6.2.6 总结</strong></h3><p>Redis主从复制的配置十分简单，它可以使slave是master的完全拷贝。下面是关于Redis主从复制的几点重要内容：</p>
<ol>
<li>Redis使用异步复制。但从Redis 2.8开始，slave会周期性的应答从复制流中处理的数据量。</li>
<li>一个master可以有多个slave。</li>
<li>slave也可以接受其他slave的连接。除了多个slave连接到一个master之外，多个slave也可以连接到一个slave上，形成一个图状结构</li>
<li>Redis主从复制不阻塞master端。也就是说当若干个slave在进行初始同步时，master仍然可以处理请求。</li>
<li>主从复制也不阻塞slave端。当slave进行初始同步时，它使用旧版本的数据来应对查询请求，假设你在redis.conf配置文件是这么配置的。否则的话，你可以配置当复制流关闭时让slave给客户端返回一个错误。但是，当初始同步完成后，需要删除旧的数据集和加载新的数据集，在这个短暂的时间内，slave会阻塞连接进来的请求。</li>
<li>主从复制可以用来增强扩展性，使用多个slave来处理只读的请求（比如，繁重的排序操作可以放到slave去做），也可以简单的用来做数据冗余。</li>
<li>使用主从复制可以为master免除把数据写入磁盘的消耗：在master的redis.conf文件中配置“避免保存”（注释掉所有“保存“命令），然后连接一个配置为“进行保存”的slave即可。但是这个配置要确保master不会自动重启</li>
</ol>
<h4 id="当主服务器不进行持久化时复制的安全性"><a href="#当主服务器不进行持久化时复制的安全性" class="headerlink" title="当主服务器不进行持久化时复制的安全性"></a><strong>当主服务器不进行持久化时复制的安全性</strong></h4><p>在进行主从复制设置时，强烈建议在master服务器上开启持久化，当不能这么做时，比如考虑到延迟的问题，应该将实例配置为避免自动重启。<br>为什么不持久化的master服务器自动重启非常危险呢？为了更好的理解这个问题，看下面这个失败的例子，其中master服务器和slave服务器中数据库都被删除了。<br>我们设置节点A为master，关闭持久化，节点B和C从节点A复制数据。<br>这时出现了一个崩溃，但Redis具有自动重启系统，重启了进程，因为关闭了持久化，节点重启后只有一个空的数据集。<br>节点B和C从节点A进行复制，现在节点A是空的，所以节点B和C上的复制数据也会被删除。<br>当在高可用系统中使用Redis Sentinel，关闭了master服务器的持久化，并且允许自动重启，这种情况是很危险的。比如master服务器可能在很短的时间就完成了重启，以至于Sentinel都无法检测到这次失败，那么上面说的这种失败的情况就发生了。<br>如果数据比较重要，并且在使用主从复制时关闭了主服务器持久化功能的场景中，都应该禁止实例自动重启。</p>
<h4 id="部分重新同步"><a href="#部分重新同步" class="headerlink" title="部分重新同步"></a><strong>部分重新同步</strong></h4><p>从Redis 2.8开始，如果遭遇连接断开，重新连接之后可以从中断处继续进行复制，而不必重新同步。<br>它的工作原理是这样，主服务器端为复制流维护一个内存缓冲区（in-memory backlog）。主从服务器都维护一个复制偏移量（replication offset）和master run id ，当连接断开时，从服务器会重新连接上主服务器，然后请求继续复制，假如主从服务器的两个master run id相同，并且指定的偏移量在内存缓冲区中还有效，复制就会从上次中断的点开始继续。如果其中一个条件不满足，就会进行完全重新同步（在2.8版本之前就是直接进行完全重新同步）。因为主运行id不保存在磁盘中，如果从服务器重启了的话就只能进行完全同步了。<br>部分重新同步这个新特性内部使用<code>PSYNC</code>命令，旧的实现中使用SYNC命令。Redis2.8版本可以检测出它所连接的服务器是否支持PSYNC命令，不支持的话使用SYNC命令。</p>
<h4 id="无磁盘复制"><a href="#无磁盘复制" class="headerlink" title="无磁盘复制"></a><strong>无磁盘复制</strong></h4><p>通常来讲，一个完全重新同步需要在磁盘上创建一个RDB文件，然后加载这个文件以便为从服务器发送数据。<br>如果使用比较低速的磁盘，这种操作会给主服务器带来较大的压力。Redis从2.8.18版本开始尝试支持无磁盘的复制。使用这种设置时，子进程直接将RDB通过网络发送给从服务器，不使用磁盘作为中间存储。<br>这一特性目前只是实验性的。<br>关于部分重新同步，还有一些针对复制内存缓冲区的优化参数。查看Redis介质中的Redis.conf示例获得更多信息。<br>使用<code>repl-diskless-sync</code>配置参数来启动无磁盘复制。使用<code>repl-diskless-sync-delay</code> 参数来配置传输开始的延迟时间，以便等待更多的从服务器连接上来。</p>
<h4 id="设置从服务器到主服务器验证"><a href="#设置从服务器到主服务器验证" class="headerlink" title="设置从服务器到主服务器验证"></a><strong>设置从服务器到主服务器验证</strong></h4><p>如果主服务器设置了密码，配置从服务器在所有同步中使用这个密码十分简单。<br>对于运行中的实例，使用redis-cli并输入：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">config</span> <span class="built_in">set</span> masterauth &lt;password&gt;</span></pre></td></tr></table></figure>

<p>要使配置永久生效，把如下命令加入到配置文件中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">masterauth <span class="tag">&lt;<span class="name">password</span>&gt;</span></span></pre></td></tr></table></figure>

<h4 id="限制有N个以上从服务器才允许写入"><a href="#限制有N个以上从服务器才允许写入" class="headerlink" title="限制有N个以上从服务器才允许写入"></a><strong>限制有N个以上从服务器才允许写入</strong></h4><p>从Redis 2.8版本开始，可以配置主服务器连接N个以上从服务器才允许对主服务器进行写操作。但是，因为Redis使用的是异步主从复制，没办法确保从服务器确实收到了要写入的数据，所以还是有一定的数据丢失的可能性。<br>这一特性的工作原理如下：</p>
<ul>
<li>从服务器每秒钟ping一次主服务器，确认处理的复制流数量。</li>
<li>主服务器记住每个从服务器最近一次ping的时间。</li>
<li>用户可以配置最少要有N个服务器有小于M秒的确认延迟。</li>
<li>如果有N个以上从服务器，并且确认延迟小于M秒，主服务器接受写操作。</li>
</ul>
<p>你可以把这看做是CAP原则（一致性，可用性，分区容错性）不严格的一致性实现，虽然不能百分百确保一致性，但至少保证了丢失的数据不会超过M秒内的数据量。<br>如果条件不满足，主服务器会拒绝写操作并返回一个错误。<br><code>min-slaves-to-write</code>（最小从服务器数）<br><code>min-slaves-max-lag</code>（从服务器最大确认延迟）<br>参考文档：<br><a href="http://ifeve.com/redis-replication/" target="_blank" rel="noopener">http://ifeve.com/redis-replication/</a></p>
<h2 id="6-3-redis-sentinel"><a href="#6-3-redis-sentinel" class="headerlink" title="6.3 redis-sentinel"></a>6.3 redis-sentinel</h2><p>Redis Sentinel为Redis提供了高可用解决方案。实际上这意味着使用Sentinel可以部署一套Redis，在没有人为干预的情况下去应付各种各样的失败事件。<br>Redis Sentinel同时提供了一些其他的功能，例如：监控、通知、并为client提供配置。<br>下面是Sentinel的功能列表：</p>
<ol>
<li><strong>监控（Monitoring）</strong>：Sentinel不断的去检查你的主从实例是否按照预期在工作。</li>
<li><strong>通知（Notification）</strong>：Sentinel可以通过一个api来通知系统管理员或者另外的应用程序，被监控的Redis实例有一些问题。</li>
<li><strong>自动故障转移（Automatic failover）</strong>：如果一个主节点没有按照预期工作，Sentinel会开始故障转移过程，把一个从节点提升为主节点，并重新配置其他的从节点使用新的主节点，使用Redis服务的应用程序在连接的时候也被通知新的地址。</li>
<li><strong>配置提供者（Configuration provider）</strong>：Sentinel给客户端的服务发现提供来源：对于一个给定的服务，客户端连接到Sentinels来寻找当前主节点的地址。当故障转移发生的时候，Sentinels将报告新的地址。</li>
</ol>
<h3 id="Sentinel的分布式特性"><a href="#Sentinel的分布式特性" class="headerlink" title="Sentinel的分布式特性"></a><strong>Sentinel的分布式特性</strong></h3><p>Redis Sentinel是一个分布式系统，Sentinel运行在有许多Sentinel进程互相合作的环境下，它本身就是这样被设计的。有许多Sentinel进程互相合作的优点如下：</p>
<ol>
<li>当多个Sentinel同意一个master不再可用的时候，就执行故障检测。这明显降低了错误概率。</li>
<li>即使并非全部的Sentinel都在工作，Sentinel也可以正常工作，这种特性，让系统非常的健康。</li>
<li>所有的Sentinels，Redis实例，连接到Sentinel和Redis的客户端，本身就是一个有着特殊性质的大型分布式系统。在这篇文章中，我将逐步地介绍这些概念，最开始是一些基本的信息来理解Sentinel的基本属性，后面是更复杂的信息来理解Sentinel是怎么工作的。</li>
</ol>
<h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a><strong>快速开始</strong></h3><p>获取 Sentinel<br>当前版本的Sentinel的被称为 Sentinel 2 。它使用更强更简单的预测算法重写了Sentinel的初始化实现（文章的后面将会解释）。<br>Redis Sentinel 的一个稳定版本是随着Redis2.8和3.0一起的。这两个是Redis最新的稳定版。<br>新的进展在unstable分支下进行，一旦新的特性是稳定的，就会被合并到2.8和3.0分支。<br>和Redis 2.6一起的Redis Sentinel版本1，是过时的。我们不该使用它。</p>
<h3 id="运行Sentinel"><a href="#运行Sentinel" class="headerlink" title="运行Sentinel"></a><strong>运行Sentinel</strong></h3><p>如果你使用<code>redis-sentinel</code>可执行文件，你可以使用下面的命令来运行Sentinel：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis-sentinel /<span class="type">path</span>/<span class="keyword">to</span>/sentinel.conf</span></pre></td></tr></table></figure>

<p>另外，你可以直接使用redis-server并以Sentinel模式来启动：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis-<span class="keyword">server</span> /<span class="type">path</span>/<span class="keyword">to</span>/sentinel.conf <span class="comment">--sentinel</span></span></pre></td></tr></table></figure>

<p>两种方式是一样的。<br>不管咋样，使用一个配置文件来运行Sentinel是必须的，这个文件被系统使用来存储当前状态，如果重启，这些状态会被重新载入。如果没有配置文件或者配置文件的路径不对，Sentinel将会拒绝启动。<br>默认情况下，Sentinels监听TCP端口<code>26379</code>，所以为了让Sentinels运行，你的机器的26379端口必须是打开的，用来接收其他Sentinel实例的连接，否则，Sentinels不能互相交流，也不知道该干什么，也不会执行故障转移。</p>
<h3 id="部署之前了解关于Sentinel的基本东西"><a href="#部署之前了解关于Sentinel的基本东西" class="headerlink" title="部署之前了解关于Sentinel的基本东西"></a><strong>部署之前了解关于Sentinel的基本东西</strong></h3><ol>
<li>一个健康的集群部署，至少需要三个Sentinel实例</li>
<li>三个Sentinel实例应该被放在失败独立的电脑上或虚拟机中，比如说不同的物理机或者在不同的可用区域上执行的虚拟机。</li>
<li>Sentinel + Redis 分布式系统在失败期间并不确保写入请求被保存，因为Redis使用异步拷贝。可是有很多部署Sentinel的方式来让窗口把丢失写入限制在特定的时刻，当然也有另外的不安全的方式来部署。</li>
<li>如果你在开发环境中没有经常测试，或者在生产环境中也没有，那就没有高可用的设置是安全的。你或许有一个错误的配置而仅仅只是在很晚的时候才出现（凌晨3点你的主节点宕掉了）。</li>
<li>Sentinel，Docker ，其他的网络地址转换表，端口映射 使用应该很小心的使用：Docker执行端口重新映射，破坏Sentinel自动发现另外的Sentinel进程和一个主节点的从节点列表。在文章的稍后部分查看更过关于Sentinel和Docker的信息。</li>
</ol>
<h3 id="Sentinel配置"><a href="#Sentinel配置" class="headerlink" title="Sentinel配置"></a><strong>Sentinel配置</strong></h3><p>Redis源码中包含一个名为<code>sentinel.conf</code>的文件，是一个你可以用来配置Sentinel的示例配置文件。一个典型的最小配置文件像下面这样：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">sentinel<span class="built_in"> monitor </span>mymaster 127.0.0.1 6379 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">sentinel down-after-milliseconds mymaster 60000</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">sentinel failover-timeout mymaster 180000</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">sentinel parallel-syncs mymaster 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">sentinel<span class="built_in"> monitor </span>resque 192.168.1.3 6380 4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">sentinel down-after-milliseconds resque 10000</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">sentinel failover-timeout resque 180000</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">sentinel parallel-syncs resque 5</span></pre></td></tr></table></figure>

<p>你仅仅只需要指定要监控的主节点，并给每个单独的主节点一个不同的名称。不需要指定从节点，从节点会被自动发现。Sentinel将会根据从节点额外的信息自动更新配置（为了在重启时保留信息）。在故障转移中每当一个从节点被提升为主节点或者当一个新的Sentinel被发现的时候，配置信息也被重新写入。<br>示例配置在上面，监控两个Redis实例集合，每个集合由一个主节点和不明确数量的从节点组成。一个集合叫做mymaster，另外一个叫做resque。<br>sentinel monitor参数的意思在下面</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">sentinel<span class="built_in"> monitor </span>&lt;master-group-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</span></pre></td></tr></table></figure>

<p>为了更加清晰明了，让我们一行一行来检查配置选项的意思：<br>第一行用来告诉Redis监控一个叫做mymaster的主节点，地址是 127.0.0.1 端口号是6379，并且有2个仲裁机器。所有的意思都很明显，但是除了这个<code>quorum</code>参数：</p>
<ul>
<li>quorum 是 需要同意主节点不可用的Sentinels的数量</li>
<li>然而quorum 仅仅只是用来检测失败。为了实际的执行故障转移，Sentinels中的一个需要被选定为leader并且被授权进行操作，这仅仅发生在大多数Sentinels进行投票的时候。</li>
</ul>
<p>比如如果你有五个Sentinel进程，对于一个主节点quorum被设置为2，下面是发生的事情：</p>
<ul>
<li>同时有两个Sentinels同意主节点不可用，其中的一个将会尝试开始故障转移。</li>
<li>如果至少有三个Sentinels是可用的，故障转移将会被授权并且开始</li>
</ul>
<p>实际中，这意味着在失败时，如果大多数的Sentinel进程没有同意，Sentinel永远不会开始故障转移。<br>设置quorum的原因是，如果一个Sentinel进程检到master不可用，并不能一定代表这个master不可用，可能只是这个sentinel进程自己存在问题。所以必须和其他Sentinel进程进行通信，多个Sentinel进程都认为不可用，则说明这个master的确不可用了。</p>
<h3 id="其他的Sentinels选项"><a href="#其他的Sentinels选项" class="headerlink" title="其他的Sentinels选项"></a><strong>其他的Sentinels选项</strong></h3><p>其他的选项几乎都是如下形式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">sentinel <span class="tag">&lt;<span class="name">option_name</span>&gt;</span> <span class="tag">&lt;<span class="name">master_name</span>&gt;</span> <span class="tag">&lt;<span class="name">option_value</span>&gt;</span></span></pre></td></tr></table></figure>

<p>用途如下：<br><code>down-after-milliseconds</code>：当一个实例失去联系（要么不回复我们的请求，要么回复一个错误）超过了这个时间（毫秒为单位），Sentinel就开始认为这个实例挂掉了。<br><code>parallel-syncs</code>：设置的从节点的数量，这些从节点在一次故障转移过后可以使用新的主节点进行重新配置。数量越少，完成故障转移过程将花费更多的时间，如果从节点为旧的数据提供服务，你或许不想所有的从节点使用主节点进行重新同步。复制进程对于从节点来说大部分是非阻塞的，还是有一个时刻它会停下来去从主节点加载数据。你或许想确保一次只有一个从节点是不可达的，可以通过设置这个选项的值为1来完成。<br>别的选项在文章的其他部分进行描述。<br>所有的配置参数都可以在运行时使用<code>SENTINEL SET</code>命令进行更改，查看 Reconfiguring Sentinel at runtime章节获取更多内容。</p>
<h3 id="Sentinel部署示例"><a href="#Sentinel部署示例" class="headerlink" title="Sentinel部署示例"></a><strong>Sentinel部署示例</strong></h3><p>现在你已经知道了Sentinel的基本信息，你或许想知道哪里放置你的Sentinel进程，需要多少个Sentinel进程等等。这个章节给出了几个部署的例子。<br>为了以图形（graphical ）格式展示配置示例，我们使用ASCII艺术。下面是不同的符号的意思：<br>+——————–+<br>| 这是一个独立电脑  |<br>| 或者VM。我们称它为 |<br>| “box”       |<br>+——————–+<br>我们把我们想要运行的东西写到boxes里：<br>+——————-+<br>| Redis master M1  |<br>| Redis Sentinel S1 |<br>+——————-+<br>不同的box之间通过一条线连接，表示他们之间可以互相交流：<br>+————-+        +————-+<br>| Sentinel S1 |—————| Sentinel S2 |<br>+————-+        +————-+<br>中断的线条表示不同的网络分区：<br>+————-+         +————-+<br>| Sentinel S1 |—— // ——| Sentinel S2 |<br>+————-+         +————-+<br>同时还要注意：</p>
<ul>
<li>主节点称为M1，M2，M3，…，Mn。</li>
<li>从节点称为R1，R2，R3，…，Rn。</li>
<li>Sentinels称为S1，S2，S3，…，Sn。</li>
<li>客户端称为C1，C2，C3，…，Cn。</li>
<li>当一个实例因为Sentinels的行为转换角色，我们把它放在方括号里，所以[M1]表示一个实例现在是主节点。</li>
</ul>
<p>注意永远不要设置只有两个Sentinels，因为开始一个故障转移，Sentinels总是需要和大多数Sentinels交流。</p>
<h4 id="示例1：仅仅只有两个Sentinels，永远不要这么做"><a href="#示例1：仅仅只有两个Sentinels，永远不要这么做" class="headerlink" title="示例1：仅仅只有两个Sentinels，永远不要这么做"></a><strong>示例1：仅仅只有两个Sentinels，永远不要这么做</strong></h4><p>+—-+     +—-+<br>| M1 |———| R1 |<br>| S1 |     | S2 |<br>+—-+     +—-+<br>Configuration: quorum = 1<br>在这个设置中，如果M1宕掉了，R1将会被提升至主节点，因为两个Sentinels将会达成一致（显然把quorum设置为1），并且授权开始一个故障转移因为大多数是两个。显然，表面上可以工作，但是请检查下一个点来看看为什么这种设置是不可以的。<br>如果M1的box停止工作，M1也会停止。运行在另外一个box中的S2将不会被授权进行故障转移，所以系统将不可用。<br>注意，需要大多数是为了应付不同的故障，最新的配置稍后会传播给所有的Sentinels。同时注意在上述设置中单独一边的故障转移能力，没有任何协议，将是非常危险的：<br>+—-+      +——+<br>| M1 |—-//—–| [M1] |<br>| S1 |      | S2  |<br>+—-+      +——+<br>在上面的配置中，我们完美对称地创建了两个主节点（假设S2在没有授权的情况下可以进行故障转移），客户端或许会不确定写往哪一边，并且没有办法理解当分区治愈时候哪边的配置是正确的。<br>所以请至少部署三个Sentinels在三个不同的box当中。</p>
<h4 id="示例2：三个box的基本设置"><a href="#示例2：三个box的基本设置" class="headerlink" title="示例2：三个box的基本设置"></a><strong>示例2：三个box的基本设置</strong></h4><p>这是一个非常简单的设置，拥有更加安全的优点。它是基于三个boxes的，每个box运行一个Redis进程和Sentinel进程。<br>+—-+<br>| M1 |<br>| S1 |<br>+—-+<br>|<br>+—-+   |   +—-+<br>| R2 |—-+—-| R3 |<br>| S2 |     | S3 |<br>+—-+     +—-+<br>Configuration: quorum = 2<br>如果M1挂掉，S2和S3将认同这次失败，并且能授权开始一次故障转移，这样使客户端可以继续使用。<br>在每一个Sentinel设置中，Redis是异步复制的，总是有丢失一些写入数据的危险，因为当一个从节点被提升为主节点的时候一个写入确认还没有到达。然而在上面的设置中，还有一种更加危险的情况，由于客户端和一个老的主节点在一个网络分区中，就像下面这样：<br>+—-+<br>| M1 |<br>| S1 | &lt;- C1 (writes will be lost)<br>+—-+<br>|<br>/<br>/<br>+——+   |   +—-+<br>| [M2] |—-+—-| R3 |<br>| S2  |     | S3 |<br>+——+     +—-+<br>在这种情况下，网络分区把旧的主节点[M1]给孤立了，所以从节点R2被提升为主节点。然而，像客户端C1，和旧的主节点在同一个网络分区中，或许继续像旧的主节点写入数据。当分区治愈，这些数据将永久丢失，这个旧得主节点将会被重新配置，作为新的主节点下的一个从节点，并丢弃它自己的数据。<br>可以使用下面的Redis复制特性减轻这个问题，如果一个主节点发现它不再能够把它的写入请求发送给指定数量的从节点，它就停止接受写入请求。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>-slaves-<span class="built_in">to</span>-<span class="built_in">write</span> <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>-slaves-<span class="built_in">max</span>-lag <span class="number">10</span></span></pre></td></tr></table></figure>

<p>当上面的配置应用于一个Redis实例。Redis发现它不能写入至少一个1从节点，作为主节点的Reids将会停止接受写入请求。由于复制是异步，不能写入也意味着从节点也是断开的，或者超过了指定的max-lag秒数没有发送异步回应。<br>在上面的示例中，使用这个配置的旧的主节点M1，在10秒过后就不可用了。当分区治愈，Sentinel配置将会统一为新的，客户端C1将获取到一个有效的配置并且继续。<br>然而天下没有免费的午餐，在这种改进下，如果两个从节点挂掉了，主节点将会停止接收写入请求，这就是一个权衡。</p>
<h4 id="示例3：Sentinel在客户端所在的box中"><a href="#示例3：Sentinel在客户端所在的box中" class="headerlink" title="示例3：Sentinel在客户端所在的box中"></a><strong>示例3：Sentinel在客户端所在的box中</strong></h4><p>有时候，我们只有两个Redis box是可用的，一个给主节点，一个给从节点。在那种情况下，示例2中的配置是不可行的，我们可以采取下面的方法，Sentinels被放置在客户端所在的地方：<br>+—-+     +—-+<br>| M1 |—-+—-| R1 |<br>| S1 |   |   | S2 |<br>+—-+   |   +—-+<br>|<br>+————+————+<br>|       |       |<br>|       |       |<br>+—-+     +—-+    +—-+<br>| C1 |     | C2 |    | C3 |<br>| S1 |     | S2 |    | S3 |<br>+—-+     +—-+    +—-+<br>Configuration: quorum = 2<br>在这种设置下，Sentinels的视角和客户端是 一样的：如果大部分的客户端认为一个主节点是可用的，它就是可用的。这里的C1，C2，C3是一般的客户端， 并不意味着C1是连接到Redis的单个客户端，它更像一个应用服务器，一个Redis app，或者类似的东西。<br>如果M1和S1所在的box挂掉了，故障转移将会进行，但是很明显的看到不同的网络分区将导致不同的行为。比如说，如果客户端和Redis服务断开连接，Sentinel将不会被设置，因为Redis的主节点和从节点都是不可用的。<br>注意如果C3和M1在一个分区，我们有了一个和示例2中描述的类似的问题，不同的是，这里我们没有办法打破对称，因为只有一个主节点和从节点，所以主节点不会停止接收请求。<br>所以这是一个有效的设置，但是实例2中的设置更有优势，比如Redis高可用系统，Redis运行在同一个box中，更容易被管理，并且可以限制在小部分的分区中主节点接收写入请求的时间。</p>
<h4 id="示例4：Sentinel-客户端-这一边少于三个客户端"><a href="#示例4：Sentinel-客户端-这一边少于三个客户端" class="headerlink" title="示例4：Sentinel 客户端 这一边少于三个客户端"></a><strong>示例4：Sentinel 客户端 这一边少于三个客户端</strong></h4><p>示例3描述的设置中，如果客户端这一边的box少于不够三个，这个 设置就不能使用。在这种情况下，我们需要借助混合设置，像下面这样：<br>+—-+     +—-+<br>| M1 |—-+—-| R1 |<br>| S1 |   |   | S2 |<br>+—-+   |   +—-+<br>|<br>+——+—–+<br>|       |<br>|       |<br>+—-+     +—-+<br>| C1 |     | C2 |<br>| S3 |     | S4 |<br>+—-+     +—-+<br>Configuration: quorum = 3<br>这和示例3中的设置非常相似，但是这里我们在可用的四个box中运行了四个Sentinel。如果主节点M1变成不可用节点，其他三个Sentinel将执行故障转移。<br>理论上，当移除S2和S4正在运行的box，这个设置可以工作，把quorum设置为2。然而，在应用层没有高可用的系统，想在Redis这一边得到高可用是不太可能的。</p>
<h3 id="Sentinel，Docker-NAT-和可能的问题"><a href="#Sentinel，Docker-NAT-和可能的问题" class="headerlink" title="Sentinel，Docker,NAT 和可能的问题"></a><strong>Sentinel，Docker,NAT 和可能的问题</strong></h3><p>Docker使用被称为端口映射的技术：与一个程序认为他使用的端口相比，运行在Docker容器里面的程序可能被暴露在不同的端口上。为了运行多个容器在相同的服务器上同时使用同一个端口，这是非常有用的。<br>Docker不是唯一会发生这件事情的软件系统，也有其他的网络地址转换设置导致端口是被重映射，并且有时候没有端口，只有IP地址。<br>端口和地址重映射在两个方面制造了与Sentinel有关的问题：</p>
<ol>
<li>Sentinel的自动发现服务将停止工作，因为它使基于每个Sentinel 往它监听的端口和IP地址广播hello消息来实现的。但是Sentinels没有办法来理解端口和IP地址被重映射了，所以他会宣布它和其他的Sentinels的连接是不正常的。</li>
<li>在一个主节点的INFO输出中，从节点 被列出来也是类似的方式：主节点检查远端对等的TCP连接来发现地址，在握手过程中，从节点自己广告他的端口，然而由于相同的原因，端口或许是错误的。</li>
</ol>
<p>因为Sentinels自动发现从节点使用主节点的INFO输出信息，发现的从节点是不可达的，并且Sentinel将永远不会开始故障转移，因为从系统的观点来看，没有好的从节点，所以目前没有方式监控使用Docker部署的主节点和从节点实例，除非你通知Docker以1:1映射端口。<br>对于第一个问题，万一你想使用Docker运行一堆Sentinel实例，你可以使用下面的两个Sentinel配置，为了强迫Sentinel宣布一个指定的端口和IP：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="symbol">sentinel</span> announce-<span class="built_in">ip</span> &lt;<span class="built_in">ip</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="symbol">sentinel</span> announce-port &lt;port&gt;</span></pre></td></tr></table></figure>

<p>注意，Docker可以运行host networking模式。这就不会有问题因为端口不会被重新映射。</p>
<h3 id="快速教程"><a href="#快速教程" class="headerlink" title="快速教程"></a><strong>快速教程</strong></h3><p>在文章接下来的部分中，所有的说明都是关于Sentinel API，配置和语义。对于想尽快上手的人，这部分的教程展示了三个Sentinel怎么配置和交互。<br>现在我假设三个实例分别在端口5000、5001、5002上。我也假设你在6379上有一个主节点Redis实例，6380上有一个从节点实例。在本教程中我们将使用IPV4回调地址127.0.0.1，假设你在你的电脑上运行了 模拟环境。<br>三个Sentinel配置文件应该看起来像下面这样：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">port 5000</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">sentinel<span class="built_in"> monitor </span>mymaster 127.0.0.1 6379 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">sentinel down-after-milliseconds mymaster 5000</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">sentinel failover-timeout mymaster 60000</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">sentinel parallel-syncs mymaster 1</span></pre></td></tr></table></figure>

<p>另外的两个配置文件也是相同的，但是使用5001,5002作为端口号。<br>上面的配置中需要注意的一些事情：<br>主节点集群称为mymaster，它定义了主节点和它的从节点。因为每个master set 有一个不同的名称，Sentinel能同时监控不同的主节点和从节点的集合。<br><code>quorum</code>被设置为2。<br><code>down-after-milliseconds</code>的值是5000毫秒，就是5秒钟，所以在这个时间内一旦我们不能收到回复，主节点将发现失败。<br>一旦你启动了三个Sentinels，可以看到他们打印的一些信息：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">+monitor master mymaster <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> quorum <span class="number">2</span></span></pre></td></tr></table></figure>

<p>这是一个Sentinel事件，如果你<code>SUBSCRIBE</code>了指定名称的事件，你可以收到这种事件通过发布/订阅。<br>Sentinel在故障检测和故障转移中生成和打印不同的事件。<br>询问Sentinel关于主节点的状态<br>Sentinel开始启动的时候，要做的事情是检查主节点的监控是否正常：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ redis-cli -p <span class="number">5000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>&gt; sentinel master mymaster</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>) <span class="string">"name"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"> <span class="number">2</span>) <span class="string">"mymaster"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"> <span class="number">3</span>) <span class="string">"ip"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"> <span class="number">4</span>) <span class="string">"127.0.0.1"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"> <span class="number">5</span>) <span class="string">"port"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"> <span class="number">6</span>) <span class="string">"6379"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"> <span class="number">7</span>) <span class="string">"runid"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"> <span class="number">8</span>) <span class="string">"953ae6a589449c13ddefaee3538d356d287f509b"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"> <span class="number">9</span>) <span class="string">"flags"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>) <span class="string">"master"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>) <span class="string">"link-pending-commands"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>) <span class="string">"0"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="number">13</span>) <span class="string">"link-refcount"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="number">14</span>) <span class="string">"1"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="number">15</span>) <span class="string">"last-ping-sent"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="number">16</span>) <span class="string">"0"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="number">17</span>) <span class="string">"last-ok-ping-reply"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="number">18</span>) <span class="string">"735"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>) <span class="string">"last-ping-reply"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>) <span class="string">"735"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>) <span class="string">"down-after-milliseconds"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="number">22</span>) <span class="string">"5000"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="number">23</span>) <span class="string">"info-refresh"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="number">24</span>) <span class="string">"126"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="number">25</span>) <span class="string">"role-reported"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="number">26</span>) <span class="string">"master"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="number">27</span>) <span class="string">"role-reported-time"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="number">28</span>) <span class="string">"532439"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="number">29</span>) <span class="string">"config-epoch"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="number">30</span>) <span class="string">"1"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="number">31</span>) <span class="string">"num-slaves"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"><span class="number">32</span>) <span class="string">"1"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="number">33</span>) <span class="string">"num-other-sentinels"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"><span class="number">34</span>) <span class="string">"2"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="number">35</span>) <span class="string">"quorum"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="number">36</span>) <span class="string">"2"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"><span class="number">37</span>) <span class="string">"failover-timeout"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"><span class="number">38</span>) <span class="string">"60000"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="number">39</span>) <span class="string">"parallel-syncs"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"><span class="number">40</span>) <span class="string">"1"</span></span></pre></td></tr></table></figure>

<p>像你所见的，它打印了主节点的一些信息。有几个是我们特别有兴趣的：<br>num-other-sentinels 是2，所以我们知道对于这个主节点Sentinel已经发现了两个以上的Sentinels。如果你检查日志，你可以看到+sentinel事件发生。<br>flags是master。如果主节点挂掉了，我们可以看到<code>s_down</code>或者<code>o_down</code>标志。<br>num-slaves现在是1，所以Sentinel发现有一个从节点。<br>为了探测关于这个实例更多的信息，你可以尝试下面的两个命令：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">SENTINEL</span> <span class="string">slaves mymaster</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attr">SENTINEL</span> <span class="string">sentinels mymaster</span></span></pre></td></tr></table></figure>

<p>第一个将提供关于从节点类似的信息，第二个是关于另外的Sentinels。</p>
<h3 id="获取当前主节点的地址"><a href="#获取当前主节点的地址" class="headerlink" title="获取当前主节点的地址"></a><strong>获取当前主节点的地址</strong></h3><p>Sentinel也作为一个配置提供者，提供给客户端它们想连接的主节点和从节点的集群。因为可能的故障转移和重配置，客户端不知道一个集群实例内当前的活着的主节点，所以Sentinel提供了一个API：</p>
<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="string">127.</span>0.0.<span class="string">1:5000&gt;</span> <span class="string">SENTINEL </span><span class="built_in">get-master-addr-by-name</span> <span class="string">mymaster</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="string">1)</span> <span class="string">"127.0.0.1"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">2) <span class="string">"6379"</span></span></pre></td></tr></table></figure>

<h3 id="故障转移测试"><a href="#故障转移测试" class="headerlink" title="故障转移测试"></a><strong>故障转移测试</strong></h3><p>现在我们部署Sentinel可以被测试了。我们可以杀死主节点然后查看配置变化。做我们可以做的：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis-cli -p <span class="number">6379</span> DEBUG sleep <span class="number">30</span></span></pre></td></tr></table></figure>

<p>这个命令让我们的主节点变为不可达，睡眠30秒，它基本上模拟了主节点挂掉的一些原因。<br>如果你检查Sentinel的日志，你应该能看到许多动作：<br><img src="http://image.winrains.cn/2019/10/d8633-1458458929970002365.png" alt="QQ截图20160320152458.png"></p>
<ol>
<li>每个Sentinel发现了主节点挂掉了并有一个+sdown事件</li>
<li>这个事件稍候升级到+odown，意味着大多数Sentinel已经同意了主节点是不可达的。</li>
<li>Sentinels开始投票一个Sentinel开始并尝试故障转移</li>
<li>故障转移开始</li>
</ol>
<p>如果你重新询问mymaster的当前主节点的地址，这次我们会得到一个不同的回复：</p>
<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="string">127.</span>0.0.<span class="string">1:5000&gt;</span> <span class="string">SENTINEL </span><span class="built_in">get-master-addr-by-name</span> <span class="string">mymaster</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="string">1)</span> <span class="string">"127.0.0.1"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">2) <span class="string">"6380"</span></span></pre></td></tr></table></figure>

<p>目前为止一切都很顺利，现在你可以创建你自己的Sentinel部署或者阅读更多来理解Sentinel的命令和内部原理。</p>
<h3 id="Sentinel-API"><a href="#Sentinel-API" class="headerlink" title="Sentinel API"></a><strong>Sentinel API</strong></h3><p>Sentinel提供了一个API，可以用来检查它的状态，检查主节点和从节点的健康，订阅具体的通知并在运行时改变Sentinel的配置。<br>默认情况下Sentinel使用TCP端口号26379。Sentinels接收使用Redis的协议命令，所以你可以使用redis-cli或者其他未修改的Redis客户端来和Sentinel交流。<br>直接查询一个Sentinel来检查所监控的Redis实例的状态，看看另外的Sentinels所知道是可能的。有两种方式，使用发布/订阅，每当一些事件发生，比如说一次故障转移，或一个实例发生错误等，都可能接收到一个从Sentinels推送过来的通知。</p>
<h3 id="Sentinel命令"><a href="#Sentinel命令" class="headerlink" title="Sentinel命令"></a><strong>Sentinel命令</strong></h3><p>下面是可以接收的命令列表，没有覆盖到那些用来改变Sentinel配置的命令：</p>
<ul>
<li>PING 这个命令仅仅返回PONG。</li>
<li>SENTINEL masters  展示监控的主节点和它们的状态列表</li>
<li>SENTINEL master <master name> 展示指定的主节点的信息</li>
<li>SENTINEL salves <master name> 展示这个主节点的从节点，以及它们的状态</li>
<li>SENTINEL  sentinels <master name> 展示这个主节点的sentinel实例，以及它们的状态</li>
<li>SENTINEL  get-master-addr-by-name  <master name> 返回主节点的IP和端口号。如果这个主节点的一次故障转移正在进行，就返回提升的从节点的IP和端口号</li>
<li>SENTINEL reset <pattern> 这个命令将会根据匹配的名称重置主节点，pattern参数是通配符（glob-style）类型，重置进程清除主节点中之前的所有状态，并且移除主节点发现和关联的从节点和sentinel。</li>
<li>SENTINEL failover <master name> 如果主节点不可达，强制开始故障转移，不需要另外的Sentinels同意。</li>
<li>SENTINEL ckquorum <master name> 检查当前的Sentinel配置对于主节点的故障转移是否能达到仲裁人数，并且大多数是需要的来授权故障转移。这个命令应该在监控系统中使用来检查一个Sentinel部署是否正常。</li>
<li>SENTINEL flushconfig  强制Sentinel重新写入它的配置到磁盘上，包括当前Sentinel状态。通常，每次当它状态里的一些东西改变，Sentinel就会重写配置信息。然而有时候配置文件会丢失，由于错误的操作、磁盘故障、包升级脚本、或配置管理。在那种情况下，强制Sentinel重写它的配置文件是容易的。甚至之前的配置文件完全丢失，这个命令也能很好的工作。</li>
</ul>
<h3 id="运行时重新配置Sentinel"><a href="#运行时重新配置Sentinel" class="headerlink" title="运行时重新配置Sentinel"></a><strong>运行时重新配置Sentinel</strong></h3><p>从Redis 2.8.4开始，Sentinel提供了一个API为了增加、移除或者改变一个给定的主节点的配置。注意如果你有多个sentinels，为了工作正常，你应该改变所有的Redis Sentinel 实例。这意味着改变单个Sentinel的配置不会把变化发送给在网络中另外的Sentinels.<br>下面是SENTINEL自命令列表，用来更新一个Sentinel实例的配置：</p>
<ul>
<li>SENTINEL MONITOR <name> <ip> <port> <quorum> 这个命令告诉Sentinel开始监控一个指定名称、IP、端口号、quorum的主节点，它和sentinel.conf配置文件中的sentinel monitor配置指令是完全相同的，不同的是这里不能使用主机名作为IP，需要提供一个IPV4或IPV6地址。</li>
<li>SENTINEL REMOVE <name> 用来移除指定的主节点：主节点不再被监控，并且将被从Sentinel的内部状态中被完全移除，所以不会被SENTINEL masters列出。</li>
<li>SENTINEL SET <name> <option> <value> SET命令和Reids的CONFIG SET指令非常相似，被用来改变一个指定主节点的配置参数。多个选项-值可以被指定。所有通过sentinel.conf配置的参数可以使用SET命令重新配置。</li>
</ul>
<p>下面是SENTINEL SET命令的一个例子，为了修改一个名为objects-cache的主节点的down-after-milliseconds配置：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">SENTINEL <span class="keyword">SET</span> objects-<span class="keyword">cache</span>-<span class="keyword">master</span> down-<span class="keyword">after</span>-milliseconds <span class="number">1000</span></span></pre></td></tr></table></figure>

<p>正如我们提到的，SENTINEL SET可以被用来设置所有的在启动配置文件中被设置的参数。而且，还可以仅仅改变主节点的quorum配置，而不需要使用SENTINEL REMOVE和SENTINEL MONITOR来删除或者增加主节点，只需要使用：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">SENTINEL SET objects-cache-<span class="keyword">master</span> <span class="title">quorum</span> <span class="number">5</span></span></pre></td></tr></table></figure>

<p>注意，没有等价的GET命令，因为SENTINEL MASTER以一种易于解析的格式提供了所有的配置参数。</p>
<h3 id="添加和移除sentinels"><a href="#添加和移除sentinels" class="headerlink" title="添加和移除sentinels"></a><strong>添加和移除sentinels</strong></h3><p>添加一个新的sentinel到你的部署中是很容易的一个过程，因为Sentinel有自动发现机制。所有的你需要做的事情是开启一个新的Sentinel来监控当前的主节点。10秒过后，Sentinel将获取到其他的Sentinels列表和当前主节点的从节点。<br>如果你想一次性增加多个Sentinels，建议你一个接一个的增加，等所有的Sentinels已经知道第一个再添加另一个。在添加的新的Sentinels过程中错误有可能发生，在这时候保证在一次网络分区内中大部分是可用是很有用的。<br>在没有网络分区时，通过在30秒后增加每个新的节点，这是很容易实现的。<br>最后，可以使用SENTINEL MASTER mastername命令来检查是否全部Sentinels都同意了监控主节点的Sentinels的总数。<br>移除一个Sentinel稍微复杂一点：Sentinels永远不会忘记已经看到的Sentinels，甚至他们在相当长的一段时间内不可达，因为我们不想动态的改变授权一次故障转移和创建新的配置所需要的大多数。在没有网络分区的说话，需要执行下面的步骤来移除一个Sentinel：</p>
<ol>
<li>停止你想要移除的Sentinel的进程</li>
<li>发送一个SENTINEL RESET *命令到其他的Sentinel实例，相继的，两次发送到实例之间至少等待30秒</li>
<li>检查所有的Sentinels赞同的当前存活的Sentinels的数量，通过检查每个SENTINEL MASTER mastername的输出。</li>
</ol>
<h3 id="移除旧的主节点或不可达的从节点"><a href="#移除旧的主节点或不可达的从节点" class="headerlink" title="移除旧的主节点或不可达的从节点"></a><strong>移除旧的主节点或不可达的从节点</strong></h3><p>Sentinels永远不会忘记一个主节点的从节点，甚至当他们很长时间都不可达。这是很有用的，因为在一次网络分区或失败事件发生后，Sentinels应该能正确地重新配置一个返回的从节点。<br>而且，在故障转移发生之后，被故障转移的主节点实际上被添加为新的主节点的从节点，一旦它可用的时候，这种方式将重新配置来复制新的主节点。<br>然而有时候你想从Sentinels监控的从节点列表中永久的移除一个从节点。<br>为了做这件事，你需要发送一个SENTINEL RESET mastername命令给所有的Sentinels：它们将在十秒后刷新从节点列表，只添加当前主节点的INFO输出中正确的复制列表。</p>
<h3 id="发布-订阅消息"><a href="#发布-订阅消息" class="headerlink" title="发布/订阅消息"></a><strong>发布/订阅消息</strong></h3><p>一个客户端能使用一个Sentinel作为一个Redis兼容的发布/订阅服务器，为了SUBSCRIBE或者PSUBSCRIBE到指定频道，获取指定事件通知。<br>频道的名称和事件的名称是一样的。比如说名称为+sdown的频道将收到所有的关于实例进入SDOWN 条件的通知。<br>使用 PSUBSCRIBE * 订阅来获取所有的消息。<br>下面是一个频道列表，以及使用API，你可以接收到的消息格式。第一个词是频道/事件名称，剩余部分是数据格式。<br>注意，指定instance details的地方意味着提供了下面的参数用于表示目标实例：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;instance-<span class="class"><span class="keyword">type</span>&gt; &lt;name&gt; &lt;ip&gt; &lt;port&gt; @ &lt;master-name&gt; &lt;master-ip&gt; &lt;master-port&gt;</span></span></pre></td></tr></table></figure>

<p>标识主节点的部分（从@开始到结束）是可选的，只有实例本身不是主节点的时指定。</p>
<ul>
<li>+reset-master <instance details> — 主节点被重置。</li>
<li>+slave <instance details> — 一个新的从节点被发现和关联。</li>
<li>+failover-state-reconf-slaves <instance details> — 故障转移状态被转换为reconf-slaves状态。</li>
<li>+failover-detected <instance details> — 另一个Sentinel开始了故障转移或者其他的外部实体被发现（一个关联的从节点变为主节点）。</li>
<li>+slave-reconf-sent <instance details> — 为了给新的从节点重新配置，sentinel 中的leader发送SLAVEOF命令到这个实例。</li>
<li>+slave-reconf-inprog <instance details> –从节点被重新配置展示一个主节点的从节点，但是同步过程尚未完成。</li>
<li>+slave-reconf-done <instance details> — 从节点现在和主节点是同步的。</li>
<li>-dup-sentinel <instance details> –指定的主节点，一个或者多个sentinels被 移除，因为是重复的。</li>
<li>+sentinel <instance details> — 这个主节点的一个新的sentinel被发现和关联。</li>
<li>+sdown <instance details> — 指定的实例现在处于主观下线状态。</li>
<li>-sdown <instance details> — 指定的实例不再处于主观下线状态。</li>
<li>+odown <instance details> — 指定的实例现在处于客观下线状态。</li>
<li>-odown <instance details> — 指定的实例现在不处于客观下线状态。</li>
<li>+new-epoch <instance details> — 当前时间被更新。</li>
<li>+try-failover <instance details> — 准备新的故障转移，等待大多数的选举。</li>
<li>+elected-leader <instance details> — 赢得了选举，开始故障转移。</li>
<li>+failover-state-select-slave <instance details> — 新的故障转移状态是select-slave：我们 正在寻找合适提升为主节点的从节点。</li>
<li>no-good-slave <instance details> — 没有合适进行提升的从节点。一般会在稍后重试，但是这或许会改变并且终止故障转移。</li>
<li>selected-slave <instance details> — 我们找到了指定的从节点来进行提升。</li>
<li>failover-state-send-slaveof-noone <instance details> — 我们尝试重新配置这个提升后的主节点，等待它切换。</li>
<li>failover-end-for-timeout <instance details> — 故障转移由于超时而停止，无论如何从节点最后被配置为复制新的主节点。</li>
<li>failover-end <instance details> — 故障转移由于成功而停止，所有的从节点被配置为复制新的主节点。</li>
<li>switch-master <master name> <oldip> <oldport> <newip> <newport> — 配置改变后，主节点新的IP和地址都是指定的。这是大多数外部用户感兴趣的消息。</li>
<li>+tilt — 进入Tilt模式。</li>
<li>-tilt — 退出Tilt模式。</li>
</ul>
<h3 id="从节点优先"><a href="#从节点优先" class="headerlink" title="从节点优先"></a><strong>从节点优先</strong></h3><p>Redis实例有个配置参数叫slave-priority。这个信息在Redis从节点实例的INFO输出中展示出来，并且Sentinel使用它来选择一个从节点在一次故障转移中：<br>如果从节点的优先级被设置为0，这个从节点永远不会被提升为主节点。<br>Sentinel首选一个由更低（ lower）优先级的从节点。<br>比如在当前主节点的同一个数据中心有一个从节点S1，并且有另外的从节点S2在另外的数据中心，可以将S1优先级设置为10，S2优先级设置为100，如果主节点挂掉了并且S1和S2都是可用的，S1将是首选的。<br>查看关于从节点选举的更多信息，请查看本文章的slave selection and priority章节。</p>
<h3 id="Sentinel和Redis权限"><a href="#Sentinel和Redis权限" class="headerlink" title="Sentinel和Redis权限"></a><strong>Sentinel和Redis权限</strong></h3><p>当主节点被配置为从客户端需要密码，作为一个安全措施，从节点也需要知道这个密码为了主节点认证并且创建主-从连接用于异步复制协议。<br>使用下列的配置选项来实现：</p>
<ul>
<li>requirepass 在主节点中，为了设置认证密码，并且确保实例不会处理来自没有认证的客户端的请求。</li>
<li>masterauth 在从节点中，为了取得主节点的认证，来从主节点正确的复制 数据。</li>
</ul>
<p>当Sentinel使用的时候，没有一个单独的主节点，因为一次故障转移过后，从节点将扮演主节点的角色，并且老的主节点被重新配置作为一个从节点，所以你要做的是在全部的实例中设置上面的选项，包括主节点和从节点。<br>这通常是一个理智的设置，因为你不想要仅仅在主节点中保护你的数据，在从节点中有同样的数据。<br>然而，在罕见的情况下，你需要一个从节点是可进入的而不需要认证，你可以设置一个优先级为0的从节点来实现，阻止这个从节点被提升为主节点，配置这个从节点的masterauth选项，不要使用requirepass选项，以便数据可以被读在没有认证的情况下。</p>
<h3 id="Sentinel-客户端实现"><a href="#Sentinel-客户端实现" class="headerlink" title="Sentinel 客户端实现"></a><strong>Sentinel 客户端实现</strong></h3><p>Sentinel需要显式的客户端支持，除非系统配置为执行脚本来执行一个透明的重定向对于所有的主节点实例的请求（虚拟IP或类似的系统）。可以参考文档Sentinel clients guidelines。</p>
<h3 id="更高级的概念"><a href="#更高级的概念" class="headerlink" title="更高级的概念"></a><strong>更高级的概念</strong></h3><p>下面的章节是关于Sentinel怎么工作的一些细节，没有付诸于实现的想法和算法在文章的最后章节。</p>
<h4 id="SDOWN和ODOWN失败状态"><a href="#SDOWN和ODOWN失败状态" class="headerlink" title="SDOWN和ODOWN失败状态"></a><strong>SDOWN和ODOWN失败状态</strong></h4><p>Redis Sentine有两个不同概念的下线，一个被称为主观下线（Subjectively Down ）条件（SDOWN），是一个本地Sentinel实例下线条件。另一个被称为客观下线（Objectively Down ）条件（ODOWN），是当足够的Sentinels具有SDOWN条件就满足ODOWN，并且从其他的Sentinels使用SENTINEL is-master-down-by-addr命令得到反馈。<br>从一个Sentinel的角度来看，满足一个SDOWN条件就是在指定的时间内对于PING请求不能收到有效的回复，这个时间在配置文件中是is-master-down-after-milliseconds参数。<br>一个PING请求可接受的回复是下列之一：</p>
<ul>
<li>回复+PONG。</li>
<li>回复 -LOADING错误。</li>
<li>回复-MASTERDOWN错误。</li>
</ul>
<p>其他的回复（或根本没有回复）被认为是无效的。注意一个合理的主节点在INFO输出中通知他自己是一个从节点被认为是下线的。<br>注意SDOWN需要在配置中整个的时间间隔都没有收到有效的回复，因此对于实例如果时间间隔是30000毫秒，并且我们每隔29秒收到有效的回复，这个实例就被认为在工作。<br>SDOWN还不够触发故障转移：它仅仅意味着一个单独的Sentinel相信一个Redis实例不可达。要触发故障转移，必须达到ODOWN状态。<br>从SDOWN转换到ODOWN，没有使用强一致性算法，而仅仅是gossip的形式：如果一个Sentinel在一个给定的时间范围内从足够的Sentinels 得到一个报告说一个主节点没有在工作，SDOWN被提升为ODOWN。如果这个确认稍候消失，这个标识也会清除。<br>一个更加严格的授权是使用大多数需要为了真正的开始故障转移，但是在达到ODOWN状态之前不会触发故障转移。<br>ODOWN条件只适用于主节点。对于其他类型的实例，Sentinel不需要采取行动，所以对于从节点和其他的sentinels来说ODOWN状态永远不可能达到，而仅仅只有SDOWN状态。<br>然而SDOWN也有语义的影响，比如一个从节点在SDOWN状态不会被选举来提升来执行一个故障转移。</p>
<h4 id="Sentinels和从节点自动发现"><a href="#Sentinels和从节点自动发现" class="headerlink" title="Sentinels和从节点自动发现"></a><strong>Sentinels和从节点自动发现</strong></h4><p>Sentinels和其他的Sentinels保持连接为了互相之间检查是否可达和交换消息。然而你不需要在每个运行的Sentinel 实例中配置其他的Sentinel地址列表，Sentinel使用Redis实例的发布/订阅能力来发现其他的监控相同的主节点和从节点的Sentinels。<br>通过往名称为<strong>sentinel</strong>:hello的通道发送hello消息（hello messages）来实现这个特性。<br>同样的，你不需要配置一个主节点关联的从节点的列表，Sentinel也会自动发现这个列表通过问询Redis：<br>每隔两秒，每个Sentinel向每个监控的主节点和从节点的发布/订阅通道<strong>sentinel</strong>:hello来公布一个消息，宣布它自己的IP，端口，id。<br>每个Sentinel都订阅每个主节点和从节点的发布/订阅通道<strong>sentinel</strong>:hello，寻找未知的sentinels。当新的sentinels被检测到，他们增加这个主节点的sentinels。<br>Hello消息也包含主节点的全部配置信息，如果接收的Sentinel有一个更旧的配置，它会立即更新它的配置。<br>在增加一个主节点的新的sentinel之前，Sentinel总是要检查是否已经有一个有相同的id、地址的sentinel。在这种情况下，所有匹配的sentinels被移除，新的被增加。</p>
<h4 id="故障转移之外重新配置"><a href="#故障转移之外重新配置" class="headerlink" title="故障转移之外重新配置"></a><strong>故障转移之外重新配置</strong></h4><p>即使没有故障转移，Sentinels将尝试设置当前的配置到监控的实例上面。<br>特别的：</p>
<ul>
<li>从节点声称为主节点，将被作为从节点配置来复制当前的主节点。</li>
<li>从节点连接了一个错误的主节点，也会被重新配置来复制正确的主节点。</li>
</ul>
<p>Sentinels重新配置从节点，错误的配置在一段时间内应该被观察到，比在广播新的配置的时候要好得多。<br>这个阻止了有一个过时配置（比如说从一个分区中重新加入）的Sentinels 在收到更新之前去交换从节点的配置。<br>同样注意：</p>
<ul>
<li>主节点的故障转移被重新配置作为从节点当他们返回可用的时候</li>
<li>在一个网络分区中，从节点一旦可达，被重新配置。</li>
</ul>
<p>本章最重要的教训就是：Sentinels是每个进程总是尝试去把最后的配置施加到监控的实例上的一个系统。<br><a href="http://ifeve.com/redis-sentinel/" target="_blank" rel="noopener">http://ifeve.com/redis-sentinel/</a></p>
<h2 id="6-4-Redis-分区"><a href="#6-4-Redis-分区" class="headerlink" title="6.4 Redis 分区"></a>6.4 Redis 分区</h2><p>分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。</p>
<h3 id="分区的优势"><a href="#分区的优势" class="headerlink" title="分区的优势"></a><strong>分区的优势</strong></h3><ul>
<li>通过利用多台计算机内存的和值，允许我们构造更大的数据库。</li>
<li>通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。</li>
</ul>
<h3 id="分区的不足"><a href="#分区的不足" class="headerlink" title="分区的不足"></a><strong>分区的不足</strong></h3><p>redis的一些特性在分区方面表现的不是很好：</p>
<ul>
<li>涉及多个key的操作通常是不被支持的。举例来说，当两个set映射到不同的redis实例上时，你就不能对这两个set执行交集操作。</li>
<li>涉及多个key的redis事务不能使用。</li>
<li>当使用分区时，数据处理较为复杂，比如你需要处理多个rdb/aof文件，并且从多个实例和主机备份持久化文件。</li>
<li>增加或删除容量也比较复杂。redis集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然而，一种叫做<code>presharding</code>的技术对此是有帮助的。</li>
</ul>
<h3 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a><strong>分区类型</strong></h3><p>Redis 有两种类型分区。 假设有4个Redis实例 R0，R1，R2，R3，和类似user:1，user:2这样的表示用户的多个key，对既定的key有多种不同方式来选择这个key存放在哪个实例中。也就是说，有不同的系统来映射某个key到某个Redis服务。</p>
<h4 id="范围分区"><a href="#范围分区" class="headerlink" title="范围分区"></a><strong>范围分区</strong></h4><p>最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的Redis实例。<br>比如，ID从0到10000的用户会保存到实例R0，ID从10001到 20000的用户会保存到R1，以此类推。<br>这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射表。这个表要被管理，同时还需要各 种对象的映射表，通常对Redis来说并非是好的方法。</p>
<h4 id="哈希分区"><a href="#哈希分区" class="headerlink" title="哈希分区"></a><strong>哈希分区</strong></h4><p>另外一种分区方法是hash分区。这对任何key都适用，也无需是object_name:<id>这种形式，像下面描述的一样简单：</p>
<ul>
<li>用一个hash函数将key转换为一个数字，比如使用crc32 hash函数。对key foobar执行crc32(foobar)会输出类似93024922的整数。</li>
<li>对这个整数取模，将其转化为0-3之间的数字，就可以将这个整数映射到4个Redis实例中的一个了。93024922 % 4 = 2，就是说key foobar应该被存到R2实例中。注意：取模操作是取除的余数，通常在多种编程语言中用%操作符实现。</li>
</ul>
<h3 id="分区不同实现方式"><a href="#分区不同实现方式" class="headerlink" title="分区不同实现方式"></a><strong>分区不同实现方式</strong></h3><p>分区可以由一个软件栈的不同部分完成。<br><strong>客户端分区：</strong>客户端直接选择正确节点读写指定键。很多Redis客户实现了这种分区方式。<br><strong>代理辅助分区：</strong>是指我们的客户端通过Redis协议把请求发送给代理，而不是直接发送给真正的Redis实例服务器。这个代理会确保我们的请求根据配置分区策略发送到正确的Redis实例上，并返回给客户端。Redis和Memcached的代理都是用Twemproxy （译者注：这是twitter开源的一个代理框架）来实现代理服务分区的。<br><strong>查询路由：</strong>是指你可以把一个请求发送给一个随机的实例，这时实例会把该查询转发给正确的节点。通过客户端重定向(客户端的请求不用直接从一个实例转发到另一个实例，而是被重定向到正确的节点)，Redis集群实现了一种混合查询路由。</p>
<h3 id="作为数据存储还是作为缓存使用？"><a href="#作为数据存储还是作为缓存使用？" class="headerlink" title="作为数据存储还是作为缓存使用？"></a><strong>作为数据存储还是作为缓存使用？</strong></h3><p>使用Redis存储数据或者缓存数据在概念上是相同的，但是Redis被当作数据存储使用时有一个显著限制。当Redis被当作数据存储服务器使用的时候意味着对于相同的键值必须被映射到相同的实例上面，但是如果把Redis当作数据缓存器，使用多个不同节点，一个给定节点挂掉并不是个大问题，改变键值和实例映射表可以提升系统的可用性(也就是系统处理查询请求的能力)。<br>如果一个指定键的首选节点不可用，一致性哈希可以为指定键切换到其他的节点上。同样的，你添加一个新的节点，部分新的键值开始存储到新添加的节点上面。<br>主要的概念如下：</p>
<ul>
<li>如果Redis只作为可伸缩缓存服务器来使用，那么用一致性哈希是非常容易的。</li>
<li>若果Redis被作为数据持久化服务器，需要提供节点和键值的固定映射，还有节点数目必须是固定的，不能改变。否则当增加或删除节点时，我们需要一个系统来为键重新分配节点，从2015年4月1日开始，Redis集群提供该特性。</li>
</ul>
<h3 id="预分片"><a href="#预分片" class="headerlink" title="预分片"></a><strong>预分片</strong></h3><p>从分区的概念中，我们知道分区有一个缺点：除非只把Redis当作缓存服务器来使用，否则添加和删除Redis节点都会非常复杂。相反使用固定的键值和实例映射更加简单。<br>然而数据存储会经常需要变化。今天我只需要10个Redis节点（实例），但是明天我可能会需要50个节点。<br>因为Redis足够轻量和小巧(一个备用实例使用1M的内存)，解决这个问题的简单方法就是一开始就使用大量的实例节点。即使你开始只有一个服务器，你可以换成分布式的结构，通过分区分方式在单个服务器上来运行多个Redis实例。<br>你一开始可以选择的实例可数可以非常大。例如，32或者64个实例能够满足绝大多数的用户，并且可以为其提供足够的增长空间。<br>通过这样的方法，当摸得数据存储需求增加时，你只需要更多的Redis服务器，然后把一个节点移动到另外的服务器上面。一旦你添加了额外的服务器，你需要将一半的Redis的实例移动到第二个服务器，以此类推。</p>
<ul>
<li>你可以使用Redis 的主从复制来减少服务的停止时间：</li>
<li>在新服务器上开启新的redis空实例。</li>
<li>将节点的数据配置移动到新的从服务器上</li>
<li>停止你的redis客户端。</li>
<li>在新的服务器上更新IP地址到移动过来的节点配置文件中。</li>
<li>发送SLAVEOF NO ONE 命令到新服务器的从节点。</li>
<li>使用新的配置重启客户端。</li>
<li>最后关闭老服务器上不再使用的节点。</li>
</ul>
<h3 id="分区实践"><a href="#分区实践" class="headerlink" title="分区实践"></a><strong>分区实践</strong></h3><p>到目前为止，我们讲了分区的原理。但是该如何实战？你应该使用什么样的系统？</p>
<h4 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a><strong>Redis集群</strong></h4><p>推荐使用Redis集群获得自动分片和高可用性。Redis集群是2015年4月1日版本发布的可用和生成就绪特性。可以从集群教程中获取更多信息。<br>一旦Redis集群是可用的，并且一个Redis集群兼容客户端支持您的编程语言，Redis集群就是Redis分区事实上标准。<br>Redis集群混合使用了查询路由和客户端分区。</p>
<h4 id="Twemproxy-框架"><a href="#Twemproxy-框架" class="headerlink" title="Twemproxy 框架"></a><strong>Twemproxy 框架</strong></h4><p>Twemproxy是一个由Twitter开发的适合Memached ASCII和Redis协议的代理。它是单线程工作，使用C语言实现的，速度非常快。并且是基于Apache 2.0 协议的开源软件。<br>Twemproxy支持自动在多个redis节点分区，如果某个节点不可用，将会被自动屏蔽(这将改变键值和节点映射表，所以如果你把Redis当作缓存服务器使用，你应该使用这个功能)。<br>你可以启用多个代理，让你的客户端得到可用的连接，这样不会发生单点故障。<br>Twemproxy基本上是Redis和客户端的一个中间层，通过简化使用让我们使用可靠的分区。<br>你可以在<a href="http://antirez.com/news/44" target="_blank" rel="noopener">antirez</a>的博客获取有关Twemproxy的更多知识。</p>
<h4 id="客户端一致性哈希实现"><a href="#客户端一致性哈希实现" class="headerlink" title="客户端一致性哈希实现"></a><strong>客户端一致性哈希实现</strong></h4><p>替代Twemproxy的一种方案是使用客户端一致性哈西或者其他类似的算法。有很多Redis客户端支持一致性哈希，比如Redis-rb和Predis。<br>推荐参考文档：<br><a href="http://ifeve.com/redis-partitioning/" target="_blank" rel="noopener">http://ifeve.com/redis-partitioning/</a></p>
<h2 id="6-5-redis集群实战"><a href="#6-5-redis集群实战" class="headerlink" title="6.5 redis集群实战"></a>6.5 redis集群实战</h2><p>这篇教程是Redis集群的简要介绍，而非讲解分布式系统的复杂概念。它主要从一个使用者的角度介绍如何搭建、测试和使用Redis集群，至于Redis集群的详细设计将在“Redis集群规范”中进行描述。<br>本教程以redis使用者的角度，用简单易懂的方式介绍Redis集群的可用性和一致性。<br>注意： 本教程要求redis3.0或以上的版本。<br>如果你打算部署redis集群，你可以读一些关于集群的详细设计，当然，这不是必须的。由这篇教程入门，先大概使用一下Redis的集群，然后再读Redis集群的详细设计，也是不错的选择。</p>
<h3 id="Redis集群-1"><a href="#Redis集群-1" class="headerlink" title="Redis集群"></a><strong>Redis集群</strong></h3><p>redis集群在启动的时候就自动在多个节点间分好片。同时提供了分片之间的可用性：当一部分redis节点故障或网络中断，集群也能继续工作。但是，当大面积的节点故障或网络中断（比如大部分的主节点都不可用了），集群就不能使用。<br>所以，从实用性的角度，Redis集群提供以下功能：</p>
<ul>
<li>自动把数据切分到多个redis节点中</li>
<li>当一部分节点挂了或不可达，集群依然能继续工作</li>
</ul>
<h4 id="Redis集群的TCP端口"><a href="#Redis集群的TCP端口" class="headerlink" title="Redis集群的TCP端口"></a><strong>Redis集群的TCP端口</strong></h4><p>redis集群中的每个节点都需要建立2个tcp连接，监听这2个端口：<br>一个端口称之为“<code>客户端端口</code>”，用于接受客户端指令，与客户端交互，比如6379；另一个端口称之为“<code>集群总线端口</code>”，是在客户端端口号上加10000，比如16379，用于节点之间通过二进制协议通讯。各节点通过集群总线检测宕机节点、更新配置、故障转移验证等。客户端只能使用客户端端口，不能使用集群总线端口。请确保你的防火墙允许打开这两个端口，否则redis集群没法工作。客户端端口和集群总线端口之间的差值是固定的，集群总线端口比客户端端口高10000。<br>注意，关于集群的２个端口：</p>
<ul>
<li>客户端端口（一般是6379）需要对所有客户端和集群节点开放，因为集群节点需要通过该端口转移数据。</li>
<li>集群总线端口（一般是16379）只需对集群中的所有节点开放</li>
</ul>
<p>这２个端口必须打开，否则集群没法正常工作。</p>
<h4 id="Redis集群数据的分片"><a href="#Redis集群数据的分片" class="headerlink" title="Redis集群数据的分片"></a><strong>Redis集群数据的分片</strong></h4><p>Redis集群不是使用一致性哈希，而是使用哈希槽。整个redis集群有16384个哈希槽，决定一个key应该分配到那个槽的算法是：计算该key的CRC16结果再模16834。<br>集群中的每个节点负责一部分哈希槽，比如集群中有３个节点，则：</p>
<ul>
<li>点Ａ存储的哈希槽范围是：0 – 5500</li>
<li>节点Ｂ存储的哈希槽范围是：5501 – 11000</li>
<li>节点Ｃ存储的哈希槽范围是：11001 – 16384</li>
</ul>
<p>这样的分布方式方便节点的添加和删除。比如，需要新增一个节点Ｄ，只需要把Ａ、Ｂ、Ｃ中的部分哈希槽数据移到Ｄ节点。同样，如果希望在集群中删除Ａ节点，只需要把Ａ节点的哈希槽的数据移到Ｂ和Ｃ节点，当Ａ节点的数据全部被移走后，Ａ节点就可以完全从集群中删除。<br>因为把哈希槽从一个节点移到另一个节点是不需要停机的，所以，增加或删除节点，或更改节点上的哈希槽，也是不需要停机的。<br>集群节点之间通过集群总线端口交互数据，使用的协议不同于客户端的协议，是二进制协议，这可以减少带宽和处理时间。<br>如果多个key都属于一个哈希槽，集群支持通过一个命令（或事务, 或lua脚本）同时操作这些key。通过“<code>哈希标签</code>”的概念，用户可以让多个key分配到同一个哈希槽。哈希标签在集群详细文档中有描述，这里做个简单介绍：如果key含有大括号”{}”,则只有大括号中的字符串会参与哈希，比如”this{foo}”和”another{foo}”这２个key会分配到同一个哈希槽，所以可以在一个命令中同时操作他们。</p>
<h4 id="Redis集群的主从模式"><a href="#Redis集群的主从模式" class="headerlink" title="Redis集群的主从模式"></a><strong>Redis集群的主从模式</strong></h4><p>为了保证在部分节点故障或网络不通时集群依然能正常工作，集群使用了主从模型，每个哈希槽有一（主节点）到N个副本（N-1个从节点）。在我们刚才的集群例子中，有A,B,C三个节点，如果B节点故障集群就不能正常工作了，因为Ｂ节点中的哈希槽数据没法操作。但是，如果我们给每一个节点都增加一个从节点，就变成了：A,B,C三个节点是主节点，A1, B1, C1 分别是他们的从节点，当B节点宕机时，我们的集群也能正常运作。B1节点是B节点的副本，如果B节点故障，集群会提升B1为主节点，从而让集群继续正常工作。但是，如果B和B1同时故障，集群就不能继续工作了。</p>
<h4 id="Redis集群的一致性保证"><a href="#Redis集群的一致性保证" class="headerlink" title="Redis集群的一致性保证"></a><strong>Redis集群的一致性保证</strong></h4><p>Redis集群不能保证强一致性。一些已经向客户端确认写成功的操作，会在某些不确定的情况下丢失。<br>产生写操作丢失的第一个原因，是因为主从节点之间使用了异步的方式来同步数据。<br>一个写操作是这样一个流程：<br>1)客户端向主节点B发起写的操作<br>2)主节点B回应客户端写操作成功<br>3)主节点B向它的从节点B1,B2,B3同步该写操作<br>从上面的流程可以看出来，主节点B并没有等从节点B1,B2,B3写完之后再回复客户端这次操作的结果。所以，如果主节点B在通知客户端写操作成功之后，但同步给从节点之前，主节点Ｂ故障了，其中一个没有收到该写操作的从节点会晋升成主节点，该写操作就这样永远丢失了。<br>就像传统的数据库，在不涉及到分布式的情况下，它每秒写回磁盘。为了提高一致性，可以在写盘完成之后再回复客户端，但这样就要损失性能。这种方式就等于Redis集群使用同步复制的方式。<br>基本上，在性能和一致性之间，需要一个权衡。<br>如果真的需要，Redis集群支持同步复制的方式，通过<code>WAIT</code>指令来实现，这可以让丢失写操作的可能性降到很低。但就算使用了同步复制的方式，Redis集群依然不是强一致性的，在某些复杂的情况下，比如从节点在与主节点失去连接之后被选为主节点，不一致性还是会发生。<br>这种不一致性发生的情况是这样的，当客户端与少数的节点（至少含有一个主节点）网络联通，但他们与其他大多数节点网络不通。比如６个节点，A,B,C是主节点，A1,B1,C1分别是他们的从节点，一个客户端称之为Z1。<br>当网络出问题时，他们被分成２组网络，组内网络联通，但２组之间的网络不通，假设A,C,A1,B1,C1彼此之间是联通的，另一边，B和Z1的网络是联通的。Z1可以继续往B发起写操作，Ｂ也接受Z1的写操作。当网络恢复时，如果这个时间间隔足够短，集群仍然能继续正常工作。如果时间比较长，以致B1在大多数的这边被选为主节点，那刚才Z1发给Ｂ的写操作都将丢失。<br>注意，Z1给Ｂ发送写操作是有一个限制的，如果时间长度达到了大多数节点那边可以选出一个新的主节点时，少数这边的所有主节点都不接受写操作。<br>这个时间的配置，称之为节点超时（node timeout），对集群来说非常重要，当达到了这个节点超时的时间之后，主节点被认为已经宕机，可以用它的一个从节点来代替。同样，在节点超时时，如果主节点依然不能联系到其他主节点，它将进入错误状态，不再接受写操作。</p>
<h4 id="Redis集群参数配置"><a href="#Redis集群参数配置" class="headerlink" title="Redis集群参数配置"></a><strong>Redis集群参数配置</strong></h4><p>我们后面会部署一个Redis集群作为例子，在那之前，先介绍一下集群在redis.conf中的参数。</p>
<ul>
<li><code>cluster-enabled</code> &lt;yes/no&gt;: 如果配置”yes”则开启集群功能，此redis实例作为集群的一个节点，否则，它是一个普通的单一的redis实例。</li>
<li><code>cluster-config-file</code> <filename>: 注意：虽然此配置的名字叫“集群配置文件”，但是此配置文件不能人工编辑，它是集群节点自动维护的文件，主要用于记录集群中有哪些节点、他们的状态以及一些持久化参数等，方便在重启时恢复这些状态。通常是在收到请求之后这个文件就会被更新。</li>
<li><code>cluster-node-timeout</code> <milliseconds>: 这是集群中的节点能够失联的最大时间，超过这个时间，该节点就会被认为故障。如果主节点超过这个时间还是不可达，则用它的从节点将启动故障迁移，升级成主节点。注意，任何一个节点在这个时间之内如果还是没有连上大部分的主节点，则此节点将停止接收任何请求。</li>
<li><code>cluster-slave-validity-factor</code> <factor>: 如果设置成０，则无论从节点与主节点失联多久，从节点都会尝试升级成主节点。如果设置成正数，则cluster-node-timeout乘以cluster-slave-validity-factor得到的时间，是从节点与主节点失联后，此从节点数据有效的最长时间，超过这个时间，从节点不会启动故障迁移。假设cluster-node-timeout=5，cluster-slave-validity-factor=10，则如果从节点跟主节点失联超过50秒，此从节点不能成为主节点。注意，如果此参数配置为非0，将可能出现由于某主节点失联却没有从节点能顶上的情况，从而导致集群不能正常工作，在这种情况下，只有等到原来的主节点重新回归到集群，集群才恢复运作。</li>
<li><code>cluster-migration-barrier</code> <count>:主节点需要的最小从节点数，只有达到这个数，主节点失败时，它从节点才会进行迁移。更详细介绍可以看本教程后面关于副本迁移到部分。</li>
<li><code>cluster-require-full-coverage</code>&lt;yes/no&gt;:在部分key所在的节点不可用时，如果此参数设置为”yes”(默认值), 则整个集群停止接受操作；如果此参数设置为”no”，则集群依然为可达节点上的key提供读操作。</li>
</ul>
<h4 id="创建和使用Redis集群"><a href="#创建和使用Redis集群" class="headerlink" title="创建和使用Redis集群"></a><strong>创建和使用Redis集群</strong></h4><p>注意：手动部署Redis集群能够很好的了解它是如何运作的，但如果你希望尽快的让集群运行起来，可以跳过本节和下一节，直接到”使用create-cluster脚本创建Redis集群”章节。<br>要创建集群，首先需要以集群模式运行的空redis实例。也就说，以普通模式启动的redis是不能作为集群的节点的，需要以集群模式启动的redis实例才能有集群节点的特性、支持集群的指令，成为集群的节点。<br>下面是最小的redis集群的配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="string">port</span> <span class="number">7000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="string">cluster-enabled</span> <span class="literal">yes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="string">cluster-config-file</span> <span class="string">nodes.conf</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="string">cluster-node-timeout</span> <span class="number">5000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="string">appendonly</span> <span class="literal">yes</span></span></pre></td></tr></table></figure>

<p>开启集群模式只需打开cluster-enabled配置项即可。每一个redis实例都包含一个配置文件，默认是nodes.conf,用于存储此节点的一些配置信息。这个配置文件由redis集群的节点自行创建和更新，不能由人手动地去修改。<br>一个最小的集群需要最少３个主节点。第一次测试，强烈建议你配置６个节点：３个主节点和３个从节点。<br>开始测试，步骤如下：先进入新的目录，以redis实例的端口为目录名，创建目录，我们将在这些目录里运行我们的实例。<br>类似这样：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">mkdir</span> <span class="keyword">cluster</span>-<span class="keyword">test</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="keyword">cluster</span>-<span class="keyword">test</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">mkdir</span> 7000 7001 7002 7003 7004 7005</span></pre></td></tr></table></figure>

<p>在7000-7005的每个目录中创建配置文件redis.conf，内容就用上面的最简配置做模板，注意修改端口号，改为跟目录一致的端口。<br>把你的redis服务器(用GitHub中的不稳定分支的最新的代码编译来)拷贝到cluster-test目录，然后打开６个终端页准备测试。<br>在每个终端启动一个redis实例，指令类似这样：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> 7000</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="string">../redis-server</span> <span class="string">./redis.conf</span></span></pre></td></tr></table></figure>

<p>在日志中我们可以看到，由于没有<code>nodes.conf</code>文件不存在，每个节点都给自己一个新的ID。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">[<span class="number">82462</span>] <span class="number">26</span> Nov <span class="number">11</span>:<span class="number">56</span>:<span class="number">55.329</span> * No cluster configuration found, I<span class="string">'m 97a3a64667477371c4479320d683e4c8db5858b1</span></span></pre></td></tr></table></figure>

<p>这个ID将一直被此节点使用，作为此节点在整个集群中的唯一标识。节点区分其他节点也是通过此ID来标识，而非IP或端口。IP可以改，端口可以改，但此ID不能改，直到这个节点离开集群。这个ID称之为节点ID(Node ID)。</p>
<h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a><strong>创建集群</strong></h3><p>现在６个实例已经运行起来了，我们需要给节点写一些有意义的配置来创建集群。redis集群的命令工具<code>redis-trib</code>可以让我们创建集群变得非常简单。redis-trib是一个用ruby写的脚本，用于给各节点发指令创建集群、检查集群状态或给集群重新分片等。redis-trib在Redis源码的src目录下，需要gem redis来运行redis-trib。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">gem <span class="keyword">install</span> redis</span></pre></td></tr></table></figure>

<p>创建集群只需输入指令：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">./redis-trib.rb create --replicas <span class="number">1</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7000</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7001</span> \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7002</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7003</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7004</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7005</span></span></pre></td></tr></table></figure>

<p>这里用的命令是<code>create</code>，因为我们需要创建一个新的集群。选项”–replicas 1”表示每个主节点需要一个从节点。其他参数就是需要加入这个集群的redis实例的地址。<br>我们创建的集群有３个主节点和３个从节点。<br>redis-trib会给你一些配置建议，输入yes表示接受。集群会被配置并彼此连接好，意思是各节点实例被引导彼此通话并最终形成集群。最后，如果一切顺利，会看到类似下面的信息：</p>
<ol>
<li><p>[OK] All 16384 slots covered</p>
</li>
<li><p>这表示，16384个哈希槽都被主节点正常服务着。</p>
</li>
</ol>
<h4 id="使用create-cluster脚本创建redis集群"><a href="#使用create-cluster脚本创建redis集群" class="headerlink" title="使用create-cluster脚本创建redis集群"></a><strong>使用create-cluster脚本创建redis集群</strong></h4><p>如果你不想像上面那样，单独的手工配置各节点的方式来创建集群，还有一个更简单的系统（当然也没法了解到集群运作的一些细节）。<br>在utils/create-cluster目录下，有一个名为<code>create-cluster</code>的bash脚本。如果需要启动一个有3个主节点和３个从节点的集群，只需要输入以下指令</p>
<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">create-cluster</span> <span class="string">start</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="string">create-</span><span class="string">cluster </span><span class="string">create</span></span></pre></td></tr></table></figure>

<p>在步骤２，当redis-trib要你接受集群的布局时，输入”yes”。<br>现在你可以跟集群交互，第一个节点的起始端口默认是30001。当你完成后，停止集群用如下指令:</p>
<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">create-cluster</span> <span class="string">stop</span></span></pre></td></tr></table></figure>

<p>请查看目录下的<code>README</code>，它有详细的介绍如何使用此脚本。</p>
<h4 id="试用一下集群"><a href="#试用一下集群" class="headerlink" title="试用一下集群"></a><strong>试用一下集群</strong></h4><p>在这个阶段集群的其中一个问题就是客户端库比较少。<br>我知道的一些客户端库有：</p>
<ul>
<li>redis-rb-cluster 我用ruby写的，作为其他语言实现的一个参考。它是原来的redis-rb的简单封装，实现了集群交互的最基础功能。</li>
<li>redis-py-cluster redis-rb-cluster导出的python接口。支持大部分redis-py的功能，它处于活跃开发状态。</li>
<li>Predis 在最近的更新中已经支持Redis集群，并且在活跃开发状态。</li>
<li>java最常用的客户端 Jedis 最近加入对集群的支持，具体请查看Jedis README中关于集群章节。</li>
<li>StackExchange.Redis 支持C#，对于大部分.NET语言，VB,F#等应该都支持。</li>
<li>thunk-redid 支持Node.js和io.js。它是支持pipelining和集群的 thunk/promise-based redis 客户端</li>
<li>redis-cli 　在不稳定版分支中，对集群提供了最基础的支持，使用-c指令开启。</li>
</ul>
<p>可以用上面提供的客户端或redis-cli命令来测试集群。<br>下面用redis-cli来作为例子测试：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ redis-cli -c -p <span class="number">7000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7000</span>&gt; <span class="keyword">set</span> foo bar</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">-&gt; Redirected to slot [<span class="number">12182</span>] located at <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7002</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">OK</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7002</span>&gt; <span class="keyword">set</span> hello world</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">-&gt; Redirected to slot [<span class="number">866</span>] located at <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">OK</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7000</span>&gt; <span class="keyword">get</span> foo</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">-&gt; Redirected to slot [<span class="number">12182</span>] located at <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7002</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="string">"bar"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7000</span>&gt; <span class="keyword">get</span> hello</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">-&gt; Redirected to slot [<span class="number">866</span>] located at <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="string">"world"</span></span></pre></td></tr></table></figure>

<p>注意：如果你用脚本来创建的集群，你的redis可能监听在不同的端口，默认是从30001开始。<br>redis-cli利用集群的任意节点会告知客户端正确节点的特性，实现了集群客户端的最基础功能。实现得比较严谨的客户端可以缓存哈希槽到节点的映射关系，让客户端直接连接到正确的节点，只有集群的节点配置有更新时才刷新缓存，比如发生了故障迁移，或者管理员增加或减少了节点等。</p>
<h4 id="用redis-rb-cluster写一个应用例子"><a href="#用redis-rb-cluster写一个应用例子" class="headerlink" title="用redis-rb-cluster写一个应用例子"></a><strong>用redis-rb-cluster写一个应用例子</strong></h4><p>在进一步学习如何操作Redis集群之前，比如了解故障迁移、重新分片等，我们先理解客户端是如何与集群交互的。<br>我们通过一个例子，让部分节点故障或重新分片等，来了解这实际运作中，redis集群是如何处理的。如果这期间没有客户端对集群发起写操作，将不益于我们了解情况。<br>这节通过2个例子来演示redis-rb-cluster的基础用法，下面是第一个例子，源码在<code>redis-rb-cluster</code>目录下的<a href="https://github.com/antirez/redis-rb-cluster/blob/master/example.rb" target="_blank" rel="noopener"><code>example.rb</code></a>文件中。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'./cluster'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ARGV.length != <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    startup_nodes = [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        &#123;<span class="symbol">:host</span> =&gt; <span class="string">"127.0.0.1"</span>, <span class="symbol">:port</span> =&gt; <span class="number">6379</span>&#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        &#123;<span class="symbol">:host</span> =&gt; <span class="string">"127.0.0.1"</span>, <span class="symbol">:port</span> =&gt; <span class="number">6380</span>&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    startup_nodes = [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        &#123;<span class="symbol">:host</span> =&gt; ARGV[<span class="number">0</span>], <span class="symbol">:port</span> =&gt; ARGV[<span class="number">1</span>].to_i&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">end</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">rc = RedisCluster.new(startup_nodes,<span class="number">32</span>,<span class="symbol">:timeout</span> =&gt; <span class="number">0</span>.<span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">last = <span class="literal">false</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> last</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">begin</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        last = rc.get(<span class="string">"__last__"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        last = <span class="number">0</span> <span class="keyword">if</span> !last</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">rescue</span> =&gt; e</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        puts <span class="string">"error <span class="subst">#&#123;e.to_s&#125;</span>"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        sleep <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">end</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">end</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">((last.to_i+<span class="number">1</span>)..<span class="number">1000000000</span>).each&#123;<span class="params">|x|</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">begin</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        rc.set(<span class="string">"foo<span class="subst">#&#123;x&#125;</span>"</span>,x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        puts rc.get(<span class="string">"foo<span class="subst">#&#123;x&#125;</span>"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        rc.set(<span class="string">"__last__"</span>,x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">rescue</span> =&gt; e</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        puts <span class="string">"error <span class="subst">#&#123;e.to_s&#125;</span>"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">end</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    sleep <span class="number">0</span>.<span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个脚本做了一件非常简单的事情，它一个接一个地设类似“foo<number>”的数值为number，等效于于运行下面的指令：<br>* SET foo0 0<br>* SET foo1 1<br>* SET foo2 2<br>* 以此类推…<br>这脚本看起来比平普通的脚本复杂，因为在遇到错误的时候，它需要把错误显示出来，而不是因为一个异常就停止运行，所以每个操作都用”begin” “rescure”包裹起来。<br>第7行，创建了一个Redis Cluster对象，使用的3个参数分别是：第一个参数startup_nodes，客户端需要连接的集群的部分或全部节点列表；第二个参数是此对象连接集群内的各节点时允许创建的最大连接数；第三个参数是一个操作多久得不到响应则被判为失败的超时设定。<br>第一个参数startup_nodes不要求包含集群的所有节点，但要求至少有一个节点是正常运作的。注意，redis-rb-cluster在它连上第一个节点后，会自动更新startup_nodes，实现得比较严谨的其他客户端也应该是这样的。<br>现在，我们可以像使用普通的Redis对象实例一样，来使用变量名为rc的Redis集群对象实例了。<br>第11到19行：每次我们重新运行此脚本的时候，我们不希望每次都从”foo0″开始执行，所以我们在redis中存储了一个计数器，记录我们执行到哪了。这几行代码就是读这个计数器，如果这个计数器不存在，就给他个初始值:0。<br>注意一下while循环，我们希望这个脚本可以一直运行，哪怕在集群宕机的时候，打印一个error提示然后要继续运行。普通的应用程序可以不用这样。<br>第21到30行：写key的主循环。<br>注意最后一行的sleep调用，如果希望往集群中写的速度快点，可以把这行sleep调用删除（在最好的情况下，每秒可以执行1万个请求）。<br>为了方便我们跟踪脚本的情况，一般情况下我们会让它执行得慢点。<br>下面是我运行脚本的输出</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">ruby ./example.rb</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">^C (我停止了此脚本)</span></pre></td></tr></table></figure>

<p>这个脚本很无趣（后面我们再写个有趣点的），但它已经足够帮助我们了解重新分片的情况（需要让它一直运行着）。</p>
<h4 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a><strong>重新分片</strong></h4><p>现在，我们开始重新分片。在重新分片时，请让刚才的example.rb脚本继续运行，这样可以看到重新分片对此脚本的影响，同时，你可以把sleep调用注释掉，以便在重新分片过程中的增加写入的压力。<br>重新分片简单的说就是把哈希槽从一些节点移动到另外一些节点。重新分片可以像创建集群一样，使用redis-trib来完成。<br>开始重新分片，输入以下指令：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">./redis-trib.rb reshard <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7000</span></span></pre></td></tr></table></figure>

<p>你只需要指定集群中的一个节点，redis-trib会自动找到集群中的其他节点。<br>目前，redis-trib只支持管理员操作，不能够说：移动50％的哈希槽从这个节点到那个节点。它以问问题的方式开始。第一个问题是，你需要重新分片多少个哈希槽：</p>
<h4 id="How-many-slots-do-you-want-to-move-from-1-to-16384"><a href="#How-many-slots-do-you-want-to-move-from-1-to-16384" class="headerlink" title="How many slots do you want to move (from 1 to 16384)?"></a><strong>How many slots do you want to move (from 1 to 16384)?</strong></h4><p>由于我们之前的脚本一直在运行，而且没有用sleep调用，这时候应该已经插入了比较多的key了。我们可以尝试给1000个哈希槽重新分片。<br>然后，redis-trib需要知道我们要把这1000个哈希槽移动到哪个节点去，也就是接受这1000个哈希槽的节点。我想用127.0.0.1:7000这个节点。需要用节点ID来告知redis-trib是哪个节点。redis-trib已经在屏幕上列出了所有的节点和他们的ID。也可以通过以下命令找到指定节点的ID：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ redis-cli -p <span class="number">7000</span> cluster nodes | grep myself</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="number">97</span>a3a64667477371c4479320d683e4c8db5858b1 :<span class="number">0</span> myself,master - <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> connected <span class="number">0</span><span class="number">-5460</span></span></pre></td></tr></table></figure>

<p>好了，我的目标节点是97a3a64667477371c4479320d683e4c8db5858b1。<br>现在redis-trib会问：你想从哪些节点中挪走这些哈希槽呢？我输入all，会从其他的主节点中挪走哈希槽。<br>在输入最后确认之后，redis-trib在屏幕上会输出每一个哈希槽将从哪个节点转移到哪个节点。每实际移动一个key屏幕就会打印一个点。<br>在重新分片的过程中，你可以看到，你刚才运行的脚本不受影响，你甚至可以在重新分片的过程中，反复的重新运行该例子脚本。<br>在重新分片结束后，你可以检查集群的当前状态是否正常，运行下面的命令：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">.</span>/redis-trib.rb<span class="built_in"> check </span>127.0.0.1:7000</span></pre></td></tr></table></figure>

<p>所有的哈希槽都存在，这时候127.0.0.1:7000的主节点有多一点的哈希槽，有大概6461个。</p>
<h4 id="脚本化重新分片"><a href="#脚本化重新分片" class="headerlink" title="脚本化重新分片"></a><strong>脚本化重新分片</strong></h4><p>重新分片可以不用以交互的方式进行，使用下面的指令可以自动执行：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">./redis-trib.rb reshard --from <span class="symbol">&lt;node-id&gt;</span> --<span class="keyword">to</span> <span class="symbol">&lt;node-id&gt;</span> --slots &lt;<span class="keyword">number</span> of slots&gt; --yes <span class="symbol">&lt;host&gt;</span>:<span class="symbol">&lt;port&gt;</span></span></pre></td></tr></table></figure>

<p>如果你想要经常的重新分片，可以使用上面的指令自动分片，但是目前redis-trib脚本不会根据节点上的key的分布来做负载均衡、智能地迁移哈希槽。这个特性在将来我们会添加的。</p>
<h4 id="一个更有趣的例子"><a href="#一个更有趣的例子" class="headerlink" title="一个更有趣的例子"></a><strong>一个更有趣的例子</strong></h4><p>我们之前写的例子不太好，因为它只是简单的向集群写数据，却不检查写的数据是不是正确的。假设它一直往集群中写的都是把”set foo 42”, 我们也不会发现。<br>所以在redis-rb-cluster中有一个更有趣的例子，叫<a href="https://github.com/antirez/redis-rb-cluster/blob/master/consistency-test.rb" target="_blank" rel="noopener">consistency-test.rb</a>，它使用一组计数器，通过INCR指令来增加这些计数器。<br>除了只是<code>INCR</code>的写之外，它还做了2件其他事情：</p>
<ul>
<li>当一个计数器使用INCR指令的时候，该应用程序记录着它的返回值</li>
<li>每次写之前，先随机地读一个计数器，比较一下它的结果是否跟缓存的结果一致</li>
</ul>
<p>这个程序是一个简单的一致性检查器（consistency checker），如果计数器在redis中的数值小于缓存中的数值，则认为丢失了部分写；如果是大于，则认为多了一些不属于此应用程序加进去的数据。<br>运行此测试脚本，每秒会在屏幕显示类似以下的数据：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ ruby consistency-test.rb</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="number">925</span> R (<span class="number">0</span> err) | <span class="number">925</span> W (<span class="number">0</span> err) |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="number">5030</span> R (<span class="number">0</span> err) | <span class="number">5030</span> W (<span class="number">0</span> err) |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="number">9261</span> R (<span class="number">0</span> err) | <span class="number">9261</span> W (<span class="number">0</span> err) |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="number">13517</span> R (<span class="number">0</span> err) | <span class="number">13517</span> W (<span class="number">0</span> err) |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="number">17780</span> R (<span class="number">0</span> err) | <span class="number">17780</span> W (<span class="number">0</span> err) |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="number">22025</span> R (<span class="number">0</span> err) | <span class="number">22025</span> W (<span class="number">0</span> err) |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="number">25818</span> R (<span class="number">0</span> err) | <span class="number">25818</span> W (<span class="number">0</span> err) |</span></pre></td></tr></table></figure>

<p>每行显示一共执行了多少次读和写，以及相关的错误（读错误，是因为系统不能正常工作了）。<br>如果一些不一致性被检测到，屏幕也会有不一样的显示。下面就是一个例子，在该应用程序在运行的过程中，我手动的重置了一个计数器：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7000</span>&gt; <span class="keyword">set</span> key_217 <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">OK</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">(<span class="keyword">in</span> the other tab I see...)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="number">94774</span> R (<span class="number">0</span> err) | <span class="number">94774</span> W (<span class="number">0</span> err) |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="number">98821</span> R (<span class="number">0</span> err) | <span class="number">98821</span> W (<span class="number">0</span> err) |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="number">102886</span> R (<span class="number">0</span> err) | <span class="number">102886</span> W (<span class="number">0</span> err) | <span class="number">114</span> lost |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="number">107046</span> R (<span class="number">0</span> err) | <span class="number">107046</span> W (<span class="number">0</span> err) | <span class="number">114</span> lost |</span></pre></td></tr></table></figure>

<p>当我把一个本来是114的计数器设置成0的时候，此程序就报告有114个写丢失了。<br>这个例子作为一个测试用例非常有趣，下面我们用它来测试集群的故障迁移。</p>
<h4 id="测试故障迁移"><a href="#测试故障迁移" class="headerlink" title="测试故障迁移"></a><strong>测试故障迁移</strong></h4><p>注意：测试过程中，请让上面的一致性测试的应用程序一直运行中。<br>为了触发故障迁移，最简单的办法是让一个进程宕机，在我们的用例中，就是让其中一个主节点进程宕机。<br>我们可以用下面的指令区分集群节点：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ redis-cli -p <span class="number">7000</span> cluster nodes | grep master</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="number">3e3</span>a6cb0d9a9a87168e266b0a0b24026c0aae3f0 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7001</span> master - <span class="number">0</span> <span class="number">1385482984082</span> <span class="number">0</span> connected <span class="number">5960</span><span class="number">-10921</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="number">2938205e12</span>de373867bf38f1ca29d31d0ddb3e46 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7002</span> master - <span class="number">0</span> <span class="number">1385482983582</span> <span class="number">0</span> connected <span class="number">11423</span><span class="number">-16383</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="number">97</span>a3a64667477371c4479320d683e4c8db5858b1 :<span class="number">0</span> myself,master - <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> connected <span class="number">0</span><span class="number">-5959</span> <span class="number">10922</span><span class="number">-11422</span></span></pre></td></tr></table></figure>

<p>所以，7000，7001，7002是主节点，我们要使7002当机，使用DEBUG SEGFAULT指令：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7002 <span class="builtin-name">debug</span> segfault</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Error:<span class="built_in"> Server </span>closed the connection</span></pre></td></tr></table></figure>

<p>现在，我们看看刚才那个一致性检测器的例子输出了什么：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="number">18849</span> R (<span class="number">0</span> err) | <span class="number">18849</span> W (<span class="number">0</span> err) |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="number">23151</span> R (<span class="number">0</span> err) | <span class="number">23151</span> W (<span class="number">0</span> err) |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="number">27302</span> R (<span class="number">0</span> err) | <span class="number">27302</span> W (<span class="number">0</span> err) |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">... many error warnings here ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="number">29659</span> R (<span class="number">578</span> err) | <span class="number">29660</span> W (<span class="number">577</span> err) |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="number">33749</span> R (<span class="number">578</span> err) | <span class="number">33750</span> W (<span class="number">577</span> err) |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="number">37918</span> R (<span class="number">578</span> err) | <span class="number">37919</span> W (<span class="number">577</span> err) |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="number">42077</span> R (<span class="number">578</span> err) | <span class="number">42078</span> W (<span class="number">577</span> err) |</span></pre></td></tr></table></figure>

<p>我们看到，例子显示有578个读失败和577个写失败，但没有不一致性产生。我们前面的章节提到过，redis集群不是强一致性的，由于它异步复制数据到从节点，可能会在主节点失败的情况下导致数据丢失，但是上面的例子显示没有不一致性产生，为什么呢？因为主节点响应客户端后马上同步数据给从节点，这几乎是同时的，这里的时间差非常小，只有在这个非常小的时间差中主节点故障，才会发生不一致性。尽管发生的可能性很小，不代表它不可能发生，redis集群依然不是强一致性的。<br>现在我们看看当该节点故障之后，集群做了什么（注意，我已经重启了该故障的节点，它已经重新连上集群，并成为了从节点）：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ redis-cli -p <span class="number">7000</span> cluster nodes</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="number">3f</span>c783611028b1707fd65345e763befb36454d73 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7004</span> slave <span class="number">3e3</span>a6cb0d9a9a87168e266b0a0b24026c0aae3f0 <span class="number">0</span> <span class="number">1385503418521</span> <span class="number">0</span> connected</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">a211e242fc6b22a9427fed61285e85892fa04e08 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7003</span> slave <span class="number">97</span>a3a64667477371c4479320d683e4c8db5858b1 <span class="number">0</span> <span class="number">1385503419023</span> <span class="number">0</span> connected</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="number">97</span>a3a64667477371c4479320d683e4c8db5858b1 :<span class="number">0</span> myself,master - <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> connected <span class="number">0</span><span class="number">-5959</span> <span class="number">10922</span><span class="number">-11422</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>c3a0c74aae0b56170ccb03a76b60cfe7dc1912e <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7005</span> master - <span class="number">0</span> <span class="number">1385503419023</span> <span class="number">3</span> connected <span class="number">11423</span><span class="number">-16383</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="number">3e3</span>a6cb0d9a9a87168e266b0a0b24026c0aae3f0 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7001</span> master - <span class="number">0</span> <span class="number">1385503417005</span> <span class="number">0</span> connected <span class="number">5960</span><span class="number">-10921</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="number">2938205e12</span>de373867bf38f1ca29d31d0ddb3e46 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7002</span> slave <span class="number">3</span>c3a0c74aae0b56170ccb03a76b60cfe7dc1912e <span class="number">0</span> <span class="number">1385503418016</span> <span class="number">3</span> connected</span></pre></td></tr></table></figure>

<p>现在，主节点的端口变成了：7000，7001，7005（之前主节点是7002的，现在变成主节点是7005了）。<br>“cluster nodes”指令的输出看起来蛮吓人的，其实很简单，它的每列意义如下：<br>*节点ID<br>*IP:端口<br>*标记位：主节点，从节点，自己，失败。。。<br>*如果是从节点，则接下来是它的主节点的ID<br>*最后一次发送ping依然等待响应的时间<br>*最后一次收到pong的时间<br>*上次更新此配置的时间<br>*节点的连接状态<br>*存储的哈希槽</p>
<h4 id="手动故障转移"><a href="#手动故障转移" class="headerlink" title="手动故障转移"></a><strong>手动故障转移</strong></h4><p>有时候，手动故障转移是非常有用的，它不会给主节点带来任何问题，比如，需要升级某个主节点的redis进程，可以先通过手动故障转移使之成为从节点，让升级对集群可用性的影响达到最低。<br>redis集群支持通过指令”CLUSTER FAILOVER”产生故障转移，但需要在被失效的主节点的一个从节点上执行该命令。<br>相对于真的主节点宕机，手动故障转移是比较安全的，它可以避免数据丢失，当新的主节点复制完所有数据之后，会让客户端从原来的主节点重定向到新的主节点。<br>下面是在其中一个从节点上执行了cluster failover指令之后看到的一些日志:</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta"># Manual failover user request accepted.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta"># Received replication offset for paused master manual failover: 347540</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta"># All master replication stream processed, manual failover can start.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta"># Start of election delayed for 0 milliseconds (rank #0, offset 347540).</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="meta"># Starting a failover election for epoch 7545.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="meta"># Failover election won: I'm the new master.</span></span></pre></td></tr></table></figure>

<p>简单的说：客户端停止连接被故障转移的原主节点；同时该原主节点把还没同步的复制集同步给从节点；当从节点收到所有复制集之后，故障转移开始，原来主节点被通知配置更新，主节点更换了；客户端被重定向到新的主节点。</p>
<h4 id="新增新的节点"><a href="#新增新的节点" class="headerlink" title="新增新的节点"></a><strong>新增新的节点</strong></h4><p>新增一个节点，就增加一个空的节点到集群。有两种情况：如果新增的是主节点，则是从集群的其他节点中转移部分数据给它；如果新增的是从节点，则告诉它从一个已知的节点中同步复制集。<br>我们2种情况都试试。首先是新增一个新的主节点到集群中。<br>两种情况，都是需要先加入一个空的节点到集群中<br>鉴于我们前面已经启动了6个节点，端口号7000-7005已经用了，新增节点的端口号就用7006吧。新增一个新的空节点，就跟上面启动前面6个节点的步骤一样（记得改配置文件的端口号）：</p>
<ul>
<li>*在终端打开一个新的页面</li>
<li>*进入到cluster-test目录</li>
<li>*创建名为“7006”的目录</li>
<li>*在该目录下创建redis.conf文件，内容跟其他节点的内容一致，只是端口号改成7006.</li>
<li>*最后启动它：../redis-server ./redis.conf</li>
</ul>
<p>现在该节点应该运行起来了。<br>现在，我们使用redis-trib来增加一个新节点到集群中：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">.</span>/redis-trib.rb<span class="built_in"> add-node </span>127.0.0.1:7006 127.0.0.1:7000</span></pre></td></tr></table></figure>

<p>使用add-node指令来新增节点，第一个地址是需要新增的节点地址，第二个地址是集群中任意一个节点地址。<br>redis-trib脚本只是给发送CLUSTER MEET消息给节点，这也可以手动地通过客户端发送，但redis-trib在发送之前会检查集群的状态，所以，还是用redis-trib脚本来操作集群会比较好。<br>现在我们可以连上新的节点，看看它是不是已经加入集群了：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7006</span>&gt; cluster nodes</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="number">3e3</span>a6cb0d9a9a87168e266b0a0b24026c0aae3f0 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7001</span> master - <span class="number">0</span> <span class="number">1385543178575</span> <span class="number">0</span> connected <span class="number">5960</span><span class="number">-10921</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="number">3f</span>c783611028b1707fd65345e763befb36454d73 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7004</span> slave <span class="number">3e3</span>a6cb0d9a9a87168e266b0a0b24026c0aae3f0 <span class="number">0</span> <span class="number">1385543179583</span> <span class="number">0</span> connected</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">f093c80dde814da99c5cf72a7dd01590792b783b :<span class="number">0</span> myself,master - <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> connected</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="number">2938205e12</span>de373867bf38f1ca29d31d0ddb3e46 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7002</span> slave <span class="number">3</span>c3a0c74aae0b56170ccb03a76b60cfe7dc1912e <span class="number">0</span> <span class="number">1385543178072</span> <span class="number">3</span> connected</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">a211e242fc6b22a9427fed61285e85892fa04e08 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7003</span> slave <span class="number">97</span>a3a64667477371c4479320d683e4c8db5858b1 <span class="number">0</span> <span class="number">1385543178575</span> <span class="number">0</span> connected</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="number">97</span>a3a64667477371c4479320d683e4c8db5858b1 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7000</span> master - <span class="number">0</span> <span class="number">1385543179080</span> <span class="number">0</span> connected <span class="number">0</span><span class="number">-5959</span> <span class="number">10922</span><span class="number">-11422</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>c3a0c74aae0b56170ccb03a76b60cfe7dc1912e <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7005</span> master - <span class="number">0</span> <span class="number">1385543177568</span> <span class="number">3</span> connected <span class="number">11423</span><span class="number">-16383</span></span></pre></td></tr></table></figure>

<p>虽然现在此新节点已经连到集群，并且可以重定向客户端到正确的集群节点了，但是它跟集群的其他主节点有个不同的地方：</p>
<ul>
<li>*它没有数据，因为没有分配哈希槽给它</li>
<li>*因为它是一个没有哈希槽的主节点，当一个从节点需要被选举成新主节点时，它没有参与权</li>
</ul>
<p>可以通过redis-trib的重新分片指令来给新节点增加哈希槽。由于前面已经介绍过如何重新分片了，这里就不做详细介绍。</p>
<h4 id="添加一个从节点"><a href="#添加一个从节点" class="headerlink" title="添加一个从节点"></a><strong>添加一个从节点</strong></h4><p>新增从节点有两种方法，第一个是使用上面的redis-trib脚本，增–slave选项，类似这样：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">.</span>/redis-trib.rb<span class="built_in"> add-node </span>--slave 127.0.0.1:7006 127.0.0.1:7000</span></pre></td></tr></table></figure>

<p>注意到上面的命令行跟我们加主节点的命令行类似，所以没有没有指定新增的从节点的主节点是哪个，这时候redis-trib会在拥有最少从节点的主节点中随机选一个作为新增节点的主节点。<br>当然也可以通过如下的命令指定新增从节点的主节点：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">.</span>/redis-trib.rb<span class="built_in"> add-node </span>--slave --master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7006 127.0.0.1:7000</span></pre></td></tr></table></figure>

<p>用上面的指令，我们可以指定新的从节点是那个主节点的副本集。<br>另一个方法，先把新节点以主节点的形式加入到集群，然后再用“CLUSTER REPLICATE”指令把它变为从节点。这个方式也适用于给从节点更换主节点。<br>比如，已有主节点127.0.0.1:7005，它存储的哈希槽范围是11423-16383，节点ID为3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e，我们希望给它新增从节点。首先用之前的方法新增一个空的主节点，然后连上该新节点，发送如下指令：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7006</span>&gt; cluster replicate <span class="number">3</span>c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</span></pre></td></tr></table></figure>

<p>这样，新的从节点添加成功，而且集群中其他所有节点都已经知道新节点了（可能需要一些时间来更新配置）。我们可以通过以下指令来验证：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ redis-cli -p <span class="number">7000</span> cluster nodes | grep slave | grep <span class="number">3</span>c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">f093c80dde814da99c5cf72a7dd01590792b783b <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7006</span> slave <span class="number">3</span>c3a0c74aae0b56170ccb03a76b60cfe7dc1912e <span class="number">0</span> <span class="number">1385543617702</span> <span class="number">3</span> connected</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="number">2938205e12</span>de373867bf38f1ca29d31d0ddb3e46 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7002</span> slave <span class="number">3</span>c3a0c74aae0b56170ccb03a76b60cfe7dc1912e <span class="number">0</span> <span class="number">1385543617198</span> <span class="number">3</span> connected</span></pre></td></tr></table></figure>

<p>现在节点3c3a0c…有2个从节点，分别是原来的运行在7002端口的节点和刚刚新增的7006端口的节点。</p>
<h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a><strong>删除节点</strong></h4><p>使用redis-trib的指令”del-node”可以删除节点：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">./redis-trib del-<span class="keyword">node</span> <span class="title">127</span>.<span class="number">0.0</span>.<span class="number">1</span>:<span class="number">7000</span> `<span class="keyword">node</span><span class="title">-id</span>`</span></pre></td></tr></table></figure>

<p>第一个参数是集群的任意一个节点，第二个参数是需要删除的节点的ID。<br>同样的方法可以删除主节点，但是在删除之前，需要通过重新分片把数据都移走。<br>另一个删除主节点的方式是通过手动故障转移，让它的其中一个从节点升级成主节点后再把此节点删除。但这样并不会减少集群的主节点数，如果需要减少主节点数，重新分片在所难免。</p>
<h4 id="复制集迁移"><a href="#复制集迁移" class="headerlink" title="复制集迁移"></a><strong>复制集迁移</strong></h4><p>在redis集群中，可以通过如下指令，在任意时间给从节点更换主节点：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">CLUSTER</span> REPLICATE &lt;master-node-<span class="keyword">id</span>&gt;</span></pre></td></tr></table></figure>

<p>有一种特殊的场景：系统自动地更改复制集的主节点，而不是要管理员手动处理。这种自动重新配置从节点的情景叫副本集迁移（replicas migration），它可以增加redis集群的健壮性。<br>注意：你可以通过《Redis Cluster Specification》了解更多详细的内容，这里只是对它的简单介绍以及它的用处。<br>假如一个每个主节点只有一个从节点的集群，在一个主节点和从节点同时故障的情况下，集群将不能继续工作，因为已经故障的节点中存储的哈希槽数据已经没法读写。虽然网络断开很可能会让一大批节点同时被隔离，但是还有很多其他情况会导致节点故障，比如硬件或者软件的故障导致一个节点宕机，也是非常重要的导致节点故障的原因，这种情况一般不会所有节点同时故障。比如，集群中每个主节点都有一个从节点，在4点的时候一个从节点被kill，该主节点在6点被kill。这样依然会导致集群不能工作。<br>为了增强系统的可用性，可以给每个主节点再增加一个从节点，但这样做是比较昂贵的。复制集迁移可以让我们只给部分主节点增加多些从节点。比如有10个主节点，每个主节点有1个从节点，总共20个节点，然后可以再增加一些从节点（比如3个从节点）到一些主节点，这样就有部分主节点的从节点数超过1。<br>当一个主节点没有从节点时，如果集群中存在一个主节点有多个从节点时，复制集迁移机制在这些多个从节点中找一个节点，给没有从节点的主节点做复制集。所以当4点钟一个从节点宕机，另一个从节点将会代替它成为该主节点的从节点；然后在5点钟主节点宕机时还有一个从节点可以升级成主节点，这样集群可以继续运行。<br>所以，简单的说副本集迁移就是：<br>*集群会找到拥有最多从节点的主节点，在它的从节点中挑选一个，进行复制集迁移<br>*为了让复制集迁移生效，只需要在集群中多加几个从节点，随便加到哪个主节点都可以<br>*关于复制集迁移，有一个配置参数叫“cluster-migration-barrier”，在集群的样板配置文件中有详细说明，需要了解清楚</p>
<h4 id="升级集群中的节点"><a href="#升级集群中的节点" class="headerlink" title="升级集群中的节点"></a><strong>升级集群中的节点</strong></h4><p>升级从节点非常简单，只要停止它再重启更新过的版本即可。如果客户端连到了从节点，在该节点不可用时，客户端需要重连到另外可用的从节点上。<br>升级主点则相对复杂，下面是推荐的流程：<br>\1. 使用CLUSTER FAILOVER指令触发手动故障转移，让主节点变成从节点<br>\2. 等到主节点成为从节点<br>3.升级该从节点<br>\4. 如果你想让升级过的节点重新变成主节点，则再次触发手动故障转移，让它变成新的主节点。<br>用这样的步骤，一个个的升级所有节点。</p>
<h4 id="迁移到redis集群"><a href="#迁移到redis集群" class="headerlink" title="迁移到redis集群"></a><strong>迁移到redis集群</strong></h4><p>用户需要把redis的数据迁移到redis集群，原来的数据可能是只有一个主节点，也可能是用已有的方式分片过，key被存储在N个几节点中。<br>上面2中情况都很容易迁移，特别重要的细节是是否使用了多个key以及是如何使用多个key的。下面是3种不同的情况：<br>\1. 没有操作多个key（包括操作多个key的指令、事务、lua脚本）。所有key都是独立操作的.<br>\2. 操作了多个key（包括操作多个key的指令、事务、lua脚本），但这些key都有相同的哈希标签，比如这些被同时操作的key：SUNION{user:1000}.foo {user:1000}.bar<br>\3. 操作了多个key（包括操作多个key的指令、事务、lua脚本），这些key没有特别处理，也没有相同标签。<br>第三种情况redis集群没法处理，需要修改应用程序，不要使用多个key，或者给这些key加上相同的哈希标签。<br>第一和第二种情况可以处理，而且他们的处理方式一样。<br>假设你已有的数据被分成N个主节点存储（当N=1时，就是没有分片的情况），要把数据迁移到redis集群，需要执行下面几个步骤：<br>\1. 停止你的客户端。目前没有自动在线迁移到redis集群的方法。你可以自己策划如何让你的应用程序支持在线迁移。<br>\2. 使用BGREWRITEAOF指令让所有主节点产生AOF文件，并且等待这些文件创建完成。<br>\3. 把这些AOF文件保存下来，分别命名为aof-1, aof-2, ..aof-N，如果需要，可以停止原来的redis实例（对于非虚拟化部署，需要重用这台电脑来说，把旧进程停掉很有帮助）。<br>\4. 创建N个主节点+0个从节点的redis集群。晚些时候再添加从节点。请确认所有节点都开启了appendonly的配置。<br>\5. 停止集群的所有节点，然后用刚才保存的AOF文件，代替每个节点的AOF文件，aof-1给第一个节点，aof-2给第二个节点，以此类推。<br>\6. 重启所有节点，这些节点可能会提示说根据配置有些key不应该存储在这个节点。<br>\7. 使用redis-trib fix指令，让集群自动根据哈希槽迁移数据<br>\8. 使用redis-trib check指令确保你的集群是正常的<br>\9. 让你的客户端使用redis集群客户端库，并重启它。<br>还有一个方法可以从已有的redis实例中导入数据到redis集群，使用redis-trib import指令。该指令会把源实例中的数据都删除，并把数据写入事先部署好的集群中。需要注意的是，如果你的源实例使用的是redis2.8版本，这个导入过程可能会比较长，因为2.8版本没有实现数据迁移的连接缓存，所以最好把源实例的redis版本先升级到3.x的版本。<br><a href="http://ifeve.com/redis-cluster-spec/" target="_blank" rel="noopener">http://ifeve.com/redis-cluster-spec/</a><br><a href="http://ifeve.com/redis-cluster-tutorial/" target="_blank" rel="noopener">http://ifeve.com/redis-cluster-tutorial/</a></p>
<blockquote>
<p>作者：田守芝<br>来源：<a href="http://www.tianshouzhi.com/api/tutorials/redis/205" target="_blank" rel="noopener">http://www.tianshouzhi.com/api/tutorials/redis/205</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/" rel="tag"># 高可用</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/29/Redis%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%884%EF%BC%89%EF%BC%9AJedis/" rel="prev" title="Redis使用教程（4）：Jedis">
      <i class="fa fa-chevron-left"></i> Redis使用教程（4）：Jedis
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/29/Redis%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%886%EF%BC%89%EF%BC%9A%E7%AE%A1%E7%90%86/" rel="next" title="Redis使用教程（6）：管理">
      Redis使用教程（6）：管理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#6-reids高可用"><span class="nav-number">1.</span> <span class="nav-text">6 reids高可用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-持久化"><span class="nav-number">1.1.</span> <span class="nav-text">6.1 持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1-RDB方式"><span class="nav-number">1.1.1.</span> <span class="nav-text">6.1.1 RDB方式**</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RDB-的优点"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">RDB 的优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RDB-的缺点"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">RDB 的缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-2-AOF方式"><span class="nav-number">1.1.2.</span> <span class="nav-text">6.1.2 AOF方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF-的优点"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">AOF 的优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF-的缺点"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">AOF 的缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RDB-和-AOF-我应该用哪一个？"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">RDB 和 AOF ,我应该用哪一个？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-主从复制"><span class="nav-number">1.2.</span> <span class="nav-text">6.2 主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-配置"><span class="nav-number">1.2.1.</span> <span class="nav-text">6.2.1 配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-原理"><span class="nav-number">1.2.2.</span> <span class="nav-text">6.2.2 原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-3-图结构"><span class="nav-number">1.2.3.</span> <span class="nav-text">6.2.3 图结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-4-读写分离"><span class="nav-number">1.2.4.</span> <span class="nav-text">6.2.4 读写分离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-5-从数据库持久化"><span class="nav-number">1.2.5.</span> <span class="nav-text">6.2.5 从数据库持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-6-总结"><span class="nav-number">1.2.6.</span> <span class="nav-text">6.2.6 总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#当主服务器不进行持久化时复制的安全性"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">当主服务器不进行持久化时复制的安全性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#部分重新同步"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">部分重新同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无磁盘复制"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">无磁盘复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设置从服务器到主服务器验证"><span class="nav-number">1.2.6.4.</span> <span class="nav-text">设置从服务器到主服务器验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#限制有N个以上从服务器才允许写入"><span class="nav-number">1.2.6.5.</span> <span class="nav-text">限制有N个以上从服务器才允许写入</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-redis-sentinel"><span class="nav-number">1.3.</span> <span class="nav-text">6.3 redis-sentinel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Sentinel的分布式特性"><span class="nav-number">1.3.1.</span> <span class="nav-text">Sentinel的分布式特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速开始"><span class="nav-number">1.3.2.</span> <span class="nav-text">快速开始</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行Sentinel"><span class="nav-number">1.3.3.</span> <span class="nav-text">运行Sentinel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#部署之前了解关于Sentinel的基本东西"><span class="nav-number">1.3.4.</span> <span class="nav-text">部署之前了解关于Sentinel的基本东西</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sentinel配置"><span class="nav-number">1.3.5.</span> <span class="nav-text">Sentinel配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他的Sentinels选项"><span class="nav-number">1.3.6.</span> <span class="nav-text">其他的Sentinels选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sentinel部署示例"><span class="nav-number">1.3.7.</span> <span class="nav-text">Sentinel部署示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例1：仅仅只有两个Sentinels，永远不要这么做"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">示例1：仅仅只有两个Sentinels，永远不要这么做</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例2：三个box的基本设置"><span class="nav-number">1.3.7.2.</span> <span class="nav-text">示例2：三个box的基本设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例3：Sentinel在客户端所在的box中"><span class="nav-number">1.3.7.3.</span> <span class="nav-text">示例3：Sentinel在客户端所在的box中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例4：Sentinel-客户端-这一边少于三个客户端"><span class="nav-number">1.3.7.4.</span> <span class="nav-text">示例4：Sentinel 客户端 这一边少于三个客户端</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sentinel，Docker-NAT-和可能的问题"><span class="nav-number">1.3.8.</span> <span class="nav-text">Sentinel，Docker,NAT 和可能的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速教程"><span class="nav-number">1.3.9.</span> <span class="nav-text">快速教程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取当前主节点的地址"><span class="nav-number">1.3.10.</span> <span class="nav-text">获取当前主节点的地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#故障转移测试"><span class="nav-number">1.3.11.</span> <span class="nav-text">故障转移测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sentinel-API"><span class="nav-number">1.3.12.</span> <span class="nav-text">Sentinel API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sentinel命令"><span class="nav-number">1.3.13.</span> <span class="nav-text">Sentinel命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时重新配置Sentinel"><span class="nav-number">1.3.14.</span> <span class="nav-text">运行时重新配置Sentinel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#添加和移除sentinels"><span class="nav-number">1.3.15.</span> <span class="nav-text">添加和移除sentinels</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#移除旧的主节点或不可达的从节点"><span class="nav-number">1.3.16.</span> <span class="nav-text">移除旧的主节点或不可达的从节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发布-订阅消息"><span class="nav-number">1.3.17.</span> <span class="nav-text">发布/订阅消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从节点优先"><span class="nav-number">1.3.18.</span> <span class="nav-text">从节点优先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sentinel和Redis权限"><span class="nav-number">1.3.19.</span> <span class="nav-text">Sentinel和Redis权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sentinel-客户端实现"><span class="nav-number">1.3.20.</span> <span class="nav-text">Sentinel 客户端实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更高级的概念"><span class="nav-number">1.3.21.</span> <span class="nav-text">更高级的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SDOWN和ODOWN失败状态"><span class="nav-number">1.3.21.1.</span> <span class="nav-text">SDOWN和ODOWN失败状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sentinels和从节点自动发现"><span class="nav-number">1.3.21.2.</span> <span class="nav-text">Sentinels和从节点自动发现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#故障转移之外重新配置"><span class="nav-number">1.3.21.3.</span> <span class="nav-text">故障转移之外重新配置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-Redis-分区"><span class="nav-number">1.4.</span> <span class="nav-text">6.4 Redis 分区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分区的优势"><span class="nav-number">1.4.1.</span> <span class="nav-text">分区的优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分区的不足"><span class="nav-number">1.4.2.</span> <span class="nav-text">分区的不足</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分区类型"><span class="nav-number">1.4.3.</span> <span class="nav-text">分区类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#范围分区"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">范围分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#哈希分区"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">哈希分区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分区不同实现方式"><span class="nav-number">1.4.4.</span> <span class="nav-text">分区不同实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作为数据存储还是作为缓存使用？"><span class="nav-number">1.4.5.</span> <span class="nav-text">作为数据存储还是作为缓存使用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预分片"><span class="nav-number">1.4.6.</span> <span class="nav-text">预分片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分区实践"><span class="nav-number">1.4.7.</span> <span class="nav-text">分区实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis集群"><span class="nav-number">1.4.7.1.</span> <span class="nav-text">Redis集群</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Twemproxy-框架"><span class="nav-number">1.4.7.2.</span> <span class="nav-text">Twemproxy 框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#客户端一致性哈希实现"><span class="nav-number">1.4.7.3.</span> <span class="nav-text">客户端一致性哈希实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-redis集群实战"><span class="nav-number">1.5.</span> <span class="nav-text">6.5 redis集群实战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis集群-1"><span class="nav-number">1.5.1.</span> <span class="nav-text">Redis集群</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis集群的TCP端口"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">Redis集群的TCP端口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis集群数据的分片"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">Redis集群数据的分片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis集群的主从模式"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">Redis集群的主从模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis集群的一致性保证"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">Redis集群的一致性保证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis集群参数配置"><span class="nav-number">1.5.1.5.</span> <span class="nav-text">Redis集群参数配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建和使用Redis集群"><span class="nav-number">1.5.1.6.</span> <span class="nav-text">创建和使用Redis集群</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建集群"><span class="nav-number">1.5.2.</span> <span class="nav-text">创建集群</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用create-cluster脚本创建redis集群"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">使用create-cluster脚本创建redis集群</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#试用一下集群"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">试用一下集群</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用redis-rb-cluster写一个应用例子"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">用redis-rb-cluster写一个应用例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重新分片"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">重新分片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#How-many-slots-do-you-want-to-move-from-1-to-16384"><span class="nav-number">1.5.2.5.</span> <span class="nav-text">How many slots do you want to move (from 1 to 16384)?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#脚本化重新分片"><span class="nav-number">1.5.2.6.</span> <span class="nav-text">脚本化重新分片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一个更有趣的例子"><span class="nav-number">1.5.2.7.</span> <span class="nav-text">一个更有趣的例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#测试故障迁移"><span class="nav-number">1.5.2.8.</span> <span class="nav-text">测试故障迁移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#手动故障转移"><span class="nav-number">1.5.2.9.</span> <span class="nav-text">手动故障转移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#新增新的节点"><span class="nav-number">1.5.2.10.</span> <span class="nav-text">新增新的节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#添加一个从节点"><span class="nav-number">1.5.2.11.</span> <span class="nav-text">添加一个从节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除节点"><span class="nav-number">1.5.2.12.</span> <span class="nav-text">删除节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复制集迁移"><span class="nav-number">1.5.2.13.</span> <span class="nav-text">复制集迁移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#升级集群中的节点"><span class="nav-number">1.5.2.14.</span> <span class="nav-text">升级集群中的节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迁移到redis集群"><span class="nav-number">1.5.2.15.</span> <span class="nav-text">迁移到redis集群</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">congsheng.wang</p>
  <div class="site-description" itemprop="description">trouble is a friend</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">503</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">83</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">111</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">congsheng.wang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
