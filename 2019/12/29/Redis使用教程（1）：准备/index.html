<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://congsheng.wang').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="1 Redis简介Redis是一个开源的高性能键值对数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，并借助许多高层级的接口使其可以胜任如缓存、队列系统等不同的角色。本章将分别介绍Redis的历史和特性，以使读者能够快速地对Redis有一个全面的了解。">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis使用教程（1）：准备">
<meta property="og:url" content="http:&#x2F;&#x2F;congsheng.wang&#x2F;2019&#x2F;12&#x2F;29&#x2F;Redis%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89%EF%BC%9A%E5%87%86%E5%A4%87&#x2F;index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="1 Redis简介Redis是一个开源的高性能键值对数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，并借助许多高层级的接口使其可以胜任如缓存、队列系统等不同的角色。本章将分别介绍Redis的历史和特性，以使读者能够快速地对Redis有一个全面的了解。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;5cca8-1458321704791041932.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;d3d73-1458269719795012616.png">
<meta property="og:updated_time" content="2019-12-29T05:28:43.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;5cca8-1458321704791041932.png">

<link rel="canonical" href="http://congsheng.wang/2019/12/29/Redis%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89%EF%BC%9A%E5%87%86%E5%A4%87/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Redis使用教程（1）：准备 | 个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">winrains的个人博客</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">108</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">83</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">489</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://congsheng.wang/2019/12/29/Redis%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89%EF%BC%9A%E5%87%86%E5%A4%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="winrains">
      <meta itemprop="description" content="淡泊明志">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis使用教程（1）：准备
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-29 13:28:43" itemprop="dateCreated datePublished" datetime="2019-12-29T13:28:43+08:00">2019-12-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">Java技术</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-Redis简介"><a href="#1-Redis简介" class="headerlink" title="1 Redis简介"></a>1 Redis简介</h1><p><img src="http://image.winrains.cn/2019/10/5cca8-1458321704791041932.png" alt="QQ截图20160319012123.png"><br>Redis是一个开源的高性能键值对数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，并借助许多高层级的接口使其可以胜任如缓存、队列系统等不同的角色。本章将分别介绍Redis的历史和特性，以使读者能够快速地对Redis有一个全面的了解。</p>
<a id="more"></a>

<h2 id="1-1-历史与发展"><a href="#1-1-历史与发展" class="headerlink" title="1.1 历史与发展**"></a>1.1 历史与发展**</h2><p>2008年，意大利的一家创业公司Merzia.推出了一款基于MySQL的网站实时统计系统LLOOGG ，然而没过多久该公司的创始人Salvatore Sanfilippo便开始对MySQL的性能感到失望，于是他决定亲自为LLOOGG量身定做一个数据库，并于2009年开发完成，这个数据库就是Redis。不过Salvatore Sanfilippo并不满足只将Redis用于LLOOGG这一款产品，而是希望让更多的人使用它，于是在同一年Salvatore Sanfilippo将Redis开源发布，并开始和Redis的另一名主要的代码贡献者Pieter Noordhuis一起继续着Redis的开发，直到今天。<br>Salvatore Sanfilippo自己也没有想到，短短的几年时间，Redis就拥有了庞大的用户群体。Hacker News在2012年发布了一份数据库的使用情况调查 ，结果显示有近12%的公司在使用Redis。国内如新浪微博、街旁和知乎，国外如GitHub、Stack Overflow、Flickr、暴雪和Instagram，都是Redis的用户。<br>VMware公司从2010年开始赞助Redis的开发，Salvatore Sanfilippo和Pieter Noordhuis也分别于同年的3月和5月加入VMware，全职开发Redis。</p>
<h2 id="1-2-特性"><a href="#1-2-特性" class="headerlink" title="1.2 特性"></a><strong>1.2 特性</strong></h2><p>作为一款个人开发的数据库，Redis究竟有什么魅力吸引了如此多的用户呢？**<br>**</p>
<h3 id="1-2-1-存储结构"><a href="#1-2-1-存储结构" class="headerlink" title="1.2.1 存储结构"></a><strong>1.2.1 存储结构</strong></h3><p>有过脚本语言编程经验的读者对字典（或称映射、关联数组）数据结构一定很熟悉，如代码dict[“key”]=”value”中dict是一个字典结构变量，字符串”key”是键名，而”value”是键值，在字典中我们可以获取或设置键名对应的键值，也可以删除一个键。Redis是REmote DIctionary Server（远程字典服务器）的缩写，它以字典结构存储数据，并允许其他应用通过TCP协议读写字典中的内容。同大多数脚本语言中的字典一样，Redis字典中的键值除了可以是字符串，还可以是其他数据类型。到目前为止Redis支持的键值数据类型如下：<br>●字符串类型<br>●散列类型<br>●列表类型<br>●集合类型<br>●有序集合类型<br>这种字典形式的存储结构与常见的MySQL 等关系数据库的二维表形式的存储结构有很大的差异。举个例子，如下所示，我们在程序中使用post变量存储了一篇文章的数据（包括标题、正文、阅读量和标签）：</p>
<ol>
<li>post[“title”]=”Hello World!”</li>
<li>post[“content”]=”Blablabla…”</li>
<li>post[“views”]=0</li>
<li>post[“tags”]=[“PHP”,”Ruby”,”Node.js”]</li>
</ol>
<p>现在我们希望将这篇文章的数据存储在数据库中，并且要求可以通过标签检索出文章。如果使用关系数据库存储，一般会将其中的标题、正文和阅读量存储在一个表中，而将标签存储在另一个表中，然后使用第三个表连接文章和标签表 。需要查询时还得将三个表进行连接，不是很直观。而Redis字典结构的存储方式和对多种键值数据类型的支持使得开发者可以将程序中的数据直接映射到Redis中，数据在Redis中的存储形式和其在程序中的存储方式非常相近。使用Redis的另一个优势是其对不同的数据类型提供了非常方便的操作方式，如使用集合类型存储文章标签，Redis可以对标签进行如交集、并集这样的集合运算操作。后文会专门介绍如何借助集合运算轻易地实现“找出所有同时属于A标签和B标签且不属于C标签”这样关系数据库实现起来性能不高且较为繁琐的操作。</p>
<h3 id="1-2-2-内存存储与持久化"><a href="#1-2-2-内存存储与持久化" class="headerlink" title="1.2.2 内存存储与持久化"></a><strong>1.2.2 内存存储与持久化</strong></h3><p>Redis数据库中的所有数据都存储在内存中。由于内存的读写速度远快于硬盘，因此Redis在性能上对比其他基于硬盘存储的数据库有非常明显的优势，在一台普通的笔记本电脑上，Redis可以在一秒内读写超过十万个键值。<br>将数据存储在内存中也有问题，例如，程序退出后内存中的数据会丢失。不过 Redis提供了对持久化的支持，即将可以内存中的数据异步写入到硬盘中，同时不影响继续提供服务。</p>
<h3 id="1-2-3-功能丰富"><a href="#1-2-3-功能丰富" class="headerlink" title="1.2.3 功能丰富"></a><strong>1.2.3 功能丰富</strong></h3><p>Redis虽然是作为数据库开发的，但由于其提供了丰富的功能，越来越多的人将其用作缓存、队列系统等。Redis可谓是名副其实的多面手。<br>Redis可以为每个键设置生存时间（Time To Live，TTL），生存时间到期后键会自动被删除。这一功能配合出色的性能让Redis可以作为缓存系统来使用，而且由于Redis支持持久化和丰富的数据类型，使其成为了另一个非常流行的缓存系统Memcached的有力竞争者。<br>讨论 关于Redis和Memcached优劣的讨论一直是一个热门的话题。在性能上Redis是单线程模型，而Memcached支持多线程，所以在多核服务器上后者的性能更高一些。然而，前面已经介绍过，Redis的性能已经足够优异，在绝大部分场合下其性能都不会成为瓶颈。所以在使用时更应该关心的是二者在功能上的区别，如果需要用到高级的数据类型或是持久化等功能，Redis将会是Memcached很好的替代品。<br>作为缓存系统，Redis还可以限定数据占用的最大内存空间，在数据达到空间限制后可以按照一定的规则自动淘汰不需要的键。<br>除此之外，Redis的列表类型键可以用来实现队列，并且支持阻塞式读取，可以很容易地实现一个高性能的优先级队列。同时在更高层面上，Redis还支持“发布/订阅”的消息模式，可以基于此构建聊天室等系统。</p>
<h3 id="1-2-4-简单稳定"><a href="#1-2-4-简单稳定" class="headerlink" title="1.2.4 简单稳定"></a><strong>1.2.4 简单稳定</strong></h3><p>即使功能再丰富，如果使用起来太复杂也很难吸引人。Redis直观的存储结构使得通过程序与Redis交互十分简单。在Redis中使用命令来读写数据，命令语句之于Redis就相当于SQL语言之于关系数据库。例如在关系数据库中要获取posts表内id为1的记录的title字段的值可以使用如下SQL语句实现：</p>
<ol>
<li>SELECT title FROM posts WHERE id=1 LIMIT 1</li>
</ol>
<p>相对应的，在Redis中要读取键名为post:1的散列类型键的title字段的值，可以使用如下命令语句实现：</p>
<ol>
<li>HGET post:1 title</li>
</ol>
<p>其中HGET就是一个命令。Redis提供了一百多个命令，听起来很多，但是常用的却只有十几个，并且每个命令都很容易记忆。读完第3章你就会发现Redis的命令比SQL语言要简单很多。<br>Redis提供了几十种不同编程语言的客户端库，这些库都很好地封装了Redis的命令，使得在程序中与Redis进行交互变得更容易。有些库还提供了可以将编程语言中的数据类型直接以相应的形式存储到Redis中（如将数组直接以列表类型存入Redis）的简单方法，使用起来非常方便。<br>读者可以在<a href="http://redis.io/commands上查看到所有的redis命令和使用方法" target="_blank" rel="noopener">http://redis.io/commands上查看到所有的redis命令和使用方法</a><br>Redis使用C语言开发，代码量只有3万多行。这降低了用户通过修改Redis源代码来使之更适合自己项目需要的门槛。对于希望“榨干”数据库性能的开发者而言，这无疑是一个很大的吸引力。<br>Redis 是开源的，所以事实上Redis的开发者并不止Salvatore Sanfilippo和Pieter Noordhuis。截至目前，有将近100名开发者为Redis贡献了代码。良好的开发氛围和严谨的版本发布机制使得Redis的稳定版本非常可靠，如此多的公司在项目中使用了Redis也可以印证这一点。</p>
<h1 id="2-准备"><a href="#2-准备" class="headerlink" title="2 准备"></a>2 准备</h1><blockquote>
<p>“纸上得来终觉浅，绝知此事要躬行。”<br>——陆游《冬夜读书示子聿》</p>
</blockquote>
<p>学习Redis最好的办法就是动手尝试它。在介绍Redis最核心的内容之前，本章先来介绍一下如何安装和运行Redis，以及Redis的基础知识，使读者可以在之后的章节中一边学习一边实践。</p>
<h2 id="2-1-安装Redis"><a href="#2-1-安装Redis" class="headerlink" title="2.1 安装Redis"></a>2.1 安装Redis</h2><p>安装Redis是开始Redis学习之旅的第一步。在安装Redis前需要了解Redis的版本规则以选择最适合自己的版本，Redis约定次版本号（即第一个小数点后的数字）为偶数的版本是稳定版（如2.4版、2.6版），奇数版本是非稳定版（如2.5版、2.7版），推荐使用稳定版本进行开发和在生产环境使用。<br>Redis兼容大部分POSIX系统，包括Linux、OS X和BSD等，在这些系统中推荐直接下载Redis源代码编译安装以获得最新的稳定版本。Redis最新稳定版本的源代码可以从地址<a href="http://download.redis.io/redis-stable.tar.gz下载。" target="_blank" rel="noopener">http://download.redis.io/redis-stable.tar.gz下载。</a><br>下载安装包后解压即可使用make 命令完成编译，完整的命令如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">wget</span> <span class="string">http://download.redis.io/redis-stable.tar.gz</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attr">tar</span> <span class="string">xzf redis-stable.tar.gz</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attr">cd</span> <span class="string">redis-stable</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="attr">make</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="attr">make</span> <span class="string">install</span></span></pre></td></tr></table></figure>

<p>Redis没有其他外部依赖，安装过程很简单。编译后在Redis源代码目录的src文件夹中可以找到若干个可执行程序，最好在编译后直接执行<code>make install</code>命令来将这些可执行程序复制到/usr/local/bin目录中以便以后执行程序时可以不用输入完整的路径。<br>在实际运行Redis前推荐使用make test命令测试Redis是否编译正确，尤其是在编译一个不稳定版本的Redis时。<br><strong>提示</strong> 除了手工编译外，还可以使用操作系统中的软件包管理器来安装Redis，但目前大多数软件包管理器中的Redis的版本都较古老。考虑到Redis的每次升级都提供了对以往版本的问题修复和性能提升，使用最新版本的Redis往往可以提供更加稳定的体验。如果希望享受包管理器带来的便利，在安装前请确认您使用的软件包管理器中Redis的版本并了解该版本与最新版之间的差异。<a href="http://redis.io/topics/problems中列举了一些在以往版本中存在的已知问题。" target="_blank" rel="noopener">http://redis.io/topics/problems中列举了一些在以往版本中存在的已知问题。</a><br>安装完毕，常用工具会自动拷贝到/user/loca/bin目录下。做为服务器，我们常常还需要把redis设置成开机自启动，源码包中有个很好用的脚本<code>install_server.sh</code>，执行脚步根据提示输入即可。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">[root@iZ28csbxcf3Z utils]# ./install_server.sh </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Welcome <span class="keyword">to</span> the redis<span class="built_in"> service </span>installer</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">This<span class="built_in"> script </span>will help you easily <span class="builtin-name">set</span> up a running redis server</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Please select the redis<span class="built_in"> port </span><span class="keyword">for</span> this instance: [6379] </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">Selecting default: 6379</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">Please select the redis<span class="built_in"> config </span>file name [/etc/redis/6379.conf] </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">Selected<span class="built_in"> default </span>- /etc/redis/6379.conf</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">Please select the redis log file name [/var/log/redis_6379.log] </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">Selected<span class="built_in"> default </span>- /var/log/redis_6379.log</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">Please select the data directory <span class="keyword">for</span> this<span class="built_in"> instance </span>[/var/lib/redis/6379] </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">Selected<span class="built_in"> default </span>- /var/lib/redis/6379</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">Please select the redis executable path [/usr/local/bin/redis-server] </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">Selected config:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">Port           : 6379</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">Config file    : /etc/redis/6379.conf</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">Log file       : /var/log/redis_6379.log</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">Data dir       : /var/lib/redis/6379</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">Executable     : /usr/local/bin/redis-server</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">Cli Executable : /usr/local/bin/redis-cli</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">Is this ok? Then press ENTER <span class="keyword">to</span> go on <span class="keyword">or</span> Ctrl-C <span class="keyword">to</span> abort.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">Copied /tmp/6379.conf =&gt; /etc/init.d/redis_6379</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">Installing service<span class="built_in">..</span>.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">Successfully added <span class="keyword">to</span> chkconfig!</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">Successfully added <span class="keyword">to</span> runlevels 345!</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">Starting Redis server<span class="built_in">..</span>.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">Installation successful!</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">[root@iZ28csbxcf3Z utils]# which redis-server</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">/usr/local/bin/redis-server</span></pre></td></tr></table></figure>

<p>注意执行install_server.sh，需要先进入utils目录，不然脚本会报错，提示找不到相应文件。<code>安装完服务，redis自动启动了</code>。可以用ps命令查看到相关信息：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>iZ28csbxcf3Z utils]# ps -ef | grep redis</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">root     <span class="number">20237</span> <span class="number">20196</span>  <span class="number">0</span> <span class="number">22</span>:<span class="number">09</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> redis-cli</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">root     <span class="number">20628</span>     <span class="number">1</span>  <span class="number">0</span> <span class="number">22</span>:<span class="number">35</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> /usr/local/bin/redis-server *:<span class="number">6379</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">root     <span class="number">20703</span> <span class="number">20455</span>  <span class="number">0</span> <span class="number">22</span>:<span class="number">44</span> pts/<span class="number">1</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> grep --color=<span class="built_in">auto</span> redis</span></pre></td></tr></table></figure>

<p>参考文档：<br><a href="http://blog.csdn.net/love__coder/article/details/8271832" target="_blank" rel="noopener">http://blog.csdn.net/love__coder/article/details/8271832</a></p>
<h2 id="2-2-启动和停止Redis"><a href="#2-2-启动和停止Redis" class="headerlink" title="2.2 启动和停止Redis"></a>2.2 启动和停止Redis</h2><p>安装完Redis后的下一步就是启动它，本节将分别介绍在开发环境和生产环境中运行Redis的方法以及正确停止Redis的步骤。<br>在这之前首先需要了解Redis包含的可执行文件都有哪些，表2-1中列出了这些程序的名称以及对应的说明。如果在编译后执行了make install命令，这些程序会被复制到<code>/usr/local/bin</code>目录内，所以在命令行中直接输入程序名称即可执行。<br><img src="http://image.winrains.cn/2019/10/d3d73-1458269719795012616.png" alt="QQ截图20160318105439.png"><br>我们最常使用的两个程序是redis-server和redis-cli，其中redis-server是Redis的服务器，启动Redis即运行redis-server；而redis-cli是Redis自带的Redis命令行客户端，是学习Redis的重要工具，2.3节会详细介绍它。<br>由于上一节我们使用<code>install_server.sh</code>脚本安装为server之后，就redis就已经自动启动了。所以我们需要先要将其关闭。然后演示启动和关闭过程。</p>
<h3 id="2-2-1-停止Redis"><a href="#2-2-1-停止Redis" class="headerlink" title="2.2.1 停止Redis"></a><strong>2.2.1 停止Redis</strong></h3><p>考虑到Redis有可能正在将内存中的数据同步到硬盘中，强行终止Redis进程可能会导致数据丢失。正确停止Redis的方式应该是向Redis发送SHUTDOWN命令，方法为：<br>redis-cli SHUTDOWN<br>当Redis收到SHUTDOWN命令后，会先断开所有客户端连接，然后根据配置执行持久化，最后完成退出。<br>Redis可以妥善处理SIGTERM信号，所以使用“kill Redis进程的PID”也可以正常结束Redis，效果与发送SHUTDOWN命令一样。<br>启动Redis有直接启动和通过初始化脚本启动两种方式，分别适用于开发环境和生产环境。</p>
<h3 id="2-2-2直接启动"><a href="#2-2-2直接启动" class="headerlink" title="2.2.2直接启动"></a><strong>2.2.2直接启动</strong></h3><p>直接运行redis-server即可启动Redis，十分简单：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis-server</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">[5101]14Dec20:58:59.944#Warning:no<span class="built_in"> config </span>file specified,using the default</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">config.<span class="keyword">In</span> order <span class="keyword">to</span> specify a<span class="built_in"> config </span>file use redis-server/path/<span class="keyword">to</span>/redis.conf</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">[5101]14Dec20:58:59.948*Max number of open files <span class="builtin-name">set</span> <span class="keyword">to</span> 10032</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">..</span>.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">[5101]14Dec20:58:59.949#Server started,Redis version 2.6.9</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">[5101]14Dec20:58:59.949*The<span class="built_in"> server </span>is now ready <span class="keyword">to</span> accept connections on<span class="built_in"> port </span>6379</span></pre></td></tr></table></figure>

<p>Redis服务器默认会使用6379端口 ，通过<code>--port</code>参数可以自定义端口号：<br><strong>注释：</strong>6379是手机键盘上MERZ对应的数字，MERZ 是一名意大利歌女的名字。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt;redis-<span class="keyword">server</span> <span class="comment">--port 6380</span></span></pre></td></tr></table></figure>

<h3 id="2-2-3-作为服务启动"><a href="#2-2-3-作为服务启动" class="headerlink" title="2.2.3 作为服务启动"></a><strong>2.2.3 作为服务启动</strong></h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/bin/</span>redis-server <span class="meta-keyword">/etc/</span>redis/redis.conf   <span class="meta">#指定配置文件启动</span></span></pre></td></tr></table></figure>

<h2 id="2-3-Redis命令行客户端"><a href="#2-3-Redis命令行客户端" class="headerlink" title="2.3 Redis命令行客户端"></a>2.3 Redis命令行客户端</h2><p>还记得我们刚才编译出来的<code>redis-cli</code>程序吗？redis-cli（Redis Command Line Interface）是Redis自带的基于命令行的Redis客户端，也是我们学习和测试Redis的重要工具，本书后面会使用它来讲解Redis各种命令的用法。<br>本节将会介绍如何通过redis-cli向Redis发送命令，并且对Redis命令返回值的不同类型进行简单介绍。</p>
<h3 id="2-3-1-发送命令"><a href="#2-3-1-发送命令" class="headerlink" title="2.3.1 发送命令"></a><strong>2.3.1 发送命令</strong></h3><p>通过 redis-cli向Redis发送命令有两种方式，第一种方式是将命令作为redis-cli的参数执行，比如在2.2.2节中用过的redis-cli SHUTDOWN。redis-cli执行时会自动按照默认配置（服务器地址为127.0.0.1，端口号为6379）连接Redis，通过<code>-h</code>和<code>-p</code>参数可以自定义地址和端口号：**<br>**</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6379</span></span></pre></td></tr></table></figure>

<p>Redis提供了PING命令来测试客户端与Redis的连接是否正常，如果连接正常会收到回复PONG。如：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis-cli PING</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">PONG</span></pre></td></tr></table></figure>

<p>第二种方式是不附带参数运行redis-cli，这样会进入交互模式，可以自由输入命令，例如：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis-cli</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; PING</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">PONG</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; ECHO hi</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="string">"hi"</span></span></pre></td></tr></table></figure>

<p>这种方式在要输入多条命令时比较方便，也是本书中主要采用的方式。为了简便起见，后文中我们将用redis&gt;表示redis 127.0.0.1:6379&gt;。</p>
<h3 id="2-3-2-命令返回值"><a href="#2-3-2-命令返回值" class="headerlink" title="2.3.2 命令返回值"></a><strong>2.3.2 命令返回值</strong></h3><p>在大多数情况下，执行一条命令后我们往往会关心命令的返回值，如1.2.4节中的<code>HGET</code>命令的返回值就是我们需要的指定键的title字段的值。命令的返回值有5种类型，对于每种类型redis-cli的展现结果都不同，下面分别说明。**<br>**</p>
<h4 id="1．状态回复"><a href="#1．状态回复" class="headerlink" title="1．状态回复"></a><strong>1．状态回复</strong></h4><p>状态回复（status reply）是最简单的一种回复，比如向Redis发送SET命令设置某个键的值时，Redis会回复状态OK表示设置成功。另外之前演示的对<code>PING</code>命令的回复<code>PONG</code>也是状态回复。状态回复直接显示状态信息，例如：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis&gt;<span class="built_in">PING</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">PONG</span></pre></td></tr></table></figure>

<h4 id="2．错误回复"><a href="#2．错误回复" class="headerlink" title="2．错误回复"></a><strong>2．错误回复</strong></h4><p>当出现命令不存在或命令格式有错误等情况时Redis会返回错误回复（error reply）。错误回复以(error)开头，并在后面跟上错误信息。如执行一个不存在的命令：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis&gt;ERRORCOMMEND</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">(error) ERR unknown <span class="keyword">command</span> <span class="string">'ERRORCOMMEND'</span></span></pre></td></tr></table></figure>

<h4 id="3．整数回复"><a href="#3．整数回复" class="headerlink" title="3．整数回复"></a><strong>3．整数回复</strong></h4><p>Redis虽然没有整数类型，但是却提供了一些用于整数操作的命令，如递增键值的<code>INCR</code>命令会以整数形式返回递增后的键值。除此之外，一些其他命令也会返回整数，如可以获取当前数据库中键的数量的<code>DBSIZE</code>命令等。整数回复（integer reply）以(integer)开头，并在后面跟上整数数据：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis&gt;INCR foo</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span></pre></td></tr></table></figure>

<h4 id="4．字符串回复"><a href="#4．字符串回复" class="headerlink" title="4．字符串回复"></a><strong>4．字符串回复</strong></h4><p>字符串回复（bulk reply）是最常见的一种回复类型，当请求一个字符串类型键的键值或一个其他类型键中的某个元素时就会得到一个字符串回复。字符串回复以双引号包裹：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis&gt;<span class="builtin-name">GET</span> foo</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="string">"1"</span></span></pre></td></tr></table></figure>

<p>特殊情况是当请求的键值不存在时会得到一个空结果，显示为(<code>nil</code>)。如：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis&gt;<span class="builtin-name">GET</span> noexists</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">(<span class="literal">nil</span>)=</span></pre></td></tr></table></figure>

<h4 id="5．多行字符串回复"><a href="#5．多行字符串回复" class="headerlink" title="5．多行字符串回复"></a><strong>5．多行字符串回复</strong></h4><p>多行字符串回复（multi-bulk reply）同样很常见，如当请求一个非字符串类型键的元素列表时就会收到多行字符串回复。多行字符串回复中的每行字符串都以一个序号开头，如：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis&gt; KEYS *</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="string">"bar"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>) <span class="string">"foo"</span></span></pre></td></tr></table></figure>

<p><strong>提示</strong> <code>KEYS</code>命令的作用是获取数据库中符合指定规则的键名，由于读者的Redis中还没有存储数据，所以得到的返回值应该是（empty list or set）。3.1节会具体介绍KEYS命令，此处读者只需了解多行字符串回复的格式即可。</p>
<h2 id="2-4-配置"><a href="#2-4-配置" class="headerlink" title="2.4 配置"></a>2.4 配置</h2><h3 id="一、通过配置文件设置配置项参数"><a href="#一、通过配置文件设置配置项参数" class="headerlink" title="一、通过配置文件设置配置项参数"></a><strong>一、通过配置文件设置配置项参数</strong></h3><p>前面我们通过redis-server的启动参数port设置了Redis的端口号，除此之外Redis还支持其他配置选项，如是否开启持久化、日志级别等。由于可以配置的选项较多，通过启动参数设置这些选项并不方便，所以Redis支持通过配置文件来设置这些选项。启用配置文件的方法是在启动时将配置文件的路径作为启动参数传递给redis-server，如：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis-<span class="keyword">server</span> /<span class="type">path</span>/<span class="keyword">to</span>/redis.conf</span></pre></td></tr></table></figure>

<p>通过启动参数传递同名的配置选项会覆盖配置文件中相应的参数，就像这样：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis-<span class="keyword">server</span> /<span class="type">path</span>/<span class="keyword">to</span>/redis.conf <span class="comment">--loglevel warning</span></span></pre></td></tr></table></figure>

<p>Redis提供了一个配置文件的模板<code>redis.conf</code>，位于源代码目录的根目录中。如果你一步一步按照操作来进行的话，目前我们使用的是：/etc/redis/6379.conf。<br><strong>参数说明</strong><br>redis.conf 配置项说明如下：<br>\1. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程<br>  daemonize no<br>\2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定<br>  pidfile /var/run/redis.pid<br>\3. 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字<br>  port 6379<br>\4. 绑定的主机地址<br>  bind 127.0.0.1<br>5.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能<br>  timeout 300<br>\6. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose<br>  loglevel verbose<br>\7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null<br>  logfile stdout<br>\8. 设置数据库的数量，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id<br>  databases 16<br>\9. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合<br>  save <seconds> <changes><br>Redis默认配置文件中提供了三个条件：<br>save 900 1<br>save 300 10<br>save 60 10000<br>分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。<br>\10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大<br>  rdbcompression yes<br>\11. 指定本地数据库文件名，默认值为dump.rdb<br>  dbfilename dump.rdb<br>\12. 指定本地数据库存放目录<br>  dir ./<br>\13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步<br>  slaveof <masterip> <masterport><br>\14. 当master服务设置了密码保护时，slav服务连接master的密码<br>  masterauth <master-password><br>\15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认关闭<br>  requirepass foobared<br>\16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息<br>  maxclients 128<br>\17. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区<br>  maxmemory <bytes><br>\18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no<br>  appendonly no<br>\19. 指定更新日志文件名，默认为appendonly.aof<br>   appendfilename appendonly.aof<br>\20. 指定更新日志条件，共有3个可选值：<br>no：表示等操作系统进行数据缓存同步到磁盘（快）<br>always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）<br>everysec：表示每秒同步一次（折衷，默认值）<br>appendfsync everysec<br>\21. 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）<br>   vm-enabled no<br>\22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享<br>   vm-swap-file /tmp/redis.swap<br>\23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0<br>   vm-max-memory 0<br>\24. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值<br>   vm-page-size 32<br>\25. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。<br>   vm-pages 134217728<br>\26. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4<br>   vm-max-threads 4<br>\27. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启<br>  glueoutputbuf yes<br>\28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法<br>  hash-max-zipmap-entries 64<br>  hash-max-zipmap-value 512<br>\29. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）<br>  activerehashing yes<br>\30. 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件<br>  include /path/to/local.conf</p>
<h3 id="二、通过CONFIG命令动态设置-获取参数"><a href="#二、通过CONFIG命令动态设置-获取参数" class="headerlink" title="二、通过CONFIG命令动态设置/获取参数"></a><strong>二、通过CONFIG命令动态设置/获取参数</strong></h3><p>除此之外还可以在Redis运行时通过<code>CONFIG SET</code> 命令在不重新启动Redis的情况下动态修改部分Redis配置。而通过<code>CONFIG GET</code>命令则是获取配置项的值。</p>
<h4 id="查看配置项的值"><a href="#查看配置项的值" class="headerlink" title="查看配置项的值"></a><strong>查看配置项的值</strong></h4><p><strong>语法：</strong></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">CONFIG <span class="builtin-name">GET</span> CONFIG_SETTING_NAME</span></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;<span class="built_in"> CONFIG </span><span class="builtin-name">GET</span> loglevel</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">1) <span class="string">"loglevel"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">2) <span class="string">"notice"</span></span></pre></td></tr></table></figure>

<p>使用<code>CONFIG GET *</code>可以获取所有的配置项</p>
<h4 id="修改配置项的值"><a href="#修改配置项的值" class="headerlink" title="修改配置项的值"></a><strong>修改配置项的值</strong></h4><p><strong>语法：</strong></p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> CONFIG_SETTING_NAME <span class="comment">NEW_CONFIG_VALUE</span></span></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis&gt;CONFIG <span class="builtin-name">SET</span> loglevel warning</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">OK</span></pre></td></tr></table></figure>

<p>并不是所有的配置都可以使用CONFIG SET命令修改，附录B列出了哪些配置能够使用该命令修改。同样在运行的时候也可以使用CONFIG GET命令获得Redis当前的配置情况，例如：</p>
<ol>
<li>redis&gt;CONFIG GET loglevel</li>
<li>1) “loglevel”</li>
<li>2) “warning”</li>
</ol>
<p>其中第一行字符串回复表示的是选项名，第二行即是选项值。<br>参考文档：<br><a href="http://www.runoob.com/redis/redis-conf.html" target="_blank" rel="noopener">http://www.runoob.com/redis/redis-conf.html</a></p>
<h2 id="2-5-多数据库"><a href="#2-5-多数据库" class="headerlink" title="2.5 多数据库"></a>2.5 多数据库</h2><p>第1章介绍过Redis是一个字典结构的存储服务器，而实际上一个Redis实例提供了多个用来存储数据的字典，客户端可以指定将数据存储在哪个字典中。这与我们熟知的在一个关系数据库实例中可以创建多个数据库类似，所以可以将其中的每个字典都理解成一个独立的数据库。<br>每个数据库对外都是以一个从0开始的递增数字命名，Redis默认支持16个数据库，可以通过配置参数databases来修改这一数字。客户端与Redis建立连接后会自动选择0号数据库，不过可以随时使用SELECT命令更换数据库，如要选择1号数据库：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis&gt;SELECT 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">OK</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">redis [1]&gt;<span class="builtin-name">GET</span> foo</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">(<span class="literal">nil</span>)</span></pre></td></tr></table></figure>

<p>然而这些以数字命名的数据库又与我们理解的数据库有所区别。首先Redis不支持自定义数据库的名字，每个数据库都以编号命名，开发者必须自己记录哪些数据库存储了哪些数据。另外Redis也不支持为每个数据库设置不同的访问密码，所以一个客户端要么可以访问全部数据库，要么连一个数据库也没有权限访问。最重要的一点是多个数据库之间并不是完全隔离，比如<code>FLUSHALL</code>命令可以清空一个Redis实例中所有数据库中的数据。综上所述，这些数据库更像是一种命名空间，而不适宜存储不同应用程序的数据。比如可以使用0号数据库存储某个应用生产环境中的数据，使用1号数据库存储测试环境中的数据，但不适宜使用0号数据库存储A应用的数据而使用1号数据库存储B应用的数据，不同的应用应该使用不同的Redis实例存储数据。由于Redis非常轻量级，一个空Redis实例占用的内存只有1MB左右，所以不用担心多个Redis实例会额外占用很多内存。</p>
<blockquote>
<p>作者：田守芝</p>
<p>来源：<a href="http://www.tianshouzhi.com/api/tutorials/redis/160" target="_blank" rel="noopener">http://www.tianshouzhi.com/api/tutorials/redis/160</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%AF%A6%E8%A7%A3/" rel="prev" title="数据库中间件详解">
      <i class="fa fa-chevron-left"></i> 数据库中间件详解
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/29/Redis%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%882%EF%BC%89%EF%BC%9A%E5%85%A5%E9%97%A8/" rel="next" title="Redis使用教程（2）：入门">
      Redis使用教程（2）：入门 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Redis简介"><span class="nav-number">1.</span> <span class="nav-text">1 Redis简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-历史与发展"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 历史与发展**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-特性"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-存储结构"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1 存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-内存存储与持久化"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2 内存存储与持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-功能丰富"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.2.3 功能丰富</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-4-简单稳定"><span class="nav-number">1.2.4.</span> <span class="nav-text">1.2.4 简单稳定</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-准备"><span class="nav-number">2.</span> <span class="nav-text">2 准备</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-安装Redis"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 安装Redis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-启动和停止Redis"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 启动和停止Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-停止Redis"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1 停止Redis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2直接启动"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2直接启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-作为服务启动"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.2.3 作为服务启动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-Redis命令行客户端"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 Redis命令行客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-发送命令"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1 发送命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-命令返回值"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.3.2 命令返回值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1．状态回复"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">1．状态回复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2．错误回复"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">2．错误回复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3．整数回复"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">3．整数回复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4．字符串回复"><span class="nav-number">2.3.2.4.</span> <span class="nav-text">4．字符串回复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5．多行字符串回复"><span class="nav-number">2.3.2.5.</span> <span class="nav-text">5．多行字符串回复</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-配置"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、通过配置文件设置配置项参数"><span class="nav-number">2.4.1.</span> <span class="nav-text">一、通过配置文件设置配置项参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、通过CONFIG命令动态设置-获取参数"><span class="nav-number">2.4.2.</span> <span class="nav-text">二、通过CONFIG命令动态设置/获取参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#查看配置项的值"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">查看配置项的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修改配置项的值"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">修改配置项的值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-多数据库"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 多数据库</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">winrains</p>
  <div class="site-description" itemprop="description">淡泊明志</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">489</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">83</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">108</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">winrains</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
