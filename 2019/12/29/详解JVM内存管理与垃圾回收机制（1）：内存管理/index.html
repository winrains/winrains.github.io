<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://congsheng.wang').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="Java应用程序是运行在JVM上的，得益于JVM的内存管理和垃圾收集机制，开发人员的效率得到了显著提升，也不容易出现内存溢出和泄漏问题。但正是因为开发人员把内存的控制权交给了JVM，一旦出现内存方面的问题，如果不了解JVM的工作原理，将很难排查错误。本文将从理论角度介绍虚拟机的内存管理和垃圾回收机制，算是入门级的文章，希望对大家的日常开发有所助益。">
<meta property="og:type" content="article">
<meta property="og:title" content="详解JVM内存管理与垃圾回收机制（1）：内存管理">
<meta property="og:url" content="http:&#x2F;&#x2F;congsheng.wang&#x2F;2019&#x2F;12&#x2F;29&#x2F;%E8%AF%A6%E8%A7%A3JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%881%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86&#x2F;index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="Java应用程序是运行在JVM上的，得益于JVM的内存管理和垃圾收集机制，开发人员的效率得到了显著提升，也不容易出现内存溢出和泄漏问题。但正是因为开发人员把内存的控制权交给了JVM，一旦出现内存方面的问题，如果不了解JVM的工作原理，将很难排查错误。本文将从理论角度介绍虚拟机的内存管理和垃圾回收机制，算是入门级的文章，希望对大家的日常开发有所助益。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191020120347-e8890.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191020120349-c4326.png">
<meta property="og:updated_time" content="2019-12-29T14:34:16.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191020120347-e8890.png">

<link rel="canonical" href="http://congsheng.wang/2019/12/29/%E8%AF%A6%E8%A7%A3JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%881%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>详解JVM内存管理与垃圾回收机制（1）：内存管理 | 个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">congsheng的博客</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">156</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">94</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">984</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://congsheng.wang/2019/12/29/%E8%AF%A6%E8%A7%A3JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%881%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="congsheng.wang">
      <meta itemprop="description" content="trouble is a friend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          详解JVM内存管理与垃圾回收机制（1）：内存管理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-29 22:34:16" itemprop="dateCreated datePublished" datetime="2019-12-29T22:34:16+08:00">2019-12-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" itemprop="url" rel="index">
                    <span itemprop="name">垃圾回收</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Java应用程序是运行在JVM上的，得益于JVM的内存管理和垃圾收集机制，开发人员的效率得到了显著提升，也不容易出现内存溢出和泄漏问题。但正是因为开发人员把内存的控制权交给了JVM，一旦出现内存方面的问题，如果不了解JVM的工作原理，将很难排查错误。本文将从理论角度介绍虚拟机的内存管理和垃圾回收机制，算是入门级的文章，希望对大家的日常开发有所助益。</p>
<a id="more"></a>

<h2 id="一、内存管理"><a href="#一、内存管理" class="headerlink" title="一、内存管理"></a>一、内存管理</h2><p>也许大家都有过这样的经历，在启动时通过<code>-Xmx</code>或者<code>-XX:MaxPermSize</code>这样的参数来显式的设置应用的堆(Heap)和永久代(Permgen)的内存大小，但为什么不直接设置JVM所占内存的大小，而要分别去设置不同的区域？JVM所管理的内存被分成多少区域？每个区域有什么作用？如何来管理这些区域？</p>
<h3 id="1-1-运行时数据区"><a href="#1-1-运行时数据区" class="headerlink" title="1.1 运行时数据区"></a>1.1 运行时数据区</h3><p>JVM在执行Java程序时会把其所管理的内存划分成多个不同的数据区域，每个区域的创建时间、销毁时间以及用途都各不相同。比如有的内存区域是所有线程共享的，而有的内存区域是线程隔离的。线程隔离的区域就会随着线程的启动和结束而创建和销毁。JVM所管理的内存将会包含以下几个运行时数据区域，如下图的上半部分所示。</p>
<p><img src="http://image.winrains.cn/2019/10/20191020120347-e8890.png" alt="img"></p>
<p>图1：JVM运行时数据区</p>
<h4 id="Method-Area-方法区"><a href="#Method-Area-方法区" class="headerlink" title="Method Area (方法区)"></a>Method Area (方法区)</h4><p>方法区是所有线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、JIT编译后的代码等数据。在Java虚拟机规范中，方法区属于堆的一个逻辑部分，但很多情况下，都把方法区与堆区分开来说。大家平时开发中通过反射获取到的类名、方法名、字段名称、访问修饰符等信息都是从这块区域获取的。<br>对于HotSpot虚拟机，方法区对应为<code>永久代(Permanent Generation)</code>，但本质上，两者并不等价，仅仅是因为HotSpot虚拟机的设计团队是用永久代来实现方法区而已，对于其他的虚拟机(JRockit、J9)来说，是不存在永久代这一概念的。<br>但现在看来，使用永久代来实现方法区并不是一个好注意，由于方法区会存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等，在某些场景下非常容易出现永久代内存溢出。如Spring、Hibernate等框架在对类进行增强时，都会使用到CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存。在JSP页面较多的情况下，也会出现同样的问题。可以通过如下代码来测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * VM Args：-XX:PermSize=10M -XX:MaxPermSize=10M(JDK6.0)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * VM Args: -XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=10M(JDK8.0)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGlibProxy</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            enhancer.setSuperclass(ProxyObject<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] os, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                    System.out.println(<span class="string">"I am proxy"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">return</span> proxy.invokeSuper(o,os);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            ProxyObject proxy = (ProxyObject) enhancer.create();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            proxy.greet();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyObject</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">greet</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="string">"Thanks for you"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在JDK1.8中运行一小会儿出现内存溢出错误：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Exception</span> <span class="selector-tag">in</span> <span class="selector-tag">thread</span> "<span class="selector-tag">main</span>" <span class="selector-tag">I</span> <span class="selector-tag">am</span> <span class="selector-tag">proxy</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.OutOfMemoryError</span>: <span class="selector-tag">Metaspace</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="selector-tag">at</span> <span class="selector-tag">org</span><span class="selector-class">.mockito</span><span class="selector-class">.cglib</span><span class="selector-class">.core</span><span class="selector-class">.AbstractClassGenerator</span><span class="selector-class">.create</span>(<span class="selector-tag">AbstractClassGenerator</span><span class="selector-class">.java</span><span class="selector-pseudo">:238)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="selector-tag">at</span> <span class="selector-tag">org</span><span class="selector-class">.mockito</span><span class="selector-class">.cglib</span><span class="selector-class">.proxy</span><span class="selector-class">.Enhancer</span><span class="selector-class">.createHelper</span>(<span class="selector-tag">Enhancer</span><span class="selector-class">.java</span><span class="selector-pseudo">:378)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="selector-tag">at</span> <span class="selector-tag">org</span><span class="selector-class">.mockito</span><span class="selector-class">.cglib</span><span class="selector-class">.proxy</span><span class="selector-class">.Enhancer</span><span class="selector-class">.create</span>(<span class="selector-tag">Enhancer</span><span class="selector-class">.java</span><span class="selector-pseudo">:286)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="selector-tag">at</span> <span class="selector-tag">com</span><span class="selector-class">.lwork</span><span class="selector-class">.mdo</span><span class="selector-class">.CGlibProxy</span><span class="selector-class">.main</span>(<span class="selector-tag">CGlibProxy</span><span class="selector-class">.java</span><span class="selector-pseudo">:23)</span></span></pre></td></tr></table></figure>

<p>在JDK1.8下并没有出现我们期望的永久代内存溢出错误，而是Metaspace内存溢出错误。这是因为Java团队从JDK1.7开始就逐渐移除了永久代，到JDK1.8时，永久代已经被Metaspace取代，因此在JDK1.8并没有出现我们期望的永久代内存溢出错误。在JDK1.8中，JVM参数<code>-XX:PermSize</code>和<code>-XX:MaxPermSize</code>已经失效，取而代之的是<code>-XX:MetaspaceSize</code>和<code>XX:MaxMetaspaceSize</code>。注意：Metaspace已经不再使用堆空间，转而使用Native Memory。关于Native Memory，下文会详细说明。<br>还有一点需要说明的是，在JDK1.6中，方法区虽然被称为永久代，但并不意味着这些对象真的能够永久存在了，JVM的内存回收机制，仍然会对这一块区域进行扫描，即使回收这部分内存的条件相当苛刻。</p>
<h4 id="Runtime-Constant-Pool-运行时常量池"><a href="#Runtime-Constant-Pool-运行时常量池" class="headerlink" title="Runtime Constant Pool (运行时常量池)"></a>Runtime Constant Pool (运行时常量池)</h4><p>回过头来看下图1的下半部分，方法区主要包含：</p>
<ol>
<li>运行时常量池(Runtime Constant Pool)</li>
<li>类信息(Class &amp; Field &amp; Method data)</li>
<li>编译器编译后的代码(Code)等等<br>后面两项都比较好理解，但运行时常量池有何作用，其意义何在？抛开运行时3个字，首先了解下何为常量池。</li>
</ol>
<p>Java源文件经编译后得到存储字节码的Class文件，Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中。也就是说，哪个字节代表什么含义，长度多少，先后顺序如何都是被严格限定的，是不允许改变的。比如：开头的4个字节存放在魔数，用于确定这个文件是否能够被JVM接受，接下来的4个字节用于存放版本号，再接着存放的就是常量池，常量池的长度是不固定的，所以，在常量池的入口存放着常量池容量的计数值。<br>常量池主要用于存放两大类常量：字面量和符号引用量，字面量相当于Java语言层面常量的概念，比如：字符串常量、声明为final的常量等等。符号引用是用一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。理解不了？举个例子，有如下代码：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">M</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> mstring = <span class="string">"chen"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用javap工具输出M.class文件字节码的部分内容如下：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">⇒ javap <span class="params">-verbose</span> M</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="params">...</span><span class="params">...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Constant pool:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">   #1 = Methodref          #5.#20         <span class="comment">// java/lang/Object."&lt;init&gt;":()V</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">   #2 = <span class="built_in">String</span>             #21            <span class="comment">// chen</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">   #3 = Fieldref           #4.#22         <span class="comment">// com/lwork/mdo/M.mstring:Ljava/lang/String;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">   #4 = Class              #23            <span class="comment">// com/lwork/mdo/M</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">   #5 = Class              #24            <span class="comment">// java/lang/Object</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">   #6 = Utf8               m</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">   #7 = Utf8               I</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">   #8 = Utf8               mstring</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">   #9 = Utf8               Ljava/lang/<span class="built_in">String</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  #10 = Utf8               &lt;init&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  #11 = Utf8               ()V</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  #12 = Utf8               Code</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  #13 = Utf8               LineNumberTable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  #14 = Utf8               LocalVariableTable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  #15 = Utf8               this</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  #16 = Utf8               Lcom/lwork/mdo/M;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法名称</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">  #17 = Utf8               f</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">  #18 = Utf8               SourceFile</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类名称</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">  #19 = Utf8               M.java</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">  #20 = NameAndType        #10:#11        <span class="comment">// "&lt;init&gt;":()V</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">  #21 = Utf8               chen</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">  #22 = NameAndType        #8:#9          <span class="comment">// mstring:Ljava/lang/String;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的完整路径，注意class文件中是用"/"来代替"."</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">  #23 = Utf8               com/lwork/mdo/M</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  #24 = Utf8               java/lang/Object</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="params">...</span><span class="params">...</span></span></pre></td></tr></table></figure>

<p>这里只保留了常量池的部分，从中可以看到M.class文件的常量池总共24项，其中包含类的完整名称、字段名称和描述符、方法名称和描述符等等。当然其中还包含<code>I</code>、<code>V</code>、``、<code>LineNumberTable</code>、<code>LocalVariableTable</code>等代码中没有出现过的常量，其实这些常量是用来描述如下信息：方法的返回值是什么？有多少个参数？每个参数的类型是什么…… 这个示例非常直观的向大家展示了常量池中存储的内容。</p>
<blockquote>
<p>关于“符号引用”的详细讲解可以参考：<a href="https://www.zhihu.com/question/30300585/answer/51335493" target="_blank" rel="noopener">JVM里的符号引用如何存储？</a></p>
</blockquote>
<p>接下来就比较好理解运行时常量池了。我们都知道：Class文件中存储的各种信息，最终都需要加载到虚拟机中之后才能运行和使用。运行时常量池就可以理解为常量池被加载到内存之后的版本，但并非只有Class文件中常量池的内容才能进入方法区的运行时常量池，运行期间也可能产生新的常量，它们也可以放入运行时常量池中。</p>
<h4 id="Heap-Space-Java堆"><a href="#Heap-Space-Java堆" class="headerlink" title="Heap Space (Java堆)"></a>Heap Space (Java堆)</h4><p>Java堆是JVM所管理的最大一块内存，所有线程共享这块内存区域，几乎所有的对象实例都在这里分配内存，因此，它也是垃圾收集器管理的主要区域。从内存回收的角度来看，由于现在的收集器基本都采用分代收集算法，所以Java堆又可以细分成：新生代和老年代，新生代里面有分为：Eden空间、From Survivor空间、To Survivor空间，如图1所示。有一点需要注意：Java堆空间只是在逻辑上是连续的，在物理上并不一定是连续的内存空间。<br>默认情况下，新生代中Eden空间与Survivor空间的比例是8:1，注意不要被示意图误导，可以使用参数<code>-XX:SurvivorRatio</code>对其进行配置。大多数情况下，新生对象在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，则触发一次Minor GC，将对象Copy到Survivor区，如果Survivor区没有足够的空间来容纳，则会通过分配担保机制提前转移到老年代去。</p>
<blockquote>
<p>何为分配担保机制？在发送Minor GC前，JVM会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果是，那么可以确保Minor GC是安全的，如果不是，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果小于，直接进行Full GC，如果大于，将尝试着进行一次Minor GC，Minor GC失败才会触发Full GC。注：不同版本的JDK，流程略有不同</p>
</blockquote>
<p>Survivor区作为Eden区和老年代的缓冲区域，常规情况下，在Survivor区的对象经过若干次垃圾回收仍然存活的话，才会被转移到老年代。JVM通过这种方式，将大部分命短的对象放在一起，将少数命长的对象放在一起，分别采取不同的回收策略。关于JVM内存分配更直观的介绍，请阅读参考资料3。</p>
<h4 id="VM-Stack-虚拟机栈-amp-Native-Method-Stack-本地方法栈"><a href="#VM-Stack-虚拟机栈-amp-Native-Method-Stack-本地方法栈" class="headerlink" title="VM Stack (虚拟机栈) &amp; Native Method Stack (本地方法栈)"></a>VM Stack (虚拟机栈) &amp; Native Method Stack (本地方法栈)</h4><p>虚拟机栈与本地方法栈都属于线程私有，它们的生命周期与线程相同。虚拟机栈用于描述Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态连接、方法出口等信息。<br>其中局部变量表用于存储方法参数和方法内部定义的局部变量，它只在当前函数调用中有效，当函数调用结束，随着函数栈帧的销毁，局部变量表也随之消失；操作数栈是一个后入先出栈，用于存放方法运行过程中的各种中间变量和字节码指令 (在学习栈的时候，有一个经典的例子就是用栈来实现4则运算，其实方法执行过程中操作数栈的变化过程，与4则预算中栈中数字与符号的变化类似)；动态连接其实是指一个过程，即在程序运行过程中将符号引用解析为直接引用的过程。</p>
<blockquote>
<p>如何理解动态连接？我们知道Class文件的常量池中存有大量的符号引用，在加载过程中会被原样的拷贝到内存里先放着，到真正使用的时候就会被解析为直接引用 (直接引用包含：直接指向目标的指针、相对偏移量、能间接定位到目标的句柄等)。有些符号引用会在类的加载阶段或者第一次使用的时候转化为直接引用，这种转化称为静态解析，而有的将在运行期间转化为直接引用，这部分称为动态连接。<br>全部静态解析不是更好，为何会存在动态连接？Java多态的实现会导致一个引用变量到底指向哪个类的实例对象，或者说该引用变量发出的方法调用到底是调用哪个类中实现方法都需要在运行期间才能确定。因此有些符号引用在类加载阶段是不知道它对应的直接引用的</p>
</blockquote>
<p>每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程，下面通过一个非常简单的图例来描述这一过程，有如下的代码片段：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> sayHello(String <span class="type">name</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("hello " + <span class="type">name</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    greet(<span class="type">name</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    bye();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其调用过程中虚拟机栈的大致示意图如下图所示：</p>
<p><img src="http://image.winrains.cn/2019/10/20191020120349-c4326.png" alt="img"></p>
<p>图二：调用栈</p>
<p>调用sayHello方法时，在栈中分配有一块内存用来保存该方法的局部变量等信息，①当函数执行到greet()方法时，栈中同样有一块内存用来保存greet方法的相关信息，当然第二个内存块位于第一个内存块上面，②接着从greet方法返回，③现在栈顶的内存块就是sayHello方法的，这表示你已经返回到sayHello方法，④接着继续调用bye方法，在栈顶添加了bye方法的内存块，⑤接着再从bye方法返回到sayHello方法中，由于没有别的事了，现在就从sayHello方法返回。<br>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法 (也就是字节码) 服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p>
<h4 id="Program-Counter-Register-程序计数器"><a href="#Program-Counter-Register-程序计数器" class="headerlink" title="Program Counter Register (程序计数器)"></a>Program Counter Register (程序计数器)</h4><p>程序计数器(Program Counter Register)，很多地方也被称为PC寄存器，但寄存器是CPU的一个部件，用于存储CPU内部重要的数据资源，比如在汇编语言中，它保存的是程序当前执行的指令的地址（也可以说保存下一条指令的所在存储单元的地址），当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。<br>类似的，JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。<br>Java虚拟机可以支持多条线程同时执行，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，JVM中的程序计数器是每个线程私有的。</p>
<h3 id="1-2-堆外内存"><a href="#1-2-堆外内存" class="headerlink" title="1.2 堆外内存"></a>1.2 堆外内存</h3><p>堆外内存又被称为直接内存(Direct Memory)，它并不是虚拟机运行时数据区的一部分，Java虚拟机规范中也没有定义这部分内存区域，使用时由Java程序直接向系统申请，访问直接内存的速度要优于Java堆，因此，读写频繁的场景下使用直接内存，性能会有提升，比如Java NIO库，就是使用Native函数直接分配堆外内存，然后通过一个存储在Java堆中的DirectBytedBuffer对象作为这块内存的引用进行操作。<br>由于直接内存在Java堆外，其大小不会直接受限于Xmx指定的堆大小，但它肯定会受到本机总内存大小以及处理器寻址空间的限制，因此我们在配置JVM参数时，特别是有大量网络通讯场景下，要特别注意，防止各个内存区域的总内存大于物理内存限制 (包括物理的和OS的限制)。</p>
<h3 id="1-3-小结"><a href="#1-3-小结" class="headerlink" title="1.3 小结"></a>1.3 小结</h3><p>花了很大篇幅来介绍Java虚拟机的内存结构，其中在讲解Java堆时，还简单的介绍了JVM的内存分配机制；在介绍虚拟机栈的同时，也对方法调用过程中栈的数据变化作了形象的说明。当然这样的篇幅肯定不足以完全理清整个内存结构以及其内存分配机制，你尽可以把它当做简单的入门，带你更好的学习。接下来会以此为背景介绍一些常用的JVM参数。</p>
<h2 id="二、常用JVM参数"><a href="#二、常用JVM参数" class="headerlink" title="二、常用JVM参数"></a>二、常用JVM参数</h2><h3 id="2-1-关于JVM参数必须知道的小知识"><a href="#2-1-关于JVM参数必须知道的小知识" class="headerlink" title="2.1 关于JVM参数必须知道的小知识"></a>2.1 关于JVM参数必须知道的小知识</h3><ol>
<li>JVM参数分为标准参数和非标准参数，所有以<code>-X</code>和<code>-XX</code>开头的参数都是非标准参数，标准参数可以通过<code>java -help</code>命令查看，比如：<code>-server</code>就是一个标准参数。</li>
<li>非标准参数中，以<code>-XX</code>开头的都是不稳定的且不推荐在生成环境中使用。但现在的情况已经有所改变，很多<code>-XX</code>开头的参数也已经非常稳定了，但不管什么参数在使用前都应该了解它可能产生的影响。</li>
<li>布尔型参数，<code>-XX:+</code>表示激活选项，<code>-XX:-</code>表示关闭此选项。</li>
<li>部分参数可以使用<code>jinfo</code>工具动态设置，比如：<code>jinfo -flag +PrintGCDetails 12278</code>，能够动态设置的参数很少，所以用处有限，至于哪些参数可以动态设置，可以参考<code>jinfo</code>工具的使用方法。</li>
</ol>
<h3 id="2-2-GC日志"><a href="#2-2-GC日志" class="headerlink" title="2.2 GC日志"></a>2.2 GC日志</h3><p>GC日志是一个非常重要的工具，它准确的记录了每一次GC的执行时间和结果，通过分析GC日志可以帮助我们优化内存设置，也可以帮助改进应用的对象分配方式。如何阅读GC日志不在本文的范畴内，大家可以参考网上相关文章。<br>下面几个关于GC日志的参数应该加入到应用启动参数列表中：</p>
<ul>
<li><code>-XX:+PrintGCDetails</code> 开启详细GC日志模式</li>
<li><code>-XX:+PrintGCTimeStamps</code>在每行GC日志头部加上GC发生的时间，这个时间是指相对于JVM的启动时间，单位是秒</li>
<li><code>-XX:+PrintGCDateStamps</code>在GC日志的每一行加上绝对日期和时间，推荐同时使用这两个参数，这样在关联不同来源的GC日志时很有帮助</li>
<li><code>-XX:+PrintHeapAtGC</code>输出GC回收前和回收后的堆信息，使用这个参数可以更好的观察GC对堆空间的影响</li>
<li><code>-Xloggc</code>设置GC日志目录</li>
</ul>
<p>设置这几个参数后，发生GC时输出的日志就类似于下面的格式 (不同的垃圾收集器格式可能略有差异)：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-07</span>T19:<span class="number">45</span>:<span class="number">08.627</span>+<span class="number">0800</span>: <span class="number">0.794</span>: [GC (Allocation Failure) [PSYoungGen: <span class="number">153600</span>K-&gt;<span class="number">4564</span>K(<span class="number">179200</span>K)] <span class="number">153600</span>K-&gt;<span class="number">4580</span>K(<span class="number">384000</span>K), <span class="number">0.0051736</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">......</span></pre></td></tr></table></figure>

<p>简单的说明：</p>
<ul>
<li>2018-01-07T19:45:08.627+0800 - GC开始时间</li>
<li>0.794 - GC开始时间相对于JVM启动时间</li>
<li>GC - 用来区分是Minor GC 还是 Full GC，这里是Minor GC</li>
<li>Allocation Failure - GC原因，这里是因为年轻代中没有任何足够空间，也就是分配失败</li>
<li>PSYoungGen - 垃圾收集算法，这里是Parallel Scavenge</li>
<li>153600K-&gt;4564K(179200K) - 本次垃圾回收前后年轻代内存使用情况，括号内表示年轻代总大小</li>
<li>153600K-&gt;4580K(384000K) - 在本次垃圾回收前后整个堆内存的使用情况，括号内表示总的可用堆内存</li>
<li>0.0051736 secs - GC持续时间</li>
<li>[Times: user=0.01 sys=0.00, real=0.01 secs] - 多个维度衡量GC持续时间</li>
</ul>
<h3 id="2-3-内存优化"><a href="#2-3-内存优化" class="headerlink" title="2.3 内存优化"></a>2.3 内存优化</h3><p>我们的程序可能会经常出现性能问题，但如何分析和定位？知道一些常用的JVM内存管理参数，对我们开发人员有莫大的帮助。</p>
<h4 id="堆空间设置"><a href="#堆空间设置" class="headerlink" title="堆空间设置"></a>堆空间设置</h4><p>使用<code>-Xms</code>和<code>-Xmx</code>来指定JVM堆空间的初始值和最大值，比如：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">java </span>-Xms128m -Xmx2g app</span></pre></td></tr></table></figure>

<p>虽然JVM可以在运行时动态的调整堆内存大小，但很多时候我们都直接将<code>-Xms</code>和<code>-Xmx</code>设置相等的值，这样可以减少程序运行时进行垃圾回收的次数。</p>
<h4 id="新生代设置"><a href="#新生代设置" class="headerlink" title="新生代设置"></a>新生代设置</h4><p>参数<code>-Xmn</code>用于设置新生代大小，设置一个较大的新生代会减少老年代的大小，这个参数堆GC行为影响很大。一般情况下不需要使用这个参数，在分析GC日志后，发现确实是因为新生代设置过小导致频繁的Full GC，可以配置这个参数，一般情况下，新生代设置为堆空间的1/3 - 1/4左右。<br>还可以通过<code>-XX:SurviorRatio</code>设置新生代中eden区和Survivor from/to区空间的比例关系，也可使用<code>-XX:NewRatio</code>设置新生代和老年代的比例。<br>配置这3个参数的基本策略是：尽可能将对象预留在新生代，减少老年代GC的次数，所以需要更谨慎的对其进行修改，不要太随意。</p>
<h4 id="生成快照文件"><a href="#生成快照文件" class="headerlink" title="生成快照文件"></a>生成快照文件</h4><p>我们可能没有办法给最大堆内存设置一个合适的值，因为我们时常面临内存溢出的状况，当然我们可以在内存溢出情况出现后，再监控程序，dump出内存快照来定位，但这种方法的前提条件是内存溢出问题要再次发生。更好方法是通过设置<code>-XX:+HeapDumpOnOutOfMemoryError</code>让JVM在发生内存溢出时自动的生成堆内存快照。有了这个参数，当我们在面对内存溢出异常的时候会节约大量的时间，<code>-XX:HeapDumpPath</code>则可以设置快照的生成路径。堆内存快照文件可能很庞大，要注意存储的磁盘空间。</p>
<h4 id="方法区设置"><a href="#方法区设置" class="headerlink" title="方法区设置"></a>方法区设置</h4><p>方法区中存放中JVM加载的类信息，如果JVM加载的类过多，就需要合理设置永久大的大小，在JDK1.6和JDK1.7中，可以使用 <code>-XX:PermSize</code>和<code>-XX:MaxPermSize</code>来达到这个目的，前者用于设置永久代的初始大小，后者用于设置永久代的最大值。前面我们知道，方法区并不在堆内存中，所以要注意所有JVM参数设置的内存总大小。<br>在JDK1.8中已经使用元空间代替永久代，同样的目的，需要使用<code>-XX:MetaspaceSize</code>和<code>-XX:MaxMetaspaceSize</code>来代替。</p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>参数<code>-XX:MaxDirectMemorySize</code>用于配置直接内存大小 ，如果不设置，默认值为最大堆空间，即-Xmx，当直接内存使用量达到设置的值时，就会触发垃圾回收，如果垃圾回收不能有效释放足够空间，仍然会引起OOM。如果堆外内存发生OOM，请检查此参数是否配置过小。</p>
<h3 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h3><p>这部分主要介绍一些常用的JVM参数，理解这些JVM参数的前提是需要理解JVM的内存结构以及各个内存区域的作用，希望通过这些参数的介绍，能够加深大家对JVM内存结构的理解，也希望在平时的工作中能够注意这些参数的运用。下篇文章将着重介绍常用的垃圾回收算法与垃圾收集器。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>周志明 著; 深入理解Java虚拟机(第2版); 机械工业出版社,2013</li>
<li><a href="https://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="noopener">Java8内存模型—永久代(PermGen)和元空间(Metaspace)</a></li>
<li><a href="https://www.cnblogs.com/xiaotian15/p/6971353.html" target="_blank" rel="noopener">java虚拟机：运行时常量池</a></li>
<li><a href="http://www.idouba.net/a-simple-example-demo-jvm-allocation-and-gc/" target="_blank" rel="noopener">最简单例子图解JVM内存分配和回收</a></li>
<li><a href="https://www.cnblogs.com/dolphin0520/p/3613043.html" target="_blank" rel="noopener">JVM的内存区域划分</a></li>
<li><a href="http://ifeve.com/useful-jvm-flags-part-8-gc-logging/" target="_blank" rel="noopener">JVM实用参数（八）GC日志</a></li>
<li><a href="http://ifeve.com/useful-jvm-flags-part-4-heap-tuning/" target="_blank" rel="noopener">JVM实用参数（四）内存调优</a></li>
</ol>
<blockquote>
<p>作者：CHEN川</p>
<p>来源：<a href="https://www.jianshu.com/p/f8d71e1e8821" target="_blank" rel="noopener">https://www.jianshu.com/p/f8d71e1e8821</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/29/Spring-Boot%E7%9F%A5%E8%AF%86%E6%B8%85%E5%8D%95/" rel="prev" title="Spring Boot知识清单">
      <i class="fa fa-chevron-left"></i> Spring Boot知识清单
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/29/%E8%AF%A6%E8%A7%A3JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%882%EF%BC%89%EF%BC%9A%E4%BD%95%E4%B8%BA%E5%9E%83%E5%9C%BE/" rel="next" title="详解JVM内存管理与垃圾回收机制（2）：何为垃圾">
      详解JVM内存管理与垃圾回收机制（2）：何为垃圾 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、内存管理"><span class="nav-number">1.</span> <span class="nav-text">一、内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-运行时数据区"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 运行时数据区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Method-Area-方法区"><span class="nav-number">1.1.1.</span> <span class="nav-text">Method Area (方法区)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Runtime-Constant-Pool-运行时常量池"><span class="nav-number">1.1.2.</span> <span class="nav-text">Runtime Constant Pool (运行时常量池)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Heap-Space-Java堆"><span class="nav-number">1.1.3.</span> <span class="nav-text">Heap Space (Java堆)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VM-Stack-虚拟机栈-amp-Native-Method-Stack-本地方法栈"><span class="nav-number">1.1.4.</span> <span class="nav-text">VM Stack (虚拟机栈) &amp; Native Method Stack (本地方法栈)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Program-Counter-Register-程序计数器"><span class="nav-number">1.1.5.</span> <span class="nav-text">Program Counter Register (程序计数器)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-堆外内存"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 堆外内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-小结"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、常用JVM参数"><span class="nav-number">2.</span> <span class="nav-text">二、常用JVM参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-关于JVM参数必须知道的小知识"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 关于JVM参数必须知道的小知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-GC日志"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 GC日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-内存优化"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 内存优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#堆空间设置"><span class="nav-number">2.3.1.</span> <span class="nav-text">堆空间设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#新生代设置"><span class="nav-number">2.3.2.</span> <span class="nav-text">新生代设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生成快照文件"><span class="nav-number">2.3.3.</span> <span class="nav-text">生成快照文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法区设置"><span class="nav-number">2.3.4.</span> <span class="nav-text">方法区设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#直接内存"><span class="nav-number">2.3.5.</span> <span class="nav-text">直接内存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-小结"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">3.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">congsheng.wang</p>
  <div class="site-description" itemprop="description">trouble is a friend</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">984</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">94</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">156</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">congsheng.wang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
