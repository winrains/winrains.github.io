<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://congsheng.wang').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="0、前言 读完本文，你将了解到：一、为什么说Jabalpur语言是跨平台的二、Java虚拟机启动、加载类过程分析三、类加载器有哪些？其组织结构是怎样的？四、双亲加载模型的逻辑和底层代码实现是怎样的？五、类加载器与Class 实例的关系六、线程上下文加载器">
<meta property="og:type" content="article">
<meta property="og:title" content="Java虚拟机原理图解（9）：JVM类加载器机制与类加载过程">
<meta property="og:url" content="http:&#x2F;&#x2F;congsheng.wang&#x2F;2019&#x2F;12&#x2F;28&#x2F;Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3%EF%BC%889%EF%BC%89%EF%BC%9AJVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B&#x2F;index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="0、前言 读完本文，你将了解到：一、为什么说Jabalpur语言是跨平台的二、Java虚拟机启动、加载类过程分析三、类加载器有哪些？其组织结构是怎样的？四、双亲加载模型的逻辑和底层代码实现是怎样的？五、类加载器与Class 实例的关系六、线程上下文加载器">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;20190926185635-3ec84.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;20190926185635-6c059.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;20190926185636-532e0.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;20190926185636-cd95f.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;20190926185636-8a100.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;20190926185638-c2360.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;20190926185639-4bca3.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;20190926185639-84570.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;20190926185638-c2360.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;20190926185636-8a100.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;20190926185641-21830.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;20190926185642-1c11a.jpeg">
<meta property="og:updated_time" content="2019-12-28T06:54:49.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;20190926185635-3ec84.jpeg">

<link rel="canonical" href="http://congsheng.wang/2019/12/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3%EF%BC%889%EF%BC%89%EF%BC%9AJVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Java虚拟机原理图解（9）：JVM类加载器机制与类加载过程 | 个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">winrains的个人博客</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">108</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">83</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">489</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://congsheng.wang/2019/12/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3%EF%BC%889%EF%BC%89%EF%BC%9AJVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="winrains">
      <meta itemprop="description" content="淡泊明志">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java虚拟机原理图解（9）：JVM类加载器机制与类加载过程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-28 14:54:49" itemprop="dateCreated datePublished" datetime="2019-12-28T14:54:49+08:00">2019-12-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" itemprop="url" rel="index">
                    <span itemprop="name">类加载机制</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h1><blockquote>
<p>读完本文，你将了解到：<br>一、为什么说Jabalpur语言是跨平台的<br>二、Java虚拟机启动、加载类过程分析<br>三、类加载器有哪些？其组织结构是怎样的？<br>四、双亲加载模型的逻辑和底层代码实现是怎样的？<br>五、类加载器与Class<T> 实例的关系<br>六、线程上下文加载器</p>
</blockquote>
<a id="more"></a>

<h1 id="一、为什么说Java语言是跨平台的？"><a href="#一、为什么说Java语言是跨平台的？" class="headerlink" title="一、为什么说Java语言是跨平台的？"></a>一、为什么说Java语言是跨平台的？</h1><p>Java语言之所以说它是跨平台的、可以在当前绝大部分的操作系统平台下运行，是因为Java语言的运行环境是在Java虚拟机中。<br>Java虚拟机消除了各个平台之间的差异，只要操作系统平台下安装了Java虚拟机，那么使用Java开发的东西都能在其上面运行。如下图所示：<br><img src="http://image.winrains.cn/2019/09/20190926185635-3ec84.jpeg" alt="img"><br>Java虚拟机对各个平台而言，实质上是各个平台上的一个可执行程序。例如在windows平台下，java虚拟机对于windows而言，就是一个java.exe进程而已。</p>
<h1 id="二、Java虚拟机启动、加载类过程分析"><a href="#二、Java虚拟机启动、加载类过程分析" class="headerlink" title="二、Java虚拟机启动、加载类过程分析"></a>二、Java虚拟机启动、加载类过程分析</h1><p>下面我将定义一个非常简单的java程序并运行它，来逐步分析java虚拟机启动的过程。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">package org.luanlouis.jvm.<span class="keyword">load</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.<span class="keyword">security</span>.pkcs11.P11Util;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Created by louis on 2016/1/16.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Main &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("Hello,World!");</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        ClassLoader loader = P11Util.<span class="keyword">class</span>.getClassLoader();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(loader);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在windows命令行下输入：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">java</span> <span class="selector-tag">org</span><span class="selector-class">.luanlouis</span><span class="selector-class">.jvm</span><span class="selector-class">.load</span><span class="selector-class">.Main</span></span></pre></td></tr></table></figure>

<p>当输入上述的命令时：<br>windows开始运行<code>{JRE_HOME}/bin/java.exe</code>程序，java.exe 程序将完成以下步骤：<br>\1. 根据JVM内存配置要求，为JVM申请特定大小的内存空间；<br>\2. 创建一个引导类加载器实例，初步加载系统类到内存方法区区域中；<br>\3. 创建JVM 启动器实例 <code>Launcher</code>,并取得类加载器<code>ClassLoader</code>；<br>\4. 使用上述获取的<code>ClassLoader</code>实例加载我们定义的 <code>org.luanlouis.jvm.load.Main</code>类；<br>\5. 加载完成时候JVM会执行<code>Main</code>类的<code>main</code>方法入口，执行<code>Main</code>类的<code>main</code>方法；<br>\6. 结束，java程序运行结束，JVM销毁。</p>
<h2 id="Step-1-根据JVM内存配置要求，为JVM申请特定大小的内存空间"><a href="#Step-1-根据JVM内存配置要求，为JVM申请特定大小的内存空间" class="headerlink" title="Step 1.根据JVM内存配置要求，为JVM申请特定大小的内存空间"></a>Step 1.根据JVM内存配置要求，为JVM申请特定大小的内存空间</h2><p>为了不降低本文的理解难度，这里就不详细介绍JVM内存配置要求的话题，今概括地介绍一下内存的功能划分。<br>JVM启动时，按功能划分，其内存应该由以下几部分组成：<br><img src="http://image.winrains.cn/2019/09/20190926185635-6c059.jpeg" alt="img"><br>如上图所示，JVM内存按照功能上的划分，可以粗略地划分为方法区(Method Area) 和堆(Heap),而所有的类的定义信息都会被加载到方法区中。<br>关于具体方法区里有什么内容，读者可以参考我的另一篇博文：<br><a href="http://blog.csdn.net/luanlouis/article/details/40043991" target="_blank" rel="noopener">《Java虚拟机原理图解》3、JVM运行时数据区</a></p>
<h2 id="Step-2-创建一个引导类加载器实例，初步加载系统类到内存方法区区域中；"><a href="#Step-2-创建一个引导类加载器实例，初步加载系统类到内存方法区区域中；" class="headerlink" title="Step 2. 创建一个引导类加载器实例，初步加载系统类到内存方法区区域中；"></a>Step 2. 创建一个引导类加载器实例，初步加载系统类到内存方法区区域中；</h2><p>JVM申请好内存空间后，JVM会创建一个引导类加载器（Bootstrap Classloader）实例，引导类加载器是使用C++语言实现的，负责加载JVM虚拟机运行时所需的基本系统级别的类，如<code>java.lang.String, java.lang.Object</code>等等。<br>引导类加载器(Bootstrap Classloader)会读取 <code>{JRE_HOME}/lib</code> 下的jar包和配置，然后将这些系统类加载到方法区内。<br>本例中，引导类加载器是用<code>{JRE_HOME}/lib</code>加载类的，不过，你也可以使用参数 <code>-Xbootclasspath</code> 或 系统变量<code>sun.boot.class.path</code>来指定的目录来加载类。<br>一般而言，<code>{JRE_HOME}/lib</code>下存放着JVM正常工作所需要的系统类，如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">文件名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">rt.jar</td>
<td align="center">运行环境包，rt即runtime，J2SE 的类定义都在这个包内</td>
</tr>
<tr>
<td align="center">charsets.jar</td>
<td align="center">字符集支持包</td>
</tr>
<tr>
<td align="center">jce.jar</td>
<td align="center">是一组包，它们提供用于加密、密钥生成和协商以及 Message Authentication Code（MAC）算法的框架和实现</td>
</tr>
<tr>
<td align="center">jsse.jar</td>
<td align="center">安全套接字拓展包Java(TM) Secure Socket Extension</td>
</tr>
<tr>
<td align="center">classlist</td>
<td align="center">该文件内表示是引导类加载器应该加载的类的清单</td>
</tr>
<tr>
<td align="center">net.properties</td>
<td align="center">JVM 网络配置信息</td>
</tr>
</tbody></table>
<p>引导类加载器(Bootstrap ClassLoader） 加载系统类后，JVM内存会呈现如下格局：<br><img src="http://image.winrains.cn/2019/09/20190926185636-532e0.jpeg" alt="img"></p>
<ul>
<li>引导类加载器将类信息加载到方法区中，以特定方式组织，对于某一个特定的类而言，在方法区中它应该有 运行时常量池、类型信息、字段信息、方法信息、类加载器的引用，对应class实例的引用等信息。</li>
<li><strong>类加载器的引用</strong>,由于这些类是由引导类加载器(Bootstrap Classloader)进行加载的，而 引导类加载器是有C++语言实现的，所以是无法访问的，故而该引用为NULL</li>
<li><strong>对应class实例的引用</strong>， 类加载器在加载类信息放到方法区中后，会创建一个对应的Class 类型的实例放到堆(Heap)中, 作为开发人员访问方法区中类定义的入口和切入点。</li>
</ul>
<p>小测试：<br>当我们在代码中尝试获取系统类如<code>java.lang.Object</code>的类加载器时，你会始终得到NULL：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">ClassLoader()</span>);<span class="comment">//null</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">ClassLoader()</span>);<span class="comment">//null</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">ClassLoader()</span>);<span class="comment">//null</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">ClassLoader()</span>);<span class="comment">//null</span></span></pre></td></tr></table></figure>

<h2 id="Step-3-创建JVM-启动器实例-Launcher-并取得类加载器ClassLoader"><a href="#Step-3-创建JVM-启动器实例-Launcher-并取得类加载器ClassLoader" class="headerlink" title="Step 3. 创建JVM 启动器实例 Launcher,并取得类加载器ClassLoader"></a>Step 3. 创建JVM 启动器实例 Launcher,并取得类加载器ClassLoader</h2><p>上述步骤完成，JVM基本运行环境就准备就绪了。接着，我们要让JVM工作起来了：运行我们定义的程序 <code>org.luanlouis,jvm.load.Main</code>。<br>此时，JVM虚拟机调用已经加载在方法区的类<code>sun.misc.Launcher</code> 的静态方法<code>getLauncher()</code>, 获取<code>sun.misc.Launcher</code> 实例：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher launcher = sun.misc.<span class="module-access"><span class="module"><span class="identifier">Launcher</span>.</span></span>get<span class="constructor">Launcher()</span>; <span class="comment">//获取Java启动器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = launcher.get<span class="constructor">ClassLoader()</span>;          <span class="comment">//获取类加载器ClassLoader用来加载class到内存来</span></span></pre></td></tr></table></figure>

<p><code>sun.misc.Launcher</code> 使用了单例模式设计，保证一个JVM虚拟机内只有一个<code>sun.misc.Launcher</code>实例。<br>在Launcher的内部，其定义了两个类加载器(<code>ClassLoader</code>),分别是<code>sun.misc.Launcher.ExtClassLoader</code>和<code>sun.misc.Launcher.AppClassLoader</code>，这两个类加载器分别被称为拓展类加载器(Extension ClassLoader) 和 应用类加载器(Application ClassLoader).如下图所示：<br><img src="http://image.winrains.cn/2019/09/20190926185636-cd95f.jpeg" alt="img"><br>图例注释：除了引导类加载器(Bootstrap Class Loader )的所有类加载器，都有一个能力，就是判断某一个类是否被引导类加载器加载过，如果加载过，可以直接返回对应的<code>Class instance</code>，如果没有，则返回null. 图上的指向引导类加载器的虚线表示类加载器的这个有限的访问 引导类加载器的功能。<br>此时的 <code>launcher.getClassLoader()</code> 方法将会返回 <code>AppClassLoader</code> 实例，<code>AppClassLoader</code>将<code>ExtClassLoader</code>作为自己的父加载器。<br>当<code>AppClassLoader</code>加载类时，会首先尝试让父加载器<code>ExtClassLoader</code>进行加载，如果父加载器<code>ExtClassLoader</code>加载成功，则<code>AppClassLoader</code>直接返回父加载器<code>ExtClassLoader</code>加载的结果；如果父加载器<code>ExtClassLoader</code>加载失败，<code>AppClassLoader</code>则会判断该类是否是引导的系统类(即是否是通过<code>Bootstrap</code>类加载器加载，这会调用<code>Native</code>方法进行查找)；若要加载的类不是系统引导类，那么<code>ClassLoader</code>将会尝试自己加载，加载失败将会抛出“<code>ClassNotFoundException</code>”。<br>具体<code>AppClassLoader</code>的工作流程如下所示：<br><img src="http://image.winrains.cn/2019/09/20190926185636-8a100.jpeg" alt="img"><br>双亲委派模型(parent-delegation model)：<br>上面讨论的应用类加载器<code>AppClassLoader</code>的加载类的模式就是我们常说的双亲委派模型(parent-delegation model).<br>对于某个特定的类加载器而言，应该为其指定一个父类加载器，当用其进行加载类的时候：<br>\1. 委托父类加载器帮忙加载；<br>\2. 父类加载器加载不了，则查询引导类加载器有没有加载过该类；<br>\3. 如果引导类加载器没有加载过该类，则当前的类加载器应该自己加载该类；<br>\4. 若加载成功，返回 对应的<code>Class</code> 对象；若失败，抛出异常“<code>ClassNotFoundException</code>”。<br>请注意：<br>双亲委派模型中的”双亲”并不是指它有两个父类加载器的意思，一个类加载器只应该有一个父加载器。上面的步骤中，有两个角色：<br>\1. 父类加载器(parent classloader)：它可以替子加载器尝试加载类<br>\2. 引导类加载器（bootstrap classloader）: 子类加载器只能判断某个类是否被引导类加载器加载过，而不能委托它加载某个类；换句话说，就是子类加载器不能接触到引导类加载器，引导类加载器对其他类加载器而言是透明的。<br>一般情况下，双亲加载模型如下所示：<br><img src="http://image.winrains.cn/2019/09/20190926185638-c2360.jpeg" alt="img"></p>
<h2 id="Step-4-使用类加载器ClassLoader加载Main类"><a href="#Step-4-使用类加载器ClassLoader加载Main类" class="headerlink" title="Step 4. 使用类加载器ClassLoader加载Main类"></a>Step 4. 使用类加载器ClassLoader加载Main类</h2><p>通过 <code>launcher.getClassLoader()</code>方法返回<code>AppClassLoader</code>实例，接着就是<code>AppClassLoader</code>加载 <code>org.luanlouis.jvm.load.Main</code>类的时候了。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">ClassLoader classloader = launcher.get<span class="constructor">ClassLoader()</span>;<span class="comment">//取得AppClassLoader类</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">classLoader.load<span class="constructor">Class(<span class="string">"org.luanlouis.jvm.load.Main"</span>)</span>;<span class="comment">//加载自定义类</span></span></pre></td></tr></table></figure>

<p>上述定义的<code>org.luanlouis.jvm.load.Main</code>类被编译成<code>org.luanlouis.jvm.load.Main class</code>二进制文件，这个class文件中有一个叫常量池(Constant Pool)的结构体来存储该class的常亮信息。常量池中有<code>CONSTANT_CLASS_INFO</code>类型的常量，表示该class中声明了要用到那些类：<br><img src="http://image.winrains.cn/2019/09/20190926185639-4bca3.jpeg" alt="img"><br>当<code>AppClassLoader</code>要加载 <code>org.luanlouis.jvm.load.Main</code>类时，会去查看该类的定义，发现它内部声明使用了其它的类： <code>sun.security.pkcs11.P11Util</code>、<code>java.lang.Object</code>、<code>java.lang.System</code>、<code>java.io.PrintStream</code>、<code>java.lang.Class</code>；<code>org.luanlouis.jvm.load.Main</code>类要想正常工作，首先要能够保证这些其内部声明的类加载成功。所以<code>AppClassLoader</code>要先将这些类加载到内存中。（注：为了理解方便，这里没有考虑懒加载的情况，事实上的JVM加载类过程比这复杂的多）<br>加载顺序：<br><strong>1. 加载java.lang.Object、java.lang.System、java.io.PrintStream、java,lang.Class</strong><br><code>AppClassLoader</code>尝试加载这些类的时候，会先委托<code>ExtClassLoader</code>进行加载；而<code>ExtClassLoader</code>发现不是其加载范围，其返回null；<code>AppClassLoader</code>发现父类加载器<code>ExtClassLoader</code>无法加载，则会查询这些类是否已经被<code>BootstrapClassLoader</code>加载过，结果表明这些类已经被<code>BootstrapClassLoader</code>加载过，则无需重复加载，直接返回对应的<code>Class</code>实例；<br><strong>2. 加载sun.security.pkcs11.P11Util</strong><br>此在<code>{JRE_HOME}/lib/ext/sunpkcs11.jar</code>包内，属于<code>ExtClassLoader</code>负责加载的范畴。<code>AppClassLoader</code>尝试加载这些类的时候，会先委托<code>ExtClassLoader</code>进行加载；而<code>ExtClassLoader</code>发现其正好属于加载范围，故<code>ExtClassLoader</code>负责将其加载到内存中。<code>ExtClassLoader</code>在加载<code>sun.security.pkcs11.P11Util</code>时也分析这个类内都使用了哪些类，并将这些类先加载内存后，才开始加载<code>sun.security.pkcs11.P11Util</code>，加载成功后直接返回对应的<code>Class</code>实例；<br><strong>3. 加载org.luanlouis.jvm.load.Main</strong><br><code>AppClassLoader</code>尝试加载这些类的时候，会先委托<code>ExtClassLoader</code>进行加载；而<code>ExtClassLoader</code>发现不是其加载范围，其返回null；<code>AppClassLoader</code>发现父类加载器<code>ExtClassLoader</code>无法加载，则会查询这些类是否已经被<code>BootstrapClassLoader</code>加载过。而结果表明<code>BootstrapClassLoader</code> 没有加载过它，这时候<code>AppClassLoader</code>只能自己动手负责将其加载到内存中，然后返回对应的<code>Class</code>实例引用；<br>以上三步骤都成功，才表示<code>classLoader.loadClass(&quot;org.luanlouis.jvm.load.Main&quot;)</code>完成，上述操作完成后，JVM内存方法区的格局会如下所示：<br><img src="http://image.winrains.cn/2019/09/20190926185639-84570.jpeg" alt="img"><br>如上图所示：</p>
<ul>
<li>JVM方法区的类信息区是按照类加载器进行划分的，每个类加载器会维护自己加载类信息；</li>
<li>某个类加载器在加载相应的类时，会相应地在JVM内存堆（Heap）中创建一个对应的<code>Class</code>，用来表示访问该类信息的入口</li>
</ul>
<p>Step 5. 使用<code>Main</code>类的<code>main</code>方法作为程序入口运行程序<br>Step 6. 方法执行完毕，JVM销毁，释放内存</p>
<h1 id="三、类加载器有哪些？其组织结构是怎样的？"><a href="#三、类加载器有哪些？其组织结构是怎样的？" class="headerlink" title="三、类加载器有哪些？其组织结构是怎样的？"></a>三、类加载器有哪些？其组织结构是怎样的？</h1><p>类加载器(Class Loader)：顾名思义，指的是可以加载类的工具。JVM自身定义了三个类加载器：引导类加载器(Bootstrap Class Loader)、拓展类加载器(Extension Class Loader )、应用加载器(Application Class Loader)。当然，我们有时候也会自己定义一些类加载器来满足自身的需要。<br>引导类加载器(Bootstrap Class Loader): 该类加载器使JVM使用C/C++底层代码实现的加载器，用以加载JVM运行时所需要的系统类，这些系统类在<code>{JRE_HOME}/lib</code>目录下。由于类加载器是使用平台相关的底层C/C++语言实现的， 所以该加载器不能被Java代码访问到。但是，我们可以查询某个类是否被引导类加载器加载过。我们经常使用的系统类如：<code>java.lang.String,java.lang.Object,java.lang*</code>……. 这些都被放在 <code>{JRE_HOME}/lib/rt.jar</code>包内， 当JVM系统启动的时候，引导类加载器会将其加载到 JVM内存的方法区中。<br>拓展类加载器(Extension Class Loader): 该加载器是用于加载 java 的拓展类 ，拓展类一般会放在 <code>{JRE_HOME}/lib/ext/</code> 目录下，用来提供除了系统类之外的额外功能。拓展类加载器是是整个JVM加载器的Java代码可以访问到的类加载器的最顶端，即是超级父加载器，拓展类加载器是没有父类加载器的。<br>应用类加载器(Applocatoin Class Loader): 该类加载器是用于加载用户代码，是用户代码的入口。我经常执行指令 <code>java xxx.x.xxx.x.x.XClass</code> , 实际上，JVM就是使用的AppClassLoader加载 <code>xxx.x.xxx.x.x.XClass</code> 类的。应用类加载器将拓展类加载器当成自己的父类加载器，当其尝试加载类的时候，首先尝试让其父加载器-拓展类加载器加载；如果拓展类加载器加载成功，则直接返回加载结果<code>Class instance</code>,加载失败，则会询问是否引导类加载器已经加载了该类；只有没有加载的时候，应用类加载器才会尝试自己加载。由于<code>xxx.x.xxx.x.x.XClass</code>是整个用户代码的入口，在Java虚拟机规范中，称其为 初始类(Initial Class).<br>用户自定义类加载器（Customized Class Loader）：用户可以自己定义类加载器来加载类。所有的类加载器都要继承<code>java.lang.ClassLoader</code>类。<br><img src="http://image.winrains.cn/2019/09/20190926185638-c2360.jpeg" alt="img"></p>
<h1 id="四、双亲加载模型的逻辑和底层代码实现是怎样的？"><a href="#四、双亲加载模型的逻辑和底层代码实现是怎样的？" class="headerlink" title="四、双亲加载模型的逻辑和底层代码实现是怎样的？"></a>四、双亲加载模型的逻辑和底层代码实现是怎样的？</h1><p>上面已经不厌其烦地讲解什么是双亲加载模型，以及其机制是什么，这些东西都是可以通过底层代码查看到的。<br>我们也可以通过JDK源码看<code>java.lang.ClassLoader</code>的核心方法<code>loadClass()</code>的实现：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//提供class类的二进制名称表示，加载对应class，加载成功，则返回表示该类对应的Class&lt;T&gt; instance 实例</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">public Class&lt;?&gt; load<span class="constructor">Class(String <span class="params">name</span>)</span> throws ClassNotFoundException &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    return load<span class="constructor">Class(<span class="params">name</span>, <span class="params">false</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; load<span class="constructor">Class(String <span class="params">name</span>, <span class="params">boolean</span> <span class="params">resolve</span>)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    throws ClassNotFoundException</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    synchronized (get<span class="constructor">ClassLoadingLock(<span class="params">name</span>)</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 首先，检查是否已经被当前的类加载器记载过了，如果已经被加载，直接返回对应的Class&lt;T&gt;实例</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        Class&lt;?&gt; c = find<span class="constructor">LoadedClass(<span class="params">name</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//初次加载</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (c<span class="operator"> == </span>null) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            long t0 = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>nano<span class="constructor">Time()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (parent != null) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment">//如果有父类加载器，则先让父类加载器加载</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                    c = parent.load<span class="constructor">Class(<span class="params">name</span>, <span class="params">false</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment">// 没有父加载器，则查看是否已经被引导类加载器加载，有则直接返回</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                    c = find<span class="constructor">BootstrapClassOrNull(<span class="params">name</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// from the non-null parent class loader</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 父加载器加载失败，并且没有被引导类加载器加载，则尝试该类加载器自己尝试加载</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (c<span class="operator"> == </span>null) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// to find the class.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                long t1 = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>nano<span class="constructor">Time()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 自己尝试加载</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">                c = find<span class="constructor">Class(<span class="params">name</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">                sun.misc.<span class="module-access"><span class="module"><span class="identifier">PerfCounter</span>.</span></span>get<span class="constructor">ParentDelegationTime()</span>.add<span class="constructor">Time(<span class="params">t1</span> - <span class="params">t0</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">                sun.misc.<span class="module-access"><span class="module"><span class="identifier">PerfCounter</span>.</span></span>get<span class="constructor">FindClassTime()</span>.add<span class="constructor">ElapsedTimeFrom(<span class="params">t1</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">                sun.misc.<span class="module-access"><span class="module"><span class="identifier">PerfCounter</span>.</span></span>get<span class="constructor">FindClasses()</span>.increment<span class="literal">()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//是否解析类</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">            resolve<span class="constructor">Class(<span class="params">c</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        return c;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>相对应地，我们可以整理出双亲模型的工作流程图：<br><img src="http://image.winrains.cn/2019/09/20190926185636-8a100.jpeg" alt="img"><br>相信读者看过这张图后会对双亲加载模型有了非常清晰的脉络。当然，这是JDK自身默认的加载类的行为，我们可以通过继承复写该方法，改变其行为。</p>
<h1 id="五、类加载器与Class-实例的关系"><a href="#五、类加载器与Class-实例的关系" class="headerlink" title="五、类加载器与Class 实例的关系"></a>五、类加载器与Class<T> 实例的关系</h1><p><img src="http://image.winrains.cn/2019/09/20190926185641-21830.jpeg" alt="img"></p>
<h1 id="六、线程上下文加载器"><a href="#六、线程上下文加载器" class="headerlink" title="六、线程上下文加载器"></a>六、线程上下文加载器</h1><p>Java 任何一段代码的执行，都有对应的线程上下文。如果我们在代码中，想看当前是哪一个线程在执行当前代码，我们经常是使用如下方法：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">Thread</span>  <span class="keyword">thread</span> = <span class="keyword">Thread</span>.currentThread();<span class="comment">//返回对当当前运行线程的引用</span></span></pre></td></tr></table></figure>

<p><img src="http://image.winrains.cn/2019/09/20190926185642-1c11a.jpeg" alt="img"><br>相应地，我们可以为当前的线程指定类加载器。在上述的例子中， 当执行 <code>java org.luanlouis.jvm.load.Main</code> 的时候，JVM会创建一个<code>Main</code>线程，而创建应用类加载器<code>AppClassLoader</code>的时候，会将<code>AppClassLoader</code> 设置成<code>Main</code>线程的上下文类加载器：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public <span class="constructor">Launcher()</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    Launcher.ExtClassLoader var1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        var1 = <span class="module-access"><span class="module"><span class="identifier">Launcher</span>.</span><span class="module"><span class="identifier">ExtClassLoader</span>.</span></span>get<span class="constructor">ExtClassLoader()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125; catch (IOException var10) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        throw <span class="keyword">new</span> <span class="constructor">InternalError(<span class="string">"Could not create extension class loader"</span>, <span class="params">var10</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        this.loader = <span class="module-access"><span class="module"><span class="identifier">Launcher</span>.</span><span class="module"><span class="identifier">AppClassLoader</span>.</span></span>get<span class="constructor">AppClassLoader(<span class="params">var1</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125; catch (IOException var9) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        throw <span class="keyword">new</span> <span class="constructor">InternalError(<span class="string">"Could not create application class loader"</span>, <span class="params">var9</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//将AppClassLoader设置成当前线程的上下文加载器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.set<span class="constructor">ContextClassLoader(<span class="params">this</span>.<span class="params">loader</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//.......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>线程上下文类加载器是从线程的角度来看待类的加载，为每一个线程绑定一个类加载器，可以将类的加载从单纯的 双亲加载模型解放出来，进而实现特定的加载需求。</p>
<blockquote>
<p>作者：亦山</p>
<p>来源：<a href="https://blog.csdn.net/luanlouis/article/details/50529868" target="_blank" rel="noopener">https://blog.csdn.net/luanlouis/article/details/50529868</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3%EF%BC%888%EF%BC%89%EF%BC%9AJVM%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E9%9B%86/" rel="prev" title="Java虚拟机原理图解（8）：JVM机器指令集">
      <i class="fa fa-chevron-left"></i> Java虚拟机原理图解（8）：JVM机器指令集
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/28/Java%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8/" rel="next" title="Java反射的作用">
      Java反射的作用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0、前言"><span class="nav-number">1.</span> <span class="nav-text">0、前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一、为什么说Java语言是跨平台的？"><span class="nav-number">2.</span> <span class="nav-text">一、为什么说Java语言是跨平台的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、Java虚拟机启动、加载类过程分析"><span class="nav-number">3.</span> <span class="nav-text">二、Java虚拟机启动、加载类过程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Step-1-根据JVM内存配置要求，为JVM申请特定大小的内存空间"><span class="nav-number">3.1.</span> <span class="nav-text">Step 1.根据JVM内存配置要求，为JVM申请特定大小的内存空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Step-2-创建一个引导类加载器实例，初步加载系统类到内存方法区区域中；"><span class="nav-number">3.2.</span> <span class="nav-text">Step 2. 创建一个引导类加载器实例，初步加载系统类到内存方法区区域中；</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Step-3-创建JVM-启动器实例-Launcher-并取得类加载器ClassLoader"><span class="nav-number">3.3.</span> <span class="nav-text">Step 3. 创建JVM 启动器实例 Launcher,并取得类加载器ClassLoader</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Step-4-使用类加载器ClassLoader加载Main类"><span class="nav-number">3.4.</span> <span class="nav-text">Step 4. 使用类加载器ClassLoader加载Main类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、类加载器有哪些？其组织结构是怎样的？"><span class="nav-number">4.</span> <span class="nav-text">三、类加载器有哪些？其组织结构是怎样的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、双亲加载模型的逻辑和底层代码实现是怎样的？"><span class="nav-number">5.</span> <span class="nav-text">四、双亲加载模型的逻辑和底层代码实现是怎样的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五、类加载器与Class-实例的关系"><span class="nav-number">6.</span> <span class="nav-text">五、类加载器与Class 实例的关系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#六、线程上下文加载器"><span class="nav-number">7.</span> <span class="nav-text">六、线程上下文加载器</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">winrains</p>
  <div class="site-description" itemprop="description">淡泊明志</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">489</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">83</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">108</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">winrains</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
