<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://congsheng.wang').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="java注解是在JDK5时引入的新特性，鉴于目前大部分框架(如Spring)都使用了注解简化代码并提高编码的效率，因此掌握并深入理解注解对于一个Java工程师是来说是很有必要的事。">
<meta name="keywords" content="注解">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Java注解类型">
<meta property="og:url" content="http:&#x2F;&#x2F;congsheng.wang&#x2F;2019&#x2F;12&#x2F;28&#x2F;%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E6%B3%A8%E8%A7%A3%E7%B1%BB%E5%9E%8B&#x2F;index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="java注解是在JDK5时引入的新特性，鉴于目前大部分框架(如Spring)都使用了注解简化代码并提高编码的效率，因此掌握并深入理解注解对于一个Java工程师是来说是很有必要的事。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-12-28T07:12:21.000Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://congsheng.wang/2019/12/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E6%B3%A8%E8%A7%A3%E7%B1%BB%E5%9E%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>深入理解Java注解类型 | 个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">winrains的个人博客</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">108</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">82</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">469</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://congsheng.wang/2019/12/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E6%B3%A8%E8%A7%A3%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="winrains">
      <meta itemprop="description" content="淡泊明志">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入理解Java注解类型
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-28 15:12:21" itemprop="dateCreated datePublished" datetime="2019-12-28T15:12:21+08:00">2019-12-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">Java技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>java注解是在JDK5时引入的新特性，鉴于目前大部分框架(如Spring)都使用了注解简化代码并提高编码的效率，因此掌握并深入理解注解对于一个Java工程师是来说是很有必要的事。</p>
<a id="more"></a>

<h1 id="1-理解Java注解"><a href="#1-理解Java注解" class="headerlink" title="1 理解Java注解"></a>1 理解Java注解</h1><p>实际上Java注解与普通修饰符(<code>public</code>、<code>static</code>、<code>void</code>等)的使用方式并没有多大区别，下面的例子是常见的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemo</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//@Test注解修饰方法A</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Test....."</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//一个方法上可以拥有多个不同的注解</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Deprecated</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"uncheck"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过在方法上使用<code>@Test</code>注解后，在运行该方法时，测试框架会自动识别该方法并单独调用，<code>@Test</code>实际上是一种标记注解，起标记作用，运行时告诉测试框架该方法为测试方法。而对于<code>@Deprecated</code>和<code>@SuppressWarnings(“uncheck”)</code>，则是Java本身内置的注解，在代码中，可以经常看见它们，但这并不是一件好事，毕竟当方法或是类上面有<code>@Deprecated</code>注解时，说明该方法或是类都已经过期不建议再用，<code>@SuppressWarnings</code> 则表示忽略指定警告，比如<code>@SuppressWarnings(“uncheck”)</code>，这就是注解的最简单的使用方式，那么下面我们就来看看注解定义的基本语法</p>
<h1 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2 基本语法"></a>2 基本语法</h1><h2 id="2-1-声明注解与元注解"><a href="#2-1-声明注解与元注解" class="headerlink" title="2.1 声明注解与元注解"></a>2.1 声明注解与元注解</h2><p>我们先来看看前面的<code>Test</code>注解是如何声明的：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明Test注解</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(ElementType.METHOD)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">public <span class="variable">@interface</span> Test &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们使用了<code>@interface</code>声明了<code>Test</code>注解，并使用<code>@Target</code>注解传入<code>ElementType.METHOD</code>参数来标明<code>@Test</code>只能用于方法上，<code>@Retention(RetentionPolicy.RUNTIME)</code>则用来表示该注解生存期是运行时，从代码上看注解的定义很像接口的定义，确实如此，毕竟在编译后也会生成<code>Test.class</code>文件。对于<code>@Target</code>和<code>@Retention</code>是由Java提供的元注解，所谓元注解就是标记其他注解的注解，下面分别介绍</p>
<ul>
<li><code>@Target</code> 用来约束注解可以应用的地方（如方法、类或字段），其中<code>ElementType</code>是枚举类型，其定义如下，也代表可能的取值范围</li>
</ul>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    /**标明该注解可以用于类、接口（包括注解类型）或<span class="class"><span class="keyword">enum</span>声明*/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    TYPE,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    /** 标明该注解可以用于字段(域)声明，包括<span class="class"><span class="keyword">enum</span>实例 */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    FIELD,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    /** 标明该注解可以用于方法声明 *<span class="regexp">/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    METHOD,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    /</span>** 标明该注解可以用于参数声明 *<span class="regexp">/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    PARAMETER,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    /</span>** 标明注解可以用于构造函数声明 *<span class="regexp">/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    CONSTRUCTOR,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    /</span>** 标明注解可以用于局部变量声明 *<span class="regexp">/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    LOCAL_VARIABLE,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    /</span>** 标明注解可以用于注解声明(应用于另一个注解上)*<span class="regexp">/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    ANNOTATION_TYPE,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    /</span>** 标明注解可以用于包声明 *<span class="regexp">/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    PACKAGE,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    /</span>**</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">     * 标明注解可以用于类型参数声明（<span class="number">1.8</span>新加入）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">     * @since <span class="number">1.8</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">     *<span class="regexp">/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    TYPE_PARAMETER,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    /</span>**</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">     * 类型使用声明（<span class="number">1.8</span>新加入)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">     * @since <span class="number">1.8</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">     *<span class="regexp">/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    TYPE_USE</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">&#125;</span></span></pre></td></tr></table></figure>

<p>请注意，当注解未指定<code>Target</code>值时，则此注解可以用于任何元素之上，多个值使用{}包含并用逗号隔开，如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">@<span class="keyword">Target</span>(<span class="keyword">value</span>=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, <span class="keyword">PARAMETER</span>, <span class="keyword">TYPE</span>&#125;)</span></pre></td></tr></table></figure>

<ul>
<li><pre><code>@Retention
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  用来约束注解的生命周期，分别有三个值，源码级别（source），类文件级别（class）或者运行时级别（runtime），其含有如下：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  - SOURCE：注解将被编译器丢弃（该类型的注解信息只会保留在源码里，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class文件里）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  - CLASS：注解在class文件中可用，但会被VM丢弃（该类型的注解信息会保留在源码里和class文件里，在执行的时候，不会加载到虚拟机中），请注意，当注解未定义`Retention`值时，默认值是`CLASS`，如Java内置注解，`@Override`、`@Deprecated`、`@SuppressWarnning`等</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  - RUNTIME：注解信息将在运行期(JVM)也保留，因此可以通过反射机制读取注解的信息（源码、class文件和执行的时候都有注解的信息），如SpringMvc中的`@Controller`、`@Autowired`、`@RequestMapping`等。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">## <span class="number">2.2</span> 注解元素及其数据类型</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">通过上述对`@Test`注解的定义，我们了解了注解定义的过程，由于`@Test`内部没有定义其他元素，所以`@Test`也称为标记注解（marker annotation），但在自定义注解中，一般都会包含一些元素以表示某些值，方便处理器使用，这点在下面的例子将会看到：</span></pre></td></tr></table></figure>
/**
* Created by wuzejian on 2017/5/18.
* 对应数据表注解
*/
@Target(ElementType.TYPE)//只能应用于类上
@Retention(RetentionPolicy.RUNTIME)//保存到运行时
public @interface DBTable {
  String name() default &quot;&quot;;
}
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">上述定义一个名为`DBTable`的注解，该用于主要用于数据库表与`Bean`类的映射（稍后会有完整案例分析），与前面`Test`注解不同的是，我们声明一个String类型的`name`元素，其默认值为空字符，但是必须注意到对应任何元素的声明应采用方法的声明方式，同时可选择使用`default`提供默认值，`@DBTable`使用方式如下：</span></pre></td></tr></table></figure>
//在类上使用该注解
@DBTable(name = &quot;MEMBER&quot;)
public class Member {
  //.......
}
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">关于注解支持的元素数据类型除了上述的<span class="keyword">String</span>，还支持如下数据类型</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">- 所有基本类型（<span class="keyword">int</span>,<span class="keyword">float</span>,<span class="keyword">boolean</span>,<span class="keyword">byte</span>,<span class="keyword">double</span>,<span class="keyword">char</span>,<span class="keyword">long</span>,<span class="keyword">short</span>）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">- <span class="keyword">String</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">- Class</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">- <span class="keyword">enum</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">- Annotation</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">- 上述类型的数组</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">倘若使用了其他数据类型，编译器将会丢出一个编译错误，注意，声明注解元素时可以使用基本类型但不允许使用任何包装类型，同时还应该注意到注解也可以作为元素的类型，也就是嵌套注解，下面的代码演示了上述类型的使用过程：</span></pre></td></tr></table></figure>
package com.zejian.annotationdemo;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
* Created by wuzejian on 2017/5/19.
* 数据类型使用Demo
*/
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface Reference{
  boolean next() default false;
}
public @interface AnnotationElementDemo {
  //枚举类型
  enum Status {FIXED,NORMAL};
  //声明枚举
  Status status() default Status.FIXED;
  //布尔类型
  boolean showSupport() default false;
  //String类型
  String name() default &quot;&quot;;
  //class类型
  Class&lt;?&gt; testCase() default Void.class;
  //注解嵌套
  Reference reference() default @Reference(next=true);
  //数组类型
  long[] value();
}
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">## <span class="number">2.3</span> 编译器对默认值的限制</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">编译器对元素的默认值有些过分挑剔。首先，元素不能有不确定的值。也就是说，元素必须要么具有默认值，要么在使用注解时提供元素的值。其次，对于非基本类型的元素，无论是在源代码中声明，还是在注解接口中定义默认值，都不能以null作为值，这就是限制，没有什么利用可言，但造成一个元素的存在或缺失状态，因为每个注解的声明中，所有的元素都存在，并且都具有相应的值，为了绕开这个限制，只能定义一些特殊的值，例如空字符串或负数，表示某个元素不存在。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">## <span class="number">2.4</span> 注解不支持继承</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">注解是不支持继承的，因此不能使用关键字`extends`来继承某个`@interface`，但注解在编译后，编译器会自动继承`java.lang.annotation.Annotation`接口，这里我们反编译前面定义的`DBTable`注解</span></pre></td></tr></table></figure>
package com.zejian.annotationdemo;
import java.lang.annotation.Annotation;
//反编译后的代码
public interface DBTable extends Annotation
{
  public abstract String name();
}
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">虽然反编译后发现`DBTable`注解继承了`Annotation`接口，请记住，即使Java的接口可以实现多继承，但定义注解时依然无法使用`extends`关键字继承`@interface`。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">## <span class="number">2.5</span> 快捷方式</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">所谓的快捷方式就是注解中定义了名为`value`的元素，并且在使用该注解时，如果该元素是唯一需要赋值的一个元素，那么此时无需使用`key=value`的语法，而只需在括号内给出`value`元素所需的值即可。这可以应用于任何合法类型的元素，记住，这限制了元素名必须为`value`，简单案例如下</span></pre></td></tr></table></figure>
package com.zejian.annotationdemo;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
* Created by zejian on 2017/5/20.
* Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]
*/
//定义注解
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@interface IntegerVaule{
  int value() default 0;
  String name() default &quot;&quot;;
}
//使用注解
public class QuicklyWay {
  //当只想给value赋值时,可以使用以下快捷方式
  @IntegerVaule(20)
  public int age;
  //当name也需要赋值时必须采用key=value的方式赋值
  @IntegerVaule(value = 10000,name = &quot;MONEY&quot;)
  public int money;
}
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="section">## 2.6 Java内置注解与其它元注解</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">接着看看Java提供的内置注解，主要有3个，如下：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span><span class="code">`@Override`</span>：用于标明此方法覆盖了父类的方法，源码如下</span></pre></td></tr></table></figure>
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">- `@Deprecated`：用于标明已经过时的方法或类，源码如下，关于`@Documented`稍后分析：</span></pre></td></tr></table></figure>
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})
public @interface Deprecated {
}
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span><span class="code">`@SuppressWarnnings`</span>:用于有选择的关闭编译器对类、方法、成员变量、变量初始化的警告，其实现源码如下：</span></pre></td></tr></table></figure>
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
  String[] value();
}
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">其内部有一个<span class="keyword">String</span>数组，主要接收值如下：</span></pre></td></tr></table></figure>
deprecation：使用了不赞成使用的类或方法时的警告；
unchecked：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型;
fallthrough：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;
path：在类路径、源文件路径等中有不存在的路径时的警告;
serial：当在可序列化的类上缺少 serialVersionUID 定义时的警告;
finally：任何 finally 子句不能正常完成时的警告;
all：关于以上所有情况的警告。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">这个三个注解比较简单，看个简单案例即可：</span></pre></td></tr></table></figure>
//注明该类已过时，不建议使用
@Deprecated
class A{
  public void A(){ }
  //注明该方法已过时，不建议使用
  @Deprecated()
  public void B(){ }
}
class B extends A{
  @Override //标明覆盖父类A的A方法
  public void A() {
      super.A();
  }
  //去掉检测警告
  @SuppressWarnings({&quot;uncheck&quot;,&quot;deprecation&quot;})
  public void C(){ }
  //去掉检测警告
  @SuppressWarnings(&quot;uncheck&quot;)
  public void D(){ }
}
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">前面我们分析了两种元注解，`<span class="variable">@Target</span><span class="built_in">`和`</span><span class="variable">@Retention</span><span class="built_in">`，除了这两种元注解，Java还提供了另外两种元注解，`</span><span class="variable">@Documented</span><span class="built_in">`和`</span><span class="variable">@Inherited</span>`，下面分别介绍：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">- <span class="built_in">`@Documented`</span> 被修饰的注解会生成到javadoc中</span></pre></td></tr></table></figure>
/**
* Created by zejian on 2017/5/20.
* Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]
*/
@Documented
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface DocumentA {
}
//没有使用@Documented
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface DocumentB {
}
//使用注解
@DocumentA
@DocumentB
public class DocumentDemo {
  public void A(){
  }
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">使用javadoc命令生成文档：</span></pre></td></tr></table></figure>
zejian@zejiandeMBP annotationdemo$ javadoc DocumentDemo.java DocumentA.java DocumentB.java
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">如下：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">![<span class="string">img</span>](<span class="link">http://image.winrains.cn/2019/09/20190930173726-ea110.png</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">可以发现使用<span class="code">`@Documented`</span>元注解定义的注解(<span class="code">`@DocumentA`</span>)将会生成到javadoc中,而<span class="code">`@DocumentB`</span>则没有在doc文档中出现，这就是元注解<span class="code">`@Documented`</span>的作用。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span><span class="code">`@Inherited`</span> 可以让注解被继承，但这并不是真的继承，只是通过使用<span class="code">`@Inherited`</span>，可以让子类Class对象使用<span class="code">`getAnnotations()`</span>获取父类被<span class="code">`@Inherited`</span>修饰的注解，如下：</span></pre></td></tr></table></figure>
@Inherited
@Documented
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface DocumentA {
}
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface DocumentB {
}
@DocumentA
class A{ }
class B extends A{ }
@DocumentB
class C{ }
class D extends C{ }
//测试
public class DocumentDemo {
  public static void main(String... args){
      A instanceA=new B();
      System.out.println(&quot;已使用的@Inherited注解:&quot;+Arrays.toString(instanceA.getClass().getAnnotations()));
      C instanceC = new D();
      System.out.println(&quot;没有使用的@Inherited注解:&quot;+Arrays.toString(instanceC.getClass().getAnnotations()));
  }
  /**
   * 运行结果:
   已使用的@Inherited注解:[@com.zejian.annotationdemo.DocumentA()]
   没有使用的@Inherited注解:[]
   */
}
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"># <span class="number">3</span> 注解与反射机制</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">前面经过反编译后，我们知道Java所有注解都继承了`Annotation`接口，也就是说　Java使用`Annotation`接口代表注解元素，该接口是所有`Annotation`类型的父接口。同时为了运行时能准确获取到注解的相关信息，Java在`java.lang.reflect` 反射包下新增了`AnnotatedElement`接口，它主要用于表示目前正在 VM 中运行的程序中已使用注解的元素，通过该接口提供的方法可以利用反射技术地读取注解的信息，如反射包的`Constructor`类、`Field`类、`Method`类、`Package`类和`Class`类都实现了`AnnotatedElement`接口，它简要含义如下（更多详细介绍可以看 深入理解Java类型信息(`Class`对象)与反射机制）：</span></pre></td></tr></table></figure>
Class：类的Class对象定义 　
Constructor：代表类的构造器定义 　
Field：代表类的成员变量定义
Method：代表类的方法定义 　
Package：代表类的包定义
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">下面是`AnnotatedElement`中相关的API方法，以上<span class="number">5</span>个类都实现以下的方法</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">|         返回值         |                           方法名称                           |                             说明                             |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">| <span class="symbol">:--------------------</span>: | <span class="symbol">:----------------------------------------------------------</span>: | <span class="symbol">:----------------------------------------------------------</span>: |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">| &lt;A extends Annotation&gt; |           getAnnotation(Class&lt;A&gt; annotationClass)            | 该元素如果存在指定类型的注解，则返回这些注解，否则返回 null。 |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">|      Annotation[]      |                       getAnnotations()                       |         返回此元素上存在的所有注解，包括从父类继承的         |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">|        boolean         | isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) | 如果指定类型的注解存在于此元素上，则返回 <span class="keyword">true</span>，否则返回 <span class="keyword">false</span>。 |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">|      Annotation[]      |                   getDeclaredAnnotations()                   | 返回直接存在于此元素上的所有注解，注意，不包括父类的注解，调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响，没有则返回长度为0的数组 |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">简单案例演示如下：</span></pre></td></tr></table></figure>
package com.zejian.annotationdemo;
import java.lang.annotation.Annotation;
import java.util.Arrays;
/**
* Created by zejian on 2017/5/20.
* Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]
*/
@DocumentA
class A{ }
//继承了A类
@DocumentB
public class DocumentDemo extends A{
  public static void main(String... args){
      Class&lt;?&gt; clazz = DocumentDemo.class;
      //根据指定注解类型获取该注解
      DocumentA documentA=clazz.getAnnotation(DocumentA.class);
      System.out.println(&quot;A:&quot;+documentA);
      //获取该元素上的所有注解，包含从父类继承
      Annotation[] an= clazz.getAnnotations();
      System.out.println(&quot;an:&quot;+ Arrays.toString(an));
      //获取该元素上的所有注解，但不包含继承！
      Annotation[] an2=clazz.getDeclaredAnnotations();
      System.out.println(&quot;an2:&quot;+ Arrays.toString(an2));
      //判断注解DocumentA是否在该元素上
      boolean b=clazz.isAnnotationPresent(DocumentA.class);
      System.out.println(&quot;b:&quot;+b);
      /**
       * 执行结果:
       A:@com.zejian.annotationdemo.DocumentA()
       an:[@com.zejian.annotationdemo.DocumentA(), @com.zejian.annotationdemo.DocumentB()]
       an2:@com.zejian.annotationdemo.DocumentB()
       b:true
       */
  }
}
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta"># 4 运行时注解处理器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">了解完注解与反射的相关API后，现在通过一个实例（该例子是博主改编自《Tinking in Java》）来演示利用运行时注解来组装数据库SQL的构建语句的过程</span></pre></td></tr></table></figure>
/**
* Created by wuzejian on 2017/5/18.
* 表注解
*/
@Target(ElementType.TYPE)//只能应用于类上
@Retention(RetentionPolicy.RUNTIME)//保存到运行时
public @interface DBTable {
  String name() default &quot;&quot;;
}
/**
* Created by wuzejian on 2017/5/18.
* 注解Integer类型的字段
*/
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface SQLInteger {
  //该字段对应数据库表列名
  String name() default &quot;&quot;;
  //嵌套注解
  Constraints constraint() default @Constraints;
}
/**
* Created by wuzejian on 2017/5/18.
* 注解String类型的字段
*/
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface SQLString {
  //对应数据库表的列名
  String name() default &quot;&quot;;
  //列类型分配的长度，如varchar(30)的30
  int value() default 0;
  Constraints constraint() default @Constraints;
}
/**
* Created by wuzejian on 2017/5/18.
* 约束注解
*/
@Target(ElementType.FIELD)//只能应用在字段上
@Retention(RetentionPolicy.RUNTIME)
public @interface Constraints {
  //判断是否作为主键约束
  boolean primaryKey() default false;
  //判断是否允许为null
  boolean allowNull() default false;
  //判断是否唯一
  boolean unique() default false;
}
/**
* Created by wuzejian on 2017/5/18.
* 数据库表Member对应实例类bean
*/
@DBTable(name = &quot;MEMBER&quot;)
public class Member {
  //主键ID
  @SQLString(name = &quot;ID&quot;,value = 50, constraint = @Constraints(primaryKey = true))
  private String id;
  @SQLString(name = &quot;NAME&quot; , value = 30)
  private String name;
  @SQLInteger(name = &quot;AGE&quot;)
  private int age;
  @SQLString(name = &quot;DESCRIPTION&quot; ,value = 150 , constraint = @Constraints(allowNull = true))
  private String description;//个人描述
 //省略set get.....
}
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">上述定义<span class="number">4</span>个注解，分别是`@DBTable`(用于类上)、`@Constraints`(用于字段上)、 `@SQLString`(用于字段上)、`@SQLString`(用于字段上)并在`Member`类中使用这些注解，这些注解的作用的是用于帮助注解处理器生成创建数据库表`MEMBER`的构建语句，在这里有点需要注意的是，我们使用了嵌套注解`@Constraints`，该注解主要用于判断字段是否为null或者字段是否唯一。必须清楚认识到上述提供的注解生命周期必须为`@Retention(RetentionPolicy.RUNTIME)`，即运行时，这样才可以使用反射机制获取其信息。有了上述注解和使用，剩余的就是编写上述的注解处理器了，前面我们聊了很多注解，其处理器要么是Java自身已提供、要么是框架已提供的，我们自己都没有涉及到注解处理器的编写，但上述定义处理SQL的注解，其处理器必须由我们自己编写了，如下</span></pre></td></tr></table></figure>
package com.zejian.annotationdemo;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;
/**
* Created by zejian on 2017/5/13.
* Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]
* 运行时注解处理器，构造表创建语句
*/
public class TableCreator {
public static String createTableSql(String className) throws ClassNotFoundException {
  Class&lt;?&gt; cl = Class.forName(className);
  DBTable dbTable = cl.getAnnotation(DBTable.class);
  //如果没有表注解，直接返回
  if(dbTable == null) {
    System.out.println(
            &quot;No DBTable annotations in class &quot; + className);
    return null;
  }
  String tableName = dbTable.name();
  // If the name is empty, use the Class name:
  if(tableName.length() &lt; 1)
    tableName = cl.getName().toUpperCase();
  List&lt;String&gt; columnDefs = new ArrayList&lt;String&gt;();
  //通过Class类API获取到所有成员字段
  for(Field field : cl.getDeclaredFields()) {
    String columnName = null;
    //获取字段上的注解
    Annotation[] anns = field.getDeclaredAnnotations();
    if(anns.length &lt; 1)
      continue; // Not a db table column
    //判断注解类型
    if(anns[0] instanceof SQLInteger) {
      SQLInteger sInt = (SQLInteger) anns[0];
      //获取字段对应列名称，如果没有就是使用字段名称替代
      if(sInt.name().length() &lt; 1)
        columnName = field.getName().toUpperCase();
      else
        columnName = sInt.name();
      //构建语句
      columnDefs.add(columnName + &quot; INT&quot; +
              getConstraints(sInt.constraint()));
    }
    //判断String类型
    if(anns[0] instanceof SQLString) {
      SQLString sString = (SQLString) anns[0];
      // Use field name if name not specified.
      if(sString.name().length() &lt; 1)
        columnName = field.getName().toUpperCase();
      else
        columnName = sString.name();
      columnDefs.add(columnName + &quot; VARCHAR(&quot; +
              sString.value() + &quot;)&quot; +
              getConstraints(sString.constraint()));
    }
  }
  //数据库表构建语句
  StringBuilder createCommand = new StringBuilder(
          &quot;CREATE TABLE &quot; + tableName + &quot;(&quot;);
  for(String columnDef : columnDefs)
    createCommand.append(&quot;\n    &quot; + columnDef + &quot;,&quot;);
  // Remove trailing comma
  String tableCreate = createCommand.substring(
          0, createCommand.length() - 1) + &quot;);&quot;;
  return tableCreate;
}
  /**
   * 判断该字段是否有其他约束
   * @param con
   * @return
   */
private static String getConstraints(Constraints con) {
  String constraints = &quot;&quot;;
  if(!con.allowNull())
    constraints += &quot; NOT NULL&quot;;
  if(con.primaryKey())
    constraints += &quot; PRIMARY KEY&quot;;
  if(con.unique())
    constraints += &quot; UNIQUE&quot;;
  return constraints;
}
public static void main(String[] args) throws Exception {
  String[] arg={&quot;com.zejian.annotationdemo.Member&quot;};
  for(String className : arg) {
    System.out.println(&quot;Table Creation SQL for &quot; +
            className + &quot; is :\n&quot; + createTableSql(className));
  }
  /**
   * 输出结果：
   Table Creation SQL for com.zejian.annotationdemo.Member is :
   CREATE TABLE MEMBER(
   ID VARCHAR(50) NOT NULL PRIMARY KEY,
   NAME VARCHAR(30) NOT NULL,
   AGE INT NOT NULL,
   DESCRIPTION VARCHAR(150)
   );
   */
}
}
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">如果对反射比较熟悉的同学，上述代码就相对简单了，我们通过传递`Member`的全路径后通过`Class.forName()`方法获取到`Member`的`class`对象，然后利用`Class`对象中的方法获取所有成员字段`Field`，最后利用`field.getDeclaredAnnotations()`遍历每个`Field`上的注解再通过注解的类型判断来构建建表的SQL语句。这便是利用注解结合反射来构建SQL语句的简单的处理器模型，是否已回想起Hibernate？</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"># <span class="number">5</span> Java <span class="number">8</span>中注解增强</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">## <span class="number">5.1</span> 元注解@Repeatable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">元注解`@Repeatable`是JDK1.<span class="number">8</span>新加入的，它表示在同一个位置重复相同的注解。在没有该注解前，一般是无法在同一个类型上使用相同的注解的</span></pre></td></tr></table></figure>
//Java8前无法这样使用
@FilterPath(&quot;/web/update&quot;)
@FilterPath(&quot;/web/add&quot;)
public class A {}
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Java8前如果是想实现类似的功能，我们需要在定义`@FilterPath`注解时定义一个数组元素接收多个值如下</span></pre></td></tr></table></figure>
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface FilterPath {
  String [] value();
}
//使用
@FilterPath({&quot;/update&quot;,&quot;/add&quot;})
public class A { }
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">但在Java8新增了`@Repeatable`注解后就可以采用如下的方式定义并使用了</span></pre></td></tr></table></figure>
package com.zejian.annotationdemo;
import java.lang.annotation.*;
/**
* Created by zejian on 2017/5/20.
* Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]
*/
//使用Java8新增@Repeatable原注解
@Target({ElementType.TYPE,ElementType.FIELD,ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Repeatable(FilterPaths.class)//参数指明接收的注解class
public @interface FilterPath {
  String  value();
}
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface FilterPaths {
  FilterPath[] value();
}
//使用案例
@FilterPath(&quot;/web/update&quot;)
@FilterPath(&quot;/web/add&quot;)
@FilterPath(&quot;/web/delete&quot;)
class AA{ }
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">我们可以简单理解为通过使用`<span class="variable">@Repeatable</span><span class="built_in">`后，将使用`</span><span class="variable">@FilterPaths</span><span class="built_in">`注解作为接收同一个类型上重复注解的容器，而每个`</span><span class="variable">@FilterPath</span><span class="built_in">`则负责保存指定的路径串。为了处理上述的新增注解，Java8还在`</span>AnnotatedElement<span class="built_in">`接口新增了`</span>getDeclaredAnnotationsByType()<span class="built_in">` 和 `</span>getAnnotationsByType()<span class="built_in">`两个方法并在接口给出了默认实现，在指定`</span><span class="variable">@Repeatable</span><span class="built_in">`的注解时，可以通过这两个方法获取到注解相关信息。但请注意，旧版API中的`</span>getDeclaredAnnotation()<span class="built_in">`和 `</span>getAnnotation()<span class="built_in">`是不对`</span><span class="variable">@Repeatable</span><span class="built_in">`注解的处理的(除非该注解没有在同一个声明上重复出现)。注意`</span>getDeclaredAnnotationsByType<span class="built_in">`方法获取到的注解不包括父类，其实当 `</span>getAnnotationsByType()<span class="built_in">`方法调用时，其内部先执行了`</span>getDeclaredAnnotationsByType<span class="built_in">`方法，只有当前类不存在指定注解时，`</span>getAnnotationsByType()<span class="built_in">`才会继续从其父类寻找，但请注意如果`</span><span class="variable">@FilterPath</span><span class="built_in">`和`</span><span class="variable">@FilterPaths</span><span class="built_in">`没有使用了`</span><span class="variable">@Inherited</span>`的话，仍然无法获取。下面通过代码来演示：</span></pre></td></tr></table></figure>
/**
* Created by zejian on 2017/5/20.
* Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]
*/
//使用Java8新增@Repeatable原注解
@Target({ElementType.TYPE,ElementType.FIELD,ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Repeatable(FilterPaths.class)
public @interface FilterPath {
  String  value();
}
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface FilterPaths {
  FilterPath[] value();
}
@FilterPath(&quot;/web/list&quot;)
class CC { }
//使用案例
@FilterPath(&quot;/web/update&quot;)
@FilterPath(&quot;/web/add&quot;)
@FilterPath(&quot;/web/delete&quot;)
class AA extends CC{
  public static void main(String[] args) {
      Class&lt;?&gt; clazz = AA.class;
      //通过getAnnotationsByType方法获取所有重复注解
      FilterPath[] annotationsByType = clazz.getAnnotationsByType(FilterPath.class);
      FilterPath[] annotationsByType2 = clazz.getDeclaredAnnotationsByType(FilterPath.class);
      if (annotationsByType != null) {
          for (FilterPath filter : annotationsByType) {
              System.out.println(&quot;1:&quot;+filter.value());
          }
      }
      System.out.println(&quot;-----------------&quot;);
      if (annotationsByType2 != null) {
          for (FilterPath filter : annotationsByType2) {
              System.out.println(&quot;2:&quot;+filter.value());
          }
      }
      System.out.println(&quot;使用getAnnotation的结果:&quot;+clazz.getAnnotation(FilterPath.class));
      /**
       * 执行结果(当前类拥有该注解FilterPath,则不会从CC父类寻找)
       1:/web/update
       1:/web/add
       1:/web/delete
       -----------------
       2:/web/update
       2:/web/add
       2:/web/delete
       使用getAnnotation的结果:null
       */
  }
}
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">从执行结果来看如果当前类拥有该注解`<span class="variable">@FilterPath</span><span class="built_in">`,则`</span>getAnnotationsByType<span class="built_in">`方法不会从CC父类寻找，下面看看另外一种情况，即AA类上没有`</span><span class="variable">@FilterPath</span>`注解</span></pre></td></tr></table></figure>
/**
* Created by zejian on 2017/5/20.
* Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]
*/
//使用Java8新增@Repeatable原注解
@Target({ElementType.TYPE,ElementType.FIELD,ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited //添加可继承元注解
@Repeatable(FilterPaths.class)
public @interface FilterPath {
  String  value();
}
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Inherited //添加可继承元注解
@interface FilterPaths {
  FilterPath[] value();
}
@FilterPath(&quot;/web/list&quot;)
@FilterPath(&quot;/web/getList&quot;)
class CC { }
//AA上不使用@FilterPath注解,getAnnotationsByType将会从父类查询
class AA extends CC{
  public static void main(String[] args) {
      Class&lt;?&gt; clazz = AA.class;
      //通过getAnnotationsByType方法获取所有重复注解
      FilterPath[] annotationsByType = clazz.getAnnotationsByType(FilterPath.class);
      FilterPath[] annotationsByType2 = clazz.getDeclaredAnnotationsByType(FilterPath.class);
      if (annotationsByType != null) {
          for (FilterPath filter : annotationsByType) {
              System.out.println(&quot;1:&quot;+filter.value());
          }
      }
      System.out.println(&quot;-----------------&quot;);
      if (annotationsByType2 != null) {
          for (FilterPath filter : annotationsByType2) {
              System.out.println(&quot;2:&quot;+filter.value());
          }
      }
      System.out.println(&quot;使用getAnnotation的结果:&quot;+clazz.getAnnotation(FilterPath.class));
      /**
       * 执行结果(当前类没有@FilterPath,getAnnotationsByType方法从CC父类寻找)
       1:/web/list
       1:/web/getList
       -----------------
       使用getAnnotation的结果:null
       */
  }
}
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">注意定义`<span class="variable">@FilterPath</span><span class="built_in">`和`</span><span class="variable">@FilterPath</span><span class="built_in">`时必须指明`</span><span class="variable">@Inherited</span><span class="built_in">`，`</span>getAnnotationsByType<span class="built_in">`方法否则依旧无法从父类获取`</span><span class="variable">@FilterPath</span><span class="built_in">`注解，这是为什么呢，不妨看看`</span>getAnnotationsByType`方法的实现源码：</span></pre></td></tr></table></figure>
//接口默认实现方法
default &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass) {
//先调用getDeclaredAnnotationsByType方法
T[] result = getDeclaredAnnotationsByType(annotationClass);
//判断当前类获取到的注解数组是否为0
if (result.length == 0 &amp;&amp; this instanceof Class &amp;&amp;
//判断定义注解上是否使用了@Inherited元注解
AnnotationType.getInstance(annotationClass).isInherited()) { // Inheritable
      //从父类获取
     Class&lt;?&gt; superClass = ((Class&lt;?&gt;) this).getSuperclass();
 if (superClass != null) {
    result = superClass.getAnnotationsByType(annotationClass);
     }
 }
 return result;
}
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">## <span class="number">5.2</span> 新增的两种ElementType</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">在Java8中 `ElementType` 新增两个枚举成员，`TYPE_PARAMETER` 和 `TYPE_USE` ，在Java8前注解只能标注在一个声明(如字段、类、方法)上，Java8后，新增的`TYPE_PARAMETER`可以用于标注类型参数，而`TYPE_USE`则可以用于标注任意类型(不包括`class`)。如下所示</span></pre></td></tr></table></figure>
//TYPE_PARAMETER 标注在类型参数上
class D&lt;@Parameter T&gt; { }
//TYPE_USE则可以用于标注任意类型(不包括class)
//用于父类或者接口
class Image implements @Rectangular Shape { }
//用于构造函数
new @Path String(&quot;/usr/bin&quot;)
//用于强制转换和instanceof检查,注意这些注解中用于外部工具，它们不会对类型转换或者instanceof的检查行为带来任何影响。
String path=(@Path String)input;
if(input instanceof @Path String)
//用于指定异常
public Person read() throws @Localized IOException.
//用于通配符绑定
List&lt;@ReadOnly ? extends Person&gt;
List&lt;? extends @ReadOnly Person&gt;
@NotNull String.class //非法，不能标注class
import java.lang.@NotNull String //非法，不能标注import</code></pre></li>
</ul>
<p>这里主要说明一下<code>TYPE_USE</code>，类型注解用来支持在Java的程序中做强类型检查，配合第三方插件工具（如Checker Framework），可以在编译期检测出runtime error（如<code>UnsupportedOperationException</code>、<code>NullPointerException</code>异常），避免异常延续到运行期才发现，从而提高代码质量，这就是类型注解的主要作用。总之Java 8 新增加了两个注解的元素类型<code>ElementType.TYPE_USE</code> 和<code>ElementType.TYPE_PARAMETER</code> ，通过它们，我们可以把注解应用到各种新场合中。<br>ok~，关于注解暂且聊到这，实际上还有一个大块的知识点没详细聊到，源码级注解处理器，这个话题博主打算后面另开一篇分析。<br>主要参考资料 《Thinking in Java》</p>
<blockquote>
<p>作者：zejian_</p>
<p>来源：<a href="https://blog.csdn.net/javazejian/article/details/71860633" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/71860633</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%B3%A8%E8%A7%A3/" rel="tag"># 注解</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%B9%B6%E5%8F%91%E4%B9%8Bsynchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" rel="prev" title="深入理解Java并发之synchronized实现原理">
      <i class="fa fa-chevron-left"></i> 深入理解Java并发之synchronized实现原理
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/" rel="next" title="深入理解Java枚举类型">
      深入理解Java枚举类型 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-理解Java注解"><span class="nav-number">1.</span> <span class="nav-text">1 理解Java注解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-基本语法"><span class="nav-number">2.</span> <span class="nav-text">2 基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-声明注解与元注解"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 声明注解与元注解</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">winrains</p>
  <div class="site-description" itemprop="description">淡泊明志</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">469</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">82</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">108</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">winrains</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
