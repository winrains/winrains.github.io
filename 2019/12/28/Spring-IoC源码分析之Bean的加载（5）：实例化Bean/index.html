<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://congsheng.wang').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="上篇文章Spring Ioc源码分析 之 Bean的加载（四）：createBean()中我们分析了doCreateBean()方法的大致流程，这篇文章我们就详细分析下实例化 bean的createBeanInstance()方法，剩下的步骤将在其他文章中介绍。  简言：实例化Bean的本质其实就是找到一个合适的构造方法，然后通过构造方法调用newInstance()来实例化Bean。这样看起来">
<meta name="keywords" content="源码,IoC">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring IoC源码分析之Bean的加载（5）：实例化Bean">
<meta property="og:url" content="http:&#x2F;&#x2F;congsheng.wang&#x2F;2019&#x2F;12&#x2F;28&#x2F;Spring-IoC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BBean%E7%9A%84%E5%8A%A0%E8%BD%BD%EF%BC%885%EF%BC%89%EF%BC%9A%E5%AE%9E%E4%BE%8B%E5%8C%96Bean&#x2F;index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="上篇文章Spring Ioc源码分析 之 Bean的加载（四）：createBean()中我们分析了doCreateBean()方法的大致流程，这篇文章我们就详细分析下实例化 bean的createBeanInstance()方法，剩下的步骤将在其他文章中介绍。  简言：实例化Bean的本质其实就是找到一个合适的构造方法，然后通过构造方法调用newInstance()来实例化Bean。这样看起来">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191013114438-ab374.png">
<meta property="og:updated_time" content="2019-12-28T11:09:05.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191013114438-ab374.png">

<link rel="canonical" href="http://congsheng.wang/2019/12/28/Spring-IoC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BBean%E7%9A%84%E5%8A%A0%E8%BD%BD%EF%BC%885%EF%BC%89%EF%BC%9A%E5%AE%9E%E4%BE%8B%E5%8C%96Bean/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Spring IoC源码分析之Bean的加载（5）：实例化Bean | 个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">congsheng的博客</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">111</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">83</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">503</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://congsheng.wang/2019/12/28/Spring-IoC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BBean%E7%9A%84%E5%8A%A0%E8%BD%BD%EF%BC%885%EF%BC%89%EF%BC%9A%E5%AE%9E%E4%BE%8B%E5%8C%96Bean/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="congsheng.wang">
      <meta itemprop="description" content="trouble is a friend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring IoC源码分析之Bean的加载（5）：实例化Bean
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-28 19:09:05" itemprop="dateCreated datePublished" datetime="2019-12-28T19:09:05+08:00">2019-12-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">Spring技术</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring%E6%8A%80%E6%9C%AF/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>上篇文章<a href="https://juejin.im/post/5d73561fe51d4561b072dd7c" target="_blank" rel="noopener">Spring Ioc源码分析 之 Bean的加载（四）：createBean()</a>中我们分析了<code>doCreateBean()</code>方法的大致流程，这篇文章我们就详细分析下<strong>实例化 bean</strong>的<code>createBeanInstance()</code>方法，剩下的步骤将在其他文章中介绍。</p>
</blockquote>
<p><strong>简言：</strong><br>实例化Bean的本质其实就是找到一个合适的构造方法，然后通过构造方法调用<code>newInstance()</code>来实例化Bean。<br>这样看起来实例化Bean的过程很简单，但其实Spring花费了大量经历去寻找合适的构造方法。</p>
<a id="more"></a>

<h2 id="实例化-Bean"><a href="#实例化-Bean" class="headerlink" title="实例化 Bean"></a>实例化 Bean</h2><p>在<code>doCreateBean()</code>代码 &lt;2&gt; 处，有一行代码<code>instanceWrapper = createBeanInstance(beanName, mbd, args);</code><br>这段代码就是实例化Bean的过程。<br>我们追踪进去看一下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory.java</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Bean的实例对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">protected BeanWrapper create<span class="constructor">BeanInstance(String <span class="params">beanName</span>, RootBeanDefinition <span class="params">mbd</span>, @Nullable Object[] <span class="params">args</span>)</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Make sure bean class is actually resolved at this point.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 解析beanName 为 class</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    Class&lt;?&gt; beanClass = resolve<span class="constructor">BeanClass(<span class="params">mbd</span>, <span class="params">beanName</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 检查确认Bean是可实例化的</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (beanClass != null<span class="operator"> &amp;&amp; </span>!<span class="module-access"><span class="module"><span class="identifier">Modifier</span>.</span></span>is<span class="constructor">Public(<span class="params">beanClass</span>.<span class="params">getModifiers</span>()</span>)<span class="operator"> &amp;&amp; </span>!mbd.is<span class="constructor">NonPublicAccessAllowed()</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        throw <span class="keyword">new</span> <span class="constructor">BeanCreationException(<span class="params">mbd</span>.<span class="params">getResourceDescription</span>()</span>, beanName,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                <span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.get<span class="constructor">Name()</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 如果存在 Supplier 回调，则使用给定的回调方法初始化策略</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    Supplier&lt;?&gt; instanceSupplier = mbd.get<span class="constructor">InstanceSupplier()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (instanceSupplier != null) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        return obtain<span class="constructor">FromSupplier(<span class="params">instanceSupplier</span>, <span class="params">beanName</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 使用 FactoryBean 的 factory-method 来创建，支持静态工厂和实例工厂</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (mbd.get<span class="constructor">FactoryMethodName()</span> != null) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 调用工厂方法实例化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        return instantiate<span class="constructor">UsingFactoryMethod(<span class="params">beanName</span>, <span class="params">mbd</span>, <span class="params">args</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Shortcut when re-creating the same bean...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 构造函数自动注入进行实例化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    boolean resolved = <span class="literal">false</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    boolean autowireNecessary = <span class="literal">false</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (args<span class="operator"> == </span>null) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        synchronized (mbd.constructorArgumentLock) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != null) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 如果已缓存的解析的构造函数或者工厂方法不为空，则可以利用构造函数解析</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 因为需要根据参数确认到底使用哪个构造函数，该过程比较消耗性能，所有采用缓存机制</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                resolved = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">                autowireNecessary = mbd.constructorArgumentsResolved;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 如果已经解析过，不需要再次解析</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (resolved) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (autowireNecessary) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 构造函数自动注入进行实例化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 一个类有多个构造函数，每个构造函数都有不同的参数，所以需要根据参数锁定构造函数进行 bean 的实例化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">            return autowire<span class="constructor">Constructor(<span class="params">beanName</span>, <span class="params">mbd</span>, <span class="params">null</span>, <span class="params">null</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 使用默认的无参构造方法实例化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">            return instantiate<span class="constructor">Bean(<span class="params">beanName</span>, <span class="params">mbd</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Need to determine the constructor...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 需要根据参数解析构造函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">    Constructor&lt;?&gt;<span class="literal">[]</span> ctors = determine<span class="constructor">ConstructorsFromBeanPostProcessors(<span class="params">beanClass</span>, <span class="params">beanName</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (ctors != null<span class="operator"> || </span>mbd.get<span class="constructor">ResolvedAutowireMode()</span><span class="operator"> == </span>RootBeanDefinition.AUTOWIRE_CONSTRUCTOR</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"><span class="operator">            || </span>mbd.has<span class="constructor">ConstructorArgumentValues()</span><span class="operator"> || </span>!<span class="module-access"><span class="module"><span class="identifier">ObjectUtils</span>.</span></span>is<span class="constructor">Empty(<span class="params">args</span>)</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 使用容器的自动装配特性，调用匹配的构造方法实例化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">        return autowire<span class="constructor">Constructor(<span class="params">beanName</span>, <span class="params">mbd</span>, <span class="params">ctors</span>, <span class="params">args</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// No special handling: simply use no-arg constructor.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 使用默认的无参构造方法实例化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">    return instantiate<span class="constructor">Bean(<span class="params">beanName</span>, <span class="params">mbd</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这段代码中，Spring把Bean的实例话分为了4种方式：</p>
<ul>
<li>Supplier 回调</li>
<li>工厂方法初始化</li>
<li>构造函数自动注入初始化</li>
<li>默认无参构造方法初始化</li>
</ul>
<h3 id="1-1、-Supplier-回调"><a href="#1-1、-Supplier-回调" class="headerlink" title="1.1、 Supplier 回调"></a>1.1、 Supplier 回调</h3><p>如果存在 Supplier 回调，则调用 <code>obtainFromSupplier(Supplier instanceSupplier, String beanName)</code> 方法，进行初始化。<br>Supplier是一个接口，定义如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Supplier&lt;T&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    T <span class="builtin-name">get</span>();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个接口有什么作用？用于指定创建 bean 的回调。如果我们设置了这样的回调，那么其他的构造器或者工厂方法都会没有用<br>设置的地方在BeanDefinition的构造函数中，如：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// RootBeanDefinition.java</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; <span class="constructor">RootBeanDefinition(@Nullable Class&lt;T&gt; <span class="params">beanClass</span>, String <span class="params">scope</span>, @Nullable Supplier&lt;T&gt; <span class="params">instanceSupplier</span>)</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    super<span class="literal">()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    set<span class="constructor">BeanClass(<span class="params">beanClass</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    set<span class="constructor">Scope(<span class="params">scope</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 设置 instanceSupplier 属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    set<span class="constructor">InstanceSupplier(<span class="params">instanceSupplier</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="1-2、工厂方法初始化"><a href="#1-2、工厂方法初始化" class="headerlink" title="1.2、工厂方法初始化"></a>1.2、工厂方法初始化</h3><p>如果存在工厂方法，则使用工厂方法进行初始化。这部分代码非常长，很复杂，这里就不详细说了。</p>
<h3 id="1-3、构造函数自动注入初始化"><a href="#1-3、构造函数自动注入初始化" class="headerlink" title="1.3、构造函数自动注入初始化"></a>1.3、构造函数自动注入初始化</h3><p>首先判断缓存，如果缓存中存在（resolved==true），即已经解析过了，则直接使用已经解析了的。否则，先解析构造函数，然后通过构造函数自动注入初始化。</p>
<h4 id="1-3-1、autowireConstructor"><a href="#1-3-1、autowireConstructor" class="headerlink" title="1.3.1、autowireConstructor()"></a>1.3.1、autowireConstructor()</h4><p><code>autowireConstructor()</code> 这个初始化方法，我们可以简单理解为通过带有参数的构造方法，来初始化 Bean 对象。带有参数的实例化过程相当复杂，因为存在这不确定性，所以在判断对应参数上做了大量工作。<br>代码段如下：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractAutowireCapableBeanFactory.java</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanWrapper autowireConstructor(<span class="keyword">final</span> <span class="keyword">String</span> beanName, <span class="keyword">final</span> RootBeanDefinition mbd,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        @Nullable Constructor&lt;?&gt;[] chosenCtors, @Nullable <span class="keyword">final</span> <span class="keyword">Object</span>[] explicitArgs) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 封装 BeanWrapperImpl 对象，并完成初始化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    BeanWrapperImpl bw = <span class="keyword">new</span> BeanWrapperImpl();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.beanFactory.initBeanWrapper(bw);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    Constructor&lt;?&gt; constructorToUse = <span class="keyword">null</span>;<span class="comment">// 最终使用的构造函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    ArgumentsHolder argsHolderToUse = <span class="keyword">null</span>;<span class="comment">// 构造参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">Object</span>[] argsToUse = <span class="keyword">null</span>;<span class="comment">// 构造参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 判断有无显式指定参数,如果有则优先使用,如 xxxBeanFactory.getBean("teacher", "李华",3);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&lt;<span class="number">1</span>&gt; <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        argsToUse = explicitArgs;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 没有显式指定参数,则解析配置文件中的参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&lt;<span class="number">2</span>&gt; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">Object</span>[] argsToResolve = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 优先尝试从缓存中获取,spring对参数的解析过程是比较复杂也耗时的,所以这里先尝试从缓存中获取已经解析过的构造函数参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                        <span class="comment">//如果构造方法和参数都不为Null</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// Found a cached constructor...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 获取缓存中的构造参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                argsToUse = mbd.resolvedConstructorArguments;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (argsToUse == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">                    argsToResolve = mbd.preparedConstructorArguments;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 缓存中存在,则解析存储在 BeanDefinition 中的参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 如给定方法的构造函数 A(int ,int )，则通过此方法后就会把配置文件中的("1","1")转换为 (1,1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 缓存中的值可能是原始值也有可能是最终值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (argsToResolve != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">            argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 缓存不存在,则需要解析构造函数参数,以确定使用哪一个构造函数来进行实例化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">&lt;<span class="number">3</span>&gt; <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// Need to resolve the constructor.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">boolean</span> autowiring = (chosenCtors != <span class="keyword">null</span> ||</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">                mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 用于承载解析后的构造函数参数的值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        ConstructorArgumentValues resolvedValues = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//参数个数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">&lt;<span class="number">4</span>&gt;     <span class="built_in">int</span> minNrOfArgs;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">            minNrOfArgs = explicitArgs.length;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 从 BeanDefinition 中获取构造参数，也就是从配置文件中提取构造参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">            resolvedValues = <span class="keyword">new</span> ConstructorArgumentValues();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 能解析到的参数个数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// Take specified constructors, if any.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//使用指定的构造函数，如果有的话</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">&lt;<span class="number">5</span>&gt;     Constructor&lt;?&gt;[] candidates = chosenCtors;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//没有</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (candidates == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">            Class&lt;?&gt; beanClass = mbd.getBeanClass();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">//通过反射获取所有构造函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">                candidates = (mbd.isNonPublicAccessAllowed() ?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">                        beanClass.getDeclaredConstructors() : beanClass.getConstructors());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">                        <span class="string">"Resolution of declared constructors on bean Class ["</span> + beanClass.getName() +</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">                        <span class="string">"] from ClassLoader ["</span> + beanClass.getClassLoader() + <span class="string">"] failed"</span>, ex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 对所有构造函数进行排序,public 且 参数最多的构造函数会排在第一位</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">&lt;<span class="number">6</span>&gt;     AutowireUtils.sortConstructors(candidates);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">int</span> minTypeDiffWeight = Integer.MAX_VALUE;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//模棱两可的构造函数集合</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">        Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">        LinkedList&lt;UnsatisfiedDependencyException&gt; causes = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 迭代所有构造函数，解析确定使用哪一个构造函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">&lt;<span class="number">7</span>&gt;     <span class="keyword">for</span> (Constructor&lt;?&gt; candidate : candidates) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 获取该构造函数的参数类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">&lt;<span class="number">8</span>&gt;         Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 如果已经找到选用的构造函数或者需要的参数个数小于当前的构造函数参数个数，则终止。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 因为，已经按照参数个数降序排列了</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; argsToUse.length &gt; paramTypes.length) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// Already found greedy constructor that can be satisfied -&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// do not look any further, there are only less greedy constructors left.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 参数个数不等，跳过</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (paramTypes.length &lt; minNrOfArgs) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 参数持有者 ArgumentsHolder 对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line">            ArgumentsHolder argsHolder;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line">&lt;<span class="number">9</span>&gt;         <span class="keyword">if</span> (resolvedValues != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">98</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment">// 获取注解上的参数名称 by @ConstructorProperties</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">99</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">String</span>[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">100</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (paramNames == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">101</span></pre></td><td class="code"><pre><span class="line">                        ParameterNameDiscoverer pnd = <span class="keyword">this</span>.beanFactory.getParameterNameDiscoverer();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">102</span></pre></td><td class="code"><pre><span class="line">                        <span class="keyword">if</span> (pnd != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">103</span></pre></td><td class="code"><pre><span class="line">                            <span class="comment">// 获取指定构造函数的参数名称</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">104</span></pre></td><td class="code"><pre><span class="line">                            paramNames = pnd.getParameterNames(candidate);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">105</span></pre></td><td class="code"><pre><span class="line">                        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">106</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">107</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment">// 根据构造函数和构造参数，创建参数持有者 ArgumentsHolder 对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">108</span></pre></td><td class="code"><pre><span class="line">                    argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">109</span></pre></td><td class="code"><pre><span class="line">                            getUserDeclaredConstructor(candidate), autowiring);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">110</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">111</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">catch</span> (UnsatisfiedDependencyException ex) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">112</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.logger.isTraceEnabled()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">113</span></pre></td><td class="code"><pre><span class="line">                        <span class="keyword">this</span>.beanFactory.logger.trace(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">114</span></pre></td><td class="code"><pre><span class="line">                                <span class="string">"Ignoring constructor ["</span> + candidate + <span class="string">"] of bean '"</span> + beanName + <span class="string">"': "</span> + ex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">115</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">116</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment">// Swallow and try next constructor.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">117</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (causes == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">118</span></pre></td><td class="code"><pre><span class="line">                        causes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">119</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">120</span></pre></td><td class="code"><pre><span class="line">                    causes.<span class="built_in">add</span>(ex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">121</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">122</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">123</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">124</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">125</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// Explicit arguments given -&gt; arguments length must match exactly.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">126</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (paramTypes.length != explicitArgs.length) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">127</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">128</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">129</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 根据 getBean()传入的 explicitArgs ，创建 ArgumentsHolder 对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">130</span></pre></td><td class="code"><pre><span class="line">                argsHolder = <span class="keyword">new</span> ArgumentsHolder(explicitArgs);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">131</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">132</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//通过构造函数参数差异值对比,得出最适合使用的构造函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">133</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// isLenientConstructorResolution 判断解析构造函数的时候是否以宽松模式还是严格模式（默认宽松）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">134</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 严格模式：解析构造函数时，必须所有的都需要匹配，否则抛出异常</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">135</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 宽松模式：使用具有"最接近的模式"进行匹配</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">136</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">int</span> typeDiffWeight = (mbd.isLenientConstructorResolution() ?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">137</span></pre></td><td class="code"><pre><span class="line">                    argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">138</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Choose this constructor if it represents the closest match.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">139</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 如果它代表着当前最接近的匹配则选择其作为构造函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">140</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//差异值越小，越匹配，每次和分数最小的去比较</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">141</span></pre></td><td class="code"><pre><span class="line">&lt;<span class="number">10</span>&gt;            <span class="keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">142</span></pre></td><td class="code"><pre><span class="line">                constructorToUse = candidate;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">143</span></pre></td><td class="code"><pre><span class="line">                argsHolderToUse = argsHolder;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">144</span></pre></td><td class="code"><pre><span class="line">                argsToUse = argsHolder.arguments;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">145</span></pre></td><td class="code"><pre><span class="line">                minTypeDiffWeight = typeDiffWeight;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">146</span></pre></td><td class="code"><pre><span class="line">                ambiguousConstructors = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">147</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">148</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 如果两个构造方法与参数值类型列表之间的差异量一致，那么这两个方法都可以作为</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">149</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment">// 候选项，这个时候就出现歧义了，这里先把有歧义的构造方法放入ambiguousConstructors</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">150</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">151</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (ambiguousConstructors == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">152</span></pre></td><td class="code"><pre><span class="line">                    ambiguousConstructors = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">153</span></pre></td><td class="code"><pre><span class="line">                    ambiguousConstructors.<span class="built_in">add</span>(constructorToUse);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">154</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">155</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">//把候选构造函数 加入到 模棱两可的构造函数集合中</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">156</span></pre></td><td class="code"><pre><span class="line">                ambiguousConstructors.<span class="built_in">add</span>(candidate);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">157</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">158</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">159</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 没有可执行的构造方法，抛出异常</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">160</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">161</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (causes != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">162</span></pre></td><td class="code"><pre><span class="line">                UnsatisfiedDependencyException ex = causes.removeLast();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">163</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">for</span> (Exception cause : causes) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">164</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">this</span>.beanFactory.onSuppressedException(cause);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">165</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">166</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">throw</span> ex;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">167</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">168</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">169</span></pre></td><td class="code"><pre><span class="line">                    <span class="string">"Could not resolve matching constructor "</span> +</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">170</span></pre></td><td class="code"><pre><span class="line">                    <span class="string">"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">171</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">172</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//如果模棱两可的构造函数不为空，且为 严格模式，则抛异常</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">173</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ambiguousConstructors != <span class="keyword">null</span> &amp;&amp; !mbd.isLenientConstructorResolution()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">174</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">175</span></pre></td><td class="code"><pre><span class="line">                    <span class="string">"Ambiguous constructor matches found in bean '"</span> + beanName + <span class="string">"' "</span> +</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">176</span></pre></td><td class="code"><pre><span class="line">                    <span class="string">"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): "</span> +</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">177</span></pre></td><td class="code"><pre><span class="line">                    ambiguousConstructors);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">178</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">179</span></pre></td><td class="code"><pre><span class="line">                 <span class="comment">// 将解析的构造函数、参数 加入缓存</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">180</span></pre></td><td class="code"><pre><span class="line">&lt;<span class="number">11</span>&gt;        <span class="keyword">if</span> (explicitArgs == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">181</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">182</span></pre></td><td class="code"><pre><span class="line"><span class="comment">                     * 缓存相关信息，比如：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">183</span></pre></td><td class="code"><pre><span class="line"><span class="comment">                     *   1. 已解析出的构造方法对象 resolvedConstructorOrFactoryMethod</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">184</span></pre></td><td class="code"><pre><span class="line"><span class="comment">                     *   2. 构造方法参数列表是否已解析标志 constructorArgumentsResolved</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">185</span></pre></td><td class="code"><pre><span class="line"><span class="comment">                     *   3. 参数值列表 resolvedConstructorArguments 或 preparedConstructorArguments</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">186</span></pre></td><td class="code"><pre><span class="line"><span class="comment">                     *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">187</span></pre></td><td class="code"><pre><span class="line"><span class="comment">                     * 这些信息可用在其他地方，用于进行快捷判断</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">188</span></pre></td><td class="code"><pre><span class="line"><span class="comment">                     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">189</span></pre></td><td class="code"><pre><span class="line">            argsHolderToUse.storeCache(mbd, constructorToUse);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">190</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">191</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">192</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">193</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//获取Bean的初始化策略</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">194</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">final</span> InstantiationStrategy strategy = beanFactory.getInstantiationStrategy();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">195</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">Object</span> beanInstance;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">196</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//创建 Bean 对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">197</span></pre></td><td class="code"><pre><span class="line">&lt;<span class="number">12</span>&gt;        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">198</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; ctorToUse = constructorToUse;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">199</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">final</span> <span class="keyword">Object</span>[] argumentsToUse = argsToUse;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">200</span></pre></td><td class="code"><pre><span class="line">            beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;<span class="keyword">Object</span>&gt;) () -&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">201</span></pre></td><td class="code"><pre><span class="line">                    strategy.instantiate(mbd, beanName, beanFactory, ctorToUse, argumentsToUse),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">202</span></pre></td><td class="code"><pre><span class="line">                    beanFactory.getAccessControlContext());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">203</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">204</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">205</span></pre></td><td class="code"><pre><span class="line">            beanInstance = strategy.instantiate(mbd, beanName, <span class="keyword">this</span>.beanFactory, constructorToUse, argsToUse);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">206</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">207</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//设置到 bw 中</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">208</span></pre></td><td class="code"><pre><span class="line">        bw.setBeanInstance(beanInstance);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">209</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> bw;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">210</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">211</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">212</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">213</span></pre></td><td class="code"><pre><span class="line">                <span class="string">"Bean instantiation via constructor failed"</span>, ex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">214</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">215</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>代码很长，但不要慌，我们来一步步分析：</p>
<ul>
<li>&lt;1&gt;处，判断有无显式指定构造参数</li>
<li>&lt;2&gt;处，没有显式指定参数，则从缓存中获取</li>
<li>&lt;3&gt;处，缓存不存在,解析构造函数参数</li>
<li>&lt;4&gt;处，获取构造参数个数</li>
<li>&lt;5&gt;处，获取所有构造方法</li>
<li>&lt;6&gt;处，对所有构造方法排序</li>
<li>&lt;7&gt;处，遍历所有构造方法</li>
<li>&lt;8&gt;处，通过参数校验构造方法</li>
<li>&lt;9&gt;处，创建参数持有者 ArgumentsHolder</li>
<li>&lt;10&gt;处，筛选出符合的构造方法</li>
<li>&lt;11&gt;处，将解析的构造函数、参数 加入缓存</li>
<li>&lt;12&gt;处，实例化Bean对象</li>
</ul>
<h5 id="1-3-1-1、判断有无显式指定构造参数"><a href="#1-3-1-1、判断有无显式指定构造参数" class="headerlink" title="1.3.1.1、判断有无显式指定构造参数"></a>1.3.1.1、判断有无显式指定构造参数</h5><ul>
<li>explicitArgs<br><code>外部传入的指定构造参数</code></li>
<li>argsToUse<br><code>要使用的构造参数</code></li>
</ul>
<p>explicitArgs 是指外部传入的指定构造参数，例如<code>xxxBeanFactory.getBean(&quot;teacher&quot;, &quot;李华&quot;,3)</code>，（李华和3）就是传入的指定参数。<br>argsToUse 是我们实例化时要使用的构造参数，这里判断如果explicitArgs不为null的化，就把explicitArgs赋值给 argsToUse。</p>
<h5 id="1-3-1-2、没有显式指定参数，则从缓存中获取"><a href="#1-3-1-2、没有显式指定参数，则从缓存中获取" class="headerlink" title="1.3.1.2、没有显式指定参数，则从缓存中获取"></a>1.3.1.2、没有显式指定参数，则从缓存中获取</h5><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Object[] argsToResolve = <span class="built_in">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">synchronized</span> (mbd.constructorArgumentLock) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 优先尝试从缓存中获取,spring对参数的解析过程是比较复杂也耗时的,所以这里先尝试从缓存中获取已经解析过的构造函数参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//如果构造方法和参数都不为Null</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (constructorToUse != <span class="built_in">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// Found a cached constructor...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 获取缓存中的构造参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        argsToUse = mbd.resolvedConstructorArguments;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (argsToUse == <span class="built_in">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            argsToResolve = mbd.preparedConstructorArguments;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存中存在,则解析存储在 BeanDefinition 中的参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如给定方法的构造函数 A(int ,int )，则通过此方法后就会把配置文件中的("1","1")转换为 (1,1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存中的值可能是原始值也有可能是最终值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argsToResolve != <span class="built_in">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    argsToUse = <span class="built_in">resolvePreparedArguments</span>(beanName, mbd, bw, constructorToUse, argsToResolve);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>首先从缓存中<code>mbd.resolvedConstructorOrFactoryMethod</code>获取构造方法，如果缓存中存在构造方法和参数，就解析构造参数。<br>因为缓存中的构造参数不一定是最终值，如给定方法的构造函数 A(int ,int )，则通过此方法后就会把配置文件中的(“1”,”1”)转换为 (1,1)</p>
<h5 id="1-3-1-3、缓存不存在-解析构造函数参数"><a href="#1-3-1-3、缓存不存在-解析构造函数参数" class="headerlink" title="1.3.1.3、缓存不存在,解析构造函数参数"></a>1.3.1.3、缓存不存在,解析构造函数参数</h5><p>如果缓存不存在,则需要解析构造函数参数,以确定使用哪一个构造函数来进行实例化</p>
<h5 id="1-3-1-4、获取构造参数个数"><a href="#1-3-1-4、获取构造参数个数" class="headerlink" title="1.3.1.4、获取构造参数个数"></a>1.3.1.4、获取构造参数个数</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数个数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> minNrOfArgs;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (explicitArgs != null) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    minNrOfArgs = explicitArgs.length;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 从 BeanDefinition 中获取构造参数，也就是从配置文件中提取构造参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    ConstructorArgumentValues cargs = mbd.get<span class="constructor">ConstructorArgumentValues()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    resolvedValues = <span class="keyword">new</span> <span class="constructor">ConstructorArgumentValues()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 能解析到的参数个数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    minNrOfArgs = resolve<span class="constructor">ConstructorArguments(<span class="params">beanName</span>, <span class="params">mbd</span>, <span class="params">bw</span>, <span class="params">cargs</span>, <span class="params">resolvedValues</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li>如果explicitArgs不为null<br>则直接获取。</li>
<li>为null<br>需要解析保存在 BeanDefinition 构造函数中指定的参数<br>并获取能解析到的参数个数</li>
</ul>
<h5 id="1-3-1-5、获取所有构造方法"><a href="#1-3-1-5、获取所有构造方法" class="headerlink" title="1.3.1.5、获取所有构造方法"></a>1.3.1.5、获取所有构造方法</h5><p>先尝试获取指定的构造方法，如果没有，则利用反射获取所有构造方法</p>
<h5 id="1-3-1-6、对所有构造方法排序"><a href="#1-3-1-6、对所有构造方法排序" class="headerlink" title="1.3.1.6、对所有构造方法排序"></a>1.3.1.6、对所有构造方法排序</h5><p>排序的主要目的，是为了能够更加方便的找到最匹配的构造方法，因为构造方法的确认是根据参数个数确认的。排序的规则是：先按照 public / 非 public 构造方法升序，再按照构造参数数量降序。</p>
<h5 id="1-3-1-7、遍历所有构造方法"><a href="#1-3-1-7、遍历所有构造方法" class="headerlink" title="1.3.1.7、遍历所有构造方法"></a>1.3.1.7、遍历所有构造方法</h5><p>遍历所有构造方法，筛选出最匹配的一个</p>
<h5 id="1-3-1-8、通过参数校验构造方法"><a href="#1-3-1-8、通过参数校验构造方法" class="headerlink" title="1.3.1.8、通过参数校验构造方法"></a>1.3.1.8、通过参数校验构造方法</h5><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取该构造函数的参数类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">///这里的判断构造方法和构造方法参数 都不是空，又由于之前对构造方法做了排序。所以在使用的参数的个数已经大于当前构造方法的参数个数的时候，实际上已经取到了想要的构造方法。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (constructorToUse != <span class="built_in">null</span> &amp;&amp; argsToUse.length &gt; paramTypes.length) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Already found greedy constructor that can be satisfied -&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// do not look any further, there are only less greedy constructors left.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前的构造参数个数小于我们要求的个数，跳过</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (paramTypes.length &lt; minNrOfArgs) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这段代码也不复杂，第一个if是break分支，满足条件就跳出for循环，到这里就意为着找到了最匹配的构造方法。<br>EX： 假设现在有一组构造方法按照上面的排序规则进行排序，排序结果如下：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">public</span> Hello(<span class="built_in">Object</span>, <span class="built_in">Object</span>, <span class="built_in">Object</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span> <span class="keyword">public</span> Hello(<span class="built_in">Object</span>, <span class="built_in">Object</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span> <span class="keyword">public</span> Hello(<span class="built_in">Object</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="number">4.</span> <span class="keyword">protected</span> Hello(<span class="built_in">Integer</span>, <span class="built_in">Object</span>, <span class="built_in">Object</span>, <span class="built_in">Object</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="number">5.</span> <span class="keyword">protected</span> Hello(<span class="built_in">Integer</span>, <span class="built_in">Object</span>, <span class="built_in">Object</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="number">6.</span> <span class="keyword">protected</span> Hello(<span class="built_in">Integer</span>, <span class="built_in">Object</span>)</span></pre></td></tr></table></figure>

<p>由于是按降序排序的，所以会先去匹配构造方法1，发现 argsToUse.length &gt; paramTypes.length<br>第二个if是快速判断当前构造方法是否符合我们的要求。</p>
<ul>
<li>paramTypes<br>当前构造方法的参数个数</li>
<li>minNrOfArgs<br>我们要求的构造方法的参数个数 如果当前的构造参数个数小于我们要求的个数，说明当前构造方法不符合我们的要求，直接 continue</li>
</ul>
<h5 id="1-3-1-9、创建参数持有者-ArgumentsHolder"><a href="#1-3-1-9、创建参数持有者-ArgumentsHolder" class="headerlink" title="1.3.1.9、创建参数持有者 ArgumentsHolder"></a>1.3.1.9、创建参数持有者 ArgumentsHolder</h5><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数持有者 ArgumentsHolder 对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">ArgumentsHolder argsHolder;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (resolvedValues != <span class="literal">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 获取注解上的参数名称 by @ConstructorProperties</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">String</span>[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (paramNames == <span class="literal">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// ParameterNameDiscoverer 是用于解析方法和构造函数的参数名称的接口，为参数名称探测器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            ParameterNameDiscoverer pnd = <span class="built_in">this</span>.beanFactory.getParameterNameDiscoverer();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (pnd != <span class="literal">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 获取指定构造函数的参数名称</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                paramNames = pnd.getParameterNames(candidate);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 根据构造函数和构造参数，创建参数持有者 ArgumentsHolder 对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                getUserDeclaredConstructor(candidate), autowiring);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">catch</span> (UnsatisfiedDependencyException ex) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory.logger.isTraceEnabled()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">this</span>.beanFactory.logger.<span class="built_in">trace</span>(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                    <span class="string">"Ignoring constructor ["</span> + candidate + <span class="string">"] of bean '"</span> + beanName + <span class="string">"': "</span> + ex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// Swallow and try next constructor.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (causes == <span class="literal">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            causes = <span class="keyword">new</span> <span class="type">LinkedList</span>&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        causes.add(ex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Explicit arguments given -&gt; arguments length must match exactly.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (paramTypes.length != explicitArgs.length) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 根据 getBean()传入的 explicitArgs ，创建 ArgumentsHolder 对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    argsHolder = <span class="keyword">new</span> <span class="type">ArgumentsHolder</span>(explicitArgs);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里主要有两个逻辑：</p>
<ul>
<li>resolvedValues != null<br>即没有显示指定构造参数</li>
<li>resolvedValues == null<br>即显示指定了构造参数</li>
</ul>
<p>第一个分支：<br>先通过<code>@ConstructorProperties</code>注解获取构造参数名称，如果获取不到，再通过<code>ParameterNameDiscoverer</code>获取，最后创建 ArgumentsHolder<br>第二个分支：<br>直接使用显示传入的构造参数 explicitArgs 来 new 一个ArgumentsHolder<br>将参数包装成 <code>ArgumentsHolder</code> 对象。该对象用于保存参数，我们称之为参数持有者。在这个过程中再次解析构造参数，进行类型转换，如把配置文件中的string转换成需要的int。<br>当将对象包装成 ArgumentsHolder 对象后，我们就可以通过它来进行构造函数匹配。匹配分为严格模式和宽松模式：</p>
<ul>
<li>严格模式：解析构造函数时，必须所有参数都需要匹配，否则抛出异常。</li>
<li>宽松模式：从模棱两可的构造方法中，选择最接近的。<br>判断的依据是根据 BeanDefinition 的 <code>isLenientConstructorResolution</code> 属性（该参数是我们在构造 AbstractBeanDefinition 对象是传递的）来获取类型差异权重（typeDiffWeight） 的。</li>
</ul>
<h5 id="1-3-1-10、筛选出符合的构造方法"><a href="#1-3-1-10、筛选出符合的构造方法" class="headerlink" title="1.3.1.10、筛选出符合的构造方法"></a>1.3.1.10、筛选出符合的构造方法</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过构造函数参数差异值对比,得出最适合使用的构造函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// isLenientConstructorResolution 判断解析构造函数的时候是否以宽松模式还是严格模式（默认宽松）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 严格模式：解析构造函数时，必须所有的都需要匹配，否则抛出异常</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宽松模式：使用具有"最接近的模式"进行匹配</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> typeDiffWeight = (mbd.is<span class="constructor">LenientConstructorResolution()</span> ?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        argsHolder.get<span class="constructor">TypeDifferenceWeight(<span class="params">paramTypes</span>)</span> : argsHolder.get<span class="constructor">AssignabilityWeight(<span class="params">paramTypes</span>)</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Choose this constructor if it represents the closest match.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果它代表着当前最接近的匹配则选择其作为构造函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//差异值越小，越匹配，每次和分数最小的去比较</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    constructorToUse = candidate;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    argsHolderToUse = argsHolder;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    argsToUse = argsHolder.arguments;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    minTypeDiffWeight = typeDiffWeight;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    ambiguousConstructors = null;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果两个构造方法与参数值类型列表之间的差异量一致，那么这两个方法都可以作为</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 候选项，这个时候就出现歧义了，这里先把有歧义的构造方法放入ambiguousConstructors</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (constructorToUse != null<span class="operator"> &amp;&amp; </span>typeDiffWeight<span class="operator"> == </span>minTypeDiffWeight) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (ambiguousConstructors<span class="operator"> == </span>null) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        ambiguousConstructors = <span class="keyword">new</span> LinkedHashSet&lt;&gt;<span class="literal">()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        ambiguousConstructors.add(constructorToUse);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//把候选构造函数 加入到 模棱两可的构造函数集合中</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    ambiguousConstructors.add(candidate);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有可执行的构造方法，抛出异常</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (constructorToUse<span class="operator"> == </span>null) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (causes != null) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    UnsatisfiedDependencyException ex = causes.remove<span class="constructor">Last()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    for (Exception cause : causes) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        this.beanFactory.on<span class="constructor">SuppressedException(<span class="params">cause</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    throw ex;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">throw <span class="keyword">new</span> <span class="constructor">BeanCreationException(<span class="params">mbd</span>.<span class="params">getResourceDescription</span>()</span>, beanName,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"Could not resolve matching constructor "</span> +</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果模棱两可的构造函数不为空，且为 严格模式，则抛异常</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ambiguousConstructors != null<span class="operator"> &amp;&amp; </span>mbd.is<span class="constructor">LenientConstructorResolution()</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">throw <span class="keyword">new</span> <span class="constructor">BeanCreationException(<span class="params">mbd</span>.<span class="params">getResourceDescription</span>()</span>, beanName,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"Ambiguous constructor matches found in bean '"</span> + beanName + <span class="string">"' "</span> +</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): "</span> +</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">        ambiguousConstructors);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>先通过计算得出当前构造方法的差异值<code>typeDiffWeight</code>,每次和分数最小的去比较，筛选出差异值最小的，最终比较出一个最匹配的构造方法。<br>差异值大于最小差异值的，加入到候选集合<code>ambiguousConstructors</code>，我称之为模棱两可的构造方法，该集合在《宽松模式》下使用。<br>至此，所有构造方法都遍历完毕。如果仍没有筛选出构造方法，抛出异常。<br>如果模棱两可的构造方法不为空，但模式为 严格模式，则抛异常。</p>
<h5 id="1-3-1-11、将解析的构造函数、参数-加入缓存"><a href="#1-3-1-11、将解析的构造函数、参数-加入缓存" class="headerlink" title="1.3.1.11、将解析的构造函数、参数 加入缓存"></a>1.3.1.11、将解析的构造函数、参数 加入缓存</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">// 将解析的构造函数、参数 加入缓存</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">if (explicitArgs == null) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="code">    /*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="bullet">     * </span>缓存相关信息，比如：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="bullet">     *   </span>1. 已解析出的构造方法对象 resolvedConstructorOrFactoryMethod</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="bullet">     *   </span>2. 构造方法参数列表是否已解析标志 constructorArgumentsResolved</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="bullet">     *   </span>3. 参数值列表 resolvedConstructorArguments 或 preparedConstructorArguments</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="code">     *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="bullet">     * </span>这些信息可用在其他地方，用于进行快捷判断</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="code">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="code">    argsHolderToUse.storeCache(mbd, constructorToUse);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>继续追踪：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArgumentsHolder.java</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">Object</span> rawArguments[];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">Object</span> arguments[];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">Object</span> preparedArguments[];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> storeCache(RootBeanDefinition mbd, Executable constructorOrFactoryMethod) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        mbd.resolvedConstructorOrFactoryMethod = constructorOrFactoryMethod;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        mbd.constructorArgumentsResolved = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.resolveNecessary) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            mbd.preparedConstructorArguments = <span class="keyword">this</span>.preparedArguments;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            mbd.resolvedConstructorArguments = <span class="keyword">this</span>.arguments;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>相信大家看到这里应该对<code>resolvedConstructorOrFactoryMethod</code> 和 <code>resolvedConstructorArguments</code>等这几个参数很熟悉。<br>正如你所想，在前面判断缓存中是否存在的时候，就是通过这几个参数来判断的。</p>
<h5 id="1-3-1-12、实例化Bean对象"><a href="#1-3-1-12、实例化Bean对象" class="headerlink" title="1.3.1.12、实例化Bean对象"></a>1.3.1.12、实例化Bean对象</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleInstantiationStrategy.java</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        final Constructor&lt;?&gt; ctor, @Nullable Object... args) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 没有方法覆盖，直接使用反射实例化即可</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!bd.has<span class="constructor">MethodOverrides()</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>get<span class="constructor">SecurityManager()</span> != null) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// use own privileged to change accessibility (when security is on)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 设置构造方法，可访问</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="module-access"><span class="module"><span class="identifier">AccessController</span>.</span></span><span class="keyword">do</span><span class="constructor">Privileged((PrivilegedAction&lt;Object&gt;)</span> <span class="literal">()</span> -&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                <span class="module-access"><span class="module"><span class="identifier">ReflectionUtils</span>.</span></span>make<span class="constructor">Accessible(<span class="params">ctor</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                return null;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 通过 BeanUtils 直接使用构造函数实例化 Bean 对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        return (args != null ? <span class="module-access"><span class="module"><span class="identifier">BeanUtils</span>.</span></span>instantiate<span class="constructor">Class(<span class="params">ctor</span>, <span class="params">args</span>)</span> : <span class="module-access"><span class="module"><span class="identifier">BeanUtils</span>.</span></span>instantiate<span class="constructor">Class(<span class="params">ctor</span>)</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 使用 CGLIB 创建代理对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 方法覆盖，在调用目标方法的时候，对调用过程进行拦截，调用实现增强功能的拦截器，返回原来实例的代理</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 所以要用cglib动态代理</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        return instantiate<span class="constructor">WithMethodInjection(<span class="params">bd</span>, <span class="params">beanName</span>, <span class="params">owner</span>, <span class="params">ctor</span>, <span class="params">args</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>BeanUtils.instantiateClass(ctor, args)</strong></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; T instantiate<span class="constructor">Class(Constructor&lt;T&gt; <span class="params">ctor</span>, Object<span class="operator">...</span> <span class="params">args</span>)</span> throws BeanInstantiationException &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Assert</span>.</span></span>not<span class="constructor">Null(<span class="params">ctor</span>, <span class="string">"Constructor must not be null"</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 设置构造方法，可访问</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">ReflectionUtils</span>.</span></span>make<span class="constructor">Accessible(<span class="params">ctor</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 使用构造方法，创建对象 newInstance</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        return (<span class="module-access"><span class="module"><span class="identifier">KotlinDetector</span>.</span></span>is<span class="constructor">KotlinType(<span class="params">ctor</span>.<span class="params">getDeclaringClass</span>()</span>) ?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                <span class="module-access"><span class="module"><span class="identifier">KotlinDelegate</span>.</span></span>instantiate<span class="constructor">Class(<span class="params">ctor</span>, <span class="params">args</span>)</span> : ctor.<span class="keyword">new</span><span class="constructor">Instance(<span class="params">args</span>)</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    catch (InstantiationException ex) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        throw <span class="keyword">new</span> <span class="constructor">BeanInstantiationException(<span class="params">ctor</span>, <span class="string">"Is it an abstract class?"</span>, <span class="params">ex</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    catch (IllegalAccessException ex) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        throw <span class="keyword">new</span> <span class="constructor">BeanInstantiationException(<span class="params">ctor</span>, <span class="string">"Is the constructor accessible?"</span>, <span class="params">ex</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    catch (IllegalArgumentException ex) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        throw <span class="keyword">new</span> <span class="constructor">BeanInstantiationException(<span class="params">ctor</span>, <span class="string">"Illegal arguments for constructor"</span>, <span class="params">ex</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    catch (InvocationTargetException ex) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        throw <span class="keyword">new</span> <span class="constructor">BeanInstantiationException(<span class="params">ctor</span>, <span class="string">"Constructor threw exception"</span>, <span class="params">ex</span>.<span class="params">getTargetException</span>()</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="1-3-2、图解流程"><a href="#1-3-2、图解流程" class="headerlink" title="1.3.2、图解流程"></a>1.3.2、图解流程</h4><p>因为这段代码还是挺复杂的，所以我画了一个（explicitArgs=null）的分支流程图，便于理解。</p>
<p><img src="http://image.winrains.cn/2019/10/20191013114438-ab374.png" alt="img"></p>
<h3 id="1-3、默认无参构造方法初始化"><a href="#1-3、默认无参构造方法初始化" class="headerlink" title="1.3、默认无参构造方法初始化"></a>1.3、默认无参构造方法初始化</h3><p>经过有参构造方法初始化源码的摧残之后，再来看无参的源码，会发现简单多了。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">return instantiate<span class="constructor">Bean(<span class="params">beanName</span>, <span class="params">mbd</span>)</span>;</span></pre></td></tr></table></figure>

<p>继续追踪：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认的无参构造方法实例化Bean对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> BeanWrapper instantiateBean(<span class="keyword">final</span> <span class="keyword">String</span> beanName, <span class="keyword">final</span> RootBeanDefinition mbd) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">Object</span> beanInstance;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 获取系统的安全管理接口，JDK标准的安全管理API</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 这里是一个匿名内置类，根据实例化策略创建实例对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            beanInstance = AccessController.doPrivileged(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                    (PrivilegedAction&lt;<span class="keyword">Object</span>&gt;) () -&gt; getInstantiationStrategy().instantiate(mbd, beanName, parent),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                    getAccessControlContext());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 将实例化的对象封装起来</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        initBeanWrapper(bw);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> bw;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Instantiation of bean failed"</span>, ex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>看过有参构造方法初始化的源码之后，再看看无参的，发现代码真的简单太多了，没有复杂的确定构造参数、构造方法的逻辑。<br><strong>instantiate(mbd, beanName, parent)</strong></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleInstantiationStrategy.java</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用初始化策略实例化Bean对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Don't override the class with CGLIB if no overrides.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 没有覆盖，直接使用反射实例化即可</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        Constructor&lt;?&gt; constructorToUse;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 从缓存中获取对象的构造方法或工厂方法</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 缓存没有</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 使用JDK的反射机制，判断要实例化的Bean是否是接口</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (clazz.isInterface()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"Specified class is an interface"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">                        <span class="comment">// 这里是一个匿名内置类，使用反射机制获取Bean的构造方法</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                        constructorToUse = AccessController.doPrivileged(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                                (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) () -&gt; clazz.getDeclaredConstructor());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                        constructorToUse = clazz.getDeclaredConstructor();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                    bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"No default constructor found"</span>, ex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 使用BeanUtils实例化，通过反射机制调用”构造方法.newInstance(arg)”来进行实例化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">return</span> BeanUtils.<span class="title">instantiateClass</span><span class="params">(constructorToUse)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// Must generate CGLIB subclass.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 有方法覆盖，使用CGLIB来实例化对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 方法覆盖，在调用目标方法的时候，对调用过程进行拦截，调用实现增强功能的拦截器，返回原来实例的代理</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 所以要用cglib动态代理</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">instantiateWithMethodInjection</span><span class="params">(bd, beanName, owner)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>很简单的几个步骤：</p>
<ul>
<li>判断有无方法覆盖</li>
<li>尝试从缓存中获取构造方法</li>
<li>校验bean是否为interface</li>
<li>利用反射获取默认构造方法</li>
<li>利用BeanUtils实例化</li>
</ul>
<p><strong>BeanUtils.instantiateClass(constructorToUse)</strong></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; T instantiate<span class="constructor">Class(Constructor&lt;T&gt; <span class="params">ctor</span>, Object<span class="operator">...</span> <span class="params">args</span>)</span> throws BeanInstantiationException &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Assert</span>.</span></span>not<span class="constructor">Null(<span class="params">ctor</span>, <span class="string">"Constructor must not be null"</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 设置构造方法，可访问</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="module-access"><span class="module"><span class="identifier">ReflectionUtils</span>.</span></span>make<span class="constructor">Accessible(<span class="params">ctor</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 使用构造方法，创建对象 newInstance</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        return (<span class="module-access"><span class="module"><span class="identifier">KotlinDetector</span>.</span></span>is<span class="constructor">KotlinType(<span class="params">ctor</span>.<span class="params">getDeclaringClass</span>()</span>) ? <span class="module-access"><span class="module"><span class="identifier">KotlinDelegate</span>.</span></span>instantiate<span class="constructor">Class(<span class="params">ctor</span>, <span class="params">args</span>)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                : ctor.<span class="keyword">new</span><span class="constructor">Instance(<span class="params">args</span>)</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125; catch (InstantiationException ex) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        throw <span class="keyword">new</span> <span class="constructor">BeanInstantiationException(<span class="params">ctor</span>, <span class="string">"Is it an abstract class?"</span>, <span class="params">ex</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125; catch (IllegalAccessException ex) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        throw <span class="keyword">new</span> <span class="constructor">BeanInstantiationException(<span class="params">ctor</span>, <span class="string">"Is the constructor accessible?"</span>, <span class="params">ex</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125; catch (IllegalArgumentException ex) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        throw <span class="keyword">new</span> <span class="constructor">BeanInstantiationException(<span class="params">ctor</span>, <span class="string">"Illegal arguments for constructor"</span>, <span class="params">ex</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125; catch (InvocationTargetException ex) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        throw <span class="keyword">new</span> <span class="constructor">BeanInstantiationException(<span class="params">ctor</span>, <span class="string">"Constructor threw exception"</span>, <span class="params">ex</span>.<span class="params">getTargetException</span>()</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>先设置强吻访问，然后<code>newInstance()</code>创建对象。</p>
<blockquote>
<p>总结</p>
</blockquote>
<p>对于 <code>createBeanInstance()</code> 方法而言，他就是选择合适实例化策略来为 bean 创建实例对象，具体的策略有：</p>
<ul>
<li>Supplier 回调方式</li>
<li>工厂方法初始化</li>
<li>构造函数自动注入初始化</li>
<li>默认构造函数注入。</li>
</ul>
<p>其中，工厂方法初始化和构造函数自动注入初始化两种方式最为复杂，主要是因为构造函数和构造参数的不确定性，Spring 需要花大量的精力来确定构造函数和构造参数，如果确定了则好办，直接选择实例化策略即可。<br>当然，在实例化的时候会根据是否有需要覆盖或者动态替换掉的方法，因为存在覆盖或者织入的话需要创建动态代理将方法织入，这个时候就只能选择 CGLIB 的方式来实例化，否则直接利用反射的方式即可，方便快捷。<br><strong>最后：</strong><br>到这里实例化Bean的代码就分析完了，这部分源码看起来还是有难度的，看的我头发的慌了，写的也挺累的，但还是会继续写下去，会发现当你研究懂一段源码之后，那种成就感真的很爽0.0<br>下篇将分析第4个过程：循环依赖的处理。其实，循环依赖并不仅仅只是在 #doCreateBean(…) 方法中处理，在整个加载 bean 的过程中都有涉及。所以下篇内容并不仅仅只局限于 #doCreateBean(…) 方法。<br><strong>PS：</strong> 码字不易，希望大家多多点赞哈，给小弟点动力T.T<br>参考：公众号-芋道源码</p>
<blockquote>
<p>作者：大王叫下</p>
<p>来源：<a href="https://juejin.im/post/5d760049f265da03cc08e267" target="_blank" rel="noopener">https://juejin.im/post/5d760049f265da03cc08e267</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%BA%90%E7%A0%81/" rel="tag"># 源码</a>
              <a href="/tags/IoC/" rel="tag"># IoC</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/28/Spring-IoC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BBean%E7%9A%84%E5%8A%A0%E8%BD%BD%EF%BC%884%EF%BC%89%EF%BC%9AcreateBean/" rel="prev" title="Spring IoC源码分析之Bean的加载（4）：createBean()">
      <i class="fa fa-chevron-left"></i> Spring IoC源码分析之Bean的加载（4）：createBean()
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/28/Spring-IoC-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3-%EF%BC%881%EF%BC%89/" rel="next" title="Spring IoC 源码分析 (基于注解) （1）">
      Spring IoC 源码分析 (基于注解) （1） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#实例化-Bean"><span class="nav-number">1.</span> <span class="nav-text">实例化 Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1、-Supplier-回调"><span class="nav-number">1.1.</span> <span class="nav-text">1.1、 Supplier 回调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2、工厂方法初始化"><span class="nav-number">1.2.</span> <span class="nav-text">1.2、工厂方法初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3、构造函数自动注入初始化"><span class="nav-number">1.3.</span> <span class="nav-text">1.3、构造函数自动注入初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1、autowireConstructor"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.3.1、autowireConstructor()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-1-1、判断有无显式指定构造参数"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">1.3.1.1、判断有无显式指定构造参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-1-2、没有显式指定参数，则从缓存中获取"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">1.3.1.2、没有显式指定参数，则从缓存中获取</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-1-3、缓存不存在-解析构造函数参数"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">1.3.1.3、缓存不存在,解析构造函数参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-1-4、获取构造参数个数"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">1.3.1.4、获取构造参数个数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-1-5、获取所有构造方法"><span class="nav-number">1.3.1.5.</span> <span class="nav-text">1.3.1.5、获取所有构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-1-6、对所有构造方法排序"><span class="nav-number">1.3.1.6.</span> <span class="nav-text">1.3.1.6、对所有构造方法排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-1-7、遍历所有构造方法"><span class="nav-number">1.3.1.7.</span> <span class="nav-text">1.3.1.7、遍历所有构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-1-8、通过参数校验构造方法"><span class="nav-number">1.3.1.8.</span> <span class="nav-text">1.3.1.8、通过参数校验构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-1-9、创建参数持有者-ArgumentsHolder"><span class="nav-number">1.3.1.9.</span> <span class="nav-text">1.3.1.9、创建参数持有者 ArgumentsHolder</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-1-10、筛选出符合的构造方法"><span class="nav-number">1.3.1.10.</span> <span class="nav-text">1.3.1.10、筛选出符合的构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-1-11、将解析的构造函数、参数-加入缓存"><span class="nav-number">1.3.1.11.</span> <span class="nav-text">1.3.1.11、将解析的构造函数、参数 加入缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-1-12、实例化Bean对象"><span class="nav-number">1.3.1.12.</span> <span class="nav-text">1.3.1.12、实例化Bean对象</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2、图解流程"><span class="nav-number">1.3.2.</span> <span class="nav-text">1.3.2、图解流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3、默认无参构造方法初始化"><span class="nav-number">1.4.</span> <span class="nav-text">1.3、默认无参构造方法初始化</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">congsheng.wang</p>
  <div class="site-description" itemprop="description">trouble is a friend</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">503</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">83</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">111</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">congsheng.wang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
