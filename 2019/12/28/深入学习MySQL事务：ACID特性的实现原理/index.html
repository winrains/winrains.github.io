<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://congsheng.wang').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="事务是MySQL等关系型数据库区别于NoSQL的重要方面，是保证数据一致性的重要手段。本文将首先介绍**MySQL事务相关的基础概念，然后介绍事务的ACID特性，并分析其实现原理。**MySQL博大精深，文章疏漏之处在所难免，欢迎批评指正。">
<meta name="keywords" content="事务">
<meta property="og:type" content="article">
<meta property="og:title" content="深入学习MySQL事务：ACID特性的实现原理">
<meta property="og:url" content="http:&#x2F;&#x2F;congsheng.wang&#x2F;2019&#x2F;12&#x2F;28&#x2F;%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0MySQL%E4%BA%8B%E5%8A%A1%EF%BC%9AACID%E7%89%B9%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86&#x2F;index.html">
<meta property="og:site_name" content="congsheng的博客">
<meta property="og:description" content="事务是MySQL等关系型数据库区别于NoSQL的重要方面，是保证数据一致性的重要手段。本文将首先介绍**MySQL事务相关的基础概念，然后介绍事务的ACID特性，并分析其实现原理。**MySQL博大精深，文章疏漏之处在所难免，欢迎批评指正。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;c899b-1174710-20190128200647649-2138221098.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;87ecb-1174710-20190128200732629-417401931.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;f0c93-1174710-20190128200751635-466164258.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;c67a0-1174710-20190128200929607-1639664811.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;197e2-1174710-20190128200936671-1683619195.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;e5492-1174710-20190128201003630-2050662608.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;daf6c-1174710-20190128201011603-1317894910.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;ba72e-1174710-20190128201021606-1089980279.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;851b2-1174710-20190128201034603-681355962.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;9e41c-1174710-20190128201103652-719570401.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;ecff9-1174710-20190128201111615-210490190.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;4a58c-1174710-20190128201126604-235257040.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;f2895-1174710-20190128201139635-1779107964.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;b93a6-1174710-20190128201149661-1275460669.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;3f10d-1174710-20190128201206609-1998192060.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;41936-1174710-20190128201219610-1942897077.png">
<meta property="og:updated_time" content="2019-12-28T11:02:16.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;c899b-1174710-20190128200647649-2138221098.png">

<link rel="canonical" href="http://congsheng.wang/2019/12/28/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0MySQL%E4%BA%8B%E5%8A%A1%EF%BC%9AACID%E7%89%B9%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>深入学习MySQL事务：ACID特性的实现原理 | congsheng的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">congsheng的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">欢迎访问：winrains.cn</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">156</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">94</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">984</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://congsheng.wang/2019/12/28/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0MySQL%E4%BA%8B%E5%8A%A1%EF%BC%9AACID%E7%89%B9%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="congsheng.wang">
      <meta itemprop="description" content="trouble is a friend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="congsheng的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入学习MySQL事务：ACID特性的实现原理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-28 19:02:16" itemprop="dateCreated datePublished" datetime="2019-12-28T19:02:16+08:00">2019-12-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>事务是MySQL等关系型数据库区别于NoSQL的重要方面，是保证数据一致性的重要手段。<strong>本文将首先介绍**</strong>MySQL<strong><strong>事务相关的基础概念，然后介绍事务的ACID</strong></strong>特性，并分析其实现原理。**<br>MySQL博大精深，文章疏漏之处在所难免，欢迎批评指正。</p>
<a id="more"></a>

<h1 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h1><p>事务（Transaction）是访问和更新数据库的程序执行单元；事务中可能包含一个或多个sql语句，这些语句要么都执行，要么都不执行。作为一个关系型数据库，MySQL支持事务，本文介绍基于MySQL5.6。<br>首先回顾一下MySQL事务的基础知识。</p>
<h2 id="1-逻辑架构和存储引擎"><a href="#1-逻辑架构和存储引擎" class="headerlink" title="1. 逻辑架构和存储引擎"></a>1. 逻辑架构和存储引擎</h2><p><img src="http://image.winrains.cn/2019/10/c899b-1174710-20190128200647649-2138221098.png" alt="img"><br>如上图所示，MySQL服务器逻辑架构从上往下可以分为三层：<br>（1）第一层：处理客户端连接、授权认证等。<br>（2）第二层：服务器层，负责查询语句的解析、优化、缓存以及内置函数的实现、存储过程等。<br>（3）第三层：存储引擎，负责MySQL中数据的存储和提取。<strong>MySQL**</strong>中服务器层不管理事务，事务是由存储引擎实现的。**MySQL支持事务的存储引擎有InnoDB、NDB Cluster等，其中InnoDB的使用最为广泛；其他存储引擎不支持事务，如MyIsam、Memory等。<br>如无特殊说明，后文中描述的内容都是基于InnoDB。</p>
<h2 id="2-提交和回滚"><a href="#2-提交和回滚" class="headerlink" title="2. 提交和回滚"></a>2. 提交和回滚</h2><p>典型的MySQL事务是如下操作的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">……  <span class="comment">#一条或多条sql语句</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span></pre></td></tr></table></figure>



<p>其中<code>start transaction</code>标识事务开始，<code>commit</code>提交事务，将执行结果写入到数据库。如果sql语句执行出现问题，会调用<code>rollback</code>，回滚所有已经执行成功的sql语句。当然，也可以在事务中直接使用<code>rollback</code>语句进行回滚。<br><strong>自动提交</strong><br>MySQL中默认采用的是自动提交（<code>autocommit</code>）模式，如下所示：<br><img src="http://image.winrains.cn/2019/10/87ecb-1174710-20190128200732629-417401931.png" alt="img"><br>在自动提交模式下，如果没有<code>start transaction</code>显式地开始一个事务，那么每个sql语句都会被当做一个事务执行提交操作。<br>通过如下方式，可以关闭<code>autocommit</code>；需要注意的是，<code>autocommit</code>参数是针对连接的，在一个连接中修改了参数，不会对其他连接产生影响。<br><img src="http://image.winrains.cn/2019/10/f0c93-1174710-20190128200751635-466164258.png" alt="img"><br>如果关闭了<code>autocommit</code>，则所有的sql语句都在一个事务中，直到执行了<code>commit</code>或<code>rollback</code>，该事务结束，同时开始了另外一个事务。<br><strong>特殊操作</strong><br>在MySQL中，存在一些特殊的命令，如果在事务中执行了这些命令，会马上强制执行<code>commit</code>提交事务；如DDL语句(<code>create table/drop table/alter/table</code>)、<code>lock tables</code>语句等等。<br>不过，常用的select、insert、update和delete命令，都不会强制提交事务。</p>
<h2 id="3-ACID特性"><a href="#3-ACID特性" class="headerlink" title="3. ACID特性"></a>3. ACID特性</h2><p>ACID是衡量事务的四个特性：</p>
<ul>
<li>原子性（Atomicity，或称不可分割性）</li>
<li>一致性（Consistency）</li>
<li>隔离性（Isolation）</li>
<li>持久性（Durability）</li>
</ul>
<p>按照严格的标准，只有同时满足ACID特性才是事务；但是在各大数据库厂商的实现中，真正满足ACID的事务少之又少。例如MySQL的NDB Cluster事务不满足持久性和隔离性；InnoDB默认事务隔离级别是可重复读，不满足隔离性；Oracle默认的事务隔离级别为<code>READ COMMITTED</code>，不满足隔离性……<strong>因此与其说**</strong>ACID<strong>**是事务必须满足的条件，不如说它们是衡量事务的四个维度。</strong><br>下面将详细介绍ACID特性及其实现原理；为了便于理解，介绍的顺序不是严格按照A-C-I-D。</p>
<h1 id="二、原子性"><a href="#二、原子性" class="headerlink" title="二、原子性"></a>二、原子性</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。</p>
<h2 id="2-实现原理：undo-log"><a href="#2-实现原理：undo-log" class="headerlink" title="2. 实现原理：undo log"></a>2. 实现原理：undo log</h2><p>在说明原子性原理之前，首先介绍一下MySQL的事务日志。MySQL的日志有很多种，如二进制日志、错误日志、查询日志、慢查询日志等，此外InnoDB存储引擎还提供了两种事务日志：<code>redo log</code>(重做日志)和<code>undo log</code>(回滚日志)。其中<code>redo log</code>用于保证事务持久性；<code>undo log</code>则是事务原子性和隔离性实现的基础。<br>下面说回<code>undo log</code>。实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。<strong>InnoDB**</strong>实现回滚，靠的是<code>undo log</code><strong><strong>：当事务对数据库进行修改时，InnoDB</strong></strong>会生成对应的<code>undo log</code><strong><strong>；如果事务执行失败或调用了<code>rollback</code></strong></strong>，导致事务需要回滚，便可以利用<code>undo log</code><strong>**中的信息将数据回滚到修改之前的样子。</strong><br><code>undo log</code>属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据<code>undo log</code>的内容做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。<br>以update操作为例：当事务执行update时，其生成的<code>undo log</code>中会包含被修改行的主键(以便知道修改了哪些行)、修改了哪些列、这些列在修改前后的值等信息，回滚时便可以使用这些信息将数据还原到update之前的状态。</p>
<h1 id="三、持久性"><a href="#三、持久性" class="headerlink" title="三、持久性"></a>三、持久性</h1><h2 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</p>
<h2 id="2-实现原理：redo-log"><a href="#2-实现原理：redo-log" class="headerlink" title="2. 实现原理：redo log"></a>2. 实现原理：redo log</h2><p><code>redo log</code>和<code>undo log</code>都属于InnoDB的事务日志。下面先聊一下<code>redo log</code>存在的背景。<br>InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存(<code>Buffer Pool</code>)，<code>Buffer Pool</code>中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：当从数据库读取数据时，会首先从<code>Buffer Pool</code>中读取，如果<code>Buffer Pool</code>中没有，则从磁盘读取后放入<code>Buffer Pool</code>；当向数据库写入数据时，会首先写入<code>Buffer Pool</code>，<code>Buffer Pool</code>中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。<br><code>Buffer Pool</code>的使用大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时<code>Buffer Pool</code>中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。<br>于是，<code>redo log</code>被引入来解决这个问题：当数据修改时，除了修改<code>Buffer Pool</code>中的数据，还会在<code>redo log</code>记录这次操作；当事务提交时，会调用<code>fsync</code>接口对<code>redo log</code>进行刷盘。如果MySQL宕机，重启时可以读取<code>redo log</code>中的数据，对数据库进行恢复。<code>redo log</code>采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到<code>Buffer Pool</code>，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。<br>既然<code>redo log</code>也需要在事务提交时将日志写入磁盘，为什么它比直接将<code>Buffer Pool</code>中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因：<br>（1）刷脏是随机IO，因为每次修改的数据位置随机，但写<code>redo log</code>是追加操作，属于顺序IO。<br>（2）刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而<code>redo log</code>中只包含真正需要写入的部分，无效IO大大减少。</p>
<h2 id="3-redo-log与binlog"><a href="#3-redo-log与binlog" class="headerlink" title="3. redo log与binlog"></a>3. redo log与binlog</h2><p>我们知道，在MySQL中还存在<code>binlog</code>(二进制日志)也可以记录写操作并用于数据的恢复，但二者是有着根本的不同的：<br>（1）作用不同：<code>redo log</code>是用于<code>crash recovery</code>的，保证MySQL宕机也不会影响持久性；<code>binlog</code>是用于<code>point-in-time recovery</code>的，保证服务器可以基于时间点恢复数据，此外<code>binlog</code>还用于主从复制。<br>（2）层次不同：<code>redo log</code>是InnoDB存储引擎实现的，而binlog是MySQL的服务器层(可以参考文章前面对MySQL逻辑架构的介绍)实现的，同时支持InnoDB和其他存储引擎。<br>（3）内容不同：<code>redo log</code>是物理日志，内容基于磁盘的Page；<code>binlog</code>的内容是二进制的，根据<code>binlog_format</code>参数的不同，可能基于sql语句、基于数据本身或者二者的混合。<br>（4）写入时机不同：<code>binlog</code>在事务提交时写入；<code>redo log</code>的写入时机相对多元：</p>
<ul>
<li>前面曾提到：当事务提交时会调用<code>fsync</code>对<code>redo log</code>进行刷盘；这是默认情况下的策略，修改<code>innodb_flush_log_at_trx_commit</code>参数可以改变该策略，但事务的持久性将无法保证。</li>
<li>除了事务提交时，还有其他刷盘时机：如<code>master thread</code>每秒刷盘一次<code>redo log</code>等，这样的好处是不一定要等到<code>commit</code>时刷盘，<code>commit</code>速度大大加快。</li>
</ul>
<h1 id="四、隔离性"><a href="#四、隔离性" class="headerlink" title="四、隔离性"></a>四、隔离性</h1><h2 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1. 定义"></a>1. 定义</h2><p><strong>与原子性、持久性侧重于研究事务本身不同，隔离性研究的是不同事务之间的相互影响。</strong>隔离性是指，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。严格的隔离性，对应了事务隔离级别中的Serializable (可串行化)，但实际应用中出于性能方面的考虑很少会使用可串行化。<br>隔离性追求的是并发情形下事务之间互不干扰。简单起见，我们仅考虑最简单的读操作和写操作(暂时不考虑带锁读等特殊操作)，那么隔离性的探讨，主要可以分为两个方面：</p>
<ul>
<li>(一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性</li>
<li>(一个事务)写操作对(另一个事务)读操作的影响：MVCC保证隔离性</li>
</ul>
<h2 id="2-锁机制"><a href="#2-锁机制" class="headerlink" title="2. 锁机制"></a>2. 锁机制</h2><p>首先来看两个事务的写操作之间的相互影响。隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB通过锁机制来保证这一点。<br>锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。<br><strong>行锁与表锁</strong><br>按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。表锁在操作数据时会锁定整张表，并发性能较差；行锁则只锁定需要操作的数据，并发性能好。但是由于加锁本身需要消耗资源(获得锁、检查锁、释放锁等都需要消耗资源)，因此在锁定数据较多情况下使用表锁可以节省大量资源。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。<br><strong>如何查看锁信息</strong><br>有多种方法可以查看InnoDB中锁的情况，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_locks; <span class="comment">#锁的概况</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engine</span> <span class="keyword">innodb</span> <span class="keyword">status</span>; <span class="comment">#InnoDB整体状态，其中包括锁的情况</span></span></pre></td></tr></table></figure>

<p>下面来看一个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#在事务A中执行：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">SET</span> balance = <span class="number">1000</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#在事务B中执行：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">SET</span> balance = <span class="number">2000</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span></pre></td></tr></table></figure>

<p>此时查看锁的情况：<br><img src="http://image.winrains.cn/2019/10/c67a0-1174710-20190128200929607-1639664811.png" alt="img"><br><code>show engine innodb status</code>查看锁相关的部分：<br><img src="http://image.winrains.cn/2019/10/197e2-1174710-20190128200936671-1683619195.png" alt="img"><br>通过上述命令可以查看事务24052和24053占用锁的情况；其中<code>lock_type</code>为<code>RECORD</code>，代表锁为行锁(记录锁)；<code>lock_mode</code>为<code>X</code>，代表排它锁(写锁)。<br>除了排它锁(写锁)之外，MySQL中还有共享锁(读锁)的概念。由于本文重点是MySQL事务的实现原理，因此对锁的介绍到此为止，后续会专门写文章分析MySQL中不同锁的区别、使用场景等，欢迎关注。<br>介绍完写操作之间的相互影响，下面讨论写操作对读操作的影响。</p>
<h2 id="3-脏读、不可重复读和幻读"><a href="#3-脏读、不可重复读和幻读" class="headerlink" title="3. 脏读、不可重复读和幻读"></a>3. 脏读、不可重复读和幻读</h2><p>首先来看并发情况下，读操作可能存在的三类问题：<br>（1）脏读：当前事务(<code>A</code>)中可以读到其他事务(<code>B</code>)未提交的数据（脏数据），这种现象是脏读。举例如下（以账户余额表为例）：<br><img src="http://image.winrains.cn/2019/10/e5492-1174710-20190128201003630-2050662608.png" alt="img"><br>（2）不可重复读：在事务<code>A</code>中先后两次读取同一个数据，两次读取的结果不一样，这种现象称为不可重复读。脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。举例如下：<br><img src="http://image.winrains.cn/2019/10/daf6c-1174710-20190128201011603-1317894910.png" alt="img"><br>（3）幻读：在事务<code>A</code>中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。举例如下：<br><img src="http://image.winrains.cn/2019/10/ba72e-1174710-20190128201021606-1089980279.png" alt="img"></p>
<h2 id="4-事务隔离级别"><a href="#4-事务隔离级别" class="headerlink" title="4. 事务隔离级别"></a>4. 事务隔离级别</h2><p>SQL标准中定义了四种隔离级别，并规定了每种隔离级别下上述几个问题是否存在。一般来说，隔离级别越低，系统开销越低，可支持的并发越高，但隔离性也越差。隔离级别与读问题的关系如下：<br><img src="http://image.winrains.cn/2019/10/851b2-1174710-20190128201034603-681355962.png" alt="img"><br>在实际应用中，<strong>读未提交</strong>在并发时会导致很多问题，而性能相对于其他隔离级别提高却很有限，因此使用较少。<strong>可串行化</strong>强制事务串行，并发效率很低，只有当对数据一致性要求极高且可以接受没有并发时使用，因此使用也较少。因此在大多数数据库系统中，默认的隔离级别是<strong>读已提交**</strong>(<strong>**如Oracle)</strong>或<strong>可重复读（后文简称**</strong>RR<strong>**）</strong>。<br>可以通过如下两个命令分别查看全局隔离级别和本次会话的隔离级别：<br><img src="http://image.winrains.cn/2019/10/9e41c-1174710-20190128201103652-719570401.png" alt="img"><br><img src="http://image.winrains.cn/2019/10/ecff9-1174710-20190128201111615-210490190.png" alt="img"><br>InnoDB默认的隔离级别是RR，后文会重点介绍RR。需要注意的是，在SQL标准中，RR是无法避免幻读问题的，但是InnoDB实现的RR避免了幻读问题。</p>
<h2 id="5-MVCC"><a href="#5-MVCC" class="headerlink" title="5. MVCC"></a>5. MVCC</h2><p>RR解决脏读、不可重复读、幻读等问题，使用的是MVCC：MVCC全称Multi-Version Concurrency Control，即多版本的并发控制协议。下面的例子很好的体现了MVCC的特点：在同一时刻，不同的事务读取到的数据可能是不同的(即多版本)——在<code>T5</code>时刻，事务<code>A</code>和事务<code>C</code>可以读取到不同版本的数据。<br><img src="http://image.winrains.cn/2019/10/4a58c-1174710-20190128201126604-235257040.png" alt="img"><br>MVCC最大的优点是读不加锁，因此读写不冲突，并发性能好。InnoDB实现MVCC，多个版本的数据可以共存，主要是依靠数据的隐藏列(也可以称之为标记位)和<code>undo log</code>。其中数据的隐藏列包括了该行数据的版本号、删除时间、指向<code>undo log</code>的指针等等；当读取数据时，MySQL可以通过隐藏列判断是否需要回滚并找到回滚需要的<code>undo log</code>，从而实现MVCC；隐藏列的详细格式不再展开。<br>下面结合前文提到的几个问题分别说明。<br>（1）脏读<br><img src="http://image.winrains.cn/2019/10/f2895-1174710-20190128201139635-1779107964.png" alt="img"><br>当事务<code>A</code>在<code>T3</code>时间节点读取<code>zhangsan</code>的余额时，会发现数据已被其他事务修改，且状态为未提交。此时事务<code>A</code>读取最新数据后，根据数据的<code>undo log</code>执行回滚操作，得到事务<code>B</code>修改前的数据，从而避免了脏读。<br>（2）不可重复读<br><img src="http://image.winrains.cn/2019/10/b93a6-1174710-20190128201149661-1275460669.png" alt="img"><br>当事务<code>A</code>在<code>T2</code>节点第一次读取数据时，会记录该数据的版本号（数据的版本号是以row为单位记录的），假设版本号为1；当事务<code>B</code>提交时，该行记录的版本号增加，假设版本号为2；当事务<code>A</code>在<code>T5</code>再一次读取数据时，发现数据的版本号（2）大于第一次读取时记录的版本号（1），因此会根据<code>undo log</code>执行回滚操作，得到版本号为1时的数据，从而实现了可重复读。<br>（3）幻读<br>InnoDB实现的RR通过<code>next-key lock</code>机制避免了幻读现象。<br><strong><code>next-key lock</code>**</strong>是行锁的一种，实现相当于<code>record lock</code>(<strong><strong>记录锁) + <code>gap lock</code>(</strong></strong>间隙锁)<strong><strong>；其特点是不仅会锁住记录本身(<code>record lock</code></strong></strong>的功能)<strong><strong>，还会锁定一个范围(<code>gap lock</code></strong></strong>的功能)<strong>**。</strong>当然，这里我们讨论的是不加锁读：此时的<code>next-key lock</code>并不是真的加锁，只是为读取的数据增加了标记（标记内容包括数据的版本号等）；准确起见姑且称之为类<code>next-key lock</code>机制。还是以前面的例子来说明：<br><img src="http://image.winrains.cn/2019/10/3f10d-1174710-20190128201206609-1998192060.png" alt="img"><br>当事务<code>A</code>在<code>T2</code>节点第一次读取<code>0数据时，标记的不只是</code>id=1<code>的数据，而是将范围</code>(0,5)<code>进行了标记，这样当</code>T5<code>时刻再次读取</code>0数据时，便可以发现<code>id=2</code>的数据比之前标记的版本号更高，此时再结合<code>undo log</code>执行回滚操作，避免了幻读。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>概括来说，InnoDB实现的RR，通过锁机制、数据的隐藏列、<code>undo log</code>和类<code>next-key lock</code>，实现了一定程度的隔离性，可以满足大多数场景的需要。不过需要说明的是，RR虽然避免了幻读问题，但是毕竟不是<code>Serializable</code>，不能保证完全的隔离，下面是一个例子，大家可以自己验证一下。<br><img src="http://image.winrains.cn/2019/10/41936-1174710-20190128201219610-1942897077.png" alt="img"></p>
<h1 id="五、一致性"><a href="#五、一致性" class="headerlink" title="五、一致性"></a>五、一致性</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><p>一致性是指事务执行结束后，<strong>数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。</strong>数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）。</p>
<h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h2><p>可以说，一致性是事务追求的最终目标：前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。<br>实现一致性的措施包括：</p>
<ul>
<li>保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证</li>
<li>数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等</li>
<li>应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致</li>
</ul>
<h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p>下面总结一下ACID特性及其实现原理：</p>
<ul>
<li>原子性：语句要么全执行，要么全不执行，是事务最核心的特性，事务本身就是以原子性来定义的；实现主要基于<code>undo log</code></li>
<li>持久性：保证事务提交后不会因为宕机等原因导致数据丢失；实现主要基于<code>redo log</code></li>
<li>隔离性：保证事务执行尽可能不受其他事务影响；InnoDB默认的隔离级别是RR，RR的实现主要基于锁机制、数据的隐藏列、<code>undo log</code>和类<code>next-key lock</code>机制</li>
<li>一致性：事务追求的最终目标，一致性的实现既需要数据库层面的保障，也需要应用层面的保障</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>《MySQL技术内幕：InnoDB存储引擎》<br>《高性能MySQL》<br>《MySQL运维内参》<br><a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_acid" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_acid</a><br><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-next-key-locking.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-next-key-locking.html</a><br><a href="http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html</a><br><a href="https://mp.weixin.qq.com/s/2dwGBTmu_da2x-HiHlN0vw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2dwGBTmu_da2x-HiHlN0vw</a><br><a href="http://www.cnblogs.com/chenpingzhao/p/5065316.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenpingzhao/p/5065316.html</a><br><a href="https://juejin.im/entry/5ba0a254e51d450e735e4a1f" target="_blank" rel="noopener">https://juejin.im/entry/5ba0a254e51d450e735e4a1f</a><br><a href="http://hedengcheng.com/?p=771" target="_blank" rel="noopener">http://hedengcheng.com/?p=771</a></p>
<blockquote>
<p>作者：编程迷思</p>
<p>来源：<a href="https://www.cnblogs.com/kismetv/p/10331633.html" target="_blank" rel="noopener">https://www.cnblogs.com/kismetv/p/10331633.html</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag"># 事务</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/28/Java-%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" rel="prev" title="Java 中的代理模式及动态代理">
      <i class="fa fa-chevron-left"></i> Java 中的代理模式及动态代理
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/28/%E4%B8%80%E6%9D%A1sql%E8%AF%AD%E5%8F%A5%E5%9C%A8MySQL%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/" rel="next" title="一条sql语句在MySQL中是如何执行的">
      一条sql语句在MySQL中是如何执行的 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、基础概念"><span class="nav-number">1.</span> <span class="nav-text">一、基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-逻辑架构和存储引擎"><span class="nav-number">1.1.</span> <span class="nav-text">1. 逻辑架构和存储引擎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-提交和回滚"><span class="nav-number">1.2.</span> <span class="nav-text">2. 提交和回滚</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-ACID特性"><span class="nav-number">1.3.</span> <span class="nav-text">3. ACID特性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、原子性"><span class="nav-number">2.</span> <span class="nav-text">二、原子性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-定义"><span class="nav-number">2.1.</span> <span class="nav-text">1. 定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-实现原理：undo-log"><span class="nav-number">2.2.</span> <span class="nav-text">2. 实现原理：undo log</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、持久性"><span class="nav-number">3.</span> <span class="nav-text">三、持久性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-定义-1"><span class="nav-number">3.1.</span> <span class="nav-text">1. 定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-实现原理：redo-log"><span class="nav-number">3.2.</span> <span class="nav-text">2. 实现原理：redo log</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-redo-log与binlog"><span class="nav-number">3.3.</span> <span class="nav-text">3. redo log与binlog</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、隔离性"><span class="nav-number">4.</span> <span class="nav-text">四、隔离性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-定义-2"><span class="nav-number">4.1.</span> <span class="nav-text">1. 定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-锁机制"><span class="nav-number">4.2.</span> <span class="nav-text">2. 锁机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-脏读、不可重复读和幻读"><span class="nav-number">4.3.</span> <span class="nav-text">3. 脏读、不可重复读和幻读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-事务隔离级别"><span class="nav-number">4.4.</span> <span class="nav-text">4. 事务隔离级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-MVCC"><span class="nav-number">4.5.</span> <span class="nav-text">5. MVCC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-总结"><span class="nav-number">4.6.</span> <span class="nav-text">6. 总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五、一致性"><span class="nav-number">5.</span> <span class="nav-text">五、一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-基本概念"><span class="nav-number">5.1.</span> <span class="nav-text">1. 基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-实现"><span class="nav-number">5.2.</span> <span class="nav-text">2. 实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#六、总结"><span class="nav-number">6.</span> <span class="nav-text">六、总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考文献"><span class="nav-number">7.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">congsheng.wang</p>
  <div class="site-description" itemprop="description">trouble is a friend</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">984</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">94</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">156</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">congsheng.wang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
