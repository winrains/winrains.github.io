<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://congsheng.wang').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="开篇相信大家都用过事务以及了解他的特点，如原子性(Atomicity),一致性(Consistency),隔离型(Isolation)以及持久性(Durability)等。今天想跟大家一起研究下事务内部到底是怎么实现的，在讲解前我想先抛出个问题：事务想要做到什么效果？按我理解，无非是要做到可靠性以及并发处理可靠性：数据库要保证当insert或update操作时抛异常或者数据库crash的时候需要保">
<meta name="keywords" content="事务">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL事务实现原理">
<meta property="og:url" content="http:&#x2F;&#x2F;congsheng.wang&#x2F;2019&#x2F;12&#x2F;28&#x2F;MySQL%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86&#x2F;index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="开篇相信大家都用过事务以及了解他的特点，如原子性(Atomicity),一致性(Consistency),隔离型(Isolation)以及持久性(Durability)等。今天想跟大家一起研究下事务内部到底是怎么实现的，在讲解前我想先抛出个问题：事务想要做到什么效果？按我理解，无非是要做到可靠性以及并发处理可靠性：数据库要保证当insert或update操作时抛异常或者数据库crash的时候需要保">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191012145938-b9453.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191012145939-85eec.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191012145940-9c3c2.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191012145940-b346a.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191012145941-5dc34.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191012145942-ce93d.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191012145942-f249e.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191012145943-9cebc.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191012145944-52427.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191012145945-69cca.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191012145945-ec923.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191012145946-9e41c.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191012145946-bad8c.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191012145947-1b37e.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191012145948-3a319.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191012145949-9c235.png">
<meta property="og:updated_time" content="2019-12-28T07:31:24.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;10&#x2F;20191012145938-b9453.png">

<link rel="canonical" href="http://congsheng.wang/2019/12/28/MySQL%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>MySQL事务实现原理 | 个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">winrains的个人博客</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">108</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">83</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">489</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://congsheng.wang/2019/12/28/MySQL%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="winrains">
      <meta itemprop="description" content="淡泊明志">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL事务实现原理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-28 15:31:24" itemprop="dateCreated datePublished" datetime="2019-12-28T15:31:24+08:00">2019-12-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>相信大家都用过事务以及了解他的特点，如原子性(Atomicity),一致性(Consistency),隔离型(Isolation)以及持久性(Durability)等。今天想跟大家一起研究下事务内部到底是怎么实现的，在讲解前我想先抛出个问题：<br><strong>事务想要做到什么效果？</strong><br>按我理解，无非是要做到<strong>可靠性</strong>以及<strong>并发处理</strong><br>可靠性：数据库要保证当insert或update操作时抛异常或者数据库crash的时候需要保障数据的操作前后的一致，想要做到这个，我需要知道我修改之前和修改之后的状态，所以就有了<code>undo log</code>和<code>redo log</code>。<br>并发处理：也就是说当多个并发请求过来，并且其中有一个请求是对数据修改操作的时候会有影响，为了避免读到脏数据，所以需要对事务之间的读写进行隔离，至于隔离到啥程度得看业务系统的场景了，实现这个就得用MySQL 的隔离级别。</p>
<a id="more"></a>

<p>下面我首先讲实现事务功能的三个技术，分别是日志文件(<code>redo log</code> 和 <code>undo log</code>)，锁技术以及MVCC，然后再讲事务的实现原理，包括原子性是怎么实现的，隔离型是怎么实现的等等。最后在做一个总结，希望大家能够耐心看完</p>
<ul>
<li><code>redo log</code>与<code>undo log</code>介绍</li>
<li>mysql锁技术以及MVCC基础</li>
<li>事务的实现原理</li>
<li>总结</li>
</ul>
<hr>
<h2 id="二、-redo-log-与-undo-log介绍"><a href="#二、-redo-log-与-undo-log介绍" class="headerlink" title="二、 redo log 与 undo log介绍"></a>二、 redo log 与 undo log介绍</h2><h3 id="1-redo-log"><a href="#1-redo-log" class="headerlink" title="1. redo log"></a>1. redo log</h3><h4 id="什么是redo-log"><a href="#什么是redo-log" class="headerlink" title="什么是redo log ?"></a><strong>什么是redo log ?</strong></h4><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">redo</span> <span class="keyword">log</span><span class="string">`叫做**重做**日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（`</span><span class="keyword">redo</span> <span class="keyword">log</span> buffer<span class="string">`）以及重做日志文件（`</span><span class="keyword">redo</span> <span class="keyword">log</span><span class="string">`）,前者是在内存中，后者在磁盘中。当**事务提交之后**会把所有修改信息都会存到该日志中。假设有个表叫做`</span>tb1(id,username)<span class="string">` 现在要插入数据`</span>（<span class="number">3</span>，ceshi）</span></pre></td></tr></table></figure>

<p><img src="http://image.winrains.cn/2019/10/20191012145938-b9453.png" alt="img"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> balance <span class="keyword">from</span> bank <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">"zhangsan"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">// 生成 重做日志 balance=600</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> bank <span class="keyword">set</span> balance = balance - <span class="number">400</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">// 生成 重做日志 amount=400</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> finance <span class="keyword">set</span> amount = amount + <span class="number">400</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span></pre></td></tr></table></figure>

<p><img src="http://image.winrains.cn/2019/10/20191012145939-85eec.png" alt="img"></p>
<h4 id="redo-log-有什么作用？"><a href="#redo-log-有什么作用？" class="headerlink" title="redo log 有什么作用？"></a><strong>redo log 有什么作用？</strong></h4><p>mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到<code>Boffer Pool</code>(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做<strong>缓冲池和磁盘之间的同步</strong>。<br>那么问题来了，如果还没来的同步的时候宕机或断电了怎么办？还没来得及执行上面图中红色的操作。这样会导致丢部分已提交事务的修改信息！<br>所以引入了<code>redo log</code>来记录已成功提交事务的修改信息，并且会把<code>redo log</code>持久化到磁盘，系统重启之后在读取<code>redo log</code>恢复最新数据。<br>总结：<br><code>redo log</code>是用来恢复数据的 用于保障，已提交事务的持久化特性</p>
<h3 id="2-undo-log"><a href="#2-undo-log" class="headerlink" title="2.undo log"></a>2.undo log</h3><h4 id="什么是-undo-log-？"><a href="#什么是-undo-log-？" class="headerlink" title="什么是 undo log ？"></a><strong>什么是 undo log ？</strong></h4><p><code>undo log</code> 叫做回滚日志，用于记录数据<strong>被修改前</strong>的信息。他正好跟前面所说的重做日志所记录的相反，重做日志记录数据被修改后的信息。<code>undo log</code>主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。<br>还用上面那两张表</p>
<p><img src="http://image.winrains.cn/2019/10/20191012145940-9c3c2.png" alt="img"></p>
<p>每次写入数据或者修改数据之前都会把修改前的信息记录到 <code>undo log</code>。</p>
<h4 id="undo-log-有什么作用？"><a href="#undo-log-有什么作用？" class="headerlink" title="undo log 有什么作用？"></a><strong>undo log 有什么作用？</strong></h4><p><code>undo log</code> 记录事务修改之前版本的数据信息，因此假如由于系统错误或者<code>rollback</code>操作而回滚的话可以根据<code>undo log</code>的信息来进行回滚到没被修改前的状态。<br>总结：<br><code>undo log</code>是用来回滚数据的用于保障 未提交事务的原子性</p>
<hr>
<h2 id="三、mysql锁技术以及MVCC基础"><a href="#三、mysql锁技术以及MVCC基础" class="headerlink" title="三、mysql锁技术以及MVCC基础"></a>三、mysql锁技术以及MVCC基础</h2><h3 id="1-mysql锁技术"><a href="#1-mysql锁技术" class="headerlink" title="1. mysql锁技术"></a>1. mysql锁技术</h3><p>当有多个请求来读取表中的数据时可以不采取任何操作，但是多个请求里有读请求，又有修改请求时必须有一种措施来进行并发控制。不然很有可能会造成不一致。<br><strong>读写锁</strong><br>解决上述问题很简单，只需用两种锁的组合来对读写请求进行控制即可，这两种锁被称为：<br>共享锁(shared lock),又叫做”读锁”<br>读锁是可以共享的，或者说多个读请求可以共享一把锁读数据，不会造成阻塞。<br>排他锁(exclusive lock),又叫做”写锁”<br>写锁会排斥其他所有获取锁的请求，一直阻塞，直到写入完成释放锁。</p>
<p><img src="http://image.winrains.cn/2019/10/20191012145940-b346a.png" alt="img"></p>
<p>总结：<br>通过读写锁，可以做到读读可以并行，但是不能做到写读，写写并行<br>事务的隔离性就是根据读写锁来实现的！！！这个后面再说。</p>
<h3 id="2-MVCC基础"><a href="#2-MVCC基础" class="headerlink" title="2. MVCC基础"></a>2. MVCC基础</h3><p>MVCC (MultiVersion Concurrency Control) 叫做多版本并发控制。</p>
<blockquote>
<p>InnoDB的 MVCC ，是通过在每行记录的后面保存两个隐藏的列来实现的。这两个列， 一个保存了行的创建时间，一个保存了行的过期时间， 当然存储的并不是实际的时间值，而是系统版本号。</p>
</blockquote>
<p>以上片段摘自《高性能Mysql》这本书对MVCC的定义。他的主要实现思想是通过<strong>数据多版本</strong>来做到<strong>读写分离</strong>。从而实现不加锁读进而做到读写并行。<br><strong>MVCC在mysql中的实现依赖的是undo log与read view</strong></p>
<ul>
<li>undo log :undo log 中记录某行数据的多个版本的数据。</li>
<li>read view :用来判断当前版本数据的可见性</li>
</ul>
<p><img src="http://image.winrains.cn/2019/10/20191012145941-5dc34.png" alt="img"></p>
<hr>
<h2 id="四、事务的实现"><a href="#四、事务的实现" class="headerlink" title="四、事务的实现"></a>四、事务的实现</h2><p>前面讲的重做日志，回滚日志以及锁技术就是实现事务的基础。</p>
<ul>
<li>事务的原子性是通过 <code>undo log</code> 来实现的</li>
<li>事务的持久性性是通过 <code>redo log</code> 来实现的</li>
<li>事务的隔离性是通过 (读写锁+MVCC)来实现的</li>
<li>而事务的终极大 boss <strong>一致性</strong>是通过原子性，持久性，隔离性来实现的！！！</li>
</ul>
<p><strong>原子性，持久性，隔离性折腾半天的目的也是为了保障数据的一致性！</strong><br>总之，ACID只是个概念，事务最终目的是要保障数据的可靠性，一致性。</p>
<h3 id="1-原子性的实现"><a href="#1-原子性的实现" class="headerlink" title="1.原子性的实现"></a>1.原子性的实现</h3><p>什么是原子性：<br>一个事务必须被视为不可分割的最小工作单位，一个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说不可能只执行其中的部分操作，这就是事务的原子性。<br>上面这段话取自《高性能MySQL》这本书对原子性的定义，原子性可以概括为就是要实现要么全部失败，要么全部成功。<br>以上概念相信大家伙儿都了解，那么数据库是怎么实现的呢？ 就是通过<strong>回滚</strong>操作。 所谓回滚操作就是当发生错误异常或者显式的执行<code>rollback</code>语句时需要把数据还原到原先的模样，所以这时候就需要用到undo log来进行回滚，接下来看一下<code>undo log</code>在实现事务原子性时怎么发挥作用的</p>
<h4 id="1-1-undo-log-的生成"><a href="#1-1-undo-log-的生成" class="headerlink" title="1.1 undo log 的生成"></a>1.1 undo log 的生成</h4><p>假设有两个表 <code>bank</code>和<code>finance</code>，表中原始数据如图所示，当进行插入，删除以及更新操作时生成的<code>undo log</code>如下面图所示：</p>
<p><img src="http://image.winrains.cn/2019/10/20191012145942-ce93d.png" alt="img"></p>
<p><img src="http://image.winrains.cn/2019/10/20191012145942-f249e.png" alt="img"></p>
<p>从上图可以了解到数据的变更都伴随着回滚日志的产生：<br>(1) 产生了被修改前数据<code>(zhangsan,1000)</code> 的回滚日志<br>(2) 产生了被修改前数据<code>(zhangsan,0)</code> 的回滚日志<br>根据上面流程可以得出如下结论：<br><strong>1.每条数据变更(insert/update/delete)操作都伴随一条<code>undo log</code>的生成,并且回滚日志必须先于数据持久化到磁盘上</strong><br><strong>2.所谓的回滚就是根据回滚日志做逆向操作，比如delete的逆向操作为insert，insert的逆向操作为delete，update的逆向为update等。</strong><br>思考：为什么先写日志后写数据库？ —稍后做解释</p>
<h4 id="1-2-根据undo-log-进行回滚"><a href="#1-2-根据undo-log-进行回滚" class="headerlink" title="1.2 根据undo log 进行回滚"></a>1.2 根据undo log 进行回滚</h4><p>为了做到同时成功或者失败，当系统发生错误或者执行<code>rollback</code>操作时需要根据<code>undo log</code> 进行回滚</p>
<p><img src="http://image.winrains.cn/2019/10/20191012145943-9cebc.png" alt="img"></p>
<p>回滚操作就是要还原到原来的状态，<code>undo log</code>记录了数据被修改前的信息以及新增和被删除的数据信息，根据<code>undo log</code>生成回滚语句，比如：<br>(1) 如果在回滚日志里有新增数据记录，则生成删除该条的语句<br>(2) 如果在回滚日志里有删除数据记录，则生成生成该条的语句<br>(3) 如果在回滚日志里有修改数据记录，则生成修改到原先数据的语句</p>
<h3 id="2-持久性的实现"><a href="#2-持久性的实现" class="headerlink" title="2.持久性的实现"></a>2.持久性的实现</h3><p>事务一旦提交，其所作做的修改会永久保存到数据库中，此时即使系统崩溃修改的数据也不会丢失。<br>先了解一下MySQL的数据存储机制，MySQL的表数据是存放在磁盘上的，因此想要存取的时候都要经历磁盘IO,然而即使是使用SSD磁盘IO也是非常消耗性能的。 为此，为了提升性能InnoDB提供了缓冲池(<code>Buffer Pool</code>)，<code>Buffer Pool</code>中包含了磁盘数据页的映射，可以当做缓存来使用：<br><strong>读数据</strong>：会首先从缓冲池中读取，如果缓冲池中没有，则从磁盘读取在放入缓冲池；<br><strong>写数据</strong>：会首先写入缓冲池，缓冲池中的数据会定期同步到磁盘中；<br>上面这种缓冲池的措施虽然在性能方面带来了质的飞跃，但是它也带来了新的问题，当MySQL系统宕机，断电的时候可能会丢数据！！！<br>因为我们的数据已经提交了，但此时是在缓冲池里头，还没来得及在磁盘持久化，所以我们急需一种机制需要存一下已提交事务的数据，为恢复数据使用。<br>于是 <code>redo log</code>就派上用场了。下面看下<code>redo log</code>是什么时候产生的</p>
<p><img src="http://image.winrains.cn/2019/10/20191012145944-52427.png" alt="img"></p>
<p>既然<code>redo log</code>也需要存储，也涉及磁盘IO为啥还用它？<br>（1）<code>redo log</code> 的存储是顺序存储，而缓存同步是随机操作。<br>（2）缓存同步是以数据页为单位的，每次传输的数据大小大于<code>redo log</code>。</p>
<hr>
<h3 id="3-隔离性实现"><a href="#3-隔离性实现" class="headerlink" title="3.隔离性实现"></a>3.隔离性实现</h3><p>隔离性是事务ACID特性里最复杂的一个。在SQL标准里定义了四种隔离级别，每一种级别都规定一个事务中的修改，哪些是事务之间可见的，哪些是不可见的。<br>级别越低的隔离级别可以执行越高的并发，但同时实现复杂度以及开销也越大。<br>Mysql 隔离级别有以下四种（级别由低到高）：</p>
<ul>
<li><strong>READ UNCOMMITED</strong> (未提交读)</li>
<li><strong>READ COMMITED</strong> (提交读)</li>
<li><strong>REPEATABLE READ</strong> (可重复读)</li>
<li><strong>SERIALIZABLE</strong> (可重复读)</li>
</ul>
<p>只要彻底理解了隔离级别以及他的实现原理就相当于理解了ACID里的隔离型。前面说过原子性，隔离性，持久性的目的都是为了要做到一致性，但隔离型跟其他两个有所区别，原子性和持久性是为了要实现数据的可性保障靠，比如要做到宕机后的恢复，以及错误后的回滚。<br>那么隔离性是要做到什么呢？ <strong>隔离性是要管理多个并发读写请求的访问顺序。</strong> 这种顺序包括<strong>串行</strong>或者是<strong>并行</strong><br>说明一点，写请求不仅仅是指insert操作，又包括update操作。</p>
<p><img src="http://image.winrains.cn/2019/10/20191012145945-69cca.png" alt="img"></p>
<p>总之，从隔离性的实现可以看出这是一场数据的可靠性与性能之间的权衡。</p>
<ul>
<li>可靠性性高的，并发性能低(比如 <code>Serializable</code>)</li>
<li>可靠性低的，并发性能高(比如 <code>Read Uncommited</code>)</li>
</ul>
<h4 id="READ-UNCOMMITTED"><a href="#READ-UNCOMMITTED" class="headerlink" title="READ UNCOMMITTED"></a><strong>READ UNCOMMITTED</strong></h4><p>在<code>READ UNCOMMITTED</code>隔离级别下，事务中的修改即使还没提交，对其他事务是可见的。事务可以读取未提交的数据，造成脏读。<br>因为读不会加任何锁，所以写操作在读的过程中修改数据，所以会造成脏读。好处是可以提升并发处理性能，能做到<strong>读写并行</strong>。<br>换句话说，读的操作不能排斥写请求。</p>
<p><img src="http://image.winrains.cn/2019/10/20191012145945-ec923.png" alt="img"></p>
<p>优点：读写并行，性能高<br>缺点：造成脏读</p>
<h4 id="READ-COMMITTED"><a href="#READ-COMMITTED" class="headerlink" title="READ COMMITTED"></a><strong>READ COMMITTED</strong></h4><p>一个事务的修改在他提交之前的所有修改，对其他事务都是不可见的。其他事务能读到已提交的修改变化。在很多场景下这种逻辑是可以接受的。<br>InnoDB在 <code>READ COMMITTED</code>，使用排它锁,读取数据不加锁而是使用了MVCC机制。或者换句话说他采用了<strong>读写分离机制</strong>。<br>但是该级别会产生<strong>不可重读</strong>以及<strong>幻读</strong>问题。</p>
<blockquote>
<p>什么是不可重读？</p>
</blockquote>
<p>在一个事务内多次读取的结果不一样。</p>
<blockquote>
<p>为什么会产生不可重复读？</p>
</blockquote>
<p>这跟 <code>READ COMMITTED</code> 级别下的MVCC机制有关系，在该隔离级别下每次 select的时候新<strong>生成一个版本号</strong>，所以每次select的时候读的不是一个副本而是不同的副本。<br>在每次select之间有其他事务<strong>更新</strong>了我们读取的数据并提交了，那就出现了不可重复读</p>
<p><img src="http://image.winrains.cn/2019/10/20191012145946-9e41c.png" alt="img"></p>
<h4 id="REPEATABLE-READ-Mysql默认隔离级别"><a href="#REPEATABLE-READ-Mysql默认隔离级别" class="headerlink" title="REPEATABLE READ(Mysql默认隔离级别)"></a><strong>REPEATABLE READ</strong>(Mysql默认隔离级别)</h4><p>在一个事务内的多次读取的结果是一样的。这种级别下可以避免，脏读，不可重复读等查询问题。mysql 有两种机制可以达到这种隔离级别的效果，分别是采用读写锁以及MVCC。<br><strong>采用读写锁实现</strong>：</p>
<p><img src="http://image.winrains.cn/2019/10/20191012145946-bad8c.png" alt="img"></p>
<p>为什么能可重复度？只要没释放读锁，在次读的时候还是可以读到第一次读的数据。<br>优点：实现起来简单<br>缺点：无法做到读写并行<br><strong>采用MVCC实现</strong>：</p>
<p><img src="http://image.winrains.cn/2019/10/20191012145947-1b37e.png" alt="img"></p>
<p>为什么能可重复度？因为多次读取只生成一个版本，读到的自然是相同数据。<br> 优点：读写并行 缺点：实现的复杂度高<br>但是在该隔离级别下仍会存在幻读的问题，关于幻读的解决我打算另开一篇来介绍。</p>
<h4 id="SERIALIZABLE"><a href="#SERIALIZABLE" class="headerlink" title="SERIALIZABLE"></a><strong>SERIALIZABLE</strong></h4><p>该隔离级别理解起来最简单，实现也最单。在隔离级别下除了不会造成数据不一致问题，没其他优点。</p>
<p><img src="http://image.winrains.cn/2019/10/20191012145948-3a319.png" alt="img"></p>
<p><img src="http://image.winrains.cn/2019/10/20191012145949-9c235.png" alt="img"></p>
<p>–摘自《高性能Mysql》</p>
<h3 id="4-一致性的实现"><a href="#4-一致性的实现" class="headerlink" title="4.一致性的实现"></a>4.一致性的实现</h3><blockquote>
<p>数据库总是从一个一致性的状态转移到另一个一致性的状态.</p>
</blockquote>
<p>下面举个例子:<code>zhangsan</code> 从银行卡转400到理财账户</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> balance <span class="keyword">from</span> bank <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">"zhangsan"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">// 生成 重做日志 balance=600</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> bank <span class="keyword">set</span> balance = balance - <span class="number">400</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">// 生成 重做日志 amount=400</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> finance <span class="keyword">set</span> amount = amount + <span class="number">400</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span></pre></td></tr></table></figure>

<p>1.假如执行完 <code>update bank set balance = balance - 400;</code>之发生异常了，银行卡的钱也不能平白无辜的减少，而是回滚到最初状态。<br>2.又或者事务提交之后，缓冲池还没同步到磁盘的时候宕机了，这也是不能接受的，应该在重启的时候恢复并持久化。<br>3.假如有并发事务请求的时候也应该做好事务之间的可见性问题，避免造成脏读，不可重复读，幻读等。在涉及并发的情况下往往在性能和一致性之间做平衡，做一定的取舍，所以隔离性也是对一致性的一种破坏。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文出发点是想讲一下Mysql的事务的实现原理。<br>实现事务采取了哪些技术以及思想？</p>
<ul>
<li>原子性：使用 <code>undo log</code> ，从而达到回滚</li>
<li>持久性：使用 <code>redo log</code>，从而达到故障后恢复</li>
<li>隔离性：使用锁以及MVCC,运用的优化思想有读写分离，读读并行，读写并行</li>
<li>一致性：通过回滚，以及恢复，和在并发环境下的隔离做到一致性。</li>
</ul>
<blockquote>
<p>作者：小小木</p>
<p>来源：<a href="https://juejin.im/post/5cb2e3b46fb9a0686e40c5cb" target="_blank" rel="noopener">https://juejin.im/post/5cb2e3b46fb9a0686e40c5cb</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag"># 事务</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/28/Spring-MVC-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="prev" title="Spring MVC 启动过程源码分析">
      <i class="fa fa-chevron-left"></i> Spring MVC 启动过程源码分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/28/Synchronized%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" rel="next" title="Synchronized及其实现原理">
      Synchronized及其实现原理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#开篇"><span class="nav-number">1.</span> <span class="nav-text">开篇</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、-redo-log-与-undo-log介绍"><span class="nav-number">2.</span> <span class="nav-text">二、 redo log 与 undo log介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-redo-log"><span class="nav-number">2.1.</span> <span class="nav-text">1. redo log</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是redo-log"><span class="nav-number">2.1.1.</span> <span class="nav-text">什么是redo log ?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redo-log-有什么作用？"><span class="nav-number">2.1.2.</span> <span class="nav-text">redo log 有什么作用？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-undo-log"><span class="nav-number">2.2.</span> <span class="nav-text">2.undo log</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是-undo-log-？"><span class="nav-number">2.2.1.</span> <span class="nav-text">什么是 undo log ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undo-log-有什么作用？"><span class="nav-number">2.2.2.</span> <span class="nav-text">undo log 有什么作用？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、mysql锁技术以及MVCC基础"><span class="nav-number">3.</span> <span class="nav-text">三、mysql锁技术以及MVCC基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-mysql锁技术"><span class="nav-number">3.1.</span> <span class="nav-text">1. mysql锁技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-MVCC基础"><span class="nav-number">3.2.</span> <span class="nav-text">2. MVCC基础</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、事务的实现"><span class="nav-number">4.</span> <span class="nav-text">四、事务的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-原子性的实现"><span class="nav-number">4.1.</span> <span class="nav-text">1.原子性的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-undo-log-的生成"><span class="nav-number">4.1.1.</span> <span class="nav-text">1.1 undo log 的生成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-根据undo-log-进行回滚"><span class="nav-number">4.1.2.</span> <span class="nav-text">1.2 根据undo log 进行回滚</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-持久性的实现"><span class="nav-number">4.2.</span> <span class="nav-text">2.持久性的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-隔离性实现"><span class="nav-number">4.3.</span> <span class="nav-text">3.隔离性实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#READ-UNCOMMITTED"><span class="nav-number">4.3.1.</span> <span class="nav-text">READ UNCOMMITTED</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#READ-COMMITTED"><span class="nav-number">4.3.2.</span> <span class="nav-text">READ COMMITTED</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#REPEATABLE-READ-Mysql默认隔离级别"><span class="nav-number">4.3.3.</span> <span class="nav-text">REPEATABLE READ(Mysql默认隔离级别)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SERIALIZABLE"><span class="nav-number">4.3.4.</span> <span class="nav-text">SERIALIZABLE</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-一致性的实现"><span class="nav-number">4.4.</span> <span class="nav-text">4.一致性的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">winrains</p>
  <div class="site-description" itemprop="description">淡泊明志</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">489</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">83</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">108</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">winrains</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
