<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://congsheng.wang').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="1、引言我们常常会听说，某个互联网应用的服务器端系统多么牛逼，比如QQ、微信、淘宝。那么，一个大型互联网应用的服务器端系统，到底牛逼在什么地方？为什么海量的用户访问，会让一个服务器端系统变得更复杂？本文结合作者多年的互联网系统设计实践经验，从最基本的技术概念开始，带你探寻服务器端系统架构的方方面面。本文适合有过几年工作经验、正处于技术上升期的程序员阅读，内容少有浮夸，多为实践经验总结，希望能为您的">
<meta property="og:type" content="article">
<meta property="og:title" content="大型分布式系统设计概述">
<meta property="og:url" content="http:&#x2F;&#x2F;congsheng.wang&#x2F;2019&#x2F;12&#x2F;27&#x2F;%E5%A4%A7%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0&#x2F;index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="1、引言我们常常会听说，某个互联网应用的服务器端系统多么牛逼，比如QQ、微信、淘宝。那么，一个大型互联网应用的服务器端系统，到底牛逼在什么地方？为什么海量的用户访问，会让一个服务器端系统变得更复杂？本文结合作者多年的互联网系统设计实践经验，从最基本的技术概念开始，带你探寻服务器端系统架构的方方面面。本文适合有过几年工作经验、正处于技术上升期的程序员阅读，内容少有浮夸，多为实践经验总结，希望能为您的">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;66e68-144641igaq1a4i3l3cc77q.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;61e5a-144645c5i75pu9j795kws4.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;348e1-144736e7pm7a7cmzxijcni.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;ccc61-145928zgw866cwrqwfggqc.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;2a308-145654l28ybvz33no99ikb.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;aa0c3-150026t5k4l1mf4adh21t2.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;53410-151440kbtcrrz4773fmgvb.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;b5943-152552b7cfrindln1lnce1.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;62706-153156sg6jo7g9s6rkzokj.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;c834a-153638gr9rd5553hga33r7.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;6192b-153738prn482fb2zfw2nzr.gif">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;4b526-153842cztjf6whupsbmjep.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;73639-153918pijvlla2bidvdjqd.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;b2451-155000b27w3a9m4c1r2hsp.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;a2685-155132nnb6n29o6b6zw7c2.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;d373f-154018v7ln9llw0qidlq91.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;48c2f-154243qab7qfmktmbagx0z.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;8c149-154954ii1u799484g5w7z8.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;eb149-155204hvy77o5t7ou1eoyj.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;32c77-155205sliloiealslbepuz.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;535aa-155337aettajgzyrew0ath.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;e82c4-155725zosov6u6yosbn6u6.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;5be86-155737nt5mw1z4v5ezrmel.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;a7aa4-155757cso2mmlbnyswws22.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;caf1e-155804jub77tsvg8c7necs.jpg">
<meta property="og:updated_time" content="2019-12-27T09:33:02.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;66e68-144641igaq1a4i3l3cc77q.png">

<link rel="canonical" href="http://congsheng.wang/2019/12/27/%E5%A4%A7%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>大型分布式系统设计概述 | 个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">congsheng的博客</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">156</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">94</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">984</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://congsheng.wang/2019/12/27/%E5%A4%A7%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="congsheng.wang">
      <meta itemprop="description" content="trouble is a friend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          大型分布式系统设计概述
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-27 17:33:02" itemprop="dateCreated datePublished" datetime="2019-12-27T17:33:02+08:00">2019-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">系统架构</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h2><p>我们常常会听说，某个互联网应用的服务器端系统多么牛逼，比如QQ、微信、淘宝。那么，一个大型互联网应用的服务器端系统，到底牛逼在什么地方？为什么海量的用户访问，会让一个服务器端系统变得更复杂？本文结合作者多年的互联网系统设计实践经验，从最基本的技术概念开始，带你探寻服务器端系统架构的方方面面。<br>本文适合有过几年工作经验、正处于技术上升期的程序员阅读，内容少有浮夸，多为实践经验总结，希望能为您的技术成长加油助力。<br><strong>特别说明：</strong>如果您是架构技术方面的初学者可以先阅读《<a href="http://www.52im.net/thread-2007-1-1.html" target="_blank" rel="noopener">新手入门：零基础理解大型分布式架构的演进历史、技术原理、最佳实践</a>》一文，再来继续理解本文效果会更佳。</p>
<a id="more"></a>

<h2 id="2、关于作者"><a href="#2、关于作者" class="headerlink" title="2、关于作者"></a>2、关于作者</h2><p><strong>韩伟：</strong>1999年大学实习期加入初创期的网易，成为第30号员工，8年间从程序员开始，历任项目经理、产品总监；2007年后创业4年，开发过视频直播社区，及多款页游产品；2011年后就职于腾讯游戏研发部公共技术中心架构规划组，负责腾讯游戏公共技术和底层平台的架构设计。<br>韩伟是难得的技术+管理的复合型人才，他的《<a href="http://mini.eastday.com/mobile/171104084840291.html" target="_blank" rel="noopener">腾讯高级工程师自述：十年沉浮，我为什么选择离开管理岗位？</a>》一文，观点独到也很犀利，同样值得一读。</p>
<h2 id="3、相关文章"><a href="#3、相关文章" class="headerlink" title="3、相关文章"></a>3、相关文章</h2><p>《<a href="http://www.52im.net/thread-307-1-1.html" target="_blank" rel="noopener">浅谈IM系统的架构设计</a>》<br>《<a href="http://www.52im.net/thread-812-1-1.html" target="_blank" rel="noopener">一套海量在线用户的移动端IM架构设计实践分享(含详细图文)</a>》<br>《<a href="http://www.52im.net/thread-151-1-1.html" target="_blank" rel="noopener">一套原创分布式即时通讯(IM)系统理论架构方案</a>》<br>《<a href="http://www.52im.net/thread-152-1-1.html" target="_blank" rel="noopener">从零到卓越：京东客服即时通讯系统的技术架构演进历程</a>》<br>《<a href="http://www.52im.net/thread-31-1-1.html" target="_blank" rel="noopener">蘑菇街即时通讯/IM服务器开发之架构选择</a>》<br>《<a href="http://www.52im.net/thread-1542-1-1.html" target="_blank" rel="noopener">WhatsApp技术实践分享：32人工程团队创造的技术神话</a>》<br>《<a href="http://www.52im.net/thread-1569-1-1.html" target="_blank" rel="noopener">微信朋友圈千亿访问量背后的技术挑战和实践总结</a>》<br>《<a href="http://www.52im.net/thread-1595-1-1.html" target="_blank" rel="noopener">王者荣耀2亿用户量的背后：产品定位、技术架构、网络方案等</a>》<br>《<a href="http://www.52im.net/thread-158-1-1.html" target="_blank" rel="noopener">腾讯QQ1.4亿在线用户的技术挑战和架构演进之路PPT</a>》<br>《<a href="http://www.52im.net/thread-895-1-1.html" target="_blank" rel="noopener">微信后台基于时间序的海量数据冷热分级架构设计实践</a>》<br>《<a href="http://www.52im.net/thread-200-1-1.html" target="_blank" rel="noopener">微信技术总监谈架构：微信之道——大道至简(演讲全文)</a>》<br>《<a href="http://www.52im.net/thread-201-1-1.html" target="_blank" rel="noopener">如何解读《微信技术总监谈架构：微信之道——大道至简》</a>》<br>《<a href="http://www.52im.net/thread-168-1-1.html" target="_blank" rel="noopener">快速裂变：见证微信强大后台架构从0到1的演进历程（一）</a>》<br><strong>PS：</strong>如果您是架构技术方面的初学者可以先阅读《<a href="http://www.52im.net/thread-2007-1-1.html" target="_blank" rel="noopener">新手入门：零基础理解大型分布式架构的演进历史、技术原理、最佳实践</a>》一文，再来继续理解本文效果会更佳。</p>
<h2 id="4、承载量是分布式系统存在的原因"><a href="#4、承载量是分布式系统存在的原因" class="headerlink" title="4、承载量是分布式系统存在的原因"></a>4、承载量是分布式系统存在的原因</h2><p>当一个互联网业务获得大众欢迎的时候，最显著碰到的技术问题，就是服务器非常繁忙。当每天有1000万个用户访问你的网站时，无论你使用什么样的服务器硬件，都不可能只用一台机器就承载的了。因此，在互联网程序员解决服务器端问题的时候，必须要考虑如何使用多台服务器，为同一种互联网应用提供服务，这就是所谓“分布式系统”的来源。<br>然而，大量用户访问同一个互联网业务，所造成的问题并不简单。从表面上看，要能满足很多用户来自互联网的请求，最基本的需求就是所谓性能需求：用户反应网页打开很慢，或者网游中的动作很卡等等。而这些对于“服务速度”的要求，实际上包含的部分却是以下几个：高吞吐、高并发、低延迟和负载均衡。<br><strong>高吞吐：</strong>意味着你的系统，可以同时承载大量的用户使用。这里关注的整个系统能同时服务的用户数。这个吞吐量肯定是不可能用单台服务器解决的，因此需要多台服务器协作，才能达到所需要的吞吐量。而在多台服务器的协作中，如何才能有效的利用这些服务器，不致于其中某一部分服务器成为瓶颈，从而影响整个系统的处理能力，这就是一个分布式系统，在架构上需要仔细权衡的问题。<br><strong>高并发：</strong>是高吞吐的一个延伸需求。当我们在承载海量用户的时候，我们当然希望每个服务器都能尽其所能的工作，而不要出现无谓的消耗和等待的情况。然而，软件系统并不是简单的设计，就能对同时处理多个任务，做到“尽量多”的处理。很多时候，我们的程序会因为要选择处理哪个任务，而导致额外的消耗。这也是分布式系统解决的问题。<br><strong>低延迟：</strong>对于人数稀少的服务来说不算什么问题。然而，如果我们需要在大量用户访问的时候，也能很快的返回计算结果，这就要困难的多。因为除了大量用户访问可能造成请求在排队外，还有可能因为排队的长度太长，导致内存耗尽、带宽占满等空间性的问题。如果因为排队失败而采取重试的策略，则整个延迟会变的更高。所以分布式系统会采用很多请求分拣和分发的做法，尽快的让更多的服务器来出来用户的请求。但是，由于一个数量庞大的分布式系统，必然需要把用户的请求经过多次的分发，整个延迟可能会因为这些分发和转交的操作，变得更高，所以分布式系统除了分发请求外，还要尽量想办法减少分发的层次数，以便让请求能尽快的得到处理<br>由于互联网业务的用户来自全世界，因此在物理空间上可能来自各种不同延迟的网络和线路，在时间上也可能来自不同的时区，所以要有效的应对这种用户来源的复杂性，就需要把多个服务器部署在不同的空间来提供服务。同时，我们也需要让同时发生的请求，有效的让多个不同服务器承载。所谓的负载均衡，就是分布式系统与生俱来需要完成的功课。<br>由于分布式系统，几乎是解决互联网业务承载量问题，的最基本方法，所以作为一个服务器端程序员，掌握分布式系统技术就变得异常重要了。然而，分布式系统的问题，并非是学会用几个框架和使用几个库，就能轻易解决的，因为当一个程序在一个电脑上运行，变成了又无数个电脑上同时协同运行，在开发、运维上都会带来很大的差别。</p>
<h2 id="5、分布式系统提高承载量的基本手段"><a href="#5、分布式系统提高承载量的基本手段" class="headerlink" title="5、分布式系统提高承载量的基本手段"></a>5、分布式系统提高承载量的基本手段</h2><h3 id="5-1-分层模型（路由、代理）"><a href="#5-1-分层模型（路由、代理）" class="headerlink" title="5.1 分层模型（路由、代理）"></a>5.1 分层模型（路由、代理）</h3><p>使用多态服务器来协同完成计算任务，最简单的思路就是，让每个服务器都能完成全部的请求，然后把请求随机的发给任何一个服务器处理。最早期的互联网应用中，DNS轮询就是这样的做法：当用户输入一个域名试图访问某个网站，这个域名会被解释成多个IP地址中的一个，随后这个网站的访问请求，就被发往对应IP的服务器了，这样多个服务器（多个IP地址）就能一起解决处理大量的用户请求。（详细的原理，可以看看《<a href="http://www.52im.net/thread-802-1-1.html" target="_blank" rel="noopener">通俗易懂：基于集群的移动端IM接入层负载均衡方案分享</a>》）<br>然而，单纯的请求随机转发，并不能解决一切问题。比如我们很多互联网业务，都是需要用户登录的。在登录某一个服务器后，用户会发起多个请求，如果我们把这些请求随机的转发到不同的服务器上，那么用户登录的状态就会丢失，造成一些请求处理失败。简单的依靠一层服务转发是不够的，所以我们会增加一批服务器，这些服务器会根据用户的Cookie，或者用户的登录凭据，来再次转发给后面具体处理业务的服务器。（更详细的技术原理，请阅读：《[url=<a href="http://www.52im.net/thread-1686-1-1.html]小白必读：闲话HTTP短连接中的Session和Token[/url]》、《[IM开发基础知识补课：正确理解前置HTTP" target="_blank" rel="noopener">http://www.52im.net/thread-1686-1-1.html]小白必读：闲话HTTP短连接中的Session和Token[/url]》、《[IM开发基础知识补课：正确理解前置HTTP</a> SSO单点登陆接口的原理](<a href="http://www.52im.net/thread-1351-1-1.html)》、《[IM开发基础知识补课(四)：正确理解HTTP短连接中的Cookie、Session和Token](http://www.52im.net/thread-1525-1-1.html)》）" target="_blank" rel="noopener">http://www.52im.net/thread-1351-1-1.html)》、《[IM开发基础知识补课(四)：正确理解HTTP短连接中的Cookie、Session和Token](http://www.52im.net/thread-1525-1-1.html)》）</a><br>除了登录的需求外，我们还发现，很多数据是需要数据库来处理的，而我们的这些数据往往都只能集中到一个数据库中，否则在查询的时候就会丢失其他服务器上存放的数据结果。所以往往我们还会把数据库单独出来成为一批专用的服务器。<br>至此，我们就会发现，一个典型的三层结构出现了：接入、逻辑、存储。<br>然而，这种三层结果，并不就能包医百病。例如：当我们需要让用户在线互动（网游和IM就是典型） ，那么分割在不同逻辑服务器上的在线状态数据，是无法知道对方的，这样我们就需要专门做一个类似互动或接层服务器的专门系统，让用户登录的时候，也同时记录一份数据到它那里，表明某个用户登录在某个服务器上，而所有的互动操作，要先经过这个互动服务器，才能正确的把消息转发到目标用户的服务器上。<br><img src="http://image.winrains.cn/2019/09/66e68-144641igaq1a4i3l3cc77q.png" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_2.png"><br>又例如，当我们在使用网上论坛（BBS）系统的时候，我们发的文章，不可能只写入一个数据库里，因为太多人的阅读请求会拖死这个数据库。我们常常会按论坛板块来写入不同的数据库，又或者是同时写入多个数据库。这样把文章数据分别存放到不同的服务器上，才能应对大量的操作请求。然而，用户在读取文章的时候，就需要有一个专门的程序，去查找具体文章在哪一个服务器上，这时候我们就要架设一个专门的代理层，把所有的文章请求先转交给它，由它按照我们预设的存储计划，去找对应的数据库获取数据。<br>根据上面的例子来看，分布式系统虽然具有三层典型的结构，但是实际上往往不止有三层，而是根据业务需求，会设计成多个层次的。为了把请求转交给正确的进程处理，我们而设计很多专门用于转发请求的进程和服务器。这些进程我们常常以Proxy或者Router来命名，一个多层结构常常会具备各种各样的Proxy进程。这些代理进程，很多时候都是通过TCP来连接前后两端。然而，TCP虽然简单，但是却会有故障后不容易恢复的问题。而且TCP的网络编程，也是有点复杂的。所以，人们设计出更好进程间通讯机制：消息队列。<br><img src="http://image.winrains.cn/2019/09/61e5a-144645c5i75pu9j795kws4.jpg" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_3.jpg"><br>尽管通过各种Proxy或者Router进程能组建出强大的分布式系统，但是其管理的复杂性也是非常高的。所以人们在分层模式的基础上，想出了更多的方法，来让这种分层模式的程序变得更简单高效的方法。</p>
<h3 id="5-2-并发模型（多线程、异步）"><a href="#5-2-并发模型（多线程、异步）" class="headerlink" title="5.2 并发模型（多线程、异步）"></a>5.2 并发模型（多线程、异步）</h3><p>当我们在编写服务器端程序是，我们会明确的知道，大部分的程序，都是会处理同时到达的多个请求的。因此我们不能好像HelloWorld那么简单的，从一个简单的输入计算出输出来。因为我们会同时获得很多个输入，需要返回很多个输出。在这些处理的过程中，往往我们还会碰到需要“等待”或“阻塞”的情况，比如我们的程序要等待数据库处理结果，等待向另外一个进程请求结果等等……如果我们把请求一个挨着一个的处理，那么这些空闲的等待时间将白白浪费，造成用户的响应延时增加，以及整体系统的吞吐量极度下降。<br>所以在如何同时处理多个请求的问题上，业界有2个典型的方案：</p>
<ul>
<li>一种是多线程；</li>
<li>一种是异步。</li>
</ul>
<p>在早期的系统中，多线程或多进程是最常用的技术。这种技术的代码编写起来比较简单，因为每个线程中的代码都肯定是按先后顺序执行的。但是由于同时运行着多个线程，所以你无法保障多个线程之间的代码的先后顺序。这对于需要处理同一个数据的逻辑来说，是一个非常严重的问题，最简单的例子就是显示某个新闻的阅读量。两个++操作同时运行，有可能结果只加了1，而不是2。所以多线程下，我们常常要加很多数据的锁，而这些锁又反过来可能导致线程的死锁。<br>因此异步回调模型在随后比多线程更加流行，除了多线程的死锁问题外，异步还能解决多线程下，线程反复切换导致不必要的开销的问题：每个线程都需要一个独立的栈空间，在多线程并行运行的时候，这些栈的数据可能需要来回的拷贝，这额外消耗了CPU。同时由于每个线程都需要占用栈空间，所以在大量线程存在的时候，内存的消耗也是巨大的。而异步回调模型则能很好的解决这些问题，不过异步回调更像是“手工版”的并行处理，需要开发者自己去实现如何“并行”的问题。<br>异步回调基于非阻塞的I/O操作（网络和文件），这样我们就不用在调用读写函数的时候“卡”在那一句函数调用，而是立刻返回“有无数据”的结果。而Linux的epoll技术，则利用底层内核的机制，让我们可以快速的“查找”到有数据可以读写的连接\文件。由于每个操作都是非阻塞的，所以我们的程序可以只用一个进程，就处理大量并发的请求。因为只有一个进程，所以所有的数据处理，其顺序都是固定的，不可能出现多线程中，两个函数的语句交错执行的情况，因此也不需要各种“锁”。从这个角度看，异步非阻塞的技术，是大大简化了开发的过程。由于只有一个线程，也不需要有线程切换之类的开销，所以异步非阻塞成为很多对吞吐量、并发有较高要求的系统首选。<br><img src="http://image.winrains.cn/2019/09/348e1-144736e7pm7a7cmzxijcni.jpg" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_4.jpg"><br>▲ Linux epoll网络模型原理图</p>
<p>int epoll_create(int size)；// 创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大<br>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；<br>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</p>
<h3 id="5-3-缓冲技术"><a href="#5-3-缓冲技术" class="headerlink" title="5.3 缓冲技术"></a>5.3 缓冲技术</h3><p>在互联网服务中，大部分的用户交互，都是需要立刻返回结果的，所以对于延迟有一定的要求。而类似网络游戏之类服务，延迟更是要求缩短到几十毫秒以内。所以为了降低延迟，缓冲是互联网服务中最常见的技术之一。<br>早期的WEB系统中，如果每个HTTP请求的处理，都去数据库（MySQL）读写一次，那么数据库很快就会因为连接数占满而停止响应。因为一般的数据库，支持的连接数都只有几百，而WEB的应用的并发请求，轻松能到几千。这也是很多设计不良的网站人一多就卡死的最直接原因。为了尽量减少对数据库的连接和访问，人们设计了很多缓冲系统——把从数据库中查询的结果存放到更快的设施上，如果没有相关联的修改，就直接从这里读。<br>最典型的WEB应用缓冲系统是Memcache（更新一点的技术方案是Redis）。由于PHP本身的线程结构，是不带状态的。早期PHP本身甚至连操作“堆”内存的方法都没有，所以那些持久的状态，就一定要存放到另外一个进程里。而Memcache就是一个简单可靠的存放临时状态的开源软件。很多PHP应用现在的处理逻辑，都是先从数据库读取数据，然后写入Memcache；当下次请求来的时候，先尝试从Memcache里面读取数据，这样就有可能大大减少对数据库的访问。<br><img src="http://image.winrains.cn/2019/09/ccc61-145928zgw866cwrqwfggqc.jpg" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_6.jpg"><br>然而Memcache本身是一个独立的服务器进程，这个进程自身并不带特别的集群功能。也就是说这些Memcache进程，并不能直接组建成一个统一的集群。如果一个Memcache不够用，我们就要手工用代码去分配，哪些数据应该去哪个Memcache进程。——这对于真正的大型分布式网站来说，管理一个这样的缓冲系统，是一个很繁琐的工作。<br>因此人们开始考虑设计一些更高效的缓冲系统：从性能上来说，Memcache的每笔请求，都要经过网络传输，才能去拉取内存中的数据。这无疑是有一点浪费的，因为请求者本身的内存，也是可以存放数据的。——这就是促成了很多利用请求方内存的缓冲算法和技术，其中最简单的就是使用LRU算法，把数据放在一个哈希表结构的堆内存中。<br>而Memcache的不具备集群功能，也是一个用户的痛点。于是很多人开始设计，如何让数据缓存分不到不同的机器上。最简单的思路是所谓读写分离，也就是缓存每次写，都写到多个缓冲进程上记录，而读则可以随机读任何一个进程。在业务数据有明显的读写不平衡差距上，效果是非常好的。<br>然而，并不是所有的业务都能简单的用读写分离来解决问题，比如一些在线互动的互联网业务，比如社区、游戏。这些业务的数据读写频率并没很大的差异，而且也要求很高的延迟。因此人们又再想办法，把本地内存和远端进程的内存缓存结合起来使用，让数据具备两级缓存。同时，一个数据不在同时的复制存在所有的缓存进程上，而是按一定规律分布在多个进程上。——这种分布规律使用的算法，最流行的就是所谓“一致性哈希”。这种算法的好处是，当某一个进程失效挂掉，不需要把整个集群中所有的缓存数据，都重新修改一次位置。你可以想象一下，如果我们的数据缓存分布，是用简单的以数据的ID对进程数取模，那么一旦进程数变化，每个数据存放的进程位置都可能变化，这对于服务器的故障容忍是不利的。<br>Orcale公司旗下有一款叫Coherence的产品（详见《<a href="http://www.it610.com/article/1267142.htm" target="_blank" rel="noopener">分布式网格缓存Coherence简介</a>》），是在缓存系统上设计比较好的。这个产品是一个商业产品，支持利用本地内存缓存和远程进程缓存协作。集群进程是完全自管理的，还支持在数据缓存所在进程，进行用户定义的计算（处理器功能），这就不仅仅是缓存了，还是一个分布式的计算系统。<br><img src="http://image.winrains.cn/2019/09/2a308-145654l28ybvz33no99ikb.jpg" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_7.jpg"></p>
<h3 id="5-4-存储技术（NoSQL）"><a href="#5-4-存储技术（NoSQL）" class="headerlink" title="5.4 存储技术（NoSQL）"></a>5.4 存储技术（NoSQL）</h3><p>相信CAP理论大家已经耳熟能详，然而在互联发展的早期，大家都还在使用MySQL的时候，如何让数据库存放更多的数据，承载更多的连接，很多团队都是绞尽脑汁。甚至于有很多业务，主要的数据存储方式是文件，数据库反而变成是辅助的设施了。<br><img src="http://image.winrains.cn/2019/09/aa0c3-150026t5k4l1mf4adh21t2.jpg" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_8.jpg"><br>然而，当NoSQL兴起，大家突然发现，其实很多互联网业务，其数据格式是如此的简单，很多时候根部不需要关系型数据库那种复杂的表格。对于索引的要求往往也只是根据主索引搜索。而更复杂的全文搜索，本身数据库也做不到。所以现在相当多的高并发的互联网业务，首选NoSQL来做存储设施。最早的NoSQL数据库有MangoDB等，现在最流行的似乎就是Redis了。甚至有些团队，把Redis也当成缓冲系统的一部分，实际上也是认可Redis的性能优势。<br>NoSQL除了更快、承载量更大以外，更重要的特点是，这种数据存储方式，只能按照一条索引来检索和写入。这样的需求约束，带来了分布上的好处，我们可以按这条主索引，来定义数据存放的进程（服务器）。这样一个数据库的数据，就能很方便的存放在不同的服务器上。在分布式系统的必然趋势下，数据存储层终于也找到了分布的方法。</p>
<h2 id="6、分布式系统在可管理性上造成的问题"><a href="#6、分布式系统在可管理性上造成的问题" class="headerlink" title="6、分布式系统在可管理性上造成的问题"></a>6、分布式系统在可管理性上造成的问题</h2><p>分布式系统并不是简单的把一堆服务器一起运行起来就能满足需求的。对比单机或少量服务器的集群，有一些特别需要解决的问题等待着我们。</p>
<h3 id="6-1-硬件故障率"><a href="#6-1-硬件故障率" class="headerlink" title="6.1 硬件故障率"></a>6.1 硬件故障率</h3><p>所谓分布式系统，肯定就不是只有一台服务器。假设一台服务器的平均故障时间是1%，那么当你有100台服务器的时候，那就几乎总有一台是在故障的。虽然这个比方不一定很准确，但是，当你的系统所涉及的硬件越来越多，硬件的故障也会从偶然事件变成一个必然事件。一般我们在写功能代码的时候，是不会考虑到硬件故障的时候应该怎么办的。而如果在编写分布式系统的时候，就一定需要面对这个问题了。否则，很可能只有一台服务器出故障，整个数百台服务器的集群都工作不正常了。<br><img src="http://image.winrains.cn/2019/09/53410-151440kbtcrrz4773fmgvb.jpg" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_未标题-1.jpg"><br>▲ 为了让服务器不宕机，“开光”、“祈祷”必不可少啊！<br>除了服务器自己的内存、硬盘等故障，服务器之间的网络线路故障更加常见。而且这种故障还有可能是偶发的，或者是会自动恢复的。面对这种问题，如果只是简单的把“出现故障”的机器剔除出去，那还是不够的。因为网络可能过一会儿就又恢复了，而你的集群可能因为这一下的临时故障，丢失了过半的处理能力。<br>如何让分布式系统，在各种可能随时出现故障的情况下，尽量的自动维护和维持对外服务，成为了编写程序就要考虑的问题。由于要考虑到这种故障的情况，所以我们在设计架构的时候，也要有意识的预设一些冗余、自我维护的功能。这些都不是产品上的业务需求，完全就是技术上的功能需求。能否在这方面提出对的需求，然后正确的实现，是服务器端程序员最重要的职责之一。</p>
<h3 id="6-2-资源利用率优化"><a href="#6-2-资源利用率优化" class="headerlink" title="6.2 资源利用率优化"></a>6.2 资源利用率优化</h3><p>在分布式系统的集群，包含了很多个服务器，当这样一个集群的硬件承载能力到达极限的时候，最自然的想法就是增加更多的硬件。然而，一个软件系统不是那么容易就可以通过“增加”硬件来提高承载性能的。因为软件在多个服务器上的工作，是需要有复杂细致的协调工作。在对一个集群扩容的时候，我们往往会要停掉整个集群的服务，然后修改各种配置，最后才能重新启动一个加入了新的服务器的集群。<br><img src="http://image.winrains.cn/2019/09/b5943-152552b7cfrindln1lnce1.jpg" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_5.jpg"><br>由于在每个服务器的内存里，都可能会有一些用户使用的数据，所以如果冒然在运行的时候，就试图修改集群中提供服务的配置，很可能会造成内存数据的丢失和错误。因此，运行时扩容在对无状态的服务上，是比较容易的，比如增加一些Web服务器。但如果是在有状态的服务上，比如网络游戏，几乎是不可能进行简单的运行时扩容的。<br>分布式集群除了扩容，还有缩容的需求。当用户人数下降，服务器硬件资源出现空闲的时候，我们往往需要这些空闲的资源能利用起来，放到另外一些新的服务集群里去。缩容和集群中有故障需要容灾有一定类似之处，区别是缩容的时间点和目标是可预期的。<br>由于分布式集群中的扩容、缩容，以及希望尽量能在线操作，这导致了非常复杂的技术问题需要处理，比如集群中互相关联的配置如何正确高效的修改、如何对有状态的进程进行操作、如何在扩容缩容的过程中保证集群中节点之间通信的正常。作为服务器端程序员，会需要花费大量的经历，来对多个进程的集群状态变化，造成的一系列问题进行专门的开发。</p>
<h3 id="6-3-软件服务内容更新"><a href="#6-3-软件服务内容更新" class="headerlink" title="6.3 软件服务内容更新"></a>6.3 软件服务内容更新</h3><p>现在都流行用敏捷开发模式中的“迭代”，来表示一个服务不断的更新程序，满足新的需求，修正BUG。如果我们仅仅管理一台服务器，那么更新这一台服务器上的程序，是非常简单的：只要把软件包拷贝过去，然后修改下配置就好。但是如果你要对成百上千的服务器去做同样的操作，就不可能每台服务器登录上去处理。<br>服务器端的程序批量安装部署工具，是每个分布式系统开发者都需要的。然而，我们的安装工作除了拷贝二进制文件和配置文件外，还会有很多其他的操作。比如打开防火墙、建立共享内存文件、修改数据库表结构、改写一些数据文件等等……甚至有一些还要在服务器上安装新的软件。<br><img src="http://image.winrains.cn/2019/09/62706-153156sg6jo7g9s6rkzokj.jpg" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_7.jpg"><br>如果我们在开发服务器端程序的时候，就考虑到软件更新、版本升级的问题，那么我们对于配置文件、命令行参数、系统变量的使用，就会预先做一定的规划，这能让安装部署的工具运行更快，可靠性更高。<br>除了安装部署的过程，还有一个重要的问题，就是不同版本间数据的问题。我们在升级版本的时候，旧版本程序生成的一些持久化数据，一般都是旧的数据格式的；而我们升级版本中如果涉及修改了数据格式，比如数据表结果，那么这些旧格式的数据，都要转换改写成新版本的数据格式才行。这导致了我们在设计数据结构的时候，就要考虑清楚这些表格的结构，是用最简单直接的表达方式，来让将来的修改更简单；还是一早就预计到修改的范围，专门预设一些字段，或者使用其他形式存放数据。<br>除了持久化数据以外，如果存在客户端程序（如受击APP），这些客户端程序的升级往往不能和服务器同步，如果升级的内容包含了通信协议的修改，这就造成了我们必须为不同的版本部署不同的服务器端系统的问题。为了避免同时维护多套服务器，我们在软件开发的时候，往往倾向于所谓“版本兼容”的协议定义方式。而怎样设计的协议才能有很好的兼容性，又是服务器端程序需要仔细考虑的问题。</p>
<h3 id="6-4数据统计和决策"><a href="#6-4数据统计和决策" class="headerlink" title="6.4数据统计和决策"></a>6.4数据统计和决策</h3><p>一般来说，分布式系统的日志数据，都是被集中到一起，然后统一进行统计的。然而，当集群的规模到一定程度的时候，这些日志的数据量会变得非常恐怖。很多时候，统计一天的日志量，要消耗计算机运行一天以上的时间。所以，日志统计这项工作，也变成一门非常专业的活动。<br>经典的分布式统计模型，有Google的<a href="https://baike.baidu.com/item/MapReduce/133425?fr=aladdin" target="_blank" rel="noopener">Map Reduce模型</a>。这种模型既有灵活性，也能利用大量服务器进行统计工作。但是缺点是易用性往往不够好，因为这些数据的统计和我们常见的SQL数据表统计有非常大的差异，所以我们最后还是常常把数据丢到MySQL里面去做更细层面的统计。<br><img src="http://image.winrains.cn/2019/09/c834a-153638gr9rd5553hga33r7.jpg" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_8.jpg"><br>由于分布式系统日志数量的庞大，以及日志复杂程度的提高。我们变得必须要掌握类似Map Reduce技术，才能真正的对分布式系统进行数据统计。而且我们还需要想办法提高统计工作的工作效率。</p>
<h2 id="7、解决分布式系统可管理性的基本手段"><a href="#7、解决分布式系统可管理性的基本手段" class="headerlink" title="7、解决分布式系统可管理性的基本手段"></a>7、解决分布式系统可管理性的基本手段</h2><h3 id="7-1-目录服务（ZooKeeper）"><a href="#7-1-目录服务（ZooKeeper）" class="headerlink" title="7.1 目录服务（ZooKeeper）"></a>7.1 目录服务（ZooKeeper）</h3><p>分布式系统是一个由很多进程组成的整体，这个整体中每个成员部分，都会具备一些状态，比如自己的负责模块，自己的负载情况，对某些数据的掌握等等。而这些和其他进程相关的数据，在故障恢复、扩容缩容的时候变得非常重要。<br>简单的分布式系统，可以通过静态的配置文件，来记录这些数据：进程之间的连接对应关系，他们的IP地址和端口，等等。然而一个自动化程度高的分布式系统，必然要求这些状态数据都是动态保存的。这样才能让程序自己去做容灾和负载均衡的工作。<br>一些程序员会专门自己编写一个DIR服务（目录服务），来记录集群中进程的运行状态。集群中进程会和这个DIR服务产生自动关联，这样在容灾、扩容、负载均衡的时候，就可以自动根据这些DIR服务里的数据，来调整请求的发送目地，从而达到绕开故障机器、或连接到新的服务器的操作。<br><img src="http://image.winrains.cn/2019/09/6192b-153738prn482fb2zfw2nzr.gif" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_1.gif"><br>然而，如果我们只是用一个进程来充当这个工作。那么这个进程就成为了这个集群的“单点”——意思就是，如果这个进程故障了，那么整个集群可能都无法运行的。所以存放集群状态的目录服务，也需要是分布式的。幸好我们有<a href="https://zookeeper.apache.org/" target="_blank" rel="noopener">ZooKeeper</a>这个优秀的开源软件，它正是一个分布式的目录服务区。<br>ZooKeeper可以简单启动奇数个进程，来形成一个小的目录服务集群。这个集群会提供给所有其他进程，进行读写其巨大的“配置树”的能力。这些数据不仅仅会存放在一个ZooKeeper进程中，而是会根据一套非常安全的算法，让多个进程来承载。这让ZooKeeper成为一个优秀的分布式数据保存系统。<br>由于ZooKeeper的数据存储结构，是一个类似文件目录的树状系统，所以我们常常会利用它的功能，把每个进程都绑定到其中一个“分枝”上，然后通过检查这些“分支”，来进行服务器请求的转发，就能简单的解决请求路由（由谁去做）的问题。另外还可以在这些“分支”上标记进程的负载的状态，这样负载均衡也很容易做了。<br>目录服务是分布式系统中最关键的组件之一。而ZooKeeper是一个很好的开源软件，正好是用来完成这个任务。</p>
<h3 id="7-2-消息队列服务（ActiveMQ、ZeroMQ、Jgroups、Kafka、RabbitMQ）"><a href="#7-2-消息队列服务（ActiveMQ、ZeroMQ、Jgroups、Kafka、RabbitMQ）" class="headerlink" title="7.2 消息队列服务（ActiveMQ、ZeroMQ、Jgroups、Kafka、RabbitMQ）"></a>7.2 消息队列服务（ActiveMQ、ZeroMQ、Jgroups、Kafka、RabbitMQ）</h3><p>两个进程间如果要跨机器通讯，我们几乎都会用TCP/UDP这些协议。但是直接使用网络API去编写跨进程通讯，是一件非常麻烦的事情。除了要编写大量的底层socket代码外，我们还要处理诸如：如何找到要交互数据的进程，如何保障数据包的完整性不至于丢失，如果通讯的对方进程挂掉了，或者进程需要重启应该怎样等等这一系列问题。这些问题包含了容灾扩容、负载均衡等一系列的需求。<br>为了解决分布式系统进程间通讯的问题，人们总结出了一个有效的模型，就是“消息队列”模型。消息队列模型，就是把进程间的交互，抽象成对一个个消息的处理，而对于这些消息，我们都有一些“队列”，也就是管道，来对消息进行暂存。每个进程都可以访问一个或者多个队列，从里面读取消息（消费）或写入消息（生产）。由于有一个缓存的管道，我们可以放心的对进程状态进行变化。当进程起来的时候，它会自动去消费消息就可以了。而消息本身的路由，也是由存放的队列决定的，这样就把复杂的路由问题，变成了如何管理静态的队列的问题。<br>一般的消息队列服务，都是提供简单的“投递”和“收取”两个接口，但是消息队列本身的管理方式却比较复杂，一般来说有两种。一部分的消息队列服务，提倡点对点的队列管理方式：每对通信节点之间，都有一个单独的消息队列。这种做法的好处是不同来源的消息，可以互不影响，不会因为某个队列的消息过多，挤占了其他队列的消息缓存空间。而且处理消息的程序也可以自己来定义处理的优先级——先收取、多处理某个队列，而少处理另外一些队列。<br>但是这种点对点的消息队列，会随着集群的增长而增加大量的队列，这对于内存占用和运维管理都是一个复杂的事情。因此更高级的消息队列服务，开始可以让不同的队列共享内存空间，而消息队列的地址信息、建立和删除，都采用自动化的手段。——这些自动化往往需要依赖上文所述的“目录服务”，来登记队列的ID对应的物理IP和端口等信息。比如很多开发者使用ZooKeeper来充当消息队列服务的中央节点；而类似Jgropus这类软件，则自己维护一个集群状态来存放各节点今昔。<br><img src="http://image.winrains.cn/2019/09/4b526-153842cztjf6whupsbmjep.jpg" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_2.jpg"><br>另外一种消息队列，则类似一个公共的邮箱。一个消息队列服务就是一个进程，任何使用者都可以投递或收取这个进程中的消息。这样对于消息队列的使用更简便，运维管理也比较方便。不过这种用法下，任何一个消息从发出到处理，最少进过两次进程间通信，其延迟是相对比较高的。并且由于没有预定的投递、收取约束，所以也比较容易出BUG。<br>不管使用那种消息队列服务，在一个分布式服务器端系统中，进程间通讯都是必须要解决的问题，所以作为服务器端程序员，在编写分布式系统代码的时候，使用的最多的就是基于消息队列驱动的代码，这也直接导致了EJB3.0把“消息驱动的Bean”加入到规范之中。</p>
<h3 id="7-3-事务系统"><a href="#7-3-事务系统" class="headerlink" title="7.3 事务系统"></a>7.3 事务系统</h3><p>在分布式的系统中，事务是最难解决的技术问题之一。由于一个处理可能分布在不同的处理进程上，任何一个进程都可能出现故障，而这个故障问题则需要导致一次回滚。这种回滚大部分又涉及多个其他的进程。这是一个扩散性的多进程通讯问题。要在分布式系统上解决事务问题，必须具备两个核心工具：一个是稳定的状态存储系统；另外一个是方便可靠的广播系统。<br><img src="http://image.winrains.cn/2019/09/73639-153918pijvlla2bidvdjqd.png" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_3.png"><br>事务中任何一步的状态，都必须在整个集群中可见，并且还要有容灾的能力。这个需求，一般还是由集群的“目录服务”来承担。如果我们的目录服务足够健壮，那么我们可以把每步事务的处理状态，都同步写到目录服务上去。ZooKeeper再次在这个地方能发挥重要的作用。<br>如果事务发生了中断，需要回滚，那么这个过程会涉及到多个已经执行过的步骤。也许这个回滚只需要在入口处回滚即可（加入那里有保存回滚所需的数据），也可能需要在各个处理节点上回滚。如果是后者，那么就需要集群中出现异常的节点，向其他所有相关的节点广播一个“回滚！事务ID是XXXX”这样的消息。这个广播的底层一般会由消息队列服务来承载，而类似<a href="http://www.jgroups.org/" target="_blank" rel="noopener">Jgroups</a>这样的软件，直接提供了广播服务。<br>虽然现在我们在讨论事务系统，但实际上分布式系统经常所需的“分布式锁”功能，也是这个系统可以同时完成的。所谓的“分布式锁”，也就是一种能让各个节点先检查后执行的限制条件。如果我们有高效而单子操作的目录服务，那么这个锁状态实际上就是一种“单步事务”的状态记录，而回滚操作则默认是“暂停操作，稍后再试”。这种“锁”的方式，比事务的处理更简单，因此可靠性更高，所以现在越来越多的开发人员，愿意使用这种“锁”服务，而不是去实现一个“事务系统”。<br><img src="http://image.winrains.cn/2019/09/b2451-155000b27w3a9m4c1r2hsp.jpg" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_001.jpg"></p>
<h3 id="7-4自动部署工具（Docker）"><a href="#7-4自动部署工具（Docker）" class="headerlink" title="7.4自动部署工具（Docker）"></a>7.4自动部署工具（Docker）</h3><p>由于分布式系统最大的需求，是在运行时（有可能需要中断服务）来进行服务容量的变更：扩容或者缩容。而在分布式系统中某些节点故障的时候，也需要新的节点来恢复工作。这些如果还是像老式的服务器管理方式，通过填表、申报、进机房、装服务器、部署软件……这一套做法，那效率肯定是不行。<br>在分布式系统的环境下，我们一般都是采用“池”的方式来管理服务。我们预先会申请一批机器，然后在某些机器上运行服务软件，另外一些则作为备份。显然我们这一批服务器不可能只为某一个业务服务，而是会提供多个不同的业务承载。那些备份的服务器，则会成为多个业务的通用备份“池”。随着业务需求的变化，一些服务器可能“退出”A服务而“加入”B服务。<br>这种频繁的服务变化，依赖高度自动的软件部署工具。我们的运维人员，应该掌握这开发人员提供的部署工具，而不是厚厚的手册，来进行这类运维操作。一些比较有经验的开发团队，会统一所有的业务底层框架，以期大部分的部署、配置工具，都能用一套通用的系统来进行管理。而开源界，也有类似的尝试，最广为人知的莫过于RPM安装包格式，然而RPM的打包方式还是太复杂，不太符合服务器端程序的部署需求。所以后来又出现了Chef为代表的，可编程的通用部署系统。<br><img src="http://image.winrains.cn/2019/09/a2685-155132nnb6n29o6b6zw7c2.jpg" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_002.jpg"><br>在虚拟机技术出现之后，PaaS平台为自动部署提供了强大的支持：如果我们是按某个PaaS平台的规范来编写的应用，可以完全把程序丢给平台去部署，其承载量计算、部署规划，都自动完成了。这方面的佼佼者是Google的<a href="https://baike.baidu.com/item/GoogleAppEngine/3254832" target="_blank" rel="noopener">AppEngine</a>：我们可以直接用Eclipse开发一个本地的Web应用，然后上传到AppEngine里面，所有的部署就完成了！AppEngine会自动的根据对这个Web应用的访问量，来进行扩容、缩容、故障恢复。<br>然而，真正有革命性的工具，是<a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a>的出现。虽然虚拟机、沙箱技术早就不是什么新技术，但是真正使用这些技术来作为部署工具的时间却不长。Linux高效的轻量级容器技术，提供了部署上巨大的便利性——我们可以在各种库、各种协作软件的环境下打包我们的应用程序，然后随意的部署在任何一个Linux系统上。<br><img src="http://image.winrains.cn/2019/09/d373f-154018v7ln9llw0qidlq91.jpg" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_88.jpg"><br>为了管理大量的分布式服务器端进程，我们确实需要花很多功夫，其优化其部署管理的工作。统一服务器端进程的运行规范，是实现自动化部署管理的基本条件。我们可以根据“操作系统”作为规范，采用Docker技术；也可以根据“Web应用”作为规范，采用某些PaaS平台技术；或者自己定义一些更具体的规范，自己开发完整的分布式计算平台。</p>
<h3 id="7-5-日志服务（log4j）"><a href="#7-5-日志服务（log4j）" class="headerlink" title="7.5 日志服务（log4j）"></a>7.5 日志服务（log4j）</h3><p>服务器端的日志，一直是一个既重要又容易被忽视的问题。很多团队在刚开始的时候，仅仅把日志视为开发调试、排除BUG的辅助工具。但是很快会发现，在服务运营起来之后，日志几乎是服务器端系统，在运行时可以用来了解程序情况的唯一有效手段。<br>尽管我们有各种profile工具（比如<a href="https://www.ej-technologies.com/products/jprofiler/overview.html" target="_blank" rel="noopener">JProfile</a>），但是这些工具大部分都不适合在正式运营的服务上开启，因为会严重降低其运行性能。所以我们更多的时候需要根据日志来分析。尽管日志从本质上，就是一行行的文本信息，但是由于其具有很大的灵活性，所以会很受开发和运维人员的重视。<br>日志本身从概念上，是一个很模糊的东西。你可以随便打开一个文件，然后写入一些信息。但是现代的服务器系统，一般都会对日志做一些标准化的需求规范：日志必须是一行一行的，这样比较方便日后的统计分析；每行日志文本，都应该有一些统一的头部，比如日期时间就是基本的需求；日志的输出应该是分等级的，比如fatal/error/warning/info/debug/trace等等，程序可以在运行时调整输出的等级，以便可以节省日志打印的消耗；日志的头部一般还需要一些类似用户ID或者IP地址之类的头信息，用于快速查找定位过滤某一批日志记录，或者有一些其他的用于过滤缩小日志查看范围的字段，这叫做染色功能；日志文件还需要有“回滚”功能，也就是保持固定大小的多个文件，避免长期运行后，把硬盘写满。<br><img src="http://image.winrains.cn/2019/09/48c2f-154243qab7qfmktmbagx0z.jpg" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_99.jpg"><br>由于有上述的各种需求，所以开源界提供了很多游戏的日志组件库，比如大名鼎鼎的<a href="https://logging.apache.org/log4j/2.x/" target="_blank" rel="noopener">log4j</a>，以及成员众多的<a href="http://logging.apache.org/" target="_blank" rel="noopener">log4X家族库</a>，这些都是应用广泛而饱受好评的工具。<br>不过对比日志的打印功能，日志的搜集和统计功能却往往比较容易被忽视。作为分布式系统的程序员，肯定是希望能从一个集中节点，能搜集统计到整个集群日志情况。而有一些日志的统计结果，甚至希望能在很短时间内反复获取，用来监控整个集群的健康情况。要做到这一点，就必须有一个分布式的文件系统，用来存放源源不断到达的日志（这些日志往往通过UDP协议发送过来）。而在这个文件系统上，则需要有一个类似Map Reduce架构的统计系统，这样才能对海量的日志信息，进行快速的统计以及报警。有一些开发者会直接使用Hadoop系统，有一些则用<a href="http://kafka.apache.org/" target="_blank" rel="noopener">Kafka</a>来作为日志存储系统，上面再搭建自己的统计程序。<br><strong>关于Kafka：</strong></p>
<p>Kafka是最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、storm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，用scala语言编写，Linkedin于2010年贡献给了Apache基金会并成为顶级开源 项目。</p>
<p>日志服务是分布式运维的仪表盘、潜望镜。如果没有一个可靠的日志服务，整个系统的运行状况可能会是失控的。所以无论你的分布式系统节点是多还是少，必须花费重要的精力和专门的开发时间，去建立一个对日志进行自动化统计分析的系统。<br><img src="http://image.winrains.cn/2019/09/8c149-154954ii1u799484g5w7z8.jpg" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_0.jpg"></p>
<h2 id="8、分布式系统在开发效率上造成的问题和解决思路"><a href="#8、分布式系统在开发效率上造成的问题和解决思路" class="headerlink" title="8、分布式系统在开发效率上造成的问题和解决思路"></a>8、分布式系统在开发效率上造成的问题和解决思路</h2><p>根据上文所述，分布式系统在业务需求的功能以为，还需要增加额外很多非功能的需求。这些非功能需求，往往都是为了一个多进程系统能稳定可靠运行而去设计和实现的。这些“额外”的工作，一般都会让你的代码更加复杂，如果没有很好的工具，就会让你的开发效率严重下降。</p>
<h3 id="8-1-微服务框架：EJB、WebService"><a href="#8-1-微服务框架：EJB、WebService" class="headerlink" title="8.1 微服务框架：EJB、WebService"></a>8.1 微服务框架：EJB、WebService</h3><p>当我们在讨论服务器端软件分布的时候，服务进程之间的通信就难免了。然而服务进程间的通讯，并不是简单的收发消息就能完成的。这里还涉及了消息的路由、编码解码、服务状态的读写等等。如果整个流程都由自己开发，那就太累人了。<br><img src="http://image.winrains.cn/2019/09/eb149-155204hvy77o5t7ou1eoyj.jpg" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_1.jpg"><br>所以业界很早就推出了各种分布式的服务器端开发框架，最著名的就是“EJB”——企业JavaBean。但凡冠以“企业”的技术，往往都是分布式下所需的部分，而EJB这种技术，也是一种分布式对象调用的技术。我们如果需要让多个进程合作完成任务，则需要把任务分解到多个“类”上，然后这些“类”的对象就会在各个进程容器中存活，从而协作提供服务。这个过程很“面向对象”。每个对象都是一个“微服务”，可以提供某些分布式的功能。<br>而另外一些系统，则走向学习互联网的基本模型：HTTP。所以就有了各种的WebService框架，从开源的到商业软件，都有各自的WebService实现。这种模型，把复杂的路由、编解码等操作，简化成常见的一次HTTP操作，是一种非常有效的抽象。开发人员开发和部署多个WebService到Web服务器上，就完成了分布式系统的搭建。<br><img src="http://image.winrains.cn/2019/09/32c77-155205sliloiealslbepuz.jpg" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_2.jpg"><br>不管我们是学习EJB还是WebService，实际上我们都需要简化分布式调用的复杂程度。而分布式调用的复杂之处，就是因为需要把容灾、扩容、负载均衡等功能，融合到跨进程调用里。所以使用一套通用的代码，来为所有的跨进程通讯（调用），统一的实现容灾、扩容、负载均衡、过载保护、状态缓存命中等等非功能性需求，能大大简化整个分布式系统的复杂性。<br>一般我们的微服务框架，都会在路由阶段，对整个集群所有节点的状态进行观察，如哪些地址上运行了哪些服务的进程，这些服务进程的负载状况如何，是否可用，然后对于有状态的服务，还会使用类似一致性哈希的算法，去尽量试图提高缓存的命中率。当集群中的节点状态发生变化的时候，微服务框架下的所有节点，都能尽快的获得这个变化的情况，从新根据当前状态，重新规划以后的服务路由方向，从而实现自动化的路由选择，避开那些负载过高或者失效的节点。<br>有一些微服务框架，还提供了类似IDL转换成“骨架”、“桩”代码的工具，这样在编写远程调用程序的时候，完全无需编写那些复杂的网络相关的代码，所有的传输层、编码层代码都自动的编写好了。这方面EJB、Facebook的Thrift，Google gRPC都具备这种能力。在具备代码生成能力的框架下，我们编写一个分布式下可用的功能模块（可能是一个函数或者是一个类），就好像编写一个本地的函数那样简单。这绝对是分布式系统下非常重要的效率提升。<br><img src="http://image.winrains.cn/2019/09/535aa-155337aettajgzyrew0ath.jpg" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_3.jpg"></p>
<h3 id="8-2-异步编程工具：协程、Futrue、Lamda"><a href="#8-2-异步编程工具：协程、Futrue、Lamda" class="headerlink" title="8.2 异步编程工具：协程、Futrue、Lamda"></a>8.2 异步编程工具：协程、Futrue、Lamda</h3><p>在分布式系统中编程，你不可避免的会碰到大量的“回调”型API。因为分布式系统涉及非常多的网络通信。任何一个业务命令，都可能被分解到多个进程，通过多次网络通信来组合完成。由于异步非阻塞的编程模型大行其道，所以我们的代码也往往动不动就要碰到“回调函数”。然而，回调这种异步编程模型，是一种非常不利于代码阅读的编程方法。因为你无法从头到尾的阅读代码，去了解一个业务任务，是怎样被逐步的完成的。属于一个业务任务的代码，由于多次的非阻塞回调，从而被分割成很多个回调函数，在代码的各处被串接起来。<br>更有甚者，我们有时候会选择使用“观察者模式”，我们会在一个地方注册大量的“事件-响应函数”，然后在所有需要回调的地方，都发出一个事件。——这样的代码，比单纯的注册回调函数更难理解。因为事件对应的响应函数，通常在发出事件处是无法找到的。这些函数永远都会放在另外的一些文件里，而且有时候这些函数还会在运行时改变。而事件名字本身，也往往是匪夷所思难以理解的，因为当你的程序需要成千上百的事件的时候，起一个容易理解名符其实的名字，几乎是不可能的。<br>为了解决回调函数这种对于代码可读性的破坏作用，人们发明了很多不同的改进方法。其中最著名的是“协程”。我们以前常常习惯于用多线程来解决问题，所以非常熟悉以同步的方式去写代码。协程正是延续了我们的这一习惯，但不同于多线程的是，协程并不会“同时”运行，它只是在需要阻塞的地方，用Yield()切换出去执行其他协程，然后当阻塞结束后，用Resume()回到刚刚切换的位置继续往下执行。这相当于我们可以把回调函数的内容，接到Yield()调用的后面。这种编写代码的方法，非常类似于同步的写法，让代码变得非常易读。但是唯一的缺点是，Resume()的代码还是需要在所谓“主线程”中运行。用户必须自己从阻塞恢复的时候，去调用Resume()。协程另外一个缺点，是需要做栈保存，在切换到其他协程之后，栈上的临时变量，也都需要额外占用空间，这限制了协程代码的写法，让开发者不能用太大的临时变量。<br><img src="http://image.winrains.cn/2019/09/e82c4-155725zosov6u6yosbn6u6.jpg" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_1.jpg"><br>而另外一种改善回调函数的写法，往往叫做Future/Promise模型。这种写法的基本思路，就是“一次性把所有回调写到一起”。这是一个非常实用的编程模型，它没有让你去彻底干掉回调，而是让你可以把回调从分散各处，集中到一个地方。在同一段代码中，你可以清晰的看到各个异步的步骤是如何串接、或者并行执行的。<br><img src="http://image.winrains.cn/2019/09/5be86-155737nt5mw1z4v5ezrmel.jpg" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_2.jpg"><br>最后说一下lamda模型，这种写法流行于js语言的广泛应用。由于在其他语言中，定一个回调函数是非常费事的：Java语言要设计一个接口然后做一个实现，简直是五星级的费事程度；C/C++支持函数指针，算是比较简单，但是也很容易导致代码看不懂；脚本语言相对好一些，也要定义个函数。而直接在调用回调的地方，写回调函数的内容，是最方便开发，也比较利于阅读的。更重要的，lamda一般意味着闭包，也就是说，这种回调函数的调用栈，是被分别保存的，很多需要在异步操作中，需要建立一个类似“会话池”的状态保存变量，在这里都是不需要的，而是可以自然生效的。这一点和协程有异曲同工之妙。<br><img src="http://image.winrains.cn/2019/09/a7aa4-155757cso2mmlbnyswws22.jpg" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_3.jpg"><br>不管使用哪一种异步编程方式，其编码的复杂度，都是一定比同步调用的代码高的。所以我们在编写分布式服务器代码的时候，一定要仔细规划代码结构，避免出现随意添加功能代码，导致代码的可读性被破坏的情况。不可读的代码，就是不可维护的代码，而大量异步回调的服务器端代码，是更容易出现这种情况的。</p>
<h3 id="8-3-云服务模型：IaaS-PaaS-SaaS"><a href="#8-3-云服务模型：IaaS-PaaS-SaaS" class="headerlink" title="8.3 云服务模型：IaaS/PaaS/SaaS"></a>8.3 云服务模型：IaaS/PaaS/SaaS</h3><p>在复杂的分布式系统开发和使用过程中，如何对大量服务器和进程的运维，一直是一个贯穿其中的问题。不管是使用微服务框架、还是统一的部署工具、日志监控服务，都是因为大量的服务器，要集中的管理，是非常不容易的。这里背后的原因，主要是大量的硬件和网络，把逻辑上的计算能力，切割成很多小块。<br>随着计算机运算能力的提升，出现的虚拟化技术，却能把被分割的计算单元，更智能的统一起来。其中最常见的就是IaaS技术：当我们可以用一个服务器硬件，运行多个虚拟的服务器操作系统的时候，我们需要维护的硬件数量就会成倍的下降。<br>而PaaS技术的流行，让我们可以为某一种特定的编程模型，统一的进行系统运行环境的部署维护。而不需要再一台台服务器的去装操作系统、配置运行容器、上传运行代码和数据。在没有统一的PaaS之前，安装大量的MySQL数据库，曾经是消耗大量时间和精力的工作。<br>当我们的业务模型，成熟到可以抽象为一些固定的软件时，我们的分布式系统就会变得更加易用。我们的计算能力不再是代码和库，而是一个个通过网络提供服务的云——SaaS，这样使用者根本来维护、部署的工作都不需要，只要申请一个接口，填上预期的容量额度，就能直接使用了。这不仅节省了大量开发对应功能的事件，还等于把大量的运维工作，都交出去给SaaS的维护者——而他们做这样的维护会更加专业。<br><img src="http://image.winrains.cn/2019/09/caf1e-155804jub77tsvg8c7necs.jpg" alt="腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面_4.jpg"><br>在运维模型的进化上，从IaaS到PaaS到SaaS，其应用范围也许是越来越窄，但使用的便利性却成倍的提高。这也证明了，软件劳动的工作，也是可以通过分工，向更专业化、更细分的方向去提高效率。</p>
<blockquote>
<p>作者：JackJiang</p>
<p>来源：<a href="http://www.52im.net/thread-1811-1-1.html" target="_blank" rel="noopener">http://www.52im.net/thread-1811-1-1.html</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/27/%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84Redis%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF/" rel="prev" title="高性能的Redis缓存实践之路">
      <i class="fa fa-chevron-left"></i> 高性能的Redis缓存实践之路
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/27/%E4%BB%8E%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%B1%82%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%AF%86HTTP/" rel="next" title="从数据传输层深度解密HTTP">
      从数据传输层深度解密HTTP <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、引言"><span class="nav-number">1.</span> <span class="nav-text">1、引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、关于作者"><span class="nav-number">2.</span> <span class="nav-text">2、关于作者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、相关文章"><span class="nav-number">3.</span> <span class="nav-text">3、相关文章</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、承载量是分布式系统存在的原因"><span class="nav-number">4.</span> <span class="nav-text">4、承载量是分布式系统存在的原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、分布式系统提高承载量的基本手段"><span class="nav-number">5.</span> <span class="nav-text">5、分布式系统提高承载量的基本手段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-分层模型（路由、代理）"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 分层模型（路由、代理）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-并发模型（多线程、异步）"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 并发模型（多线程、异步）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-缓冲技术"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 缓冲技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-存储技术（NoSQL）"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 存储技术（NoSQL）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、分布式系统在可管理性上造成的问题"><span class="nav-number">6.</span> <span class="nav-text">6、分布式系统在可管理性上造成的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-硬件故障率"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 硬件故障率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-资源利用率优化"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 资源利用率优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-软件服务内容更新"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 软件服务内容更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4数据统计和决策"><span class="nav-number">6.4.</span> <span class="nav-text">6.4数据统计和决策</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、解决分布式系统可管理性的基本手段"><span class="nav-number">7.</span> <span class="nav-text">7、解决分布式系统可管理性的基本手段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-目录服务（ZooKeeper）"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 目录服务（ZooKeeper）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-消息队列服务（ActiveMQ、ZeroMQ、Jgroups、Kafka、RabbitMQ）"><span class="nav-number">7.2.</span> <span class="nav-text">7.2 消息队列服务（ActiveMQ、ZeroMQ、Jgroups、Kafka、RabbitMQ）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-事务系统"><span class="nav-number">7.3.</span> <span class="nav-text">7.3 事务系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4自动部署工具（Docker）"><span class="nav-number">7.4.</span> <span class="nav-text">7.4自动部署工具（Docker）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-日志服务（log4j）"><span class="nav-number">7.5.</span> <span class="nav-text">7.5 日志服务（log4j）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8、分布式系统在开发效率上造成的问题和解决思路"><span class="nav-number">8.</span> <span class="nav-text">8、分布式系统在开发效率上造成的问题和解决思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-微服务框架：EJB、WebService"><span class="nav-number">8.1.</span> <span class="nav-text">8.1 微服务框架：EJB、WebService</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-异步编程工具：协程、Futrue、Lamda"><span class="nav-number">8.2.</span> <span class="nav-text">8.2 异步编程工具：协程、Futrue、Lamda</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-云服务模型：IaaS-PaaS-SaaS"><span class="nav-number">8.3.</span> <span class="nav-text">8.3 云服务模型：IaaS/PaaS/SaaS</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">congsheng.wang</p>
  <div class="site-description" itemprop="description">trouble is a friend</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">984</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">94</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">156</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">congsheng.wang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
