<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://congsheng.wang').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="前言通常为了弄清楚一个概念，我们需要掌握十个概念。在判断 JWT(JsonWebToken) 是否能代替 session 管理之前，我们要了解什么是 token，以及 access token 和 refresh token 的区别。了解什么是 OAuth，什么是 SSO，SSO 下不同策略 OAuth 和 SAML 的不同，以及 OAuth 与 OpenID 的不同，更重要的是区分 author">
<meta name="keywords" content="JWT">
<meta property="og:type" content="article">
<meta property="og:title" content="浅谈SAML, OAuth, OpenID和SSO, JWT和Session">
<meta property="og:url" content="http:&#x2F;&#x2F;congsheng.wang&#x2F;2019&#x2F;12&#x2F;27&#x2F;%E6%B5%85%E8%B0%88SAML-OAuth-OpenID%E5%92%8CSSO-JWT%E5%92%8CSession&#x2F;index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="前言通常为了弄清楚一个概念，我们需要掌握十个概念。在判断 JWT(JsonWebToken) 是否能代替 session 管理之前，我们要了解什么是 token，以及 access token 和 refresh token 的区别。了解什么是 OAuth，什么是 SSO，SSO 下不同策略 OAuth 和 SAML 的不同，以及 OAuth 与 OpenID 的不同，更重要的是区分 author">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;20190822161311-7dff1.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;20190822161311-65f21.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;20190822161311-4ca88.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;20190822161311-789ea.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;20190822161311-63fd8.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;20190822161312-861f3.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;20190822161312-3f765.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;20190822161312-63b4a.jpeg">
<meta property="og:updated_time" content="2019-12-27T02:02:55.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;20190822161311-7dff1.jpeg">

<link rel="canonical" href="http://congsheng.wang/2019/12/27/%E6%B5%85%E8%B0%88SAML-OAuth-OpenID%E5%92%8CSSO-JWT%E5%92%8CSession/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>浅谈SAML, OAuth, OpenID和SSO, JWT和Session | 个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">winrains的个人博客</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">108</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">82</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">469</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://congsheng.wang/2019/12/27/%E6%B5%85%E8%B0%88SAML-OAuth-OpenID%E5%92%8CSSO-JWT%E5%92%8CSession/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="winrains">
      <meta itemprop="description" content="淡泊明志">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          浅谈SAML, OAuth, OpenID和SSO, JWT和Session
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-27 10:02:55" itemprop="dateCreated datePublished" datetime="2019-12-27T10:02:55+08:00">2019-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">Java技术</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF/Session/" itemprop="url" rel="index">
                    <span itemprop="name">Session</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通常为了弄清楚一个概念，我们需要掌握十个概念。在判断 JWT(JsonWebToken) 是否能代替 session 管理之前，我们要了解什么是 token，以及 access token 和 refresh token 的区别。<br>了解什么是 OAuth，什么是 SSO，SSO 下不同策略 OAuth 和 SAML 的不同，以及 OAuth 与 OpenID 的不同，更重要的是区分 authorisation 和 authentication。<br>最后我们引出 JSON WEB TOKEN，聊聊 JWT 在 Session 管理方面的优势和劣势，同时尝试解决这些劣势，看看成本和代价有多少。</p>
<p><img src="http://image.winrains.cn/2019/08/20190822161311-7dff1.jpeg" alt="浅谈SAML, OAuth, OpenID和SSO, JWT和Session，不了解一下吗？"></p>
<a id="more"></a>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>本文关于 OAuth <strong>授权</strong> 和 API 调用实例都来自 Google API。</p>
<h2 id="关于Token"><a href="#关于Token" class="headerlink" title="关于Token"></a>关于Token</h2><p>Token 即使是在计算机领域中也有不同的定义，这里我们说的 token，是指 <strong>访问资源</strong> 的凭据。例如当你调用 Google API 时，需要带上有效 token 来表明你请求的 <strong>合法性</strong>。这个 Token 是 Google 给你的，这代表 Google 给你的 <strong>授权</strong> 使得你有能力访问 API 背后的 <strong>资源</strong>。<br>请求 API 时携带 token 的方式也有很多种，通过 HTTP Header 或者 url 参数或者 google 提供的类库都可以：</p>
<ul>
<li><strong>HTTP Header</strong></li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/drive/v2/files</span> HTTP/1.1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">Authorization</span>: Bearer &lt;token&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attribute">Host</span>: www.googleapis.com/</span></pre></td></tr></table></figure>

<ul>
<li><strong>URL参数</strong></li>
</ul>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">GET <span class="keyword">https</span>://www.googleapis.com/drive/v2/<span class="built_in">files</span>?<span class="keyword">token</span>=&lt;<span class="keyword">token</span>&gt;</span></pre></td></tr></table></figure>

<ul>
<li><strong>Python函数库</strong></li>
</ul>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> googleapiclient.discovery import build</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">drive = build(<span class="string">'drive'</span>, <span class="string">'v2'</span>, <span class="attribute">credentials</span>=credentials)</span></pre></td></tr></table></figure>

<p>更具体的说，上面用于调用 API 的 token，我们称为细分为 access token。通常 access token 是有 <strong>有效期限</strong> 的，如果 <strong>过期</strong> 就需要 <strong>重新获取</strong>。那么如何重新获取？先看看第一次获取 token 的流程是怎样的:</p>
<ol>
<li>首先需要向 Google API 注册一个应用程序，注册完毕之后就会拿到 <strong>认证信息</strong>（credentials）包括 ID 和 secret。不是所有的程序类型都有 secret。</li>
<li>接下来就要向 Google 请求 access token。这里先忽略一些细节，例如请求参数（当然需要上面申请到的 secret）。重要的是，如果你想访问的是 <strong>用户资源</strong>，这里就会提醒用户进行 <strong>授权</strong>。</li>
<li>如果 <strong>用户授权</strong> 完毕。Google 就会返回 access token。又或者是返回 <strong>授权代码</strong>（authorization code），再通过代码取得 access token。</li>
</ol>
<p>token 获取到之后，就能够带上 token 访问 API 了。<br>流程如下图所示：</p>
<p><img src="http://image.winrains.cn/2019/08/20190822161311-65f21.jpeg" alt="浅谈SAML, OAuth, OpenID和SSO, JWT和Session，不了解一下吗？"></p>
<blockquote>
<p>注意：在第三步通过 authorization code 兑换 access token 的过程中，Google 并不会仅仅返回 access token，还会返回额外的信息，这其中和之后更新相关的就是 refresh token。</p>
</blockquote>
<p>一旦 access token 过期，你就可以通过 refresh token 再次请求 access token。<br>以上只是大致的流程，并且故意省略了一些额外的概念。比如更新 access token 当然也可以不需要 refresh token，这要根据你的 <strong>请求方式</strong> 和访问的 <strong>资源类型</strong> 而定。<br>这里又会引起另外的两个问题：</p>
<ol>
<li>如果 refesh token 也过期了怎么办？这时就需要用户 <strong>重新登陆授权</strong>。</li>
<li>为什么要区分 refresh token 和 access token？如果合并成一个 token 然后把 <strong>过期时间</strong> 调整的 <strong>更长</strong>，并且每次 <strong>失效</strong> 之后用户 <strong>重新登陆授权</strong> 就好了？这个问题会和后面谈的相关概念有关，后面会给予解释说明。</li>
</ol>
<h3 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h3><p>从获取 token 到使用 token 访问接口。这其实是标准的 OAuth2.0 机制下访问 API 的流程。这里介绍一下 OAuth 里外相关的概念，更深入的理解 token 的作用。</p>
<h4 id="SSO-Single-sign-on"><a href="#SSO-Single-sign-on" class="headerlink" title="SSO (Single sign-on)"></a>SSO (Single sign-on)</h4><p>通常公司内部会有非常多的平台供大家使用，比如人力资源，代码管理，日志监控，预算申请等等。如果每一个平台都实现自己的用户体系的话无疑是巨大的浪费，所以公司内部会有一套 <strong>公用的用户体系</strong>，用户只要登陆之后，就能够 <strong>访问所有的系统</strong>。这就是 <strong>单点登录</strong>。<br>SSO 是一类 <strong>解决方案</strong> 的统称，而在具体的实施方面，我们有两种策略可供选择：</p>
<ul>
<li><strong>SAML 2.0</strong></li>
<li><strong>OAuth 2.0</strong></li>
</ul>
<p>接下来我们区别这 <strong>两种授权方式</strong> 有什么不同。但是在描述 <strong>不同的策略</strong> 之前，我们先叙述几个 <strong>共有的特性</strong>，并且相当重要的概念。</p>
<h4 id="Authentication-VS-Authorisation"><a href="#Authentication-VS-Authorisation" class="headerlink" title="Authentication VS Authorisation"></a>Authentication VS Authorisation</h4><ul>
<li><strong>Authentication:</strong> 身份鉴别，以下简称 <strong>认证</strong>；</li>
<li><strong>Authorisation:</strong> 资源访问 <strong>授权</strong>。</li>
</ul>
<p><strong>认证</strong> 的作用在于 <strong>认可</strong> 你能够访问系统，用于 <strong>鉴别访问者</strong> 是否是 <strong>合法用户</strong>；而 <strong>授权</strong> 用于决定你有访问 <strong>哪些资源的权限</strong>。<br>大多数人不会区分这两者的区别，因为站在用户的立场上。而作为系统的设计者来说，这两者是有差别的，这是不同的两个工作职责。我们可以只需要 <strong>认证功能</strong>，而不需要 <strong>授权功能</strong>，甚至不需要自己实现 <strong>认证功能</strong>。而借助 Google 的认证系统，即用户可以用 Google 的账号进行登陆。<br>Authorization Server/Identity Provider(IdP)<br>把负责 <strong>认证的服务</strong> 称为 AuthorizationServer 或者 IdentityProvider，以下简称 IDP。<br>Service Provider(SP)/Resource Server<br>把负责 <strong>提供资源</strong>（API 调用）的服务称为 ResourceServer 或者 ServiceProvider，以下简称 SP。</p>
<h4 id="SAML-2-0"><a href="#SAML-2-0" class="headerlink" title="SAML 2.0"></a>SAML 2.0</h4><p>下图是 SAML2.0 的流程图，看图说话：</p>
<p><img src="http://image.winrains.cn/2019/08/20190822161311-4ca88.jpeg" alt="浅谈SAML, OAuth, OpenID和SSO, JWT和Session，不了解一下吗？"></p>
<ol>
<li>还 <strong>未登陆</strong> 的用户 <strong>打开浏览器</strong> 访问你的网站（SP），网站 <strong>提供服务</strong> 但是并 <strong>不负责用户认证</strong>。</li>
<li>于是 SP 向 IDP 发送了一个 SAML 认证请求，同时 SP 将 <strong>用户浏览器</strong> 重定向到 IDP。</li>
<li>IDP 在验证完来自 SP 的 <strong>请求无误</strong> 之后，在浏览器中呈现 <strong>登陆表单</strong> 让用户填写 <strong>用户名</strong> 和 <strong>密码</strong> 进行登陆。</li>
<li>一旦用户登陆成功， IDP 会生成一个包含 <strong>用户信息</strong>（<strong>用户名</strong> 或者 <strong>密码</strong>）的 SAML token（SAML token 又称为 SAML Assertion，本质上是 XML 节点）。IDP 向 SP 返回 token，并且将 <strong>用户重定向</strong> 到 SP (token 的返回是在 <strong>重定向步骤</strong> 中实现的，下面会详细说明)。</li>
<li>SP 对拿到的 token 进行验证，并从中解析出 <strong>用户信息</strong>，例如 <strong>用户是谁</strong> 以及 <strong>用户的权限</strong> 有哪些。此时就能够根据这些信息允许用户访问我们网站的内容。</li>
</ol>
<p>当用户在 IDP 登陆成功之后，IDP 需要将用户 <strong>再次重定向</strong> 到 SP 站点，这一步通常有两个办法：</p>
<ul>
<li>HTTP 重定向：这并不推荐，因为 <strong>重定向</strong> 的 URL 长度 <strong>有限制</strong>，无法携带更长的信息，比如 SAML Token。</li>
<li>HTTP POST 请求：这个是更常规的做法，当用户登陆完毕之后渲染出一个表单，用户点击后向 SP 提交 POST 请求。又或者可以使用 JavaScript 向 SP 发出一个 POST 请求。</li>
</ul>
<p>如果你的应用是基于 Web，那么以上的方案没有任何问题。但如果你开发的是一个 iOS 或者 Android 的手机应用，那么问题就来了：</p>
<ol>
<li>用户在 iPhone 上打开应用，此时用户需要通过 IDP 进行认证。</li>
<li>应用跳转至 Safari 浏览器，在登陆认证完毕之后，需要通过 HTTP POST 的形式将 token 返回至 <strong>手机应用</strong>。</li>
</ol>
<p>虽然 POST 的 url 可以 <strong>拉起应用</strong>，但是 <strong>手机应用</strong> 无法解析 POST 的内容，我们也就无法读取 SAML Token。</p>
<blockquote>
<p>当然还是有办法的，比如在 IDP <strong>授权阶段</strong> 不跳转至系统的 Safari 浏览器，在 <strong>内嵌</strong> 的 Webview 中解决，在想方设法从 Webview 中提取 token，或者利用 <strong>代理服务器</strong>。</p>
</blockquote>
<p>无论如何，SAML 2.0 并 <strong>不适用</strong> 于当下 <strong>跨平台</strong> 的场景，这也许与它产生的年代也有关系，它诞生于 2005 年，在那个时刻 HTTP POST 确实是最好的选择方案。</p>
<h2 id="OAuth-2-0-1"><a href="#OAuth-2-0-1" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h2><p>我们先简单了解 SSO 下的 OAuth2.0 的流程。</p>
<p><img src="http://image.winrains.cn/2019/08/20190822161311-789ea.jpeg" alt="浅谈SAML, OAuth, OpenID和SSO, JWT和Session，不了解一下吗？"></p>
<ol>
<li>用户通过 <strong>客户端</strong>（可以是 <strong>浏览器</strong> 也可以是 <strong>手机应用</strong>）想要访问 SP 上的资源，但是 SP 告诉用户需要进行 <strong>认证</strong>，将用户 <strong>重定向</strong> 至 IDP。</li>
<li>IDP 向 <strong>用户</strong> 询问 SP 是否可以访问 <strong>用户信息</strong>。如果用户同意，IDP 向 <strong>客户端</strong> 返回 authorization code。</li>
<li>客户端拿到 authorization code 向 IDP 交换 access token，并拿着 access token 向 SP 请求资源。</li>
<li>SP 接受到请求之后，拿着附带的 token 向 IDP 验证 <strong>用户的身份</strong>。确认身份无误后，SP 向 <strong>客户端</strong> 发放相关资源。</li>
</ol>
<p>那么 OAuth 是如何避免 SAML 流程下 <strong>无法解析</strong> POST 内容的信息的呢？</p>
<ul>
<li>一方面是用户从 IDP 返回 <strong>客户端</strong> 的方式，也是通过 URL 重定向，这里的 URL 允许 <strong>自定义</strong> schema，所以即使在 <strong>手机</strong> 上也能 <strong>拉起应用</strong>；</li>
<li>另一方面因为 IDP 向 <strong>客户端</strong> 传递的是 authorization code，而不是 XML 信息，所以 code 可以很轻易的附着在 <strong>重定向</strong> URL 上进行传递。</li>
</ul>
<p>但以上的 SSO 流程体现不出 OAuth 的本意。OAuth 的本意是 <strong>一个应用</strong> 允许 <strong>另一个应用</strong> 在 <strong>用户授权</strong> 的情况下 <strong>访问自己的数据</strong>。<br>OAuth 的设计本意更倾向于 <strong>授权而非认证</strong>（当然授权用户信息就间接实现了认证），虽然 Google 的 OAuth 2.0 API 同时支持 <strong>授权</strong> 和 <strong>认证</strong>。所以你在使用 Facebook 或者 Gmail 账号登陆第三方站点时，会出现 <strong>授权对话框</strong>，告诉你 <strong>第三方站点</strong> 可以访问你的哪些信息，需要征得你的同意。</p>
<p><img src="http://image.winrains.cn/2019/08/20190822161311-63fd8.jpeg" alt="浅谈SAML, OAuth, OpenID和SSO, JWT和Session，不了解一下吗？"></p>
<p>在上面 SSO 的 OAuth 流程中涉及三方角色: SP, IDP 以及 Client。但在实际工作中 Client 可以是不存在的，例如你编写了一个 <strong>后端程序</strong> 定时的通过 Google API 从 Youtube 拉取最新的节目数据，那么你的 <strong>后端程序</strong> 需要得到 Youtube 的 OAuth <strong>授权</strong> 即可。</p>
<h2 id="OAuth-VS-OpenId"><a href="#OAuth-VS-OpenId" class="headerlink" title="OAuth VS OpenId"></a>OAuth VS OpenId</h2><p>如果你有留心的话，你会在某些站点看到允许以 OpenID 的方式登陆，其实也就是以 Facebook 账号或者 Google 账号登陆站点：</p>
<p><img src="http://image.winrains.cn/2019/08/20190822161312-861f3.jpeg" alt="浅谈SAML, OAuth, OpenID和SSO, JWT和Session，不了解一下吗？"></p>
<p>OpenID 和 OAuth 很像。但本质上来说它们是截然不同的两个东西：</p>
<ul>
<li><strong>OpenID:</strong> 只用于 <strong>身份认证</strong>（Authentication），允许你以 <strong>同一个账户</strong> 在 <strong>多个网站登陆</strong>。它仅仅是为你的 <strong>合法身份</strong> 背书，当你以 Facebook 账号登陆某个站点之后，该站点 <strong>无权访问</strong> 你的在 Facebook 上的 <strong>数据</strong>。</li>
<li><strong>OAuth:</strong> 用于 <strong>授权</strong>（Authorisation），允许 <strong>被授权方</strong> 访问 <strong>授权方</strong> 的 <strong>用户数据</strong>。</li>
</ul>
<h2 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h2><p>现在可以回答上面的问题了，为什么我们需要 refresh token？<br>这样的处理是为了 <strong>职责的分离</strong>：</p>
<ul>
<li><strong>refresh token:</strong> 负责 <strong>身份认证</strong>；</li>
<li><strong>access token:</strong> 负责 <strong>请求资源</strong>。</li>
</ul>
<p>虽然 refresh token 和 access token 都由 IDP 发出，但是 access token 还要和 SP 进行 <strong>数据交换</strong>，如果 <strong>公用的话</strong> 这样就会有 <strong>身份泄露</strong> 的可能。并且 IDP 和 SP 可能是 <strong>完全不同</strong> 的 <strong>服务提供</strong> 的。而在上文，我们之所以没有这样的顾虑是因为 IDP 和 SP 都是 Google。</p>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="初步认识"><a href="#初步认识" class="headerlink" title="初步认识"></a>初步认识</h3><p>本质上来说 JWT 也是 token，正如我们在上文提到的，它是 <strong>访问资源</strong> 的 <strong>凭证</strong>。<br>Google 的一些 API 诸如 Prediction API 或者 Google Cloud Storage，是不需要 <strong>访问</strong> 用户的 <strong>个人数据</strong> 的。因而不需要经过 <strong>用户的授权</strong> 这一步骤，应用程序可以直接访问。就像上面 OAuth 中没有 Client 没有参与的流程类似。这就要借助 JWT 完成访问了, 具体流程如下：</p>
<p><img src="http://image.winrains.cn/2019/08/20190822161312-3f765.jpeg" alt="浅谈SAML, OAuth, OpenID和SSO, JWT和Session，不了解一下吗？"></p>
<ol>
<li>首先需要在 Google API 上创建一个服务账号（service account）。</li>
<li>获取 <strong>服务账号</strong> 的 <strong>认证信息</strong>（credential），包括 <strong>邮箱地址</strong>，client ID，以及一对 <strong>公钥/私钥</strong>。</li>
<li>使用 Client ID 和 <strong>私钥</strong> 创一个 <strong>签名</strong> 的 JWT，然后将这个 JWT 发送给 Google 交换 access token。</li>
<li>Google 返回 access token。</li>
<li>程序通过 access token 访问 API。</li>
</ol>
<p>甚至你可以不需要向 Google 索要 access token，而是携带 JWT 作为 HTTP header 里的 bearer token 直接访问 API 也是可以的。这才是 JWT 的最大魅力。</p>
<h3 id="理性认识"><a href="#理性认识" class="headerlink" title="理性认识"></a>理性认识</h3><p>JWT 顾名思义，它是 JSON 结构的 token，由三部分组成：</p>
<ul>
<li><strong>header</strong></li>
<li><strong>payload</strong></li>
<li><strong>signature</strong></li>
</ul>
<p>header<br>header 用于描述 <strong>元信息</strong>，例如产生 signature 的算法：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attr">"typ"</span>: <span class="string">"JWT"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attr">"alg"</span>: <span class="string">"HS256"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其中 alg 关键字就指定了使用哪一种 <strong>哈希算法</strong> 来创建 signature。<br>payload<br>payload 用于携带你希望 <strong>向服务端传递</strong> 的信息。你既可以往里添加 <strong>官方字段</strong>，例如：iss(Issuer), sub(Subject), exp(Expirationtime)，也可以塞入 <strong>自定义的字段</strong>，比如 userId:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attr">"userId"</span>: <span class="string">"b08f86af-35da-48f2-8fab-cef3904660bd"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>signature<br>signature 译为 <strong>签名</strong>，创建签名要分以下几个步骤：</p>
<ol>
<li>从 <strong>接口服务端</strong> 拿到 <strong>密钥</strong>，假设为 secret。</li>
<li>对 header 进行 base64 编码，假设结果为 headerStr。</li>
<li>将 payload 进行 base64 编码，假设结果为 payloadStr。</li>
<li>将 headerStr 和 payloadStr 用 . <strong>字符</strong> 拼装起来成为字符 data。</li>
<li>以 data 和 secret 作为参数，使用 <strong>哈希算法</strong> 计算出 <strong>签名</strong>。</li>
</ol>
<p>如果上述描述还不直观，用 <strong>伪代码</strong> 表示就是：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Signature algorithm</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">data = base64url<span class="constructor">Encode( <span class="params">header</span> )</span> + “.” + base64url<span class="constructor">Encode( <span class="params">payload</span> )</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">signature = <span class="constructor">Hash( <span class="params">data</span>, <span class="params">secret</span> )</span>;</span></pre></td></tr></table></figure>

<p>假设我们的原始 JSON 结构是这样的：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Header</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attr">"typ"</span>: <span class="string">"JWT"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="attr">"alg"</span>: <span class="string">"HS256"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Payload</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="attr">"userId"</span>: <span class="string">"b08f86af-35da-48f2-8fab-cef3904660bd"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如果 <strong>密钥</strong> 是字符串 secret 的话，那么最终 JWT 的结果就是这样的：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">eyJ<span class="number">0</span>eXAiOiJKV<span class="number">1</span>QiLCJhbGciOiJIUzI<span class="number">1</span>NiJ<span class="number">9</span>.eyJ<span class="number">1</span><span class="keyword">c</span><span class="number">2</span>VySWQiOiJiMDhmODZhZ<span class="keyword">i0</span>zNWRhLTQ<span class="number">4</span>ZjItOGZhY<span class="keyword">i1</span>jZWYzOTA<span class="number">0</span>NjYwYmQifQ.-xN_h<span class="number">82</span>PHVTCMA<span class="number">9</span>vdoHrcZxH-<span class="keyword">x</span><span class="number">5</span>mb<span class="number">11</span>y<span class="number">1537</span>t<span class="number">3</span>rGzcM</span></pre></td></tr></table></figure>

<p>可以在 jwt.io 上 <strong>验证</strong> 这个结果。</p>
<h3 id="JWT究竟带来了什么"><a href="#JWT究竟带来了什么" class="headerlink" title="JWT究竟带来了什么"></a>JWT究竟带来了什么</h3><p>确保数据完整性<br>JWT 的目的不是为了 <strong>隐藏</strong> 或者 <strong>保密数据</strong>，而是为了确保 <strong>数据</strong> 确实来自被 <strong>授权的人</strong> 创建的，以防止 <strong>中途篡改</strong>。<br>回想一下，当你拿到 JWT 时候，你完全可以在没有 secret 的情况下解码出 header 和 payload，因为 header 和 payload 只是经过了 base64 编码（encode）而已，编码的目的在于 <strong>利于数据结构的传输</strong>。<br>虽然创建 signature 的过程近似于 <strong>加密</strong> (encrypt)，但本质其实是一种 <strong>签名</strong> (sign) 的行为，用于保证 <strong>数据的完整性</strong>，实际上也并且并 <strong>没有加密任何数据</strong>。<br>用于接口调用<br>接下来在 API 调用中就可以附上 JWT（通常是在 HTTP Header 中）。又因为 SP 会与程序 <strong>共享</strong> 一个 secret，所以 <strong>程序</strong> 可以通过 header 提供的相同的 hash 算法来 <strong>验证签名</strong> 是否正确，从而判断应用是否有权力调用 API。<br>有状态的对话Session<br>因为 HTTP 是 <strong>无状态</strong> 的，所以 <strong>客户端</strong> 和 <strong>服务端</strong> 需要解决的问题是，如何让它们之间的对话变得有状态。例如只有是 <strong>登陆状态</strong> 的 <strong>用户</strong> 才有权限调用某些接口，那么在 <strong>用户登陆</strong> 之后，需要记住该用户是 <strong>已经登陆</strong> 的状态。常见的方法是使用 session 机制。<br>常见的 session 模型是这样工作的：</p>
<p><img src="http://image.winrains.cn/2019/08/20190822161312-63b4a.jpeg" alt="浅谈SAML, OAuth, OpenID和SSO, JWT和Session，不了解一下吗？"></p>
<ol>
<li>用户在浏览器 <strong>登陆</strong> 之后，服务端为用户生成 <strong>唯一</strong> 的 session id，存储在 <strong>服务端</strong> 的 <strong>存储服务</strong>（例如 MySQL, Redis）中。</li>
<li>该 session id 也同时 <strong>返回给浏览器</strong>，以 SESSION_ID 为 KEY 存储在浏览器的 cookie 中。</li>
<li>如果用户再次访问该网站，cookie 里的 SESSION_ID 会随着 <strong>请求</strong> 一同发往 <strong>服务端</strong>。</li>
<li>服务端通过判断 SESSION_ID 是否已经在 Redis 中判断用户是否处于 <strong>登陆状态</strong>。</li>
</ol>
<p>相信你已经察觉了，理论上来说，JWT 机制可以取代 session 机制。用户不需要提前进行登陆，后端也不需要 Redis 记录用户的登陆信息。客户端的本地保存一份合法的 JWT，当用户需要调用接口时，附带上该合法的 JWT，每一次调用接口，后端都使用请求中附带的 JWT 做一次 <strong>合法性的验证</strong>。这样也间接达到了 <strong>认证用户</strong> 的目的。</p>
<blockquote>
<p>作者：程序猿的内心独白</p>
<p>来源：<a href="https://www.toutiao.com/i6682893136332587528/" target="_blank" rel="noopener">https://www.toutiao.com/i6682893136332587528/</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JWT/" rel="tag"># JWT</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/27/Maven%E5%92%8CGradle%E5%AF%B9%E6%AF%94/" rel="prev" title="Maven和Gradle对比">
      <i class="fa fa-chevron-left"></i> Maven和Gradle对比
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/27/%E5%A4%A7%E5%9E%8BWeb%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98%E4%B9%8B9%E5%A4%A7%E9%98%B6%E6%AE%B5/" rel="next" title="大型Web网站架构演变之9大阶段">
      大型Web网站架构演变之9大阶段 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#正文"><span class="nav-number">2.</span> <span class="nav-text">正文</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#关于Token"><span class="nav-number">2.1.</span> <span class="nav-text">关于Token</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OAuth-2-0"><span class="nav-number">2.1.1.</span> <span class="nav-text">OAuth 2.0</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SSO-Single-sign-on"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">SSO (Single sign-on)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Authentication-VS-Authorisation"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">Authentication VS Authorisation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SAML-2-0"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">SAML 2.0</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OAuth-2-0-1"><span class="nav-number">2.2.</span> <span class="nav-text">OAuth 2.0</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OAuth-VS-OpenId"><span class="nav-number">2.3.</span> <span class="nav-text">OAuth VS OpenId</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Refresh-Token"><span class="nav-number">2.4.</span> <span class="nav-text">Refresh Token</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JWT"><span class="nav-number">2.5.</span> <span class="nav-text">JWT</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初步认识"><span class="nav-number">2.5.1.</span> <span class="nav-text">初步认识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理性认识"><span class="nav-number">2.5.2.</span> <span class="nav-text">理性认识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JWT究竟带来了什么"><span class="nav-number">2.5.3.</span> <span class="nav-text">JWT究竟带来了什么</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">winrains</p>
  <div class="site-description" itemprop="description">淡泊明志</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">469</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">82</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">108</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">winrains</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
