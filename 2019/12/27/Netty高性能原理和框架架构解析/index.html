<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://congsheng.wang').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="1、引言Netty 是一个广受欢迎的异步事件驱动的Java开源网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。本文基于 Netty 4.1 展开介绍相关理论模型，使用场景，基本组件、整体架构，知其然且知其所以然，希望给大家在实际开发实践、学习开源项目方面提供参考。本文作者的另两篇《高性能网络编程(五)：一文读懂高性能网络编程中的I&#x2F;O模型》、《高性能网络编程(六)：一文读懂高性能网">
<meta name="keywords" content="高性能">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty高性能原理和框架架构解析">
<meta property="og:url" content="http:&#x2F;&#x2F;congsheng.wang&#x2F;2019&#x2F;12&#x2F;27&#x2F;Netty%E9%AB%98%E6%80%A7%E8%83%BD%E5%8E%9F%E7%90%86%E5%92%8C%E6%A1%86%E6%9E%B6%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90&#x2F;index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="1、引言Netty 是一个广受欢迎的异步事件驱动的Java开源网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。本文基于 Netty 4.1 展开介绍相关理论模型，使用场景，基本组件、整体架构，知其然且知其所以然，希望给大家在实际开发实践、学习开源项目方面提供参考。本文作者的另两篇《高性能网络编程(五)：一文读懂高性能网络编程中的I&#x2F;O模型》、《高性能网络编程(六)：一文读懂高性能网">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;abf27-221221fh9r6h6r7wzoh9hi.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;d5f1a-221307gaaaj1zdzkv0dr60.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;e7ec7-221327oisbipbowoc1iolo.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;4a100-221754vh8am78hk6bhat7b.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;e7d70-221944dt7zeenn88zz8m7e.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;5b642-222227f7qcpolpiiwuipuj.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;1bbfc-222622tdflgmgojm6b6ogb.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;56391-223156rsmnjdwsn9m9qw6m.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;420e1-223208d868dge5580qdg6g.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;5cf97-223554nm0xvs0i0zso9fof.jpg">
<meta property="og:updated_time" content="2019-12-27T08:20:07.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;abf27-221221fh9r6h6r7wzoh9hi.jpg">

<link rel="canonical" href="http://congsheng.wang/2019/12/27/Netty%E9%AB%98%E6%80%A7%E8%83%BD%E5%8E%9F%E7%90%86%E5%92%8C%E6%A1%86%E6%9E%B6%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Netty高性能原理和框架架构解析 | 个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">winrains的个人博客</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">108</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">83</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">489</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://congsheng.wang/2019/12/27/Netty%E9%AB%98%E6%80%A7%E8%83%BD%E5%8E%9F%E7%90%86%E5%92%8C%E6%A1%86%E6%9E%B6%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="winrains">
      <meta itemprop="description" content="淡泊明志">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Netty高性能原理和框架架构解析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-27 16:20:07" itemprop="dateCreated datePublished" datetime="2019-12-27T16:20:07+08:00">2019-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B6%E5%AE%83%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">其它技术</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B6%E5%AE%83%E6%8A%80%E6%9C%AF/Netty/" itemprop="url" rel="index">
                    <span itemprop="name">Netty</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h2><p><a href="https://netty.io/" target="_blank" rel="noopener">Netty</a> 是一个广受欢迎的异步事件驱动的Java开源网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。<br>本文基于 <a href="https://netty.io/" target="_blank" rel="noopener">Netty 4.1</a> 展开介绍相关理论模型，使用场景，基本组件、整体架构，知其然且知其所以然，希望给大家在实际开发实践、学习开源项目方面提供参考。<br>本文作者的另两篇《<a href="http://www.52im.net/thread-1935-1-1.html" target="_blank" rel="noopener">高性能网络编程(五)：一文读懂高性能网络编程中的I/O模型</a>》、《<a href="http://www.52im.net/thread-1939-1-1.html" target="_blank" rel="noopener">高性能网络编程(六)：一文读懂高性能网络编程中的线程模型</a>》也写的很好，有兴趣的读者可以一并看看。<br><strong>关于作者：</strong><br>陈彩华(caison)，从事服务端开发，善于系统设计、优化重构、线上问题排查工作，主要开发语言是 Java，微信号：hua1881375。</p>
<a id="more"></a>

<h2 id="2、相关资料"><a href="#2、相关资料" class="headerlink" title="2、相关资料"></a>2、相关资料</h2><p><strong>Netty源码在线阅读：</strong></p>
<ul>
<li>Netty-4.1.x地址是：<a href="http://docs.52im.net/extend/docs/src/netty4_1/" target="_blank" rel="noopener">http://docs.52im.net/extend/docs/src/netty4_1/</a></li>
<li>Netty-4.0.x地址是：<a href="http://docs.52im.net/extend/docs/src/netty4/" target="_blank" rel="noopener">http://docs.52im.net/extend/docs/src/netty4/</a></li>
<li>Netty-3.x地址是：<a href="http://docs.52im.net/extend/docs/src/netty3/" target="_blank" rel="noopener">http://docs.52im.net/extend/docs/src/netty3/</a></li>
</ul>
<p><strong>Netty在线API文档：</strong></p>
<ul>
<li>Netty-4.1.x API文档(在线版)：<a href="http://docs.52im.net/extend/docs/api/netty4_1/" target="_blank" rel="noopener">http://docs.52im.net/extend/docs/api/netty4_1/</a></li>
<li>Netty-4.0.x API文档(在线版)：<a href="http://docs.52im.net/extend/docs/api/netty4/" target="_blank" rel="noopener">http://docs.52im.net/extend/docs/api/netty4/</a></li>
<li>Netty-3.x API文档(在线版)：<a href="http://docs.52im.net/extend/docs/api/netty3/" target="_blank" rel="noopener">http://docs.52im.net/extend/docs/api/netty3/</a></li>
</ul>
<p><strong>有关Netty的其它精华文章：</strong></p>
<ul>
<li>《<a href="http://www.52im.net/thread-163-1-1.html" target="_blank" rel="noopener">有关“为何选择Netty”的11个疑问及解答</a>》</li>
<li>《<a href="http://www.52im.net/thread-153-1-1.html" target="_blank" rel="noopener">开源NIO框架八卦——到底是先有MINA还是先有Netty?</a>》</li>
<li>《<a href="http://www.52im.net/thread-96-1-1.html" target="_blank" rel="noopener">选Netty还是Mina：深入研究与对比（一）</a>》</li>
<li>《<a href="http://www.52im.net/thread-101-1-1.html" target="_blank" rel="noopener">选Netty还是Mina：深入研究与对比（二）</a>》</li>
<li>《<a href="http://www.52im.net/thread-99-1-1.html" target="_blank" rel="noopener">Netty 4.x学习（一）：ByteBuf详解</a>》</li>
<li>《<a href="http://www.52im.net/thread-100-1-1.html" target="_blank" rel="noopener">Netty 4.x学习（二）：Channel和Pipeline详解</a>》</li>
<li>《<a href="http://www.52im.net/thread-98-1-1.html" target="_blank" rel="noopener">Netty 4.x学习（三）：线程模型详解</a>》</li>
<li>《<a href="http://www.52im.net/thread-181-1-1.html" target="_blank" rel="noopener">实践总结：Netty3.x升级Netty4.x遇到的那些坑（线程篇）</a>》</li>
<li>《<a href="http://www.52im.net/thread-184-1-1.html" target="_blank" rel="noopener">实践总结：Netty3.x VS Netty4.x的线程模型</a>》</li>
<li>《<a href="http://www.52im.net/thread-426-1-1.html" target="_blank" rel="noopener">详解Netty的安全性：原理介绍、代码演示（上篇）</a>》</li>
<li>《<a href="http://www.52im.net/thread-427-1-1.html" target="_blank" rel="noopener">详解Netty的安全性：原理介绍、代码演示（下篇）</a>》</li>
<li>《<a href="http://www.52im.net/thread-348-1-1.html" target="_blank" rel="noopener">详解Netty的优雅退出机制和原理</a>》</li>
<li>《<a href="http://www.52im.net/thread-400-1-1.html" target="_blank" rel="noopener">NIO框架详解：Netty的高性能之道</a>》</li>
<li>《<a href="http://www.52im.net/thread-97-1-1.html" target="_blank" rel="noopener">Twitter：如何使用Netty 4来减少JVM的GC开销（译文）</a>》</li>
<li>《<a href="http://www.52im.net/thread-166-1-1.html" target="_blank" rel="noopener">绝对干货：基于Netty实现海量接入的推送服务技术要点</a>》</li>
<li>《<a href="http://www.52im.net/thread-1243-1-1.html" target="_blank" rel="noopener">Netty干货分享：京东京麦的生产级TCP网关技术实践总结</a>》</li>
</ul>
<h2 id="3、JDK-原生-NIO-程序的问题"><a href="#3、JDK-原生-NIO-程序的问题" class="headerlink" title="3、JDK 原生 NIO 程序的问题"></a>3、JDK 原生 NIO 程序的问题</h2><p><strong>JDK 原生也有一套网络应用程序 API，但是存在一系列问题，主要如下：</strong></p>
<ul>
<li>1）NIO 的类库和 API 繁杂，使用麻烦：你需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等。</li>
<li>2）需要具备其他的额外技能做铺垫：例如熟悉 Java 多线程编程，因为 NIO 编程涉及到 Reactor 模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的 NIO 程序。</li>
<li>3）可靠性能力补齐，开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等。NIO 编程的特点是功能开发相对容易，但是可靠性能力补齐工作量和难度都非常大。</li>
<li>4）JDK NIO 的 Bug：例如臭名昭著的 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU 100%。官方声称在 JDK 1.6 版本的 update 18 修复了该问题，但是直到 JDK 1.7 版本该问题仍旧存在，只不过该 Bug 发生概率降低了一些而已，它并没有被根本解决。</li>
</ul>
<h2 id="4、Netty-的特点"><a href="#4、Netty-的特点" class="headerlink" title="4、Netty 的特点"></a>4、Netty 的特点</h2><p>Netty 对 JDK 自带的 NIO 的 API 进行了封装，解决了上述问题。<br><strong>Netty的主要特点有：</strong></p>
<ul>
<li>1）设计优雅：适用于各种传输类型的统一 API 阻塞和非阻塞 Socket；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型 - 单线程，一个或多个线程池；真正的无连接数据报套接字支持（自 3.1 起）。</li>
<li>2）使用方便：详细记录的 Javadoc，用户指南和示例；没有其他依赖项，JDK 5（Netty 3.x）或 6（Netty 4.x）就足够了。</li>
<li>3）高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。</li>
<li>4）安全：完整的 SSL/TLS 和 StartTLS 支持。</li>
<li>5）社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 Bug 可以被及时修复，同时，更多的新功能会被加入。</li>
</ul>
<h2 id="5、Netty-常见使用场景"><a href="#5、Netty-常见使用场景" class="headerlink" title="5、Netty 常见使用场景"></a>5、Netty 常见使用场景</h2><p><strong>Netty 常见的使用场景如下：</strong></p>
<ul>
<li>1）互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的 RPC 框架必不可少，Netty 作为异步高性能的通信框架，往往作为基础通信组件被这些 RPC 框架使用。典型的应用有：阿里分布式服务框架 Dubbo 的 RPC 框架使用 Dubbo 协议进行节点间通信，Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现各进程节点之间的内部通信。</li>
<li>2）游戏行业：无论是手游服务端还是大型的网络游戏，Java 语言得到了越来越广泛的应用。Netty 作为高性能的基础通信组件，它本身提供了 TCP/UDP 和 HTTP 协议栈。</li>
<li>非常方便定制和开发私有协议栈，账号登录服务器，地图服务器之间可以方便的通过 Netty 进行高性能的通信。</li>
<li>3）大数据领域：经典的 Hadoop 的高性能通信和序列化组件 Avro 的 RPC 框架，默认采用 Netty 进行跨界点通信，它的 Netty Service 基于 Netty 框架二次封装实现。</li>
</ul>
<p>有兴趣的读者可以了解一下目前有哪些开源项目使用了 <a href="https://netty.io/wiki/related-projects.html" target="_blank" rel="noopener">Netty的Related Projects</a>。</p>
<h2 id="6、Netty-高性能设计"><a href="#6、Netty-高性能设计" class="headerlink" title="6、Netty 高性能设计"></a>6、Netty 高性能设计</h2><p>Netty 作为异步事件驱动的网络，高性能之处主要来自于其 I/O 模型和线程处理模型，前者决定如何收发数据，后者决定如何处理数据。</p>
<h3 id="6-1I-O-模型"><a href="#6-1I-O-模型" class="headerlink" title="6.1I/O 模型"></a>6.1I/O 模型</h3><p>用什么样的通道将数据发送给对方，<a href="http://www.52im.net/thread-306-1-1.html" target="_blank" rel="noopener">BIO、NIO 或者 AIO</a>，I/O 模型在很大程度上决定了框架的性能。<br><strong><em>【阻塞 I/O】：\</em></strong><br>传统阻塞型 I/O(BIO)可以用下图表示：<br><img src="http://image.winrains.cn/2019/09/abf27-221221fh9r6h6r7wzoh9hi.jpg" alt="新手入门：目前为止最透彻的的Netty高性能原理和框架架构解析_1.jpg"><br>特点如下：</p>
<ul>
<li>每个请求都需要独立的线程完成数据 Read，业务处理，数据 Write 的完整操作问题。</li>
<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费。</li>
</ul>
<p><strong><em>【I/O 复用模型】：\</em></strong><br><img src="http://image.winrains.cn/2019/09/d5f1a-221307gaaaj1zdzkv0dr60.jpg" alt="新手入门：目前为止最透彻的的Netty高性能原理和框架架构解析_2.jpg"><br>在 I/O 复用模型中，会用到 Select，这个函数也会使进程阻塞，但是和阻塞 I/O 所不同的是这两个函数可以同时阻塞多个 I/O 操作。<br>而且可以同时对多个读操作，多个写操作的 I/O 函数进行检测，直到有数据可读或可写时，才真正调用 I/O 操作函数。<br>Netty 的非阻塞 I/O 的实现关键是基于 I/O 复用模型，这里用 Selector 对象表示：<br><img src="http://image.winrains.cn/2019/09/e7ec7-221327oisbipbowoc1iolo.jpg" alt="新手入门：目前为止最透彻的的Netty高性能原理和框架架构解析_3.jpg"><br>Netty 的 IO 线程 NioEventLoop 由于聚合了多路复用器 Selector，可以同时并发处理成百上千个客户端连接。<br>当线程从某客户端 Socket 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。<br>线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。<br>由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于频繁 I/O 阻塞导致的线程挂起。<br>一个 I/O 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 I/O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。<br><strong><em>【基于 Buffer】：\</em></strong><br>传统的 I/O 是面向字节流或字符流的，以流式的方式顺序地从一个 Stream 中读取一个或多个字节, 因此也就不能随意改变读取指针的位置。<br>在 NIO 中，抛弃了传统的 I/O 流，而是引入了 Channel 和 Buffer 的概念。在 NIO 中，只能从 Channel 中读取数据到 Buffer 中或将数据从 Buffer 中写入到 Channel。<br>基于 Buffer 操作不像传统 IO 的顺序操作，NIO 中可以随意地读取任意位置的数据。</p>
<h3 id="6-2线程模型"><a href="#6-2线程模型" class="headerlink" title="6.2线程模型"></a>6.2线程模型</h3><p>数据报如何读取？读取之后的编解码在哪个线程进行，编解码后的消息如何派发，线程模型的不同，对性能的影响也非常大。<br><strong><em>【事件驱动模型】：\</em></strong><br>通常，我们设计一个事件处理模型的程序有两种思路：</p>
<ul>
<li>1）轮询方式：线程不断轮询访问相关事件发生源有没有发生事件，有发生事件就调用事件处理逻辑；</li>
<li>2）事件驱动方式：发生事件，主线程把事件放入事件队列，在另外线程不断循环消费事件列表中的事件，调用事件对应的处理逻辑处理事件。事件驱动方式也被称为消息通知方式，其实是设计模式中观察者模式的思路。</li>
</ul>
<p>以 GUI 的逻辑处理为例，说明两种逻辑的不同：</p>
<ul>
<li>1）轮询方式：线程不断轮询是否发生按钮点击事件，如果发生，调用处理逻辑。</li>
<li>2）事件驱动方式：发生点击事件把事件放入事件队列，在另外线程消费的事件列表中的事件，根据事件类型调用相关事件处理逻辑。</li>
</ul>
<p>这里借用 O’Reilly 大神关于事件驱动模型解释图：<br><img src="http://image.winrains.cn/2019/09/4a100-221754vh8am78hk6bhat7b.jpg" alt="新手入门：目前为止最透彻的的Netty高性能原理和框架架构解析_4.jpg"><br>主要包括 4 个基本组件：</p>
<ul>
<li>1）事件队列（event queue）：接收事件的入口，存储待处理事件；</li>
<li>2）分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元；</li>
<li>3）事件通道（event channel）：分发器与处理器之间的联系渠道；</li>
<li>4）事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作。</li>
</ul>
<p>可以看出，相对传统轮询模式，事件驱动有如下优点：</p>
<ul>
<li>1）可扩展性好：分布式的异步架构，事件处理器之间高度解耦，可以方便扩展事件处理逻辑；</li>
<li>2）高性能：基于队列暂存事件，能方便并行异步处理事件。</li>
</ul>
<p><strong><em>【Reactor 线程模型】：\</em></strong><br>Reactor 是反应堆的意思，Reactor 模型是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。<br>服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor 模式也叫 Dispatcher 模式，即 I/O 多了复用统一监听事件，收到事件后分发(Dispatch 给某进程)，是编写高性能网络服务器的必备技术之一。<br>Reactor 模型中有 2 个关键组成：</p>
<ul>
<li>1）Reactor：Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 IO 事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；</li>
<li>2）Handlers：处理程序执行 I/O 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor 通过调度适当的处理程序来响应 I/O 事件，处理程序执行非阻塞操作。</li>
</ul>
<p><img src="http://image.winrains.cn/2019/09/e7d70-221944dt7zeenn88zz8m7e.jpg" alt="新手入门：目前为止最透彻的的Netty高性能原理和框架架构解析_5.jpg"><br>取决于 Reactor 的数量和 Hanndler 线程数量的不同，Reactor 模型有 3 个变种：</p>
<ul>
<li>1）单 Reactor 单线程；</li>
<li>2）单 Reactor 多线程；</li>
<li>3）主从 Reactor 多线程。</li>
</ul>
<p>可以这样理解，Reactor 就是一个执行 while (true) { selector.select(); …} 循环的线程，会源源不断的产生新的事件，称作反应堆很贴切。<br>篇幅关系，这里不再具体展开 Reactor 特性、优缺点比较，有兴趣的读者可以参考我之前另外一篇文章：《<a href="http://www.52im.net/thread-1935-1-1.html" target="_blank" rel="noopener">高性能网络编程(五)：一文读懂高性能网络编程中的I/O模型</a>》、《<a href="http://www.52im.net/thread-1939-1-1.html" target="_blank" rel="noopener">高性能网络编程(六)：一文读懂高性能网络编程中的线程模型</a>》。<br><strong><em>【Netty 线程模型】：\</em></strong><br>Netty 主要基于主从 Reactors 多线程模型（如下图）做了一定的修改，其中主从 Reactor 多线程模型有多个 Reactor：</p>
<ul>
<li>1）MainReactor 负责客户端的连接请求，并将请求转交给 SubReactor；</li>
<li>2）SubReactor 负责相应通道的 IO 读写请求；</li>
<li>3）非 IO 请求（具体逻辑处理）的任务则会直接写入队列，等待 worker threads 进行处理。</li>
</ul>
<p>这里引用 Doug Lee 大神的 Reactor 介绍——Scalable IO in Java 里面关于主从 Reactor 多线程模型的图：<br><img src="http://image.winrains.cn/2019/09/5b642-222227f7qcpolpiiwuipuj.jpg" alt="新手入门：目前为止最透彻的的Netty高性能原理和框架架构解析_6.jpg"><br><strong>特别说明的是：</strong>虽然 Netty 的线程模型基于主从 Reactor 多线程，借用了 MainReactor 和 SubReactor 的结构。但是实际实现上 SubReactor 和 Worker 线程在同一个线程池中：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = new NioEventLoopGroup();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">EventLoopGroup workerGroup = new NioEventLoopGroup();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">ServerBootstrap<span class="built_in"> server </span>= new ServerBootstrap();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">server.group(bossGroup, workerGroup)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">.channel(NioServerSocketChannel.class)</span></pre></td></tr></table></figure>

<p>上面代码中的 bossGroup 和 workerGroup 是 Bootstrap 构造方法中传入的两个对象，这两个 group 均是线程池：</p>
<ul>
<li>1）bossGroup 线程池则只是在 Bind 某个端口后，获得其中一个线程作为 MainReactor，专门处理端口的 Accept 事件，每个端口对应一个 Boss 线程；</li>
<li>2）workerGroup 线程池会被各个 SubReactor 和 Worker 线程充分利用。</li>
</ul>
<p><strong><em>【异步处理】：\</em></strong><br>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。<br>Netty 中的 I/O 操作是异步的，包括 Bind、Write、Connect 等操作会简单的返回一个 ChannelFuture。<br>调用者并不能立刻获得结果，而是通过 Future-Listener 机制，用户可以方便的主动获取或者通过通知机制获得 IO 操作结果。<br>当 Future 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 ChannelFuture 来获取操作执行的状态，注册监听函数来执行完成后的操作。<br>常见有如下操作：</p>
<ul>
<li>1）通过 isDone 方法来判断当前操作是否完成；</li>
<li>2）通过 isSuccess 方法来判断已完成的当前操作是否成功；</li>
<li>3）通过 getCause 方法来获取已完成的当前操作失败的原因；</li>
<li>4）通过 isCancelled 方法来判断已完成的当前操作是否被取消；</li>
<li>5）通过 addListener 方法来注册监听器，当操作已完成(isDone 方法返回完成)，将会通知指定的监听器；如果 Future 对象已完成，则理解通知指定的监听器。</li>
</ul>
<p>例如下面的代码中绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">serverBootstrap.bind(port).addListener(future -&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (future.isSuccess()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">       System.out.println(new Date() + <span class="string">": 端口["</span> +<span class="built_in"> port </span>+ <span class="string">"]绑定成功!"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">   &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">       System.err.println(<span class="string">"端口["</span> +<span class="built_in"> port </span>+ <span class="string">"]绑定失败!"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>相比传统阻塞 I/O，执行 I/O 操作后线程会被阻塞住, 直到操作完成；异步处理的好处是不会造成线程阻塞，线程在 I/O 操作期间可以执行别的程序，在高并发情形下会更稳定和更高的吞吐量。</p>
<h2 id="7、Netty框架的架构设计"><a href="#7、Netty框架的架构设计" class="headerlink" title="7、Netty框架的架构设计"></a>7、Netty框架的架构设计</h2><p>前面介绍完 Netty 相关一些理论，下面从功能特性、模块组件、运作过程来介绍 Netty 的架构设计。</p>
<h3 id="7-1功能特性-Netty-功能特性如下："><a href="#7-1功能特性-Netty-功能特性如下：" class="headerlink" title="7.1功能特性 Netty 功能特性如下："></a>7.1功能特性<img src="http://image.winrains.cn/2019/09/1bbfc-222622tdflgmgojm6b6ogb.jpg" alt="新手入门：目前为止最透彻的的Netty高性能原理和框架架构解析_7.jpg"> <strong>Netty 功能特性如下：</strong></h3><ul>
<li>1）传输服务：支持 BIO 和 NIO；</li>
<li>2）容器集成：支持 OSGI、JBossMC、Spring、Guice 容器；</li>
<li>3）协议支持：HTTP、Protobuf、二进制、文本、WebSocket 等一系列常见协议都支持。还支持通过实行编码解码逻辑来实现自定义协议；</li>
<li>4）Core 核心：可扩展事件模型、通用通信 API、支持零拷贝的 ByteBuf 缓冲对象。</li>
</ul>
<h3 id="7-2模块组件"><a href="#7-2模块组件" class="headerlink" title="7.2模块组件"></a>7.2模块组件</h3><p><strong><em>【Bootstrap、ServerBootstrap】：\</em></strong><br>Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联各个组件，Netty 中 Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类。<br><strong><em>【Future、ChannelFuture】：\</em></strong><br>正如前面介绍，在 Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。<br>但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 Future 和 ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。<br><strong><em>【Channel】：\</em></strong><br>Netty 网络通信的组件，能够用于执行网络 I/O 操作。Channel 为用户提供：</p>
<ul>
<li>1）当前网络连接的通道的状态（例如是否打开？是否已连接？）</li>
<li>2）网络连接的配置参数 （例如接收缓冲区大小）</li>
<li>3）提供异步的网络 I/O 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 I/O 调用都将立即返回，并且不保证在调用结束时所请求的 I/O 操作已完成。</li>
<li>4）调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I/O 操作成功、失败或取消时回调通知调用方。</li>
<li>5）支持关联 I/O 操作与对应的处理程序。</li>
</ul>
<p>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应。<br>下面是一些常用的 Channel 类型：</p>
<ul>
<li>NioSocketChannel，异步的客户端 TCP Socket 连接。</li>
<li>NioServerSocketChannel，异步的服务器端 TCP Socket 连接。</li>
<li>NioDatagramChannel，异步的 UDP 连接。</li>
<li>NioSctpChannel，异步的客户端 Sctp 连接。</li>
<li>NioSctpServerChannel，异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。</li>
</ul>
<p><strong><em>【Selector】：</em></strong><br>Netty 基于 Selector 对象实现 I/O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件。<br>当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询(Select) 这些注册的 Channel 是否有已就绪的 I/O 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 Channel 。<br><strong><em>【NioEventLoop】：\</em></strong><br>NioEventLoop 中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用 NioEventLoop 的 run 方法，执行 I/O 任务和非 I/O 任务：</p>
<ul>
<li>I/O 任务，即 selectionKey 中 ready 的事件，如 accept、connect、read、write 等，由 processSelectedKeys 方法触发。</li>
<li>非 IO 任务，添加到 taskQueue 中的任务，如 register0、bind0 等任务，由 runAllTasks 方法触发。</li>
</ul>
<p>两种任务的执行时间比由变量 ioRatio 控制，默认为 50，则表示允许非 IO 任务执行的时间与 IO 任务的执行时间相等。<br><strong><em>【NioEventLoopGroup】：\</em></strong><br>NioEventLoopGroup，主要管理 eventLoop 的生命周期，可以理解为一个线程池，内部维护了一组线程，每个线程(NioEventLoop)负责处理多个 Channel 上的事件，而一个 Channel 只对应于一个线程。<br><strong><em>【ChannelHandler】：\</em></strong><br>ChannelHandler 是一个接口，处理 I/O 事件或拦截 I/O 操作，并将其转发到其 ChannelPipeline(业务处理链)中的下一个处理程序。<br>ChannelHandler 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类：</p>
<ul>
<li>ChannelInboundHandler 用于处理入站 I/O 事件。</li>
<li>ChannelOutboundHandler 用于处理出站 I/O 操作。</li>
</ul>
<p>或者使用以下适配器类：</p>
<ul>
<li>ChannelInboundHandlerAdapter 用于处理入站 I/O 事件。</li>
<li>ChannelOutboundHandlerAdapter 用于处理出站 I/O 操作。</li>
<li>ChannelDuplexHandler 用于处理入站和出站事件。</li>
</ul>
<p><strong><em>【ChannelHandlerContext】：\</em></strong><br>保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象。<br><strong><em>【ChannelPipline】：\</em></strong><br>保存 ChannelHandler 的 List，用于处理或拦截 Channel 的入站事件和出站操作。<br>ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 Channel 中各个的 ChannelHandler 如何相互交互。<br>下图引用 Netty 的 Javadoc 4.1 中 ChannelPipeline 的说明，描述了 ChannelPipeline 中 ChannelHandler 通常如何处理 I/O 事件。<br>I/O 事件由 ChannelInboundHandler 或 ChannelOutboundHandler 处理，并通过调用 ChannelHandlerContext 中定义的事件传播方法。<br>例如：ChannelHandlerContext.fireChannelRead（Object）和 ChannelOutboundInvoker.write（Object）转发到其最近的处理程序。<br><img src="http://image.winrains.cn/2019/09/56391-223156rsmnjdwsn9m9qw6m.jpg" alt="新手入门：目前为止最透彻的的Netty高性能原理和框架架构解析_8.jpg"><br>入站事件由自下而上方向的入站处理程序处理，如图左侧所示。入站 Handler 处理程序通常处理由图底部的 I/O 线程生成的入站数据。<br>通常通过实际输入操作（例如 SocketChannel.read（ByteBuffer））从远程读取入站数据。<br>出站事件由上下方向处理，如图右侧所示。出站 Handler 处理程序通常会生成或转换出站传输，例如 write 请求。<br>I/O 线程通常执行实际的输出操作，例如 SocketChannel.write（ByteBuffer）。<br>在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下：<br><img src="http://image.winrains.cn/2019/09/420e1-223208d868dge5580qdg6g.jpg" alt="新手入门：目前为止最透彻的的Netty高性能原理和框架架构解析_9.jpg"><br>一个 Channel 包含了一个 ChannelPipeline，而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表，并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler。<br>入站事件和出站事件在一个双向链表中，入站事件会从链表 head 往后传递到最后一个入站的 handler，出站事件会从链表 tail 往前传递到最前一个出站的 handler，两种类型的 handler 互不干扰。</p>
<h2 id="8、Netty框架的工作原理"><a href="#8、Netty框架的工作原理" class="headerlink" title="8、Netty框架的工作原理"></a>8、Netty框架的工作原理</h2><p><strong>典型的初始化并启动 Netty 服务端的过程代码如下：</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 创建mainReactor</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">   NioEventLoopGroup boosGroup = <span class="keyword">new</span> NioEventLoopGroup();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 创建工作线程组</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">   NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">   final ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">   serverBootstrap</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 组装NioEventLoopGroup</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">       .group(boosGroup, workerGroup)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 设置channel类型为NIO类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">       .channel(NioServerSocketChannel.class)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">       <span class="comment">// 设置连接配置参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">       .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">       .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">       .childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">       <span class="comment">// 配置入站、出站事件handler</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">       .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">           @Override</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">           <span class="keyword">protected</span> <span class="keyword">void</span> initChannel(NioSocketChannel ch) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">               <span class="comment">// 配置入站、出站事件channel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">               ch.pipeline().addLast(...);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">               ch.pipeline().addLast(...);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">           &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 绑定端口</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">int</span> port = <span class="number">8080</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">   serverBootstrap.bind(port).addListener(<span class="built_in">future</span> -&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">       <span class="keyword">if</span> (<span class="built_in">future</span>.isSuccess()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">           System.out.<span class="built_in">println</span>(<span class="keyword">new</span> Date() + <span class="string">": 端口["</span> + port + <span class="string">"]绑定成功!"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">       &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">           System.err.<span class="built_in">println</span>(<span class="string">"端口["</span> + port + <span class="string">"]绑定失败!"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">       &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">   &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>基本过程描述如下：</strong></p>
<ul>
<li>1）初始化创建 2 个 NioEventLoopGroup：其中 boosGroup 用于 Accetpt 连接建立事件并分发请求，workerGroup 用于处理 I/O 读写事件和业务逻辑。</li>
<li>2）基于 ServerBootstrap(服务端启动引导类)：配置 EventLoopGroup、Channel 类型，连接参数、配置入站、出站事件 handler。</li>
<li>3）绑定端口：开始工作。</li>
</ul>
<p><strong>结合上面介绍的 Netty Reactor 模型，介绍服务端 Netty 的工作架构图：</strong><br><img src="http://image.winrains.cn/2019/09/5cf97-223554nm0xvs0i0zso9fof.jpg" alt="新手入门：目前为止最透彻的的Netty高性能原理和框架架构解析_19.jpg"><br>Server 端包含 1 个 Boss NioEventLoopGroup 和 1 个 Worker NioEventLoopGroup。<br>NioEventLoopGroup 相当于 1 个事件循环组，这个组里包含多个事件循环 NioEventLoop，每个 NioEventLoop 包含 1 个 Selector 和 1 个事件循环线程。<br><strong>每个 Boss NioEventLoop 循环执行的任务包含 3 步：</strong></p>
<ul>
<li>1）轮询 Accept 事件；</li>
<li>2）处理 Accept I/O 事件，与 Client 建立连接，生成 NioSocketChannel，并将 NioSocketChannel 注册到某个 Worker NioEventLoop 的 Selector 上；</li>
<li>3）处理任务队列中的任务，runAllTasks。任务队列中的任务包括用户调用 eventloop.execute 或 schedule 执行的任务，或者其他线程提交到该 eventloop 的任务。</li>
</ul>
<p><strong>每个 Worker NioEventLoop 循环执行的任务包含 3 步：</strong></p>
<ul>
<li>1）轮询 Read、Write 事件；</li>
<li>2）处理 I/O 事件，即 Read、Write 事件，在 NioSocketChannel 可读、可写事件发生时进行处理；</li>
<li>3）处理任务队列中的任务，runAllTasks。</li>
</ul>
<p><strong>其中任务队列中的 Task 有 3 种典型使用场景：</strong><br><em>① 用户程序自定义的普通任务：</em></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ctx</span><span class="selector-class">.channel</span>()<span class="selector-class">.eventLoop</span>()<span class="selector-class">.execute</span>(new Runnable() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="variable">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">   public void run() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">       <span class="comment">//...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p><em>② 非当前 Reactor 线程调用 Channel 的各种方法：</em></p>
<p>例如在推送系统的业务线程里面，根据用户的标识，找到对应的 Channel 引用，然后调用 Write 类方法向该用户推送消息，就会进入到这种场景。最终的 Write 会提交到任务队列中后被异步消费。<br><em>③ 用户自定义定时任务：</em></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ctx</span><span class="selector-class">.channel</span>()<span class="selector-class">.eventLoop</span>()<span class="selector-class">.schedule</span>(new Runnable() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="variable">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">   public void run() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;, <span class="number">60</span>, TimeUnit.SECONDS);</span></pre></td></tr></table></figure>

<h2 id="9、本文小结"><a href="#9、本文小结" class="headerlink" title="9、本文小结"></a>9、本文小结</h2><p>现在推荐使用的主流稳定版本还是 Netty4，Netty5 中使用了 ForkJoinPool，增加了代码的复杂度，但是对性能的改善却不明显，所以这个版本不推荐使用，官网也没有提供下载链接。<br>Netty 入门门槛相对较高，是因为这方面的资料较少，并不是因为它有多难，大家其实都可以像搞透 Spring 一样搞透 Netty。<br>在学习之前，建议先理解透整个框架原理结构，运行过程，可以少走很多弯路。</p>
<blockquote>
<p>作者：JackJiang</p>
<p>来源：<a href="http://www.52im.net/thread-2043-1-1.html" target="_blank" rel="noopener">http://www.52im.net/thread-2043-1-1.html</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%AB%98%E6%80%A7%E8%83%BD/" rel="tag"># 高性能</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/27/Spring-Session%EF%BC%883%EF%BC%89%EF%BC%9A%E4%B8%8ESpring-Boot%E6%95%B4%E5%90%88%E5%AE%9E%E6%88%98/" rel="prev" title="Spring Session（3）：与Spring Boot整合实战">
      <i class="fa fa-chevron-left"></i> Spring Session（3）：与Spring Boot整合实战
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/27/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84I-O%E6%A8%A1%E5%9E%8B/" rel="next" title="高性能网络编程中的I/O模型">
      高性能网络编程中的I/O模型 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、引言"><span class="nav-number">1.</span> <span class="nav-text">1、引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、相关资料"><span class="nav-number">2.</span> <span class="nav-text">2、相关资料</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、JDK-原生-NIO-程序的问题"><span class="nav-number">3.</span> <span class="nav-text">3、JDK 原生 NIO 程序的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、Netty-的特点"><span class="nav-number">4.</span> <span class="nav-text">4、Netty 的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、Netty-常见使用场景"><span class="nav-number">5.</span> <span class="nav-text">5、Netty 常见使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、Netty-高性能设计"><span class="nav-number">6.</span> <span class="nav-text">6、Netty 高性能设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1I-O-模型"><span class="nav-number">6.1.</span> <span class="nav-text">6.1I/O 模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2线程模型"><span class="nav-number">6.2.</span> <span class="nav-text">6.2线程模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、Netty框架的架构设计"><span class="nav-number">7.</span> <span class="nav-text">7、Netty框架的架构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1功能特性-Netty-功能特性如下："><span class="nav-number">7.1.</span> <span class="nav-text">7.1功能特性 Netty 功能特性如下：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2模块组件"><span class="nav-number">7.2.</span> <span class="nav-text">7.2模块组件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8、Netty框架的工作原理"><span class="nav-number">8.</span> <span class="nav-text">8、Netty框架的工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9、本文小结"><span class="nav-number">9.</span> <span class="nav-text">9、本文小结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">winrains</p>
  <div class="site-description" itemprop="description">淡泊明志</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">489</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">83</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">108</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">winrains</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
