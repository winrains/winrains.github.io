<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://congsheng.wang').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="1、引言RPC对于分布式系统来说，是一项非常有价值的技术。就拿IM系统来说，单实例情况下自然没RPC什么事，最多用用MQ消息中间件就能很好的发挥系统效力。但一旦IM用户规模越来越大，单实例络究有出现拼颈的那一天，那么自然而然就要走到IM集群这一步了。说到IM集群，好像看起来很简单，很多Web后端出身的程序员可能脱口而出——用Nginx解决不就行了？显然不是那么回事，如果你也有这种想法，那么请读一读">
<meta property="og:type" content="article">
<meta property="og:title" content="RPC基本概念、原理和用途">
<meta property="og:url" content="http:&#x2F;&#x2F;congsheng.wang&#x2F;2019&#x2F;12&#x2F;27&#x2F;RPC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%81%E5%8E%9F%E7%90%86%E5%92%8C%E7%94%A8%E9%80%94&#x2F;index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="1、引言RPC对于分布式系统来说，是一项非常有价值的技术。就拿IM系统来说，单实例情况下自然没RPC什么事，最多用用MQ消息中间件就能很好的发挥系统效力。但一旦IM用户规模越来越大，单实例络究有出现拼颈的那一天，那么自然而然就要走到IM集群这一步了。说到IM集群，好像看起来很简单，很多Web后端出身的程序员可能脱口而出——用Nginx解决不就行了？显然不是那么回事，如果你也有这种想法，那么请读一读">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;e45cd-154251yzawfdmyzjmwdfmk.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;b1314-154353il4oswoopuegwl8o.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;39f4a-154830y1p5vjsnzonnnqnn.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;3272b-154846fl6gz8666rv96j8s.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;8ca9c-201832igghnn45nkka93nn.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;d7838-201913ozv4kjvmmrnyj6yj.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;8f384-201943wq5jg0wqnqejfzfx.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;bcf49-202034x4gyv2zglzs226iv.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;48d7f-202433o24ehyc49wn53042.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;c8895-202753b62xqq6b2z6dxy2q.jpg">
<meta property="og:updated_time" content="2019-12-27T09:28:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;09&#x2F;e45cd-154251yzawfdmyzjmwdfmk.jpg">

<link rel="canonical" href="http://congsheng.wang/2019/12/27/RPC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%81%E5%8E%9F%E7%90%86%E5%92%8C%E7%94%A8%E9%80%94/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>RPC基本概念、原理和用途 | 个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">winrains的个人博客</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">108</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">83</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">489</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://congsheng.wang/2019/12/27/RPC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%81%E5%8E%9F%E7%90%86%E5%92%8C%E7%94%A8%E9%80%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="winrains">
      <meta itemprop="description" content="淡泊明志">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RPC基本概念、原理和用途
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-27 17:28:32" itemprop="dateCreated datePublished" datetime="2019-12-27T17:28:32+08:00">2019-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B6%E5%AE%83%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">其它技术</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B6%E5%AE%83%E6%8A%80%E6%9C%AF/RPC/" itemprop="url" rel="index">
                    <span itemprop="name">RPC</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h2><p>RPC对于分布式系统来说，是一项非常有价值的技术。<br>就拿IM系统来说，单实例情况下自然没RPC什么事，最多用用MQ消息中间件就能很好的发挥系统效力。但一旦IM用户规模越来越大，单实例络究有出现拼颈的那一天，那么自然而然就要走到IM集群这一步了。<br>说到IM集群，好像看起来很简单，很多Web后端出身的程序员可能脱口而出——用Nginx解决不就行了？显然不是那么回事，如果你也有这种想法，那么请读一读《<a href="http://www.52im.net/thread-2600-1-1.html" target="_blank" rel="noopener">即时通讯新手入门：一文读懂什么是Nginx？它能否实现IM的负载均衡？</a>》后，再来讨论。</p>
<a id="more"></a>

<p>当然，真正要做到可投入到生产级别的IM集群系统，难度还是相当大的，必竟IM这种长连接应用相比传统Http这种短连接应用太不标准，因而现成可用的技术太少，多数时候只能自已造轮子。以一个典型的IM聊天消息传输为例，假设存在两个正在聊天的用户（用户A和用户B），当A连接的是IM集群中的IM实例1、B连接的是IM集群中的IM实例2，此时当用户A向用户B发送一条聊天消息时，这条消息应该如何传递呢？<br><strong>我们梳理一下这个过程：</strong></p>
<ul>
<li>1）消息首先会由用户A发往IM实例1；</li>
<li>2）IM实例1会将此条消息转交给IM实例2；</li>
<li>3）IM实例2会将此条消息最终投递给连接在本实例上的用户B。</li>
</ul>
<p>以上，就是一个IM集群中，一条聊天消息的典型投递流程。<br>那么，<strong>这其中涉及到一个关键步骤：</strong>即第2）步中如何实现“IM实例1会将此条消息转交给IM实例2”？<br>要解决这个问题，就需要用到RPC技术了。本文将带你从基本概念、原理和用途方面，快速理解快速理解RPC技术，以便您在进行IM集群开发时能更好的进行方案设计和实现。</p>
<h2 id="2、相关文章"><a href="#2、相关文章" class="headerlink" title="2、相关文章"></a>2、相关文章</h2><ul>
<li>《<a href="http://www.52im.net/thread-307-1-1.html" target="_blank" rel="noopener">浅谈IM系统的架构设计</a>》</li>
<li>《<a href="http://www.52im.net/thread-289-1-1.html" target="_blank" rel="noopener">简述移动端IM开发的那些坑：架构设计、通信协议和客户端</a>》</li>
<li>《<a href="http://www.52im.net/thread-812-1-1.html" target="_blank" rel="noopener">一套海量在线用户的移动端IM架构设计实践分享(含详细图文)</a>》</li>
<li>《<a href="http://www.52im.net/thread-151-1-1.html" target="_blank" rel="noopener">一套原创分布式即时通讯(IM)系统理论架构方案</a>》</li>
<li>《<a href="http://www.52im.net/thread-152-1-1.html" target="_blank" rel="noopener">从零到卓越：京东客服即时通讯系统的技术架构演进历程</a>》</li>
<li>《<a href="http://www.52im.net/thread-31-1-1.html" target="_blank" rel="noopener">蘑菇街即时通讯/IM服务器开发之架构选择</a>》</li>
<li>《<a href="http://www.52im.net/thread-1221-1-1.html" target="_blank" rel="noopener">移动端IM中大规模群消息的推送如何保证效率、实时性？</a>》</li>
<li>《<a href="http://www.52im.net/thread-1230-1-1.html" target="_blank" rel="noopener">现代IM系统中聊天消息的同步和存储方案探讨</a>》</li>
<li>《<a href="http://www.52im.net/thread-1811-1-1.html" target="_blank" rel="noopener">腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面</a>》</li>
<li>《<a href="http://www.52im.net/thread-2007-1-1.html" target="_blank" rel="noopener">新手入门：零基础理解大型分布式架构的演进历史、技术原理、最佳实践</a>》</li>
<li>《<a href="http://www.52im.net/thread-2015-1-1.html" target="_blank" rel="noopener">一套高可用、易伸缩、高并发的IM群聊、单聊架构方案设计实践</a>》</li>
<li>《<a href="http://www.52im.net/thread-2600-1-1.html" target="_blank" rel="noopener">即时通讯新手入门：一文读懂什么是Nginx？它能否实现IM的负载均衡？</a>》</li>
</ul>
<h2 id="3、基本概念"><a href="#3、基本概念" class="headerlink" title="3、基本概念"></a>3、基本概念</h2><p><strong>RPC（Remote Procedure Call）：</strong>远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想。<br>RPC 是一种技术思想而非一种具体的规范或协议。<br><strong>常见 RPC 技术和框架有：</strong></p>
<ul>
<li>1）应用级的服务框架：阿里的 Dubbo/Dubbox、Google gRPC、Spring Boot/Spring Cloud。</li>
<li>2）远程通信协议：RMI、Socket、SOAP(HTTP XML)、REST(HTTP JSON)。</li>
<li>3）通信框架：MINA 和 Netty。</li>
</ul>
<p>目前流行的开源 RPC 框架还是比较多的，有阿里巴巴的 Dubbo、Facebook 的 Thrift、Google 的 gRPC、Twitter 的 Finagle 等。<br><strong>下面重点介绍当前最流行的三种：</strong></p>
<ul>
<li>1）<a href="https://grpc.io/" target="_blank" rel="noopener">gRPC</a>：是 Google 公布的开源软件，基于最新的 HTTP 2.0 协议，并支持常见的众多编程语言。RPC 框架是基于 HTTP 协议实现的，底层使用到了 Netty 框架的支持；</li>
<li>2）<a href="http://thrift.apache.org/" target="_blank" rel="noopener">Thrift</a>：是 Facebook 的开源 RPC 框架，主要是一个跨语言的服务开发框架。用户只要在其之上进行二次开发就行，应用对于底层的 RPC 通讯等都是透明的。不过这个对于用户来说需要学习特定领域语言这个特性，还是有一定成本的；</li>
<li>3）<a href="http://dubbo.apache.org/" target="_blank" rel="noopener">Dubbo</a>：是阿里集团开源的一个极为出名的 RPC 框架，在很多互联网公司和企业应用中广泛使用。协议和序列化框架都可以插拔是极其鲜明的特色。</li>
</ul>
<h2 id="4、典型的-RPC-框架"><a href="#4、典型的-RPC-框架" class="headerlink" title="4、典型的 RPC 框架"></a>4、典型的 RPC 框架</h2><p>在一个典型 RPC 的使用场景中，包含了服务发现、负载、容错、网络传输、序列化等组件，其中“RPC 协议”就指明了程序如何进行网络传输和序列化。<br><img src="http://image.winrains.cn/2019/09/e45cd-154251yzawfdmyzjmwdfmk.jpg" alt="即时通讯新手入门：快速理解RPC技术——基本概念、原理和用途_1.jpg"><br>▲ 一个典型的 RPC 架构原理图<br><strong>如下是 Dubbo 的设计架构图，分层清晰，功能复杂：</strong><br><img src="http://image.winrains.cn/2019/09/b1314-154353il4oswoopuegwl8o.jpg" alt="即时通讯新手入门：快速理解RPC技术——基本概念、原理和用途_2.jpg"><br>▲ Dubbo 架构图</p>
<h2 id="5、RPC的核心功能"><a href="#5、RPC的核心功能" class="headerlink" title="5、RPC的核心功能"></a>5、RPC的核心功能</h2><p>RPC 的核心功能是指实现一个 RPC 最重要的功能模块，就是上图中的”RPC 协议”部分：<br><img src="http://image.winrains.cn/2019/09/39f4a-154830y1p5vjsnzonnnqnn.jpg" alt="即时通讯新手入门：快速理解RPC技术——基本概念、原理和用途_3.jpg"><br>▲ RPC 核心功能<br>一个 RPC 的核心功能主要有 5 个部分组成，分别是：客户端、客户端 Stub、网络传输模块、服务端 Stub、服务端等。<br><img src="http://image.winrains.cn/2019/09/3272b-154846fl6gz8666rv96j8s.jpg" alt="即时通讯新手入门：快速理解RPC技术——基本概念、原理和用途_4.jpg"><br>▲ RPC 核心功能原理图<br><strong>下面分别介绍核心 RPC 框架的重要组成：</strong></p>
<ul>
<li>1）客户端（Client）：服务调用方；</li>
<li>2）客户端存根（Client Stub）：存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端；</li>
<li>3）服务端存根（Server Stub）：接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理；</li>
<li>4）服务端（Server）：服务的真正提供者；</li>
<li>5）Network Service：底层传输，可以是 TCP 或 HTTP。</li>
</ul>
<p>我们用一个demo实例来讲解这个调用过程。<br><strong>Demo实例中，客户端和服务端的ip地址如下：</strong></p>
<p>客户端 IP：172.171.4.176<br>服务端 IP：172.171.5.95</p>
<p><strong>通信使用 HTTP 协议，XML 文件传输格式。传输的字段包括：方法名 methodName，两个参数 2，3：</strong><br><img src="http://image.winrains.cn/2019/09/8ca9c-201832igghnn45nkka93nn.jpg" alt="即时通讯新手入门：快速理解RPC技术——基本概念、原理和用途_5.jpg"><br>▲ Request 抓包<br><strong>服务端返回结果，字段返回值 Value，结果是 5：</strong><br><img src="http://image.winrains.cn/2019/09/d7838-201913ozv4kjvmmrnyj6yj.jpg" alt="即时通讯新手入门：快速理解RPC技术——基本概念、原理和用途_6.jpg"><br>▲ Response 抓包<br><strong>在这两次网络传输中使用了 HTTP 协议，建立 HTTP 协议之间有 TCP 三次握手，断开 HTTP 协议时有 TCP 四次挥手：</strong><br><img src="http://image.winrains.cn/2019/09/8f384-201943wq5jg0wqnqejfzfx.png" alt="即时通讯新手入门：快速理解RPC技术——基本概念、原理和用途_7.png"><br>▲ 基于 HTTP 协议的 RPC 连接过程<br>Demo实例详细调用过程，我们来一起看看。<br><strong>Demo 实现的实现过程，流程和分工角色可以用下图来表示：</strong><br><img src="http://image.winrains.cn/2019/09/bcf49-202034x4gyv2zglzs226iv.jpg" alt="即时通讯新手入门：快速理解RPC技术——基本概念、原理和用途_8.jpg"><br>▲ RPC 调用详细流程图<br><strong>针对Demo实例，我们可以知道一次典型的 RPC 调用流程如下：</strong></p>
<ul>
<li>1）服务消费者（Client 客户端）通过本地调用的方式调用服务；</li>
<li>2）客户端存根（Client Stub）接收到调用请求后负责将方法、入参等信息序列化（组装）成能够进行网络传输的消息体；</li>
<li>3）客户端存根（Client Stub）找到远程的服务地址，并且将消息通过网络发送给服务端；</li>
<li>4）服务端存根（Server Stub）收到消息后进行解码（反序列化操作）；</li>
<li>5）服务端存根（Server Stub）根据解码结果调用本地的服务进行相关处理；</li>
<li>6）服务端(Server)本地服务业务处理；</li>
<li>7）处理结果返回给服务端存根（Server Stub）；</li>
<li>8）服务端存根（Server Stub）序列化结果；</li>
<li>9）服务端存根（Server Stub）将结果通过网络发送至消费方；</li>
<li>10）客户端存根（Client Stub）接收到消息，并进行解码（反序列化）；</li>
<li>11）服务消费方得到最终结果。</li>
</ul>
<h2 id="5、RPC-核心功能的实现介绍"><a href="#5、RPC-核心功能的实现介绍" class="headerlink" title="5、RPC 核心功能的实现介绍"></a>5、RPC 核心功能的实现介绍</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>RPC 的核心功能主要由 5 个模块组成，如果想要自己实现一个 RPC，最简单的方式要实现三个技术点。<br><strong>它们分别是：</strong></p>
<ul>
<li>1）服务寻址；</li>
<li>2）数据流的序列化和反序列化；</li>
<li>3）网络传输。</li>
</ul>
<h3 id="5-2-服务寻址"><a href="#5-2-服务寻址" class="headerlink" title="5.2 服务寻址"></a>5.2 服务寻址</h3><p>服务寻址可以使用 Call ID 映射。在本地调用中，函数体是直接通过函数指针来指定的，但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。<br>所以在 RPC 中，所有的函数都必须有自己的一个 ID。这个 ID 在所有进程中都是唯一确定的。<br>客户端在做远程过程调用时，必须附上这个 ID。然后我们还需要在客户端和服务端分别维护一个函数和Call ID的对应表。<br>当客户端需要进行远程调用时，它就查一下这个表，找出相应的 Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。<br><strong>实现方式：</strong>服务注册中心。<br>要调用服务，首先你需要一个服务注册中心去查询对方服务都有哪些实例。Dubbo 的服务注册中心是可以配置的，官方推荐使用 Zookeeper。<br><strong>实现案例：</strong>RMI（Remote Method Invocation，远程方法调用）也就是 RPC 本身的实现方式。<br><img src="http://image.winrains.cn/2019/09/48d7f-202433o24ehyc49wn53042.jpg" alt="即时通讯新手入门：快速理解RPC技术——基本概念、原理和用途_9.jpg"><br>▲ RMI 架构图<br><strong>Registry(服务发现)：</strong>借助 JNDI 发布并调用了 RMI 服务。实际上，JNDI 就是一个注册表，服务端将服务对象放入到注册表中，客户端从注册表中获取服务对象。<br>RMI 服务在服务端实现之后需要注册到 RMI Server 上，然后客户端从指定的 RMI 地址上 Lookup 服务，调用该服务对应的方法即可完成远程方法调用。<br>Registry 是个很重要的功能，当服务端开发完服务之后，要对外暴露，如果没有服务注册，则客户端是无从调用的，即使服务端的服务就在那里。</p>
<h3 id="5-3-序列化和反序列化"><a href="#5-3-序列化和反序列化" class="headerlink" title="5.3 序列化和反序列化"></a>5.3 序列化和反序列化</h3><p>客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。<br>但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。<br>这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。<br><strong>只有二进制数据才能在网络中传输，序列化和反序列化的定义是：</strong></p>
<ul>
<li>1）将对象转换成二进制流的过程叫做序列化；</li>
<li>2）将二进制流转换成对象的过程叫做反序列化。</li>
</ul>
<p>这个过程叫序列化和反序列化。<br>同理，从服务端返回的值也需要序列化反序列化的过程。</p>
<h3 id="5-4-网络传输"><a href="#5-4-网络传输" class="headerlink" title="5.4 网络传输"></a>5.4 网络传输</h3><p><strong>网络传输：</strong>远程调用往往用在网络上，客户端和服务端是通过网络连接的。<br>所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把 Call ID 和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。<br>只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。<br>尽管大部分 RPC 框架都使用 TCP 协议，但其实 UDP 也可以，而 gRPC 干脆就用了 HTTP2。<br><strong>TCP 的连接是最常见的，简要分析基于 TCP 的连接：</strong>通常 TCP 连接可以是按需连接（需要调用的时候就先建立连接，调用结束后就立马断掉），也可以是长连接（客户端和服务器建立起连接之后保持长期持有，不管此时有无数据包的发送，可以配合心跳检测机制定期检测建立的连接是否存活有效），多个远程过程调用共享同一个连接。<br><strong>所以，要实现一个 RPC 框架，只需要把以下三点实现了就基本完成了：</strong></p>
<ul>
<li>1）Call ID 映射：可以直接使用函数字符串，也可以使用整数 ID。映射表一般就是一个哈希表；</li>
<li>2）序列化反序列化：可以自己写，也可以使用 Protobuf 或者 FlatBuffers 之类的；</li>
<li>3）网络传输库：可以自己写 Socket，或者用 Asio，ZeroMQ，Netty 之类。</li>
</ul>
<h2 id="6、RPC-核心之网络传输协议"><a href="#6、RPC-核心之网络传输协议" class="headerlink" title="6、RPC 核心之网络传输协议"></a>6、RPC 核心之网络传输协议</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p>上一节中说明了要实现一个 RPC，需要选择网络传输的方式。<br><img src="http://image.winrains.cn/2019/09/c8895-202753b62xqq6b2z6dxy2q.jpg" alt="即时通讯新手入门：快速理解RPC技术——基本概念、原理和用途_10.jpg"><br>▲ 网络传输<br>在 RPC 中可选的网络传输方式有多种，可以选择 TCP 协议、UDP 协议、HTTP 协议。<br>每一种协议对整体的性能和效率都有不同的影响，如何选择一个正确的网络传输协议呢？首先要搞明白各种传输协议在 RPC 中的工作方式。</p>
<h3 id="6-2-基于-TCP-协议的-RPC-调用"><a href="#6-2-基于-TCP-协议的-RPC-调用" class="headerlink" title="6.2 基于 TCP 协议的 RPC 调用"></a>6.2 基于 TCP 协议的 RPC 调用</h3><p>由服务的调用方与服务的提供方建立 Socket 连接，并由服务的调用方通过 Socket 将需要调用的接口名称、方法名称和参数序列化后传递给服务的提供方，服务的提供方反序列化后再利用反射调用相关的方法。<br>最后将结果返回给服务的调用方，整个基于 TCP 协议的 RPC 调用大致如此。<br>但是在实例应用中则会进行一系列的封装，如 RMI 便是在 TCP 协议上传递可序列化的 Java 对象。</p>
<h3 id="6-3-基于-HTTP-协议的-RPC-调用"><a href="#6-3-基于-HTTP-协议的-RPC-调用" class="headerlink" title="6.3 基于 HTTP 协议的 RPC 调用"></a>6.3 基于 HTTP 协议的 RPC 调用</h3><p>该方法更像是访问网页一样，只是它的返回结果更加单一简单。<br><strong>其大致流程为：</strong>由服务的调用者向服务的提供者发送请求，这种请求的方式可能是 GET、POST、PUT、DELETE 等中的一种，服务的提供者可能会根据不同的请求方式做出不同的处理，或者某个方法只允许某种请求方式。<br>而调用的具体方法则是根据 URL 进行方法调用，而方法所需要的参数可能是对服务调用方传输过去的 XML 数据或者 JSON 数据解析后的结果，最后返回 JOSN 或者 XML 的数据结果。<br>由于目前有很多开源的 Web 服务器，如 Tomcat，所以其实现起来更加容易，就像做 Web 项目一样。</p>
<h3 id="6-4-两种方式对比"><a href="#6-4-两种方式对比" class="headerlink" title="6.4 两种方式对比"></a>6.4 两种方式对比</h3><p>基于 TCP 的协议实现的 RPC 调用，由于 TCP 协议处于协议栈的下层，能够更加灵活地对协议字段进行定制，减少网络开销，提高性能，实现更大的吞吐量和并发数。<br>但是需要更多关注底层复杂的细节，实现的代价更高。同时对不同平台，如安卓，iOS 等，需要重新开发出不同的工具包来进行请求发送和相应解析，工作量大，难以快速响应和满足用户需求。<br>基于 HTTP 协议实现的 RPC 则可以使用 JSON 和 XML 格式的请求或响应数据。<br>而 JSON 和 XML 作为通用的格式标准（使用 HTTP 协议也需要序列化和反序列化，不过这不是该协议下关心的内容，成熟的 Web 程序已经做好了序列化内容），开源的解析工具已经相当成熟，在其上进行二次开发会非常便捷和简单。<br>但是由于 HTTP 协议是上层协议，发送包含同等内容的信息，使用 HTTP 协议传输所占用的字节数会比使用 TCP 协议传输所占用的字节数更高。<br>因此在同等网络下，通过 HTTP 协议传输相同内容，效率会比基于 TCP 协议的数据效率要低，信息传输所占用的时间也会更长，当然压缩数据，能够缩小这一差距。</p>
<h2 id="7、RPC的主要使用场景"><a href="#7、RPC的主要使用场景" class="headerlink" title="7、RPC的主要使用场景"></a>7、RPC的主要使用场景</h2><p>RPC 主要用于公司内部的服务调用（准确地说是大型系统内部各模块、子系统间的调用，而不是提供给外界调用），性能消耗低，传输效率高，实现复杂。<br>相对而言，HTTP 主要用于对外的异构环境，比如：浏览器接口调用、App 接口调用、第三方接口调用等。<br>RPC 的主要使用场景尤其是大型的网站的情况下，内部子系统较多、接口非常多的情况下适合使用 RPC。<br><strong>RPC 的使用场景一般来说有以下特点：</strong></p>
<ul>
<li><strong>1）长链接：</strong>不必每次通信都要像 HTTP 一样去 3 次握手，减少了网络开销；</li>
<li><strong>2）注册发布机制：</strong>RPC 框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作；</li>
<li><strong>3）安全性：</strong>没有暴露资源操作；</li>
<li><strong>4）微服务支持：</strong>就是最近流行的服务化架构、服务化治理，RPC 框架是一个强力的支撑。</li>
</ul>
<h2 id="8、小结一下"><a href="#8、小结一下" class="headerlink" title="8、小结一下"></a>8、小结一下</h2><p>RPC（即远程调用）简单说就是发送一个请求给远程机器（一般来说就是分布系统内网中的机器），远程机器返回一个结果回来的过程。<br>为什么要这么做？因为单台服务器的性能远远不能满足现在互联网这个体量的用户的需求，就好比你去肯德基点个餐，餐台的服务员把薯条鸡腿汉堡的任务分给不同的人，然后收集起来给你的过程，餐台服务员就相当于调用远程服务。<br>但假如不这么做，点餐员直接做这些事情（又得点餐，又得炸薯条、炸鸡腿等等)，两相比较，你就知道远程调用有什么好处了。<br>简单来说就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如比如不同的系统间的通讯，甚至不同的组织间的通讯。由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。<br>当然，RPC有有点也有缺点，只有用在合适的场景，才能发挥它的最大威力。<br><strong>RPC的主要优点有：</strong> </p>
<ul>
<li>1）提升系统可扩展性；</li>
<li>2）提升系统可维护性和持续交付能力；</li>
<li>3）实现系统高可。</li>
</ul>
<p><strong>RPC的主要缺点有：</strong> </p>
<ul>
<li>1）一个完善的RPC框架开发难度大、成本高 ；</li>
<li>2）RPC框架调用成功率受限于网络状况；</li>
<li>3）调用远程方法对初学者来说难度大。</li>
</ul>
<blockquote>
<p>作者：李金葵</p>
<p>来源：<a href="http://www.52im.net/thread-2620-1-1.html" target="_blank" rel="noopener">http://www.52im.net/thread-2620-1-1.html</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/27/Java-NIO%E5%85%A5%E9%97%A8/" rel="prev" title="Java NIO入门">
      <i class="fa fa-chevron-left"></i> Java NIO入门
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%8A%80%E6%9C%AF/" rel="next" title="分布式架构下的负载均衡技术">
      分布式架构下的负载均衡技术 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、引言"><span class="nav-number">1.</span> <span class="nav-text">1、引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、相关文章"><span class="nav-number">2.</span> <span class="nav-text">2、相关文章</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、基本概念"><span class="nav-number">3.</span> <span class="nav-text">3、基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、典型的-RPC-框架"><span class="nav-number">4.</span> <span class="nav-text">4、典型的 RPC 框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、RPC的核心功能"><span class="nav-number">5.</span> <span class="nav-text">5、RPC的核心功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、RPC-核心功能的实现介绍"><span class="nav-number">6.</span> <span class="nav-text">5、RPC 核心功能的实现介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-概述"><span class="nav-number">6.1.</span> <span class="nav-text">5.1 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-服务寻址"><span class="nav-number">6.2.</span> <span class="nav-text">5.2 服务寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-序列化和反序列化"><span class="nav-number">6.3.</span> <span class="nav-text">5.3 序列化和反序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-网络传输"><span class="nav-number">6.4.</span> <span class="nav-text">5.4 网络传输</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、RPC-核心之网络传输协议"><span class="nav-number">7.</span> <span class="nav-text">6、RPC 核心之网络传输协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-概述"><span class="nav-number">7.1.</span> <span class="nav-text">6.1 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-基于-TCP-协议的-RPC-调用"><span class="nav-number">7.2.</span> <span class="nav-text">6.2 基于 TCP 协议的 RPC 调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-基于-HTTP-协议的-RPC-调用"><span class="nav-number">7.3.</span> <span class="nav-text">6.3 基于 HTTP 协议的 RPC 调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-两种方式对比"><span class="nav-number">7.4.</span> <span class="nav-text">6.4 两种方式对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、RPC的主要使用场景"><span class="nav-number">8.</span> <span class="nav-text">7、RPC的主要使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8、小结一下"><span class="nav-number">9.</span> <span class="nav-text">8、小结一下</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">winrains</p>
  <div class="site-description" itemprop="description">淡泊明志</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">489</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">83</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">108</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">winrains</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
