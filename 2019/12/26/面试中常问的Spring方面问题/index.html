<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://congsheng.wang').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="Spring Framework 现在几乎已成为 Java Web 开发的标配框架。那么，作为 Java 程序员，你对 Spring 的主要技术点又掌握了多少呢？不妨用本文的问题来检测一下。">
<meta name="keywords" content="面试">
<meta property="og:type" content="article">
<meta property="og:title" content="面试中常问的Spring方面问题">
<meta property="og:url" content="http:&#x2F;&#x2F;congsheng.wang&#x2F;2019&#x2F;12&#x2F;26&#x2F;%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%B8%B8%E9%97%AE%E7%9A%84Spring%E6%96%B9%E9%9D%A2%E9%97%AE%E9%A2%98&#x2F;index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="Spring Framework 现在几乎已成为 Java Web 开发的标配框架。那么，作为 Java 程序员，你对 Spring 的主要技术点又掌握了多少呢？不妨用本文的问题来检测一下。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;641e0-2c9c6daadf8154be46afbfd87d3e5824.jpeg-wh_651x-s_919540347.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;20190829143756-2ecdd.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;a4f36-223b876d39a7bd0d001271c445d56aa7.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;af3ef-41bc3485d75dc4aabe3d843ac2048790.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;caa7f-d6ebd1c162702b14bf48320d0ce48921.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;2a040-bc1af77af5b09fb02a8920292ff4f8e1.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;dfa9f-801b410c598b76a9ac602373008c90e1.jpeg">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;62864-0a2ce874e9e8b25d524d2fe7b4da8770.jpeg">
<meta property="og:updated_time" content="2019-12-26T08:41:51.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;641e0-2c9c6daadf8154be46afbfd87d3e5824.jpeg-wh_651x-s_919540347.jpeg">

<link rel="canonical" href="http://congsheng.wang/2019/12/26/%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%B8%B8%E9%97%AE%E7%9A%84Spring%E6%96%B9%E9%9D%A2%E9%97%AE%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>面试中常问的Spring方面问题 | 个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">congsheng的博客</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">141</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">91</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">807</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://congsheng.wang/2019/12/26/%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%B8%B8%E9%97%AE%E7%9A%84Spring%E6%96%B9%E9%9D%A2%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="congsheng.wang">
      <meta itemprop="description" content="trouble is a friend">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试中常问的Spring方面问题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-26 16:41:51" itemprop="dateCreated datePublished" datetime="2019-12-26T16:41:51+08:00">2019-12-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">Spring技术</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring%E6%8A%80%E6%9C%AF/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Spring Framework 现在几乎已成为 Java Web 开发的标配框架。那么，作为 Java 程序员，你对 Spring 的主要技术点又掌握了多少呢？不妨用本文的问题来检测一下。</p>
<a id="more"></a>

<h2 id="1、一般问题"><a href="#1、一般问题" class="headerlink" title="1、一般问题"></a>1、一般问题</h2><h3 id="1-1-不同版本的-Spring-Framework-有哪些主要功能？"><a href="#1-1-不同版本的-Spring-Framework-有哪些主要功能？" class="headerlink" title="1.1. 不同版本的 Spring Framework 有哪些主要功能？"></a>1.1. 不同版本的 Spring Framework 有哪些主要功能？</h3><p>VersionFeatureSpring 2.5发布于 2007 年。这是第一个支持注解的版本。Spring 3.0发布于 2009 年。它完全利用了 Java5 中的改进，并为 JEE6 提供了支持。Spring 4.0发布于 2013 年。这是第一个完全支持 JAVA8 的版本。</p>
<h3 id="1-2-什么是-Spring-Framework？"><a href="#1-2-什么是-Spring-Framework？" class="headerlink" title="1.2. 什么是 Spring Framework？"></a>1.2. 什么是 Spring Framework？</h3><ul>
<li>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</li>
<li>它是轻量级、松散耦合的。</li>
<li>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</li>
<li>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。</li>
</ul>
<h3 id="1-3-列举-Spring-Framework-的优点。"><a href="#1-3-列举-Spring-Framework-的优点。" class="headerlink" title="1.3. 列举 Spring Framework 的优点。"></a>1.3. 列举 Spring Framework 的优点。</h3><ul>
<li>由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。</li>
<li>Spring Framework 支持 POJO(Plain Old Java Object) 编程，从而具备持续集成和可测试性。</li>
<li>由于依赖注入和控制反转，JDBC 得以简化。</li>
<li>它是开源免费的。</li>
</ul>
<h3 id="1-4-Spring-Framework-有哪些不同的功能？"><a href="#1-4-Spring-Framework-有哪些不同的功能？" class="headerlink" title="1.4. Spring Framework 有哪些不同的功能？"></a>1.4. Spring Framework 有哪些不同的功能？</h3><ul>
<li><strong>轻量级</strong> - Spring 在代码量和透明度方面都很轻便。</li>
<li><strong>IOC</strong> - 控制反转</li>
<li><strong>AOP</strong> - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。</li>
<li><strong>容器</strong> - Spring 负责创建和管理对象（Bean）的生命周期和配置。</li>
<li><strong>MVC</strong> - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</li>
<li><strong>事务管理</strong> - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。</li>
<li><strong>JDBC 异常</strong> - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</li>
</ul>
<h3 id="1-5-Spring-Framework-中有多少个模块，它们分别是什么？"><a href="#1-5-Spring-Framework-中有多少个模块，它们分别是什么？" class="headerlink" title="1.5. Spring Framework 中有多少个模块，它们分别是什么？"></a>1.5. Spring Framework 中有多少个模块，它们分别是什么？</h3><p><img src="http://image.winrains.cn/2019/08/641e0-2c9c6daadf8154be46afbfd87d3e5824.jpeg-wh_651x-s_919540347.jpeg" alt="http://image.winrains.cn/2019/08/641e0-2c9c6daadf8154be46afbfd87d3e5824.jpeg-wh_651x-s_919540347.jpeg"></p>
<ul>
<li><p>Spring 核心容器</p>
<p> – 该层基本上是 Spring Framework 的核心。它包含以下模块：</p>
<ul>
<li>Spring Core</li>
<li>Spring Bean</li>
<li>SpEL (Spring Expression Language)</li>
<li>Spring Context</li>
</ul>
</li>
<li><p>数据访问/集成</p>
<p> – 该层提供与数据库交互的支持。它包含以下模块：</p>
<ul>
<li>JDBC (Java DataBase Connectivity)</li>
<li>ORM (Object Relational Mapping)</li>
<li>OXM (Object XML Mappers)</li>
<li>JMS (Java Messaging Service)</li>
<li>Transaction</li>
</ul>
</li>
<li><p>Web</p>
<p> – 该层提供了创建 Web 应用程序的支持。它包含以下模块：</p>
<ul>
<li>Web</li>
<li>Web – Servlet</li>
<li>Web – Socket</li>
<li>Web – Portlet</li>
</ul>
</li>
<li><p><strong>AOP</strong> – 该层支持面向切面编程</p>
</li>
<li><p><strong>Instrumentation</strong> – 该层为类检测和类加载器实现提供支持。</p>
</li>
<li><p><strong>Test</strong> – 该层为使用 JUnit 和 TestNG 进行测试提供支持。</p>
</li>
<li><p>几个杂项模块:</p>
<ul>
<li>Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。</li>
<li>Aspects – 该模块为与 AspectJ 的集成提供支持。</li>
</ul>
</li>
</ul>
<h3 id="1-6-什么是-Spring-配置文件？"><a href="#1-6-什么是-Spring-配置文件？" class="headerlink" title="1.6. 什么是 Spring 配置文件？"></a>1.6. 什么是 Spring 配置文件？</h3><p>Spring 配置文件是 XML 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。但是，XML 配置文件冗长且更加干净。如果没有正确规划和编写，那么在大项目中管理变得非常困难。</p>
<h3 id="1-7-Spring-应用程序有哪些不同组件？"><a href="#1-7-Spring-应用程序有哪些不同组件？" class="headerlink" title="1.7. Spring 应用程序有哪些不同组件？"></a>1.7. Spring 应用程序有哪些不同组件？</h3><p>Spring 应用一般有以下组件：</p>
<ul>
<li><strong>接口</strong> - 定义功能。</li>
<li><strong>Bean 类</strong> - 它包含属性，setter 和 getter 方法，函数等。</li>
<li><strong>Spring 面向切面编程（AOP）</strong> - 提供面向切面编程的功能。</li>
<li><strong>Bean 配置文件</strong> - 包含类的信息以及如何配置它们。</li>
<li><strong>用户程序</strong> - 它使用接口。</li>
</ul>
<h3 id="1-8-使用-Spring-有哪些方式？"><a href="#1-8-使用-Spring-有哪些方式？" class="headerlink" title="1.8. 使用 Spring 有哪些方式？"></a>1.8. 使用 Spring 有哪些方式？</h3><p>使用 Spring 有以下方式：</p>
<ul>
<li>作为一个成熟的 Spring Web 应用程序。</li>
<li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li>
<li>用于远程使用。</li>
<li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li>
</ul>
<h2 id="2、依赖注入（Ioc）"><a href="#2、依赖注入（Ioc）" class="headerlink" title="2、依赖注入（Ioc）"></a>2、依赖注入（Ioc）</h2><h3 id="2-1-什么是-Spring-IOC-容器？"><a href="#2-1-什么是-Spring-IOC-容器？" class="headerlink" title="2.1. 什么是 Spring IOC 容器？"></a>2.1. 什么是 Spring IOC 容器？</h3><p>Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过 XML，Java 注解或 Java 代码提供。</p>
<p><img src="http://image.winrains.cn/2019/08/20190829143756-2ecdd.jpeg" alt="img"></p>
<h3 id="2-2-什么是依赖注入？"><a href="#2-2-什么是依赖注入？" class="headerlink" title="2.2. 什么是依赖注入？"></a>2.2. 什么是依赖注入？</h3><p>在依赖注入中，您不必创建对象，但必须描述如何创建它们。您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。由 IoC 容器将它们装配在一起。</p>
<h3 id="2-3-可以通过多少种方式完成依赖注入？"><a href="#2-3-可以通过多少种方式完成依赖注入？" class="headerlink" title="2.3. 可以通过多少种方式完成依赖注入？"></a>2.3. 可以通过多少种方式完成依赖注入？</h3><p>通常，依赖注入可以通过三种方式完成，即：</p>
<ul>
<li>构造函数注入</li>
<li>setter 注入</li>
<li>接口注入</li>
</ul>
<p>在 Spring Framework 中，仅使用构造函数和 setter 注入。</p>
<h3 id="2-4-区分构造函数注入和-setter-注入。"><a href="#2-4-区分构造函数注入和-setter-注入。" class="headerlink" title="2.4. 区分构造函数注入和 setter 注入。"></a>2.4. 区分构造函数注入和 setter 注入。</h3><p>构造函数注入setter 注入没有部分注入有部分注入不会覆盖 setter 属性会覆盖 setter 属性任意修改都会创建一个新实例任意修改不会创建一个新实例适用于设置很多属性适用于设置少量属性</p>
<h3 id="2-5-spring-中有多少种-IOC-容器？"><a href="#2-5-spring-中有多少种-IOC-容器？" class="headerlink" title="2.5. spring 中有多少种 IOC 容器？"></a>2.5. spring 中有多少种 IOC 容器？</h3><ul>
<li>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。</li>
<li>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。</li>
</ul>
<h3 id="2-6-区分-BeanFactory-和-ApplicationContext。"><a href="#2-6-区分-BeanFactory-和-ApplicationContext。" class="headerlink" title="2.6. 区分 BeanFactory 和 ApplicationContext。"></a>2.6. 区分 BeanFactory 和 ApplicationContext。</h3><p>BeanFactoryApplicationContext它使用懒加载它使用即时加载它使用语法显式提供资源对象它自己创建和管理资源对象不支持国际化支持国际化不支持基于依赖的注解支持基于依赖的注解</p>
<h3 id="2-7-列举-IoC-的一些好处。"><a href="#2-7-列举-IoC-的一些好处。" class="headerlink" title="2.7. 列举 IoC 的一些好处。"></a>2.7. 列举 IoC 的一些好处。</h3><p>IoC 的一些好处是：</p>
<ul>
<li>它将最小化应用程序中的代码量。</li>
<li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li>
<li>它以最小的影响和最少的侵入机制促进松耦合。</li>
<li>它支持即时的实例化和延迟加载服务。</li>
</ul>
<h3 id="2-8-Spring-IoC-的实现机制。"><a href="#2-8-Spring-IoC-的实现机制。" class="headerlink" title="2.8. Spring IoC 的实现机制。"></a>2.8. Spring IoC 的实现机制。</h3><p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。<br>示例：</p>
<p><img src="http://image.winrains.cn/2019/08/a4f36-223b876d39a7bd0d001271c445d56aa7.jpeg" alt="http://image.winrains.cn/2019/08/a4f36-223b876d39a7bd0d001271c445d56aa7.jpeg"></p>
<h2 id="3-Beans"><a href="#3-Beans" class="headerlink" title="3. Beans"></a>3. Beans</h2><h3 id="3-1-什么是-spring-bean？"><a href="#3-1-什么是-spring-bean？" class="headerlink" title="3.1. 什么是 spring bean？"></a>3.1. 什么是 spring bean？</h3><ul>
<li>它们是构成用户应用程序主干的对象。</li>
<li>Bean 由 Spring IoC 容器管理。</li>
<li>它们由 Spring IoC 容器实例化，配置，装配和管理。</li>
<li>Bean 是基于用户提供给容器的配置元数据创建。</li>
</ul>
<h3 id="3-2-spring-提供了哪些配置方式？"><a href="#3-2-spring-提供了哪些配置方式？" class="headerlink" title="3.2. spring 提供了哪些配置方式？"></a>3.2. spring 提供了哪些配置方式？</h3><ul>
<li><ul>
<li>基于 xml 配置</li>
</ul>
</li>
</ul>
<p>bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">"studentbean"</span> <span class="built_in">class</span>=<span class="string">"org.edureka.firstSpring.StudentBean"</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"name"</span> value=<span class="string">"Edureka"</span>&gt;&lt;/<span class="keyword">property</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&lt;/bean&gt;</span></pre></td></tr></table></figure>

<ul>
<li>基于注解配置</li>
</ul>
<p>您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bean definitions go here --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<ul>
<li>基于 Java API 配置</li>
</ul>
<p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>
<ol>
<li>@Bean 注解扮演与 <bean /> 元素相同的角色。</li>
<li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="3-3-spring-支持集中-bean-scope？"><a href="#3-3-spring-支持集中-bean-scope？" class="headerlink" title="3.3. spring 支持集中 bean scope？"></a>3.3. spring 支持集中 bean scope？</h3><p>Spring bean 支持 5 种 scope：</p>
<ul>
<li><strong>Singleton</strong> - 每个 Spring IoC 容器仅有一个单实例。</li>
<li><strong>Prototype</strong> - 每次请求都会产生一个新的实例。</li>
<li><strong>Request</strong> - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。</li>
<li><strong>Session</strong> - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。</li>
<li><strong>Global-session</strong> - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。</li>
</ul>
<p>仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。</p>
<h3 id="3-4-spring-bean-容器的生命周期是什么样的？"><a href="#3-4-spring-bean-容器的生命周期是什么样的？" class="headerlink" title="3.4. spring bean 容器的生命周期是什么样的？"></a>3.4. spring bean 容器的生命周期是什么样的？</h3><p>spring bean 容器的生命周期流程如下：</p>
<ol>
<li>Spring 容器根据配置中的 bean 定义中实例化 bean。</li>
<li>Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。</li>
<li>如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。</li>
<li>如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。</li>
<li>如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。</li>
<li>如果为 bean 指定了 init 方法（<bean> 的 init-method 属性），那么将调用它。</li>
<li>最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。</li>
<li>如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。</li>
<li>如果为 bean 指定了 destroy 方法（<bean> 的 destroy-method 属性），那么将调用它。<img src="http://image.winrains.cn/2019/08/af3ef-41bc3485d75dc4aabe3d843ac2048790.jpeg" alt="http://image.winrains.cn/2019/08/af3ef-41bc3485d75dc4aabe3d843ac2048790.jpeg"></li>
</ol>
<h3 id="3-5-什么是-spring-的内部-bean？"><a href="#3-5-什么是-spring-的内部-bean？" class="headerlink" title="3.5. 什么是 spring 的内部 bean？"></a>3.5. 什么是 spring 的内部 bean？</h3><p>只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean。为了定义 bean，Spring 的基于 XML 的配置元数据在 <property> 或 <constructor-arg>中提供了 <bean> 元素的使用。内部 bean 总是匿名的，它们总是作为原型。<br>例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。<br>Student.java</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Student</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> Person person;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//Setters and Getters</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Person</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> String name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> String address;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//Setters and Getters</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>bean.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“StudentBean</span>" <span class="attr">class</span>=<span class="string">"com.edureka.Student"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"person"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!--This is inner bean --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.edureka.Person"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">“Scott</span>"&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">value</span>=<span class="string">“Bangalore</span>"&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>

<h3 id="3-6-什么是-spring-装配？"><a href="#3-6-什么是-spring-装配？" class="headerlink" title="3.6. 什么是 spring 装配？"></a>3.6. 什么是 spring 装配？</h3><p>当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。 Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。</p>
<h3 id="3-7-自动装配有哪些方式？"><a href="#3-7-自动装配有哪些方式？" class="headerlink" title="3.7. 自动装配有哪些方式？"></a>3.7. 自动装配有哪些方式？</h3><p>Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。<br>自动装配的不同模式：</p>
<ul>
<li><strong>no</strong> - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li>
<li><strong>byName</strong> - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</li>
<li><strong>byType</strong> - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</li>
<li><strong>构造函数</strong> - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li>
<li><strong>autodetect</strong> - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li>
</ul>
<h3 id="3-8-自动装配有什么局限？"><a href="#3-8-自动装配有什么局限？" class="headerlink" title="3.8. 自动装配有什么局限？"></a>3.8. 自动装配有什么局限？</h3><ul>
<li>覆盖的可能性 - 您始终可以使用 <constructor-arg> 和 <property> 设置指定依赖项，这将覆盖自动装配。</li>
<li>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</li>
<li>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</li>
</ul>
<h2 id="4、注解"><a href="#4、注解" class="headerlink" title="4、注解"></a>4、注解</h2><h3 id="4-1-什么是基于注解的容器配置？"><a href="#4-1-什么是基于注解的容器配置？" class="headerlink" title="4.1. 什么是基于注解的容器配置？"></a>4.1. 什么是基于注解的容器配置？</h3><p>不使用 XML 来描述 bean 装配，开发人员通过在相关的类，方法或字段声明上使用注解将配置移动到组件类本身。它可以作为 XML 设置的替代方案。例如：<br>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>
<ul>
<li>@Bean 注解扮演与</li>
<li>元素相同的角色。</li>
<li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="4-2-如何在-spring-中启动注解装配？"><a href="#4-2-如何在-spring-中启动注解装配？" class="headerlink" title="4.2. 如何在 spring 中启动注解装配？"></a>4.2. 如何在 spring 中启动注解装配？</h3><p>默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置&lt;context：annotation-config /&gt; 元素在 Spring 配置文件中启用它。</p>
<h3 id="4-3-Component-Controller-Repository-Service-有何区别？"><a href="#4-3-Component-Controller-Repository-Service-有何区别？" class="headerlink" title="4.3. @Component, @Controller, @Repository, @Service 有何区别？"></a>4.3. @Component, @Controller, @Repository, @Service 有何区别？</h3><ul>
<li>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li>
<li>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</li>
<li>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</li>
<li>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li>
</ul>
<h3 id="4-4-Required-注解有什么用？"><a href="#4-4-Required-注解有什么用？" class="headerlink" title="4.4. @Required 注解有什么用？"></a>4.4. @Required 注解有什么用？</h3><p>@Required 应用于 bean 属性 setter 方法。此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性。如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。<br>示例：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    @Required</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name=name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">return</span> name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="4-5-Autowired-注解有什么用？"><a href="#4-5-Autowired-注解有什么用？" class="headerlink" title="4.5. @Autowired 注解有什么用？"></a>4.5. @Autowired 注解有什么用？</h3><p>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是类型驱动的注入。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name=name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="4-6-Qualifier-注解有什么用？"><a href="#4-6-Qualifier-注解有什么用？" class="headerlink" title="4.6. @Qualifier 注解有什么用？"></a>4.6. @Qualifier 注解有什么用？</h3><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。<br>例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount 中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。<br>Employee.java</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>EmpAccount.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpAccount</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> Employee emp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Qualifier</span>(emp1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showName</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Employee name : "</span> + emp.getName);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="4-7-RequestMapping-注解有什么用？"><a href="#4-7-RequestMapping-注解有什么用？" class="headerlink" title="4.7. @RequestMapping 注解有什么用？"></a>4.7. @RequestMapping 注解有什么用？</h3><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：</p>
<ul>
<li>类级别：映射请求的 URL</li>
<li>方法级别：映射 URL 以及 HTTP 请求方法</li>
</ul>
<h2 id="5、数据访问"><a href="#5、数据访问" class="headerlink" title="5、数据访问"></a>5、数据访问</h2><h3 id="5-1-spring-DAO-有什么用？"><a href="#5-1-spring-DAO-有什么用？" class="headerlink" title="5.1. spring DAO 有什么用？"></a>5.1. spring DAO 有什么用？</h3><p>Spring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p>
<h3 id="5-2-列举-Spring-DAO-抛出的异常。"><a href="#5-2-列举-Spring-DAO-抛出的异常。" class="headerlink" title="5.2. 列举 Spring DAO 抛出的异常。"></a>5.2. 列举 Spring DAO 抛出的异常。</h3><p><img src="http://image.winrains.cn/2019/08/caa7f-d6ebd1c162702b14bf48320d0ce48921.jpeg" alt="http://image.winrains.cn/2019/08/caa7f-d6ebd1c162702b14bf48320d0ce48921.jpeg"></p>
<h3 id="5-3-spring-JDBC-API-中存在哪些类？"><a href="#5-3-spring-JDBC-API-中存在哪些类？" class="headerlink" title="5.3. spring JDBC API 中存在哪些类？"></a>5.3. spring JDBC API 中存在哪些类？</h3><ul>
<li>JdbcTemplate</li>
<li>SimpleJdbcTemplate</li>
<li>NamedParameterJdbcTemplate</li>
<li>SimpleJdbcInsert</li>
<li>SimpleJdbcCall</li>
</ul>
<h3 id="5-4-使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#5-4-使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="5.4. 使用 Spring 访问 Hibernate 的方法有哪些？"></a>5.4. 使用 Spring 访问 Hibernate 的方法有哪些？</h3><p>我们可以通过两种方式使用 Spring 访问 Hibernate：</p>
<ol>
<li>使用 Hibernate 模板和回调进行控制反转</li>
<li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li>
</ol>
<h3 id="5-5-列举-spring-支持的事务管理类型"><a href="#5-5-列举-spring-支持的事务管理类型" class="headerlink" title="5.5. 列举 spring 支持的事务管理类型"></a>5.5. 列举 spring 支持的事务管理类型</h3><p>Spring 支持两种类型的事务管理：</p>
<ol>
<li>程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。</li>
<li>声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。</li>
</ol>
<h3 id="5-6-spring-支持哪些-ORM-框架？"><a href="#5-6-spring-支持哪些-ORM-框架？" class="headerlink" title="5.6. spring 支持哪些 ORM 框架？"></a>5.6. spring 支持哪些 ORM 框架？</h3><ul>
<li>Hibernate</li>
<li>iBatis</li>
<li>JPA</li>
<li>JDO</li>
<li>OJB</li>
</ul>
<h2 id="6、AOP"><a href="#6、AOP" class="headerlink" title="6、AOP"></a>6、AOP</h2><h3 id="6-1-什么是-AOP？"><a href="#6-1-什么是-AOP？" class="headerlink" title="6.1. 什么是 AOP？"></a>6.1. 什么是 AOP？</h3><p>AOP(Aspect-Oriented Programming), 即 <strong>面向切面编程</strong>, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角.<br>在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 <strong>Aspect(切面)</strong></p>
<h3 id="6-2-什么是-Aspect？"><a href="#6-2-什么是-Aspect？" class="headerlink" title="6.2. 什么是 Aspect？"></a>6.2. 什么是 Aspect？</h3><p>aspect 由 pointcount 和 advice 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.<br>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p>
<ol>
<li>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上</li>
<li>如何在 advice 中编写切面代码.</li>
</ol>
<p><strong>可以简单地认为, 使用 @Aspect 注解的类就是切面.</strong><br><img src="http://image.winrains.cn/2019/08/2a040-bc1af77af5b09fb02a8920292ff4f8e1.jpeg" alt="http://image.winrains.cn/2019/08/2a040-bc1af77af5b09fb02a8920292ff4f8e1.jpeg"></p>
<h3 id="6-3-什么是切点（JoinPoint）"><a href="#6-3-什么是切点（JoinPoint）" class="headerlink" title="6.3. 什么是切点（JoinPoint）"></a>6.3. 什么是切点（JoinPoint）</h3><p>程序运行中的一些时间点, 例如一个方法的执行, 或者是一个异常的处理.<br>在 Spring AOP 中, join point 总是方法的执行点。</p>
<h3 id="6-4-什么是通知（Advice）？"><a href="#6-4-什么是通知（Advice）？" class="headerlink" title="6.4. 什么是通知（Advice）？"></a>6.4. 什么是通知（Advice）？</h3><p>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice。Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的拦截器。</p>
<h3 id="6-5-有哪些类型的通知（Advice）？"><a href="#6-5-有哪些类型的通知（Advice）？" class="headerlink" title="6.5. 有哪些类型的通知（Advice）？"></a>6.5. 有哪些类型的通知（Advice）？</h3><ul>
<li><strong>Before</strong> - 这些类型的 Advice 在 joinpoint 方法之前执行，并使用 @Before 注解标记进行配置。</li>
<li><strong>After Returning</strong> - 这些类型的 Advice 在连接点方法正常执行后执行，并使用@AfterReturning 注解标记进行配置。</li>
<li><strong>After Throwing</strong> - 这些类型的 Advice 仅在 joinpoint 方法通过抛出异常退出并使用 @AfterThrowing 注解标记配置时执行。</li>
<li><strong>After (finally)</strong> - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @After 注解标记进行配置。</li>
<li><strong>Around</strong> - 这些类型的 Advice 在连接点之前和之后执行，并使用 @Around 注解标记进行配置。</li>
</ul>
<h3 id="6-6-指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处"><a href="#6-6-指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处" class="headerlink" title="6.6. 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处"></a>6.6. 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处</h3><p>concern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。<br>cross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。</p>
<h3 id="6-7-AOP-有哪些实现方式"><a href="#6-7-AOP-有哪些实现方式" class="headerlink" title="6.7. AOP 有哪些实现方式"></a>6.7. AOP 有哪些实现方式</h3><p>实现 AOP 的技术，主要分为两大类：</p>
<ul>
<li>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；</li>
<li>编译时编织（特殊编译器实现）</li>
<li>类加载时编织（特殊的类加载器实现）。</li>
<li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</li>
<li>JDK 动态代理</li>
<li>CGLIB</li>
</ul>
<h3 id="6-8-Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#6-8-Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="6.8. Spring AOP and AspectJ AOP 有什么区别？"></a>6.8. Spring AOP and AspectJ AOP 有什么区别？</h3><p>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。<br>Spring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。</p>
<h3 id="6-9-如何理解-Spring-中的代理？"><a href="#6-9-如何理解-Spring-中的代理？" class="headerlink" title="6.9. 如何理解 Spring 中的代理？"></a>6.9. 如何理解 Spring 中的代理？</h3><p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。<br>Advice + Target Object = Proxy</p>
<h3 id="6-10-什么是编织（Weaving）？"><a href="#6-10-什么是编织（Weaving）？" class="headerlink" title="6.10. 什么是编织（Weaving）？"></a>6.10. 什么是编织（Weaving）？</h3><p>为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）。在 Spring AOP 中，编织在运行时执行。请参考下图：<br><img src="http://image.winrains.cn/2019/08/dfa9f-801b410c598b76a9ac602373008c90e1.jpeg" alt="http://image.winrains.cn/2019/08/dfa9f-801b410c598b76a9ac602373008c90e1.jpeg"></p>
<h2 id="7、MVC"><a href="#7、MVC" class="headerlink" title="7、MVC"></a>7、MVC</h2><h3 id="7-1-Spring-MVC-框架有什么用？"><a href="#7-1-Spring-MVC-框架有什么用？" class="headerlink" title="7.1. Spring MVC 框架有什么用？"></a>7.1. Spring MVC 框架有什么用？</h3><p>Spring Web MVC 框架提供 <strong>模型-视图-控制器</strong> 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。 MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。</p>
<h3 id="7-2-描述一下-DispatcherServlet-的工作流程"><a href="#7-2-描述一下-DispatcherServlet-的工作流程" class="headerlink" title="7.2. 描述一下 DispatcherServlet 的工作流程"></a><strong>7.2. 描述一下 DispatcherServlet 的工作流程</strong></h3><p>DispatcherServlet 的工作流程可以用一幅图来说明：<br><img src="http://image.winrains.cn/2019/08/62864-0a2ce874e9e8b25d524d2fe7b4da8770.jpeg" alt="http://image.winrains.cn/2019/08/62864-0a2ce874e9e8b25d524d2fe7b4da8770.jpeg"></p>
<ol>
<li>向服务器发送 HTTP 请求，请求被前端控制器 DispatcherServlet 捕获。</li>
<li>DispatcherServlet 根据 <strong>-servlet.xml</strong> 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以HandlerExecutionChain 对象的形式返回。</li>
<li>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的 preHandler(…)方法）。</li>
<li>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：</li>
</ol>
<ul>
<li>HttpMessageConveter： 将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。</li>
<li>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等。</li>
<li>数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。</li>
<li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中。</li>
</ul>
<ol>
<li>Handler(Controller)执行完成后，向 DispatcherServlet 返回一个ModelAndView 对象；</li>
<li>根据返回的ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的ViewResolver)返回给DispatcherServlet。</li>
<li>ViewResolver 结合Model和View，来渲染视图。</li>
<li>视图负责将渲染结果返回给客户端。</li>
</ol>
<h3 id="7-3-介绍一下-WebApplicationContext"><a href="#7-3-介绍一下-WebApplicationContext" class="headerlink" title="7.3. 介绍一下 WebApplicationContext"></a><strong>7.3. 介绍一下 WebApplicationContext</strong></h3><p>WebApplicationContext 是 ApplicationContext 的扩展。它具有 Web 应用程序所需的一些额外功能。它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。</p>
<blockquote>
<p>作者：51CTO</p>
<p>来源：<a href="http://developer.51cto.com/art/201808/580655.htm" target="_blank" rel="noopener">http://developer.51cto.com/art/201808/580655.htm</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/26/Spring%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%A3%B0%E6%98%8E%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%88%87%E9%9D%A2/" rel="prev" title="Spring使用注解式声明与使用切面">
      <i class="fa fa-chevron-left"></i> Spring使用注解式声明与使用切面
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/26/BeanFactory%E5%92%8CApplicationContext%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="next" title="BeanFactory和ApplicationContext的区别">
      BeanFactory和ApplicationContext的区别 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、一般问题"><span class="nav-number">1.</span> <span class="nav-text">1、一般问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-不同版本的-Spring-Framework-有哪些主要功能？"><span class="nav-number">1.1.</span> <span class="nav-text">1.1. 不同版本的 Spring Framework 有哪些主要功能？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-什么是-Spring-Framework？"><span class="nav-number">1.2.</span> <span class="nav-text">1.2. 什么是 Spring Framework？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-列举-Spring-Framework-的优点。"><span class="nav-number">1.3.</span> <span class="nav-text">1.3. 列举 Spring Framework 的优点。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-Spring-Framework-有哪些不同的功能？"><span class="nav-number">1.4.</span> <span class="nav-text">1.4. Spring Framework 有哪些不同的功能？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-Spring-Framework-中有多少个模块，它们分别是什么？"><span class="nav-number">1.5.</span> <span class="nav-text">1.5. Spring Framework 中有多少个模块，它们分别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-什么是-Spring-配置文件？"><span class="nav-number">1.6.</span> <span class="nav-text">1.6. 什么是 Spring 配置文件？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-Spring-应用程序有哪些不同组件？"><span class="nav-number">1.7.</span> <span class="nav-text">1.7. Spring 应用程序有哪些不同组件？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-使用-Spring-有哪些方式？"><span class="nav-number">1.8.</span> <span class="nav-text">1.8. 使用 Spring 有哪些方式？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、依赖注入（Ioc）"><span class="nav-number">2.</span> <span class="nav-text">2、依赖注入（Ioc）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-什么是-Spring-IOC-容器？"><span class="nav-number">2.1.</span> <span class="nav-text">2.1. 什么是 Spring IOC 容器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-什么是依赖注入？"><span class="nav-number">2.2.</span> <span class="nav-text">2.2. 什么是依赖注入？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-可以通过多少种方式完成依赖注入？"><span class="nav-number">2.3.</span> <span class="nav-text">2.3. 可以通过多少种方式完成依赖注入？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-区分构造函数注入和-setter-注入。"><span class="nav-number">2.4.</span> <span class="nav-text">2.4. 区分构造函数注入和 setter 注入。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-spring-中有多少种-IOC-容器？"><span class="nav-number">2.5.</span> <span class="nav-text">2.5. spring 中有多少种 IOC 容器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-区分-BeanFactory-和-ApplicationContext。"><span class="nav-number">2.6.</span> <span class="nav-text">2.6. 区分 BeanFactory 和 ApplicationContext。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-列举-IoC-的一些好处。"><span class="nav-number">2.7.</span> <span class="nav-text">2.7. 列举 IoC 的一些好处。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-Spring-IoC-的实现机制。"><span class="nav-number">2.8.</span> <span class="nav-text">2.8. Spring IoC 的实现机制。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Beans"><span class="nav-number">3.</span> <span class="nav-text">3. Beans</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-什么是-spring-bean？"><span class="nav-number">3.1.</span> <span class="nav-text">3.1. 什么是 spring bean？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-spring-提供了哪些配置方式？"><span class="nav-number">3.2.</span> <span class="nav-text">3.2. spring 提供了哪些配置方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-spring-支持集中-bean-scope？"><span class="nav-number">3.3.</span> <span class="nav-text">3.3. spring 支持集中 bean scope？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-spring-bean-容器的生命周期是什么样的？"><span class="nav-number">3.4.</span> <span class="nav-text">3.4. spring bean 容器的生命周期是什么样的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-什么是-spring-的内部-bean？"><span class="nav-number">3.5.</span> <span class="nav-text">3.5. 什么是 spring 的内部 bean？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-什么是-spring-装配？"><span class="nav-number">3.6.</span> <span class="nav-text">3.6. 什么是 spring 装配？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-自动装配有哪些方式？"><span class="nav-number">3.7.</span> <span class="nav-text">3.7. 自动装配有哪些方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-自动装配有什么局限？"><span class="nav-number">3.8.</span> <span class="nav-text">3.8. 自动装配有什么局限？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、注解"><span class="nav-number">4.</span> <span class="nav-text">4、注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-什么是基于注解的容器配置？"><span class="nav-number">4.1.</span> <span class="nav-text">4.1. 什么是基于注解的容器配置？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-如何在-spring-中启动注解装配？"><span class="nav-number">4.2.</span> <span class="nav-text">4.2. 如何在 spring 中启动注解装配？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-Component-Controller-Repository-Service-有何区别？"><span class="nav-number">4.3.</span> <span class="nav-text">4.3. @Component, @Controller, @Repository, @Service 有何区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-Required-注解有什么用？"><span class="nav-number">4.4.</span> <span class="nav-text">4.4. @Required 注解有什么用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-Autowired-注解有什么用？"><span class="nav-number">4.5.</span> <span class="nav-text">4.5. @Autowired 注解有什么用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-Qualifier-注解有什么用？"><span class="nav-number">4.6.</span> <span class="nav-text">4.6. @Qualifier 注解有什么用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-RequestMapping-注解有什么用？"><span class="nav-number">4.7.</span> <span class="nav-text">4.7. @RequestMapping 注解有什么用？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、数据访问"><span class="nav-number">5.</span> <span class="nav-text">5、数据访问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-spring-DAO-有什么用？"><span class="nav-number">5.1.</span> <span class="nav-text">5.1. spring DAO 有什么用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-列举-Spring-DAO-抛出的异常。"><span class="nav-number">5.2.</span> <span class="nav-text">5.2. 列举 Spring DAO 抛出的异常。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-spring-JDBC-API-中存在哪些类？"><span class="nav-number">5.3.</span> <span class="nav-text">5.3. spring JDBC API 中存在哪些类？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-使用-Spring-访问-Hibernate-的方法有哪些？"><span class="nav-number">5.4.</span> <span class="nav-text">5.4. 使用 Spring 访问 Hibernate 的方法有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-列举-spring-支持的事务管理类型"><span class="nav-number">5.5.</span> <span class="nav-text">5.5. 列举 spring 支持的事务管理类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-spring-支持哪些-ORM-框架？"><span class="nav-number">5.6.</span> <span class="nav-text">5.6. spring 支持哪些 ORM 框架？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、AOP"><span class="nav-number">6.</span> <span class="nav-text">6、AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-什么是-AOP？"><span class="nav-number">6.1.</span> <span class="nav-text">6.1. 什么是 AOP？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-什么是-Aspect？"><span class="nav-number">6.2.</span> <span class="nav-text">6.2. 什么是 Aspect？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-什么是切点（JoinPoint）"><span class="nav-number">6.3.</span> <span class="nav-text">6.3. 什么是切点（JoinPoint）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-什么是通知（Advice）？"><span class="nav-number">6.4.</span> <span class="nav-text">6.4. 什么是通知（Advice）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-有哪些类型的通知（Advice）？"><span class="nav-number">6.5.</span> <span class="nav-text">6.5. 有哪些类型的通知（Advice）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处"><span class="nav-number">6.6.</span> <span class="nav-text">6.6. 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-AOP-有哪些实现方式"><span class="nav-number">6.7.</span> <span class="nav-text">6.7. AOP 有哪些实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-8-Spring-AOP-and-AspectJ-AOP-有什么区别？"><span class="nav-number">6.8.</span> <span class="nav-text">6.8. Spring AOP and AspectJ AOP 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-9-如何理解-Spring-中的代理？"><span class="nav-number">6.9.</span> <span class="nav-text">6.9. 如何理解 Spring 中的代理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-10-什么是编织（Weaving）？"><span class="nav-number">6.10.</span> <span class="nav-text">6.10. 什么是编织（Weaving）？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、MVC"><span class="nav-number">7.</span> <span class="nav-text">7、MVC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-Spring-MVC-框架有什么用？"><span class="nav-number">7.1.</span> <span class="nav-text">7.1. Spring MVC 框架有什么用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-描述一下-DispatcherServlet-的工作流程"><span class="nav-number">7.2.</span> <span class="nav-text">7.2. 描述一下 DispatcherServlet 的工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-介绍一下-WebApplicationContext"><span class="nav-number">7.3.</span> <span class="nav-text">7.3. 介绍一下 WebApplicationContext</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">congsheng.wang</p>
  <div class="site-description" itemprop="description">trouble is a friend</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">807</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">91</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">141</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">congsheng.wang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
