<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://winrains.cn').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="Spring 的骨骼架构Spring 总共有十几个组件，但是真正核心的组件只有几个，下面是 Spring 框架的总体架构图： 图 1 .Spring 框架的总体架构图 从上图中可以看出 Spring 框架中的核心组件只有三个：Core、Context 和 Beans。它们构建起了整个 Spring 的骨骼架构。没有它们就不可能有 AOP、Web 等上层的特性功能。下面也将主要从这三个组件入手分析">
<meta name="keywords" content="设计模式">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring框架的设计理念与设计模式分析">
<meta property="og:url" content="http:&#x2F;&#x2F;winrains.cn&#x2F;2019&#x2F;12&#x2F;26&#x2F;Spring%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90&#x2F;index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="Spring 的骨骼架构Spring 总共有十几个组件，但是真正核心的组件只有几个，下面是 Spring 框架的总体架构图： 图 1 .Spring 框架的总体架构图 从上图中可以看出 Spring 框架中的核心组件只有三个：Core、Context 和 Beans。它们构建起了整个 Spring 的骨骼架构。没有它们就不可能有 AOP、Web 等上层的特性功能。下面也将主要从这三个组件入手分析">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;85a7c-image001.gif">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;d935d-image002.gif">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;73316-image003.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;ee2cc-image004.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;48cea-image005.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;d9893-origin_image006.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;ade75-origin_image007.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;e8449-image008.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;86f3d-origin_image009.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;d475a-origin_image010.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;99248-origin_image011.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;7df0a-origin_image012.gif">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;261b0-origin_image013.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;bc8a7-origin_image014.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;90e4d-image015.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;bce42-image016.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;c1dc5-image017.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;e89a0-image018.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;49225-image019.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;62c55-image020.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;9a290-image021.gif">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;26822-image022.png">
<meta property="og:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;8d793-image023.png">
<meta property="og:updated_time" content="2019-12-26T11:34:45.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;image.winrains.cn&#x2F;2019&#x2F;08&#x2F;85a7c-image001.gif">

<link rel="canonical" href="http://winrains.cn/2019/12/26/Spring%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Spring框架的设计理念与设计模式分析 | 个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">winrains的个人博客</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">70</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">42</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">209</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://winrains.cn/2019/12/26/Spring%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="winrains">
      <meta itemprop="description" content="淡泊明志">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring框架的设计理念与设计模式分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-26 19:34:45" itemprop="dateCreated datePublished" datetime="2019-12-26T19:34:45+08:00">2019-12-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">Spring技术</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring%E6%8A%80%E6%9C%AF/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Spring-的骨骼架构"><a href="#Spring-的骨骼架构" class="headerlink" title="Spring 的骨骼架构"></a>Spring 的骨骼架构</h1><p>Spring 总共有十几个组件，但是真正核心的组件只有几个，下面是 Spring 框架的总体架构图：</p>
<p>图 1 .Spring 框架的总体架构图</p>
<p><img src="http://image.winrains.cn/2019/08/85a7c-image001.gif" alt="图 1 .Spring 框架的总体架构图"><br>从上图中可以看出 Spring 框架中的核心组件只有三个：Core、Context 和 Beans。它们构建起了整个 Spring 的骨骼架构。没有它们就不可能有 AOP、Web 等上层的特性功能。下面也将主要从这三个组件入手分析 Spring。</p>
<a id="more"></a>

<h1 id="Spring-的设计理念"><a href="#Spring-的设计理念" class="headerlink" title="Spring 的设计理念"></a>Spring 的设计理念</h1><p>前面介绍了 Spring 的三个核心组件，如果再在它们三个中选出核心的话，那就非 Beans 组件莫属了，为何这样说，其实 Spring 就是面向 Bean 的编程（BOP,Bean Oriented Programming），Bean 在 Spring 中才是真正的主角。<br>Bean 在 Spring 中作用就像 Object 对 OOP 的意义一样，没有对象的概念就像没有面向对象编程，Spring 中没有 Bean 也就没有 Spring 存在的意义。就像一次演出舞台都准备好了但是却没有演员一样。为什么要 Bean 这种角色 Bean 或者为何在 Spring 如此重要，这由 Spring 框架的设计目标决定，Spring 为何如此流行，我们用 Spring 的原因是什么，想想你会发现原来 Spring 解决了一个非常关键的问题他可以让你把对象之间的依赖关系转而用配置文件来管理，也就是他的依赖注入机制。而这个注入关系在一个叫 Ioc 容器中管理，那 Ioc 容器就是被 Bean 包裹的对象。Spring 正是通过把对象包装在 Bean 中而达到对这些对象的管理以及一些列额外操作的目的。<br>它这种设计策略完全类似于 Java 实现 OOP 的设计理念，当然了 Java 本身的设计要比 Spring 复杂太多太多，但是都是构建一个数据结构，然后根据这个数据结构设计他的生存环境，并让它在这个环境中按照一定的规律在不停的运动，在它们的不停运动中设计一系列与环境或者与其他个体完成信息交换。这样想来我们用到的其他框架都是大慨类似的设计理念。</p>
<h1 id="核心组件如何协同工作"><a href="#核心组件如何协同工作" class="headerlink" title="核心组件如何协同工作"></a>核心组件如何协同工作</h1><p>前面说 Bean 是 Spring 中关键因素，那 Context 和 Core 又有何作用呢？前面把 Bean 比作一场演出中的演员的话，那 Context 就是这场演出的舞台背景，而 Core 应该就是演出的道具了。只有他们在一起才能具备演出一场好戏的最基本条件。当然有最基本的条件还不能使这场演出脱颖而出，还要他表演的节目足够的精彩，这些节目就是 Spring 能提供的特色功能了。<br>我们知道 Bean 包装的是 Object，而 Object 必然有数据，如何给这些数据提供生存环境就是 Context 要解决的问题，对 Context 来说他就是要发现每个 Bean 之间的关系，为它们建立这种关系并且要维护好这种关系。所以 Context 就是一个 Bean 关系的集合，这个关系集合又叫 Ioc 容器，一旦建立起这个 Ioc 容器后 Spring 就可以为你工作了。那 Core 组件又有什么用武之地呢？其实 Core 就是发现、建立和维护每个 Bean 之间的关系所需要的一些列的工具，从这个角度看来，Core 这个组件叫 Util 更能让你理解。<br>它们之间可以用下图来表示：</p>
<p>图 2. 三个组件关系</p>
<p><img src="http://image.winrains.cn/2019/08/d935d-image002.gif" alt="图 2. 三个组件关系"></p>
<h2 id="核心组件详解"><a href="#核心组件详解" class="headerlink" title="核心组件详解"></a>核心组件详解</h2><p>这里将详细介绍每个组件内部类的层次关系，以及它们在运行时的时序顺序。我们在使用 Spring 是应该注意的地方。</p>
<h3 id="Bean-组件"><a href="#Bean-组件" class="headerlink" title="Bean 组件"></a><strong>Bean 组件</strong></h3><p>前面已经说明了 Bean 组件对 Spring 的重要性，下面看看 Bean 这个组件式怎么设计的。Bean 组件在 Spring 的 <code>org.springframework.beans</code> 包下。这个包下的所有类主要解决了三件事：Bean 的定义、Bean 的创建以及对 Bean 的解析。对 Spring 的使用者来说唯一需要关心的就是 Bean 的创建，其他两个由 Spring 在内部帮你完成了，对你来说是透明的。<br>Spring Bean 的创建时典型的工厂模式，它的顶级接口是 BeanFactory，下图是这个工厂的继承层次关系：</p>
<p>图 4. Bean 工厂的继承关系</p>
<p><img src="http://image.winrains.cn/2019/08/73316-image003.png" alt="图 4. Bean 工厂的继承关系"><br>BeanFactory 有三个子类：ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory。但是从上图中我们可以发现最终的默认实现类是 DefaultListableBeanFactory，实现了所有的接口。那为何要定义这么多层次的接口呢？查阅这些接口的源码和说明发现，每个接口都有使用的场合，它主要是为了区分在 Spring 内部对象的传递和转化过程中，对对象的数据访问所做的限制。例如 ListableBeanFactory 接口表示这些 Bean 是可列表的，而 HierarchicalBeanFactory 表示的这些 Bean 是有继承关系的，也就是每个 Bean 有可能有父 Bean。AutowireCapableBeanFactory 接口定义 Bean 的自动装配规则。这四个接口共同定义了 Bean 的集合、Bean 之间的关系、以及 Bean 行为。<br>Bean 的定义主要有 BeanDefinition 描述，如下图说明了这些类的层次关系：</p>
<p>图 5. Bean 定义的类层次关系图</p>
<p><img src="http://image.winrains.cn/2019/08/ee2cc-image004.png" alt="图 5. Bean 定义的类层次关系图"><br>Bean 的定义就是完整的描述了在 Spring 的配置文件中你定义的 <code>节点中所有的信息，包括各种子节点。当 Spring 成功解析你定义的一个</code> 节点后，在 Spring 的内部就被转化成 BeanDefinition 对象。以后所有的操作都是对这个对象完成的。<br>Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean 的解析主要就是对 Spring 配置文件的解析。这个解析过程主要通过下图中的类完成：</p>
<p>图 6. Bean 的解析类</p>
<p><img src="http://image.winrains.cn/2019/08/48cea-image005.png" alt="图 6. Bean 的解析类"><br>当然还有具体对 tag 的解析这里并没有列出。</p>
<h3 id="Context-组件"><a href="#Context-组件" class="headerlink" title="Context 组件"></a><strong>Context 组件</strong></h3><p>Context 在 Spring 的 <code>org.springframework.context</code> 包下，前面已经讲解了 Context 组件在 Spring 中的作用，他实际上就是给 Spring 提供一个运行时的环境，用以保存各个对象的状态。下面看一下这个环境是如何构建的。<br>ApplicationContext 是 Context 的顶级父类，他除了能标识一个应用环境的基本信息外，他还继承了五个接口，这五个接口主要是扩展了 Context 的功能。下面是 Context 的类结构图：</p>
<p>图 7. Context 相关的类结构图</p>
<p><img src="http://image.winrains.cn/2019/08/d9893-origin_image006.png" alt="http://image.winrains.cn/2019/08/d9893-origin_image006.png"><br>从上图中可以看出 ApplicationContext 继承了 BeanFactory，这也说明了 Spring 容器中运行的主体对象是 Bean，另外 ApplicationContext 继承了 ResourceLoader 接口，使得 ApplicationContext 可以访问到任何外部资源，这将在 Core 中详细说明。<br>ApplicationContext 的子类主要包含两个方面：</p>
<ol>
<li>ConfigurableApplicationContext 表示该 Context 是可修改的，也就是在构建 Context 中用户可以动态添加或修改已有的配置信息，它下面又有多个子类，其中最经常使用的是可更新的 Context，即 AbstractRefreshableApplicationContext 类。</li>
<li>WebApplicationContext 顾名思义，就是为 web 准备的 Context 他可以直接访问到 ServletContext，通常情况下，这个接口使用的少。</li>
</ol>
<p>再往下分就是按照构建 Context 的文件类型，接着就是访问 Context 的方式。这样一级一级构成了完整的 Context 等级层次。<br>总体来说 ApplicationContext 必须要完成以下几件事：</p>
<ul>
<li>标识一个应用环境</li>
<li>利用 BeanFactory 创建 Bean 对象</li>
<li>保存对象关系表</li>
<li>能够捕获各种事件</li>
</ul>
<p>Context 作为 Spring 的 Ioc 容器，基本上整合了 Spring 的大部分功能，或者说是大部分功能的基础。</p>
<h3 id="Core-组件"><a href="#Core-组件" class="headerlink" title="Core 组件"></a><strong>Core 组件</strong></h3><p>Core 组件作为 Spring 的核心组件，他其中包含了很多的关键类，其中一个重要组成部分就是定义了资源的访问方式。这种把所有资源都抽象成一个接口的方式很值得在以后的设计中拿来学习。下面就重要看一下这个部分在 Spring 的作用。<br>下图是 Resource 相关的类结构图：</p>
<p>图 8. Resource 相关的类结构图</p>
<p><img src="http://image.winrains.cn/2019/08/ade75-origin_image007.png" alt="http://image.winrains.cn/2019/08/ade75-origin_image007.png"><br>从上图可以看出 Resource 接口封装了各种可能的资源类型，也就是对使用者来说屏蔽了文件类型的不同。对资源的提供者来说，如何把资源包装起来交给其他人用这也是一个问题，我们看到 Resource 接口继承了 InputStreamSource 接口，这个接口中有个 getInputStream 方法，返回的是 InputStream 类。这样所有的资源都被可以通过 InputStream 这个类来获取，所以也屏蔽了资源的提供者。另外还有一个问题就是加载资源的问题，也就是资源的加载者要统一，从上图中可以看出这个任务是由 ResourceLoader 接口完成，他屏蔽了所有的资源加载者的差异，只需要实现这个接口就可以加载所有的资源，他的默认实现是 DefaultResourceLoader。<br>下面看一下 Context 和 Resource 是如何建立关系的？首先看一下他们的类关系图：</p>
<p>图 9. Context 和 Resource 的类关系图</p>
<p><img src="http://image.winrains.cn/2019/08/e8449-image008.png" alt="图 9. Context 和 Resource 的类关系图"><br>从上图可以看出，Context 是把资源的加载、解析和描述工作委托给了 ResourcePatternResolver 类来完成，他相当于一个接头人，他把资源的加载、解析和资源的定义整合在一起便于其他组件使用。Core 组件中还有很多类似的方式。</p>
<h1 id="Ioc-容器如何工作"><a href="#Ioc-容器如何工作" class="headerlink" title="Ioc 容器如何工作"></a><strong>Ioc 容器如何工作</strong></h1><p>前面介绍了 Core 组件、Bean 组件和 Context 组件的结构与相互关系，下面这里从使用者角度看一下他们是如何运行的，以及我们如何让 Spring 完成各种功能，Spring 到底能有那些功能，这些功能是如何得来的，下面介绍。</p>
<h2 id="如何创建-BeanFactory-工厂"><a href="#如何创建-BeanFactory-工厂" class="headerlink" title="如何创建 BeanFactory 工厂"></a><strong>如何创建 BeanFactory 工厂</strong></h2><p>正如图 2 描述的那样，Ioc 容器实际上就是 Context 组件结合其他两个组件共同构建了一个 Bean 关系网，如何构建这个关系网？构建的入口就在 AbstractApplicationContext 类的 refresh 方法中。这个方法的代码如下：</p>
<p>清单 1. AbstractApplicationContext.refresh</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public void refresh<span class="literal">()</span> throws BeansException, IllegalStateException &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    synchronized (this.startupShutdownMonitor) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        prepare<span class="constructor">Refresh()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        ConfigurableListableBeanFactory beanFactory = obtain<span class="constructor">FreshBeanFactory()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        prepare<span class="constructor">BeanFactory(<span class="params">beanFactory</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            post<span class="constructor">ProcessBeanFactory(<span class="params">beanFactory</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            invoke<span class="constructor">BeanFactoryPostProcessors(<span class="params">beanFactory</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            register<span class="constructor">BeanPostProcessors(<span class="params">beanFactory</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Initialize message source for this context.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            init<span class="constructor">MessageSource()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            init<span class="constructor">ApplicationEventMulticaster()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            on<span class="constructor">Refresh()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            register<span class="constructor">Listeners()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            finish<span class="constructor">BeanFactoryInitialization(<span class="params">beanFactory</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            finish<span class="constructor">Refresh()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        catch (BeansException ex) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">            destroy<span class="constructor">Beans()</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Reset 'active' flag.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">            cancel<span class="constructor">Refresh(<span class="params">ex</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Propagate exception to caller.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">            throw ex;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个方法就是构建整个 Ioc 容器过程的完整的代码，了解了里面的每一行代码基本上就了解大部分 Spring 的原理和功能了。<br>这段代码主要包含这样几个步骤：</p>
<ul>
<li>构建 BeanFactory，以便于产生所需的“演员”</li>
<li>注册可能感兴趣的事件</li>
<li>创建 Bean 实例对象</li>
<li>触发被监听的事件</li>
</ul>
<p>下面就结合代码分析这几个过程。<br>第二三句就是在创建和配置 BeanFactory。这里是 refresh 也就是刷新配置，前面介绍了 Context 有可更新的子类，这里正是实现这个功能，当 BeanFactory 已存在是就更新，如果没有就新创建。下面是更新 BeanFactory 的方法代码：</p>
<p>清单 2. AbstractRefreshableApplicationContext. refreshBeanFactory</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        destroyBeans();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        closeBeanFactory();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        beanFactory.setSerializationId(getId());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        customizeBeanFactory(beanFactory);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        loadBeanDefinitions(beanFactory);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">this</span>.beanFactory = beanFactory;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            <span class="string">"I/O error parsing bean definition source for "</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            + getDisplayName(), ex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个方法实现了 <code>AbstractApplicationContext</code> 的抽象方法 <code>refreshBeanFactory</code>，这段代码清楚的说明了 <code>BeanFactory</code> 的创建过程。注意 <code>BeanFactory</code> 对象的类型的变化，前面介绍了他有很多子类，在什么情况下使用不同的子类这非常关键。<code>BeanFactory</code> 的原始对象是 <code>DefaultListableBeanFactory</code>，这个非常关键，因为他设计到后面对这个对象的多种操作，下面看一下这个类的继承层次类图：</p>
<p>图 10. DefaultListableBeanFactory 类继承关系图</p>
<p><img src="http://image.winrains.cn/2019/08/86f3d-origin_image009.png" alt="http://image.winrains.cn/2019/08/86f3d-origin_image009.png"><br>从这个图中发现除了 <code>BeanFactory</code> 相关的类外，还发现了与 Bean 的 register 相关。这在 <code>refreshBeanFactory</code> 方法中有一行 <code>loadBeanDefinitions(beanFactory)</code> 将找到答案，这个方法将开始加载、解析 Bean 的定义，也就是把用户定义的数据结构转化为 Ioc 容器中的特定数据结构。<br>这个过程可以用下面时序图解释：</p>
<p>图 11. 创建 BeanFactory 时序图</p>
<p><img src="http://image.winrains.cn/2019/08/d475a-origin_image010.png" alt="http://image.winrains.cn/2019/08/d475a-origin_image010.png"><br>Bean 的解析和登记流程时序图如下：</p>
<p>图 12. 解析和登记 Bean 对象时序图</p>
<p><img src="http://image.winrains.cn/2019/08/99248-origin_image011.png" alt="http://image.winrains.cn/2019/08/99248-origin_image011.png"><br>创建好 <code>BeanFactory</code> 后，接下去添加一些 Spring 本身需要的一些工具类，这个操作在 <code>AbstractApplicationContext</code> 的 <code>prepareBeanFactory</code> 方法完成。<br><code>AbstractApplicationContext</code> 中接下来的三行代码对 Spring 的功能扩展性起了至关重要的作用。前两行主要是让你现在可以对已经构建的 BeanFactory 的配置做修改，后面一行就是让你可以对以后再创建 Bean 的实例对象时添加一些自定义的操作。所以他们都是扩展了 Spring 的功能，所以我们要学习使用 Spring 必须对这一部分搞清楚。<br>其中在 <code>invokeBeanFactoryPostProcessors</code> 方法中主要是获取实现 <code>BeanFactoryPostProcessor</code> 接口的子类。并执行它的 <code>postProcessBeanFactory</code> 方法，这个方法的声明如下：</p>
<p>清单 3. BeanFactoryPostProcessor.postProcessBeanFactory</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">throws</span> BeansException;</span></pre></td></tr></table></figure>

<p>它的参数是 <code>beanFactory</code>，说明可以对 <code>beanFactory</code> 做修改，这里注意这个 <code>beanFactory</code> 是 <code>ConfigurableListableBeanFactory</code> 类型的，这也印证了前面介绍的不同 <code>BeanFactory</code> 所使用的场合不同，这里只能是可配置的 <code>BeanFactory</code>，防止一些数据被用户随意修改。<br><code>registerBeanPostProcessors</code> 方法也是可以获取用户定义的实现了 <code>BeanPostProcessor</code> 接口的子类，并执行把它们注册到 <code>BeanFactory</code> 对象中的 <code>beanPostProcessors</code> 变量中。<code>BeanPostProcessor</code> 中声明了两个方法：<code>postProcessBeforeInitialization</code>、<code>postProcessAfterInitialization</code> 分别用于在 Bean 对象初始化时执行。可以执行用户自定义的操作。<br>后面的几行代码是初始化监听事件和对系统的其他监听者的注册，监听者必须是 ApplicationListener 的子类。</p>
<h2 id="如何创建-Bean-实例并构建-Bean-的关系网"><a href="#如何创建-Bean-实例并构建-Bean-的关系网" class="headerlink" title="如何创建 Bean 实例并构建 Bean 的关系网"></a><strong>如何创建 Bean 实例并构建 Bean 的关系网</strong></h2><p>下面就是 Bean 的实例化代码，是从 <code>finishBeanFactoryInitialization</code> 方法开始的。</p>
<p>清单 4. AbstractApplicationContext.finishBeanFactoryInitialization</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> finishBeanFactoryInitialization(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    ConfigurableListableBeanFactory beanFactory) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    beanFactory.freezeConfiguration();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    beanFactory.preInstantiateSingletons();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>从上面代码中可以发现 Bean 的实例化是在 <code>BeanFactory</code> 中发生的。<code>preInstantiateSingletons</code> 方法的代码如下：</p>
<p>清单 5. DefaultListableBeanFactory.preInstantiateSingletons</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.logger.info(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (String beanName : <span class="keyword">this</span>.beanDefinitionNames) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                &amp;&amp; !bd.isLazyInit()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">final</span> FactoryBean factory =</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                        (FactoryBean) getBean(FACTORY_BEAN_PREFIX+ beanName);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">boolean</span> isEagerInit;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                        &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                        isEagerInit = AccessController.doPrivileged(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                            <span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                            <span class="keyword">public</span> <span class="function">Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                                <span class="keyword">return</span> ((SmartFactoryBean) factory).isEagerInit();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">                        &#125;, getAccessControlContext());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                        isEagerInit = factory <span class="keyword">instanceof</span> SmartFactoryBean</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                            &amp;&amp; ((SmartFactoryBean) factory).isEagerInit();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (isEagerInit) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">                        getBean(beanName);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">                    getBean(beanName);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里出现了一个非常重要的 Bean —— FactoryBean，可以说 Spring 一大半的扩展的功能都与这个 Bean 有关，这是个特殊的 Bean 是一个工厂 Bean，可以产生 Bean 的 Bean，这里的产生 Bean 是指 Bean 的实例，如果一个类继承 FactoryBean 用户只要实现他的 getObject 方法，就可以自己定义产生实例对象的方法。然而在 Spring 内部这个 Bean 的实例对象是 FactoryBean，通过调用这个对象的 getObject 方法就能获取用户自定义产生的对象，从而为 Spring 提供了很好的扩展性。Spring 获取 FactoryBean 本身的对象是在前面加上 &amp; 来完成的。<br>如何创建 Bean 的实例对象以及如何构建 Bean 实例对象之间的关联关系式 Spring 中的一个核心关键，下面是这个过程的流程图。</p>
<p>图 13.Bean 实例创建流程图</p>
<p><img src="http://image.winrains.cn/2019/08/7df0a-origin_image012.gif" alt="http://image.winrains.cn/2019/08/7df0a-origin_image012.gif"><br>如果是普通的 Bean 就直接创建他的实例，是通过调用 getBean 方法。下面是创建 Bean 实例的时序图：</p>
<p>图 14.Bean 实例创建时序图</p>
<p><img src="http://image.winrains.cn/2019/08/261b0-origin_image013.png" alt="http://image.winrains.cn/2019/08/261b0-origin_image013.png"><br>还有一个非常重要的部分就是建立 Bean 对象实例之间的关系，这也是 Spring 框架的核心竞争力，何时、如何建立他们之间的关系请看下面的时序图：</p>
<p>图 15.Bean 对象关系建立</p>
<p><img src="http://image.winrains.cn/2019/08/bc8a7-origin_image014.png" alt="http://image.winrains.cn/2019/08/bc8a7-origin_image014.png"></p>
<h2 id="Ioc-容器的扩展点"><a href="#Ioc-容器的扩展点" class="headerlink" title="Ioc 容器的扩展点"></a><strong>Ioc 容器的扩展点</strong></h2><p>现在还有一个问题就是如何让这些 Bean 对象有一定的扩展性，就是可以加入用户的一些操作。那么有哪些扩展点呢？ Spring 又是如何调用到这些扩展点的？<br>对 Spring 的 Ioc 容器来说，主要有这么几个。BeanFactoryPostProcessor， BeanPostProcessor。他们分别是在构建 BeanFactory 和构建 Bean 对象时调用。还有就是 InitializingBean 和 DisposableBean， 他们分别是在 Bean 实例创建和销毁时被调用。用户可以实现这些接口中定义的方法，Spring 就会在适当的时候调用他们。还有一个是 FactoryBean 他是个特殊的 Bean，这个 Bean 可以被用户更多的控制。<br>这些扩展点通常也是我们使用 Spring 来完成我们特定任务的地方，如何精通 Spring 就看你有没有掌握好 Spring 有哪些扩展点，并且如何使用他们，要知道如何使用他们就必须了解他们内在的机理。可以用下面一个比喻来解释。<br>我们把 Ioc 容器比作一个箱子，这个箱子里有若干个球的模子，可以用这些模子来造很多种不同的球，还有一个造这些球模的机器，这个机器可以产生球模。那么他们的对应关系就是：BeanFactory 是那个造球模的机器，球模就是 Bean，而球模造出来的球就是 Bean 的实例。那前面所说的几个扩展点又在什么地方呢？ BeanFactoryPostProcessor 对应到当造球模被造出来时，你将有机会可以对其做出适当的修正，也就是他可以帮你修改球模。而 InitializingBean 和 DisposableBean 是在球模造球的开始和结束阶段，你可以完成一些预备和扫尾工作。BeanPostProcessor 就可以让你对球模造出来的球做出适当的修正。最后还有一个 FactoryBean，它可是一个神奇的球模。这个球模不是预先就定型了，而是由你来给他确定它的形状，既然你可以确定这个球模型的形状，当然他造出来的球肯定就是你想要的球了，这样在这个箱子里你可以发现所有你想要的球。</p>
<h2 id="Ioc-容器如何为我所用"><a href="#Ioc-容器如何为我所用" class="headerlink" title="Ioc 容器如何为我所用"></a><strong>Ioc 容器如何为我所用</strong></h2><p>前面的介绍了 Spring 容器的构建过程，那 Spring 能为我们做什么，Spring 的 Ioc 容器又能做什么呢？我们使用 Spring 必须要首先构建 Ioc 容器，没有它 Spring 无法工作，ApplicatonContext.xml 就是 Ioc 容器的默认配置文件，Spring 的所有特性功能都是基于这个 Ioc 容器工作的，比如后面要介绍的 AOP。<br>Ioc 它实际上就是为你构建了一个魔方，Spring 为你搭好了骨骼架构，这个魔方到底能变出什么好的东西出来，这必须要有你的参与。那我们怎么参与？这就是前面说的要了解 Spring 中有哪些扩展点，我们通过实现那些扩展点来改变 Spring 的通用行为。至于如何实现扩展点来得到我们想要的个性结果，Spring 中有很多例子，其中 AOP 的实现就是 Spring 本身实现了其扩展点来达到了它想要的特性功能，可以拿来参考。</p>
<h1 id="Spring-中-AOP-特性详解"><a href="#Spring-中-AOP-特性详解" class="headerlink" title="Spring 中 AOP 特性详解"></a>Spring 中 AOP 特性详解</h1><h2 id="动态代理的实现原理"><a href="#动态代理的实现原理" class="headerlink" title="动态代理的实现原理"></a>动态代理的实现原理</h2><p>要了解 Spring 的 AOP 就必须先了解动态代理的原理，因为 AOP 就是基于动态代理实现的。动态代理还要从 JDK 本身说起。<br>在 Jdk 的 java.lang.reflect 包下有个 Proxy 类，它正是构造代理类的入口。这个类的结构入下：</p>
<p>图 16. Proxy 类结构</p>
<p><img src="http://image.winrains.cn/2019/08/90e4d-image015.png" alt="图 16. Proxy 类结构"><br>从上图发现最后面四个是公有方法。而最后一个方法 newProxyInstance 就是创建代理对象的方法。这个方法的源码如下：</p>
<p>清单 6. Proxy. newProxyInstance</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="keyword">new</span><span class="type">ProxyInstance</span>(ClassLoader loader,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    Class&lt;?&gt;[] interfaces,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    InvocationHandler h)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    throws IllegalArgumentException &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (h == <span class="literal">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NullPointerException</span>();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    Class cl = getProxyClass(loader, interfaces);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        Constructor cons = cl.getConstructor(constructorParams);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> (Object) cons.<span class="keyword">new</span><span class="type">Instance</span>(<span class="keyword">new</span> <span class="type">Object</span>[] &#123; h &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InternalError</span>(e.toString());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InternalError</span>(e.toString());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InternalError</span>(e.toString());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InternalError</span>(e.toString());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个方法需要三个参数：ClassLoader，用于加载代理类的 Loader 类，通常这个 Loader 和被代理的类是同一个 Loader 类。Interfaces，是要被代理的那些那些接口。InvocationHandler，就是用于执行除了被代理接口中方法之外的用户自定义的操作，他也是用户需要代理的最终目的。用户调用目标方法都被代理到 InvocationHandler 类中定义的唯一方法 invoke 中。这在后面再详解。<br>下面还是看看 Proxy 如何产生代理类的过程，他构造出来的代理类到底是什么样子？下面揭晓啦。</p>
<p>图 17. 创建代理对象时序图</p>
<p><img src="http://image.winrains.cn/2019/08/bce42-image016.png" alt="图 17. 创建代理对象时序图"><br>其实从上图中可以发现正在构造代理类的是在 <code>ProxyGenerator</code> 的 <code>generateProxyClass</code> 的方法中。<code>ProxyGenerator</code> 类在 <code>sun.misc</code> 包下，感兴趣的话可以看看他的源码。<br>假如有这样一个接口，如下：</p>
<p>清单 7. SimpleProxy 类</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>SimpleProxy &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    public void simpleMethod1();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    public void simpleMethod2();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>代理来生成的类结构如下：</p>
<p>清单 8. $Proxy2 类</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy2</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">reflect</span>.<span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">SimpleProxy</span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    java.lang.reflect<span class="function">.<span class="keyword">Method</span> <span class="title">m0</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    java.lang.reflect<span class="function">.<span class="keyword">Method</span> <span class="title">m1</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    java.lang.reflect<span class="function">.<span class="keyword">Method</span> <span class="title">m2</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    java.lang.reflect<span class="function">.<span class="keyword">Method</span> <span class="title">m3</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    java.lang.reflect<span class="function">.<span class="keyword">Method</span> <span class="title">m4</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    int hashCode();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    boolean equals(java.lang.Object);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    java.lang.String toString();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    void simpleMethod1();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    void simpleMethod2();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个类中的方法里面将会是调用 <code>InvocationHandler</code> 的 <code>invoke</code> 方法，而每个方法也将对应一个属性变量，这个属性变量 <code>m</code> 也将传给 <code>invoke</code> 方法中的 <code>Method</code> 参数。整个代理就是这样实现的。</p>
<h2 id="Spring-AOP-如何实现"><a href="#Spring-AOP-如何实现" class="headerlink" title="Spring AOP 如何实现"></a>Spring AOP 如何实现</h2><p>从前面代理的原理我们知道，代理的目的是调用目标方法时我们可以转而执行 <code>InvocationHandler</code> 类的 <code>invoke</code> 方法，所以如何在 <code>InvocationHandler</code> 上做文章就是 Spring 实现 Aop 的关键所在。<br>Spring 的 Aop 实现是遵守 Aop 联盟的约定。同时 Spring 又扩展了它，增加了如 Pointcut、Advisor 等一些接口使得更加灵活。<br>下面是 Jdk 动态代理的类图：</p>
<p>图 18. Jdk 动态代理的类图</p>
<p><img src="http://image.winrains.cn/2019/08/c1dc5-image017.png" alt="图 18. Jdk 动态代理的类图"><br>上图清楚的显示了 Spring 引用了 Aop Alliance 定义的接口。姑且不讨论 Spring 如何扩展 Aop Alliance，先看看 Spring 如何实现代理类的，要实现代理类在 Spring 的配置文件中通常是这样定一个 Bean 的，如下：</p>
<p>清单 9. 配置代理类 Bean</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"testBeanSingleton"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    &lt;property name=<span class="string">"proxyInterfaces"</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        &lt;value&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            org.springframework.aop.framework.PrototypeTargetTests$TestBean</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        &lt;<span class="regexp">/value&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    &lt;/</span>property&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &lt;property name=<span class="string">"target"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"testBeanTarget"</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &lt;property name=<span class="string">"singleton"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &lt;property name=<span class="string">"interceptorNames"</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &lt;list&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            &lt;value&gt;testInterceptor&lt;<span class="regexp">/value&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">            &lt;value&gt;testInterceptor2&lt;/</span>value&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &lt;<span class="regexp">/list&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    &lt;/</span>property&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&lt;<span class="regexp">/bean&gt;</span></span></pre></td></tr></table></figure>

<p>配置上看到要设置被代理的接口，和接口的实现类也就是目标类，以及拦截器也就在执行目标方法之前被调用，这里 Spring 中定义的各种各样的拦截器，可以选择使用。<br>下面看看 Spring 如何完成了代理以及是如何调用拦截器的。<br>前面提到 Spring Aop 也是实现其自身的扩展点来完成这个特性的，从这个代理类可以看出它正是继承了 FactoryBean 的 ProxyFactoryBean，FactoryBean 之所以特别就在于它可以让你自定义对象的创建方法。当然代理对象要通过 Proxy 类来动态生成。<br>下面是 Spring 创建的代理对象的时序图：</p>
<p>图 19.Spring 代理对象的产生</p>
<p><img src="http://image.winrains.cn/2019/08/e89a0-image018.png" alt="图 19.Spring 代理对象的产生"><br>Spring 创建了代理对象后，当你调用目标对象上的方法时，将都会被代理到 <code>InvocationHandler</code> 类的 <code>invoke</code> 方法中执行，这在前面已经解释。在这里 <code>JdkDynamicAopProxy</code> 类实现了 <code>InvocationHandler</code> 接口。<br>下面再看看 Spring 是如何调用拦截器的，下面是这个过程的时序图：</p>
<p>图 20.Spring 调用拦截器</p>
<p><img src="http://image.winrains.cn/2019/08/49225-image019.png" alt="图 20.Spring 调用拦截器"><br>以上所说的都是 Jdk 动态代理，Spring 还支持一种 CGLIB 类代理，感兴趣自己看吧。</p>
<h1 id="Spring-中设计模式分析"><a href="#Spring-中设计模式分析" class="headerlink" title="Spring 中设计模式分析"></a>Spring 中设计模式分析</h1><p>Spring 中使用的设计模式也很多，比如工厂模式、单例模式、模版模式等，在《 Webx 框架的系统架构与设计模式》、《 Tomcat 的系统架构与模式设计分析》已经有介绍，这里就不赘述了。这里主要介绍代理模式和策略模式。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="代理模式原理"><a href="#代理模式原理" class="headerlink" title="代理模式原理"></a><strong>代理模式原理</strong></h3><p>代理模式就是给某一个对象创建一个代理对象，而由这个代理对象控制对原对象的引用，而创建这个代理对象就是可以在调用原对象时增加一些额外的操作。下面是代理模式的结构：</p>
<p>图 21. 代理模式的结构</p>
<p><img src="http://image.winrains.cn/2019/08/62c55-image020.png" alt="图 21. 代理模式的结构"></p>
<ul>
<li>Subject：抽象主题，它是代理对象的真实对象要实现的接口，当然这可以由多个接口组成。</li>
<li>ProxySubject：代理类除了实现抽象主题定义的接口外，还必须持有所代理对象的引用</li>
<li>RealSubject：被代理的类，是目标对象。</li>
</ul>
<h3 id="Spring-中如何实现代理模式"><a href="#Spring-中如何实现代理模式" class="headerlink" title="Spring 中如何实现代理模式"></a><strong>Spring 中如何实现代理模式</strong></h3><p>Spring Aop 中 Jdk 动态代理就是利用代理模式技术实现的。在 Spring 中除了实现被代理对象的接口外，还会有 <code>org.springframework.aop.SpringProxy</code> 和 <code>org.springframework.aop.framework.Advised</code> 两个接口。Spring 中使用代理模式的结构图如下：</p>
<p>图 22. Spring 中使用代理模式的结构图</p>
<p><img src="http://image.winrains.cn/2019/08/9a290-image021.gif" alt="图 22. Spring 中使用代理模式的结构图"><br><code>$Proxy</code> 就是创建的代理对象，而 <code>Subject</code> 是抽象主题，代理对象是通过 <code>InvocationHandler</code> 来持有对目标对象的引用的。<br>Spring 中一个真实的代理对象结构如下：</p>
<p>清单 10 代理对象 $Proxy4</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public class $Proxy4 <span class="keyword">extends </span><span class="keyword">java.lang.reflect.Proxy </span>implements</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">org.springframework.aop.framework.PrototypeTargetTests$TestBean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword"> </span>   <span class="keyword">org.springframework.aop.SpringProxy</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword"> </span>   <span class="keyword">org.springframework.aop.framework.Advised </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m16;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m9;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m25;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m5;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m23;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m18;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m26;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m6;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m28;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m14;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m12;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m27;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m11;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m22;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m3;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m8;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m4;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m19;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m7;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m15;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m20;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m10;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m17;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m21;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m13;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.reflect.Method </span>m24;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    int hashCode();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    int indexOf(<span class="keyword">org.springframework.aop.Advisor);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"><span class="keyword"> </span>   int indexOf(<span class="keyword">org.aopalliance.aop.Advice);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="keyword"> </span>   <span class="keyword">boolean </span>equals(<span class="keyword">java.lang.Object);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="keyword"> </span>   <span class="keyword">java.lang.String </span>toString();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    void sayhello();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    void doSomething();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    void doSomething2();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.Class </span>getProxiedInterfaces();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">java.lang.Class </span>getTargetClass();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">boolean </span>isProxyTargetClass();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">org.springframework.aop.Advisor; </span>getAdvisors();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    void <span class="keyword">addAdvisor(int, </span><span class="keyword">org.springframework.aop.Advisor)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line"><span class="keyword"> </span>       throws <span class="keyword">org.springframework.aop.framework.AopConfigException;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"><span class="keyword"> </span>   void <span class="keyword">addAdvisor(org.springframework.aop.Advisor)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line"><span class="keyword"> </span>       throws <span class="keyword">org.springframework.aop.framework.AopConfigException;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line"><span class="keyword"> </span>   void setTargetSource(<span class="keyword">org.springframework.aop.TargetSource);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"><span class="keyword"> </span>   <span class="keyword">org.springframework.aop.TargetSource </span>getTargetSource();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">    void setPreFiltered(<span class="keyword">boolean);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line"><span class="keyword"> </span>   <span class="keyword">boolean </span>isPreFiltered();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">boolean </span>isInterfaceProxied(<span class="keyword">java.lang.Class);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line"><span class="keyword"> </span>   <span class="keyword">boolean </span>removeAdvisor(<span class="keyword">org.springframework.aop.Advisor);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line"><span class="keyword"> </span>   void removeAdvisor(int)throws <span class="keyword">org.springframework.aop.framework.AopConfigException;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line"><span class="keyword"> </span>   <span class="keyword">boolean </span>replaceAdvisor(<span class="keyword">org.springframework.aop.Advisor,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line"><span class="keyword"> </span>       <span class="keyword">org.springframework.aop.Advisor)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line"><span class="keyword"> </span>       throws <span class="keyword">org.springframework.aop.framework.AopConfigException;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line"><span class="keyword"> </span>   void <span class="keyword">addAdvice(org.aopalliance.aop.Advice)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line"><span class="keyword"> </span>       throws <span class="keyword">org.springframework.aop.framework.AopConfigException;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line"><span class="keyword"> </span>   void <span class="keyword">addAdvice(int, </span><span class="keyword">org.aopalliance.aop.Advice)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line"><span class="keyword"> </span>       throws <span class="keyword">org.springframework.aop.framework.AopConfigException;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line"><span class="keyword"> </span>   <span class="keyword">boolean </span>removeAdvice(<span class="keyword">org.aopalliance.aop.Advice);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line"><span class="keyword"> </span>   <span class="keyword">java.lang.String </span>toProxyConfigString();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">boolean </span>isFrozen();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">    void setExposeProxy(<span class="keyword">boolean);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line"><span class="keyword"> </span>   <span class="keyword">boolean </span>isExposeProxy();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="策略模式原理"><a href="#策略模式原理" class="headerlink" title="策略模式原理"></a><strong>策略模式原理</strong></h3><p>策略模式顾名思义就是做某事的策略，这在编程上通常是指完成某个操作可能有多种方法，这些方法各有千秋，可能有不同的适应的场合，然而这些操作方法都有可能用到。各一个操作方法都当作一个实现策略，使用者可能根据需要选择合适的策略。<br>下面是策略模式的结构：</p>
<p>图 23. 策略模式的结构</p>
<p><img src="http://image.winrains.cn/2019/08/26822-image022.png" alt="图 23. 策略模式的结构"></p>
<ul>
<li>Context：使用不同策略的环境，它可以根据自身的条件选择不同的策略实现类来完成所要的操作。它持有一个策略实例的引用。创建具体策略对象的方法也可以由他完成。</li>
<li>Strategy：抽象策略，定义每个策略都要实现的策略方法</li>
<li>ConcreteStrategy：具体策略实现类，实现抽象策略中定义的策略方法</li>
</ul>
<h3 id="Spring-中策略模式的实现"><a href="#Spring-中策略模式的实现" class="headerlink" title="Spring 中策略模式的实现"></a><strong>Spring 中策略模式的实现</strong></h3><p>Spring 中策略模式使用有多个地方，如 Bean 定义对象的创建以及代理对象的创建等。这里主要看一下代理对象创建的策略模式的实现。<br>前面已经了解 Spring 的代理方式有两个 Jdk 动态代理和 CGLIB 代理。这两个代理方式的使用正是使用了策略模式。它的结构图如下所示：</p>
<p>图 24. Spring 中策略模式结构图</p>
<p><img src="http://image.winrains.cn/2019/08/8d793-image023.png" alt="图 24. Spring 中策略模式结构图"><br>在上面结构图中与标准的策略模式结构稍微有点不同，这里抽象策略是 <code>AopProxy</code> 接口，<code>Cglib2AopProxy</code> 和 <code>JdkDynamicAopProxy</code> 分别代表两种策略的实现方式，<code>ProxyFactoryBean</code> 就是代表 <code>Context</code> 角色，它根据条件选择使用 Jdk 代理方式还是 CGLIB 方式，而另外三个类主要是来负责创建具体策略对象，<code>ProxyFactoryBean</code> 是通过依赖的方法来关联具体策略对象的，它是通过调用策略对象的 <code>getProxy(ClassLoader classLoader)</code> 方法来完成操作。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>本文通过从 Spring 的几个核心组件入手，试图找出构建 Spring 框架的骨骼架构，进而分析 Spring 在设计时的一些设计理念，是否从中找出一些好的设计思想，对我们以后程序设计能提供一些思路。接着再详细分析了 Spring 中是如何实现这些理念的，以及在设计模式上是如何使用的。<br>通过分析 Spring 给我一个很大的启示就是这套设计理念其实对我们有很强的借鉴意义，它通过抽象复杂多变的对象，进一步做规范，然后根据它定义的这套规范设计出一个容器，容器中构建它们的复杂关系，其实现在有很多情况都可以用这种类似的处理方法。<br>虽然我很想把我对 Spring 的理解完全阐述清楚，但是所谓“书不尽言，言不尽意”。，有什么不对或者不清楚的地方大家还是看看其源码吧。</p>
<blockquote>
<p>作者：许令波</p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag"># 设计模式</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/26/Spring-%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/" rel="prev" title="Spring 框架简介">
      <i class="fa fa-chevron-left"></i> Spring 框架简介
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/26/SimpleDateFormat%E5%AE%89%E5%85%A8%E7%9A%84%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96/" rel="next" title="SimpleDateFormat安全的时间格式化">
      SimpleDateFormat安全的时间格式化 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-的骨骼架构"><span class="nav-number">1.</span> <span class="nav-text">Spring 的骨骼架构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-的设计理念"><span class="nav-number">2.</span> <span class="nav-text">Spring 的设计理念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#核心组件如何协同工作"><span class="nav-number">3.</span> <span class="nav-text">核心组件如何协同工作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#核心组件详解"><span class="nav-number">3.1.</span> <span class="nav-text">核心组件详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bean-组件"><span class="nav-number">3.1.1.</span> <span class="nav-text">Bean 组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Context-组件"><span class="nav-number">3.1.2.</span> <span class="nav-text">Context 组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Core-组件"><span class="nav-number">3.1.3.</span> <span class="nav-text">Core 组件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ioc-容器如何工作"><span class="nav-number">4.</span> <span class="nav-text">Ioc 容器如何工作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#如何创建-BeanFactory-工厂"><span class="nav-number">4.1.</span> <span class="nav-text">如何创建 BeanFactory 工厂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何创建-Bean-实例并构建-Bean-的关系网"><span class="nav-number">4.2.</span> <span class="nav-text">如何创建 Bean 实例并构建 Bean 的关系网</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ioc-容器的扩展点"><span class="nav-number">4.3.</span> <span class="nav-text">Ioc 容器的扩展点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ioc-容器如何为我所用"><span class="nav-number">4.4.</span> <span class="nav-text">Ioc 容器如何为我所用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-中-AOP-特性详解"><span class="nav-number">5.</span> <span class="nav-text">Spring 中 AOP 特性详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#动态代理的实现原理"><span class="nav-number">5.1.</span> <span class="nav-text">动态代理的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-AOP-如何实现"><span class="nav-number">5.2.</span> <span class="nav-text">Spring AOP 如何实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-中设计模式分析"><span class="nav-number">6.</span> <span class="nav-text">Spring 中设计模式分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#代理模式"><span class="nav-number">6.1.</span> <span class="nav-text">代理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代理模式原理"><span class="nav-number">6.1.1.</span> <span class="nav-text">代理模式原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-中如何实现代理模式"><span class="nav-number">6.1.2.</span> <span class="nav-text">Spring 中如何实现代理模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#策略模式"><span class="nav-number">6.2.</span> <span class="nav-text">策略模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#策略模式原理"><span class="nav-number">6.2.1.</span> <span class="nav-text">策略模式原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-中策略模式的实现"><span class="nav-number">6.2.2.</span> <span class="nav-text">Spring 中策略模式的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结束语"><span class="nav-number">7.</span> <span class="nav-text">结束语</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">winrains</p>
  <div class="site-description" itemprop="description">淡泊明志</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">209</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">70</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">winrains</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
